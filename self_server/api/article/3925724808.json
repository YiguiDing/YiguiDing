{"shortInfo":{"title":"设计模式学习笔记(TypeScript版)","date":"2023-01-10T21:21:00.000Z","cover":"\\self_server\\assets\\images\\2022-12-04-01-27-26.png","tags":["笔记"],"categories":"笔记","id":3925724808,"countWords":7030,"readSeconds":703,"assetsbaseUrl":"/self_server/assets/"},"content":"# 设计模式学习笔记(TypeScript版)\r\n\r\n## 目录\r\n\r\n- [设计模式学习笔记(TypeScript版)](#设计模式学习笔记typescript版)\r\n\t- [目录](#目录)\r\n\t- [创建型:\\_1\\_工厂方法模式](#创建型_1_工厂方法模式)\r\n\t- [创建型:\\_2\\_抽象方法模式](#创建型_2_抽象方法模式)\r\n\t- [创建型:\\_3\\_单例模式](#创建型_3_单例模式)\r\n\t- [创建型:\\_4\\_建造者模式](#创建型_4_建造者模式)\r\n\t- [创建型:\\_5\\_原型模式](#创建型_5_原型模式)\r\n\t- [结构型:\\_6\\_适配器模式](#结构型_6_适配器模式)\r\n\t\t- [对象适配器模式](#对象适配器模式)\r\n\t\t- [类适配器模式](#类适配器模式)\r\n\t- [结构型:\\_7\\_桥接模式](#结构型_7_桥接模式)\r\n\t- [结构型:\\_8\\_组合模式](#结构型_8_组合模式)\r\n\t- [结构型:\\_9\\_装饰器](#结构型_9_装饰器)\r\n\t- [结构型:\\_10\\_外观模式](#结构型_10_外观模式)\r\n\t- [结构型:\\_11\\_享元模式](#结构型_11_享元模式)\r\n\t- [结构型:\\_12\\_代理模式](#结构型_12_代理模式)\r\n\t- [行为型:\\_13\\_责任链模式](#行为型_13_责任链模式)\r\n\t- [行为型:\\_14\\_命令模式](#行为型_14_命令模式)\r\n\t- [行为型:\\_15\\_解释器模式](#行为型_15_解释器模式)\r\n\t- [行为型:\\_16\\_迭代器模式](#行为型_16_迭代器模式)\r\n\t- [行为型:\\_17\\_中介者模式](#行为型_17_中介者模式)\r\n\t- [行为型:\\_18\\_备忘录模式](#行为型_18_备忘录模式)\r\n\t- [行为型:\\_19\\_观察者模式](#行为型_19_观察者模式)\r\n\t- [行为型:\\_20\\_状态模式](#行为型_20_状态模式)\r\n\t- [行为型:\\_21\\_策略模式](#行为型_21_策略模式)\r\n\t- [行为型:\\_22\\_模板方法模式](#行为型_22_模板方法模式)\r\n\t- [行为型:\\_23\\_访问者](#行为型_23_访问者)\r\n\r\n## 创建型:_1_工厂方法模式\r\n\r\n```ts\r\n// 抽象动物\r\nabstract class Animal {\r\n\tabstract getName(): string;\r\n\tabstract getAge(): number;\r\n}\r\n// 抽象动物工厂\r\nabstract class AnimalFactory {\r\n\tabstract getAnimal(): Animal;\r\n}\r\n// 具体动物工厂，继承抽象动物工厂\r\nclass RandomAnimalFactory extends AnimalFactory {\r\n\t// 工厂负责封装创建的逻辑，比如这里封装的是随机产生动物的逻辑\r\n\t// 它的另一个优点是在动物的构造函数参数很多时，将产品的创建和使用解耦\r\n\tgetAnimal(): Animal {\r\n\t\tswitch (Math.floor(Math.random() * 2)) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn new Dog(\"Fido\", 12);\r\n\t\t\tcase 1:\r\n\t\t\t\treturn new Cat(\"Garfield\", 15);\r\n\t\t\tdefault:\r\n\t\t\t\treturn new Dog(\"Unknown\", 12);\r\n\t\t}\r\n\t}\r\n}\r\n// 具体动物类，继承抽象动物\r\nclass Dog extends Animal {\r\n\tconstructor(private name: string, private age: number) {\r\n\t\tsuper();\r\n\t\tthis.name = name;\r\n\t\tthis.age = age;\r\n\t}\r\n\tgetName(): string {\r\n\t\treturn this.name;\r\n\t}\r\n\tgetAge(): number {\r\n\t\treturn this.age;\r\n\t}\r\n}\r\n// 具体动物类，继承抽象动物\r\nclass Cat extends Animal {\r\n\tconstructor(private name: string, private age: number) {\r\n\t\tsuper();\r\n\r\n\t\tthis.name = name;\r\n\t\tthis.age = age;\r\n\t}\r\n\tgetName(): string {\r\n\t\treturn this.name;\r\n\t}\r\n\tgetAge(): number {\r\n\t\treturn this.age;\r\n\t}\r\n}\r\n\r\n\r\nfunction main() {\r\n\tlet animal = new RandomAnimalFactory().getAnimal();\r\n\tconsole.log(animal.getName());\r\n}\r\n\r\nmain();\r\n\r\n```\r\n\r\n## 创建型:_2_抽象方法模式\r\n\r\n```ts\r\n// 抽象按钮组件\r\nabstract class ComponentButton {\r\n\tabstract getName(): string;\r\n}\r\n// 抽象消息框组件\r\nabstract class ComponentMessageBox {\r\n\tabstract getName(): string;\r\n}\r\n\r\n// 抽象UI工厂\r\n// 后续将实现实际工厂类A,用能创建实际按钮类a1和实际消息框类a2,他们是一组互相兼容的组件\r\n// 后续将实现实际工厂类B,用能创建实际按钮类b1和实际消息框类b2,他们是一组互相兼容的组件\r\n// 后续将实现实际工厂类C,用能创建实际按钮类c1和实际消息框类c2,他们是一组互相兼容的组件\r\nabstract class UIFactory {\r\n\tabstract getComponentButton(): ComponentButton;\r\n\tabstract getComponentMessageBox(): ComponentMessageBox;\r\n}\r\n\r\nclass MacOsButton extends ComponentButton {\r\n\tgetName(): string {\r\n\t\treturn \"MacOsButton\";\r\n\t}\r\n}\r\nclass MacOsMessageBox extends ComponentMessageBox {\r\n\tgetName(): string {\r\n\t\treturn \"MacOsMessageBox\";\r\n\t}\r\n}\r\nclass WindowsButton extends ComponentButton {\r\n\tgetName(): string {\r\n\t\treturn \"WindowsButton\";\r\n\t}\r\n}\r\nclass WindowsMessageBox extends ComponentMessageBox {\r\n\tgetName(): string {\r\n\t\treturn \"WindowsMessageBox\";\r\n\t}\r\n}\r\nclass LinuxButton extends ComponentButton {\r\n\tgetName(): string {\r\n\t\treturn \"LinuxButton\";\r\n\t}\r\n}\r\nclass LinuxMessageBox extends ComponentMessageBox {\r\n\tgetName(): string {\r\n\t\treturn \"LinuxMessageBox\";\r\n\t}\r\n}\r\n\r\nclass MacOsUIFactory extends UIFactory {\r\n\tgetComponentButton(): ComponentButton {\r\n\t\treturn new MacOsButton();\r\n\t}\r\n\tgetComponentMessageBox(): ComponentMessageBox {\r\n\t\treturn new MacOsMessageBox();\r\n\t}\r\n}\r\n\r\nclass WindowsUIFactory extends UIFactory {\r\n\tgetComponentButton(): ComponentButton {\r\n\t\treturn new WindowsButton();\r\n\t}\r\n\tgetComponentMessageBox(): ComponentMessageBox {\r\n\t\treturn new WindowsMessageBox();\r\n\t}\r\n}\r\n\r\nclass LinuxUIFactory extends UIFactory {\r\n\tgetComponentButton(): ComponentButton {\r\n\t\treturn new LinuxButton();\r\n\t}\r\n\tgetComponentMessageBox(): ComponentMessageBox {\r\n\t\treturn new LinuxMessageBox();\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\t// let factory = new MacOsUIFactory();\t\t// Mac OS UI\r\n\t// let factory = new WindowsUIFactory();\t// Windows UI\r\n\tlet factory = new LinuxUIFactory(); // Linux UI\r\n\r\n\tlet componentButton = factory.getComponentButton();\r\n\tlet componentMessageBox = factory.getComponentMessageBox();\r\n\r\n\tconsole.log(componentButton.getName());\r\n\tconsole.log(componentMessageBox.getName());\r\n}\r\n\r\nmain();\r\n\r\n```\r\n\r\n## 创建型:_3_单例模式\r\n\r\n```ts\r\n// 单例模式保证类只被实例化一次，防止只需要一个实例对象但却被重复实例化，浪费资源\r\nclass ImgDog extends HTMLImageElement {\r\n\t// 私有化构造方法\r\n\tprivate constructor() {\r\n\t\tsuper();\r\n\t}\r\n\t// 私有静态属性\r\n\tprivate static INSTANCE = new ImgDog();\r\n\t// 静态代码块\r\n\tstatic {\r\n\t\tImgDog.INSTANCE.src = \"image.png\"; // 初始化\r\n\t}\r\n\t// 静态方法，获取img实例\r\n\tpublic static getInstance(): HTMLImageElement {\r\n\t\treturn ImgDog.INSTANCE;\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tconst imgDog1 = ImgDog.getInstance();\r\n\tconst imgDog2 = ImgDog.getInstance();\r\n\tconsole.log(imgDog1 == imgDog2);\r\n}\r\n\r\nmain();\r\n```\r\n\r\n## 创建型:_4_建造者模式\r\n\r\n```ts\r\n// 车架\r\nclass Frame {\r\n\tname: string;\r\n\tconstructor(name: string) {\r\n\t\tthis.name = name;\r\n\t}\r\n}\r\n// 车座\r\nclass Seat {\r\n\tname: string;\r\n\tconstructor(name: string) {\r\n\t\tthis.name = name;\r\n\t}\r\n}\r\n\r\n// 自行车\r\nclass Bike {\r\n\tprivate Brand: string;\r\n\tprivate frame: Frame;\r\n\tprivate seat: Seat;\r\n\tsetBrand(name: string) {\r\n\t\tthis.Brand = name;\r\n\t}\r\n\tsetFrame(frame: Frame) {\r\n\t\tthis.frame = frame;\r\n\t}\r\n\tsetSeat(seat: Seat) {\r\n\t\tthis.seat = seat;\r\n\t}\r\n}\r\n\r\n// 自行车建造者\r\nabstract class BikeBuidler {\r\n\tbike = new Bike();\r\n\tabstract buildFrame(): void;\r\n\tabstract buildSeat(): void;\r\n\tabstract getResult(): Bike;\r\n}\r\n\r\n// 指挥者，指挥建造者\r\nclass Director {\r\n\tconstructor(private bikeBuilder: BikeBuidler) {\r\n\t\tthis.bikeBuilder = bikeBuilder;\r\n\t}\r\n\tconstruct(): Bike {\r\n\t\tthis.bikeBuilder.buildFrame();\r\n\t\tthis.bikeBuilder.buildSeat();\r\n\t\treturn this.bikeBuilder.getResult();\r\n\t}\r\n}\r\n\r\n// ofo 自行车的建造者\r\nclass OfoBikeBuilder extends BikeBuidler {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.bike.setBrand(\"Ofo Bike\"); // 设置品牌\r\n\t}\r\n\tbuildFrame(): void {\r\n\t\tthis.bike.setFrame(new Frame(\"铝合金车架\")); // 建造和组装车脚\r\n\t}\r\n\tbuildSeat(): void {\r\n\t\tthis.bike.setSeat(new Seat(\"海绵坐垫\")); // 建造和组装车座\r\n\t}\r\n\tgetResult(): Bike {\r\n\t\treturn this.bike;\r\n\t}\r\n}\r\n\r\n// mobile 自行车的建造者\r\nclass MobileBikeBuilder extends BikeBuidler {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.bike.setBrand(\"Mobile Bike\"); // 设置品牌\r\n\t}\r\n\tbuildFrame(): void {\r\n\t\tthis.bike.setFrame(new Frame(\"碳纤维车架\")); // 建造和组装车脚\r\n\t}\r\n\tbuildSeat(): void {\r\n\t\tthis.bike.setSeat(new Seat(\"真皮坐垫\")); // 建造和组装车座\r\n\t}\r\n\tgetResult(): Bike {\r\n\t\treturn this.bike;\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tvar ofoBike = new Director(new OfoBikeBuilder()).construct();\r\n\tvar mobBike = new Director(new MobileBikeBuilder()).construct();\r\n\tconsole.log(ofoBike);\r\n\tconsole.log(mobBike);\r\n}\r\n\r\nmain();\r\n\r\n/*\r\n输出：\r\n\r\nBike {\r\n  Brand: 'Ofo Bike',\r\n  frame: Frame { name: '铝合金车架' },\r\n  seat: Seat { name: '海绵坐垫' }\r\n}\r\n\r\nBike {\r\n  Brand: 'Mobile Bike',\r\n  frame: Frame { name: '碳纤维车架' },\r\n  seat: Seat { name: '真皮坐垫' }\r\n}\r\n*/\r\n```\r\n\r\n## 创建型:_5_原型模式\r\n\r\n```ts\r\ninterface Clonable {\r\n\tdeepClone(): Clonable;\r\n\tclone(): Clonable;\r\n}\r\n\r\nclass Demo implements Clonable {\r\n\tname = \"Demo\";\r\n\tlist = [];\r\n\tclone(): Demo {\r\n\t\treturn Object.assign(new Demo(), this); // 浅拷贝\r\n\t}\r\n\tdeepClone(): Demo {\r\n\t\t// return JSON.parse(JSON.stringify(this)); // 深拷贝，JSON序列化和反序列化，但其原型对象为{}\r\n\t\treturn Object.assign(new Demo(), JSON.parse(JSON.stringify(this))); // 深克隆，原型对象为自身\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tvar demo1 = new Demo();\r\n\tvar demo2 = demo1.deepClone();\r\n\tconsole.log(demo1);\r\n\tconsole.log(demo2);\r\n\tconsole.log(demo1 == demo2);\r\n\tconsole.log(demo1.list == demo2.list); // fasle 深克隆\r\n\r\n\tvar demo3 = new Demo();\r\n\tvar demo4 = demo3.clone();\r\n\tconsole.log(demo3);\r\n\tconsole.log(demo4);\r\n\tconsole.log(demo3 == demo4);\r\n\tconsole.log(demo3.list == demo4.list); // true 浅拷贝\r\n}\r\n\r\nmain();\r\n```\r\n\r\n## 结构型:_6_适配器模式\r\n\r\n### 对象适配器模式\r\n\r\n```ts\r\n// 对象适配器模式就是以实现接口和聚合的方式来实现适配器\r\n\r\n// 1. 有一个旧接口 有一个旧的类 ，旧的类实现了旧的接口\r\n\r\n// 被适配的接口，旧的接口\r\ninterface OldUserInterface {\r\n\tGetUserName(): string; // 旧的命名规范是函数开头大写\r\n}\r\n// 旧的User对象，实现的是旧的接口\r\nclass OldUser implements OldUserInterface {\r\n\tGetUserName(): string {\r\n\t\treturn \"Old_DingYigui\";\r\n\t}\r\n}\r\n\r\n// 2. 有一个新的接口 也有新的实现了该接口的类，但不重要，还有一个函数，他的形参要求是一个实现了新接口的对象\r\n\r\n// 目标接口，新的接口\r\ninterface NewUserInterface {\r\n\tgetUserName(): string; // 新的命名规范是函数开头小写\r\n}\r\n// 新的User类 但不重要\r\nclass NewUser implements NewUserInterface {\r\n\tgetUserName(): string {\r\n\t\treturn \"New_DingYigui\";\r\n\t}\r\n}\r\n// 根据新接口编写的函数：\r\n// 某函数期待的对象是实现了新用户接口的类\r\nfunction welcome(user: NewUserInterface) {\r\n\tconsole.log(\"欢迎你：\" + user.getUserName());\r\n}\r\n\r\n// 3. 定义适配器，使得 旧User接口 能够适配 新User接口\r\n\r\n// 旧的User对象 为了适配新的接口 所以实现新的接口，然后通过聚合的方式调用旧对象上的对应方法\r\nclass OldUserToNewUser_Adapter implements NewUserInterface {\r\n\tconstructor(private OldUser: OldUserInterface) {\r\n\t\tthis.OldUser = OldUser;\r\n\t}\r\n\tgetUserName(): string {\r\n\t\treturn this.OldUser.GetUserName();\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\t// 报错，因为不适配\r\n\t// welcome(new OldUser()); // 因为函数要求形参是一个NewUserInterface类型 但 OldUser 是OldUserInterface类型\r\n\r\n\t// 经过适配器的转换，不报错\r\n\twelcome(new OldUserToNewUser_Adapter(new OldUser())); // 因为 旧的User对象 放入 适配器 就能满足welcome函数形参的接口要求了\r\n}\r\nmain();\r\n```\r\n\r\n### 类适配器模式\r\n\r\n```ts\r\n// 对象适配器模式就是以实现接口和聚合的方式来实现适配器\r\n\r\n// 1. 有一个旧接口 有一个旧的类 ，旧的类实现了旧的接口\r\n\r\n// 被适配的接口，旧的接口\r\ninterface OldUserInterface {\r\n\tGetUserName(): string; // 旧的命名规范是函数开头大写\r\n}\r\n// 旧的User对象，实现的是旧的接口\r\nclass OldUser implements OldUserInterface {\r\n\tGetUserName(): string {\r\n\t\treturn \"Old_DingYigui\";\r\n\t}\r\n}\r\n\r\n// 2. 有一个新的接口 也有新的实现了该接口的类，但不重要，还有一个函数，他的形参要求是一个实现了新接口的对象\r\n\r\n// 目标接口，新的接口\r\ninterface NewUserInterface {\r\n\tgetUserName(): string; // 新的命名规范是函数开头小写\r\n}\r\n// 新的User类 但不重要\r\nclass NewUser implements NewUserInterface {\r\n\tgetUserName(): string {\r\n\t\treturn \"New_DingYigui\";\r\n\t}\r\n}\r\n// 根据新接口编写的函数：\r\n// 某函数期待的对象是实现了新用户接口的类\r\nfunction welcome(user: NewUserInterface) {\r\n\tconsole.log(\"欢迎你：\" + user.getUserName());\r\n}\r\n\r\n// 3.定义新版本的OldUser，继承旧User对象， 实现新接口，使其适配新接口\r\n\r\nclass OldUserToNewUser_Adapter extends OldUser implements NewUserInterface {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t}\r\n\tgetUserName(): string {\r\n\t\treturn this.GetUserName();\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\t// 报错，因为不适配\r\n\t// welcome(new OldUser()); // 因为函数要求形参是一个NewUserInterface类型 但 OldUser 是OldUserInterface类型\r\n\r\n\t// 经过适配器的转换，不报错\r\n\twelcome(new OldUserToNewUser_Adapter());\r\n}\r\nmain();\r\n```\r\n\r\n## 结构型:_7_桥接模式\r\n\r\n```ts\r\n// 桥接模式和策略模式有些相似，\r\n// 共同点是，都是一个对象对另一个接口的聚合\r\n// 区别是，\r\n// 策略模式是在强调：`具体类`对接口的聚合，多个实现类实现该接口\r\n// 桥接模式是在强调：`抽象类`对接口的聚合，多个实现类实现该接口，多个具体类继承抽象类\r\n// 策略模式属于行为模式，桥接模式属于结构型模式\r\n// 案例：\r\n// 策略模式：我要画圆。要实心圆，我能够用solidPen来配置。画虚线圆能够用dashedPen来配置。\r\n// 桥接模式：同样是画圆，在windows下来画实心圆。就用windowPen+solidPen来配置。在unix下画实心圆就用unixPen+solidPen来配置。假设要再windows下画虚线圆。就用windowsPen+dashedPen来配置，要在unix下画虚线圆，就用unixPen+dashedPen来配置。\r\n// 画圆方法中，策略仅仅是考虑算法的替换，而桥接考虑的则是不同平台下须要调用不同的工具，接口仅仅是定义一个方法。而详细实现则由详细实现类完毕。\r\n\r\n// 文件系统\r\ninterface myFileSystem {\r\n\treadFile(path: string): string;\r\n\twriteFile(path: string, data: string): void;\r\n}\r\n\r\n// 操作系统\r\nabstract class OS {\r\n\tabstract fs: myFileSystem; // 操作系统聚合文件系统接口\r\n\tabstract readFile(path: string): string;\r\n\tabstract writeFile(path: string, data: string): void;\r\n}\r\n\r\nclass Fat32 implements myFileSystem {\r\n\treadFile(path: string): string {\r\n\t\tconsole.log(\"reading file from fat32\");\r\n\t\treturn \"reading file from fat32\";\r\n\t}\r\n\twriteFile(path: string, data: string): void {\r\n\t\tconsole.log(\"writing file to fat32\");\r\n\t}\r\n}\r\nclass NTFS implements myFileSystem {\r\n\treadFile(path: string): string {\r\n\t\tconsole.log(\"reading file from ntfs\");\r\n\t\treturn \"reading file from ntfs\";\r\n\t}\r\n\twriteFile(path: string, data: string): void {\r\n\t\tconsole.log(\"writing file to ntfs\");\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\nclass WindowOS implements OS {\r\n\tfs: myFileSystem;\r\n\tconstructor(fs: myFileSystem) {\r\n\t\tthis.fs = fs;\r\n\t}\r\n\treadFile(path: string): string {\r\n\t\tconsole.log(\"windows is reading file\");\r\n\t\treturn this.fs.readFile(path);\r\n\t}\r\n\twriteFile(path: string, data: string): void {\r\n\t\tconsole.log(\"windows is writing file\");\r\n\t\treturn this.fs.writeFile(path, data);\r\n\t}\r\n}\r\n\r\nclass Unix implements OS {\r\n\tfs: myFileSystem;\r\n\tconstructor(fs: myFileSystem) {\r\n\t\tthis.fs = fs;\r\n\t}\r\n\treadFile(path: string): string {\r\n\t\tconsole.log(\"unix is reading file\");\r\n\t\treturn this.fs.readFile(path);\r\n\t}\r\n\twriteFile(path: string, data: string): void {\r\n\t\tconsole.log(\"unix is writing file\");\r\n\t\treturn this.fs.writeFile(path, data);\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tvar windowOS = new WindowOS(new Fat32()); // Windows with fat32\r\n\tvar windowOS = new WindowOS(new NTFS()); // Windows with ntfs\r\n\twindowOS.readFile(\"/code/123.txt\");\r\n\twindowOS.writeFile(\"/code/123.txt\", \"123\");\r\n\r\n\tvar unixOS = new Unix(new NTFS()); //unix with ntfs\r\n\tvar unixOS = new Unix(new Fat32()); // unix with fat32\r\n\tunixOS.readFile(\"/code/123.txt\");\r\n\tunixOS.writeFile(\"/code/123.txt\", \"123\");\r\n}\r\n\r\nmain();\r\n```\r\n\r\n## 结构型:_8_组合模式\r\n\r\n```ts\r\ninterface Component {\r\n\tgetName(): string;\r\n\tgetLevel(): number;\r\n\tdoSomething(): void;\r\n\tprint(): void;\r\n\tgetSize(): number;\r\n}\r\ninterface MenuComponent extends Component {\r\n\tchilds: Array<Component>;\r\n\tadd(component: Component): MenuComponent;\r\n\tremove(component: Component): MenuComponent;\r\n}\r\ninterface ItemComponent extends Component {}\r\n\r\nclass MenuComponent implements MenuComponent {\r\n\tpublic childs: Array<Component> = [];\r\n\tconstructor(private name: string, private level: number) {\r\n\t\tthis.name = name;\r\n\t\tthis.level = level;\r\n\t}\r\n\tgetName() {\r\n\t\treturn this.name;\r\n\t}\r\n\tgetLevel() {\r\n\t\treturn this.level;\r\n\t}\r\n\tadd(component: Component) {\r\n\t\tthis.childs.push(component);\r\n\t\treturn this;\r\n\t}\r\n\tremove(component: Component) {\r\n\t\tthis.childs.splice(this.childs.indexOf(component), 1);\r\n\t\treturn this;\r\n\t}\r\n\tdoSomething() {\r\n\t\tthis.childs.forEach(item => item.doSomething());\r\n\t}\r\n\tprint(): void {\r\n\t\tvar array = new Array(this.getLevel() - 1).fill(\"\\t\");\r\n\t\tarray.push(this.name);\r\n\t\tconsole.log(...array);\r\n\t\tthis.childs.forEach(item => item.print());\r\n\t}\r\n\tgetSize() {\r\n\t\tlet size = 0;\r\n\t\tthis.childs.forEach(item => (size += item.getSize()));\r\n\t\treturn size;\r\n\t}\r\n}\r\n\r\nclass ItemComponent implements ItemComponent {\r\n\tconstructor(private name: string, private level: number, private size: number) {\r\n\t\tthis.name = name;\r\n\t\tthis.level = level;\r\n\t\tthis.size = size;\r\n\t}\r\n\tgetName() {\r\n\t\treturn this.name;\r\n\t}\r\n\tgetLevel() {\r\n\t\treturn this.level;\r\n\t}\r\n\tdoSomething() {\r\n\t\tconsole.log(\"doSomething\");\r\n\t}\r\n\tprint(): void {\r\n\t\tvar array = new Array(this.getLevel() - 1).fill(\"\\t\");\r\n\t\tarray.push(this.name);\r\n\t\tconsole.log(...array);\r\n\t}\r\n\tgetSize() {\r\n\t\treturn this.size;\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tconst menuRootComponent = new MenuComponent(\"MenuRoot\", 1);\r\n\tmenuRootComponent\r\n\t\t.add(new ItemComponent(\"Item\", 2, 1))\r\n\t\t.add(new ItemComponent(\"Item\", 2, 1))\r\n\t\t.add(new MenuComponent(\"Menu\", 2).add(new ItemComponent(\"Item\", 3, 1)).add(new ItemComponent(\"Item\", 3, 1)).add(new ItemComponent(\"Item\", 3, 1)))\r\n\t\t.add(\r\n\t\t\tnew MenuComponent(\"Menu\", 2)\r\n\t\t\t\t.add(new ItemComponent(\"Item\", 3, 1))\r\n\t\t\t\t.add(new ItemComponent(\"Item\", 3, 1))\r\n\t\t\t\t.add(new ItemComponent(\"Item\", 3, 1))\r\n\t\t\t\t.add(\r\n\t\t\t\t\tnew MenuComponent(\"Menu\", 3).add(new ItemComponent(\"Item\", 4, 1)).add(new ItemComponent(\"Item\", 4, 1)).add(new ItemComponent(\"Item\", 4, 1))\r\n\t\t\t\t)\r\n\t\t);\r\n\tconsole.log(\"size:\", menuRootComponent.getSize());\r\n\tconsole.log(JSON.stringify(menuRootComponent, null, 4));\r\n\tmenuRootComponent.print();\r\n\tmenuRootComponent.doSomething();\r\n}\r\nmain();\r\n\r\n/*\r\n * Output:\r\n\r\n{\r\n    \"name\": \"MenuRoot\",\r\n    \"level\": 1,\r\n    \"childs\": [\r\n        {\r\n            \"name\": \"Item\",\r\n            \"level\": 2\r\n        },\r\n        {\r\n            \"name\": \"Item\",\r\n            \"level\": 2\r\n        },\r\n        {\r\n            \"name\": \"Menu\",\r\n            \"level\": 2,\r\n            \"childs\": [\r\n                {\r\n                    \"name\": \"Item\",\r\n                    \"level\": 3\r\n                },\r\n                {\r\n                    \"name\": \"Item\",\r\n                    \"level\": 3\r\n                },\r\n                {\r\n                    \"name\": \"Item\",\r\n                    \"level\": 3\r\n                }\r\n            ]\r\n        },\r\n        {\r\n            \"name\": \"Menu\",\r\n            \"level\": 2,\r\n            \"childs\": [\r\n                {\r\n                    \"name\": \"Item\",\r\n                    \"level\": 3\r\n                },\r\n                {\r\n                    \"name\": \"Item\",\r\n                    \"level\": 3\r\n                },\r\n                {\r\n                    \"name\": \"Item\",\r\n                    \"level\": 3\r\n                },\r\n                {\r\n                    \"name\": \"Menu\",\r\n                    \"level\": 3,\r\n                    \"childs\": [\r\n                        {\r\n                            \"name\": \"Item\",\r\n                            \"level\": 4\r\n                        },\r\n                        {\r\n                            \"name\": \"Item\",\r\n                            \"level\": 4\r\n                        },\r\n                        {\r\n                            \"name\": \"Item\",\r\n                            \"level\": 4\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n}\r\n\r\n\r\n\r\n\r\n\r\nMenuRoot\r\n         Item\r\n         Item\r\n         Menu\r\n                 Item\r\n                 Item\r\n                 Item\r\n         Menu\r\n                 Item\r\n                 Item\r\n                 Item\r\n                 Menu\r\n                         Item\r\n                         Item\r\n                         Item\r\n*/\r\n```\r\n\r\n## 结构型:_9_装饰器\r\n\r\n```ts\r\n// 咖啡类\r\nabstract class Coffee {\r\n\tabstract getDescription(): string;\r\n\tabstract getCost(): number;\r\n}\r\n// 咖啡类的装饰器：继承咖啡类，并聚合咖啡类\r\nabstract class CoffeeDecorator extends Coffee {\r\n\tbeDecorated: Coffee; // 被装饰的咖啡\r\n\tconstructor(beDecorated: Coffee) {\r\n\t\tsuper();\r\n\t\tthis.beDecorated = beDecorated;\r\n\t}\r\n}\r\n\r\n// 美式咖啡\r\nclass AmericaCoffee extends Coffee {\r\n\tgetDescription() {\r\n\t\treturn \"American coffee\";\r\n\t}\r\n\tgetCost() {\r\n\t\treturn 10;\r\n\t}\r\n}\r\n// 意式咖啡\r\nclass ItalyCoffee extends Coffee {\r\n\tgetDescription() {\r\n\t\treturn \"Italian coffee\";\r\n\t}\r\n\tgetCost() {\r\n\t\treturn 20;\r\n\t}\r\n}\r\n\r\n// 加糖\r\nclass SugerCoffeeDecorator extends CoffeeDecorator {\r\n\tconstructor(public beDecorated: Coffee) {\r\n\t\tsuper(beDecorated);\r\n\t}\r\n\tgetDescription() {\r\n\t\treturn this.beDecorated.getDescription() + \" with Suger\"; // 装饰后的描述是原描述+\" with Suger\"\r\n\t}\r\n\tgetCost() {\r\n\t\treturn this.beDecorated.getCost() + 1; // 装饰后的价格是原价格+1\r\n\t}\r\n}\r\n// 加牛奶\r\nclass MilkCoffeeDecorator extends CoffeeDecorator {\r\n\tconstructor(public beDecorated: Coffee) {\r\n\t\tsuper(beDecorated);\r\n\t}\r\n\tgetDescription() {\r\n\t\treturn this.beDecorated.getDescription() + \" with Milk\";\r\n\t}\r\n\tgetCost() {\r\n\t\treturn this.beDecorated.getCost() + 5;\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tlet americaCoffee = new AmericaCoffee(); // 美式咖啡\r\n\tlet decoratedWithSuger = new SugerCoffeeDecorator(americaCoffee); // 美式咖啡加糖\r\n\tlet decoratedWithMilk = new MilkCoffeeDecorator(decoratedWithSuger); // 美式咖啡加糖后再加牛奶\r\n\r\n\tconsole.log(decoratedWithMilk.getDescription());\r\n\tconsole.log(decoratedWithMilk.getCost());\r\n}\r\nmain();\r\n```\r\n\r\n## 结构型:_10_外观模式\r\n\r\n```ts\r\n// 外观模式非常简单，就是对于一个使用起来复杂度较高的系统，另外封装成一个类，\r\n// 让这个类来接管如何使用这个系统，这种写法平时也会自然而然的写出来，没啥好说的\r\n\r\nimport { Game } from \"./Game\";\r\n\r\nfunction main() {\r\n\tlet game = new Game(); // 外观模式，把整个系统的复杂的调用细节再封装为一个类，通过这个类来运行这个系统\r\n\tgame.start();\r\n}\r\nmain();\r\n```\r\n\r\n## 结构型:_11_享元模式\r\n\r\n```ts\r\n// 享元模式的概念和单例的概念有些类似，\r\n// 但单例模式是一个对象只能被创建一个\r\n// 享元模式是，一个对象能够被创建多次，但只是通过一个共享容器，让具有某一条件的对象只被初始化一次，而这种具体的条件可以很灵活的由创建工厂来控制\r\ninterface Shape {\r\n\tdraw(): void;\r\n}\r\nclass Box implements Shape {\r\n\tconstructor(\r\n\t\t// private posX: number, // 要被共享，就只应当具有公共不变的属性\r\n\t\t// private posY: number,\r\n\t\tprivate width: number,\r\n\t\tprivate height: number,\r\n\t\tprivate color: string\r\n\t) {\r\n\t\t// this.posX = posX;\r\n\t\t// this.posY = posY;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tthis.color = color;\r\n\t}\r\n\tsetColor(color: string): void {\r\n\t\tthis.color = color;\r\n\t}\r\n\tdraw(): void {\r\n\t\tconsole.log(JSON.stringify(this, undefined, 4));\r\n\t}\r\n}\r\n\r\nclass BoxFactory {\r\n\tstatic boxMap = new Map<string, Box>();\r\n\tstatic getBox(color: string): Box {\r\n\t\tif (this.boxMap.has(color)) {\r\n\t\t\treturn this.boxMap.get(color) as Box;\r\n\t\t} else {\r\n\t\t\tvar box = new Box(100, 100, color);\r\n\t\t\tthis.boxMap.set(color, box);\r\n\t\t\treturn box;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tvar box1 = BoxFactory.getBox(\"red\");\r\n\tvar box2 = BoxFactory.getBox(\"red\");\r\n\tvar box3 = BoxFactory.getBox(\"pink\");\r\n\tconsole.log(new Box(100, 100, \"red\") == new Box(100, 100, \"red\")); // 重复创建对象 不是同一个对象\r\n\tconsole.log(box1 == box2); // 是同一个对象，避免了重复创建对象，节省了内存\r\n\tconsole.log(box2 == box3); // 不是同一个对象，对于不存在的对象，会在第一次创建对象，\r\n}\r\nmain();\r\n```\r\n\r\n## 结构型:_12_代理模式\r\n\r\n```ts\r\ninterface interfaceA {\r\n\tmethodA(): void;\r\n\tmethodB(): void;\r\n}\r\n\r\nclass A implements interfaceA {\r\n\tmethodA(): void {\r\n\t\tconsole.log(\"A:methodA\");\r\n\t}\r\n\r\n\tmethodB(): void {\r\n\t\tconsole.log(\"A:methodB\");\r\n\t}\r\n}\r\n\r\nclass ProxyA implements interfaceA {\r\n\tconstructor(private a: A) {\r\n\t\tthis.a = a;\r\n\t}\r\n\tmethodA(): void {\r\n\t\tconsole.log(\"Proxy:MethodA\");\r\n\t\tthis.a.methodA();\r\n\t}\r\n\tmethodB(): void {\r\n\t\tconsole.log(\"Proxy:MethodB\");\r\n\t\tthis.a.methodB();\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tlet proxyA = new ProxyA(new A());\r\n\tproxyA.methodA();\r\n\tproxyA.methodB();\r\n}\r\nmain();\r\n```\r\n\r\n## 行为型:_13_责任链模式\r\n\r\n```ts\r\nabstract class AbsLogger {\r\n\tprivate level: number;\r\n\tprivate next: AbsLogger | null;\r\n\tsetLevel(level: number): AbsLogger {\r\n\t\tthis.level = level;\r\n\t\treturn this;\r\n\t}\r\n\tsetNext(next: AbsLogger | null): AbsLogger {\r\n\t\tthis.next = next;\r\n\t\treturn this;\r\n\t}\r\n\tpublic logMsg(level: number, msg: string) {\r\n\t\tif (this.level >= level) {\r\n\t\t\tthis.write(level, msg);\r\n\t\t} else if (this.next) {\r\n\t\t\tthis.next.logMsg(level, msg);\r\n\t\t}\r\n\t}\r\n\tabstract write(level: number, msg: string): void;\r\n}\r\n\r\nclass ErrorLogger extends AbsLogger {\r\n\tpublic write(level: number, msg: string) {\r\n\t\tconsole.warn(\"error:\", level, msg);\r\n\t}\r\n}\r\nclass DebugLogger extends AbsLogger {\r\n\tpublic write(level: number, msg: string) {\r\n\t\tconsole.log(\"debug:\", level, msg);\r\n\t}\r\n}\r\nclass InfoLogger extends AbsLogger {\r\n\tpublic write(level: number, msg: string) {\r\n\t\tconsole.log(\"info:\", level, msg);\r\n\t}\r\n}\r\n\r\nclass LoggerChain {\r\n\tprivate static head: AbsLogger;\r\n\tprivate constructor() {}\r\n\tstatic {\r\n\t\tvar info = new InfoLogger();\r\n\t\tvar debug = new DebugLogger();\r\n\t\tvar error = new ErrorLogger();\r\n\t\tinfo.setLevel(3).setNext(debug);\r\n\t\tdebug.setLevel(2).setNext(error);\r\n\t\terror.setLevel(1).setNext(null);\r\n\t\tLoggerChain.head = info;\r\n\t}\r\n\tstatic getLogger() {\r\n\t\treturn LoggerChain.head;\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tLoggerChain.getLogger().logMsg(3, \"ha ha ha ha\");\r\n\tLoggerChain.getLogger().logMsg(2, \"ha ha ha ha\");\r\n\tLoggerChain.getLogger().logMsg(1, \"ha ha ha ha\");\r\n}\r\n\r\nmain();\r\n```\r\n\r\n## 行为型:_14_命令模式\r\n\r\n```ts\r\n// 命令接口\r\ninterface ICommand {\r\n\texecute(): void;\r\n\tunexecute(): void;\r\n}\r\n\r\n// 灯\r\nclass Ligtht {\r\n\tturnOn() {\r\n\t\tconsole.log(\"light is turn on\"); // 开灯\r\n\t}\r\n\tturnOff() {\r\n\t\tconsole.log(\"light is turn off\"); // 关灯\r\n\t}\r\n\tdown() {\r\n\t\tconsole.log(\"light is down\"); // 降低亮度\r\n\t}\r\n\tup() {\r\n\t\tconsole.log(\"light is up\"); // 调高亮度\r\n\t}\r\n}\r\n\r\n// 开灯命令\r\nclass LightTurnOnCommand implements ICommand {\r\n\tconstructor(private ligtht: Ligtht) {\r\n\t\tthis.ligtht = ligtht;\r\n\t}\r\n\texecute(): void {\r\n\t\tthis.ligtht.turnOn(); // 执行命令\r\n\t}\r\n\tunexecute(): void {\r\n\t\tthis.ligtht.turnOff(); // 撤销命令\r\n\t}\r\n}\r\n\r\n// 关灯命令\r\nclass LightTurnOffCommand implements ICommand {\r\n\tconstructor(private ligtht: Ligtht) {\r\n\t\tthis.ligtht = ligtht;\r\n\t}\r\n\texecute(): void {\r\n\t\tthis.ligtht.turnOff(); // 执行命令\r\n\t}\r\n\tunexecute(): void {\r\n\t\tthis.ligtht.turnOn(); // 撤销命令\r\n\t}\r\n}\r\n// 降低亮度\r\nclass LightDownCommand implements ICommand {\r\n\tconstructor(private ligtht: Ligtht) {\r\n\t\tthis.ligtht = ligtht;\r\n\t}\r\n\texecute(): void {\r\n\t\tthis.ligtht.down(); // 执行命令\r\n\t}\r\n\tunexecute(): void {\r\n\t\tthis.ligtht.up(); // 撤销命令\r\n\t}\r\n}\r\n\r\n// 调高亮度\r\nclass LightUpCommand implements ICommand {\r\n\tconstructor(private ligtht: Ligtht) {\r\n\t\tthis.ligtht = ligtht;\r\n\t}\r\n\texecute(): void {\r\n\t\tthis.ligtht.up(); // 执行命令\r\n\t}\r\n\tunexecute(): void {\r\n\t\tthis.ligtht.down(); // 撤销命令\r\n\t}\r\n}\r\n\r\n// 电视\r\nclass TV {\r\n\tturnOn() {\r\n\t\tconsole.log(\"TV is turn on\"); // 开灯\r\n\t}\r\n\tturnOff() {\r\n\t\tconsole.log(\"TV is turn off\"); // 关灯\r\n\t}\r\n}\r\n// 开电视命令\r\nclass TVTurnOnCommand implements ICommand {\r\n\tconstructor(private tv: TV) {\r\n\t\tthis.tv = tv;\r\n\t}\r\n\texecute(): void {\r\n\t\tthis.tv.turnOn(); // 执行命令\r\n\t}\r\n\tunexecute(): void {\r\n\t\tthis.tv.turnOff(); // 撤销命令\r\n\t}\r\n}\r\n\r\n// 关电视命令\r\nclass TVTurnOffCommand implements ICommand {\r\n\tconstructor(private tv: TV) {\r\n\t\tthis.tv = tv;\r\n\t}\r\n\texecute(): void {\r\n\t\tthis.tv.turnOff(); // 执行命令\r\n\t}\r\n\tunexecute(): void {\r\n\t\tthis.tv.turnOn(); // 撤销命令\r\n\t}\r\n}\r\n\r\n// 命令触发器\r\nclass CommandInvoker {\r\n\t// 执行和撤销的历史记录\r\n\thistory_do: Array<ICommand> = [];\r\n\thistory_undo: Array<ICommand> = [];\r\n\r\n\t// 一般命名为：setCommand(),但这里为了保持命名格式一致\r\n\tToDoCommand(ToDoCommand: ICommand): void {\r\n\t\tconsole.log(\"执行命令：\");\r\n\t\tToDoCommand.execute(); // 执行命令\r\n\t\tthis.history_do.push(ToDoCommand); // 添加到历史记录\r\n\t\tthis.history_undo = []; // 清除撤销历史记录\r\n\t}\r\n\t// 撤销命令\r\n\tUndoCommand() {\r\n\t\tlet UnDoCommand = this.history_do.pop(); // 获取栈顶命令\r\n\t\tif (UnDoCommand) {\r\n\t\t\tconsole.log(\"撤销命令：\");\r\n\t\t\tUnDoCommand.unexecute(); // 撤销命令\r\n\t\t\tthis.history_undo.push(UnDoCommand); // 添加到撤销历史记录\r\n\t\t}\r\n\t}\r\n\t// 重做命令\r\n\tRedoCommand() {\r\n\t\tlet ReDoCommand = this.history_undo.pop(); // 获取最后一条已撤销的命令\r\n\t\tif (ReDoCommand) {\r\n\t\t\tconsole.log(\"重做命令：\");\r\n\t\t\tReDoCommand.execute(); // 重做\r\n\t\t\tthis.history_do.push(ReDoCommand); // 添加到历史记录\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tlet light = new Ligtht(); // 灯\r\n\tlet tv = new TV(); // 电视\r\n\tlet commandInvoker = new CommandInvoker(); // 命令触发器（智能遥控器）\r\n\r\n\tcommandInvoker.ToDoCommand(new LightTurnOnCommand(light)); // 开灯\r\n\tcommandInvoker.ToDoCommand(new LightTurnOffCommand(light)); // 关灯\r\n\tcommandInvoker.ToDoCommand(new LightUpCommand(light)); // 灯调亮\r\n\tcommandInvoker.ToDoCommand(new LightDownCommand(light)); // 灯调暗\r\n\r\n\tcommandInvoker.ToDoCommand(new TVTurnOnCommand(tv)); // 开电视\r\n\tcommandInvoker.ToDoCommand(new TVTurnOffCommand(tv)); // 关电视\r\n\r\n\tcommandInvoker.UndoCommand(); // 撤销\r\n\tcommandInvoker.UndoCommand(); // 撤销\r\n\tcommandInvoker.UndoCommand(); // 撤销\r\n\tcommandInvoker.UndoCommand(); // 撤销\r\n\tcommandInvoker.RedoCommand(); // 重做\r\n\tcommandInvoker.RedoCommand(); // 重做\r\n\tcommandInvoker.ToDoCommand(new LightTurnOffCommand(light)); // 关灯\r\n\tcommandInvoker.RedoCommand(); // 重做，无法重做，因为撤销历史被覆盖\r\n}\r\nmain();\r\n```\r\n\r\n## 行为型:_15_解释器模式\r\n\r\n```ts\r\ninterface Expression {\r\n\tinterpret(context: Context): number;\r\n}\r\n\r\nclass Variable implements Expression {\r\n\tconstructor(protected name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\tinterpret(context: Context) {\r\n\t\treturn context.getValue(this)?.interpret(context) as number;\r\n\t}\r\n}\r\nclass Value implements Expression {\r\n\tconstructor(protected value: number) {\r\n\t\tthis.value = value;\r\n\t}\r\n\tinterpret(context: Context) {\r\n\t\treturn this.value;\r\n\t}\r\n}\r\nclass Add implements Expression {\r\n\tconstructor(protected left: Expression, protected right: Expression) {\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t}\r\n\tinterpret(context: Context) {\r\n\t\treturn this.left.interpret(context) + this.right.interpret(context);\r\n\t}\r\n}\r\nclass Minus implements Expression {\r\n\tconstructor(protected left: Expression, protected right: Expression) {\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t}\r\n\tinterpret(context: Context) {\r\n\t\treturn this.left.interpret(context) - this.right.interpret(context);\r\n\t}\r\n}\r\n\r\nclass SingleEqual implements Expression {\r\n\tconstructor(protected left: Variable, protected right: Expression) {\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t}\r\n\tinterpret(context: Context) {\r\n\t\tcontext.setValue(this.left, new Value(this.right.interpret(context)));\r\n\t\treturn this.left.interpret(context);\r\n\t}\r\n}\r\n\r\nclass Pow implements Expression {\r\n\tconstructor(protected left: Expression, protected right: Expression) {\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t}\r\n\tinterpret(context: Context) {\r\n\t\treturn Math.pow(this.left.interpret(context), this.right.interpret(context));\r\n\t}\r\n}\r\n\r\nclass Context {\r\n\tcontext = new Map<Variable, Value>();\r\n\tsetValue(variable: Variable, value: Value) {\r\n\t\tthis.context.set(variable, value);\r\n\t}\r\n\tgetValue(variable: Variable) {\r\n\t\treturn this.context.get(variable);\r\n\t}\r\n}\r\n\r\nfunction main1() {\r\n\t// 上下文\r\n\tconst ctx = new Context();\r\n\r\n\tconst a = new Variable(\"a\");\r\n\tconst b = new Variable(\"b\");\r\n\tconst c = new Variable(\"c\");\r\n\tconst d = new Variable(\"d\");\r\n\tconst result = new Variable(\"result\");\r\n\r\n\t// 赋值\r\n\tnew SingleEqual(a, new Value(1)).interpret(ctx); // a = 1\r\n\tnew SingleEqual(b, new Value(2)).interpret(ctx); // b = 2\r\n\tnew SingleEqual(c, new Value(3)).interpret(ctx); // c = 3\r\n\tnew SingleEqual(d, new Value(4)).interpret(ctx); // d = 4\r\n\r\n\t// result = (a+b)-(c+d)\r\n\tnew SingleEqual(result, new Minus(new Add(a, b), new Add(c, d))).interpret(ctx);\r\n\r\n\tconsole.log(result.interpret(ctx));\r\n}\r\nmain1();\r\n\r\nfunction main2() {\r\n\t// 上下文\r\n\tconst ctx = new Context();\r\n\r\n\tconst a = new Variable(\"a\");\r\n\tconst b = new Variable(\"b\");\r\n\tconst result = new Variable(\"result\");\r\n\r\n\t// 赋值\r\n\tnew SingleEqual(a, new Value(2)).interpret(ctx); // a = 2\r\n\tnew SingleEqual(b, new Value(3)).interpret(ctx); // b = 3\r\n\r\n\t// result = (a+b)-(c+d)\r\n\tnew SingleEqual(result, new Pow(a, b)).interpret(ctx);\r\n\r\n\tconsole.log(result.interpret(ctx));\r\n}\r\n// main2();\r\n```\r\n\r\n## 行为型:_16_迭代器模式\r\n\r\n```ts\r\n/* eslint-disable no-var */\r\n\r\n// 迭代器对象\r\ninterface myIterator<T> {\r\n\tgetNext(): T;\r\n\thasNext(): boolean;\r\n}\r\n\r\n// 可迭代接口\r\ninterface myIterable<T> {\r\n\tgetIterator(): myIterator<T>; // 获取迭代器对象\r\n}\r\n\r\n// 实现可迭代接口\r\nclass myList<T> implements myIterable<T> {\r\n\tlist: Array<T> = [];\r\n\tpush(item: T): void {\r\n\t\tthis.list.push(item);\r\n\t}\r\n\tpop(): T | undefined {\r\n\t\treturn this.list.pop();\r\n\t}\r\n\tgetIterator(): myIterator<T> {\r\n\t\treturn new myList.ListIterator<T>(this.list);\r\n\t}\r\n\tstatic ListIterator = class ListIterator<T> {\r\n\t\tcurrentIndex: number;\r\n\t\tlist: Array<T>;\r\n\t\tconstructor(list: T[]) {\r\n\t\t\tthis.list = list;\r\n\t\t\tthis.currentIndex = 0;\r\n\t\t}\r\n\t\thasNext(): boolean {\r\n\t\t\treturn this.currentIndex < this.list.length;\r\n\t\t}\r\n\t\tgetNext(): T {\r\n\t\t\treturn this.list[this.currentIndex++];\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction main() {\r\n\tvar list = new myList();\r\n\tlist.push(1);\r\n\tlist.push(2);\r\n\tlist.push(3);\r\n\tlist.push(4);\r\n\tlist.push(5);\r\n\tlist.push(6);\r\n\r\n\tvar iterator = list.getIterator(); // 获取迭代器对象\r\n\twhile (iterator.hasNext()) {\r\n\t\tconsole.log(iterator.getNext());\r\n\t}\r\n}\r\nmain();\r\n```\r\n\r\n## 行为型:_17_中介者模式\r\n\r\n```ts\r\n// 消息发送的中介者\r\nabstract class MsgMediator {\r\n\tprotected abstract msgReceivers: Map<string, MsgReceiver>;\r\n\tabstract join(receiverId: string, receiver: MsgReceiver): boolean; // 登录\r\n\tabstract sendMsgToReceiver(fromReceiverId: string, msg: string, toReceiverId: string): boolean;\r\n\tabstract sendMsgToReceivers(fromReceiverId: string, msg: string, toReceiverIds: string[]): boolean;\r\n\tabstract sendMsgToAll(fromReceiverId: string, msg: string): void;\r\n}\r\n// 消息的接受者\r\nabstract class MsgReceiver {\r\n\tprotected abstract msgMediator: MsgMediator; // 消息发送者聚合了一个中介者\r\n\tabstract receiveMsg(msg: string, fromUserId: string): void; // 接收消息\r\n\tabstract sendMsgToUser(msg: string, toUserId: string): boolean; // 使用中介者发送点对点消息\r\n\tabstract sendMsgToUsers(msg: string, toUserIds: Array<string>): boolean; // 使用中介者发送一对多消息\r\n\tabstract broadcastMessage(msg: string): void; // 使用中介者发送广播消息\r\n}\r\n\r\n// 聊天室\r\nclass ChatRoom extends MsgMediator {\r\n\tprotected chatRoomId: string;\r\n\tprotected chatRoomName: string;\r\n\tprotected msgReceivers = new Map<string, MsgReceiver>();\r\n\tconstructor(chatRoomId: string, chatRoomName: string) {\r\n\t\tsuper();\r\n\t\tthis.chatRoomId = chatRoomId;\r\n\t\tthis.chatRoomName = chatRoomName;\r\n\t}\r\n\tjoin(UserId: string, User: MsgReceiver): boolean {\r\n\t\tthis.msgReceivers.set(UserId, User);\r\n\t\tif (this.msgReceivers.has(UserId)) return true;\r\n\t\treturn false;\r\n\t}\r\n\tsendMsgToReceiver(fromUserId: string, msg: string, toUserId: string): boolean {\r\n\t\tif (this.msgReceivers.has(toUserId)) {\r\n\t\t\tthis.msgReceivers.get(toUserId)?.receiveMsg(msg, fromUserId);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tsendMsgToReceivers(fromUserId: string, msg: string, toUserIds: string[]): boolean {\r\n\t\tlet flag = true;\r\n\t\ttoUserIds.forEach(toReceiverId => {\r\n\t\t\tif (this.sendMsgToReceiver(fromUserId, msg, toReceiverId) == false) flag = false;\r\n\t\t});\r\n\t\treturn flag;\r\n\t}\r\n\tsendMsgToAll(fromUserId: string, msg: string): void {\r\n\t\tthis.msgReceivers.forEach((user, id) => user.receiveMsg(msg, fromUserId));\r\n\t}\r\n}\r\n\r\nclass User extends MsgReceiver {\r\n\tprotected msgMediator: MsgMediator;\r\n\tconstructor(private userId: string, private userName: string) {\r\n\t\tsuper();\r\n\t\tthis.userId = userId;\r\n\t\tthis.userName = userName;\r\n\t}\r\n\tjoin(msgMediator: MsgMediator) {\r\n\t\tthis.msgMediator = msgMediator;\r\n\t\tif (msgMediator.join(this.userId, this)) return true;\r\n\t\treturn false;\r\n\t}\r\n\tsendMsgToUser(msg: string, toUserId: string): boolean {\r\n\t\treturn this.msgMediator.sendMsgToReceiver(this.userId, msg, toUserId);\r\n\t}\r\n\tsendMsgToUsers(msg: string, toUserIds: Array<string>): boolean {\r\n\t\treturn this.msgMediator.sendMsgToReceivers(this.userId, msg, toUserIds);\r\n\t}\r\n\tbroadcastMessage(msg: string): void {\r\n\t\treturn this.msgMediator.sendMsgToAll(this.userId, msg);\r\n\t}\r\n\treceiveMsg(msg: string, fromUserId: string): void {\r\n\t\tconsole.log(`用户${this.userId}收到从用户${fromUserId}发来的消息:${msg}`);\r\n\t}\r\n\tgetUserId(): string {\r\n\t\treturn this.userId;\r\n\t}\r\n\tgetUserName(): string {\r\n\t\treturn this.userName;\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tconst chatRoom = new ChatRoom(\"111\", \"测试\");\r\n\r\n\tconst user1 = new User(\"001\", \"user1\");\r\n\tconst user2 = new User(\"002\", \"user2\");\r\n\tconst user3 = new User(\"003\", \"user3\");\r\n\tconst user4 = new User(\"004\", \"user4\");\r\n\tconst user5 = new User(\"005\", \"user5\");\r\n\tconst user6 = new User(\"006\", \"user6\");\r\n\tconst user7 = new User(\"007\", \"user7\");\r\n\tconst user8 = new User(\"008\", \"user8\");\r\n\r\n\tconsole.log(user1.join(chatRoom));\r\n\tconsole.log(user2.join(chatRoom));\r\n\tconsole.log(user3.join(chatRoom));\r\n\tconsole.log(user4.join(chatRoom));\r\n\tconsole.log(user5.join(chatRoom));\r\n\tconsole.log(user6.join(chatRoom));\r\n\tconsole.log(user7.join(chatRoom));\r\n\tconsole.log(user8.join(chatRoom));\r\n\r\n\t// 点对点发送\r\n\tuser1.sendMsgToUser(\"《私聊消息:哈喽》\", user2.getUserId());\r\n\tuser2.sendMsgToUser(\"《私聊消息:哈喽》\", user3.getUserId());\r\n\tuser3.sendMsgToUser(\"《私聊消息:哈喽》\", user4.getUserId());\r\n\tuser4.sendMsgToUser(\"《私聊消息:哈喽》\", user5.getUserId());\r\n\tuser5.sendMsgToUser(\"《私聊消息:哈喽》\", user6.getUserId());\r\n\tuser6.sendMsgToUser(\"《私聊消息:哈喽》\", user7.getUserId());\r\n\r\n\t// 一对多发送\r\n\tuser7.sendMsgToUsers(\"《群发消息：哈喽》\", [user1.getUserId(), user2.getUserId(), user3.getUserId()]);\r\n\r\n\t// 广播发送\r\n\tuser8.broadcastMessage(\"《广播消息:哈喽》\");\r\n}\r\nmain();\r\n```\r\n\r\n## 行为型:_18_备忘录模式\r\n\r\n```ts\r\n// 备忘录模式，记录某对象的状态\r\nclass Memento {\r\n\tprivate textContent: string;\r\n\tconstructor(textContent: string) {\r\n\t\tthis.textContent = textContent;\r\n\t}\r\n\tgetTextContent() {\r\n\t\treturn this.textContent;\r\n\t}\r\n}\r\n\r\nclass TextEditor {\r\n\tprivate textContent = \"\";\r\n\ttyping(text: string) {\r\n\t\tthis.textContent += text;\r\n\t}\r\n\t// 保存状态\r\n\tsave(): Memento {\r\n\t\treturn new Memento(this.textContent);\r\n\t}\r\n\t// 恢复状态\r\n\trestore(memento: Memento | undefined | null) {\r\n\t\tif (memento) this.textContent = memento.getTextContent();\r\n\t}\r\n}\r\n\r\nclass MementoHistoryManager {\r\n\tmementos = new Map<string, Memento>();\r\n\tadd(describe: string, memento: Memento) {\r\n\t\tthis.mementos.set(describe, memento);\r\n\t}\r\n\tget(describe: string) {\r\n\t\treturn this.mementos.get(describe);\r\n\t}\r\n\tremove(describe: string) {\r\n\t\tthis.mementos.delete(describe);\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tconst editor = new TextEditor();\r\n\tconst history = new MementoHistoryManager();\r\n\r\n\teditor.typing(\"hi this is the init state.\"); // 输入内容\r\n\thistory.add(\"快照1\", editor.save()); // 保存为快照1\r\n\tconsole.log(editor); //TextEditor { context: 'hi this is the init state.' }\r\n\r\n\teditor.typing(\"hhhhhhhhhhhhhhhhhh.\"); // 输入内容\r\n\tconsole.log(editor); //TextEditor { context: 'hi this is the init state.hhhhhhhhhhhhhhhhhh.' }\r\n\thistory.add(\"快照2\", editor.save()); // 保存为快照2\r\n\r\n\teditor.restore(history.get(\"快照1\")); // 恢复快照1\r\n\tconsole.log(editor); //TextEditor { context: 'hi this is the init state.' }\r\n}\r\nmain();\r\n```\r\n\r\n## 行为型:_19_观察者模式\r\n\r\n```ts\r\n// 可观察对象\r\ninterface IObservable {\r\n\tadd(observer: IObserver): void;\r\n\tremove(observer: IObserver): void;\r\n\tnotify(): void;\r\n}\r\n// 观察者\r\ninterface IObserver {\r\n\tupdate(): void;\r\n}\r\n\r\n// 消息发布者\r\nclass MessagePublisher implements IObservable {\r\n\tcurrentMessage: string;\r\n\tconstructor() {\r\n\t\tsetInterval(() => {\r\n\t\t\tthis.currentMessage = \"hahaha\" + Date.now();\r\n\t\t\tconsole.log(\"被观察者：我发布了新消息:\" + this.currentMessage);\r\n\t\t\tthis.notify(); // 通知被观察者\r\n\t\t}, 500);\r\n\t}\r\n\t// 注册、移除、通知观察者的逻辑\r\n\tobservers: Set<IObserver> = new Set(); // 观察者集合\r\n\tadd(observer: IObserver): void {\r\n\t\t// 添加观察者\r\n\t\tthis.observers.add(observer);\r\n\t}\r\n\tremove(observer: IObserver): void {\r\n\t\t// 移除观察者\r\n\t\tthis.observers.delete(observer);\r\n\t}\r\n\tnotify(): void {\r\n\t\t// 通知所有观察者\r\n\t\tthis.observers.forEach(item => item.update());\r\n\t}\r\n}\r\n\r\n// 消息监听者\r\nclass MessageReceiver implements IObserver {\r\n\tconstructor(private target: MessagePublisher) {\r\n\t\tthis.target = target;\r\n\t\tthis.target.add(this);\r\n\t}\r\n\tupdate(): void {\r\n\t\tconsole.log(\"观察者：收到了被观察的消息推送：\" + this.target.currentMessage);\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tlet publisher = new MessagePublisher();\r\n\tlet receiver1 = new MessageReceiver(publisher);\r\n\tlet receiver2 = new MessageReceiver(publisher);\r\n}\r\n\r\nmain();\r\n```\r\n\r\n## 行为型:_20_状态模式\r\n\r\n```ts\r\nabstract class State {\r\n\tabstract doSomething(context: Context): void;\r\n\t// abstract inputHandler(context: Context): void; // 通过输入处理函数，可以实现只能从某种状态到某种状态的切换\r\n}\r\n\r\nclass Context {\r\n\tcurrentState: State = new InitState();\r\n\tchangeState(state: State): void {\r\n\t\tthis.currentState = state;\r\n\t}\r\n\tdoSomething(): void {\r\n\t\tthis.currentState.doSomething(this);\r\n\t}\r\n}\r\n\r\nclass TiredState extends State {\r\n\tdoSomething(context: Context): void {\r\n\t\tconsole.log(\"精疲力尽的做某事\");\r\n\t}\r\n}\r\nclass InitState extends State {\r\n\tdoSomething(context: Context): void {\r\n\t\tconsole.log(\"元气满满的做某事\");\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tconst someone = new Context();\r\n\tsomeone.doSomething();\r\n\tsomeone.changeState(new TiredState());\r\n\tsomeone.doSomething();\r\n}\r\nmain();\r\n```\r\n\r\n## 行为型:_21_策略模式\r\n\r\n```ts\r\n// 策略模式\r\nclass Animal {\r\n\tconstructor(\r\n\t\tprivate flyStrategy: FlyStrategy, // 行为是接口，具体什么行为由子类定义\r\n\t\tprivate jumpStrategy: JumpStrategy,\r\n\t\tprivate runStrategy: RunStrategy\r\n\t) {\r\n\t\tthis.flyStrategy = flyStrategy;\r\n\t\tthis.jumpStrategy = jumpStrategy;\r\n\t\tthis.runStrategy = runStrategy;\r\n\t}\r\n\tfly() {\r\n\t\tthis.flyStrategy.fly();\r\n\t}\r\n\tjump() {\r\n\t\tthis.jumpStrategy.jump();\r\n\t}\r\n\trun() {\r\n\t\tthis.runStrategy.run();\r\n\t}\r\n}\r\n// 飞行策略\r\ninterface FlyStrategy {\r\n\tfly(): void;\r\n}\r\ninterface JumpStrategy {\r\n\tjump(): void;\r\n}\r\ninterface RunStrategy {\r\n\trun(): void;\r\n}\r\n\r\n// 默认的飞行策略\r\nclass DefaultFlyStrategy implements FlyStrategy {\r\n\tfly() {\r\n\t\tconsole.log(\"Default Fly\");\r\n\t}\r\n}\r\n// 不会飞的飞行策略\r\nclass CantFlyStrategy implements FlyStrategy {\r\n\tfly() {\r\n\t\tconsole.log(\"Can't Fly\");\r\n\t}\r\n}\r\n\r\nclass DefaultJumpStrategy implements JumpStrategy {\r\n\tjump() {\r\n\t\tconsole.log(\"Default Jump\");\r\n\t}\r\n}\r\nclass CantJumpStrategy implements JumpStrategy {\r\n\tjump() {\r\n\t\tconsole.log(\"Can't Jump\");\r\n\t}\r\n}\r\n\r\nclass DefaultRunStrategy implements RunStrategy {\r\n\trun() {\r\n\t\tconsole.log(\"Default Run\");\r\n\t}\r\n}\r\nclass CantRunStrategy implements RunStrategy {\r\n\trun() {\r\n\t\tconsole.log(\"Can't Run\");\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tlet bird = new Animal(new DefaultFlyStrategy(), new DefaultJumpStrategy(), new CantRunStrategy());\r\n\tconsole.log(\"bird:\");\r\n\tbird.fly();\r\n\tbird.jump();\r\n\tbird.run();\r\n\r\n\tlet dog = new Animal(new CantFlyStrategy(), new DefaultJumpStrategy(), new DefaultRunStrategy());\r\n\tconsole.log(\"dog:\");\r\n\tdog.fly();\r\n\tdog.jump();\r\n\tdog.run();\r\n\r\n\tlet duck = new Animal(new DefaultFlyStrategy(), new CantJumpStrategy(), new CantRunStrategy());\r\n\tconsole.log(\"duck:\");\r\n\tduck.fly();\r\n\tduck.jump();\r\n\tduck.run();\r\n}\r\n\r\nmain();\r\n```\r\n\r\n## 行为型:_22_模板方法模式\r\n\r\n```ts\r\n// 模板方法是指：有某一系统按某规定顺序执行，但其中某一阶段的具体实现是未知的\r\n// 解决方法是使用抽象方法，或者使用hook钩子函数\r\nabstract class SomeSystem {\r\n\tprivate beforeStage2Hooks: Array<() => void> = []; // 钩子函数列表，私有化，防止被赋值为空数组\r\n\tprivate afterStage2Hooks: Array<() => void> = [];\r\n\tbeforeStage2(hook: () => void) {\r\n\t\t// beforeStage3钩子函数添加\r\n\t\tthis.beforeStage2Hooks.push(hook);\r\n\t}\r\n\tafterStage2(hook: () => void) {\r\n\t\tthis.afterStage2Hooks.push(hook);\r\n\t}\r\n\tprivate stage1() {\r\n\t\tconsole.log(\"stage1\");\r\n\t}\r\n\tprivate stage2() {\r\n\t\tconsole.log(\"stage2\");\r\n\t}\r\n\tabstract stage3(): void; // 阶段3 的具体实现是未知的\r\n\tprivate stage4() {\r\n\t\tconsole.log(\"stage4\");\r\n\t}\r\n\tstart() {\r\n\t\tthis.stage1();\r\n\t\tthis.beforeStage2Hooks.forEach(hook => hook()); // 执行某些注入的操作\r\n\t\tthis.stage2();\r\n\t\tthis.afterStage2Hooks.forEach(hook => hook()); // 执行某些注入的操作\r\n\t\tthis.stage3();\r\n\t\tthis.stage4();\r\n\t}\r\n}\r\n\r\nclass Subsystem extends SomeSystem {\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.beforeStage2(() => {\r\n\t\t\t// 通过钩子函数，实现在阶段2之前执行某些操作\r\n\t\t\tconsole.log(\"before stage2\");\r\n\t\t});\r\n\t}\r\n\tstage3() {\r\n\t\t// 给出阶段3的具体实现\r\n\t\tconsole.log(\"stage3\");\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tlet system = new Subsystem();\r\n\tsystem.afterStage2(() => {\r\n\t\t// 通过钩子函数，实现在阶段2之后执行某些操作\r\n\t\tconsole.log(\"after stage2\");\r\n\t});\r\n\tsystem.start(); // 启动系统\r\n}\r\nmain();\r\n```\r\n\r\n## 行为型:_23_访问者\r\n\r\n```ts\r\n// 访问者接口\r\ninterface PcPartVisiter {\r\n\tvisitDisplay(display: Display): void;\r\n\tvisitMouse(mouse: Mouse): void;\r\n\tvisitKeyBoard(keyBoard: KeyBoard): void;\r\n\tvisitDisk(disk: Disk): void;\r\n}\r\n\r\n// 具体访问者\r\nclass UpdatePackage implements PcPartVisiter {\r\n\tvisitDisplay(display: Display): void {\r\n\t\t// do something\r\n\t\tdisplay.version = \"v0.2\"; // 升级\r\n\t}\r\n\tvisitMouse(mouse: Mouse): void {\r\n\t\tmouse.version = \"v0.2\";\r\n\t}\r\n\tvisitKeyBoard(keyBoard: KeyBoard): void {\r\n\t\tkeyBoard.version = \"v0.2\";\r\n\t}\r\n\tvisitDisk(disk: Disk): void {\r\n\t\tdisk.version = \"v0.2\";\r\n\t}\r\n}\r\n\r\n// 电脑\r\nclass Computer {\r\n\tdisplay = new Display();\r\n\tmouse = new Mouse();\r\n\tkeyBoard = new KeyBoard();\r\n\tdisk = new Disk();\r\n\tupdate(visiter: PcPartVisiter) {\r\n\t\tthis.display.update(visiter);\r\n\t\tthis.mouse.update(visiter);\r\n\t\tthis.keyBoard.update(visiter);\r\n\t\tthis.disk.update(visiter);\r\n\t}\r\n}\r\n\r\ninterface ComputerPart {\r\n\tversion: string;\r\n\tupdate(visiter: PcPartVisiter): void;\r\n}\r\nclass Display implements ComputerPart {\r\n\tversion = \"v0.1\";\r\n\tupdate(visiter: PcPartVisiter): void {\r\n\t\tvisiter.visitDisplay(this);\r\n\t}\r\n}\r\nclass Mouse implements ComputerPart {\r\n\tversion = \"v0.1\";\r\n\tupdate(visiter: PcPartVisiter): void {\r\n\t\tvisiter.visitMouse(this);\r\n\t}\r\n}\r\nclass KeyBoard implements ComputerPart {\r\n\tversion = \"v0.1\";\r\n\tupdate(visiter: PcPartVisiter): void {\r\n\t\tvisiter.visitKeyBoard(this);\r\n\t}\r\n}\r\nclass Disk implements ComputerPart {\r\n\tversion = \"v0.1\";\r\n\tupdate(visiter: PcPartVisiter): void {\r\n\t\tvisiter.visitDisk(this);\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tconst computer = new Computer();\r\n\tconsole.log(computer);\r\n\r\n\tcomputer.update(new UpdatePackage());\r\n\tconsole.log(computer);\r\n}\r\n\r\nmain();\r\n```\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>\r\n"}