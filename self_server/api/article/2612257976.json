{"shortInfo":{"title":"promise学习笔记","date":"2022-07-17T23:38:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["promise"],"hideAtIndex":true,"categories":"笔记","id":2612257976,"countWords":5429,"readSeconds":542.9,"assetsbaseUrl":"/self_server/assets/"},"content":"## 简介\r\n* promise对象是ES6（ECMAscript 6 ）引入的用于**异步编程**的**新**解决方案\r\n  * **旧**方法单纯使用回调函数\r\n  * **新**方法使用promise\r\n* 从语法上来说就是一个构造函数，用来封装异步的任务，并能对结果进行处理\r\n* promise在app、web中应用广泛；\r\n* 前端和后端都会用到；\r\n* 也是面试高频题目，进大厂需要掌握其内部原理\r\n* Promise支持链式操作，能够解决**回调地狱问题**\r\n* promise指定回调函数非常灵活，\r\n  * 旧方法必须在启动异步任务前指定回调函数`setTimeout(()=>{},2000)`\r\n  * promise方法可以在启动异步任务后指定回调函数\r\n\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**常见异步操作**\r\n* 定时器\r\n    ```js\r\n    //旧方法\r\n    setTimeout(()=>{},2000)\r\n    ```\r\n* ajax\r\n    ```js\r\n    //旧方法\r\n    $.get(\"./path/to/file\",(data)=>{})\r\n    ```\r\n* 数据库操作\r\n* fs文件操作\r\n    ```js\r\n    require(\"fs\").readFile(\"./file\",(error,data)=>{})\r\n    ```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**回调地狱问题**\r\n* **旧**方法单纯使用回调函数，需反复嵌套，不支持链式操作\r\n* 不利于阅读\r\n* 不便于错误处理\r\n```js\r\nfunctionA(args,(err,data)=>{\r\n    functionB(args,(err,data)=>{\r\n        functionC(args,(err,data)=>{\r\n            functionE(args,(err,data)=>{\r\n                functionF(args,(err,data)=>{\r\n                })\r\n            })\r\n        })\r\n    })\r\n})\r\n\r\n```\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**箭头函数**\r\n* `()=>{}`\r\n* ES6标准\r\n* 箭头函数中形参若只有一个则可以省略小括号\r\n* 箭头函数中的`this`始终指向该函数的创建环境，而不是其调用者\r\n* 箭头函数不能定义构造函数\r\n* 箭头函数显式定义需要变量关键字`var`、`let`、`const`，由于变量提升的特性，所以必须先定义声明再调用该函数\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**关于let**\r\n* `let`命令是ES6 新增的，用来声明变量。\r\n* `let`声明的变量只在局部作用域内有效，可用在`for`循环中\r\n* 不存在变量提升，必须先声明后使用，否则报错\r\n\r\n\r\n\r\n## promise的状态\r\n* promise状态是promise实例对象中的一个属性\r\n* 属性名为PromiseState\r\n* 该属性是一个内置属性，不能直接对其进行操作\r\n* 属性值有三种状态\r\n    * pending 未定义的初始状态\r\n    * resolved、fullfilled 成功的状态\r\n    * rejected 失败的状态\r\n* 属性的三种状态只有两种变化过程\r\n    * pending -> resolved\r\n    * pending -> rejected\r\n    * 不能由失败、成功变为未定义状态\r\n    * 不能由失败变成功，也不能由成功变失败\r\n* 属性的状态只能改变一次\r\n\r\n## promise的结果\r\n* promise结果是promise实例对象中的一个属性\r\n* 属性名为`PromiseResult`\r\n* 该属性是一个内置属性，不能直接对其进行操作\r\n* 只有函数`resolve(valure)`、`reject(reason)` 能对其值进行修改\r\n* 属性值有三种状态\r\n\r\n## 基本使用\r\n* `new Promise((resolve,reject)=>{})`构造函数的第一个形参是一个函数，该函数又接收了两个参数resolve和reject，这两个参数也是函数\r\n* `resolve()`调用完毕后会将promise对象状态设置为**成功**\r\n* `reject()`调用完毕后会将promise对象状态设置为**失败**\r\n* `promiseObj.then()`函数有两个形式参数，都是函数，\r\n    * 当promise对象状态为成功时执行第一个回调函数，为失败时执行第二个回调函数\r\n    * 第一个函数其形参value为resolve传递过来的参数\r\n    * 第二个函数其形参reason为reject传递过来的参数\r\n\r\n**新旧两种解决方案的对比**\r\n\r\n<div id=\"demo23r023jfr02\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btn = document.querySelector(\"#demo23r023jfr02>button\")\r\n    var p = document.querySelector(\"#demo23r023jfr02>p\")\r\n    btn.addEventListener(\"click\",function(){\r\n        setTimeout(function(){//模拟服务端延迟\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30)// r落在0~30区间的概率为30%if(accurate(30))\r\n                    p.innerHTML+=\"恭喜中奖\"\r\n                else\r\n                    p.innerHTML+=\"再接再厉\"\r\n        },1000)\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demo23r023jfr02\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btn = document.querySelector(\"#demo23r023jfr02>button\")\r\n    var p = document.querySelector(\"#demo23r023jfr02>p\")\r\n    btn.addEventListener(\"click\",function(){\r\n        setTimeout(function(){//模拟服务端延迟\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30)// r落在0~30区间的概率为30%if(accurate(30))\r\n                    p.innerHTML+=\"恭喜中奖\"\r\n                else\r\n                    p.innerHTML+=\"再接再厉\"\r\n        },1000)\r\n    })\r\n</script>\r\n```\r\n\r\n<div id=\"demo12312312qq\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btnn = document.querySelector(\"#demo12312312qq>button\");\r\n    var pp = document.querySelector(\"#demo12312312qq>p\");\r\n    btnn.addEventListener(\"click\",function(){\r\n        //Promise构造函数的第一个形参是一个函数，该函数又接收了两个参数resolve和reject，这两个参数也是函数\r\n        const promise = new Promise((resolve,reject)=>{\r\n            setTimeout(()=>{\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30){ // r落在0~30区间的概率为30%\r\n                    resolve(r) //调用完毕后会将promise对象状态设置为**成功**\r\n                }else{\r\n                    reject(r) //调用完毕后会将promise对象状态设置为**失败**\r\n                }\r\n            },1000);\r\n        })\r\n        //then函数有两个形式参数，都是函数，\r\n        //当promise对象状态为成功时执行第一个回调函数，为失败时执行第二个回调函数\r\n        //第一个函数其形参value为resolve传递过来的参数\r\n        //第二个函数其形参reason为reject传递过来的参数\r\n        promise.then((value)=>{\r\n            pp.innerHTML+=\"恭喜中奖\"+value\r\n        },(reason)=>{\r\n            pp.innerHTML+=\"再接再厉\"+reason\r\n        });\r\n    });\r\n</script>\r\n\r\n```html\r\n<div id=\"demo12312312qq\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btnn = document.querySelector(\"#demo12312312qq>button\");\r\n    var pp = document.querySelector(\"#demo12312312qq>p\");\r\n    btnn.addEventListener(\"click\",function(){\r\n        //Promise构造函数的第一个形参是一个函数，该函数又接收了两个参数resolve和reject，这两个参数也是函数\r\n        const promise = new Promise((resolve,reject)=>{\r\n            setTimeout(()=>{\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30){ // r落在0~30区间的概率为30%\r\n                    resolve(r) //调用完毕后会将promise对象状态设置为**成功**\r\n                }else{\r\n                    reject(r) //调用完毕后会将promise对象状态设置为**失败**\r\n                }\r\n            },1000);\r\n        })\r\n        //then函数有两个形式参数，都是函数，\r\n        //当promise对象状态为成功时执行第一个回调函数，为失败时执行第二个回调函数\r\n        //第一个函数其形参value为resolve传递过来的参数\r\n        //第二个函数其形参reason为reject传递过来的参数\r\n        promise.then((value)=>{\r\n            pp.innerHTML+=\"恭喜中奖\"+value\r\n        },(reason)=>{\r\n            pp.innerHTML+=\"再接再厉\"+reason\r\n        });\r\n    });\r\n</script>\r\n```\r\n\r\n## 用promise封装fs\r\n\r\n**promise封装前**\r\n```js\r\nconst fs = require(\"fs\");\r\nfs.readFile(\"./path/to/fileName\",(err,data)=>{\r\n    if(err) throw err;//异常处理\r\n    console.log(data.toString());//数据处理\r\n})\r\n```\r\n\r\n**promise封装后**\r\n```js\r\nconst fs = require(\"fs\");\r\n\r\nconst p = new Promise((resolve,reject)={\r\n    fs.readFile(\"./path/to/fileName\",(err,data)=>{\r\n        if(err)\r\n            reject(err);\r\n        else\r\n            resolve(data)\r\n    })\r\n})\r\n\r\n// 使用\r\np.then(value=>{// 形式参数只有一个，箭头函数的括号可省略\r\n    console.log(value.toString();//数据处理\r\n},reason=>{\r\n    throw reason;//异常处理\r\n})\r\n```\r\n\r\n**手动用promise将fs封装为一个函数**\r\n```js\r\n\r\nfunction myreadFile(path){\r\n    return new Promise((resolve,reject)={\r\n        require(\"fs\").readFile(path,(err,data)=>{\r\n            if(err)\r\n                reject(err);\r\n            else\r\n                resolve(data)\r\n        })\r\n    })\r\n}\r\n\r\n// 使用\r\nmyreadFile(\"./path/to/file\")\r\n.then(value=>{\r\n    console.log(value.toString());\r\n},reason=>{\r\n    console.log(reason);\r\n})\r\n```\r\n\r\n**通过util.promisify获取已经使用promise封装好的fs函数**\r\n```js\r\nconst util = require(\"util\")\r\nconst fs = require(\"fs\")\r\n\r\nfunction myreadFile = util.promisify(fs.readFile)\r\n\r\n// 使用\r\nmyreadFile(\"./path/to/file\")\r\n.then(value=>{\r\n    console.log(value.toString());\r\n},reason=>{\r\n    console.log(reason);\r\n})\r\n```\r\n\r\n\r\n## 用promise封装ajax\r\n\r\n**promise封装前**\r\n\r\n<div id=\"demofjwif02\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif02>button\").click(function(){\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\",\"https://api.apiopen.top/api/sentences\")\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function(){\r\n            if(xhr.readyState===4){\r\n                // 判断响应状态码\r\n                if(xhr.status>=200&&xhr.status<300){\r\n                    $(\"#demofjwif02>p\").text(xhr.response)\r\n                }else{\r\n                    $(\"#demofjwif02>p\").text(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n\r\n```js\r\n<div id=\"demofjwif02\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif02>button\").click(function(){\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\",\"https://api.apiopen.top/api/sentences\")\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function(){\r\n            if(xhr.readyState===4){\r\n                // 判断响应状态码\r\n                if(xhr.status>=200&&xhr.status<300){\r\n                    $(\"#demofjwif02>p\").text(xhr.response)\r\n                }else{\r\n                    $(\"#demofjwif02>p\").text(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n```\r\n\r\n**promise封装后**\r\n\r\n<div id=\"demofjwif021231\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif021231>button\").click(function(){\r\n        const promise = new Promise((resolve,reject)=>{\r\n            //创建对象\r\n            const xhr = new XMLHttpRequest();\r\n            // 初始化\r\n            xhr.open(\"GET\", \"https://api.apiopen.top/api/sentences\")\r\n            // 发送\r\n            xhr.send();\r\n            // 处理响应结果\r\n            xhr.onreadystatechange = function () {\r\n                if (xhr.readyState === 4) {\r\n                    // 判断响应状态码\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        resolve(xhr.response)\r\n                    } else {\r\n                        reject(xhr.status)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n        promise.then(response=>{\r\n            $(\"#demofjwif021231>p\").text(response)\r\n        },states=>{\r\n            $(\"#demofjwif021231>p\").text(states)\r\n        })\r\n    })\r\n</script>\r\n\r\n```js\r\n<div id=\"demofjwif021231\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif021231>button\").click(function(){\r\n        const promise = new Promise((resolve,reject)=>{\r\n            //创建对象\r\n            const xhr = new XMLHttpRequest();\r\n            // 初始化\r\n            xhr.open(\"GET\", \"https://api.apiopen.top/api/sentences\")\r\n            // 发送\r\n            xhr.send();\r\n            // 处理响应结果\r\n            xhr.onreadystatechange = function () {\r\n                if (xhr.readyState === 4) {\r\n                    // 判断响应状态码\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        resolve(xhr.response)\r\n                    } else {\r\n                        reject(xhr.status)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n        promise.then(response=>{\r\n            $(\"#demofjwif021231>p\").text(response)\r\n        },states=>{\r\n            $(\"#demofjwif021231>p\").text(states)\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n**用promise将ajex封装为一个函数**\r\n\r\n```js\r\nfunction sendAjax(url){\r\n    return new Promise((resolve,reject)=>{\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\", url)\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function () {\r\n            if (xhr.readyState === 4) {\r\n                // 判断响应状态码\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(xhr.response)\r\n                } else {\r\n                    reject(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n// 使用\r\nsendAjax(\"https://api.apiopen.top/api/sentences\")\r\n.then(vaule=>{\r\n    console.log(vaule)\r\n},reason=>{\r\n    console.warm(reason)\r\n})\r\n```\r\n\r\n## APIs\r\n\r\n**`new Promise(executor);`构造函数**\r\n* 形参`executor`是一个函数， 称为**执行器**，写为`(resolve,reject)=>{}`\r\n* 执行器的形参resolve，是一个函数，写在执行器函数中，执行器执行成功时调用\r\n* 执行器的形参reject，是一个函数，写在执行器函数中，执行器执行失败时调用\r\n* 执行器中的语句是随构造函数同步执行的\r\n    ```js\r\n    // 1111 2222 顺序输出\r\n    let p = new Promise((rosolve,reject)=>{\r\n        console.log(\"1111\")\r\n    })\r\n    console.log(\"2222\")\r\n    ```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.prototype.then(onResolved,onRejected);`方法**\r\n* onResolved 成功的回调函数 写为`(value)=>{}`\r\n* onRejected 失败的回调函数 写为`(reason)=>{}`\r\n* 返回值是一个新的Promise对象\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.prototype.cache(onRejected);`方法**\r\n* onRejected 失败的回调函数 写为`(reason)=>{}`\r\n* 该函数内部由then()封装实现\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.resolve(value);`方法**\r\n* 该方法是Promise对象的内置方法，不是实例化后的对象的方法\r\n* 该方法用来快速获取一个Promise实例对象，并且给其封装一个值和状态\r\n* 该方法返回值是一个promise实例对象\r\n* 当value值是一个非promise类型的对象时，返回的结果为成功的promise对象\r\n* 当value值是一个promise类型的对象时，返回的promise对象的结果（result、成功与否）与传入的promise对象的结果一致\r\n```js\r\nvar p = Promise.resolve(123)\r\nconsole.log(p)//p是一个promise对象，其结果为成功，值为123\r\n\r\nvar k = Promise.resolve(new Promise((resolve,reject)=>{\r\n    resolve(\"成功AAA\")\r\n}))\r\n\r\nconsole.log(k) // k是一个promise对象，其结果为成功，值为“成功AAA”\r\n\r\nvar k = Promise.resolve(new Promise((resolve,reject)=>{\r\n    reject(\"失败BBB\")\r\n}))\r\n\r\nconsole.log(k) // k是一个promise对象，其结果为失败，值为“失败BBB”\r\n//且由于k是一个失败的Promise对象，也没有处理失败的回调，所以会报错\r\n//解决：\r\nk.cach(reason=>{//对失败进行处理\r\n    console.log(reason)\r\n})\r\n```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.reject(value);`方法**\r\n* 和resolve基本一致，\r\n* 但是该函数不论传入的promise对象的状态是成功还是失败，其返回的promise对象的状态是失败，值为传入的promise对象\r\n* 也就是说该函数永远返回一个失败的promise，其值为传入的value值，无论传入的是否为一个Promise对象\r\n\r\n```js\r\nvar j = new Promise((resolve,reject)=>{\r\n    resolve(\"成功AAA\")\r\n})\r\nvar k = Promise.resolve(j)\r\n\r\nconsole.log(k) // k是一个promise对象，其结果为失败，其值为j，也就是为传入的成功的promise对象\r\n```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.all(promises);`方法**\r\n* 基本同上；\r\n* 用于返回一个Promise对象，状态由promises决定\r\n* promises是一个数组，包含多个promise对象，\r\n* 若promises中有一个promise对象为失败，则该函数返回的Promise对象的状态为失败，且该对象的结果为数组中的这个Promise对象本身\r\n* 仅当promises都为成功时，该函数返回的Promise对象的状态为成功，且该对象的结果是由数组中每个Promise对象的结果组成的数组\r\n\r\n```js\r\nvar p1 = new Promise((resolve,reject)=>{\r\n    resolve(\"成功结果1\")\r\n})\r\nvar p2 = Promise.resolve(\"成功结果2\")\r\nvar p3 = Promise.resolve(\"成功结果3\")\r\n\r\nvar pk = Promise.all([p1,p2,p3]);\r\nconsole.log(pk)\r\n```\r\n结果：  \r\n![](./images/promise学习笔记/2022-07-18-15-36-38.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve,reject)=>{\r\n    resolve(\"成功结果1\")\r\n})\r\nvar p2 = Promise.reject(\"失败结果2\")\r\nvar p3 = Promise.resolve(\"成功结果3\")\r\n\r\nvar pk = Promise.all([p1,p2,p3]);\r\nconsole.log(pk)\r\n```\r\n结果：  \r\n![](./images/promise学习笔记/2022-07-18-15-41-47.png)\r\n\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.race(promises);`方法**\r\n* 返回的的是promises中第一个改变状态的promsie\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n        resolve(\"成功结果1\")\r\n    }, 1000);\r\n})\r\nvar p2 = Promise.resolve(\"成功结果2\")\r\nvar p3 = Promise.resolve(\"成功结果3\")\r\nvar pk = Promise.race([p1, p2, p3]);\r\nconsole.log(pk)\r\n```\r\n\r\n结果：  \r\n![](./images/promise学习笔记/2022-07-18-15-53-23.png)\r\n\r\n\r\n## 关键问题\r\n\r\n**修改对象的状态的三种方式**\r\n* 在执行器函数中执行`resolve()` pending -> fulfilled/resolved\r\n* 在执行器函数中执行`reject()` pending -> rejected\r\n* 在执行器函数中抛出错误`throw \"字符串或error实例对象\";` pending -> rejected\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"成功结果1\")\r\n    reject(\"失败结果1\")\r\n    throw \"失败结果2\";\r\n})\r\nconsole.log(p1)\r\n```\r\n![](./images/promise学习笔记/2022-07-18-20-44-07.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**指定的多个回调都会执行**\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果\")\r\n})\r\nconsole.log(p1)\r\np1.then(value => {\r\n    console.log(\"执行了成功回调函数1,result为：\" + value)\r\n})\r\np1.then(value => {\r\n    console.log(\"执行了成功回调函数2,result为：\" + value)\r\n})\r\n```\r\n![](./images/promise学习笔记/2022-07-18-20-51-29.png)\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**改变状态和指定回调的then()函数执行顺序的问题**\r\n* 当改变状态的语句在执行器中被**同步**执行时，执行顺序是 改变状态 -> 指定回调函数 -> 执行回调函数\r\n* 当改变状态的语句在执行器中被**异步**执行时，执行顺序是 指定回调函数 -> 改变状态 -> 执行回调函数\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    console.log(\"即将执行改变状态的函数resolve()\");\r\n    resolve(\"这是成功的结果\")\r\n    console.log(\"resolve() 执行完毕\");\r\n})\r\n\r\nconsole.log(\"即将执行指定回调函数的函数then()\");\r\np1.then(value => {\r\n    console.log(\"执行了成功的回调函数，结果为:\"+ value)\r\n})\r\nconsole.log(\"then() 执行完毕\");\r\n```\r\n![](./images/promise学习笔记/2022-07-18-21-31-42.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    console.log(\"即将执行执行器中的代码\");\r\n    setTimeout(() => {\r\n        console.log(\"即将执行改变状态的函数resolve()\");\r\n        resolve(\"这是成功的结果\")\r\n        console.log(\"resolve() 执行完毕\");\r\n    }, 1000);\r\n    console.log(\"执行器中的代码执行完毕\");\r\n})\r\nconsole.log(\"即将执行指定回调函数的函数then()\");\r\np1.then(value => {\r\n    console.log(\"执行了成功的回调函数，结果为:\"+ value)\r\n})\r\nconsole.log(\"then() 执行完毕\");\r\n```\r\n\r\n![](./images/promise学习笔记/2022-07-18-21-40-21.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**then()方法的返回值问题**\r\n* 若回调函数抛出了异常，则then的返回值是一个promise对象，状态为失败，result为抛出的异常\r\n* 若回调函数的返回值是非promise对象，则then的返回值是一个promise对象，状态为成功，result为该返回值\r\n* 若回调函数的返回值是promise对象，则then的返回值是一个promise对象，状态为失败，result为该对象的result值\r\n* 若回调函数没有返回值，则then的返回值是一个promise对象，状态为成功，result为undefined\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果\")\r\n})\r\nvar k = p1.then(value => {\r\n    throw \"抛出异常\"\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-21-31.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果\")\r\n})\r\nvar k = p1.then(value => {\r\n    return 521;\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-16-14.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果1\")\r\n})\r\nvar k = p1.then(value => {\r\n    return new Promise((resolve,reject)=>{\r\n        resolve(\"这是成功的结果2\")\r\n    })\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-23-01.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果1\")\r\n})\r\nvar k = p1.then(value => {\r\n    return new Promise((resolve,reject)=>{\r\n        resolve(\"这是失败的结果1\")\r\n    })\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-24-00.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果1\")\r\n})\r\nvar k = p1.then(value => {\r\n    console.log(\"执行了成功回调函数，且没有返回值\")\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-37-37.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**promise串联多个任务**\r\n* 由于then()的返回值是一个promsie对象，所以可以通过then().then()的方式实现\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是Promise1的成功结果\")\r\n})\r\np1\r\n.then(value => {\r\n    console.log(\"这是Promise1的成功的回调函数 ，获取到的value是：\", value)\r\n    return new Promise((resolve, reject) => {\r\n        resolve(\"这是Promise2的成功结果\")\r\n    })\r\n}).then(value => {\r\n    console.log(\"这是Promise2的成功的回调函数 ，获取到的value是：\", value)\r\n    return new Promise((resolve, reject) => {\r\n        resolve(\"这是Promise3的成功结果\")\r\n    })\r\n}).then(value => {\r\n    console.log(\"这是Promise3的成功的回调函数 ，获取到的value是：\", value)\r\n}).then(value => {\r\n    console.log(\"这是Promise4的成功的回调函数 ，获取到的value是：\", value)\r\n})\r\n```\r\n![](./images/promise学习笔记/2022-07-18-23-16-20.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**异常穿透现象(或者说功能)**\r\n* 可以把异常处理的回调函数写在最后，能够对串联的所有回调函数中的异常进行处理\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是Promise1的成功结果\")\r\n})\r\np1\r\n    .then(value => {\r\n        console.log(\"这是Promise1的成功的回调函数 ，获取到的value是：\", value)\r\n        return new Promise((resolve, reject) => {\r\n            resolve(\"这是Promise2的成功结果\")\r\n        })\r\n    }).then(value => {\r\n        console.log(\"这是Promise2的成功的回调函数 ，获取到的value是：\", value)\r\n        return new Promise((resolve, reject) => {\r\n            // resolve(\"这是Promise3的成功结果\")\r\n            reject(\"这是Promise3的失败结果\")\r\n        })\r\n    }).then(value => {\r\n        console.log(\"这是Promise3的成功的回调函数 ，获取到的value是：\", value)\r\n    }).then(value => {\r\n        console.log(\"这是Promise4的成功的回调函数 ，获取到的value是：\", value)\r\n    }).catch(reason => {\r\n        console.warn(\"这是串联的所有回调函数的异常处理回调函数，获取到的reason为\", reason)\r\n    })\r\n```\r\n\r\n![](./images/promise学习笔记/2022-07-18-23-34-16.png)\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**中断Promise的链式调用**\r\n* 有且只有一种方式，那就是在回调函数中返回一个pending状态的promise实例对象\r\n* 因为then(()=>{})函数中的回调函数无论返回什么都会被封装成一个promise函数，用来交给下一个then来进行处理，若返回的是pending状态的promise对象，那么后续then中的回调函数就不会被触发\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    console.log(\"1111111111111111111\")\r\n    resolve(\"这是Promise1的成功结果\")\r\n})\r\np1\r\n    .then(value => {\r\n        console.log(\"222222222222222222\")\r\n        return new Promise((resolve, reject) => {\r\n            resolve(\"这是Promise2的成功结果\")\r\n        })\r\n    }).then(value => {\r\n        console.log(\"333333333333333333,中断链式调用，返回了一个pending状态的promise\")\r\n        return new Promise((resolve, reject) => {})\r\n    }).then(value => {\r\n        console.log(\"4444444444444444444444\")\r\n    }).then(value => {\r\n        console.log(\"55555555555555555555555\")\r\n    }).catch(reason => {\r\n        console.warn(\"err\")\r\n    })\r\n```\r\n![](./images/promise学习笔记/2022-07-19-00-03-08.png)\r\n\r\n\r\n\r\n\r\n## 手写实现promsie全部功能\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## async 与 await\r\n**async关键字**\r\n* 经async关键字修饰后的函数的返回值是一个promsie对象\r\n* 该promise对象的状态和结果由该函数的return值决定\r\n    * 若该函数抛出错误已,则该函数返回一个状态为失败的promsie，且其结果为抛出的错误值\r\n    * 若该函数return一个非promise对象,则该函数返回一个状态为成功的promsie，且其结果为return的值\r\n    * 若该函数return一个promise对象\r\n        * 若该对象状态为成功 则返回的promise状态也为成功，且结果为返回的promsie对象的结果\r\n        * 若该对象状态为失败 则返回的promise状态也为失败，且结果为返回的promsie对象的结果\r\n        * 若该对象状态为pending 则返回的promise状态也为pending，且结果为undefined\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**await关键字**\r\n* `await`必须写在经`async`修饰后的函数中，但`async`修饰的函数中可以没有await\r\n* 如果`await`获得的`promsie`**失败**，则**抛出异常**，需`try{}cach{}`捕获\r\n* 如果`await`获得的`promise`**成功**，则返回该**promise成功的结果值**result\r\n* 如果`await`获得的是**非promsie对象**，则返回的就是**该非promise对象**\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n**async与await结合的执行顺序问题**\r\n```js\r\nasync function main() {\r\n    var promiseA = new Promise((resolve, reject) => {\r\n        console.log(\"执行器执行\");\r\n        setTimeout(() => {\r\n            console.log(\"执行器中的异步函数执行\");\r\n            resolve(123)\r\n        }, 1000);\r\n    })\r\n    try {\r\n        console.log(\"promiseA状态：\");\r\n        console.log(promiseA);\r\n        console.log(\"await promiseA\");\r\n        var result = await promiseA;\r\n        console.log(\"获取到promiseA的result:\");\r\n        console.log(result);\r\n        console.log(\"执行return\");\r\n        return result;\r\n    } catch (e) {\r\n        return e;\r\n    }\r\n}\r\nconsole.log(\"调用async修饰的函数\");\r\nlet result = main()\r\nconsole.log(\"调用async修饰的函数结束\");\r\nconsole.log(\"async修饰的函数结果为\");\r\nconsole.log(result);\r\n```\r\n![](./images/promise学习笔记/2022-07-19-10-37-38.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n**async于await结合案例之文件操作**\r\n\r\n\r\n回调函数方式文件操作，合并三个文件\r\n```js\r\nconst fs = require(\"fs\")\r\nfs.readFile(\"./path/to/file1\",(err,data1)=>{\r\n    if(err) throw err;\r\n    fs.readFile(\"./path/to/file2\",(err,data2)=>{\r\n        if(err) throw err;\r\n        fs.readFile(\"./path/to/file3\",(err,data3)=>{\r\n            if(err) throw err;\r\n            console.log(data1+data2+data3)\r\n        })\r\n    })\r\n})\r\n\r\n```\r\n\r\nasync于await结合方式合并三个文件\r\n\r\n```js\r\nconst fs = require(\"fs\")\r\nconst util = require(\"util\")\r\nconst myReadFile = util.promisify(fs.readFile);\r\n\r\n(async function{\r\n    try{\r\n      let data1 = await myReadFile(\"./path/to/file1\")\r\n      let data2 = await myReadFile(\"./path/to/file2\")\r\n      let data3 = await myReadFile(\"./path/to/file3\")\r\n      console.log(data1+data2+data3)\r\n    }cache(e){\r\n        console.log(\"文件打开失败\")\r\n    }\r\n})();\r\n\r\n```\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**async与await结合案例之发送AJAX**\r\n\r\n\r\n\r\n需要用到之前写的用Promise封装好的sendAjax函数\r\n```js\r\nfunction sendAjax(url){\r\n    return new Promise((resolve,reject)=>{\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\", url)\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function () {\r\n            if (xhr.readyState === 4) {\r\n                // 判断响应状态码\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(xhr.response)\r\n                } else {\r\n                    reject(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n// 使用\r\nsendAjax(\"https://api.apiopen.top/api/sentences\")\r\n.then(vaule=>{\r\n    console.log(vaule)\r\n},reason=>{\r\n    console.warm(reason)\r\n})\r\n```\r\n\r\n有了这个封装好的函数，再结合async与await，就可以实现下列操作\r\n\r\n\r\n\r\n<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"\r\n    integrity=\"sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=\" crossorigin=\"anonymous\"></script>\r\n<div id=\"demofjwi123131f334\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwi123131f334>button\").click(async function () {\r\n        var result = await sendAjax(\"https://api.apiopen.top/api/sentences\")\r\n        $(\"#demofjwi123131f334>p\").text(result)\r\n    })\r\n    function sendAjax(url) {\r\n        return new Promise((resolve, reject) => {\r\n            //创建对象\r\n            const xhr = new XMLHttpRequest();\r\n            // 初始化\r\n            xhr.open(\"GET\", url)\r\n            // 发送\r\n            xhr.send();\r\n            // 处理响应结果\r\n            xhr.onreadystatechange = function () {\r\n                if (xhr.readyState === 4) {\r\n                    // 判断响应状态码\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        resolve(xhr.response)\r\n                    } else {\r\n                        reject(xhr.status)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n</script>\r\n\r\n```js\r\n<div id=\"demofjwi123131f334\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwi123131f334>button\").click(async function () {  //async修饰\r\n        var result = await sendAjax(\"https://api.apiopen.top/api/sentences\") //await等待\r\n        $(\"#demofjwi123131f334>p\").text(result)\r\n    })\r\n</script>\r\n```"}