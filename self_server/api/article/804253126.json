{"shortInfo":{"title":"你画我猜简易版实现","date":"2023-01-26T18:28:00.000Z","cover":"\\self_server\\assets\\images\\default\\2023-01-30-03-07-51.png","tags":["笔记","帧同步","socket","socket.io","demo","game","你画我猜"],"categories":"笔记","id":804253126,"countWords":1118,"readSeconds":111.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# 你画我猜简易版实现\r\n\r\n## 目录\r\n\r\n- [你画我猜简易版实现](#你画我猜简易版实现)\r\n\t- [目录](#目录)\r\n\t- [实现效果记录](#实现效果记录)\r\n\t- [服务端可复用代码](#服务端可复用代码)\r\n\t- [客户端部分代码实现](#客户端部分代码实现)\r\n\t- [画板的实现](#画板的实现)\r\n\r\n## 实现效果记录\r\n\r\n![](./images/default/2023-01-30-03-04-12.png)\r\n\r\n![](./images/default/2023-01-30-03-05-34.png)\r\n\r\n![](./images/default/2023-01-30-03-06-02.png)\r\n\r\n![](./images/default/2023-01-30-03-07-51.png)\r\n\r\n![](./images/default/2023-01-30-03-08-07.png)\r\n\r\n![](./images/default/2023-01-30-03-08-17.png)\r\n\r\n## 服务端可复用代码\r\n\r\n```js\r\nimport path from \"path\";\r\nimport createExpress, { static as _static } from \"express\";\r\nimport http from \"http\";\r\nimport { Server } from \"socket.io\";\r\nimport { GameServer } from \"./GameServer.js\";\r\n\r\nconst express = createExpress();\r\nconst httpServer = http.createServer(express);\r\nconst socketServer = new Server(httpServer);\r\nconst gameServer = new GameServer(socketServer); //游戏服务器,接收一个socket服务器\r\n\r\nexpress.use(_static(path.resolve(__dirname, \"../dist/\"))); // 静态页面\r\ngameServer.run(); // 游戏服务器\r\n\r\nhttpServer.listen(3000, () => {\r\n\tconsole.log(\"listening on *:3000\");\r\n});\r\n```\r\n\r\n## 客户端部分代码实现\r\n\r\n```js\r\nimport { Whiteboard } from \"@/Whiteboard\";\r\nimport type { Socket } from \"socket.io-client\";\r\n\r\nexport class GameClient implements Observable {\r\n  connect = false;\r\n  username = \"\";\r\n  usernames: Array<string> = [];\r\n  isRunning: boolean = false;\r\n  lines: any[] = [];\r\n  line_buffer: any;\r\n  master: string | undefined;\r\n  isMaster: boolean;\r\n  whiteboard: Whiteboard = new Whiteboard();\r\n  constructor(private socket: Socket) {\r\n    this.socket = socket;\r\n  }\r\n\r\n  async update() {\r\n    this.usernames = await this.reqGetUserList();\r\n    this.isRunning = await this.reqGetGameState();\r\n    this.lines = await this.reqGetLines();\r\n    this.master = await this.reqGetMaster();\r\n    if (this.username == this.master) this.isMaster = true;\r\n    else this.isMaster = false;\r\n    this.whiteboard.afterUpdate = () => {\r\n      if (this.isRunning && this.isMaster) {\r\n        this.lines = this.whiteboard.lines;\r\n        this.line_buffer = this.whiteboard.lineBuffer;\r\n        this.updateLines([...this.lines, this.line_buffer]);\r\n      } else {\r\n        this.whiteboard.lines = this.lines;\r\n      }\r\n    };\r\n  }\r\n\r\n  async becomeMaster() {\r\n    return await this.reqBecomeMaster();\r\n  }\r\n  async startGame(answer: string) {\r\n    return await this.reqStartGame(answer);\r\n  }\r\n  async updateLines(lines: any[]) {\r\n    return await this.reqUpdateLines(lines);\r\n  }\r\n  async guessAnswer(answer: string) {\r\n    return await this.reqGuessAnswer(answer);\r\n  }\r\n\r\n  public async login(username: string): Promise<boolean> {\r\n    if (await this.reqLogin(username)) {\r\n      this.username = username;\r\n      this.Notify();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  public async logout(): Promise<boolean> {\r\n    if (await this.reqLogout()) {\r\n      this.username = \"\";\r\n      this.Notify();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  public async isLogin(): Promise<boolean> {\r\n    if (await this.reqIsLogin()) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // 更新数据\r\n  private async reqGetUserList(): Promise<typeof this.usernames> {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"getUserList\", (result: Array<string>) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n  private async reqGetGameState(): Promise<boolean> {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"getGameState\", (result: boolean) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n  private async reqGetLines(): Promise<Array<any>> {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"getLines\", (result: Array<any>) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n  private async reqGetMaster(): Promise<string> {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"getMaster\", (result: string) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n  private async reqBecomeMaster() {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"becomeMaster\", (result: boolean) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n  private async reqStartGame(answer: string) {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"startGame\", answer, (result: string) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n  private async reqUpdateLines(lines: any[]) {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"updateLines\", lines, (result: string) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n  private async reqGuessAnswer(answer: string) {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"guessAnswer\", answer, (result: string) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n\r\n  private async reqLogin(username: string): Promise<boolean> {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"login\", username, (result: boolean) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n  private async reqLogout(): Promise<boolean> {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"logout\", (result: boolean) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n  private async reqIsLogin(): Promise<boolean> {\r\n    return new Promise((resolve) => {\r\n      this.socket.emit(\"isLogin\", (result: boolean) => {\r\n        resolve(result);\r\n      });\r\n    });\r\n  }\r\n\r\n  isConnect() {\r\n    return this.connect;\r\n  }\r\n  setConnect(newVal: boolean) {\r\n    this.connect = newVal;\r\n    this.Notify();\r\n  }\r\n  run() {\r\n    this.socket.on(\"connect\", () => {\r\n      console.log(\"game:connect\");\r\n      this.setConnect(true);\r\n    });\r\n    this.socket.on(\"disconnect\", () => {\r\n      this.setConnect(false);\r\n    });\r\n    this.socket.on(\"update\", () => {\r\n      this.update();\r\n    });\r\n  }\r\n  observers: Observer[] = [];\r\n  Attach(observer: Observer): void {\r\n    if (this.observers.includes(observer)) return;\r\n    this.observers.push(observer);\r\n  }\r\n  Detach(observer: Observer): void {\r\n    if (this.observers.includes(observer)) {\r\n      this.observers.splice(this.observers.indexOf(observer), 1);\r\n    }\r\n  }\r\n  Notify(): void {\r\n    this.observers.forEach((item) => item.update());\r\n  }\r\n}\r\n\r\n// 设计模式观察者模式\r\n// 观察者\r\ninterface Observer {\r\n  update(): void;\r\n}\r\n// 可观察对象\r\ninterface Observable {\r\n  observers: Array<Observer>; // 观察者\r\n  Attach(observer: Observer): void; // 附加观察者\r\n  Detach(observer: Observer): void; // 分离观察者\r\n  Notify(): void; // 通知观察者\r\n}\r\n```\r\n\r\n## 画板的实现\r\n\r\n```js\r\ntype LineInfo = {\r\n  strokeStyle: string;\r\n  lineWidth: number;\r\n  points: Array<number>;\r\n};\r\nexport class Whiteboard {\r\n  fillStyle = \"black\";\r\n  pencilSize = 10;\r\n  canvas!: HTMLCanvasElement;\r\n  ctx!: CanvasRenderingContext2D;\r\n  CANVAS_W = 1024;\r\n  CANVAS_H = 760;\r\n  lines: LineInfo[] = [];\r\n  lineBuffer: LineInfo = {\r\n    strokeStyle: \"\",\r\n    lineWidth: 0,\r\n    points: [],\r\n  };\r\n  afterUpdate = () => {};\r\n  mouseInput!: InputListener;\r\n  constructor(canvasId?: string) {\r\n    if (canvasId) this.init(canvasId);\r\n  }\r\n  init(canvasId: string) {\r\n    this.canvas = document.getElementById(canvasId) as HTMLCanvasElement;\r\n    this.ctx = this.canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n    this.canvas.width = this.CANVAS_W;\r\n    this.canvas.height = this.CANVAS_H;\r\n    this.mouseInput = new InputListener(canvasId);\r\n    return this;\r\n  }\r\n  update() {\r\n    while (this.mouseInput.inputs.length != 0) {\r\n      this.lines.push(this.mouseInput.inputs.shift());\r\n    }\r\n    this.lineBuffer = Object.assign({}, this.mouseInput.input_buffer);\r\n    this.afterUpdate();\r\n  }\r\n  drawLines(graphs: LineInfo[]) {\r\n    graphs.forEach((graph) => {\r\n      if (graph.points.length <= 2) return;\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(graph.points[0], graph.points[1]);\r\n      for (let index = 2; index < graph.points.length; ) {\r\n        const pointX = graph.points[index++];\r\n        const pointY = graph.points[index++];\r\n        this.ctx.lineTo(pointX, pointY);\r\n      }\r\n      this.ctx.lineWidth = graph.lineWidth;\r\n      this.ctx.strokeStyle = graph.strokeStyle;\r\n      this.ctx.stroke();\r\n    });\r\n  }\r\n  draw(interval: number) {\r\n    this.ctx.clearRect(0, 0, this.CANVAS_W, this.CANVAS_H);\r\n    this.drawLines(this.lines);\r\n    this.drawLines([this.lineBuffer]);\r\n  }\r\n  refresh(interval: number) {\r\n    this.update();\r\n    this.draw(interval);\r\n  }\r\n  start() {\r\n    let last = 0;\r\n    let animate = (current: number) => {\r\n      this.refresh(current - last);\r\n      last = current;\r\n      requestAnimationFrame(animate);\r\n    };\r\n    animate(0);\r\n  }\r\n}\r\nclass InputListener {\r\n  inputs: LineInfo[] = [];\r\n  input_buffer: LineInfo = {\r\n    strokeStyle: \"black\",\r\n    lineWidth: 5,\r\n    points: [],\r\n  };\r\n  target: HTMLElement;\r\n  constructor(targetId: string) {\r\n    this.target = document.getElementById(targetId) as HTMLElement;\r\n    this.listening_pc();\r\n    // this.listening_mobile()\r\n  }\r\n  listening_pc() {\r\n    let mousedown = false;\r\n    this.target.addEventListener(\"mousedown\", () => {\r\n      mousedown = true;\r\n    });\r\n    this.target.addEventListener(\"mousemove\", (e) => {\r\n      if (!mousedown) return;\r\n      this.input_buffer.points.push(e.offsetX);\r\n      this.input_buffer.points.push(e.offsetY);\r\n    });\r\n    this.target.addEventListener(\"mouseup\", () => {\r\n      mousedown = false;\r\n      this.inputs.push(Object.assign({}, this.input_buffer));\r\n      this.input_buffer.points = [];\r\n    });\r\n  }\r\n  // listening_mobile() {\r\n  // \tlet touched = false;\r\n  // \tthis.target.addEventListener(\"touchstart\", () => {\r\n  // \t\ttouched = true;\r\n  // \t})\r\n  // \tthis.target.addEventListener(\"touchmove\", (e) => {\r\n  // \t\tif (!touched) return\r\n  // \t\tthis.inputs.push({ x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY })\r\n  // \t})\r\n  // \tthis.target.addEventListener(\"touchend\", () => {\r\n  // \t\ttouched = false;\r\n  // \t})\r\n  // }\r\n}\r\n```\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>\r\n"}