{"shortInfo":{"title":"《数据结构与算法分析》第4章_6.AVL树","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-28T12:31:53.000Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":3607601954,"countWords":2611,"readSeconds":261.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_6.AVL树\r\n\r\n## AVL树 \r\n* **AVL(Adelson-Velskii and Landis)树**,名字取自其发明者**G.M.Adelson-Velsky**和**E.M. Landis**的首字母\r\n* 是一种带有**平衡条件**的**二叉查找树**\r\n* **是最老的一种平衡树**\r\n* 这个平衡条件**必须要容易保持**，且**必须保证树的深度**是O(log N)\r\n* **在每个节点中记录高度信息**\r\n* 通常定义**空子树的高度为-1**\r\n  + 高度为-1的AVL树，意味着应该有0个节点\r\n  + 高度为0的AVL树，意味着应该有1个节点，0个子树\r\n  + 高度为1的AVL树，意味着应该有1或2个叶子。\r\n  + 空树的高度为-1的约定实际上在AVL树中有一些实际用途,因为它简化了平衡因子的计算以及何时旋转子代。\r\n* **每个节点的左子树和右子树高度最多相差1**\r\n  + 不符合该要求的不是AVL树![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-11-18-54.png)\r\n\r\n## 一些不好的平衡条件：\r\n+ 一种是要求**根节点**的**左右子树**具有**相同的高度**\r\n  + **不强求深度要浅**\r\n  + 最坏情况：![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-29-07-06-48.png)\r\n  + 根据定义允许的情况：![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-09-04-11.png)\r\n+ 另一种树要求**每个节点**的**左右子树**的**高度必须相同**\r\n  + 能够保证树的深度，但条件过于严格\r\n\r\n## **AVL树高度h和节点数S(h)之间的关系**\r\n+ 讨论这个关系的意义在于明确高度为h时AVL树的节点数的界(下界、上界)\r\n+ 高度为-1的树,节点数至少为0 至多为0\r\n  + **Min(S(-1))=0**\r\n  + **Max(S(-1))=0**\r\n  + 左图为反映了至少有多少个节点，\r\n  + 右图反映了至多有多少个节点，\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-19-50.png)\r\n+ 高度为 0的树,节点数至少为1 至多为1\r\n  + **Min(S(0))=1**\r\n  + **Max(S(0))=1**\r\n  + 左图为反映了至少有多少个节点，\r\n  + 右图反映了至多有多少个节点，\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-19-26.png)\r\n+ 高度为 1的树,节点数至少为2 至多为3\r\n  + Min(S(**1**))=Min(S(**0**))+Min(S(**-1**))+1=2\r\n  + Max(S(**1**))=Max(S(**0**))+Max(S(**0**))+1=3\r\n  + 左图为反映了至少有多少个节点，其中树的左子树就是n-1的情况 右子树是n-2的情况\r\n  + 右图反映了至多有多少个节点，其中树的左子树和右子树都是n-1的情况\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-11-48-10.png)\r\n+ 高度为 2的树,节点数至少为4 至多为7\r\n  + Min(S(**2**))=Min(S(**1**))+Min(S(**0**))+1=4\r\n  + Max(S(**2**))=Max(S(**1**))+Max(S(**1**))+1=7\r\n  + 左图为反映了至少有多少个节点，其中树的左子树就是n-1的情况 右子树是n-2的情况\r\n  + 右图反映了至多有多少个节点，其中树的左子树和右子树都是n-1的情况\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-12-54.png)\r\n+ 高度为 3的树,节点数至少为7 至多为5\r\n  + Min(S(**3**))=Min(S(**2**))+Min(S(**1**))+1=7\r\n  + Max(S(**3**))=Max(S(**2**))+Max(S(**2**))+1=5\r\n  + 左图为反映了至少有多少个节点，其中树的左子树就是n-1的情况 右子树是n-2的情况\r\n  + 右图反映了至多有多少个节点，其中树的左子树和右子树都是n-1的情况\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-11-51.png)\r\n+ 高度为 4的树,节点数至少为4+7+1=12 至多为5+5+1=11\r\n  + Min(S(**4**))=Min(S(**3**))+Min(S(**2**))+1=12\r\n  + Max(S(**4**))=Max(S(**3**))+Max(S(**3**))+1=11\r\n  + 左图为反映了至少有多少个节点，其中树的左子树就是n-1的情况 右子树是n-2的情况\r\n  + 右图反映了至多有多少个节点，其中树的左子树和右子树都是n-1的情况\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-06-39.png)\r\n+ 所以可以总结出其关系类似于斐波那契数列，\r\n  + 定义S(-1)=0;S(0)=1;高度为h的AVL树的节点数至少为：**S(h)=S(h-1)+S(h-2)+1**\r\n  + 定义S(-1)=0;S(0)=1;高度为h的AVL树的节点数至多为：**S(h)=S(h-1)+S(h-1)+1**\r\n+ 若问：高度为9的AVL树至少有多少个节点、至多有多少个？\r\n  若定义S(-1)=0;S(0)=1;\r\n  则至少有min(S(9))=min(S(9-1))+min(S(9-2))+1个节点\r\n  至多有max(S(9))=max(S(9-1))+max(S(9-1))+1个节点\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-13-22-18.png)\r\n\r\n## 时间复杂度\r\n* 除去插入操作外（并且假设删除操作是懒惰删除），所有树的操作都可以以时间$O(log N)$执行\r\n  * 这里的懒惰删除是指删除时只是将节点标记为删除，不去真的删除这个节点\r\n* 插入操作存在困难的原因在于，插入一个节点后可能会破坏AVL树的平衡\r\n  * 如果这种情况发生，需要执行操作恢复AVL树的平衡，这样插入操作才算结束\r\n  + 这种操作称为**旋转（rotation）**\r\n\r\n## 旋转\r\n* 对于一个节点a,插入元素前是平衡的，插入后该节点不平衡了，也就是说其子树的高度相差2，出现这种情况的可能一共有四种\r\n  1. 对a的左儿子的左子树进行了插入操作\r\n  1. 对a的右儿子的右子树进行了插入操作\r\n  1. 对a的左儿子的右子树进行了插入操作\r\n  1. 对a的右儿子的左子树进行了插入操作\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-03-22-34.png)\r\n\r\n### 单旋转\r\n* 对于前两种情况可以使用单旋转使树恢复平衡\r\n* 具体操作就是（下图），将K1的右子树Y分给k2使其变成k2的左子树，然后将k2变成k1的右子树\r\n* 这么操作之后不影响元素的大小顺序\r\n* 整棵树的高度和插入前保持一致，所以不会影响其他部分的平衡情况（因为这整颗树可能是另一颗树的子树）\r\n* 使用单旋转对前两种情况使树恢复平衡![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-28-38.png)\r\n* 关于左单旋、右单旋名称的由来\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-01-09-18-34.png)\r\n* 插入示例\r\n  * 插入3、2、1\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-06-29.png)\r\n  * 插入4、5\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-06-55.png)\r\n  * 插入6\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-08-15.png)\r\n  * 插入7\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-08-41.png)\r\n\r\n### 双旋转\r\n* 对于后两种情况无法使用单旋转使树恢复平衡\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-18-22.png)\r\n* 需要使用双旋转恢复平衡\r\n* 具体操作就是（下图），将k2的两个节点看成是两颗树（其中一颗一定是空的），将这两颗树分别分给k1和k3,然后将k1和k3分别变成k2的左右子树\r\n* 这么操作之后不影响元素的大小顺序\r\n* 整棵树的高度和插入前保持一致，不会影响其他部分的平衡情况\r\n* 使用双旋转对前两种情况恢复平衡![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-27-28.png)\r\n* 对于双旋转名称的个人理解\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-06-23-14.png)\r\n* 插入示例\r\n  * 插入16、15\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-35-52.png)\r\n  * 插入7、14\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-37-04.png)\r\n  * 插入13\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-37-30.png)\r\n  * 插入12\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-39-03.png)\r\n\r\n## 单旋转、双旋转操作总结\r\n* 步骤：\r\n  1. 将关键字X插入到AVL树T中，递归地将X插入到T相应的子树(称$T_{LR}$)中，如果插入后$T_{LR}$高度不变，则完成插入操作\r\n  1. 否则判断T是否出现高度不平衡，如果依然平衡，则完成插入操作\r\n  1. 如果不平衡则根据情况做相应的单旋转或双旋转，更新高度，则完成插入操作\r\n* 递归与非递归的效率问题\r\n  * 因为一次旋转操作就能解决问题，所以效率上编写的非递归的程序会快很多。\r\n  * “非递归程序编写正确是相当困难的”，许多人还在用递归方式实现AVL树\r\n* 高度信息的存储的效率问题\r\n  + 存储子树高度差\r\n    + 由于真正需要的是子树的高度差，所以可以用两个二进位（存储0 -1 +1）来表示这个差\r\n    + 优点：这么做可以避免平衡因子的重复计算\r\n    + 缺点：\r\n      + 丧失了简明性\r\n      + 程序也会比原先更复杂\r\n    + 评价：\r\n      + 采取这种方式获得的速度优势难以抵消清晰度和相对简明性的损失”\r\n      + 由于大部分机器的最小存储单位是8bit,“因此所用的空间量不可能有任何差别”\r\n        + 意思是指就算你想用2bit来存储这个差，最后计算机也是用8bit来存储。\r\n  + 存储自身的高度\r\n    + 8bit能表示的树的高度高达255，再由于树是平衡的，书中的观点认为这是：“不可想象这会少到不够用”————够用的。\r\n"}