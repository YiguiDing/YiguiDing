{"shortInfo":{"title":"《数据结构与算法分析》第3章_4.队列","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-26T09:48:30.000Z","modified":"2022-05-27T09:16:54.972Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":61,"countWords":897,"readSeconds":89.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第3章_4.队列\r\n* 队列（queue）也是表\r\n* 队列的插入操作在一端进行，删除操作在另一端进行\r\n* 队列的基本操作\r\n  + Enqueue()入列，在表末尾（队尾rear）插入一个元素\r\n  + Dequeue()出列，删除或返回表头（对头front）元素\r\n* 队列抽象模型\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-01-53-23.png)\r\n\r\n## 队列的数组实现\r\n* 队列结构体\r\n  + 数组Queue[]\r\n  + 队列头 Front\r\n  + 队列尾 Rear\r\n  + 队列实际元素个数 Size\r\n* 入列操作：Size+=1,Rear+=1,Queue[Rear]=X;\r\n* 出列操作：Size-=1;return Queue[Front++];\r\n* 警惕：\r\n  + 出列操作时检测队列是否为空很重要\r\n  + 如果队列的大小是计算得出的，需要考虑一些特殊情况，修改代码时也需要更仔细\r\n* 潜在问题：队列满了之后怎么办？\r\n  + 解决方法：循环数组（circular array）实现,Front或Rear达到数组尾部时，使其绕回到开头位置。\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-43-40.png)\r\n\r\n### 具体实现\r\n```c\r\n//Queue.h\r\n#ifndef Queue_H\r\n#define Queue_H\r\n\r\n#define ElementType int\r\n\r\nstruct QueueRecord;\r\ntypedef struct QueueRecord* Queue;\r\n\r\nint IsEmpty(Queue Q);\r\nint IsFull(Queue Q);\r\nQueue CreatQueue(int MaxElements);\r\nvoid DisposeQueue(Queue Q);\r\nvoid MakeEmpty(Queue Q);\r\nvoid Enqueue(ElementType X,Queue Q);\r\nvoid Dequeue(Queue Q);\r\nElementType GetFront(Queue Q);\r\nElementType GetFrontAndDequeue(Queue Q);\r\n#endif\r\n```\r\n\r\n```c\r\n//Queue.c\r\n#include\"Queue.h\"\r\n#include<stdlib.h>\r\n#define MinQueueSize (10)\r\n\r\nstruct QueueRecord\r\n{\r\n    int Capacity;\r\n    int Front;\r\n    int Rear;\r\n    int Size;\r\n    ElementType *Array;\r\n};\r\n\r\nint IsEmpty(Queue Q)\r\n{\r\n    return Q->Size <= 0;\r\n}\r\nint IsFull(Queue Q)\r\n{\r\n    return Q->Size >= Q->Capacity;\r\n}\r\nQueue CreatQueue(int MaxElements)\r\n{\r\n    if (MaxElements<MinQueueSize)\r\n    {\r\n        Error(\"Queue size is too small\");\r\n    }\r\n    \r\n    Queue Q=malloc(sizeof(struct QueueRecord));\r\n    if (Q==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return;\r\n    }\r\n    Q->Array = malloc(sizeof(ElementType)*MaxElements);\r\n    if (Q->Array==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return;\r\n    }\r\n    MakeEmpty(Q);\r\n    return Q;\r\n}\r\nvoid DisposeQueue(Queue Q)\r\n{\r\n    if (Q!=NULL)\r\n    {   \r\n        if (Q->Array!=NULL)\r\n            free(Q->Array);\r\n        free(Q);\r\n    }\r\n}\r\nvoid MakeEmpty(Queue Q)\r\n{\r\n    Q->Size=0;\r\n    Q->Front=1;//Rear被初始化为0，意味着入列一个元素后，第一个元素的位置是1\r\n    Q->Rear=0;\r\n}\r\n\r\nvoid Enqueue(ElementType X,Queue Q)\r\n{\r\n    if (!IsFull(Q))\r\n    {\r\n        Q->Rear = getNextPosition(Q->Rear,Q);\r\n        Q->Array[Q->Rear]=X;\r\n        Q->Size++;\r\n    }\r\n    Error(\"Queue is full\");\r\n}\r\nvoid Dequeue(Queue Q)\r\n{\r\n    if (!isEmpty(Q))\r\n    {\r\n        Q->Front = getNextPosition(Q->Front,Q);\r\n        Q->Size--;\r\n        return;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nElementType GetFront(Queue Q)\r\n{\r\n    if (!isEmpty(Q))\r\n    {\r\n        return Q->Array[Q->Front];\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nElementType GetFrontAndDequeue(Queue Q)\r\n{\r\n    if (!isEmpty(Q))\r\n    {\r\n        ElementType temp = Q->Array[Q->Front];\r\n        Q->Front = getNextPosition(Q->Front,Q);\r\n        Q->Size--;\r\n        return temp;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nstatic Error(char *str)\r\n{\r\n    printf(\"%s\\n\",str);\r\n}\r\nstatic int getNextPosition(int Position,Queue Q)\r\n{\r\n    if(++Position >= Q->Capacity)\r\n        Position=0;\r\n    return Position;\r\n}\r\n\r\n```\r\n## 队列的链表实现\r\n```c\r\n//Queue.h\r\n#ifndef Queue_H\r\n#define Queue_H\r\n\r\n#define ElementType int\r\n\r\nstruct QueueRecord;\r\ntypedef struct QueueRecord* Queue;\r\n\r\nint IsEmpty(Queue Q);\r\nint IsFull(Queue Q);\r\nQueue CreatQueue();\r\nvoid DisposeQueue(Queue Q);\r\nvoid MakeEmpty(Queue Q);\r\nvoid Enqueue(ElementType X,Queue Q);\r\nvoid Dequeue(Queue Q);\r\nElementType GetFront(Queue Q);\r\nElementType GetFrontAndDequeue(Queue Q);\r\n#endif\r\n\r\n```\r\n\r\n```c\r\n//Queue.c\r\n\r\n#include\"Queue.h\"\r\n#include<stdio.h>\r\n\r\ntypedef struct \r\n{\r\n    ElementType Element;\r\n    Node *Next;\r\n    Node *Ahead;\r\n}Node;\r\n\r\nstruct QueueRecord\r\n{\r\n    int Size;\r\n    Node *Front;\r\n    Node *Ended;\r\n};\r\n\r\nint IsEmpty(Queue Q)\r\n{\r\n    return Q->Size<=0;\r\n}\r\nQueue CreatQueue()\r\n{\r\n    Queue Q=malloc(sizeof(struct QueueRecord));\r\n    if (Q!=NULL)\r\n    {\r\n        Q->Front=0;\r\n        Q->Ended=0;\r\n        return Q;    \r\n    }\r\n    Error(\"out of memory\");\r\n    return 0;\r\n}\r\nvoid DisposeQueue(Queue Q)\r\n{\r\n    Node *temp=Q->Front;\r\n    while (temp!=NULL)\r\n    {\r\n        temp=temp->Next;\r\n        free(temp->Ahead);\r\n    }\r\n    free(Q);\r\n}\r\nvoid MakeEmpty(Queue Q)\r\n{\r\n    Node *temp=Q->Front;\r\n    while (temp!=NULL)\r\n    {\r\n        temp=temp->Next;\r\n        free(temp->Ahead);\r\n    }\r\n    Q->Size=0;\r\n    Q->Ended=NULL;\r\n    Q->Front=NULL;\r\n}\r\nvoid Enqueue(ElementType X,Queue Q)\r\n{\r\n    Node *temp=malloc(sizeof(Node));\r\n    if (temp==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return;\r\n    }\r\n    temp->Element=X;\r\n    \r\n    if (Q->Front==NULL)\r\n    {\r\n        Q->Front=temp;\r\n    }\r\n    if (Q->Ended==NULL)\r\n    {\r\n        Q->Ended=temp;\r\n    }\r\n    \r\n    temp->Ahead=Q->Ended;\r\n    temp->Next=NULL;\r\n    \r\n    Q->Ended=temp;\r\n\r\n    Q->Size++;\r\n}\r\nvoid Dequeue(Queue Q)\r\n{\r\n    if (!IsEmpty(Q))\r\n    {\r\n        Node *temp = Q->Front->Next;\r\n        free(Q->Front);\r\n        Q->Front=temp;\r\n        Q->Size--;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nElementType GetFront(Queue Q)\r\n{\r\n    if (!IsEmpty(Q))\r\n    {\r\n        return Q->Front->Element;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nElementType GetFrontAndDequeue(Queue Q)\r\n{\r\n    if (!IsEmpty(Q))\r\n    {\r\n        ElementType Element=Q->Front->Element;\r\n        Node *temp = Q->Front->Next;\r\n\r\n        free(Q->Front);\r\n        Q->Front=temp;\r\n        Q->Size--;\r\n\r\n        return Element;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\n\r\n```\r\n\r\n## 队列的应用\r\n* 打印机的任务\r\n* 网络文件服务器的访问顺序，先请求先访问\r\n* 传呼系统\r\n"}