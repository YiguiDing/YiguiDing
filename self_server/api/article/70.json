{"shortInfo":{"title":"《数据结构与算法分析》第4章_9.树的遍历","cover":"/self_server/assets/images/《数据结构与算法分析》学习笔记/cover.png","coverWidth":813,"coverHeight":539,"date":"2022-06-06T07:24:05.000Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":70,"countWords":304,"readSeconds":30.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 树的遍历\r\n\r\n## 中序遍历\r\n* 中序遍历，先遍历左子树，再处理当前节点，再遍历右子树。\r\n* 由于二叉树中对信息进行了排序，因而按照排序的顺序列出所有关键字会很简单。\r\n* 下面为采用**中序遍历**的递归方式实现\r\n    * 由于在每个节点的花费都是常数时间，共N个节点，所以整个操作的时间复杂度为$O(N)$\r\n\r\n```c\r\nvoid PrintTree(SearchTree T)\r\n{\r\n    if(T!=NULL)\r\n    {\r\n        PrintTree(T->Left);\r\n        PrintElement(T->Element);\r\n        PrintTree(T->Right);\r\n    }\r\n}\r\n```\r\n\r\n## 后序遍历\r\n* 后续遍历，先遍历子节点，后处理当前节点\r\n* 采用**后序遍历**计算树的高度的例子,时间复杂度也是$O(N)$\r\n\r\n```c\r\nint Height(AVLTree T)\r\n{\r\n    if(T==NULL)\r\n        return -1;\r\n    else\r\n        return 1 + Max(Height(T->Left),Height(T->Right));\r\n}\r\n```\r\n\r\n## 先序遍历\r\n* 当前节点在子节点之前被处理\r\n* 可以利用节点深度标志每一个节点，可以用来打印目录结构\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/2022-06-06-15-44-54.png)\r\n\r\n## 层序遍历(level-order traversal)\r\n* 深度为D的节点要在深度为D+1的节点之前处理\r\n* 不是使用递归编写\r\n* 需要用到队列\r\n"}