{"shortInfo":{"title":"《数据结构与算法分析》第4章_1.树的概念","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-27T01:24:41.000Z","modified":"2022-05-28T20:35:41.330Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":2938365805,"countWords":1153,"readSeconds":115.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_1.树的概念\r\n* 对于大量输入数据，线性链表访问时间太慢不宜使用。\r\n* 树的大部分操作运行时间平均为O(log N)\r\n\r\n## 一些相关概念\r\n* **定义**\r\n  + 定义树的方式有多种\r\n  + 定义树的一种方式是递归的方式（类似于定义一个基准情况，然后自己定义自己）\r\n* **组成**\r\n  + 一棵树是一些**节点**的集合，该集合可以是空集。\r\n  + 一棵树由**根(root)节点**和0个子树或多个非空的**子树**组成\r\n  + 子树的根被一条来自根节点的有向的**边edge**所连接。(根节点指向子节点的边)\r\n  + 一棵树是N个节点和N-1条边的集合，其中一个节点叫做根\r\n  + **一个节点可有0个或多个子节点**\r\n* **称呼**\r\n  + 根节点是其下属的子树根节点的**父亲(parent)**\r\n  + 子树的根节点是父节点的**儿子(child)**\r\n  + 没有子节点的节点称为**树叶(leaf)**\r\n  + 有相同父节点的节点称为**兄弟(sibling)**\r\n  + 祖父grandparent、孙子grandchild关系以此类推\r\n+ **路径** \r\n  + 子节点到父节点之间的路径长度为其边数，也就是1\r\n  + 如果前一个节点是后一个节点的父节点，N1到Nk的路径长度为K-1,也就是该路径上的边数\r\n  + 一个节点从自己到自己的路径长度为0,可以理解为经过了0条边\r\n+ **深度**\r\n  + **某节点**的深度为根节点到该节点唯一路径的长\r\n  + **根节点**的深度为0\r\n  + **一棵树**的深度等于这棵树最深的树叶的深度，同时也等于这棵树的高\r\n+ **高度**\r\n  + **某节点**的高度为从该节点到最深叶节点的路径的长\r\n  + **叶节点**的高度为0\r\n  + **一棵树**的高度等于其根节点的高，也等于其最深叶节点的深度\r\n+ **一个树的深度等于它的最深的树叶的深度;该深度总是等于这棵树的高。**\r\n+ **祖先、真祖先**\r\n  + N1节点到N2节点存在一条路径，那么N1是N2的一位**祖先**ancestor，N2是N1的一个**后裔**descentdant\r\n  + N1节点到N2节点存在一条路径，**且N1!=N2**，那么N1是N2的一位**真祖先**proper ancestor，N2是N1的一个**真后裔**proper descentdant\r\n\r\n## 树的实现\r\n* **理想的实现方式：** 根节点拥有多个指针域分别指向其多个子节点\r\n  + **缺点：** 子节点个数是未知的，无法提前预知需要多少个指针域\r\n* **实际的实现方式：** 每个节点只有两个指针域，一个指向其子节点，另一个指向其兄弟节点\r\n```c\r\ntypedef struct TreeNode* PtrToNode;\r\nstruct TreeNode\r\n{\r\n  ElementType Element;//数据域\r\n  PtrToNode FirstChild;//指向其第一个子节点\r\n  PtrToNode NextSibling;//指向其兄弟节点\r\n};\r\n```\r\n* **各节点的逻辑关系**\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-01-24-54.png)\r\n* **各节点中指针的实际指向**\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-01-24-38.png)\r\n\r\n## 树的应用及其遍历\r\n* **unix文件系统**\r\n  + unix文件系统的目录中有一个指针指向本身，还有一个指针指向父目录，所以严格来说unix文件系统是类树(treeLike)结构.\r\n* 根据深度打印tab个数，文件名，换行符号\r\n* 一种遍历策略称为**先序遍历（preorder traversal）**。在先序遍历中，对当前所在节点的处理工作是在其子节点之前进行(pre)的\r\n* 另一种遍历策略称之为**后序遍历（postorder traversal）**。也就是先处理当前节点的子节点，再来处理当前节点。\r\n  + 应用：计算文件夹内文件的大小\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-02-30-27.png)\r\n\r\n### 先序遍历\r\n* 代码\r\n```c\r\nvoid ListDirectory(DirectoryFile D)\r\n{\r\n  ListDir(D,0);\r\n}\r\n\r\nstatic void ListDir(DirectoryFile D,int Depth)\r\n{\r\n  if(D是一条合法记录)//D是文件夹或文件\r\n  {\r\n    Print(D,Depth);//根据深度打印tab个数，文件名，换行符\r\n    if(D是一个文件夹)\r\n      for(C=getFirstChild(D);C!=NULL;C=getNextChild(D))//遍历\r\n        ListDir(C,Depth+1);\r\n  }\r\n}\r\n\r\n```\r\n* 遍历结果\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-02-42-17.png)\r\n\r\n### 后序遍历\r\n* 代码实现\r\n```c\r\nint SizeDirectory(DirectoryOrFile D)\r\n{\r\n  int totle=0;\r\n  if(D是文件或文件夹)\r\n  {\r\n    if(D是文件)\r\n    {\r\n      totle=FileSize(D);\r\n    }\r\n    for(C=getFirstChild(D);C!=NULL;C=getNextChild(D))\r\n    {\r\n      totle+=SizeDirectory(D);\r\n    }\r\n    Print(D,totle);\r\n  }\r\n  return totle;\r\n}\r\n\r\n```\r\n* 输出结果\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-03-14-24.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"}