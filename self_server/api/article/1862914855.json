{"shortInfo":{"title":"打砖块小游戏Demo实现记录","date":"2023-01-22T12:58:00.000Z","cover":"\\self_server\\assets\\images\\dafangkuai.gif","tags":["笔记","demo","game","canvas"],"categories":"笔记","id":1862914855,"countWords":947,"readSeconds":94.7,"assetsbaseUrl":"/self_server/assets/"},"content":"## 打砖块小游戏 Demo 实现记录\r\n\r\n[Demo地址](./demo_jdfowefjwi/index.html)\r\n\r\n## 目录\r\n- [打砖块小游戏 Demo 实现记录](#打砖块小游戏-demo-实现记录)\r\n- [目录](#目录)\r\n- [index.ts](#indexts)\r\n- [Game.ts](#gamets)\r\n- [InputListener.ts](#inputlistenerts)\r\n- [utils.ts](#utilsts)\r\n- [Ball.ts](#ballts)\r\n- [Wall.ts](#wallts)\r\n\r\n\r\n## index.ts\r\n\r\n```ts\r\nimport { Game } from \"./Game.js\";\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n\tvar canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\r\n\tvar context = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\tnew Game(canvas, context).start();\r\n});\r\n```\r\n\r\n## Game.ts\r\n\r\n```ts\r\nimport { Ball } from \"./Ball.js\";\r\nimport { Wall } from \"./Wall.js\";\r\nimport { Processor } from \"./Processor.js\";\r\nimport { InputListener } from \"./InputListener.js\";\r\nimport { Player } from \"./Player.js\";\r\n\r\nexport class Game {\r\n\tGAME_WIDTH = 1080;\r\n\tGAME_HEIGHT = 760;\r\n\tball: Ball;\r\n\twall: Wall;\r\n\tplayer: Player;\r\n\tinputListener = new InputListener();\r\n\tprocessor = new Processor();\r\n\tconstructor(private canvas: HTMLCanvasElement, private context: CanvasRenderingContext2D) {\r\n\t\tthis.canvas = canvas;\r\n\t\tthis.context = context;\r\n\t\tthis.canvas.width = this.GAME_WIDTH;\r\n\t\tthis.canvas.height = this.GAME_HEIGHT;\r\n\t\tthis.wall = new Wall(10, 10, this.GAME_WIDTH, 300, this.GAME_WIDTH, this.GAME_HEIGHT);\r\n\t\tthis.ball = new Ball(this.GAME_WIDTH / 2, this.GAME_HEIGHT * 0.9, this.GAME_WIDTH, this.GAME_HEIGHT);\r\n\t\tthis.player = new Player(this.GAME_WIDTH / 2, this.GAME_HEIGHT * 0.9, this.GAME_WIDTH, this.GAME_HEIGHT);\r\n\t}\r\n\tupdate(timeInterval: number) {\r\n\t\tthis.ball.update(timeInterval);\r\n\t\tthis.player.update(timeInterval);\r\n\t\tthis.processor.process(this);\r\n\t\tthis.processor.inputHandler(this, this.inputListener.inputs);\r\n\t}\r\n\tdraw(context: CanvasRenderingContext2D) {\r\n\t\tcontext.clearRect(0, 0, this.GAME_WIDTH, this.GAME_HEIGHT);\r\n\t\tthis.ball.draw(context);\r\n\t\tthis.wall.draw(context);\r\n\t\tthis.player.draw(context);\r\n\t}\r\n\trefresh(timeInterval: number, context: CanvasRenderingContext2D) {\r\n\t\tthis.update(timeInterval);\r\n\t\tthis.draw(context);\r\n\t}\r\n\tstart() {\r\n\t\tlet self = this;\r\n\t\tlet last = 0;\r\n\t\tfunction animate(current: number) {\r\n\t\t\tself.refresh(current - last, self.context);\r\n\t\t\tlast = current;\r\n\t\t\trequestAnimationFrame(animate);\r\n\t\t}\r\n\t\tanimate(0);\r\n\t}\r\n}\r\n```\r\n\r\n## InputListener.ts\r\n\r\n```ts\r\nimport { ValueOf } from \"./utils.js\";\r\n\r\nexport type KeyMapValue = ValueOf<typeof InputListener.KeyMap>;\r\nexport type TypeInputs = Array<KeyMapValue>;\r\nexport class InputListener {\r\n\tstatic KeyMap = {\r\n\t\tPressRight: \"ArrowRight\",\r\n\t\tPressLeft: \"ArrowLeft\",\r\n\t\tPressUp: \"ArrowUp\",\r\n\t\tPressDown: \"ArrowDown\",\r\n\t\tPressSpace: \" \",\r\n\t\tEnter: \"Enter\",\r\n\t\tEscape: \"Escape\"\r\n\t} as const; // const 可以保证ValueOf能起作用\r\n\tinputs: TypeInputs = [];\r\n\tconstructor() {\r\n\t\tthis.listening();\r\n\t}\r\n\tlistening() {\r\n\t\twindow.addEventListener(\"keydown\", event => {\r\n\t\t\tlet key = event.key as KeyMapValue;\r\n\t\t\tif (Object.values(InputListener.KeyMap).includes(key) && !this.inputs.includes(key)) {\r\n\t\t\t\tthis.inputs.unshift(key); // 放到开头，表示先按下的键优先级高\r\n\t\t\t}\r\n\t\t});\r\n\t\twindow.addEventListener(\"keyup\", event => {\r\n\t\t\tlet key = event.key as KeyMapValue;\r\n\t\t\tif (this.inputs.includes(key)) {\r\n\t\t\t\tthis.inputs.splice(this.inputs.indexOf(key), 1);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n```\r\n\r\n## utils.ts\r\n\r\n```ts\r\nexport function RandomRange(from: number, to: number) {\r\n\treturn Math.random() * (to - from) + from;\r\n}\r\nexport type ValueOf<T> = T[keyof T];\r\n\r\nexport type Rect = { posX: number; posY: number; width: number; height: number };\r\nexport type Point = { posX: number; posY: number };\r\nexport type Circle = { posX: number; posY: number; radius: number };\r\n// 碰撞检测,判断一个坐标是否在一个矩形内\r\nfunction collision_Rect_Point(rect: Rect, point: Point) {\r\n\treturn rect.posX < point.posX && point.posX < rect.posX + rect.width && rect.posY < point.posY && point.posY < rect.posY + rect.height;\r\n}\r\n// 碰撞检测，判断一个圆和一个矩形是否碰撞\r\nexport function collision_Rect_Circle(rect: Rect, circle: Circle) {\r\n\t// 只需要判断这个圆的中心坐标是否在一个大矩形之内，这个大矩形就是将原矩形上下左右的边长拓宽圆的一倍半径\r\n\treturn collision_Rect_Point(\r\n\t\t{\r\n\t\t\tposX: rect.posX - circle.radius,\r\n\t\t\tposY: rect.posY - circle.radius,\r\n\t\t\twidth: rect.width + 2 * circle.radius,\r\n\t\t\theight: rect.height + 2 * circle.radius\r\n\t\t},\r\n\t\t{ ...circle }\r\n\t);\r\n}\r\n```\r\n\r\n\r\n## Ball.ts\r\n```ts\r\nimport { RandomRange, Rect } from \"./utils.js\";\r\nexport class Ball {\r\n\tradius: number = 10;\r\n\tfillStyle: string = \"white\";\r\n\tstrokeStyle: string = \"whitesmoke\";\r\n\tspeedX: number = Math.sign(RandomRange(-1, 1)) * RandomRange(0.4, 0.5);\r\n\tspeedY: number = Math.sign(RandomRange(-1, 1)) * RandomRange(0.4, 0.5);\r\n\tconstructor(public posX: number, public posY: number, public GAME_WIDTH: number, public GAME_HEIGHT: number) {\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.GAME_HEIGHT = GAME_HEIGHT;\r\n\t\tthis.GAME_WIDTH = GAME_WIDTH;\r\n\t}\r\n\treverseSpeedX() {\r\n\t\tthis.speedX = -this.speedX;\r\n\t}\r\n\treverseSpeedY() {\r\n\t\tthis.speedY = -this.speedY;\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX += this.speedX * timeInterval;\r\n\t\tthis.posY += this.speedY * timeInterval;\r\n\t}\r\n\t_update(timeInterval: number) {\r\n\t\tthis.move(timeInterval);\r\n\t}\r\n\tupdate(timeInterval: number) {\r\n\t\tlet step = 1; // 按1ms模拟\r\n\t\tdo {\r\n\t\t\tthis._update(step);\r\n\t\t\ttimeInterval -= step;\r\n\t\t} while (timeInterval > 0);\r\n\t}\r\n\tdraw(context: CanvasRenderingContext2D) {\r\n\t\tcontext.save();\r\n\t\tcontext.beginPath();\r\n\t\tcontext.arc(this.posX, this.posY, this.radius, 0, Math.PI * 2);\r\n\t\tcontext.closePath();\r\n\t\tcontext.strokeStyle = this.strokeStyle;\r\n\t\tcontext.stroke();\r\n\t\tcontext.fillStyle = this.fillStyle;\r\n\t\tcontext.fill();\r\n\t\tcontext.restore();\r\n\t}\r\n}\r\n```\r\n\r\n## Wall.ts\r\n```ts\r\nexport class Block {\r\n\tconstructor(\r\n\t\tpublic posX: number,\r\n\t\tpublic posY: number,\r\n\t\tpublic width: number,\r\n\t\tpublic height: number,\r\n\t\tpublic fillStyle: string,\r\n\t\tpublic strokeStyle: string\r\n\t) {\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tthis.fillStyle = fillStyle;\r\n\t\tthis.strokeStyle = strokeStyle;\r\n\t}\r\n\tupdate(timeInterval: number) {}\r\n\tdraw(context: CanvasRenderingContext2D) {\r\n\t\tcontext.save();\r\n\t\tcontext.fillStyle = this.fillStyle;\r\n\t\tcontext.fillRect(this.posX, this.posY, this.width, this.height);\r\n\t\tcontext.strokeStyle = this.strokeStyle;\r\n\t\tcontext.strokeRect(this.posX, this.posY, this.width, this.height);\r\n\t\tcontext.restore();\r\n\t}\r\n}\r\nexport class Wall {\r\n\tblocks: Array<Block> = [];\r\n\tconstructor(\r\n\t\tpublic width: number,\r\n\t\tpublic height: number,\r\n\t\tpublic WALL_MAX_WIDTH: number,\r\n\t\tpublic WALL_MAX_HEIGHT: number,\r\n\t\tpublic GAME_WIDTH: number,\r\n\t\tpublic GAME_HEIGHT: number\r\n\t) {\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\tthis.WALL_MAX_WIDTH = WALL_MAX_WIDTH;\r\n\t\tthis.WALL_MAX_HEIGHT = WALL_MAX_HEIGHT;\r\n\t\tthis.GAME_WIDTH = GAME_WIDTH;\r\n\t\tthis.GAME_HEIGHT = GAME_HEIGHT;\r\n\r\n\t\tlet BLOCK_WIDTH = this.WALL_MAX_WIDTH / this.width;\r\n\t\tlet BLOCK_HEIGHT = this.WALL_MAX_HEIGHT / this.height;\r\n\t\tfor (var i = 0; i < this.width; i++) {\r\n\t\t\tfor (var j = 0; j < this.height; j++) {\r\n\t\t\t\tthis.blocks.push(new Block(i * BLOCK_WIDTH, j * BLOCK_HEIGHT, BLOCK_WIDTH, BLOCK_HEIGHT, \"gray\", \"black\"));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tupdate(){\r\n\t\t\r\n\t}\r\n\tdraw(context: CanvasRenderingContext2D) {\r\n\t\tthis.blocks.forEach(item => item.draw(context));\r\n\t}\r\n}\r\n```\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>\r\n"}