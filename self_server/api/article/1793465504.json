{"shortInfo":{"title":"javaScript写的2D游戏的实现细节笔记","date":"2023-01-10T05:57:00.000Z","cover":"\\self_server\\assets\\images\\shadowDogCover.gif","tags":["笔记"],"categories":"笔记","id":1793465504,"countWords":8709,"readSeconds":870.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# 1. 试玩版本 URL 地址： <u>[ShadowDog:0.0.1✅](./demo/index.html)</u>\r\n\r\n> **操作**：\r\n>\r\n> - `Enter` 键开始游戏\r\n> - `ESC` 键暂停游戏\r\n> - `Space` 键继续游戏\r\n> - `方向键上下左右`控制人物 跳、蹲、俯冲、前后移动\r\n> - 玩家在**跳起后**`在空中时`按下`Space`键可释放人物技能\r\n> - 释放技能的**过程中**按下方向键`↓`可实现俯冲\r\n> - 人物在**地面时**按下方向键`↓`可蹲下\r\n> - **蹲下后**按下方向键`→` 会有音效\r\n\r\n# 2. javaScript 写的 2D 游戏的实现细节笔记\r\n\r\n## 2.1. 笔记目录\r\n\r\n- [1. 试玩版本 URL 地址： ShadowDog:0.0.1✅](#1-试玩版本-url-地址-shadowdog001)\r\n- [2. javaScript 写的 2D 游戏的实现细节笔记](#2-javascript-写的-2d-游戏的实现细节笔记)\r\n\t- [2.1. 笔记目录](#21-笔记目录)\r\n\t- [2.2. Canvas 绘图基本步骤](#22-canvas-绘图基本步骤)\r\n\t\t- [2.2.1. 原理](#221-原理)\r\n\t\t- [2.2.2. 优化及渲染所有动图](#222-优化及渲染所有动图)\r\n\t\t- [2.2.3. 封装和抽象](#223-封装和抽象)\r\n\t\t- [2.2.4. 对动画对象 Animater 的封装](#224-对动画对象-animater-的封装)\r\n\t\t- [2.2.5. 继续定义一些列接口并定义 Animal 类](#225-继续定义一些列接口并定义-animal-类)\r\n\t\t- [2.2.6. 使用](#226-使用)\r\n\t- [2.3. 敌人的移动模式](#23-敌人的移动模式)\r\n\t\t- [2.3.1. 原地静止的物体](#231-原地静止的物体)\r\n\t\t- [2.3.2. 水平直线运动的蠕虫](#232-水平直线运动的蠕虫)\r\n\t\t- [2.3.3. 上下摆动的蝙蝠](#233-上下摆动的蝙蝠)\r\n\t\t- [2.3.4. 随机无规律移动的齿轮](#234-随机无规律移动的齿轮)\r\n\t- [2.4. 视差背景原理](#24-视差背景原理)\r\n\t\t- [2.4.1. 无限滚动的背景原理](#241-无限滚动的背景原理)\r\n\t\t- [2.4.2. 视差背景的实现](#242-视差背景的实现)\r\n\t\t- [2.4.3. 最终的抽象、封装、实现](#243-最终的抽象封装实现)\r\n\t\t- [2.4.4. 使用封装好的类实现一个视差背景](#244-使用封装好的类实现一个视差背景)\r\n\t- [2.5. 碰撞检测](#25-碰撞检测)\r\n\t\t- [2.5.1. 矩形碰撞检测](#251-矩形碰撞检测)\r\n\t\t- [2.5.2. 圆形碰撞检测](#252-圆形碰撞检测)\r\n\t\t- [2.5.3. 像素碰撞检测](#253-像素碰撞检测)\r\n\t- [2.6. 粒子特效](#26-粒子特效)\r\n\t\t- [2.6.1. 定义 Particle 抽象类](#261-定义-particle-抽象类)\r\n\t\t- [2.6.2. 灰尘影子的实现](#262-灰尘影子的实现)\r\n\t\t- [2.6.3. 火焰粒子特效](#263-火焰粒子特效)\r\n\t\t- [2.6.4. 落地的爆炸火花粒子特效](#264-落地的爆炸火花粒子特效)\r\n\t\t- [2.6.5. 爆炸的烟雾粒子特效](#265-爆炸的烟雾粒子特效)\r\n\t- [2.7. 输入监听和状态管理的实现](#27-输入监听和状态管理的实现)\r\n\t\t- [2.7.1. 输入监听](#271-输入监听)\r\n\t\t- [2.7.2. 状态管理](#272-状态管理)\r\n\t\t- [2.7.3. 使用状态设计模式实现状态管理 Player 类的部分代码](#273-使用状态设计模式实现状态管理-player-类的部分代码)\r\n\t\t- [2.7.4. 使用状态设计模式实现状态管理 Game 类的部分代码](#274-使用状态设计模式实现状态管理-game-类的部分代码)\r\n\t- [2.8. Scene 场景](#28-scene-场景)\r\n\t- [2.9. UI](#29-ui)\r\n\t- [2.10. 字体](#210-字体)\r\n\t- [2.11. Canvas 铺满页面屏幕的实现](#211-canvas-铺满页面屏幕的实现)\r\n\t- [2.12. 自写工具类](#212-自写工具类)\r\n\r\n## 2.2. Canvas 绘图基本步骤\r\n\r\n### 2.2.1. 原理\r\n\r\n[原理.html](./practices/1.canvas%EF%BC%9A%E5%8E%9F%E7%90%86/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\n// 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 600);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 600);\r\n\r\n// 单帧宽高\r\nconst Sprite_WIDTH = 575;\r\nconst Sprite_HEIGHT = 523;\r\n\r\nconst imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./shadow_dog.png\";\r\n\r\nlet frameX = 0;\r\nlet frameY = 0;\r\nlet frameCount = 0; // 第几帧\r\nlet stageFrame = 5; // 交错帧，每隔5帧 切换图片\r\n\r\nfunction animate() {\r\n\t// 计算当前要绘制的帧的index\r\n\tframeCount = ++frameCount % stageFrame;\r\n\tif (!frameCount) frameX = ++frameX % 7;\r\n\r\n\t//清除上一次绘图痕迹\r\n\tctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n\tctx.drawImage(\r\n\t\timgPlayer, // img\r\n\t\tframeX * Sprite_WIDTH, //源坐标x\r\n\t\tframeY * Sprite_HEIGHT, //源坐标y\r\n\t\tSprite_WIDTH, //源图像宽\r\n\t\tSprite_HEIGHT, //源图像高\r\n\t\t0, // 目的坐标x\r\n\t\t0, // 目的坐标y\r\n\t\tCANVAS_WIDTH, // 绘制宽度w\r\n\t\tCANVAS_HEIGHT // 绘制高度h\r\n\t);\r\n\t// requestAnimationFrame原理上相当于60fps的setInterval\r\n\trequestAnimationFrame(animate);\r\n}\r\nanimate();\r\n```\r\n\r\n### 2.2.2. 优化及渲染所有动图\r\n\r\n[优化.html](./practices/2.animate：优化/index.html)\r\n\r\n<canvas id=\"myCanvas_2j0923ru48\"></canvas>\r\n\r\n<div class=\"animation-box\">\r\n\t<label for=\"animations\">select animation:</label>\r\n\t<select name=\"\" id=\"animations_djf9498\">\r\n\t\t<option value=\"idle\">idle</option>\r\n\t\t<option value=\"jump\">jump</option>\r\n\t\t<option value=\"fall\">fall</option>\r\n\t\t<option value=\"run\">run</option>\r\n\t\t<option value=\"dizzy\">dizzy</option>\r\n\t\t<option value=\"sit\">sit</option>\r\n\t\t<option value=\"roll\">roll</option>\r\n\t\t<option value=\"bite\">bite</option>\r\n\t\t<option value=\"ko\">ko</option>\r\n\t\t<option value=\"gethit\">gethit</option>\r\n\t</select>\r\n</div>\r\n<img src=\"./images/shadow_dog.png\">\r\n<script>\r\nvar myCanvas = document.querySelector(\"#myCanvas_2j0923ru48\");\r\nvar ctx = myCanvas.getContext(\"2d\"); // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n// canvas的默认大小为300x150px 需手动修改\r\nvar CANVAS_WIDTH = (myCanvas.width = 250);\r\nvar CANVAS_HEIGHT = (myCanvas.height = 250);\r\nvar Sprite_WIDTH = 575;\r\nvar Sprite_HEIGHT = 523;\r\nvar imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./images/shadow_dog.png\";\r\nvar playerState = \"idle\";\r\nvar selector = document.querySelector(\"#animations_djf9498\");\r\nselector.addEventListener(\"change\", function () {\r\n  playerState = selector.value;\r\n});\r\nvar animations = {\r\n  idle: { rows: 0,  cols: 7},\r\n  jump: { rows: 1,  cols: 7}, \r\n  fall: { rows: 2,  cols: 7}, \r\n  run: {  rows: 3,  cols: 9}, \r\n  dizzy:{ rows: 4,  cols: 11},\r\n  sit: {  rows: 5,  cols: 5}, \r\n  roll: { rows: 6,  cols: 7}, \r\n  bite:{  rows: 7,  cols: 7}, \r\n  ko: {   rows: 8,  cols: 12},\r\n  gethit:{rows: 9,  cols: 4,  }\r\n};\r\nvar animaIndex = 0; // 动画索引\r\nvar frameIndex = 0; // 帧索引\r\nvar frameCount = 0; // 总的帧数\r\nvar stageFrame = 5; // 交错帧，每隔5帧 切换关键帧\r\nfunction animate() {\r\n  frameIndex =\r\n    Math.floor(frameCount++ / stageFrame) % animations[playerState].cols;\r\n  animaIndex = animations[playerState].rows;\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer,\r\n    frameIndex * Sprite_WIDTH,\r\n    animaIndex * Sprite_HEIGHT,\r\n    Sprite_WIDTH,\r\n    Sprite_HEIGHT,\r\n    0,\r\n    0,\r\n    CANVAS_WIDTH,\r\n    CANVAS_HEIGHT\r\n  );\r\n  // requestAnimationFrame效果上相当于60fps的setInterval\r\n  requestAnimationFrame(animate); \r\n}\r\nanimate();\r\n</script>\r\n\r\n```html\r\n<canvas id=\"myCanvas_2j0923ru48\"></canvas>\r\n\r\n<div class=\"animation-box\">\r\n\t<label for=\"animations\">select animation:</label>\r\n\t<select name=\"\" id=\"animations_djf9498\">\r\n\t\t<option value=\"idle\">idle</option>\r\n\t\t<option value=\"jump\">jump</option>\r\n\t\t<option value=\"fall\">fall</option>\r\n\t\t<option value=\"run\">run</option>\r\n\t\t<option value=\"dizzy\">dizzy</option>\r\n\t\t<option value=\"sit\">sit</option>\r\n\t\t<option value=\"roll\">roll</option>\r\n\t\t<option value=\"bite\">bite</option>\r\n\t\t<option value=\"ko\">ko</option>\r\n\t\t<option value=\"gethit\">gethit</option>\r\n\t</select>\r\n</div>\r\n<img src=\"./images/shadow_dog.png\">\r\n<script>\r\nvar myCanvas = document.querySelector(\"#myCanvas_2j0923ru48\");\r\nvar ctx = myCanvas.getContext(\"2d\"); // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n// canvas的默认大小为300x150px 需手动修改\r\nvar CANVAS_WIDTH = (myCanvas.width = 250);\r\nvar CANVAS_HEIGHT = (myCanvas.height = 250);\r\nvar Sprite_WIDTH = 575;\r\nvar Sprite_HEIGHT = 523;\r\nvar imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./images/shadow_dog.png\";\r\nvar playerState = \"idle\";\r\nvar selector = document.querySelector(\"#animations_djf9498\");\r\nselector.addEventListener(\"change\", function () {\r\n  playerState = selector.value;\r\n});\r\nvar animations = {\r\n  idle: { rows: 0,  cols: 7},\r\n  jump: { rows: 1,  cols: 7},\r\n  fall: { rows: 2,  cols: 7},\r\n  run: {  rows: 3,  cols: 9},\r\n  dizzy:{ rows: 4,  cols: 11},\r\n  sit: {  rows: 5,  cols: 5},\r\n  roll: { rows: 6,  cols: 7},\r\n  bite:{  rows: 7,  cols: 7},\r\n  ko: {   rows: 8,  cols: 12},\r\n  gethit:{rows: 9,  cols: 4,  }\r\n};\r\nvar animaIndex = 0; // 动画索引\r\nvar frameIndex = 0; // 帧索引\r\nvar frameCount = 0; // 总的帧数\r\nvar stageFrame = 5; // 交错帧，每隔5帧 切换关键帧\r\nfunction animate() {\r\n  frameIndex =\r\n    Math.floor(frameCount++ / stageFrame) % animations[playerState].cols;\r\n  animaIndex = animations[playerState].rows;\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer,\r\n    frameIndex * Sprite_WIDTH,\r\n    animaIndex * Sprite_HEIGHT,\r\n    Sprite_WIDTH,\r\n    Sprite_HEIGHT,\r\n    0,\r\n    0,\r\n    CANVAS_WIDTH,\r\n    CANVAS_HEIGHT\r\n  );\r\n  // requestAnimationFrame效果上相当于60fps的setInterval\r\n  requestAnimationFrame(animate);\r\n}\r\nanimate();\r\n```\r\n\r\n### 2.2.3. 封装和抽象\r\n\r\n### 2.2.4. 对动画对象 Animater 的封装\r\n\r\n```ts\r\nimport { RandomRange } from \"./utils.js\";\r\n// 动画对象\r\nexport class Animater {\r\n\tposX = 0; // 位置x\r\n\tposY = 0; // 位置y\r\n\tdrawWidth: number; // 实际绘制的宽度\r\n\tdrawHeight: number; // 实际绘制的高度\r\n\timg: HTMLImageElement; // 图片\r\n\timgFrameWidth: number; // 一帧的宽度\r\n\timgFrameHeight: number; // 一帧的高度\r\n\tanimateFramesTotal: Array<number>; // [动画1的总帧数,动画2的总帧数,动画3的...]\r\n\tanimateNameIndexMap: Array<string>; // 数据结构：{动画名称:该动画是第几个动画}\r\n\tanimateFrameIndexX = 0; // 当前绘制的是第几帧\r\n\tanimateFrameIndexY = 0; // 当前绘制的是第几个动画\r\n\tanimateFrameTimer = 0;\r\n\tprivate _animateFrameFps = 60;\r\n\tprivate animateFrameChangeInterval = 1000 / 60;\r\n\tprivate get animateFrameFps() {\r\n\t\treturn this._animateFrameFps;\r\n\t}\r\n\tprivate set animateFrameFps(fps) {\r\n\t\tthis._animateFrameFps = fps;\r\n\t\tthis.animateFrameChangeInterval = 1000 / fps;\r\n\t}\r\n\tpublic setFps(fps: number) {\r\n\t\tthis.animateFrameFps = fps;\r\n\t}\r\n\tstopAnimateAtLastFlag = false;\r\n\tRewindAnimateFrameFlag = false;\r\n\tconstructor(\r\n\t\timgSrc: string,\r\n\t\timgFrameWidth: number,\r\n\t\timgFrameHeight: number,\r\n\t\tsize: number,\r\n\t\tanimateFramesTotal: Array<number>,\r\n\t\tanimateNameIndexMap: Array<string>\r\n\t) {\r\n\t\tthis.img = new Image();\r\n\t\tthis.img.src = imgSrc;\r\n\t\tthis.animateFramesTotal = animateFramesTotal;\r\n\t\tthis.animateNameIndexMap = animateNameIndexMap;\r\n\t\tthis.imgFrameWidth = imgFrameWidth;\r\n\t\tthis.imgFrameHeight = imgFrameHeight;\r\n\t\tthis.drawWidth = this.imgFrameWidth * size;\r\n\t\tthis.drawHeight = this.imgFrameHeight * size;\r\n\t\tthis.setFps(60);\r\n\t}\r\n\t// 更新数据\r\n\tupdate(timeInterval: number): void {\r\n\t\t// 最后一帧则停止切换帧\r\n\t\tif (this.stopAnimateAtLastFlag == true && this.isLastAnimateFrame()) return;\r\n\t\t// 计算下一帧\r\n\t\tif (this.animateFrameTimer >= this.animateFrameChangeInterval) {\r\n\t\t\tthis.animateFrameTimer = 0;\r\n\t\t\tthis.animateFrameIndexX += 1;\r\n\t\t\tthis.animateFrameIndexX %= this.animateFramesTotal[this.animateFrameIndexY];\r\n\t\t} else this.animateFrameTimer += timeInterval;\r\n\t}\r\n\t// 绘制帧\r\n\tdraw(Context2D: CanvasRenderingContext2D): void {\r\n\t\tContext2D.drawImage(\r\n\t\t\tthis.img,\r\n\t\t\tthis.animateFrameIndexX * this.imgFrameWidth,\r\n\t\t\tthis.animateFrameIndexY * this.imgFrameHeight,\r\n\t\t\tthis.imgFrameWidth,\r\n\t\t\tthis.imgFrameHeight,\r\n\t\t\tthis.posX,\r\n\t\t\tthis.posY,\r\n\t\t\tthis.drawWidth,\r\n\t\t\tthis.drawHeight\r\n\t\t);\r\n\t}\r\n\tchangeAnimateByName(animateName: string) {\r\n\t\t// 根据名称切换动画\r\n\t\tif (this.animateNameIndexMap.includes(animateName)) this.animateFrameIndexY = this.animateNameIndexMap.indexOf(animateName);\r\n\t\telse throw new Error(`animateName:'${animateName}' is not exist.`);\r\n\t\tthis.init();\r\n\t}\r\n\t// 判断是否为最后一帧\r\n\tisLastAnimateFrame() {\r\n\t\treturn this.animateFrameIndexX == this.animateFramesTotal[this.animateFrameIndexY] - 1;\r\n\t}\r\n\t// 判断是否为第一帧\r\n\tisFirstAnimateFrame() {\r\n\t\treturn this.animateFrameIndexX == 0;\r\n\t}\r\n\t// 初始化状态\r\n\tinit() {\r\n\t\tthis.animateFrameIndexX = 0; // 设置从第一帧开始\r\n\t}\r\n\t// 请求在渲染到最后一帧的时候停止更新动画\r\n\trequestStopAnimateFrameAtLastFrame() {\r\n\t\tthis.stopAnimateAtLastFlag = true;\r\n\t}\r\n\tisOutOfLeftScreem() {\r\n\t\treturn this.posX + this.drawWidth < 0;\r\n\t}\r\n}\r\n```\r\n\r\n### 2.2.5. 继续定义一些列接口并定义 Animal 类\r\n\r\n```ts\r\nimport { Animater } from \"./Animater.js\";\r\nimport { transformAble } from \"./transformAble.js\";\r\n\r\n// 可移动的\r\ninterface MoveAble {\r\n\tmoveSpeedX: number; // x轴移动速度 单位：像素/毫秒\r\n\tmoveSpeedY: number; // x轴移动速度 单位：像素/毫秒\r\n\tmove(timeInterval: number): void; // 移动\r\n}\r\n// 活的\r\ninterface AliveAble {\r\n\taliveFlag: boolean;\r\n\tgetAliveFlag(): boolean; // 用于判断是否存活\r\n\tsetAliveFlag(newVal: boolean): void;\r\n}\r\n// 圆形碰撞检测\r\ninterface CollisionCheckAble {\r\n\tcollisionCheckPosX: number;\r\n\tcollisionCheckPosY: number;\r\n\tcollisionCheckWidth: number;\r\n\tcollisionCheckHeight: number;\r\n\tcollisionCheckRadius: number;\r\n\tcollisionCheckUpdate(): void;\r\n\tisCollision(obj: CollisionCheckAble): boolean; // 碰撞检测\r\n}\r\ninterface NameAble {\r\n\tName: string;\r\n\tgetName(): string;\r\n}\r\n\r\n// 抽象类 Animal 继承动画类 实现Moveable AliveAble 接口\r\nexport abstract class Animal extends Animater implements MoveAble, AliveAble, CollisionCheckAble, NameAble, transformAble {\r\n\t// 移动\r\n\tmoveSpeedX = 0;\r\n\tmoveSpeedY = 0;\r\n\tabstract move(timeInterval: number): void;\r\n\t// 存活\r\n\taliveFlag = true;\r\n\tsetAliveFlag(newVal: boolean): void {\r\n\t\tthis.aliveFlag = newVal;\r\n\t}\r\n\tgetAliveFlag(): boolean {\r\n\t\treturn this.aliveFlag;\r\n\t}\r\n\t// 可碰撞检测\r\n\tcollisionCheckPosX = 0;\r\n\tcollisionCheckPosY = 0;\r\n\tcollisionCheckWidth = 0;\r\n\tcollisionCheckHeight = 0;\r\n\tcollisionCheckRadius = 0;\r\n\tcollisionCheckUpdate(): void {\r\n\t\t// 圆形碰撞检测\r\n\t\tthis.collisionCheckPosX = this.posX + this.drawWidth / 2;\r\n\t\tthis.collisionCheckPosY = this.posY + this.drawHeight / 2;\r\n\t\tthis.collisionCheckRadius = (Math.min(this.drawWidth, this.drawHeight) / 2) * 0.8;\r\n\t}\r\n\tisCollision(obj: CollisionCheckAble): boolean {\r\n\t\tthis.collisionCheckUpdate();\r\n\t\tobj.collisionCheckUpdate();\r\n\t\tconst dX = this.collisionCheckPosX - obj.collisionCheckPosX;\r\n\t\tconst dY = this.collisionCheckPosY - obj.collisionCheckPosY;\r\n\t\tconst distance = Math.sqrt(dX * dX + dY * dY);\r\n\t\treturn distance < this.collisionCheckRadius + obj.collisionCheckRadius;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.collisionCheckUpdate();\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D): void {\r\n\t\t// Context2D.beginPath();\r\n\t\t// Context2D.arc(this.collisionCheckPosX, this.collisionCheckPosY, this.collisionCheckRadius, 0, Math.PI * 2);\r\n\t\t// Context2D.stroke();\r\n\t\t// Context2D.strokeRect(this.posX, this.posY, this.drawWidth, this.drawHeight);\r\n\t\tsuper.draw(Context2D);\r\n\t}\r\n\t// put it on ground();\r\n\tsetOnGround(groundPosY: number): Animal {\r\n\t\tthis.posY = groundPosY - this.drawHeight;\r\n\t\treturn this;\r\n\t}\r\n\t// 水平和垂直平移\r\n\ttransform(stepX: number, stepY: number) {\r\n\t\tthis.posX += stepX;\r\n\t\tthis.posY += stepY;\r\n\t}\r\n\tabstract Name: string;\r\n\tgetName(): string {\r\n\t\tthis.Name;\r\n\t\treturn this.Name;\r\n\t}\r\n}\r\n```\r\n\r\n### 2.2.6. 使用\r\n\r\n于是，定义一个游戏角色：蠕虫，就会变得如此简单\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Worm extends Animal {\r\n\tName = \"Worm\";\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(\"./imgs/Worm.png\", 229, 171, 0.5, [6], [\"idle\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.moveSpeedX = RandomRange(0.05, 0.1);\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX -= this.moveSpeedX * timeInterval;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.move(timeInterval);\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n```\r\n\r\n## 2.3. 敌人的移动模式\r\n\r\n### 2.3.1. 原地静止的物体\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 鬼\r\nexport class Plant extends Animal {\r\n\tName = \"Plant\";\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(\"./imgs/enemy_plant.png\", 60, 87, 1.5, [2], [\"default\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.setFps(10);\r\n\t}\r\n\tmove(timeInterval: number): void {\r\n\t\treturn;\r\n\t}\r\n}\r\n```\r\n\r\n### 2.3.2. 水平直线运动的蠕虫\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Worm extends Animal {\r\n\tName = \"Worm\";\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(\"./imgs/Worm.png\", 229, 171, 0.5, [6], [\"idle\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.moveSpeedX = RandomRange(0.05, 0.1);\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX -= this.moveSpeedX * timeInterval;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.move(timeInterval);\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n```\r\n\r\n### 2.3.3. 上下摆动的蝙蝠\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Bat extends Animal {\r\n\tName = \"Bat\";\r\n\tshakeAngle = 0; // 摆动角度,初始摆动角度 单位: 弧度\r\n\tshakeDeltaAngle: number; // 摆动增量 单位:弧度/毫秒\r\n\tshakeGapRadius: number; // 摆动范围半径 单位：像素\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(\"./imgs/Bat.png\", 266, 188, 0.5, [6], [\"idle\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.moveSpeedX = RandomRange(0.05, 0.1);\r\n\r\n\t\tthis.shakeAngle = RandomRange(Math.asin(-1), Math.asin(1));\r\n\t\tthis.shakeDeltaAngle = RandomRange(Math.asin(0.001), Math.asin(0.003));\r\n\t\tthis.shakeGapRadius = RandomRange(2, 5);\r\n\t}\r\n\tshake(timeInterval: number) {\r\n\t\tthis.posY += this.shakeGapRadius * Math.sin(this.shakeAngle);\r\n\t\tthis.shakeAngle += this.shakeDeltaAngle * timeInterval;\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX -= this.moveSpeedX * timeInterval;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.move(timeInterval);\r\n\t\tthis.shake(timeInterval);\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n```\r\n\r\n**周期线性运动的蝙蝠**\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class GhostBird extends Animal {\r\n\tName = \"GhostBird\";\r\n\r\n\tasline: {\r\n\t\tangle: number;\r\n\t\tangleIncreaseSpeed: number;\r\n\t\tfactorX: number;\r\n\t\tfactorY: number;\r\n\t} = {\r\n\t\tangle: 0,\r\n\t\tangleIncreaseSpeed: 0,\r\n\t\tfactorX: 0,\r\n\t\tfactorY: 0\r\n\t};\r\n\r\n\tCANVAS_WIDTH: number;\r\n\tCANVAS_HEIGHT: number;\r\n\toffsetY: number;\r\n\toffsetX: number;\r\n\r\n\tconstructor(posX: number, posY: number, CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n\t\tsuper(\"./imgs/GhostBird.png\", 218, 177, 0.5, [6], [\"idle\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.CANVAS_WIDTH = CANVAS_WIDTH;\r\n\t\tthis.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n\t\tthis.moveSpeedX = RandomRange(0.4, 1);\r\n\t\t// for asline\r\n\t\tthis.offsetX = 0; // 相对于屏幕右上角0，0位置的偏移量\r\n\t\tthis.offsetY = 0;\r\n\t\tthis.asline.angle = (Math.PI / 365) * RandomRange(-365, 365); // 初相角 -1 ~ 1\r\n\t\tthis.asline.angleIncreaseSpeed = (Math.PI / 365) * RandomRange(30, 90) * Math.sign(RandomRange(-1, 1)); // 移动周期 30~90 感觉不错\r\n\t\tthis.asline.factorX = (Math.PI / 365) * 0.45;\r\n\t\tthis.asline.factorY = (Math.PI / 365) * 0.35;\r\n\t}\r\n\ttransform(stepX: number, stepY: number): void {\r\n\t\t// this.offsetX += stepX;\r\n\t\t// this.offsetY += stepY;\r\n\t}\r\n\tmove_asline(timeInterval: number) {\r\n\t\t// 线性运动\r\n\t\tthis.posX =\r\n\t\t\tthis.offsetX + (this.CANVAS_WIDTH / 2) * Math.cos(this.asline.angle * this.asline.factorX) + (this.CANVAS_WIDTH / 2 - this.drawWidth / 2);\r\n\t\tthis.posY =\r\n\t\t\tthis.offsetY + (this.CANVAS_HEIGHT / 2) * Math.sin(this.asline.angle * this.asline.factorY) + (this.CANVAS_HEIGHT / 2 - this.drawHeight / 2);\r\n\t\tconst angleStep = this.asline.angleIncreaseSpeed * timeInterval;\r\n\t\tthis.asline.angle += angleStep;\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX -= this.moveSpeedX * timeInterval;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.move_asline(timeInterval);\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n```\r\n\r\n### 2.3.4. 随机无规律移动的齿轮\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Gear extends Animal {\r\n\tName = \"Gear\";\r\n\treArrange_NewPosX: number;\r\n\treArrange_NewPosY: number;\r\n\treArrange_MoveSpeed: number; // 移动速度\r\n\treArrange_Timer = 0;\r\n\treArrange_TimeInterval: number;\r\n\tCANVAS_WIDTH: number;\r\n\tCANVAS_HEIGHT: number;\r\n\r\n\tconstructor(posX: number, posY: number, CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n\t\tsuper(\"./imgs/Gear.png\", 213, 212, 0.5, [6], [\"idle\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.CANVAS_WIDTH = CANVAS_WIDTH;\r\n\t\tthis.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n\r\n\t\tthis.moveSpeedX = RandomRange(0.4, 1);\r\n\r\n\t\t// randomReArrange_ment\r\n\t\tthis.reArrange_NewPosX = this.posX;\r\n\t\tthis.reArrange_NewPosY = this.posY;\r\n\t\tthis.reArrange_TimeInterval = Math.floor(RandomRange(500, 2000)); // 0.5 ~ 2 秒\r\n\t\tthis.reArrange_MoveSpeed = RandomRange(0.5, 2.0);\r\n\t}\r\n\t// 平移\r\n\ttransform(stepX: number, stepY: number): void {\r\n\t\treturn;\r\n\t\t// 决定其是否跟随场景移动的代码\r\n\t\tthis.posX += stepX;\r\n\t\tthis.posY += stepY;\r\n\t\tthis.reArrange_NewPosX += stepX; // dx要根据这个来计算，所以也要平移\r\n\t\tthis.reArrange_NewPosY += stepY;\r\n\t}\r\n\treArrange(timeInterval: number) {\r\n\t\t// 重新排列\r\n\t\tif ((this.reArrange_Timer += timeInterval) >= this.reArrange_TimeInterval) {\r\n\t\t\tthis.reArrange_Timer = 0;\r\n\t\t\t// 随机位置，注意其范围区间\r\n\t\t\tthis.reArrange_NewPosX = RandomRange(0, this.CANVAS_WIDTH);\r\n\t\t\tthis.reArrange_NewPosY = RandomRange(0, this.CANVAS_HEIGHT);\r\n\t\t\tconsole.log(this.reArrange_NewPosX);\r\n\t\t\tconsole.log(this.reArrange_NewPosY);\r\n\t\t}\r\n\t\tconst dx = (this.reArrange_NewPosX - this.posX) / 1000;\r\n\t\tconst dy = (this.reArrange_NewPosY - this.posY) / 1000;\r\n\t\tconst moveStep = this.reArrange_MoveSpeed * timeInterval;\r\n\t\tthis.posX += dx * moveStep;\r\n\t\tthis.posY += dy * moveStep;\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX -= this.moveSpeedX * timeInterval;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.reArrange(timeInterval);\r\n\t\t// this.move(timeInterval);\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n```\r\n\r\n## 2.4. 视差背景原理\r\n\r\n### 2.4.1. 无限滚动的背景原理\r\n\r\n[](./practices/3.%E8%A7%86%E5%B7%AE%E8%83%8C%E6%99%AF%EF%BC%9A%E5%8E%9F%E7%90%86/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\n// 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 800);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 700);\r\n\r\nlet gameScrollSpeed = 10;\r\n\r\n// 层\r\nconst backgroundLayer1 = new Image();\r\nbackgroundLayer1.src = \"./imgs/layer-1.png\";\r\nconst backgroundLayer2 = new Image();\r\nbackgroundLayer2.src = \"./imgs/layer-2.png\";\r\nconst backgroundLayer3 = new Image();\r\nbackgroundLayer3.src = \"./imgs/layer-3.png\";\r\nconst backgroundLayer4 = new Image();\r\nbackgroundLayer4.src = \"./imgs/layer-4.png\";\r\nconst backgroundLayer5 = new Image();\r\nbackgroundLayer5.src = \"./imgs/layer-5.png\";\r\n\r\nlet Layer4offsetX1 = 0;\r\nlet Layer4offsetX2 = 2400;\r\n(function animate() {\r\n\tctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n\tctx.drawImage(backgroundLayer4, Layer4offsetX1, 0);\r\n\tctx.drawImage(backgroundLayer5, Layer4offsetX2, 0);\r\n\t// 如果第一张图滚动展示完毕，就将其放到第二张图的后面\r\n\tif (Layer4offsetX1 < -2400) Layer4offsetX1 = Layer4offsetX2 + 2400;\r\n\t// 如果第二张图滚动展示完毕，就将其放到第一张图的后面\r\n\tif (Layer4offsetX2 < -2400) Layer4offsetX2 = Layer4offsetX1 + 2400;\r\n\tLayer4offsetX1 -= gameScrollSpeed; // 更新位置\r\n\tLayer4offsetX2 -= gameScrollSpeed; // 更新位置\r\n\trequestAnimationFrame(animate); // 刷新\r\n})();\r\n```\r\n\r\n### 2.4.2. 视差背景的实现\r\n\r\n[视差背景.html](./practices/4.视差背景：优化/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D; // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 1080);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 720);\r\n\r\nlet gameScrollSpeed = 10;\r\n\r\nconst backgroundLayer1 = new Image();\r\nbackgroundLayer1.src = \"./imgs/layer-1.png\";\r\nconst backgroundLayer2 = new Image();\r\nbackgroundLayer2.src = \"./imgs/layer-2.png\";\r\nconst backgroundLayer3 = new Image();\r\nbackgroundLayer3.src = \"./imgs/layer-3.png\";\r\nconst backgroundLayer4 = new Image();\r\nbackgroundLayer4.src = \"./imgs/layer-4.png\";\r\nconst backgroundLayer5 = new Image();\r\nbackgroundLayer5.src = \"./imgs/layer-5.png\";\r\n\r\nlet baclkgroundlayers = [\r\n\t{\r\n\t\tname: \"layer1\",\r\n\t\timg: backgroundLayer1,\r\n\t\timgWidth: 2400,\r\n\t\tXoffset1: 0,\r\n\t\tXoffset2: 2400,\r\n\t\tspeedModify: 0.1\r\n\t},\r\n\t{\r\n\t\tname: \"layer2\",\r\n\t\timg: backgroundLayer2,\r\n\t\timgWidth: 2400,\r\n\t\tXoffset1: 0,\r\n\t\tXoffset2: 2400,\r\n\t\tspeedModify: 0.3\r\n\t},\r\n\t{\r\n\t\tname: \"layer3-cloud\",\r\n\t\timg: backgroundLayer3,\r\n\t\timgWidth: 2400,\r\n\t\tXoffset1: 0,\r\n\t\tXoffset2: 2400,\r\n\t\tspeedModify: 0.5\r\n\t},\r\n\t{\r\n\t\tname: \"layer4\",\r\n\t\timg: backgroundLayer4,\r\n\t\timgWidth: 2400,\r\n\t\tXoffset1: 0,\r\n\t\tXoffset2: 2400,\r\n\t\tspeedModify: 0.65\r\n\t},\r\n\t{\r\n\t\tname: \"layer5-floor\",\r\n\t\timg: backgroundLayer5,\r\n\t\timgWidth: 2400,\r\n\t\tXoffset1: 0,\r\n\t\tXoffset2: 2400,\r\n\t\tspeedModify: 1.0\r\n\t}\r\n];\r\n\r\nfunction refreshBackgroundLayers() {\r\n\t// 渲染背景\r\n\tbaclkgroundlayers.forEach(layerItem => {\r\n\t\t// 逐层渲染背景\r\n\t\tctx.drawImage(layerItem.img, layerItem.Xoffset1, 0);\r\n\t\tctx.drawImage(layerItem.img, layerItem.Xoffset2, 0);\r\n\t\tif (layerItem.Xoffset1 < -layerItem.imgWidth) layerItem.Xoffset1 = layerItem.Xoffset2 + layerItem.imgWidth; // 如果第一张图滚动展示完毕，就将其放到第二张图的后面\r\n\t\tif (layerItem.Xoffset2 < -layerItem.imgWidth) layerItem.Xoffset2 = layerItem.Xoffset1 + layerItem.imgWidth; // 如果第二张图滚动展示完毕，就将其放到第一张图的后面\r\n\t\tlayerItem.Xoffset1 -= gameScrollSpeed * layerItem.speedModify; // 更新位置\r\n\t\tlayerItem.Xoffset2 -= gameScrollSpeed * layerItem.speedModify; // 更新位置\r\n\t});\r\n}\r\n\r\n(function animate() {\r\n\tctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // 清除\r\n\trefreshBackgroundLayers(); // 渲染背景\r\n\trequestAnimationFrame(animate); // 刷新\r\n})();\r\n```\r\n\r\n### 2.4.3. 最终的抽象、封装、实现\r\n\r\n```ts\r\n// 可滚动的背景层\r\nexport class Layer {\r\n\treadonly CANVAS_WIDTH: number;\r\n\treadonly CANVAS_HEIGHT: number;\r\n\timg: HTMLImageElement;\r\n\timgWidth: number;\r\n\timgHeight: number;\r\n\tpos1_X: number;\r\n\tpox1_Y: number;\r\n\tpos2_X: number;\r\n\tpox2_Y: number;\r\n\tprivate layerMoveSpeedX = 0; // 层的移动速度,一个背景的所有层的移动速度应当是一致的\r\n\tprivate layerMoveSpeedFactor = 1.0; // 层的移动速度的系数，一个背景有多个层，多个层的移动速度一致，但移动速度的系数可能不一致\r\n\tconstructor(CANVAS_WIDTH: number, CANVAS_HEIGHT: number, imgSrc: string, imgWidth: number, imgHeight: number, layerMoveSpeedFactor: number) {\r\n\t\tthis.CANVAS_WIDTH = CANVAS_WIDTH;\r\n\t\tthis.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n\t\tthis.img = new Image();\r\n\t\tthis.img.src = imgSrc;\r\n\t\tthis.imgWidth = imgWidth;\r\n\t\tthis.imgHeight = imgHeight;\r\n\t\tthis.layerMoveSpeedFactor = layerMoveSpeedFactor;\r\n\t\tthis.pos1_X = 0;\r\n\t\tthis.pox1_Y = 0;\r\n\t\tthis.pos2_X = this.imgWidth;\r\n\t\tthis.pox2_Y = 0;\r\n\t}\r\n\tupdate(timeInterval: number) {\r\n\t\tthis.pos1_X += this.layerMoveSpeedX * this.layerMoveSpeedFactor * timeInterval;\r\n\t\tthis.pos2_X += this.layerMoveSpeedX * this.layerMoveSpeedFactor * timeInterval;\r\n\t\t// 图层向左移动，图层出界，向后添加新图层\r\n\t\tif (this.layerMoveSpeedX < 0 && this.pos1_X + this.imgWidth <= 0) this.pos1_X = this.pos2_X + this.imgWidth; // 图1出界就将其放置到图2之后\r\n\t\tif (this.layerMoveSpeedX < 0 && this.pos2_X + this.imgWidth <= 0) this.pos2_X = this.pos1_X + this.imgWidth; // 图2出界就将其放置到图1之后\r\n\t\t// 图层向右移动，图层出界，向前添加新图层\r\n\t\tif (this.layerMoveSpeedX > 0 && this.pos1_X >= 0) this.pos2_X = this.pos1_X - this.imgWidth; // 图1出界就将其放置到图2之后\r\n\t\tif (this.layerMoveSpeedX > 0 && this.pos2_X >= 0) this.pos1_X = this.pos2_X - this.imgWidth; // 图2出界就将其放置到图1之后\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D) {\r\n\t\tContext2D.drawImage(this.img, 0, 0, this.imgWidth, this.imgHeight, this.pos1_X, this.pox1_Y, this.imgWidth, this.CANVAS_HEIGHT);\r\n\t\tContext2D.drawImage(this.img, 0, 0, this.imgWidth, this.imgHeight, this.pos2_X, this.pox2_Y, this.imgWidth, this.CANVAS_HEIGHT);\r\n\t}\r\n\tsetSpeed(newSpeed: number) {\r\n\t\tthis.layerMoveSpeedX = newSpeed;\r\n\t}\r\n}\r\n\r\n// 可滚动的背景，该背景包含多个层\r\nexport abstract class Background {\r\n\tprivate _backgroundMoveSpeedX = 0; // 背景移动速度\r\n\tlayers: Array<Layer> = []; // 背景\r\n\tconstructor() {\r\n\t\tthis.setSpeed(0);\r\n\t}\r\n\tupdate(timeInterval: number) {\r\n\t\tthis.layers.forEach(layer => layer.update(timeInterval));\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D) {\r\n\t\tthis.layers.forEach(layer => layer.draw(Context2D));\r\n\t}\r\n\tgetSpeed() {\r\n\t\treturn this._backgroundMoveSpeedX;\r\n\t}\r\n\t// 修改背景的速度就是修改要所有层的移动速度，这里做等值判断是防止for循环浪费性能\r\n\tsetSpeed(newSpeed: number) {\r\n\t\tif (this._backgroundMoveSpeedX != newSpeed) {\r\n\t\t\tthis.layers.forEach(item => item.setSpeed(newSpeed)); // 更新所有层的速度\r\n\t\t\tthis._backgroundMoveSpeedX = newSpeed; // 更新背景速度\r\n\t\t}\r\n\t}\r\n\tabstract getGroundPosY(): number;\r\n}\r\n```\r\n\r\n### 2.4.4. 使用封装好的类实现一个视差背景\r\n\r\n现在实现一张视差背景只需要几行最关键的代码\r\n\r\n```ts\r\nimport { Background, Layer } from \"./Background.js\";\r\n// 背景city，由1层构成\r\nexport class BackgroundCity extends Background {\r\n\tCANVAS_WIDTH: number;\r\n\tCANVAS_HEIGHT: number;\r\n\tconstructor(CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n\t\tsuper();\r\n\t\tthis.layers.push(new Layer(CANVAS_WIDTH, CANVAS_HEIGHT, \"./imgs/cityLayers/layer-1.png\", 2400, 720, 0.0));\r\n\t\tthis.layers.push(new Layer(CANVAS_WIDTH, CANVAS_HEIGHT, \"./imgs/cityLayers/layer-2.png\", 2400, 720, 0.1));\r\n\t\tthis.layers.push(new Layer(CANVAS_WIDTH, CANVAS_HEIGHT, \"./imgs/cityLayers/layer-3.png\", 2400, 720, 0.3));\r\n\t\tthis.layers.push(new Layer(CANVAS_WIDTH, CANVAS_HEIGHT, \"./imgs/cityLayers/layer-4.png\", 2400, 720, 0.5));\r\n\t\tthis.layers.push(new Layer(CANVAS_WIDTH, CANVAS_HEIGHT, \"./imgs/cityLayers/layer-5.png\", 2400, 720, 1.0));\r\n\t\tthis.CANVAS_WIDTH = CANVAS_WIDTH;\r\n\t\tthis.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n\t}\r\n\tgetGroundPosY(): number {\r\n\t\treturn this.CANVAS_HEIGHT - 120;\r\n\t}\r\n}\r\n```\r\n\r\n## 2.5. 碰撞检测\r\n\r\n### 2.5.1. 矩形碰撞检测\r\n\r\n```ts\r\ninterface Rect {\r\n\tx: number;\r\n\ty: number;\r\n\tw: number;\r\n\th: number;\r\n}\r\nfunction RectColisionDetector(reactA: Rect, reactB: Rect) {\r\n\treturn reactA.x < reactB.x + reactB.w && reactA.x + reactA.w > reactB.x && reactA.y < reactB.y + reactB.h && reactA.y + reactA.h > reactB.y;\r\n}\r\n```\r\n\r\n### 2.5.2. 圆形碰撞检测\r\n\r\n```ts\r\ninterface Cycle {\r\n\tx: number;\r\n\ty: number;\r\n\tradius: number;\r\n}\r\n\r\nfunction CycleColisionDetector(cycleA: Cycle, cycleB: Cycle) {\r\n\tlet distance = Math.sqrt(Math.pow(cycleA.x - cycleB.x, 2) + Math.pow(cycleA.y - cycleB.y, 2)); // 求两坐标间距离公式\r\n\treturn distance < cycleA.radius + cycleB.radius;\r\n}\r\n```\r\n\r\n### 2.5.3. 像素碰撞检测\r\n\r\n像素碰撞检测依赖于两个 Canvas 图层，绘制对象时，将对象的轮廓和实际图像分开绘制。\r\n\r\n对象轮廓图层中的对象填充有颜色，可以认为这个颜色是该对象的唯一标识，\r\n\r\n当鼠标点击轮廓图层时可以通过点击事件的坐标获取到点击处的像素值\r\n\r\n通过像素值，遍历所有对象，匹配对象的颜色属性值，\r\n\r\n就能判断用户是否点击到该对象\r\n\r\n```ts\r\n// 像素碰撞检测\r\nfunction pixelCollsionDetection(pixelA: [number, number, number], pixelB: [number, number, number]) {\r\n\treturn pixelA[0] == pixelB[0] && pixelA[1] == pixelB[1] && pixelA[2] == pixelB[2];\r\n}\r\n\r\n// 鼠标点击事件监听，获取点击处的像素点\r\nmyCanvas.addEventListener(\"mousedown\", event => {\r\n\tlet pos: Position = { x: event.offsetX, y: event.offsetY };\r\n\tlet imgdata = ctxCollision.getImageData(pos.x, pos.y, 1, 1); // 获取一个像素颜色\r\n\tfor (let index = 0; index < enemys.length; index++) {\r\n\t\tconst item = enemys[index];\r\n\t\tif (pixelCollsionDetection(item.collisionColor, imgdata)) {\r\n\t\t\t// 像素碰撞检测\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n});\r\n```\r\n\r\n## 2.6. 粒子特效\r\n\r\n### 2.6.1. 定义 Particle 抽象类\r\n\r\n```ts\r\nimport { Animater } from \"./Animater.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\nexport abstract class Particle {\r\n\tposX: number;\r\n\tposY: number;\r\n\tmovespeedX = 0;\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t}\r\n\tabstract update(timeInterval: number): void;\r\n\tabstract draw(Context2D: CanvasRenderingContext2D): void;\r\n\tsetSpeedX(newSpeed: number) {\r\n\t\tthis.movespeedX = newSpeed;\r\n\t}\r\n}\r\n```\r\n\r\n### 2.6.2. 灰尘影子的实现\r\n\r\n该特效的实现的关键点是透明度的衰减速度和圆形半径的衰减速度，\r\n\r\n需要一点一点尝试出来，另外这个地方应该使用全局透明度，而不是字符串拼接`rgba()`\r\n\r\n```ts\r\n// 灰尘\r\nexport class Dust extends Particle {\r\n\tradius: number;\r\n\tfillStyleAlpha: number;\r\n\tfillStyle: string;\r\n\tradiusStep: number;\r\n\tfillStyleAlphaStep: number;\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(RandomRange(posX - 50, posX + 50), RandomRange(posY - 20, posY + 20));\r\n\r\n\t\tthis.radius = RandomRange(10, 20);\r\n\t\tthis.radiusStep = RandomRange(0.3, 0.5);\r\n\r\n\t\tthis.fillStyleAlpha = 1;\r\n\t\tthis.fillStyleAlphaStep = 0.01;\r\n\r\n\t\tthis.fillStyle = `rgba(0,0,0,${this.fillStyleAlpha})`;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tif (this.fillStyleAlpha > this.fillStyleAlphaStep) {\r\n\t\t\tthis.fillStyleAlpha -= this.fillStyleAlphaStep;\r\n\t\t\tthis.fillStyle = `rgba(0,0,0,${this.fillStyleAlpha})`;\r\n\t\t}\r\n\t\tif (this.radius > this.radiusStep) this.radius -= this.radiusStep;\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D): void {\r\n\t\tContext2D.save();\r\n\t\tContext2D.fillStyle = this.fillStyle;\r\n\t\tContext2D.beginPath();\r\n\t\tContext2D.arc(this.posX, this.posY, this.radius, 0, Math.PI * 2);\r\n\t\tContext2D.fill();\r\n\t\tContext2D.restore();\r\n\t}\r\n}\r\n```\r\n\r\n### 2.6.3. 火焰粒子特效\r\n\r\n关键点同上，\r\n\r\n另外代码中似乎应该不需要移动速度，因为火焰的粒子特效是放在场景中的，场景会带着粒子特效移动\r\n\r\n```ts\r\nexport class FireImg extends Particle {\r\n\timg: HTMLImageElement;\r\n\tmovespeedX: number;\r\n\timgHeight: number;\r\n\timgWidth: number;\r\n\tdrawHeight: number;\r\n\tdrawWidth: number;\r\n\tglobalAlpha: number;\r\n\tglobalAlphaStep: number;\r\n\tdrawSize: number;\r\n\tdrawSizeStep: number;\r\n\tconstructor(posX: number, posY: number, movespeedX: number) {\r\n\t\tsuper(RandomRange(posX - 10, posX + 10), RandomRange(posY - 10, posY + 10));\r\n\t\tthis.movespeedX = movespeedX;\r\n\r\n\t\tthis.img = new Image();\r\n\t\tthis.img.src = \"./imgs/fire.png\";\r\n\t\tthis.imgWidth = 100;\r\n\t\tthis.imgHeight = 90;\r\n\t\tthis.drawSize = RandomRange(0, 5);\r\n\t\tthis.drawSizeStep = RandomRange(0.01, 0.2);\r\n\t\tthis.drawWidth = this.imgWidth * this.drawSize;\r\n\t\tthis.drawHeight = this.imgHeight * this.drawSize;\r\n\r\n\t\tthis.globalAlpha = RandomRange(0.5, 1);\r\n\t\tthis.globalAlphaStep = RandomRange(0.01, 0.01);\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tif (this.globalAlpha > this.globalAlphaStep) this.globalAlpha -= this.globalAlphaStep;\r\n\t\tif (this.drawSize > this.drawSizeStep) {\r\n\t\t\tthis.drawSize -= this.drawSizeStep;\r\n\t\t\tthis.drawWidth = this.imgWidth * this.drawSize;\r\n\t\t\tthis.drawHeight = this.imgHeight * this.drawSize;\r\n\t\t}\r\n\t\tthis.posX += this.movespeedX * timeInterval;\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D): void {\r\n\t\tContext2D.save();\r\n\t\tContext2D.globalAlpha = this.globalAlpha;\r\n\t\tContext2D.drawImage(\r\n\t\t\tthis.img,\r\n\t\t\t0,\r\n\t\t\t0,\r\n\t\t\tthis.imgWidth,\r\n\t\t\tthis.imgHeight,\r\n\t\t\tthis.posX - this.drawWidth / 2,\r\n\t\t\tthis.posY - this.drawHeight / 2,\r\n\t\t\tthis.drawWidth,\r\n\t\t\tthis.drawHeight\r\n\t\t);\r\n\t\tContext2D.restore();\r\n\t}\r\n}\r\n```\r\n\r\n### 2.6.4. 落地的爆炸火花粒子特效\r\n\r\n这个地方的关键点比较多，除了衰减半径和衰减透明度，还需要考虑火花飞溅的方向，速度，重力影响。\r\n\r\n首先水平方向上，火花可以左右飞溅，所以粒子的水平方向的移动速度`movespeedY`的正负性应当是随机的。\r\n\r\n另外还需要一个和飞溅速度相反的阻力`movespeedX_f`，来使得火花飞溅速度衰减。\r\n\r\n其次考虑垂直方向，由于是撞向地面导致产生的火花粒子，所以粒子的垂直方向的速度`movespeedY`应当是负，\r\n\r\n另外重力的方向`movespeedY_weight`应当是正的，用于使得粒子向上移动的速度衰减。\r\n\r\n```ts\r\nexport class FireImgSpak extends Particle {\r\n\timg: HTMLImageElement;\r\n\tmovespeedX: number;\r\n\timgHeight: number;\r\n\timgWidth: number;\r\n\tdrawHeight: number;\r\n\tdrawWidth: number;\r\n\tglobalAlpha: number;\r\n\tglobalAlphaStep: number;\r\n\tdrawSize: number;\r\n\tdrawSizeStep: number;\r\n\tmovespeedY: number;\r\n\tmovespeedX_f: number;\r\n\tmovespeedY_weight: number;\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(RandomRange(posX, posX), RandomRange(posY, posY));\r\n\t\tthis.movespeedX = Math.sign(RandomRange(-1, 1)) * RandomRange(0.1, 2);\r\n\t\tthis.movespeedY = -RandomRange(0.1, 2);\r\n\t\tthis.movespeedX_f = -Math.sign(this.movespeedX) * 0.1; // 水平方向阻力,方向和移动方向相反\r\n\t\tthis.movespeedY_weight = 0.1; //垂直方向的重力,和重力方向一致\r\n\r\n\t\tthis.img = new Image();\r\n\t\tthis.img.src = \"./imgs/fire.png\";\r\n\t\tthis.imgWidth = 100;\r\n\t\tthis.imgHeight = 90;\r\n\t\tthis.drawSize = RandomRange(1, 2);\r\n\t\tthis.drawSizeStep = RandomRange(0.01, 0.3);\r\n\t\tthis.drawWidth = this.imgWidth * this.drawSize;\r\n\t\tthis.drawHeight = this.imgHeight * this.drawSize;\r\n\r\n\t\tthis.globalAlpha = RandomRange(0.8, 1);\r\n\t\tthis.globalAlphaStep = RandomRange(0.01, 0.01);\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\t// 透明度衰减\r\n\t\tif (this.globalAlpha > this.globalAlphaStep) this.globalAlpha -= this.globalAlphaStep;\r\n\t\t// 绘制大小衰减\r\n\t\tif (this.drawSize > this.drawSizeStep) {\r\n\t\t\tthis.drawSize -= this.drawSizeStep;\r\n\t\t\tthis.drawWidth = this.imgWidth * this.drawSize;\r\n\t\t\tthis.drawHeight = this.imgHeight * this.drawSize;\r\n\t\t}\r\n\t\t// 水平方向的移动速度根据阻力衰减，由于这两个速度始终方向相反，所以只需要按照衰减速度的方式理解就行，移动速度和摩擦力相加即可\r\n\t\tif (Math.abs(this.movespeedX) > Math.abs(this.movespeedX_f)) this.movespeedX += this.movespeedX_f; // 摩擦力和移动方向相反，所以直接相加\r\n\t\telse this.movespeedX = 0; // 步长衰减到最小值，直接设置为0\r\n\r\n\t\t// 垂直方向\r\n\t\tif (this.movespeedY <= this.movespeedY_weight) this.movespeedY += this.movespeedY_weight; // 重力始终向下，所以相减\r\n\t\telse this.movespeedY = this.movespeedY_weight;\r\n\r\n\t\tthis.posX += this.movespeedX * timeInterval;\r\n\t\tthis.posY += this.movespeedY * timeInterval;\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D): void {\r\n\t\tContext2D.save();\r\n\t\tContext2D.globalAlpha = this.globalAlpha;\r\n\t\tContext2D.drawImage(\r\n\t\t\tthis.img,\r\n\t\t\t0,\r\n\t\t\t0,\r\n\t\t\tthis.imgWidth,\r\n\t\t\tthis.imgHeight,\r\n\t\t\tthis.posX - this.drawWidth / 2,\r\n\t\t\tthis.posY - this.drawHeight / 2,\r\n\t\t\tthis.drawWidth,\r\n\t\t\tthis.drawHeight\r\n\t\t);\r\n\t\tContext2D.restore();\r\n\t}\r\n}\r\n```\r\n\r\n### 2.6.5. 爆炸的烟雾粒子特效\r\n\r\n这里值得一说的是，旋转的实现方法，具体看注释\r\n\r\n```ts\r\nexport class Explosion extends Animater {\r\n\tsound: HTMLAudioElement;\r\n\trotateAngleStep: number;\r\n\trotateAngle = 0;\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(\"./imgs/boom.png\", 200, 179, 1, [6], [\"default\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.sound = new Audio();\r\n\t\tthis.sound.src = \"./sounds/Ice attack 2.wav\";\r\n\t\tthis.rotateAngleStep = Math.sign(RandomRange(-1, 1)) * (Math.PI / 360) * RandomRange(5, 15); // +/-(15° ~ 30°)\r\n\t\t// 动画本身只有五帧，但传入的参数表示有6帧，这里再请求在最后一帧停止渲染，则会渲染空白帧\r\n\t\tthis.requestStopAnimateFrameAtLastFrame();\r\n\t\tthis.setFps(15);\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tif (this.isFirstAnimateFrame()) this.sound.play(); // 如果是第一帧 播放音效\r\n\t\tthis.rotateAngle += this.rotateAngleStep;\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D): void {\r\n\t\tContext2D.save(); // 换新笔，旧笔context入栈\r\n\t\tContext2D.translate(this.posX + this.drawWidth / 2, this.posY + this.drawHeight / 2); //改变原点坐标\r\n\t\tContext2D.rotate(this.rotateAngle); // 旋转画布某角度\r\n\t\tconst oldValX = this.posX; // 记录旧值\r\n\t\tconst oldValY = this.posY;\r\n\t\tthis.posX = -this.drawWidth / 2; // 因为坐标系变了 ，原来的坐标也要变\r\n\t\tthis.posY = -this.drawHeight / 2;\r\n\t\tsuper.draw(Context2D);\r\n\t\tthis.posX = oldValX; // 恢复旧值\r\n\t\tthis.posY = oldValY;\r\n\t\tContext2D.restore(); // 换回原来的笔，出栈context\r\n\t}\r\n}\r\n```\r\n\r\n## 2.7. 输入监听和状态管理的实现\r\n\r\n原本写的很复杂，最终优化后就成这样了，把状态管理和输入监听解耦了，目前来看还是写的比较精简的\r\n\r\n### 2.7.1. 输入监听\r\n\r\n```ts\r\nimport { ValueOf } from \"./utils.js\";\r\n\r\ntype KeyMapsValues = ValueOf<typeof InputListener.KeyMaps>;\r\nexport class InputListener {\r\n\t// 定义一些静态常量\r\n\tstatic KeyMaps = {\r\n\t\tPressRight: \"ArrowRight\",\r\n\t\tPressLeft: \"ArrowLeft\",\r\n\t\tPressUp: \"ArrowUp\",\r\n\t\tPressDown: \"ArrowDown\",\r\n\t\tPressSpase: \" \",\r\n\t\tEnter: \"Enter\",\r\n\t\tEscape: \"Escape\"\r\n\t} as const; // const 可以保证ValueOf能起作用\r\n\tinputs: Array<KeyMapsValues> = [];\r\n\tconstructor() {\r\n\t\tthis.listenning();\r\n\t}\r\n\tlistenning() {\r\n\t\twindow.addEventListener(\"keydown\", event => {\r\n\t\t\tif (Object.values(InputListener.KeyMaps).includes(event.key as KeyMapsValues)) {\r\n\t\t\t\t// this.inputs.pop(); // 弹出栈顶\r\n\t\t\t\tthis.inputs.unshift(event.key as KeyMapsValues); // 放到开头\r\n\t\t\t}\r\n\t\t});\r\n\t\twindow.addEventListener(\"keyup\", event => {\r\n\t\t\tthis.inputs = []; // 弹出栈顶\r\n\t\t});\r\n\t}\r\n}\r\n```\r\n\r\n### 2.7.2. 状态管理\r\n\r\n状态管理指的是一种设计模式，是一个比较宽泛的概念，这里是我用 ts 写的，目前来看比较满意的一种写法\r\n\r\n```ts\r\nimport { InputListener } from \"./InputListener.js\";\r\nimport { ValueOf } from \"./utils.js\";\r\nexport abstract class State {\r\n\tstateName: string | number | symbol;\r\n\tconstructor(stateName: string | number | symbol) {\r\n\t\tthis.stateName = stateName;\r\n\t}\r\n\tabstract enter(): void;\r\n\tabstract update(timeInterval: number): void;\r\n\tabstract inputsHandler(inputs: Array<ValueOf<typeof InputListener.KeyMaps>>): void;\r\n}\r\n```\r\n\r\n### 2.7.3. 使用状态设计模式实现状态管理 Player 类的部分代码\r\n\r\n```ts\r\nexport class ShadowDog extends Animal {\r\n\tName = \"ShadowDog\";\r\n\t// 静态属性 状态枚举\r\n\tstatic StateNamesEnum = {\r\n\t\tRunning: \"Running\",\r\n\t\tJumping: \"Jumping\",\r\n\t\tGetHit: \"GetHit\",\r\n\t\tPreDizzy: \"PreDizzy\",\r\n\t\tDizzy: \"Dizzy\",\r\n\t\tDiving: \"Falling\",\r\n\t\tSitting: \"Sitting\",\r\n\t\tBarkting: \"Barkting\",\r\n\t\tDying: \"Dying\"\r\n\t} as const;\r\n\t// 状态map\r\n\tStateMap: { [value in ValueOf<typeof ShadowDog.StateNamesEnum>]?: State } = {};\r\n\t// 当前状态\r\n\tcurrentState!: State;\r\n\tconstructor() {\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Running] = new RunningState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Jumping] = new JumpingState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Diving] = new DivingState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Sitting] = new SittingState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Barkting] = new BarktingState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.GetHit] = new GetHitState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.PreDizzy] = new PreDizzyState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Dizzy] = new DizzyState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Dying] = new DyingState(this);\r\n\r\n\t\t// setState 要放到最后\r\n\t\tthis.setState(ShadowDog.StateNamesEnum.Running);\r\n\t}\r\n\t// 改变状态\r\n\tsetState(stateName: ValueOf<typeof ShadowDog.StateNamesEnum>) {\r\n\t\tthis.currentState = this.StateMap[stateName] as State;\r\n\t\tthis.currentState.enter();\r\n\t}\r\n\t// 更新\r\n\tupdate(timeInterval: number): void {\r\n\t\t// 处理输入\r\n\t\tthis.currentState.inputsHandler(this.Game.InputListener.inputs);\r\n\t\t// 更新\r\n\t\tthis.currentState.update(timeInterval);\r\n\t\t// 基类的更新\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n\r\nclass RunningState extends State {\r\n\tshadowDog: ShadowDog;\r\n\tconstructor(shadowDog: ShadowDog) {\r\n\t\tsuper(ShadowDog.StateNamesEnum.Running);\r\n\t\tthis.shadowDog = shadowDog;\r\n\t}\r\n\tenter(): void {\r\n\t\t// 进入该状态，初始化到该状态\r\n\t\tthis.shadowDog.moveSpeedX = 0;\r\n\t\tthis.shadowDog.moveSpeedY = 0;\r\n\t\tthis.shadowDog.setOnGround();\r\n\t\tthis.shadowDog.changeAnimateByName(\"run\");\r\n\t\t// 场景移动速度\r\n\t\tthis.shadowDog.Game.Scene.setSceneSpeed(-this.shadowDog.maxMoveSpeedX * 0.5);\r\n\t}\r\n\t// 状态的更新\r\n\tupdate(timeInterval: number): void {\r\n\t\t// 添加粒子特效\r\n\t\tthis.shadowDog.Game.Scene.particles.unshift(\r\n\t\t\tnew Dust(this.shadowDog.posX + this.shadowDog.drawWidth / 2, this.shadowDog.posY + this.shadowDog.drawHeight)\r\n\t\t);\r\n\t\t// 检测是否收到伤害\r\n\t\tif (this.shadowDog.isGetHit(this.shadowDog.Game.Scene.enemys)) {\r\n\t\t\tthis.shadowDog.setState(ShadowDog.StateNamesEnum.GetHit);\r\n\t\t\tthis.shadowDog.Game.lives--; // 生命值减一\r\n\t\t}\r\n\t}\r\n\t// 输入处理\r\n\tinputsHandler(inputs: Array<ValueOf<typeof InputListener.KeyMaps>>): void {\r\n\t\t// 如果按下右键，改变速度等的值\r\n\t\tif (inputs.includes(InputListener.KeyMaps.PressRight)) {\r\n\t\t\tthis.shadowDog.moveSpeedX = this.shadowDog.maxMoveSpeedX * 0.5;\r\n\t\t\tthis.shadowDog.Game.Scene.setSceneSpeed(-this.shadowDog.maxMoveSpeedX * 1.0);\r\n\t\t} else if (inputs.includes(InputListener.KeyMaps.PressLeft)) {\r\n\t\t\tthis.shadowDog.moveSpeedX = -this.shadowDog.maxMoveSpeedX * 0.5;\r\n\t\t\tthis.shadowDog.Game.Scene.setSceneSpeed(this.shadowDog.maxMoveSpeedX * 0.5);\r\n\t\t}\r\n\t\t// 按下上键，进入jump状态\r\n\t\telse if (inputs.includes(InputListener.KeyMaps.PressUp)) {\r\n\t\t\tthis.shadowDog.setState(ShadowDog.StateNamesEnum.Jumping);\r\n\t\t}\r\n\t\t// 按下上键，进入sitting状态\r\n\t\telse if (inputs.includes(InputListener.KeyMaps.PressDown)) this.shadowDog.setState(ShadowDog.StateNamesEnum.Sitting);\r\n\t\t// 松开左右按键，恢复速度等的值\r\n\t\telse {\r\n\t\t\tthis.shadowDog.moveSpeedX = 0;\r\n\t\t\tthis.shadowDog.Game.Scene.setSceneSpeed(-this.shadowDog.maxMoveSpeedX * 0.5);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n### 2.7.4. 使用状态设计模式实现状态管理 Game 类的部分代码\r\n\r\n```ts\r\ntype GameStateEnum = ValueOf<typeof Game.StateEnum>;\r\nexport class Game {\r\n\t// 定义一些静态常量表示状态\r\n\tstatic StateEnum = {\r\n\t\tPreview: \"Preview\",\r\n\t\tBeforeRunning: \"BeforeRunning\",\r\n\t\tRunning: \"Running\",\r\n\t\tStop: \"Stop\",\r\n\t\tGameOver: \"GameOver\"\r\n\t} as const;\r\n\tallStates: { [key in GameStateEnum]?: State } = {};\r\n\tcurrentState!: State;\r\n\tInputListener: InputListener;\r\n\tconstructor(Context2D: CanvasRenderingContext2D, CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n\t\tthis.InputListener = new InputListener();\r\n\t\tthis.UI = new UI(this);\r\n\r\n\t\tthis.allStates[Game.StateEnum.Preview] = new PreviewStatus(this);\r\n\t\tthis.allStates[Game.StateEnum.BeforeRunning] = new BeforeRunning(this);\r\n\t\tthis.allStates[Game.StateEnum.Running] = new RunningStatus(this);\r\n\t\tthis.allStates[Game.StateEnum.Stop] = new StopStatus(this);\r\n\t\tthis.allStates[Game.StateEnum.GameOver] = new GameOverStatus(this);\r\n\t\tthis.setState(Game.StateEnum.Preview);\r\n\t}\r\n\t// 改变状态\r\n\tsetState(StateName: ValueOf<typeof Game.StateEnum>) {\r\n\t\tconsole.log(\"current:\" + StateName);\r\n\t\tthis.currentState = this.allStates[StateName] as State;\r\n\t\tthis.currentState.enter();\r\n\t}\r\n\tupdate(timeInterval: number) {\r\n\t\t// 当前状态对输入的处理\r\n\t\tthis.currentState.inputsHandler(this.InputListener.inputs);\r\n\t\t// 当前状态的更新\r\n\t\tthis.currentState.update(timeInterval);\r\n\t\tthis.UI.update(timeInterval);\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D) {\r\n\t\tthis.Scene.draw(Context2D);\r\n\t\tthis.player.draw(Context2D);\r\n\t\tthis.UI.draw(Context2D);\r\n\t}\r\n\tstart() {\r\n\t\tlet lastTimeStampFromStart = 0;\r\n\t\tconst refreshDisplay = (currentTimeStampFromStart: number) => {\r\n\t\t\tconst timeInterval = currentTimeStampFromStart - lastTimeStampFromStart; // 计算时间间隔\r\n\t\t\tlastTimeStampFromStart = currentTimeStampFromStart;\r\n\t\t\tthis.update(timeInterval);\r\n\t\t\tthis.draw(this.Context2D);\r\n\t\t\trequestAnimationFrame(refreshDisplay);\r\n\t\t};\r\n\t\trefreshDisplay(0);\r\n\t\tconsole.log(\"game is started.\");\r\n\t}\r\n}\r\n\r\nclass PreviewStatus extends State {\r\n\tGame: Game;\r\n\tconstructor(game: Game) {\r\n\t\tsuper(Game.StateEnum.Preview);\r\n\t\tthis.Game = game;\r\n\t}\r\n\tenter(): void {\r\n\t\t// 进入该状态\r\n\t\tthis.Game.Music.currentTime = 0; // 从头开始播放\r\n\t\tthis.Game.score = 0;\r\n\t\tthis.Game.lives = 1000000000;\r\n\t\tthis.Game.player.setState(ShadowDog.StateNamesEnum.Running);\r\n\t\tthis.Game.UI.addScoreInfos = [];\r\n\t\tthis.Game.Scene.enemys = [];\r\n\t\tthis.Game.Scene.particles = [];\r\n\t\tthis.Game.Scene.explosions = [];\r\n\t\tthis.Game.Scene.spakParticles = [];\r\n\t\treturn;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\t// 该状态需要更新的信息，如在stopGame状态，则以下两个信息都不更新就好了\r\n\t\tthis.Game.Scene.update(timeInterval);\r\n\t\tthis.Game.player.update(timeInterval);\r\n\t}\r\n\tinputsHandler(inputs: Array<ValueOf<typeof InputListener.KeyMaps>>) {\r\n\t\t// 输入处理，按下enter开始游戏\r\n\t\tif (inputs.includes(InputListener.KeyMaps.Enter)) {\r\n\t\t\tthis.Game.setState(Game.StateEnum.BeforeRunning);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 2.8. Scene 场景\r\n\r\n主要是用来处理当背景移动，游戏中敌人应当随着背景一起移动的问题，\r\n\r\n这里我写了一个场景类，把需要跟随场景移动的东西都放进去，\r\n\r\n由该类来处理场景的移动速度和场景中物体坐标更新的问题\r\n\r\n以下是部分代码\r\n\r\n```ts\r\nexport class Scene {\r\n\tGame: Game;\r\n\tprivate SceneSpeed = 0;\r\n\tbackground: Background;\r\n\tconstructor(Game: Game) {\r\n\t\tthis.Game = Game;\r\n\t\tthis.background = new BackgroundCity(this.Game.GAME_WIDTH, this.Game.GAME_HEIGHT);\r\n\t}\r\n\t// 这一步最关键，处理死亡的敌人，\r\n\t// 另外还要更具场景移动速度，重新计算场景中敌人的位置\r\n\tupdate(timeInterval: number) {\r\n\t\t// handles\r\n\t\tthis.enemysHandle(timeInterval);\r\n\t\t// 最值处理，限制粒子特效的数量\r\n\t\tif (this.particles.length > this.particlesMaxLength) this.particles.length = this.particlesMaxLength;\r\n\t\tif (this.spakParticles.length > this.spakParticlesMaxLength) this.spakParticles.length = this.spakParticlesMaxLength;\r\n\t\t// 更新\r\n\t\t// 更新背景的移动速度\r\n\t\tthis.background.setSpeed(this.SceneSpeed);\r\n\t\tthis.background.update(timeInterval);\r\n\t\t// 移除死亡和超出屏幕的敌人\r\n\t\tthis.enemys = this.enemys.filter(item => {\r\n\t\t\treturn !item.isOutOfLeftScreem() && item.getAliveFlag();\r\n\t\t});\r\n\t\t// 更新和重新计算敌人的坐标\r\n\t\tthis.enemys.forEach(item => {\r\n\t\t\titem.update(timeInterval);\r\n\t\t\titem.transform(this.SceneSpeed * timeInterval, 0);\r\n\t\t});\r\n\t\t// 更新和重新计算粒子特效的坐标\r\n\t\tthis.particles.forEach(item => {\r\n\t\t\titem.update(timeInterval);\r\n\t\t\titem.posX += this.SceneSpeed * timeInterval;\r\n\t\t});\r\n\t\tthis.explosions = this.explosions.filter(item => {\r\n\t\t\titem.update(timeInterval);\r\n\t\t\titem.posX += this.SceneSpeed * timeInterval;\r\n\t\t\treturn !item.isLastAnimateFrame();\r\n\t\t});\r\n\t\tthis.spakParticles.forEach(item => {\r\n\t\t\titem.update(timeInterval);\r\n\t\t\titem.posX += this.SceneSpeed * timeInterval;\r\n\t\t});\r\n\t}\r\n\t// 绘制场景中的物体\r\n\tdraw(Context2D: CanvasRenderingContext2D) {\r\n\t\tthis.background.draw(Context2D);\r\n\t\tthis.enemys.forEach(item => item.draw(Context2D));\r\n\t\tthis.explosions.forEach(item => item.draw(Context2D));\r\n\t\tthis.particles.forEach(item => item.draw(Context2D));\r\n\t\tthis.spakParticles.forEach(item => item.draw(Context2D));\r\n\t}\r\n\t// 设置场景移动速度\r\n\tsetSceneSpeed(newSpeed: number) {\r\n\t\tthis.SceneSpeed = newSpeed;\r\n\t\treturn;\r\n\t}\r\n\tenemysHandle(timeInterval: number) {\r\n\t\t// 周期添加敌人\r\n\t\tif ((this.addEnemyTimer += timeInterval) >= this.addEnemyIntermval) {\r\n\t\t\tthis.addEnemyTimer = 0;\r\n\t\t\tswitch (Math.floor(RandomRange(0, 6))) {\r\n\t\t\t\tcase 0: // 略\r\n\t\t\t\tcase 1:\r\n\t\t\t\tcase 2:\r\n\t\t\t\tcase 3:\r\n\t\t\t\tcase 4:\r\n\t\t\t\tcase 5:\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 2.9. UI\r\n\r\nUI 这部分代码写的又长又丑，只看结构\r\n\r\n```ts\r\nimport { Game } from \"./Game.js\";\r\n\r\ntype addScoreInfo = { posX: number; posY: number; score: string };\r\nexport class UI {\r\n\tGame: Game;\r\n\tlivesImg: HTMLImageElement;\r\n\timgWidth: number;\r\n\timgHeight: number;\r\n\timgDrawWidth: number;\r\n\timgDrawHeight: number;\r\n\taddScoreInfos: Array<addScoreInfo> = [];\r\n\r\n\tconstructor(Game: Game) {\r\n\t\tthis.Game = Game;\r\n\t\tthis.livesImg = new Image();\r\n\t\tthis.livesImg.src = \"./imgs/heart.png\";\r\n\t\tthis.imgWidth = 50;\r\n\t\tthis.imgHeight = 50;\r\n\t\tthis.imgDrawWidth = 40; //this.imgWidth * 0.5;\r\n\t\tthis.imgDrawHeight = 40; // this.imgHeight * 0.5;\r\n\t}\r\n\t// 对漂浮的分数的坐标的计算\r\n\tupdate(timeInterval: number) {\r\n\t\tconst targetPosX = 200;\r\n\t\tconst moveSpeedX = 0.1;\r\n\t\tconst targetPosY = 80;\r\n\t\tconst moveSpeedY = 0.1;\r\n\t\t// 这里做的操作是更新数组中的坐标，使其朝着 targetPos 所在的坐标移动\r\n\t\tthis.addScoreInfos = this.addScoreInfos\r\n\t\t\t.map(item => {\r\n\t\t\t\tconst stepX = moveSpeedX * timeInterval;\r\n\t\t\t\tconst stepY = moveSpeedY * timeInterval;\r\n\t\t\t\tif (item.posX - targetPosX >= stepX) item.posX -= stepX;\r\n\t\t\t\telse if (item.posY - targetPosY <= stepX) item.posX += stepX;\r\n\t\t\t\tif (item.posY - targetPosY >= stepY) item.posY -= stepY;\r\n\t\t\t\telse if (item.posY - targetPosY <= stepY) item.posY += stepY;\r\n\r\n\t\t\t\tconst gapX = Math.abs(item.posX - targetPosX);\r\n\t\t\t\tconst gapY = Math.abs(item.posY - targetPosY);\r\n\t\t\t\tif (gapX < stepY && gapY < stepX) {\r\n\t\t\t\t\t// 当前坐标和目标坐标之间的距离小于步长，则移除该项\r\n\t\t\t\t\treturn null as unknown as addScoreInfo;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn item;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.filter(item => item != null);\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D) {\r\n\t\tContext2D.save();\r\n\t\tconst txtSize = 40;\r\n\t\tconst ShadowWidth = 2;\r\n\t\tContext2D.font = `${txtSize}px HanaleiFill`;\r\n\r\n\t\tif (this.Game.currentState.stateName == Game.StateEnum.Preview) {\r\n\t\t\t// 预览界面：显示按下什么键开始游戏\r\n\t\t} else if (this.Game.currentState.stateName == Game.StateEnum.Running) {\r\n\t\t\t// 游戏运行界面\r\n\t\t\t// 绘制剩余的生命\r\n\t\t\tfor (let index = 0; index < this.Game.lives; index++) {\r\n\t\t\t\tContext2D.drawImage(\r\n\t\t\t\t\tthis.livesImg,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\tthis.imgWidth,\r\n\t\t\t\t\tthis.imgHeight,\r\n\t\t\t\t\tindex * (this.imgDrawWidth + 10) + 10,\r\n\t\t\t\t\t5,\r\n\t\t\t\t\tthis.imgDrawWidth,\r\n\t\t\t\t\tthis.imgDrawHeight\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\t// 绘制漂浮的得分数字\r\n\t\t\tthis.addScoreInfos.forEach(item => {\r\n\t\t\t\tContext2D.textAlign = \"left\";\r\n\t\t\t\tContext2D.fillStyle = \"white\";\r\n\t\t\t\tContext2D.fillText(item.score, item.posX, item.posY);\r\n\t\t\t\tContext2D.fillStyle = \"black\";\r\n\t\t\t\tContext2D.fillText(item.score, item.posX + ShadowWidth, item.posY + ShadowWidth);\r\n\t\t\t});\r\n\t\t} else if (this.Game.currentState.stateName == Game.StateEnum.Stop) {\r\n\t\t\t// 游戏暂停界面\r\n\t\t\t// 显示按下什么键继续游戏\r\n\t\t} else if (this.Game.currentState.stateName == Game.StateEnum.GameOver) {\r\n\t\t\t// 游戏结束界面，显示分数\r\n\t\t}\r\n\t\tContext2D.restore();\r\n\t}\r\n}\r\n```\r\n\r\n## 2.10. 字体\r\n\r\n```css\r\n// 这一步相当于是注册了一个字体，而后页面中就可以使用 `HanaleiFill` 这个字体\r\n@font-face {\r\n\tfont-family: \"HanaleiFill\";\r\n\tsrc: url(../font/HanaleiFill-Regular.ttf);\r\n}\r\n```\r\n\r\n**如**\r\n\r\n```ts\r\nContext2D.font = `${txtSize}px HanaleiFill`;\r\n```\r\n\r\n**监听页面加载完毕事件和字体加载事件**\r\n\r\n`document.fonts` 的值是文档的 FontFaceSet 接口。FontFaceSet 接口 用于 对 加载新字体、检查已加载字体的加载状态。\r\n\r\n```ts\r\nwindow.addEventListener(\"load\", () => {\r\n\t// 字体加载完成后的逻辑\r\n\tdocument.fonts.ready.then(() => {\r\n\t\t// 此时DOM中的资源和字体就以加载完毕了\r\n\t}\r\n}\r\n```\r\n\r\n## 2.11. Canvas 铺满页面屏幕的实现\r\n\r\n```less\r\n* {\r\n\tpadding: 0;\r\n\tmargin: 0;\r\n\tbox-sizing: border-box;\r\n\toverflow: hidden;\r\n}\r\nhtml,\r\nbody {\r\n\tposition: relative;\r\n\twidth: 100vw;\r\n\theight: 100vh;\r\n\t#myCanvas,\r\n\t#loading {\r\n\t\t// 居中\r\n\t\tposition: absolute;\r\n\t\tleft: 50%;\r\n\t\ttop: 50%;\r\n\t\ttransform: translate(-50%, -50%);\r\n\t\t// 关键：设置最大宽度为屏幕宽高的100%\r\n\t\tmax-width: 100vw;\r\n\t\tmax-height: 100vh;\r\n\t}\r\n}\r\n```\r\n\r\n## 2.12. 自写工具类\r\n\r\n没什么好讲的，主要看注释和用例\r\n\r\n```ts\r\nexport function RandomRange(from: number, to: number) {\r\n\treturn Math.random() * (to - from) + from;\r\n}\r\n\r\n// 注意传入的T需用as const修饰，否则被当做字符串\r\nexport type ValueOf<T> = T[keyof T];\r\n```\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>\r\n"}