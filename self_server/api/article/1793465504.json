{"shortInfo":{"title":"javaScript写的2D游戏的实现细节笔记","date":"2023-01-10T05:57:00.000Z","cover":"\\self_server\\assets\\images\\shadowDogCover.gif","tags":["笔记"],"categories":"笔记","id":1793465504,"countWords":6858,"readSeconds":685.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# 1. 试玩版本 URL 地址： [<u>ShadowDog:0.0.1</u>✅](./demo/index.html)\r\n\r\n> **操作**：\r\n>\r\n> - `Enter` 键开始游戏\r\n> - `ESC` 键暂停游戏\r\n> - `Space` 键继续游戏\r\n> - `方向键上下左右`控制人物 跳、蹲、俯冲、前后移动\r\n> - 玩家在**跳起后**`在空中时`按下`Space`键可释放人物技能\r\n> - 释放技能的**过程中**按下方向键`↓`可实现俯冲\r\n> - 人物在**地面时**按下方向键`↓`可蹲下\r\n> - **蹲下后**按下方向键`→` 会有音效\r\n\r\n# 2. javaScript 写的 2D 游戏的实现细节笔记\r\n\r\n## 2.1. 笔记目录\r\n\r\n- [1. 试玩版本 URL 地址： ShadowDog:0.0.1✅](#1-试玩版本-url-地址-shadowdog001)\r\n- [2. javaScript 写的 2D 游戏的实现细节笔记](#2-javascript-写的-2d-游戏的实现细节笔记)\r\n\t- [2.1. 笔记目录](#21-笔记目录)\r\n\t- [2.2. Canvas 绘图基本步骤](#22-canvas-绘图基本步骤)\r\n\t\t- [2.2.1. 原理](#221-原理)\r\n\t\t- [2.2.2. 优化及渲染所有动图](#222-优化及渲染所有动图)\r\n\t\t- [2.2.3. 封装和抽象](#223-封装和抽象)\r\n\t\t- [2.2.4. 对动画对象 Animater 的封装](#224-对动画对象-animater-的封装)\r\n\t\t- [2.2.5. 继续定义一些列接口并定义 Animal 类](#225-继续定义一些列接口并定义-animal-类)\r\n\t\t- [2.2.6. 使用](#226-使用)\r\n\t- [2.3. 敌人的移动模式](#23-敌人的移动模式)\r\n\t\t- [2.3.1. 原地静止的物体](#231-原地静止的物体)\r\n\t\t- [2.3.2. 水平直线运动的蠕虫](#232-水平直线运动的蠕虫)\r\n\t\t- [2.3.3. 上下摆动的蝙蝠](#233-上下摆动的蝙蝠)\r\n\t\t- [2.3.4. 随机无规律移动的齿轮](#234-随机无规律移动的齿轮)\r\n\t- [2.4. 视差背景原理](#24-视差背景原理)\r\n\t\t- [2.4.1. 无限滚动的背景原理](#241-无限滚动的背景原理)\r\n\t\t- [2.4.2. 视差背景的实现](#242-视差背景的实现)\r\n\t\t- [2.4.3. 最终的抽象、封装、实现](#243-最终的抽象封装实现)\r\n\t\t- [2.4.4. 使用封装好的类实现一个视差背景](#244-使用封装好的类实现一个视差背景)\r\n\t- [2.5. 输入监听和状态管理的实现](#25-输入监听和状态管理的实现)\r\n\t\t- [2.5.1. 输入监听](#251-输入监听)\r\n\t\t- [2.5.2. 状态管理](#252-状态管理)\r\n\t\t- [2.5.3. 使用状态设计模式实现状态管理 Player 类的部分代码](#253-使用状态设计模式实现状态管理-player-类的部分代码)\r\n\t\t- [2.5.4. 使用状态设计模式实现状态管理 Game 类的部分代码](#254-使用状态设计模式实现状态管理-game-类的部分代码)\r\n\t- [2.6. Scene 场景](#26-scene-场景)\r\n\t- [2.7. UI](#27-ui)\r\n\t- [2.8. 字体](#28-字体)\r\n\t- [2.9. Canvas 铺满页面屏幕的实现](#29-canvas-铺满页面屏幕的实现)\r\n\t- [2.10. 自写工具类](#210-自写工具类)\r\n\r\n## 2.2. Canvas 绘图基本步骤\r\n\r\n### 2.2.1. 原理\r\n\r\n[原理.html](./practices/1.canvas%EF%BC%9A%E5%8E%9F%E7%90%86/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\n// 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 600);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 600);\r\n\r\n// 单帧宽高\r\nconst Sprite_WIDTH = 575;\r\nconst Sprite_HEIGHT = 523;\r\n\r\nconst imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./shadow_dog.png\";\r\n\r\nlet frameX = 0;\r\nlet frameY = 0;\r\nlet frameCount = 0; // 第几帧\r\nlet stageFrame = 5; // 交错帧，每隔5帧 切换图片\r\n\r\nfunction animate() {\r\n  // 计算当前要绘制的帧的index\r\n  frameCount = ++frameCount % stageFrame;\r\n  if (!frameCount) frameX = ++frameX % 7;\r\n\r\n  //清除上一次绘图痕迹\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer, // img\r\n    frameX * Sprite_WIDTH, //源坐标x\r\n    frameY * Sprite_HEIGHT, //源坐标y\r\n    Sprite_WIDTH, //源图像宽\r\n    Sprite_HEIGHT, //源图像高\r\n    0, // 目的坐标x\r\n    0, // 目的坐标y\r\n    CANVAS_WIDTH, // 绘制宽度w\r\n    CANVAS_HEIGHT // 绘制高度h\r\n  );\r\n  // requestAnimationFrame原理上相当于60fps的setInterval\r\n  requestAnimationFrame(animate);\r\n}\r\nanimate();\r\n```\r\n\r\n### 2.2.2. 优化及渲染所有动图\r\n\r\n[优化.html](./practices/2.animate：优化/index.html)\r\n\r\n<canvas id=\"myCanvas_2j0923ru48\"></canvas>\r\n\r\n<div class=\"animation-box\">\r\n\t<label for=\"animations\">select animation:</label>\r\n\t<select name=\"\" id=\"animations_djf9498\">\r\n\t\t<option value=\"idle\">idle</option>\r\n\t\t<option value=\"jump\">jump</option>\r\n\t\t<option value=\"fall\">fall</option>\r\n\t\t<option value=\"run\">run</option>\r\n\t\t<option value=\"dizzy\">dizzy</option>\r\n\t\t<option value=\"sit\">sit</option>\r\n\t\t<option value=\"roll\">roll</option>\r\n\t\t<option value=\"bite\">bite</option>\r\n\t\t<option value=\"ko\">ko</option>\r\n\t\t<option value=\"gethit\">gethit</option>\r\n\t</select>\r\n</div>\r\n<img src=\"./images/shadow_dog.png\">\r\n<script>\r\nvar myCanvas = document.querySelector(\"#myCanvas_2j0923ru48\");\r\nvar ctx = myCanvas.getContext(\"2d\"); // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n// canvas的默认大小为300x150px 需手动修改\r\nvar CANVAS_WIDTH = (myCanvas.width = 250);\r\nvar CANVAS_HEIGHT = (myCanvas.height = 250);\r\nvar Sprite_WIDTH = 575;\r\nvar Sprite_HEIGHT = 523;\r\nvar imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./images/shadow_dog.png\";\r\nvar playerState = \"idle\";\r\nvar selector = document.querySelector(\"#animations_djf9498\");\r\nselector.addEventListener(\"change\", function () {\r\n  playerState = selector.value;\r\n});\r\nvar animations = {\r\n  idle: { rows: 0,  cols: 7},\r\n  jump: { rows: 1,  cols: 7}, \r\n  fall: { rows: 2,  cols: 7}, \r\n  run: {  rows: 3,  cols: 9}, \r\n  dizzy:{ rows: 4,  cols: 11},\r\n  sit: {  rows: 5,  cols: 5}, \r\n  roll: { rows: 6,  cols: 7}, \r\n  bite:{  rows: 7,  cols: 7}, \r\n  ko: {   rows: 8,  cols: 12},\r\n  gethit:{rows: 9,  cols: 4,  }\r\n};\r\nvar animaIndex = 0; // 动画索引\r\nvar frameIndex = 0; // 帧索引\r\nvar frameCount = 0; // 总的帧数\r\nvar stageFrame = 5; // 交错帧，每隔5帧 切换关键帧\r\nfunction animate() {\r\n  frameIndex =\r\n    Math.floor(frameCount++ / stageFrame) % animations[playerState].cols;\r\n  animaIndex = animations[playerState].rows;\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer,\r\n    frameIndex * Sprite_WIDTH,\r\n    animaIndex * Sprite_HEIGHT,\r\n    Sprite_WIDTH,\r\n    Sprite_HEIGHT,\r\n    0,\r\n    0,\r\n    CANVAS_WIDTH,\r\n    CANVAS_HEIGHT\r\n  );\r\n  // requestAnimationFrame效果上相当于60fps的setInterval\r\n  requestAnimationFrame(animate); \r\n}\r\nanimate();\r\n</script>\r\n\r\n```html\r\n<canvas id=\"myCanvas_2j0923ru48\"></canvas>\r\n\r\n<div class=\"animation-box\">\r\n\t<label for=\"animations\">select animation:</label>\r\n\t<select name=\"\" id=\"animations_djf9498\">\r\n\t\t<option value=\"idle\">idle</option>\r\n\t\t<option value=\"jump\">jump</option>\r\n\t\t<option value=\"fall\">fall</option>\r\n\t\t<option value=\"run\">run</option>\r\n\t\t<option value=\"dizzy\">dizzy</option>\r\n\t\t<option value=\"sit\">sit</option>\r\n\t\t<option value=\"roll\">roll</option>\r\n\t\t<option value=\"bite\">bite</option>\r\n\t\t<option value=\"ko\">ko</option>\r\n\t\t<option value=\"gethit\">gethit</option>\r\n\t</select>\r\n</div>\r\n<img src=\"./images/shadow_dog.png\">\r\n<script>\r\nvar myCanvas = document.querySelector(\"#myCanvas_2j0923ru48\");\r\nvar ctx = myCanvas.getContext(\"2d\"); // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n// canvas的默认大小为300x150px 需手动修改\r\nvar CANVAS_WIDTH = (myCanvas.width = 250);\r\nvar CANVAS_HEIGHT = (myCanvas.height = 250);\r\nvar Sprite_WIDTH = 575;\r\nvar Sprite_HEIGHT = 523;\r\nvar imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./images/shadow_dog.png\";\r\nvar playerState = \"idle\";\r\nvar selector = document.querySelector(\"#animations_djf9498\");\r\nselector.addEventListener(\"change\", function () {\r\n  playerState = selector.value;\r\n});\r\nvar animations = {\r\n  idle: { rows: 0,  cols: 7},\r\n  jump: { rows: 1,  cols: 7},\r\n  fall: { rows: 2,  cols: 7},\r\n  run: {  rows: 3,  cols: 9},\r\n  dizzy:{ rows: 4,  cols: 11},\r\n  sit: {  rows: 5,  cols: 5},\r\n  roll: { rows: 6,  cols: 7},\r\n  bite:{  rows: 7,  cols: 7},\r\n  ko: {   rows: 8,  cols: 12},\r\n  gethit:{rows: 9,  cols: 4,  }\r\n};\r\nvar animaIndex = 0; // 动画索引\r\nvar frameIndex = 0; // 帧索引\r\nvar frameCount = 0; // 总的帧数\r\nvar stageFrame = 5; // 交错帧，每隔5帧 切换关键帧\r\nfunction animate() {\r\n  frameIndex =\r\n    Math.floor(frameCount++ / stageFrame) % animations[playerState].cols;\r\n  animaIndex = animations[playerState].rows;\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer,\r\n    frameIndex * Sprite_WIDTH,\r\n    animaIndex * Sprite_HEIGHT,\r\n    Sprite_WIDTH,\r\n    Sprite_HEIGHT,\r\n    0,\r\n    0,\r\n    CANVAS_WIDTH,\r\n    CANVAS_HEIGHT\r\n  );\r\n  // requestAnimationFrame效果上相当于60fps的setInterval\r\n  requestAnimationFrame(animate);\r\n}\r\nanimate();\r\n```\r\n\r\n### 2.2.3. 封装和抽象\r\n\r\n### 2.2.4. 对动画对象 Animater 的封装\r\n\r\n```ts\r\nimport { RandomRange } from \"./utils.js\";\r\n// 动画对象\r\nexport class Animater {\r\n  posX = 0; // 位置x\r\n  posY = 0; // 位置y\r\n  drawWidth: number; // 实际绘制的宽度\r\n  drawHeight: number; // 实际绘制的高度\r\n  img: HTMLImageElement; // 图片\r\n  imgFrameWidth: number; // 一帧的宽度\r\n  imgFrameHeight: number; // 一帧的高度\r\n  animateFramesTotal: Array<number>; // [动画1的总帧数,动画2的总帧数,动画3的...]\r\n  animateNameIndexMap: Array<string>; // 数据结构：{动画名称:该动画是第几个动画}\r\n  animateFrameIndexX = 0; // 当前绘制的是第几帧\r\n  animateFrameIndexY = 0; // 当前绘制的是第几个动画\r\n  animateFrameTimer = 0;\r\n  private _animateFrameFps = 60;\r\n  private animateFrameChangeInterval = 1000 / 60;\r\n  private get animateFrameFps() {\r\n    return this._animateFrameFps;\r\n  }\r\n  private set animateFrameFps(fps) {\r\n    this._animateFrameFps = fps;\r\n    this.animateFrameChangeInterval = 1000 / fps;\r\n  }\r\n  public setFps(fps: number) {\r\n    this.animateFrameFps = fps;\r\n  }\r\n  stopAnimateAtLastFlag = false;\r\n  RewindAnimateFrameFlag = false;\r\n  constructor(\r\n    imgSrc: string,\r\n    imgFrameWidth: number,\r\n    imgFrameHeight: number,\r\n    size: number,\r\n    animateFramesTotal: Array<number>,\r\n    animateNameIndexMap: Array<string>\r\n  ) {\r\n    this.img = new Image();\r\n    this.img.src = imgSrc;\r\n    this.animateFramesTotal = animateFramesTotal;\r\n    this.animateNameIndexMap = animateNameIndexMap;\r\n    this.imgFrameWidth = imgFrameWidth;\r\n    this.imgFrameHeight = imgFrameHeight;\r\n    this.drawWidth = this.imgFrameWidth * size;\r\n    this.drawHeight = this.imgFrameHeight * size;\r\n    this.setFps(60);\r\n  }\r\n  // 更新数据\r\n  update(timeInterval: number): void {\r\n    // 最后一帧则停止切换帧\r\n    if (this.stopAnimateAtLastFlag == true && this.isLastAnimateFrame()) return;\r\n    // 计算下一帧\r\n    if (this.animateFrameTimer >= this.animateFrameChangeInterval) {\r\n      this.animateFrameTimer = 0;\r\n      this.animateFrameIndexX += 1;\r\n      this.animateFrameIndexX %=\r\n        this.animateFramesTotal[this.animateFrameIndexY];\r\n    } else this.animateFrameTimer += timeInterval;\r\n  }\r\n  // 绘制帧\r\n  draw(Context2D: CanvasRenderingContext2D): void {\r\n    Context2D.drawImage(\r\n      this.img,\r\n      this.animateFrameIndexX * this.imgFrameWidth,\r\n      this.animateFrameIndexY * this.imgFrameHeight,\r\n      this.imgFrameWidth,\r\n      this.imgFrameHeight,\r\n      this.posX,\r\n      this.posY,\r\n      this.drawWidth,\r\n      this.drawHeight\r\n    );\r\n  }\r\n  changeAnimateByName(animateName: string) {\r\n    // 根据名称切换动画\r\n    if (this.animateNameIndexMap.includes(animateName))\r\n      this.animateFrameIndexY = this.animateNameIndexMap.indexOf(animateName);\r\n    else throw new Error(`animateName:'${animateName}' is not exist.`);\r\n    this.init();\r\n  }\r\n  // 判断是否为最后一帧\r\n  isLastAnimateFrame() {\r\n    return (\r\n      this.animateFrameIndexX ==\r\n      this.animateFramesTotal[this.animateFrameIndexY] - 1\r\n    );\r\n  }\r\n  // 判断是否为第一帧\r\n  isFirstAnimateFrame() {\r\n    return this.animateFrameIndexX == 0;\r\n  }\r\n  // 初始化状态\r\n  init() {\r\n    this.animateFrameIndexX = 0; // 设置从第一帧开始\r\n  }\r\n  // 请求在渲染到最后一帧的时候停止更新动画\r\n  requestStopAnimateFrameAtLastFrame() {\r\n    this.stopAnimateAtLastFlag = true;\r\n  }\r\n  isOutOfLeftScreem() {\r\n    return this.posX + this.drawWidth < 0;\r\n  }\r\n}\r\n```\r\n\r\n### 2.2.5. 继续定义一些列接口并定义 Animal 类\r\n\r\n```ts\r\nimport { Animater } from \"./Animater.js\";\r\nimport { transformAble } from \"./transformAble.js\";\r\n\r\n// 可移动的\r\ninterface MoveAble {\r\n  moveSpeedX: number; // x轴移动速度 单位：像素/毫秒\r\n  moveSpeedY: number; // x轴移动速度 单位：像素/毫秒\r\n  move(timeInterval: number): void; // 移动\r\n}\r\n// 活的\r\ninterface AliveAble {\r\n  aliveFlag: boolean;\r\n  getAliveFlag(): boolean; // 用于判断是否存活\r\n  setAliveFlag(newVal: boolean): void;\r\n}\r\n// 圆形碰撞检测\r\ninterface CollisionCheckAble {\r\n  collisionCheckPosX: number;\r\n  collisionCheckPosY: number;\r\n  collisionCheckWidth: number;\r\n  collisionCheckHeight: number;\r\n  collisionCheckRadius: number;\r\n  collisionCheckUpdate(): void;\r\n  isCollision(obj: CollisionCheckAble): boolean; // 碰撞检测\r\n}\r\ninterface NameAble {\r\n  Name: string;\r\n  getName(): string;\r\n}\r\n\r\n// 抽象类 Animal 继承动画类 实现Moveable AliveAble 接口\r\nexport abstract class Animal\r\n  extends Animater\r\n  implements MoveAble, AliveAble, CollisionCheckAble, NameAble, transformAble\r\n{\r\n  // 移动\r\n  moveSpeedX = 0;\r\n  moveSpeedY = 0;\r\n  abstract move(timeInterval: number): void;\r\n  // 存活\r\n  aliveFlag = true;\r\n  setAliveFlag(newVal: boolean): void {\r\n    this.aliveFlag = newVal;\r\n  }\r\n  getAliveFlag(): boolean {\r\n    return this.aliveFlag;\r\n  }\r\n  // 可碰撞检测\r\n  collisionCheckPosX = 0;\r\n  collisionCheckPosY = 0;\r\n  collisionCheckWidth = 0;\r\n  collisionCheckHeight = 0;\r\n  collisionCheckRadius = 0;\r\n  collisionCheckUpdate(): void {\r\n    // 圆形碰撞检测\r\n    this.collisionCheckPosX = this.posX + this.drawWidth / 2;\r\n    this.collisionCheckPosY = this.posY + this.drawHeight / 2;\r\n    this.collisionCheckRadius =\r\n      (Math.min(this.drawWidth, this.drawHeight) / 2) * 0.8;\r\n  }\r\n  isCollision(obj: CollisionCheckAble): boolean {\r\n    this.collisionCheckUpdate();\r\n    obj.collisionCheckUpdate();\r\n    const dX = this.collisionCheckPosX - obj.collisionCheckPosX;\r\n    const dY = this.collisionCheckPosY - obj.collisionCheckPosY;\r\n    const distance = Math.sqrt(dX * dX + dY * dY);\r\n    return distance < this.collisionCheckRadius + obj.collisionCheckRadius;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.collisionCheckUpdate();\r\n    super.update(timeInterval);\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D): void {\r\n    // Context2D.beginPath();\r\n    // Context2D.arc(this.collisionCheckPosX, this.collisionCheckPosY, this.collisionCheckRadius, 0, Math.PI * 2);\r\n    // Context2D.stroke();\r\n    // Context2D.strokeRect(this.posX, this.posY, this.drawWidth, this.drawHeight);\r\n    super.draw(Context2D);\r\n  }\r\n  // put it on ground();\r\n  setOnGround(groundPosY: number): Animal {\r\n    this.posY = groundPosY - this.drawHeight;\r\n    return this;\r\n  }\r\n  // 水平和垂直平移\r\n  transform(stepX: number, stepY: number) {\r\n    this.posX += stepX;\r\n    this.posY += stepY;\r\n  }\r\n  abstract Name: string;\r\n  getName(): string {\r\n    this.Name;\r\n    return this.Name;\r\n  }\r\n}\r\n```\r\n\r\n### 2.2.6. 使用\r\n\r\n于是，定义一个游戏角色：蠕虫，就会变得如此简单\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Worm extends Animal {\r\n  Name = \"Worm\";\r\n  constructor(posX: number, posY: number) {\r\n    super(\"./imgs/Worm.png\", 229, 171, 0.5, [6], [\"idle\"]);\r\n    this.posX = posX;\r\n    this.posY = posY;\r\n    this.moveSpeedX = RandomRange(0.05, 0.1);\r\n  }\r\n  move(timeInterval: number) {\r\n    this.posX -= this.moveSpeedX * timeInterval;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.move(timeInterval);\r\n    super.update(timeInterval);\r\n  }\r\n}\r\n```\r\n\r\n## 2.3. 敌人的移动模式\r\n\r\n### 2.3.1. 原地静止的物体\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 鬼\r\nexport class Plant extends Animal {\r\n  Name = \"Plant\";\r\n  constructor(posX: number, posY: number) {\r\n    super(\"./imgs/enemy_plant.png\", 60, 87, 1.5, [2], [\"default\"]);\r\n    this.posX = posX;\r\n    this.posY = posY;\r\n    this.setFps(10);\r\n  }\r\n  move(timeInterval: number): void {\r\n    return;\r\n  }\r\n}\r\n```\r\n\r\n### 2.3.2. 水平直线运动的蠕虫\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Worm extends Animal {\r\n  Name = \"Worm\";\r\n  constructor(posX: number, posY: number) {\r\n    super(\"./imgs/Worm.png\", 229, 171, 0.5, [6], [\"idle\"]);\r\n    this.posX = posX;\r\n    this.posY = posY;\r\n    this.moveSpeedX = RandomRange(0.05, 0.1);\r\n  }\r\n  move(timeInterval: number) {\r\n    this.posX -= this.moveSpeedX * timeInterval;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.move(timeInterval);\r\n    super.update(timeInterval);\r\n  }\r\n}\r\n```\r\n\r\n### 2.3.3. 上下摆动的蝙蝠\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Bat extends Animal {\r\n  Name = \"Bat\";\r\n  shakeAngle = 0; // 摆动角度,初始摆动角度 单位: 弧度\r\n  shakeDeltaAngle: number; // 摆动增量 单位:弧度/毫秒\r\n  shakeGapRadius: number; // 摆动范围半径 单位：像素\r\n  constructor(posX: number, posY: number) {\r\n    super(\"./imgs/Bat.png\", 266, 188, 0.5, [6], [\"idle\"]);\r\n    this.posX = posX;\r\n    this.posY = posY;\r\n    this.moveSpeedX = RandomRange(0.05, 0.1);\r\n\r\n    this.shakeAngle = RandomRange(Math.asin(-1), Math.asin(1));\r\n    this.shakeDeltaAngle = RandomRange(Math.asin(0.001), Math.asin(0.003));\r\n    this.shakeGapRadius = RandomRange(2, 5);\r\n  }\r\n  shake(timeInterval: number) {\r\n    this.posY += this.shakeGapRadius * Math.sin(this.shakeAngle);\r\n    this.shakeAngle += this.shakeDeltaAngle * timeInterval;\r\n  }\r\n  move(timeInterval: number) {\r\n    this.posX -= this.moveSpeedX * timeInterval;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.move(timeInterval);\r\n    this.shake(timeInterval);\r\n    super.update(timeInterval);\r\n  }\r\n}\r\n```\r\n\r\n**周期线性运动的蝙蝠**\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class GhostBird extends Animal {\r\n  Name = \"GhostBird\";\r\n\r\n  asline: {\r\n    angle: number;\r\n    angleIncreaseSpeed: number;\r\n    factorX: number;\r\n    factorY: number;\r\n  } = {\r\n    angle: 0,\r\n    angleIncreaseSpeed: 0,\r\n    factorX: 0,\r\n    factorY: 0,\r\n  };\r\n\r\n  CANVAS_WIDTH: number;\r\n  CANVAS_HEIGHT: number;\r\n  offsetY: number;\r\n  offsetX: number;\r\n\r\n  constructor(\r\n    posX: number,\r\n    posY: number,\r\n    CANVAS_WIDTH: number,\r\n    CANVAS_HEIGHT: number\r\n  ) {\r\n    super(\"./imgs/GhostBird.png\", 218, 177, 0.5, [6], [\"idle\"]);\r\n    this.posX = posX;\r\n    this.posY = posY;\r\n    this.CANVAS_WIDTH = CANVAS_WIDTH;\r\n    this.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n    this.moveSpeedX = RandomRange(0.4, 1);\r\n    // for asline\r\n    this.offsetX = 0; // 相对于屏幕右上角0，0位置的偏移量\r\n    this.offsetY = 0;\r\n    this.asline.angle = (Math.PI / 365) * RandomRange(-365, 365); // 初相角 -1 ~ 1\r\n    this.asline.angleIncreaseSpeed =\r\n      (Math.PI / 365) * RandomRange(30, 90) * Math.sign(RandomRange(-1, 1)); // 移动周期 30~90 感觉不错\r\n    this.asline.factorX = (Math.PI / 365) * 0.45;\r\n    this.asline.factorY = (Math.PI / 365) * 0.35;\r\n  }\r\n  transform(stepX: number, stepY: number): void {\r\n    // this.offsetX += stepX;\r\n    // this.offsetY += stepY;\r\n  }\r\n  move_asline(timeInterval: number) {\r\n    // 线性运动\r\n    this.posX =\r\n      this.offsetX +\r\n      (this.CANVAS_WIDTH / 2) *\r\n        Math.cos(this.asline.angle * this.asline.factorX) +\r\n      (this.CANVAS_WIDTH / 2 - this.drawWidth / 2);\r\n    this.posY =\r\n      this.offsetY +\r\n      (this.CANVAS_HEIGHT / 2) *\r\n        Math.sin(this.asline.angle * this.asline.factorY) +\r\n      (this.CANVAS_HEIGHT / 2 - this.drawHeight / 2);\r\n    const angleStep = this.asline.angleIncreaseSpeed * timeInterval;\r\n    this.asline.angle += angleStep;\r\n  }\r\n  move(timeInterval: number) {\r\n    this.posX -= this.moveSpeedX * timeInterval;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.move_asline(timeInterval);\r\n    super.update(timeInterval);\r\n  }\r\n}\r\n```\r\n\r\n### 2.3.4. 随机无规律移动的齿轮\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Gear extends Animal {\r\n  Name = \"Gear\";\r\n  reArrange_NewPosX: number;\r\n  reArrange_NewPosY: number;\r\n  reArrange_MoveSpeed: number; // 移动速度\r\n  reArrange_Timer = 0;\r\n  reArrange_TimeInterval: number;\r\n  CANVAS_WIDTH: number;\r\n  CANVAS_HEIGHT: number;\r\n\r\n  constructor(\r\n    posX: number,\r\n    posY: number,\r\n    CANVAS_WIDTH: number,\r\n    CANVAS_HEIGHT: number\r\n  ) {\r\n    super(\"./imgs/Gear.png\", 213, 212, 0.5, [6], [\"idle\"]);\r\n    this.posX = posX;\r\n    this.posY = posY;\r\n    this.CANVAS_WIDTH = CANVAS_WIDTH;\r\n    this.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n\r\n    this.moveSpeedX = RandomRange(0.4, 1);\r\n\r\n    // randomReArrange_ment\r\n    this.reArrange_NewPosX = this.posX;\r\n    this.reArrange_NewPosY = this.posY;\r\n    this.reArrange_TimeInterval = Math.floor(RandomRange(500, 2000)); // 0.5 ~ 2 秒\r\n    this.reArrange_MoveSpeed = RandomRange(0.5, 2.0);\r\n  }\r\n  // 平移\r\n  transform(stepX: number, stepY: number): void {\r\n    return;\r\n    // 决定其是否跟随场景移动的代码\r\n    this.posX += stepX;\r\n    this.posY += stepY;\r\n    this.reArrange_NewPosX += stepX; // dx要根据这个来计算，所以也要平移\r\n    this.reArrange_NewPosY += stepY;\r\n  }\r\n  reArrange(timeInterval: number) {\r\n    // 重新排列\r\n    if ((this.reArrange_Timer += timeInterval) >= this.reArrange_TimeInterval) {\r\n      this.reArrange_Timer = 0;\r\n      // 随机位置，注意其范围区间\r\n      this.reArrange_NewPosX = RandomRange(0, this.CANVAS_WIDTH);\r\n      this.reArrange_NewPosY = RandomRange(0, this.CANVAS_HEIGHT);\r\n      console.log(this.reArrange_NewPosX);\r\n      console.log(this.reArrange_NewPosY);\r\n    }\r\n    const dx = (this.reArrange_NewPosX - this.posX) / 1000;\r\n    const dy = (this.reArrange_NewPosY - this.posY) / 1000;\r\n    const moveStep = this.reArrange_MoveSpeed * timeInterval;\r\n    this.posX += dx * moveStep;\r\n    this.posY += dy * moveStep;\r\n  }\r\n  move(timeInterval: number) {\r\n    this.posX -= this.moveSpeedX * timeInterval;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.reArrange(timeInterval);\r\n    // this.move(timeInterval);\r\n    super.update(timeInterval);\r\n  }\r\n}\r\n```\r\n\r\n## 2.4. 视差背景原理\r\n\r\n### 2.4.1. 无限滚动的背景原理\r\n\r\n[](./practices/3.%E8%A7%86%E5%B7%AE%E8%83%8C%E6%99%AF%EF%BC%9A%E5%8E%9F%E7%90%86/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\n// 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 800);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 700);\r\n\r\nlet gameScrollSpeed = 10;\r\n\r\n// 层\r\nconst backgroundLayer1 = new Image();\r\nbackgroundLayer1.src = \"./imgs/layer-1.png\";\r\nconst backgroundLayer2 = new Image();\r\nbackgroundLayer2.src = \"./imgs/layer-2.png\";\r\nconst backgroundLayer3 = new Image();\r\nbackgroundLayer3.src = \"./imgs/layer-3.png\";\r\nconst backgroundLayer4 = new Image();\r\nbackgroundLayer4.src = \"./imgs/layer-4.png\";\r\nconst backgroundLayer5 = new Image();\r\nbackgroundLayer5.src = \"./imgs/layer-5.png\";\r\n\r\nlet Layer4offsetX1 = 0;\r\nlet Layer4offsetX2 = 2400;\r\n(function animate() {\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(backgroundLayer4, Layer4offsetX1, 0);\r\n  ctx.drawImage(backgroundLayer5, Layer4offsetX2, 0);\r\n  // 如果第一张图滚动展示完毕，就将其放到第二张图的后面\r\n  if (Layer4offsetX1 < -2400) Layer4offsetX1 = Layer4offsetX2 + 2400;\r\n  // 如果第二张图滚动展示完毕，就将其放到第一张图的后面\r\n  if (Layer4offsetX2 < -2400) Layer4offsetX2 = Layer4offsetX1 + 2400;\r\n  Layer4offsetX1 -= gameScrollSpeed; // 更新位置\r\n  Layer4offsetX2 -= gameScrollSpeed; // 更新位置\r\n  requestAnimationFrame(animate); // 刷新\r\n})();\r\n```\r\n\r\n### 2.4.2. 视差背景的实现\r\n\r\n[视差背景.html](./practices/4.视差背景：优化/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D; // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 1080);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 720);\r\n\r\nlet gameScrollSpeed = 10;\r\n\r\nconst backgroundLayer1 = new Image();\r\nbackgroundLayer1.src = \"./imgs/layer-1.png\";\r\nconst backgroundLayer2 = new Image();\r\nbackgroundLayer2.src = \"./imgs/layer-2.png\";\r\nconst backgroundLayer3 = new Image();\r\nbackgroundLayer3.src = \"./imgs/layer-3.png\";\r\nconst backgroundLayer4 = new Image();\r\nbackgroundLayer4.src = \"./imgs/layer-4.png\";\r\nconst backgroundLayer5 = new Image();\r\nbackgroundLayer5.src = \"./imgs/layer-5.png\";\r\n\r\nlet baclkgroundlayers = [\r\n  {\r\n    name: \"layer1\",\r\n    img: backgroundLayer1,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.1,\r\n  },\r\n  {\r\n    name: \"layer2\",\r\n    img: backgroundLayer2,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.3,\r\n  },\r\n  {\r\n    name: \"layer3-cloud\",\r\n    img: backgroundLayer3,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.5,\r\n  },\r\n  {\r\n    name: \"layer4\",\r\n    img: backgroundLayer4,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.65,\r\n  },\r\n  {\r\n    name: \"layer5-floor\",\r\n    img: backgroundLayer5,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 1.0,\r\n  },\r\n];\r\n\r\nfunction refreshBackgroundLayers() {\r\n  // 渲染背景\r\n  baclkgroundlayers.forEach((layerItem) => {\r\n    // 逐层渲染背景\r\n    ctx.drawImage(layerItem.img, layerItem.Xoffset1, 0);\r\n    ctx.drawImage(layerItem.img, layerItem.Xoffset2, 0);\r\n    if (layerItem.Xoffset1 < -layerItem.imgWidth)\r\n      layerItem.Xoffset1 = layerItem.Xoffset2 + layerItem.imgWidth; // 如果第一张图滚动展示完毕，就将其放到第二张图的后面\r\n    if (layerItem.Xoffset2 < -layerItem.imgWidth)\r\n      layerItem.Xoffset2 = layerItem.Xoffset1 + layerItem.imgWidth; // 如果第二张图滚动展示完毕，就将其放到第一张图的后面\r\n    layerItem.Xoffset1 -= gameScrollSpeed * layerItem.speedModify; // 更新位置\r\n    layerItem.Xoffset2 -= gameScrollSpeed * layerItem.speedModify; // 更新位置\r\n  });\r\n}\r\n\r\n(function animate() {\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // 清除\r\n  refreshBackgroundLayers(); // 渲染背景\r\n  requestAnimationFrame(animate); // 刷新\r\n})();\r\n```\r\n\r\n### 2.4.3. 最终的抽象、封装、实现\r\n\r\n```ts\r\n// 可滚动的背景层\r\nexport class Layer {\r\n  readonly CANVAS_WIDTH: number;\r\n  readonly CANVAS_HEIGHT: number;\r\n  img: HTMLImageElement;\r\n  imgWidth: number;\r\n  imgHeight: number;\r\n  pos1_X: number;\r\n  pox1_Y: number;\r\n  pos2_X: number;\r\n  pox2_Y: number;\r\n  private layerMoveSpeedX = 0; // 层的移动速度,一个背景的所有层的移动速度应当是一致的\r\n  private layerMoveSpeedFactor = 1.0; // 层的移动速度的系数，一个背景有多个层，多个层的移动速度一致，但移动速度的系数可能不一致\r\n  constructor(\r\n    CANVAS_WIDTH: number,\r\n    CANVAS_HEIGHT: number,\r\n    imgSrc: string,\r\n    imgWidth: number,\r\n    imgHeight: number,\r\n    layerMoveSpeedFactor: number\r\n  ) {\r\n    this.CANVAS_WIDTH = CANVAS_WIDTH;\r\n    this.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n    this.img = new Image();\r\n    this.img.src = imgSrc;\r\n    this.imgWidth = imgWidth;\r\n    this.imgHeight = imgHeight;\r\n    this.layerMoveSpeedFactor = layerMoveSpeedFactor;\r\n    this.pos1_X = 0;\r\n    this.pox1_Y = 0;\r\n    this.pos2_X = this.imgWidth;\r\n    this.pox2_Y = 0;\r\n  }\r\n  update(timeInterval: number) {\r\n    this.pos1_X +=\r\n      this.layerMoveSpeedX * this.layerMoveSpeedFactor * timeInterval;\r\n    this.pos2_X +=\r\n      this.layerMoveSpeedX * this.layerMoveSpeedFactor * timeInterval;\r\n    // 图层向左移动，图层出界，向后添加新图层\r\n    if (this.layerMoveSpeedX < 0 && this.pos1_X + this.imgWidth <= 0)\r\n      this.pos1_X = this.pos2_X + this.imgWidth; // 图1出界就将其放置到图2之后\r\n    if (this.layerMoveSpeedX < 0 && this.pos2_X + this.imgWidth <= 0)\r\n      this.pos2_X = this.pos1_X + this.imgWidth; // 图2出界就将其放置到图1之后\r\n    // 图层向右移动，图层出界，向前添加新图层\r\n    if (this.layerMoveSpeedX > 0 && this.pos1_X >= 0)\r\n      this.pos2_X = this.pos1_X - this.imgWidth; // 图1出界就将其放置到图2之后\r\n    if (this.layerMoveSpeedX > 0 && this.pos2_X >= 0)\r\n      this.pos1_X = this.pos2_X - this.imgWidth; // 图2出界就将其放置到图1之后\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D) {\r\n    Context2D.drawImage(\r\n      this.img,\r\n      0,\r\n      0,\r\n      this.imgWidth,\r\n      this.imgHeight,\r\n      this.pos1_X,\r\n      this.pox1_Y,\r\n      this.imgWidth,\r\n      this.CANVAS_HEIGHT\r\n    );\r\n    Context2D.drawImage(\r\n      this.img,\r\n      0,\r\n      0,\r\n      this.imgWidth,\r\n      this.imgHeight,\r\n      this.pos2_X,\r\n      this.pox2_Y,\r\n      this.imgWidth,\r\n      this.CANVAS_HEIGHT\r\n    );\r\n  }\r\n  setSpeed(newSpeed: number) {\r\n    this.layerMoveSpeedX = newSpeed;\r\n  }\r\n}\r\n\r\n// 可滚动的背景，该背景包含多个层\r\nexport abstract class Background {\r\n  private _backgroundMoveSpeedX = 0; // 背景移动速度\r\n  layers: Array<Layer> = []; // 背景\r\n  constructor() {\r\n    this.setSpeed(0);\r\n  }\r\n  update(timeInterval: number) {\r\n    this.layers.forEach((layer) => layer.update(timeInterval));\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D) {\r\n    this.layers.forEach((layer) => layer.draw(Context2D));\r\n  }\r\n  getSpeed() {\r\n    return this._backgroundMoveSpeedX;\r\n  }\r\n  // 修改背景的速度就是修改要所有层的移动速度，这里做等值判断是防止for循环浪费性能\r\n  setSpeed(newSpeed: number) {\r\n    if (this._backgroundMoveSpeedX != newSpeed) {\r\n      this.layers.forEach((item) => item.setSpeed(newSpeed)); // 更新所有层的速度\r\n      this._backgroundMoveSpeedX = newSpeed; // 更新背景速度\r\n    }\r\n  }\r\n  abstract getGroundPosY(): number;\r\n}\r\n```\r\n\r\n### 2.4.4. 使用封装好的类实现一个视差背景\r\n\r\n现在实现一张视差背景只需要几行最关键的代码\r\n\r\n```ts\r\nimport { Background, Layer } from \"./Background.js\";\r\n// 背景city，由1层构成\r\nexport class BackgroundCity extends Background {\r\n  CANVAS_WIDTH: number;\r\n  CANVAS_HEIGHT: number;\r\n  constructor(CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n    super();\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-1.png\",\r\n        2400,\r\n        720,\r\n        0.0\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-2.png\",\r\n        2400,\r\n        720,\r\n        0.1\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-3.png\",\r\n        2400,\r\n        720,\r\n        0.3\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-4.png\",\r\n        2400,\r\n        720,\r\n        0.5\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-5.png\",\r\n        2400,\r\n        720,\r\n        1.0\r\n      )\r\n    );\r\n    this.CANVAS_WIDTH = CANVAS_WIDTH;\r\n    this.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n  }\r\n  getGroundPosY(): number {\r\n    return this.CANVAS_HEIGHT - 120;\r\n  }\r\n}\r\n```\r\n\r\n## 2.5. 输入监听和状态管理的实现\r\n\r\n原本写的很复杂，最终优化后就成这样了，把状态管理和输入监听解耦了，目前来看还是写的比较精简的\r\n\r\n### 2.5.1. 输入监听\r\n\r\n```ts\r\nimport { ValueOf } from \"./utils.js\";\r\n\r\ntype KeyMapsValues = ValueOf<typeof InputListener.KeyMaps>;\r\nexport class InputListener {\r\n  // 定义一些静态常量\r\n  static KeyMaps = {\r\n    PressRight: \"ArrowRight\",\r\n    PressLeft: \"ArrowLeft\",\r\n    PressUp: \"ArrowUp\",\r\n    PressDown: \"ArrowDown\",\r\n    PressSpase: \" \",\r\n    Enter: \"Enter\",\r\n    Escape: \"Escape\",\r\n  } as const; // const 可以保证ValueOf能起作用\r\n  inputs: Array<KeyMapsValues> = [];\r\n  constructor() {\r\n    this.listenning();\r\n  }\r\n  listenning() {\r\n    window.addEventListener(\"keydown\", (event) => {\r\n      if (\r\n        Object.values(InputListener.KeyMaps).includes(\r\n          event.key as KeyMapsValues\r\n        )\r\n      ) {\r\n        // this.inputs.pop(); // 弹出栈顶\r\n        this.inputs.unshift(event.key as KeyMapsValues); // 放到开头\r\n      }\r\n    });\r\n    window.addEventListener(\"keyup\", (event) => {\r\n      this.inputs = []; // 弹出栈顶\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n### 2.5.2. 状态管理\r\n\r\n状态管理指的是一种设计模式，是一个比较宽泛的概念，这里是我用 ts 写的，目前来看比较满意的一种写法\r\n\r\n```ts\r\nimport { InputListener } from \"./InputListener.js\";\r\nimport { ValueOf } from \"./utils.js\";\r\nexport abstract class State {\r\n  stateName: string | number | symbol;\r\n  constructor(stateName: string | number | symbol) {\r\n    this.stateName = stateName;\r\n  }\r\n  abstract enter(): void;\r\n  abstract update(timeInterval: number): void;\r\n  abstract inputsHandler(\r\n    inputs: Array<ValueOf<typeof InputListener.KeyMaps>>\r\n  ): void;\r\n}\r\n```\r\n\r\n### 2.5.3. 使用状态设计模式实现状态管理 Player 类的部分代码\r\n\r\n```ts\r\nexport class ShadowDog extends Animal {\r\n  Name = \"ShadowDog\";\r\n  // 静态属性 状态枚举\r\n  static StateNamesEnum = {\r\n    Running: \"Running\",\r\n    Jumping: \"Jumping\",\r\n    GetHit: \"GetHit\",\r\n    PreDizzy: \"PreDizzy\",\r\n    Dizzy: \"Dizzy\",\r\n    Diving: \"Falling\",\r\n    Sitting: \"Sitting\",\r\n    Barkting: \"Barkting\",\r\n    Dying: \"Dying\",\r\n  } as const;\r\n  // 状态map\r\n  StateMap: { [value in ValueOf<typeof ShadowDog.StateNamesEnum>]?: State } =\r\n    {};\r\n  // 当前状态\r\n  currentState!: State;\r\n  constructor() {\r\n    this.StateMap[ShadowDog.StateNamesEnum.Running] = new RunningState(this);\r\n    this.StateMap[ShadowDog.StateNamesEnum.Jumping] = new JumpingState(this);\r\n    this.StateMap[ShadowDog.StateNamesEnum.Diving] = new DivingState(this);\r\n    this.StateMap[ShadowDog.StateNamesEnum.Sitting] = new SittingState(this);\r\n    this.StateMap[ShadowDog.StateNamesEnum.Barkting] = new BarktingState(this);\r\n    this.StateMap[ShadowDog.StateNamesEnum.GetHit] = new GetHitState(this);\r\n    this.StateMap[ShadowDog.StateNamesEnum.PreDizzy] = new PreDizzyState(this);\r\n    this.StateMap[ShadowDog.StateNamesEnum.Dizzy] = new DizzyState(this);\r\n    this.StateMap[ShadowDog.StateNamesEnum.Dying] = new DyingState(this);\r\n\r\n    // setState 要放到最后\r\n    this.setState(ShadowDog.StateNamesEnum.Running);\r\n  }\r\n  // 改变状态\r\n  setState(stateName: ValueOf<typeof ShadowDog.StateNamesEnum>) {\r\n    this.currentState = this.StateMap[stateName] as State;\r\n    this.currentState.enter();\r\n  }\r\n  // 更新\r\n  update(timeInterval: number): void {\r\n    // 处理输入\r\n    this.currentState.inputsHandler(this.Game.InputListener.inputs);\r\n    // 更新\r\n    this.currentState.update(timeInterval);\r\n    // 基类的更新\r\n    super.update(timeInterval);\r\n  }\r\n}\r\n\r\nclass RunningState extends State {\r\n  shadowDog: ShadowDog;\r\n  constructor(shadowDog: ShadowDog) {\r\n    super(ShadowDog.StateNamesEnum.Running);\r\n    this.shadowDog = shadowDog;\r\n  }\r\n  enter(): void {\r\n    // 进入该状态，初始化到该状态\r\n    this.shadowDog.moveSpeedX = 0;\r\n    this.shadowDog.moveSpeedY = 0;\r\n    this.shadowDog.setOnGround();\r\n    this.shadowDog.changeAnimateByName(\"run\");\r\n    // 场景移动速度\r\n    this.shadowDog.Game.Scene.setSceneSpeed(\r\n      -this.shadowDog.maxMoveSpeedX * 0.5\r\n    );\r\n  }\r\n  // 状态的更新\r\n  update(timeInterval: number): void {\r\n    // 添加粒子特效\r\n    this.shadowDog.Game.Scene.particles.unshift(\r\n      new Dust(\r\n        this.shadowDog.posX + this.shadowDog.drawWidth / 2,\r\n        this.shadowDog.posY + this.shadowDog.drawHeight\r\n      )\r\n    );\r\n    // 检测是否收到伤害\r\n    if (this.shadowDog.isGetHit(this.shadowDog.Game.Scene.enemys)) {\r\n      this.shadowDog.setState(ShadowDog.StateNamesEnum.GetHit);\r\n      this.shadowDog.Game.lives--; // 生命值减一\r\n    }\r\n  }\r\n  // 输入处理\r\n  inputsHandler(inputs: Array<ValueOf<typeof InputListener.KeyMaps>>): void {\r\n    // 如果按下右键，改变速度等的值\r\n    if (inputs.includes(InputListener.KeyMaps.PressRight)) {\r\n      this.shadowDog.moveSpeedX = this.shadowDog.maxMoveSpeedX * 0.5;\r\n      this.shadowDog.Game.Scene.setSceneSpeed(\r\n        -this.shadowDog.maxMoveSpeedX * 1.0\r\n      );\r\n    } else if (inputs.includes(InputListener.KeyMaps.PressLeft)) {\r\n      this.shadowDog.moveSpeedX = -this.shadowDog.maxMoveSpeedX * 0.5;\r\n      this.shadowDog.Game.Scene.setSceneSpeed(\r\n        this.shadowDog.maxMoveSpeedX * 0.5\r\n      );\r\n    }\r\n    // 按下上键，进入jump状态\r\n    else if (inputs.includes(InputListener.KeyMaps.PressUp)) {\r\n      this.shadowDog.setState(ShadowDog.StateNamesEnum.Jumping);\r\n    }\r\n    // 按下上键，进入sitting状态\r\n    else if (inputs.includes(InputListener.KeyMaps.PressDown))\r\n      this.shadowDog.setState(ShadowDog.StateNamesEnum.Sitting);\r\n    // 松开左右按键，恢复速度等的值\r\n    else {\r\n      this.shadowDog.moveSpeedX = 0;\r\n      this.shadowDog.Game.Scene.setSceneSpeed(\r\n        -this.shadowDog.maxMoveSpeedX * 0.5\r\n      );\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 2.5.4. 使用状态设计模式实现状态管理 Game 类的部分代码\r\n\r\n```ts\r\ntype GameStateEnum = ValueOf<typeof Game.StateEnum>;\r\nexport class Game {\r\n  // 定义一些静态常量表示状态\r\n  static StateEnum = {\r\n    Preview: \"Preview\",\r\n    BeforeRunning: \"BeforeRunning\",\r\n    Running: \"Running\",\r\n    Stop: \"Stop\",\r\n    GameOver: \"GameOver\",\r\n  } as const;\r\n  allStates: { [key in GameStateEnum]?: State } = {};\r\n  currentState!: State;\r\n  InputListener: InputListener;\r\n  constructor(\r\n    Context2D: CanvasRenderingContext2D,\r\n    CANVAS_WIDTH: number,\r\n    CANVAS_HEIGHT: number\r\n  ) {\r\n    this.InputListener = new InputListener();\r\n    this.UI = new UI(this);\r\n\r\n    this.allStates[Game.StateEnum.Preview] = new PreviewStatus(this);\r\n    this.allStates[Game.StateEnum.BeforeRunning] = new BeforeRunning(this);\r\n    this.allStates[Game.StateEnum.Running] = new RunningStatus(this);\r\n    this.allStates[Game.StateEnum.Stop] = new StopStatus(this);\r\n    this.allStates[Game.StateEnum.GameOver] = new GameOverStatus(this);\r\n    this.setState(Game.StateEnum.Preview);\r\n  }\r\n  // 改变状态\r\n  setState(StateName: ValueOf<typeof Game.StateEnum>) {\r\n    console.log(\"current:\" + StateName);\r\n    this.currentState = this.allStates[StateName] as State;\r\n    this.currentState.enter();\r\n  }\r\n  update(timeInterval: number) {\r\n    // 当前状态对输入的处理\r\n    this.currentState.inputsHandler(this.InputListener.inputs);\r\n    // 当前状态的更新\r\n    this.currentState.update(timeInterval);\r\n    this.UI.update(timeInterval);\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D) {\r\n    this.Scene.draw(Context2D);\r\n    this.player.draw(Context2D);\r\n    this.UI.draw(Context2D);\r\n  }\r\n  start() {\r\n    let lastTimeStampFromStart = 0;\r\n    const refreshDisplay = (currentTimeStampFromStart: number) => {\r\n      const timeInterval = currentTimeStampFromStart - lastTimeStampFromStart; // 计算时间间隔\r\n      lastTimeStampFromStart = currentTimeStampFromStart;\r\n      this.update(timeInterval);\r\n      this.draw(this.Context2D);\r\n      requestAnimationFrame(refreshDisplay);\r\n    };\r\n    refreshDisplay(0);\r\n    console.log(\"game is started.\");\r\n  }\r\n}\r\n\r\nclass PreviewStatus extends State {\r\n  Game: Game;\r\n  constructor(game: Game) {\r\n    super(Game.StateEnum.Preview);\r\n    this.Game = game;\r\n  }\r\n  enter(): void {\r\n    // 进入该状态\r\n    this.Game.Music.currentTime = 0; // 从头开始播放\r\n    this.Game.score = 0;\r\n    this.Game.lives = 1000000000;\r\n    this.Game.player.setState(ShadowDog.StateNamesEnum.Running);\r\n    this.Game.UI.addScoreInfos = [];\r\n    this.Game.Scene.enemys = [];\r\n    this.Game.Scene.particles = [];\r\n    this.Game.Scene.explosions = [];\r\n    this.Game.Scene.spakParticles = [];\r\n    return;\r\n  }\r\n  update(timeInterval: number): void {\r\n    // 该状态需要更新的信息，如在stopGame状态，则以下两个信息都不更新就好了\r\n    this.Game.Scene.update(timeInterval);\r\n    this.Game.player.update(timeInterval);\r\n  }\r\n  inputsHandler(inputs: Array<ValueOf<typeof InputListener.KeyMaps>>) {\r\n    // 输入处理，按下enter开始游戏\r\n    if (inputs.includes(InputListener.KeyMaps.Enter)) {\r\n      this.Game.setState(Game.StateEnum.BeforeRunning);\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 2.6. Scene 场景\r\n\r\n主要是用来处理当背景移动，游戏中敌人应当随着背景一起移动的问题，\r\n\r\n这里我写了一个场景类，把需要跟随场景移动的东西都放进去，\r\n\r\n由该类来处理场景的移动速度和场景中物体坐标更新的问题\r\n\r\n以下是部分代码\r\n\r\n```ts\r\nexport class Scene {\r\n  Game: Game;\r\n  private SceneSpeed = 0;\r\n  background: Background;\r\n  constructor(Game: Game) {\r\n    this.Game = Game;\r\n    this.background = new BackgroundCity(\r\n      this.Game.GAME_WIDTH,\r\n      this.Game.GAME_HEIGHT\r\n    );\r\n  }\r\n  // 这一步最关键，处理死亡的敌人，\r\n  // 另外还要更具场景移动速度，重新计算场景中敌人的位置\r\n  update(timeInterval: number) {\r\n    // handles\r\n    this.enemysHandle(timeInterval);\r\n    // 最值处理，限制粒子特效的数量\r\n    if (this.particles.length > this.particlesMaxLength)\r\n      this.particles.length = this.particlesMaxLength;\r\n    if (this.spakParticles.length > this.spakParticlesMaxLength)\r\n      this.spakParticles.length = this.spakParticlesMaxLength;\r\n    // 更新\r\n    // 更新背景的移动速度\r\n    this.background.setSpeed(this.SceneSpeed);\r\n    this.background.update(timeInterval);\r\n    // 移除死亡和超出屏幕的敌人\r\n    this.enemys = this.enemys.filter((item) => {\r\n      return !item.isOutOfLeftScreem() && item.getAliveFlag();\r\n    });\r\n    // 更新和重新计算敌人的坐标\r\n    this.enemys.forEach((item) => {\r\n      item.update(timeInterval);\r\n      item.transform(this.SceneSpeed * timeInterval, 0);\r\n    });\r\n    // 更新和重新计算粒子特效的坐标\r\n    this.particles.forEach((item) => {\r\n      item.update(timeInterval);\r\n      item.posX += this.SceneSpeed * timeInterval;\r\n    });\r\n    this.explosions = this.explosions.filter((item) => {\r\n      item.update(timeInterval);\r\n      item.posX += this.SceneSpeed * timeInterval;\r\n      return !item.isLastAnimateFrame();\r\n    });\r\n    this.spakParticles.forEach((item) => {\r\n      item.update(timeInterval);\r\n      item.posX += this.SceneSpeed * timeInterval;\r\n    });\r\n  }\r\n  // 绘制场景中的物体\r\n  draw(Context2D: CanvasRenderingContext2D) {\r\n    this.background.draw(Context2D);\r\n    this.enemys.forEach((item) => item.draw(Context2D));\r\n    this.explosions.forEach((item) => item.draw(Context2D));\r\n    this.particles.forEach((item) => item.draw(Context2D));\r\n    this.spakParticles.forEach((item) => item.draw(Context2D));\r\n  }\r\n  // 设置场景移动速度\r\n  setSceneSpeed(newSpeed: number) {\r\n    this.SceneSpeed = newSpeed;\r\n    return;\r\n  }\r\n  enemysHandle(timeInterval: number) {\r\n    // 周期添加敌人\r\n    if ((this.addEnemyTimer += timeInterval) >= this.addEnemyIntermval) {\r\n      this.addEnemyTimer = 0;\r\n      switch (Math.floor(RandomRange(0, 6))) {\r\n        case 0: // 略\r\n        case 1:\r\n        case 2:\r\n        case 3:\r\n        case 4:\r\n        case 5:\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 2.7. UI\r\n\r\nUI 这部分代码写的又长又丑，只看结构\r\n\r\n```ts\r\nimport { Game } from \"./Game.js\";\r\n\r\ntype addScoreInfo = { posX: number; posY: number; score: string };\r\nexport class UI {\r\n  Game: Game;\r\n  livesImg: HTMLImageElement;\r\n  imgWidth: number;\r\n  imgHeight: number;\r\n  imgDrawWidth: number;\r\n  imgDrawHeight: number;\r\n  addScoreInfos: Array<addScoreInfo> = [];\r\n\r\n  constructor(Game: Game) {\r\n    this.Game = Game;\r\n    this.livesImg = new Image();\r\n    this.livesImg.src = \"./imgs/heart.png\";\r\n    this.imgWidth = 50;\r\n    this.imgHeight = 50;\r\n    this.imgDrawWidth = 40; //this.imgWidth * 0.5;\r\n    this.imgDrawHeight = 40; // this.imgHeight * 0.5;\r\n  }\r\n  // 对漂浮的分数的坐标的计算\r\n  update(timeInterval: number) {\r\n    const targetPosX = 200;\r\n    const moveSpeedX = 0.1;\r\n    const targetPosY = 80;\r\n    const moveSpeedY = 0.1;\r\n    // 这里做的操作是更新数组中的坐标，使其朝着 targetPos 所在的坐标移动\r\n    this.addScoreInfos = this.addScoreInfos\r\n      .map((item) => {\r\n        const stepX = moveSpeedX * timeInterval;\r\n        const stepY = moveSpeedY * timeInterval;\r\n        if (item.posX - targetPosX >= stepX) item.posX -= stepX;\r\n        else if (item.posY - targetPosY <= stepX) item.posX += stepX;\r\n        if (item.posY - targetPosY >= stepY) item.posY -= stepY;\r\n        else if (item.posY - targetPosY <= stepY) item.posY += stepY;\r\n\r\n        const gapX = Math.abs(item.posX - targetPosX);\r\n        const gapY = Math.abs(item.posY - targetPosY);\r\n        if (gapX < stepY && gapY < stepX) {\r\n          // 当前坐标和目标坐标之间的距离小于步长，则移除该项\r\n          return null as unknown as addScoreInfo;\r\n        } else {\r\n          return item;\r\n        }\r\n      })\r\n      .filter((item) => item != null);\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D) {\r\n    Context2D.save();\r\n    const txtSize = 40;\r\n    const ShadowWidth = 2;\r\n    Context2D.font = `${txtSize}px HanaleiFill`;\r\n\r\n    if (this.Game.currentState.stateName == Game.StateEnum.Preview) {\r\n      // 预览界面：显示按下什么键开始游戏\r\n    } else if (this.Game.currentState.stateName == Game.StateEnum.Running) {\r\n      // 游戏运行界面\r\n      // 绘制剩余的生命\r\n      for (let index = 0; index < this.Game.lives; index++) {\r\n        Context2D.drawImage(\r\n          this.livesImg,\r\n          0,\r\n          0,\r\n          this.imgWidth,\r\n          this.imgHeight,\r\n          index * (this.imgDrawWidth + 10) + 10,\r\n          5,\r\n          this.imgDrawWidth,\r\n          this.imgDrawHeight\r\n        );\r\n      }\r\n      // 绘制漂浮的得分数字\r\n      this.addScoreInfos.forEach((item) => {\r\n        Context2D.textAlign = \"left\";\r\n        Context2D.fillStyle = \"white\";\r\n        Context2D.fillText(item.score, item.posX, item.posY);\r\n        Context2D.fillStyle = \"black\";\r\n        Context2D.fillText(\r\n          item.score,\r\n          item.posX + ShadowWidth,\r\n          item.posY + ShadowWidth\r\n        );\r\n      });\r\n    } else if (this.Game.currentState.stateName == Game.StateEnum.Stop) {\r\n      // 游戏暂停界面\r\n      // 显示按下什么键继续游戏\r\n    } else if (this.Game.currentState.stateName == Game.StateEnum.GameOver) {\r\n      // 游戏结束界面，显示分数\r\n    }\r\n    Context2D.restore();\r\n  }\r\n}\r\n```\r\n\r\n## 2.8. 字体\r\n\r\n```css\r\n// 这一步相当于是注册了一个字体，而后页面中就可以使用 `HanaleiFill` 这个字体\r\n@font-face {\r\n  font-family: \"HanaleiFill\";\r\n  src: url(../font/HanaleiFill-Regular.ttf);\r\n}\r\n```\r\n\r\n**如**\r\n\r\n```ts\r\nContext2D.font = `${txtSize}px HanaleiFill`;\r\n```\r\n\r\n**监听页面加载完毕事件和字体加载事件**\r\n\r\n`document.fonts` 的值是文档的 FontFaceSet 接口。FontFaceSet 接口 用于 对 加载新字体、检查已加载字体的加载状态。\r\n\r\n```ts\r\nwindow.addEventListener(\"load\", () => {\r\n\t// 字体加载完成后的逻辑\r\n\tdocument.fonts.ready.then(() => {\r\n\t\t// 此时DOM中的资源和字体就以加载完毕了\r\n\t}\r\n}\r\n```\r\n\r\n## 2.9. Canvas 铺满页面屏幕的实现\r\n\r\n```less\r\n* {\r\n  padding: 0;\r\n  margin: 0;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n}\r\nhtml,\r\nbody {\r\n  position: relative;\r\n  width: 100vw;\r\n  height: 100vh;\r\n  #myCanvas,\r\n  #loading {\r\n    // 居中\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    transform: translate(-50%, -50%);\r\n    // 关键：设置最大宽度为屏幕宽高的100%\r\n    max-width: 100vw;\r\n    max-height: 100vh;\r\n  }\r\n}\r\n```\r\n\r\n## 2.10. 自写工具类\r\n\r\n没什么好讲的，主要看注释和用例\r\n\r\n```ts\r\nexport function RandomRange(from: number, to: number) {\r\n  return Math.random() * (to - from) + from;\r\n}\r\n\r\n// 注意传入的T需用as const修饰，否则被当做字符串\r\nexport type ValueOf<T> = T[keyof T];\r\n```\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>\r\n"}