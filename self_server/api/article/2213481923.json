{"shortInfo":{"title":"设计模式学习笔记(Java版)","date":"2023-01-10T21:00:00.000Z","cover":"\\self_server\\assets\\images\\2022-12-04-01-27-26.png","tags":["笔记","设计模式","design pattens","java"],"categories":"笔记","id":2213481923,"countWords":5390,"readSeconds":539,"assetsbaseUrl":"/self_server/assets/"},"content":"## 设计模式学习笔记(Java 版)\r\n\r\n## 目录\r\n\r\n- [设计模式学习笔记(Java 版)](#设计模式学习笔记java-版)\r\n- [目录](#目录)\r\n- [概述](#概述)\r\n- [统一建模语言中的类图](#统一建模语言中的类图)\r\n- [软件设计原则](#软件设计原则)\r\n\t- [单一职责原则](#单一职责原则)\r\n\t- [开闭原则(Open Close Principle)](#开闭原则open-close-principle)\r\n\t- [里氏代换原则（Liskov Substitution Principle）](#里氏代换原则liskov-substitution-principle)\r\n\t- [依赖倒转原则（Dependence Inversion Principle）](#依赖倒转原则dependence-inversion-principle)\r\n\t- [接口隔离原则（Interface Segregation Principle）](#接口隔离原则interface-segregation-principle)\r\n\t- [迪米特法则（Demeter Principle）](#迪米特法则demeter-principle)\r\n\t- [合成复用原则（Composite Reuse Principle）](#合成复用原则composite-reuse-principle)\r\n- [创建型模式](#创建型模式)\r\n\t- [\\_1\\_单例设计模式（Singleton Pattern）](#_1_单例设计模式singleton-pattern)\r\n\t\t- [饿汉单例](#饿汉单例)\r\n\t\t- [懒汉单例](#懒汉单例)\r\n\t\t- [通过对象序列化破坏单例模式](#通过对象序列化破坏单例模式)\r\n\t\t- [防止对象序列化破坏单例模式](#防止对象序列化破坏单例模式)\r\n\t\t- [通过反射破坏单例设计模式](#通过反射破坏单例设计模式)\r\n\t\t- [防止反射破坏单例设计模式](#防止反射破坏单例设计模式)\r\n\t- [工厂模式](#工厂模式)\r\n\t- [简单工厂模式(不属于 23 种经典设计模式)](#简单工厂模式不属于-23-种经典设计模式)\r\n\t- [\\_2\\_工厂方法模式](#_2_工厂方法模式)\r\n\t- [\\_3\\_抽象工厂模式](#_3_抽象工厂模式)\r\n\r\n## 概述\r\n\r\n**学习目的:**\r\n\r\n提高代码的\r\n\r\n- `可复用性`（相同功能的代码只写一次）\r\n- `可读性`(编程规范，便于其他程序员阅读和理解)\r\n- `可扩展性(可维护性)`(增添新功能方便)\r\n- `可靠性`(增加或减少功能后不影响原有功能)\r\n- 使得程序\r\n  - `高内聚`(模块内部紧密)\r\n  - `低耦合`（模块和模块之间低耦合）\r\n\r\n**分类**\r\n\r\n- **创建型**设计模式：单例、原型、工厂、抽象工厂、建造者\r\n  - 将对象的创建和使用分离，完成了解构\r\n- **结构型**设计模式：代理、适配器、桥接、装饰、外观、享元、组合\r\n  - 解决如何将类和对象组成更大结构的问题\r\n- **行为型**设计模式：模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器\r\n  - 描述类和对象如何职责分配互相协作完成单个类无法完成的任务\r\n\r\n## 统一建模语言中的类图\r\n\r\n**统一建模语言和类图**\r\n\r\n- **统一建模语言 UML** 是（Unified Modeling Language，UML）是用来**设计软件**的**可视化建模语言**。\r\n- **类图 Class diagram** 是 UML 中的一部分，反映了模型的**静态结构**\r\n\r\n**类图的格式**\r\n\r\n- 类图**属性**的完整格式 ：`可见性 属性名: 类型 [=默认值]`\r\n- 类图**方法**的完整格式 ：`可见性 方法名(形参列表)[:类型]`\r\n- 表示可见性的三种符号\r\n  - `+` public\r\n  - `-` private\r\n  - `#` protected\r\n  - ` ` default\r\n\r\n**类图示例**\r\n\r\n```\r\n+--------------------+\r\n|      Employee      |\r\n|--------------------|\r\n| - name:String      |\r\n| - age:int          |\r\n| - address:String   |\r\n|--------------------|\r\n| + work():void      |\r\n+--------------------+\r\n\r\n\r\n+---------------------------------+\r\n|             Example             |\r\n|---------------------------------|\r\n|                                 |\r\n|---------------------------------|\r\n| + method(int a,int b):void      |\r\n+---------------------------------+\r\n```\r\n\r\n**类图表示法**\r\n\r\n**关联关系**\r\n\r\n1. **单向关联关系**\r\n\r\n   - 一个类中的成员变量是另一个类\r\n   - ![](./images/customer_address.png)\r\n\r\n2. **双向关联关系**\r\n\r\n   - 两个类各自持有对方的类型成员变量\r\n   - ![](./images/customer_product.png)\r\n\r\n3. **自关联关系**  \r\n   ![](./images/node.png)\r\n\r\n4. **聚合关联关系**\r\n\r\n   - 是强关联关系\r\n   - 成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。 ![](./images/image-20191229173422328.png)\r\n\r\n5. **组合关联关系**\r\n\r\n   - 是一种更强烈的聚合关系\r\n   - 整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。 ![](./images/image-20191229173455149.png)\r\n\r\n6. **依赖关系**\r\n\r\n   - 对象之间耦合度最小的一种关系\r\n   - 是一种使用关系,是某个类的方法通过方法的**形式参数**、**局部变量**、或者对**静态方法**的调用来访问另一个类（被依赖类）中的**某些方法**来完成一些职责\r\n   - ![](./images/image-20191229173518926.png)\r\n\r\n7. **继承关系(泛化关系)**\r\n   - 对象之间耦合度最大的一种关系\r\n   - 表示一般与特殊,父类与子类之间的关系\r\n   - ![](./images/image-20191229173539838.png)\r\n\r\n## 软件设计原则\r\n\r\n设计原则是**编程应当遵守的规则**\r\n\r\n**设计原则也是各种设计模式的基础**\r\n\r\n设计原则是为了提高系统的 `可维护性`、`可复用性`、`可扩展性` 和 `灵活性`\r\n\r\n### 单一职责原则\r\n\r\n**一个类应该只负责一项职责**。\r\n\r\n- > **原因：** 如果一个类 A 负责两项职责 a、b。当修改职责 a 时可能会导致修改类 A，从而导致影响到职责 b\r\n- 就是各司其职,一`个类只只负责一项职责`\r\n- 目的是降低类的复杂度，降低变更代码引起的风险，提高可维护性、可读性\r\n- `通常情况应当遵守单一职责模式`，`除非`代码十分简单\r\n- `也可以在方法的级别上遵守单一职责模式`，`但`方法的数量要足够少\r\n\r\n**代码示例 1:待修改代码**\r\n\r\n```java\r\npackage com.dyg;\r\npublic class SingleResponsbility1 {\r\n\tpublic static void main(String[] args) {\r\n\t\tVehicle vehicle = new Vehicle();\r\n\t\tvehicle.run(\"小汽车\");\r\n\t\tvehicle.run(\"飞机\");\r\n\t\tvehicle.run(\"轮船\");\r\n\t}\r\n}\r\n\r\nclass Vehicle {\r\n\tvoid run(String name) {\r\n\t\tSystem.out.println(name + \"在地面上跑...\");\r\n\t}\r\n}\r\n```\r\n\r\n**示例代码 2：**\r\n\r\n在类的级别上按照单一职责设计模式修改\r\n\r\n```java\r\npackage com.dyg;\r\n\r\npublic class SingleResponsbility2 {\r\n\tpublic static void main(String[] args) {\r\n\t\tnew VehicleRoad().run(\"小汽车\");\r\n\t\tnew VehicleAir().run(\"飞机\");\r\n\t\tnew VehicleSea().run(\"轮船\");\r\n\t}\r\n}\r\n\r\nclass VehicleRoad {\r\n\tvoid run(String name) {\r\n\t\tSystem.out.println(name + \"在地面上跑...\");\r\n\t}\r\n}\r\n\r\nclass VehicleAir {\r\n\tvoid run(String name) {\r\n\t\tSystem.out.println(name + \"在天上飞...\");\r\n\t}\r\n}\r\n\r\nclass VehicleSea {\r\n\tvoid run(String name) {\r\n\t\tSystem.out.println(name + \"在水里游...\");\r\n\t}\r\n}\r\n```\r\n\r\n**示例代码 3**：\r\n\r\n在方法的级别上按照单一职责模式修改代码\r\n\r\n```java\r\npackage com.dyg;\r\n\r\npublic class SingleResponsbility3 {\r\n\tpublic static void main(String[] args) {\r\n\t\tVehicle3 vehicle = new Vehicle3();\r\n\t\tvehicle.runRoad(\"小汽车\");\r\n\t\tvehicle.runAir(\"飞机\");\r\n\t\tvehicle.runSea(\"轮船\");\r\n\t}\r\n}\r\n\r\nclass Vehicle3 {\r\n\tvoid runRoad(String name) {\r\n\t\tSystem.out.println(name + \"在地面上跑...\");\r\n\t}\r\n\r\n\tvoid runAir(String name) {\r\n\t\tSystem.out.println(name + \"在天上飞...\");\r\n\t}\r\n\r\n\tvoid runSea(String name) {\r\n\t\tSystem.out.println(name + \"在水里游...\");\r\n\t}\r\n}\r\n```\r\n\r\n### 开闭原则(Open Close Principle)\r\n\r\n**对扩展开放，对修改关闭**。\r\n\r\n- 就是在需要扩展程序时，不去修改源代码\r\n- 这将提高程序的可扩展性、易于维护和升级\r\n- 这种效果需要使用`接口`或`抽象类`\r\n\r\n![](./images/open-close.png)\r\n\r\n案例：搜狗输入法对外提供修改默认皮肤的方法\r\n\r\n```java\r\npackage com.dyg.openClose;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\tSouGouInput souGouInput = new SouGouInput();\r\n\t\tsouGouInput.display();\r\n\r\n\t\tsouGouInput.setSkin(new MySkin());// 修改皮肤\r\n\t\tsouGouInput.display();\r\n\t}\r\n}\r\n\r\n// 抽象皮肤类\r\nabstract class Skin {\r\n\tabstract void display();\r\n}\r\n\r\n// 默认皮肤\r\nclass DefaultSkin extends Skin {\r\n\t@Override\r\n\tvoid display() {\r\n\t\tSystem.out.println(\"默认皮肤\");\r\n\t}\r\n}\r\n\r\n// 带有默认皮肤的输入法\r\nclass SouGouInput {\r\n\tprivate Skin skin = new DefaultSkin();\r\n\r\n\tpublic void setSkin(Skin skin) {\r\n\t\tthis.skin = skin;\r\n\t}\r\n\r\n\tvoid display() {\r\n\t\tthis.skin.display();\r\n\t}\r\n}\r\n\r\n// 用户自定义皮肤\r\nclass MySkin extends Skin {\r\n\t@Override\r\n\tvoid display() {\r\n\t\tSystem.out.println(\"自定义皮肤\");\r\n\t}\r\n}\r\n\r\n```\r\n\r\n### 里氏代换原则（Liskov Substitution Principle）\r\n\r\n**任何基类可以出现的地方，子类也应当可以出现**\r\n\r\n- 换句话说，子类可以扩展父类的功能，但不能改变父类原有的功能，\r\n- 或者说，要尽量避免重写父类方法，**实在必要时，则需要十分谨慎**\r\n- 否则，随意重写父类方法，会导致在使用多态特性时，程序出错概率增大。\r\n- 该原则是面向对象设计的基本原则之一\r\n- 该原则是对开闭原则的补充。\r\n- 该原则是对实现抽象化的具体步骤的规范\r\n\r\n### 依赖倒转原则（Dependence Inversion Principle）\r\n\r\n- 针对接口编程，依赖于抽象而不依赖于具体。\r\n- 这个原则是开闭原则的基础，\r\n\r\n**如：**\r\n\r\n电脑类应当依赖 CPU 的抽象类,但不应该依赖具体某个品牌的 CPU,具体品牌只是 CPU 抽象类的实现\r\n\r\n**依赖倒转前** <img src=\"images/依赖倒转原则.png\" style=\"zoom:80%;\" />\r\n\r\n**依赖倒转后** <img src=\"images/依赖倒转原则改进.png\" alt=\"image-20191229173554296\" style=\"zoom:70%;\" />\r\n\r\n### 接口隔离原则（Interface Segregation Principle）\r\n\r\n- 客户端不应该被迫依赖它不使用的方法。\r\n- 一个类对另一个类的依赖应当建立在最小接口上\r\n- 使用多个隔离的接口，比使用单个接口要好。\r\n- **目的**是降低依赖，降低类之间的耦合。\r\n- **比如说**，有某个 C 类依赖 I 接口中的三个方法，但 I 接口中一共有 10 个方法，则应该把这三个方法单独拆分成另一个接口\r\n\r\n### 迪米特法则（Demeter Principle）\r\n\r\n- 也称最少知道原则\r\n- **意思是：**一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\r\n- **或者说，**尽量多用 private 修饰方法，尽量少用 public 修饰方法\r\n\r\n### 合成复用原则（Composite Reuse Principle）\r\n\r\n- 是指：尽量使用合成/聚合的方式，而不是使用继承。\r\n\r\n## 创建型模式\r\n\r\n### _1_单例设计模式（Singleton Pattern）\r\n\r\n- 是 Java 中最简单的设计模式之一。\r\n- 属于创建型模式，它提供了一种创建对象的最佳方式。\r\n- **意思是**让某个类只能创建(实例化)一个对象\r\n  - 这包含两个类，单例类(只能被实例化一次的类)、访问类(访问单例类的类)\r\n\r\n**分类及优缺点**\r\n\r\n- **饿汉单例**：\r\n  - 特点：类加载时创建对象\r\n  - 优缺点：浪费内存，但性能好，获取实例对象时不需要再去创建了\r\n- **懒汉单例**：\r\n  - 特点：首次调用获取实例的方法时创建对象\r\n  - 优缺点：不浪费内存，但**存在线程安全问题,需要用 `synchronized` 关键字来解决**\r\n\r\n#### 饿汉单例\r\n\r\n**java 版:静态成员变量法**\r\n\r\n也可以用静态代码块的方式，不难，不写了\r\n\r\n```java\r\npackage 创建型;\r\npublic class 单例设计模式_饿汉单例 {\r\n\tpublic static void main(String[] args) {\r\n\t\tDemo demo = Demo.getInstance();\r\n\t\tSystem.out.println(demo);\r\n\t}\r\n}\r\n\r\nclass Demo {\r\n\tprivate Demo() {\r\n\t\t// 私有化构造函数,外界使用new直接创建对象就会报错\r\n\t}\r\n\r\n\t// 内部能访问私有化后的构造函数,所以此处能够实例化。\r\n\t// 静态成员变量意味着其会在类加载阶段被初始化\r\n\tprivate static Demo instanceHunger = new Demo();\r\n\r\n\t// 对外暴露一个获取实例对象的接口\r\n\tpublic static Demo getInstance() {\r\n\t\treturn instanceHunger;\r\n\t}\r\n}\r\n```\r\n\r\n**Java 枚举版**\r\n\r\n使用枚举类是实现饿汉单例模式的最佳方法 它更简洁，自动支持序列化机制，绝对防止多次实例化。 能避免多线程同步问题，也能避免通过反射来破坏单例模式。\r\n\r\n```java\r\npackage 创建型.单例设计模式.饿汉.枚举;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\tDemo demo0 = Demo.getInstance();\r\n\t\tdemo0.doSomeThing();\r\n\r\n\t\tDemo demo1 = Demo.getInstance().getSelf();\r\n\t\tDemo demo2 = Demo.getInstance().getSelf();\r\n\t\tSystem.out.println(demo1 == demo2);\r\n\t}\r\n}\r\n\r\nenum Demo {\r\n\tINSTANCE;\r\n\t// 静态方法\r\n\tpublic static Demo getInstance() {\r\n\t\treturn INSTANCE;\r\n\t}\r\n\r\n\t// 成员方法，属于INSTANCE\r\n\tpublic void doSomeThing() {\r\n\t\tSystem.out.println(\"hello\");\r\n\t}\r\n\r\n\t// 成员方法，属于INSTANCE\r\n\tpublic Demo getSelf() {\r\n\t\treturn this;\r\n\t}\r\n}\r\n```\r\n\r\n**javascript 版**\r\n\r\n```js\r\nclass Demo {\r\n\tconstructor() {}\r\n}\r\n\r\nclass DemoInstance {\r\n\tstatic instance = new Demo();\r\n\tstatic getInstance() {\r\n\t\treturn this.instance;\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tlet i1 = DemoInstance.getInstance();\r\n\tlet i2 = DemoInstance.getInstance();\r\n\tconsole.log(i1 == i2); // true\r\n}\r\n\r\nmain();\r\n```\r\n\r\n#### 懒汉单例\r\n\r\n**java 版 1:synchronized 加锁**\r\n\r\n由于存在线程安全问题，所以需要使用 synchronized 关键字来解决，保证多个线程对该函数的调用是依次的、同步的\r\n\r\n```java\r\npackage 创建型;\r\n\r\npublic class 单例设计模式_懒汉单例 {\r\n\tpublic static void main(String[] args) {\r\n\t\tDemo demo1 = Demo.getInstance();\r\n\t\tDemo demo2 = Demo.getInstance();\r\n\t\tSystem.out.println(demo1 == demo2);\r\n\t}\r\n}\r\n\r\nclass Demo {\r\n\tprivate Demo() {\r\n\t\t// 私有化构造函数,外界使用new直接创建对象就会报错\r\n\t}\r\n\r\n\tprivate static Demo instance;\r\n\r\n\t// 由于存在线程安全问题，所以需要使用synchronized关键字来解决，保证多个线程对该函数的调用是依次的、同步的\r\n\tsynchronized public static Demo getInstance() {\r\n\t\tif (instance == null)// 仅在第一次调用获取实例方法时创建实例对象\r\n\t\t\tinstance = new Demo();\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n\r\n**java 版 2:双重检查锁（DCL，即 double-checked locking）+`volatile`关键字**\r\n\r\n由于线程安全问题只存在于写操作上，对整个函数加线程锁是有性能问题的，  \r\n这将导致多个线程同时调用该函数时，将被强制依次访问  \r\n解决的方法是双重检查锁, 仅在写操作上加锁\r\n\r\n由于 JVM 在实例化对象时会进行优化和指令重排序操作，  \r\n这将导致在多线程的情况下，双重检查锁依然可能会带来空指针问题，所以还需要使用 volatile 关键字,用它来保证指令的有序性\r\n\r\n```java\r\npackage 创建型;\r\n\r\npublic class 单例设计模式_懒汉单例2 {\r\n\tpublic static void main(String[] args) {\r\n\t\tDemo demo1 = Demo.getInstance();\r\n\t\tDemo demo2 = Demo.getInstance();\r\n\t\tSystem.out.println(demo1 == demo2);\r\n\t}\r\n}\r\n\r\nclass Demo {\r\n\tprivate Demo() {\r\n\t\t// 私有化构造函数,外界使用new直接创建对象就会报错\r\n\t}\r\n\r\n\t// 由于JVM在实例化对象时会进行优化和指令重排序操作，\r\n\t// 这将导致在多线程的情况下，双重检查锁依然可能会带来空指针问题，需要使用volatile关键字，\r\n\t// 用它来保证指令的有序性\r\n\r\n\tprivate static volatile Demo instance;\r\n\tprivate static Demo instance;\r\n\r\n\t// 由于线程安全问题只存在于写操作上，对整个函数加线程锁是有性能问题的，\r\n\t// 这将导致多个线程同时调用该函数时，将被强制依次访问\r\n\t// 解决的方法是双重检查锁, 仅在写操作上加锁\r\n\tsynchronized public static Demo getInstance() {\r\n\t\tif (instance == null) {\r\n\t\t\tsynchronized (instance) {// 锁住instance对象\r\n\t\t\t\tif (instance == null)// 重新进行判断\r\n\t\t\t\t\tinstance = new Demo();// 赋值\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n\r\n**java 版 3:利用 jvm 加载`静态内部类`的特性来实现**\r\n\r\n- 开源项目中常用\r\n- 无需加锁，线程安全\r\n- 不影响性能，不浪费空间\r\n\r\n由于 jvm 在加载类的字节码时，不会递归加载其静态的内部类，  \r\n仅当内部类被访问时，其才会被加载\r\n\r\n```java\r\npackage 创建型.懒汉单例3;\r\n\r\npublic class 单例设计模式_懒汉单例3 {\r\n\tpublic static void main(String[] args) {\r\n\t\tDemo demo1 = Demo.getInstance();\r\n\t\tDemo demo2 = Demo.getInstance();\r\n\t\tSystem.out.println(demo1 == demo2);\r\n\t}\r\n}\r\n\r\nclass Demo {\r\n\tprivate Demo() {\r\n\t\t// 私有化构造函数,外界使用new直接创建对象就会报错\r\n\t}\r\n\r\n\t// 由于jvm在加载类的字节码时，不会递归加载其静态的内部类，\r\n\t// 仅当内部类被访问时，其才会被加载\r\n\tprivate static class InstanceHolder {\r\n\t\t// 私有、静态、最终....\r\n\t\tprivate static final Demo INSTANCE = new Demo();\r\n\t}\r\n\r\n\tpublic static Demo getInstance() {\r\n\t\treturn InstanceHolder.INSTANCE;\r\n\t}\r\n}\r\n```\r\n\r\n**javaScript 版**\r\n\r\njs 是单线程，事件驱动，不用担心线程安全问题\r\n\r\n```js\r\nclass Demo {\r\n\tconstructor() {}\r\n}\r\n\r\nclass DemoInstance {\r\n\tstatic instance;\r\n\tstatic getInstance() {\r\n\t\tif (this.instance == undefined) this.instance = new Demo();\r\n\t\treturn this.instance;\r\n\t}\r\n}\r\n\r\nfunction main() {\r\n\tlet i1 = DemoInstance.getInstance();\r\n\tlet i2 = DemoInstance.getInstance();\r\n\ti1[\"test\"] = \"hhhh\";\r\n\tconsole.log(i2[\"test\"]); // \"hhhh\"\r\n\tconsole.log(i1 === i2); // true\r\n}\r\n\r\nmain();\r\n```\r\n\r\n#### 通过对象序列化破坏单例模式\r\n\r\n```java\r\npackage 创建型.单例设计模式.通过序列化破坏单例模式;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.ObjectInput;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutput;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tDemo demo1 = Demo.getInstance();\r\n\t\tUtils.ObjToFile(demo1);\r\n\t\tDemo demo2 = (Demo) Utils.FileToObj();\r\n\t\tSystem.out.println(demo1 == demo2); // false\r\n\t}\r\n}\r\n\r\nclass Demo implements Serializable {\r\n\tprivate Demo() {\r\n\t};\r\n\r\n\tprivate static Demo instance = new Demo();\r\n\r\n\tpublic static Demo getInstance() {\r\n\t\treturn instance;\r\n\t}\r\n}\r\n\r\nclass Utils {\r\n\tstatic void ObjToFile(Object object) throws Exception {\r\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(\"./temp\"));\r\n\t\tobjectOutput.writeObject(object);\r\n\t\tobjectOutput.close();\r\n\t}\r\n\r\n\tstatic Object FileToObj() throws Exception {\r\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(\"./temp\"));\r\n\t\tObject result = objectInput.readObject();\r\n\t\tobjectInput.close();\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n#### 防止对象序列化破坏单例模式\r\n\r\n只需要为其添加`public Object readResolve();`方法\r\n\r\n```java\r\npackage 创建型.单例设计模式.防止序列化破坏单例模式;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.ObjectInput;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutput;\r\nimport java.io.ObjectOutputStream;\r\nimport java.io.Serializable;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tDemo demo1 = Demo.getInstance();\r\n\t\tUtils.ObjToFile(demo1);\r\n\t\tDemo demo2 = (Demo) Utils.FileToObj();\r\n\t\tSystem.out.println(demo1 == demo2); // true\r\n\t}\r\n}\r\n\r\nclass Demo implements Serializable {\r\n\tprivate Demo() {\r\n\t};\r\n\r\n\tprivate static Demo instance = new Demo();\r\n\r\n\tpublic static Demo getInstance() {\r\n\t\treturn instance;\r\n\t}\r\n\r\n\t// 反序列化时，如果该方法存在，就会调用这个方法\r\n\tpublic Object readResolve() {\r\n\t\treturn instance;\r\n\t}\r\n}\r\n\r\nclass Utils {\r\n\tstatic void ObjToFile(Object object) throws Exception {\r\n\t\tObjectOutput objectOutput = new ObjectOutputStream(new FileOutputStream(\"./temp\"));\r\n\t\tobjectOutput.writeObject(object);\r\n\t\tobjectOutput.close();\r\n\t}\r\n\r\n\tstatic Object FileToObj() throws Exception {\r\n\t\tObjectInput objectInput = new ObjectInputStream(new FileInputStream(\"./temp\"));\r\n\t\tObject result = objectInput.readObject();\r\n\t\tobjectInput.close();\r\n\t\treturn result;\r\n\t}\r\n}\r\n```\r\n\r\n#### 通过反射破坏单例设计模式\r\n\r\n```java\r\npackage 创建型.单例设计模式.通过反射破坏单例模式;\r\n\r\nimport java.lang.reflect.Constructor;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tConstructor constrator = Demo.class.getDeclaredConstructor();// 获取构造函数\r\n\t\tconstrator.setAccessible(true);// 设置可访问性\r\n\t\tDemo demo1 = (Demo) constrator.newInstance();// 用构造函数创建对象\r\n\t\tDemo demo2 = (Demo) constrator.newInstance();// 用构造函数创建对象\r\n\t\tSystem.out.println(demo1 == demo2);// false\r\n\t}\r\n}\r\n\r\nclass Demo {\r\n\tprivate Demo() {\r\n\t};\r\n\r\n\tprivate static Demo instance = new Demo();\r\n\r\n\tpublic static Demo getInstance() {\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n\r\n#### 防止反射破坏单例设计模式\r\n\r\n```java\r\npackage 创建型.单例设计模式.防止反射破坏单例模式;\r\n\r\nimport java.lang.reflect.Constructor;\r\n\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tConstructor constrator = Demo.class.getDeclaredConstructor();// 获取构造函数\r\n\t\tconstrator.setAccessible(true);// 设置可访问性\r\n\t\tDemo demo1 = (Demo) constrator.newInstance();// 用构造函数创建对象\r\n\t\tDemo demo2 = (Demo) constrator.newInstance();// 用构造函数创建对象\r\n\t\tSystem.out.println(demo1 == demo2);// false\r\n\t}\r\n}\r\n\r\nclass Demo {\r\n\tprivate static boolean first = false;\r\n\r\n\tprivate Demo() {\r\n\t\tif (!first)\r\n\t\t\tthrow new RuntimeException(\"不能创建多个:\" + Demo.class.toString());\r\n\t\tfirst = true;\r\n\t};\r\n\r\n\tprivate static Demo instance = new Demo();\r\n\r\n\tpublic static Demo getInstance() {\r\n\t\treturn instance;\r\n\t}\r\n}\r\n```\r\n\r\n### 工厂模式\r\n\r\n**意义：**\r\n\r\n- 工厂模式的意义在于隐藏创建的细节\r\n- 如：咖啡是否加糖，加奶\r\n- 再比如，前端中，`new Image()` 后 为其设置`img.src`\r\n\r\n### 简单工厂模式(不属于 23 种经典设计模式)\r\n\r\n- 不属于 23 种经典设计模式\r\n- 只是一种编程习惯\r\n- 工厂的创建产品的方法经 static 修饰后便称**静态工厂模式**\r\n- 结构\r\n  - 抽象产品类\r\n  - 具体产品类\r\n  - 具体工厂类\r\n- 优点：封装了对象的创建过程，实现了对象的创建和使用分离\r\n- 缺点：新增产品时需要修改工厂的代码，不符合开闭原则\r\n\r\n```java\r\npackage 创建型.工厂模式.简单工厂模式;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\tStore store = new Store();\r\n\r\n\t\tCoffee coffee1 = store.orderCoffee(\"美式咖啡\");\r\n\t\tCoffee coffee2 = store.orderCoffee(\"卡布奇诺咖啡\");\r\n\r\n\t\tSystem.out.println(coffee1.getName());\r\n\t\tSystem.out.println(coffee2.getName());\r\n\t}\r\n}\r\n\r\nabstract class Coffee {\r\n\tabstract String getName();\r\n\r\n\t// 链式写法，返回值也可以为void\r\n\tabstract Coffee addSuger();\r\n\r\n\tabstract Coffee addMilk();\r\n}\r\n\r\n// 工厂模式的意义在于隐藏创建的细节(是否加糖，加奶)\r\nclass SimpleCoffeeFactory {\r\n\t// 该函数经static修饰后便称静态工厂模式\r\n\tpublic Coffee getCoffeeByName(String name) {\r\n\t\tif (name == null)\r\n\t\t\tthrow new RuntimeException(\"咖啡名称不能为null\");\r\n\t\tswitch (name) {\r\n\t\t\tcase \"美式咖啡\":\r\n\t\t\t\treturn new AmericaCoffee().addSuger();// 美式咖啡加糖\r\n\t\t\tcase \"卡布奇诺咖啡\":\r\n\t\t\t\treturn new CappuccinoCoffee().addMilk();// 卡布奇诺加牛奶\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new RuntimeException(\"咖啡名称不存在\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass Store {\r\n\tCoffee orderCoffee(String name) {\r\n\t\treturn new SimpleCoffeeFactory().getCoffeeByName(name);\r\n\t}\r\n}\r\n\r\nclass AmericaCoffee extends Coffee {\r\n\t@Override\r\n\tString getName() {\r\n\t\treturn \"美式咖啡\";\r\n\t}\r\n\r\n\t@Override\r\n\tCoffee addMilk() {\r\n\t\tSystem.out.println(\"加牛奶\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t@Override\r\n\tCoffee addSuger() {\r\n\t\tSystem.out.println(\"加糖\");\r\n\t\treturn this;\r\n\t}\r\n}\r\n\r\nclass CappuccinoCoffee extends Coffee {\r\n\t@Override\r\n\tString getName() {\r\n\t\treturn \"卡布奇诺咖啡\";\r\n\t}\r\n\r\n\t@Override\r\n\tCoffee addMilk() {\r\n\t\tSystem.out.println(\"加牛奶\");\r\n\t\treturn this;\r\n\t}\r\n\r\n\t@Override\r\n\tCoffee addSuger() {\r\n\t\tSystem.out.println(\"加糖\");\r\n\t\treturn this;\r\n\t}\r\n}\r\n```\r\n\r\n### _2_工厂方法模式\r\n\r\n- 结构\r\n  - 抽象工厂类\r\n  - 抽象产品类\r\n  - 具体产品类\r\n  - 具体产品的具体工厂类\r\n- 优点：\r\n  - 用户只需知道具体工厂名称就可以得到想要的产品，无需知道产品的创建细节\r\n  - 新增产品时，只需新增产品的工厂类，无需要修改工厂类的代码，满足开闭原则。\r\n- 缺点：\r\n  - 每增加一个产品就要新增产品的工厂类，增加了系统的复杂度。\r\n\r\n```java\r\npackage 创建型.工厂模式.工厂方法模式;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\t\tStore store = new Store();\r\n\r\n\t\tstore.setCoffeeFactory(new AmericaCoffeeFactory());\r\n\t\tCoffee coffee1 = store.orderCoffee();\r\n\t\tstore.setCoffeeFactory(new CappuccinoCoffeeFactory());\r\n\t\tCoffee coffee2 = store.orderCoffee();\r\n\r\n\t\tSystem.out.println(coffee1.getName());\r\n\t\tSystem.out.println(coffee2.getName());\r\n\t}\r\n}\r\n\r\n// 抽象产品\r\nabstract class Coffee {\r\n\tabstract String getName();\r\n\r\n\tCoffee addSuger() {\r\n\t\tSystem.out.println(\"加糖\");\r\n\t\treturn this;\r\n\t};\r\n\r\n\tCoffee addMilk() {\r\n\t\tSystem.out.println(\"加牛奶\");\r\n\t\treturn this;\r\n\t};\r\n}\r\n\r\n// 抽象工厂\r\nabstract class CoffeeFactory {\r\n\tabstract Coffee getCoffee();\r\n}\r\n\r\n// 实体咖啡美式咖啡\r\nclass AmericaCoffee extends Coffee {\r\n\t@Override\r\n\tString getName() {\r\n\t\treturn \"美式咖啡\";\r\n\t}\r\n}\r\n\r\n// 实体咖啡美式咖啡的工厂\r\nclass AmericaCoffeeFactory extends CoffeeFactory {\r\n\r\n\t@Override\r\n\tCoffee getCoffee() {\r\n\t\treturn new AmericaCoffee().addMilk().addSuger();\r\n\t}\r\n\r\n}\r\n\r\n// 实体咖啡 卡布奇诺咖啡\r\nclass CappuccinoCoffee extends Coffee {\r\n\t@Override\r\n\tString getName() {\r\n\t\treturn \"卡布奇诺咖啡\";\r\n\t}\r\n}\r\n\r\n// 实体咖啡卡布奇诺咖啡的工厂\r\nclass CappuccinoCoffeeFactory extends CoffeeFactory {\r\n\r\n\t@Override\r\n\tCoffee getCoffee() {\r\n\t\treturn new CappuccinoCoffee().addMilk();\r\n\t}\r\n}\r\n\r\nclass Store {\r\n\tCoffeeFactory coffeeFactory;\r\n\r\n\tCoffee orderCoffee() {\r\n\t\treturn coffeeFactory.getCoffee();\r\n\t}\r\n\r\n\tpublic void setCoffeeFactory(CoffeeFactory coffeeFactory) {\r\n\t\tthis.coffeeFactory = coffeeFactory;\r\n\t}\r\n}\r\n```\r\n\r\n### _3_抽象工厂模式\r\n\r\n- 优点：能保证客户端中始终只使用某一产品簇中的一组产品\r\n- 缺点：新增产品时，所有工厂类都需要修改\r\n- 使用场景，\r\n  - 游戏人物的道具，衣服、裤子、鞋、等仅为某个游戏角色独有的道具和装扮。\r\n\r\n```java\r\npackage 创建型.工厂模式.抽象工厂模式;\r\n\r\npublic class Test {\r\n\tpublic static void main(String[] args) {\r\n\r\n\t\t// StyleFactory factory = new AmericanStyleFactory();// 美式风格\r\n\t\tStyleFactory factory = new ItalyStyleFactory();// 意式风格\r\n\r\n\r\n\t\tCoffee coffee = factory.createCoffee();\r\n\t\tDessert dessert = factory.createDessert();\r\n\r\n\t\tSystem.out.println(coffee.getName());\r\n\t\tdessert.show();\r\n\r\n\t}\r\n}\r\n\r\n// 抽象甜品类\r\nabstract class Dessert {\r\n\tabstract void show();\r\n}\r\n\r\n// 抽象咖啡类\r\nabstract class Coffee {\r\n\tabstract String getName();\r\n}\r\n\r\n// 抽象工厂\r\ninterface StyleFactory {\r\n\tDessert createDessert();\r\n\r\n\tCoffee createCoffee();\r\n}\r\n\r\n// 美式风格工厂，生产 抹茶慕斯 和 美式咖啡\r\nclass AmericanStyleFactory implements StyleFactory {\r\n\r\n\t@Override\r\n\tpublic Dessert createDessert() {\r\n\t\treturn new MatchaMousse();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Coffee createCoffee() {\r\n\t\treturn new AmericaCoffee();\r\n\t}\r\n}\r\n\r\n// 意式风格工厂，生产 拿铁咖啡 和 提拉米苏\r\nclass ItalyStyleFactory implements StyleFactory {\r\n\r\n\t@Override\r\n\tpublic Dessert createDessert() {\r\n\t\treturn new Tiramisu();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Coffee createCoffee() {\r\n\t\treturn new LatteCoffee();\r\n\t}\r\n\r\n}\r\n\r\n// 美式咖啡\r\nclass AmericaCoffee extends Coffee {\r\n\r\n\t@Override\r\n\tString getName() {\r\n\t\treturn \"美式咖啡\";\r\n\t}\r\n\r\n}\r\n\r\n// 抹茶慕斯\r\nclass MatchaMousse extends Dessert {\r\n\r\n\t@Override\r\n\tvoid show() {\r\n\t\tSystem.out.println(\"抹茶慕斯\");\r\n\t}\r\n\r\n}\r\n\r\n// 拿铁咖啡\r\nclass LatteCoffee extends Coffee {\r\n\r\n\t@Override\r\n\tString getName() {\r\n\t\treturn \"拿铁咖啡\";\r\n\t}\r\n\r\n}\r\n\r\n// 提拉米苏\r\nclass Tiramisu extends Dessert {\r\n\r\n\t@Override\r\n\tvoid show() {\r\n\t\tSystem.out.println(\"提拉米苏\");\r\n\t}\r\n\r\n}\r\n```\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>\r\n"}