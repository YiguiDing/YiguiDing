{"shortInfo":{"title":"手写实现Promise","date":"2022-07-24T17:32:00.000Z","cover":"/self_server/assets/images/default_cover2.jpg","tags":["Promise"],"hideAtIndex":true,"categories":"笔记","id":82,"countWords":13544,"readSeconds":1354.4,"assetsbaseUrl":"/self_server/assets/"},"content":"## 基本结构搭建\r\n\r\n```js\r\n//1. 声明构造函数\r\n    function Promise(executor){\r\n\r\n    }\r\n//2. 添加then方法\r\n    Promise.prototype.then = function(onResolved,onRejected){\r\n\r\n    }\r\n    // let p = new Promise((resolve,reject)=>{\r\n    //     resolve(\"OK\")\r\n    // })\r\n    // p.then((value)=>{\r\n    //     console.log(value)\r\n    // })\r\n```\r\n\r\n\r\n## resolve与reject函数的结构搭建\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n\r\n//1. 执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n//2. 执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    executor(resolve,reject);\r\n\r\n\r\n//3. resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n\r\n    }\r\n//4. reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n\r\n    }\r\n\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n\r\n## resolve函数与reject函数的实现\r\n\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n//0. 添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n//1. 保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    executor(resolve,reject);\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n//2. 修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n//3. 修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n//4. reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// console.log(p)\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n## 实现异常处理\r\n执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n// 0. 异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// console.log(p)\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n## 实现状态只能修改一次\r\n执行器中的代码应该只能在第一次调用`resolve()`或`reject()`时修改**状态**和**结果**值，实现该功能只需在修改 **状态** 前判断其是否为初始值\r\n\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n    //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //0. 实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n//1. 实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\nlet p = new Promise((resolve,reject)=>{\r\n    resolve(\"OK\")\r\n})\r\nconsole.log(p)\r\np.then((value)=>{\r\n    console.log(value)\r\n})\r\n```\r\n\r\n## then()执行回调函数的实现\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n    //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n//0. 根据promise状态执行回调函数\r\n    if(this.PromsieState == \"fulfilled\")\r\n    {\r\n//2. 传递value\r\n        onResolved(this.PromsieResult);\r\n    }\r\n//1. 根据promise状态执行回调函数\r\n    if(this.PromsieState == \"rejected\")\r\n    {\r\n//3. 传递reason\r\n        onRejected(this.PromsieResult);\r\n    }\r\n    \r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// console.log(p)\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n## then处理异步执行的实现\r\n执行器中的代码存在异步语句时，then方法中需要处理该种情形\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n// 1. 声明属性用于保存回调函数\r\n    this.callBack = {}\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n    //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n// 3. 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n        if(self.callBack.onResolved)\r\n        {\r\n//4. 执行保存的回调函数\r\n            self.callBack.onResolved(data)\r\n        }\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n\r\n// 5. 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n        if(self.callBack.onRejected)\r\n        {\r\n//6. 执行保存的回调函数\r\n            self.callBack.onRejected(data)\r\n        }\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n    //根据promise状态执行回调函数\r\n    if(this.PromsieState == \"fulfilled\")\r\n    {\r\n        //传递value\r\n        onResolved(this.PromsieResult);\r\n    }\r\n    //根据promise状态执行回调函数\r\n    if(this.PromsieState == \"rejected\")\r\n    {\r\n        //传递reason\r\n        onRejected(this.PromsieResult);\r\n    }\r\n//0. 处理当执行器中存在异步语句的情形\r\n    if(this.PromsieState == \"pending\")\r\n    {\r\n// 2. 保存回调函数\r\n        this.callBack = {\r\n            onResolved:onResolved,\r\n            onRejected:onRejected\r\n        }\r\n    }\r\n    \r\n\r\n}\r\nlet p = new Promise((resolve,reject)=>{\r\n    resolve(\"OK\")\r\n})\r\nconsole.log(p)\r\np.then((value)=>{\r\n    console.log(value)\r\n})\r\n```\r\n\r\n## then处理异步执行的多个回调函数的实现\r\n\r\n```js\r\n    //声明构造函数\r\n    function Promise(executor){\r\n        //添加属性\r\n        this.PromsieState = 'pending';\r\n        this.PromsieResult = null ;\r\n        // 声明属性用于保存回调函数\r\n        // this.callBack = {}\r\n//0. 修改为保存数组\r\n        this.callBacks = []\r\n\r\n        //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n        const self = this;//self _this that\r\n\r\n        //执行器函数executor在构造函数中是同步调用的:\r\n        // executor();\r\n\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        // executor(resolve,reject);\r\n\r\n        //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n        try{\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            executor(resolve,reject);\r\n        }catch(error){\r\n            reject(error)\r\n        }\r\n\r\n\r\n        //resolve()是一个函数，应当有一个形式参数\r\n        function resolve(data){\r\n            //实现状态只能修改一次：判断状态是否为初始状态\r\n            if (self.PromsieState !==\"pending\") return;\r\n            \r\n            //修改实例化对象的状态值(属性名：promiseState)\r\n            self.PromsieState = \"fulfilled\"\r\n            //修改实例化对象的结果值(属性名：promiseResult)\r\n            self.PromsieResult = data;\r\n            // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n            // if(self.callBack.onResolved)\r\n            // {\r\n            //     //执行保存的回调函数\r\n            //     self.callBack.onResolved(data)\r\n            // }\r\n//2. 执行所有成功的回调函数\r\n            self.callBacks.forEach(item=>{\r\n                item.onResolved(data)\r\n            })\r\n        }\r\n        //reject()是一个函数，应当有一个形式参数\r\n        function reject(data){\r\n            //实现状态只能修改一次：判断状态是否为初始状态\r\n            if (self.PromsieState !==\"pending\") return;\r\n            \r\n            //reject()函数同resolve一样\r\n            self.PromsieState = \"rejected\"\r\n            self.PromsieResult = data;\r\n\r\n            // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n            // if(self.callBack.onRejected)\r\n            // {\r\n            //     //执行保存的回调函数\r\n            //     self.callBack.onRejected(data)\r\n            // }\r\n//3. 执行所有失败的回调函数\r\n            self.callBacks.forEach(item=>{\r\n                item.onRejected(data)\r\n            })\r\n        }\r\n    }\r\n    //添加then方法\r\n    Promise.prototype.then = function(onResolved,onRejected){\r\n        //根据promise状态执行回调函数\r\n        if(this.PromsieState == \"fulfilled\")\r\n        {\r\n            //传递value\r\n            onResolved(this.PromsieResult);\r\n        }\r\n        //根据promise状态执行回调函数\r\n        if(this.PromsieState == \"rejected\")\r\n        {\r\n            //传递reason\r\n            onRejected(this.PromsieResult);\r\n        }\r\n        //处理当执行器中存在异步语句的情形\r\n        if(this.PromsieState == \"pending\")\r\n        {\r\n            // 保存回调函数\r\n            // this.callBack = {\r\n            //     onResolved:onResolved,\r\n            //     onRejected:onRejected\r\n            // }\r\n//1. 保存所有回调函数\r\n            this.callBacks.push({\r\n                onResolved:onResolved,\r\n                onRejected:onRejected\r\n            })\r\n        }\r\n        \r\n\r\n    }\r\n    let p = new Promise((resolve,reject)=>{\r\n        resolve(\"OK\")\r\n    })\r\n    console.log(p)\r\n    p.then((value)=>{\r\n        console.log(value)\r\n    })\r\n```\r\n\r\n## 处理执行器中同步执行状态下then的返回值\r\nthen的返回值由其中的回调函数决定\r\n* 若回调函数的返回值是一个promise对象，则then返回的promise的状态和值与该对象一致\r\n* 若回调函数的返回值是一个非promise对象，则then返回的是状态为成功的promise对象，且其值为该返回值\r\n* 若回调函数中出现异常，则返回失败promise 且其值为抛出的异常\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n//0. then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n\r\n//5. 处理抛出异常的情况\r\n                    try{\r\n//1. 获取返回值\r\n                        let result = onResolved(this.PromsieResult);\r\n//2. 判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n//3. 分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n//4. 处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n//6. 处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n\r\n\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n//7. rejected处理过程类似\r\n//处理抛出异常的情况\r\n                    try{\r\n//获取返回值\r\n                        let result = onRejected(this.PromsieResult);\r\n//判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n//分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n//处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n//处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        onResolved:onResolved,\r\n                        onRejected:onRejected\r\n                    })\r\n                }\r\n            })\r\n\r\n            \r\n\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            resolve(\"OK\")\r\n        })\r\n        console.log(p)\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n```\r\n\r\n\r\n## 处理执行器中异步执行状态下then的返回值\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n\r\n                    //处理抛出异常的情况\r\n                    try{\r\n                        //获取返回值\r\n                        let result = onResolved(this.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n\r\n\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //处理抛出异常的情况\r\n                    try{\r\n                    //获取返回值\r\n                        let result = onRejected(this.PromsieResult);\r\n                    //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n//1. 处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //处理抛出异常的情况\r\n                            try{\r\n                                //获取返回值\r\n                                let result = onResolved(data);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        },\r\n                        onRejected:function(data){\r\n                            //处理抛出异常的情况\r\n                            try{\r\n                                //获取返回值\r\n                                let result = onRejected(data);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n            \r\n\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                resolve(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n```\r\n\r\n\r\n## then方法优化\r\n对重复执行的代码块进行封装\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n//1. 声明变量\r\n                let self = this\r\n// 2. 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n//3. 调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n//4. 调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n//5. 调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n//6. 调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n            \r\n\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                resolve(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n```\r\n\r\n## catch方法及异常穿透的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n//2. 处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n//3. 处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n        }\r\n//1. 添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n        .then(value=>{\r\n            console.log(value);\r\n        })\r\n        .catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n```\r\n\r\n## resolve方法的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n//1. 添加resolve方法\r\n        Promise.resolve = function(value){\r\n//2. 返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n        .then(value=>{\r\n            console.log(value);\r\n        })\r\n        .catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n//3. 使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n```\r\n\r\n## reject方法的实现\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n//1. 添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n        .then(value=>{\r\n            console.log(value);\r\n        })\r\n        .catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n//2. 使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## all方法的实现\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n            \r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        //添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n//1. 添加all方法\r\n        Promise.all = function(Promises=[]){\r\n            return new Promise((resolve,reject)=>{\r\n//2. 声明计数器\r\n                let count = 0\r\n//3. 成功结果数字\r\n                let results = []\r\n                for(let i =0 ; i<Promises.length;i++)\r\n                Promises[i].then(value=>{\r\n//4. 自增计数器\r\n                    count++;\r\n//5. 存入结果值\r\n                    results[i]=value\r\n//6. 判断是否所有都成功\r\n                    if(count == Promises.length){\r\n//7. 返回结果\r\n                        resolve(results)\r\n                    }\r\n                },reason=>{\r\n//8. 若有任何一个结果为失败，则all返回的也是失败\r\n                    reject(reason);\r\n                })\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## race方法的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n            \r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        //添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n        //添加all方法\r\n        Promise.all = function(Promises=[]){\r\n            return new Promise((resolve,reject)=>{\r\n        //声明计数器\r\n                let count = 0\r\n        //成功结果数字\r\n                let results = []\r\n                for(let i =0 ; i<Promises.length;i++)\r\n                Promises[i].then(value=>{\r\n        //自增计数器\r\n                    count++;\r\n        //存入结果值\r\n                    results[i]=value\r\n        //判断是否所有都成功\r\n                    if(count == Promises.length){\r\n        //返回结果\r\n                        resolve(results)\r\n                    }\r\n                },reason=>{\r\n        //若有任何一个结果为失败，则all返回的也是失败\r\n                    reject(reason);\r\n                })\r\n            })\r\n        }\r\n//1. 添加race方法\r\n        Promise.race = function(Promises=[]){\r\n//2. 返回\r\n            return new Promise((resolve,reject)=>{\r\n//3. 遍历\r\n                for(let i=0 ; i<Promises.length;i++){\r\n//4. 谁先改变状态，谁就能决定返回值的状态\r\n                    Promises[i].then(value=>{\r\n                        resolve(value)\r\n                    },reason=>{\r\n                        reject(reason)\r\n                    })\r\n                }\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## then方法中的回调函数异步执行的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n//0. 使得回调函数异步执行\r\n                    setTimeout(() => {\r\n                        try{\r\n                            //获取返回值\r\n                            let result = type(self.PromsieResult);\r\n                            //判断是否为promise对象\r\n                            if(result instanceof Promise){\r\n                                //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                result.then(v=>{\r\n                                    resolve(v)\r\n                                },r=>{\r\n                                    reject(r)\r\n                                })\r\n                            }else{\r\n                                //处理非promise对象的情况\r\n                                resolve(result)\r\n                            }\r\n                        }catch(error){\r\n                            //处理抛出的异常\r\n                            reject(error)\r\n                        }\r\n                    }, 0);\r\n\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n            \r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        //添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n        //添加all方法\r\n        Promise.all = function(Promises=[]){\r\n            return new Promise((resolve,reject)=>{\r\n        //声明计数器\r\n                let count = 0\r\n        //成功结果数字\r\n                let results = []\r\n                for(let i =0 ; i<Promises.length;i++)\r\n                Promises[i].then(value=>{\r\n        //自增计数器\r\n                    count++;\r\n        //存入结果值\r\n                    results[i]=value\r\n        //判断是否所有都成功\r\n                    if(count == Promises.length){\r\n        //返回结果\r\n                        resolve(results)\r\n                    }\r\n                },reason=>{\r\n        //若有任何一个结果为失败，则all返回的也是失败\r\n                    reject(reason);\r\n                })\r\n            })\r\n        }\r\n        // 添加race方法\r\n        Promise.race = function(Promises=[]){\r\n        // 返回\r\n            return new Promise((resolve,reject)=>{\r\n        // 遍历\r\n                for(let i=0 ; i<Promises.length;i++){\r\n        // 谁先改变状态，谁就能决定返回值的状态\r\n                    Promises[i].then(value=>{\r\n                        resolve(value)\r\n                    },reason=>{\r\n                        reject(reason)\r\n                    })\r\n                }\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## 封装成类\r\n```js\r\n//1. 类名\r\n        class Promise{\r\n//2. 构造函数\r\n            constructor(executor){\r\n                //添加属性\r\n                this.PromsieState = 'pending';\r\n                this.PromsieResult = null ;\r\n                // 声明属性用于保存回调函数\r\n                // this.callBack = {}\r\n                //修改为保存数组\r\n                this.callBacks = []\r\n\r\n                //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n                const self = this;//self _this that\r\n\r\n                //执行器函数executor在构造函数中是同步调用的:\r\n                // executor();\r\n\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                // executor(resolve,reject);\r\n\r\n                //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n                try{\r\n                    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                    executor(resolve,reject);\r\n                }catch(error){\r\n                    reject(error)\r\n                }\r\n\r\n\r\n                //resolve()是一个函数，应当有一个形式参数\r\n                function resolve(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //修改实例化对象的状态值(属性名：promiseState)\r\n                    self.PromsieState = \"fulfilled\"\r\n                    //修改实例化对象的结果值(属性名：promiseResult)\r\n                    self.PromsieResult = data;\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onResolved)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onResolved(data)\r\n                    // }\r\n                    //执行所有成功的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onResolved(data)\r\n                    })\r\n                }\r\n                //reject()是一个函数，应当有一个形式参数\r\n                function reject(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //reject()函数同resolve一样\r\n                    self.PromsieState = \"rejected\"\r\n                    self.PromsieResult = data;\r\n\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onRejected)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onRejected(data)\r\n                    // }\r\n                    //执行所有失败的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onRejected(data)\r\n                    })\r\n                }\r\n        }\r\n//3. then方法\r\n            then(onResolved,onRejected){\r\n                //then的返回值是一个promise\r\n                return new Promise((resolve,reject)=>{\r\n                    //声明变量\r\n                    let self = this\r\n                    //处理失败回调函数为undefined的情况（省略没有写）\r\n                    if(onRejected !== \"function\"){\r\n                        onRejected = (reason)=>{\r\n                            throw reason;\r\n                        }\r\n                    }\r\n                    //处理成功回调函数为undefined的情况（省略没有写）\r\n                    if(onResolved !== \"function\"){\r\n                        onResolved = value=>value\r\n                    }\r\n                    // 定义函数\r\n                    function callback(type){\r\n                        //使得回调函数异步执行\r\n                        setTimeout(() => {\r\n                            try{\r\n                                //获取返回值\r\n                                let result = type(self.PromsieResult);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        }, 0);\r\n\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"fulfilled\")\r\n                    {\r\n                        //传递value\r\n                        // onResolved(this.PromsieResult);\r\n                        //调用函数\r\n                        callback(onResolved)\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"rejected\")\r\n                    {\r\n                        //传递reason\r\n                        // onRejected(this.PromsieResult);\r\n                        //rejected处理过程类似\r\n                        //调用函数\r\n                        callback(onRejected)\r\n                    }\r\n                    //处理当执行器中存在异步语句的情形\r\n                    if(this.PromsieState == \"pending\")\r\n                    {\r\n                        // 保存回调函数\r\n                        // this.callBack = {\r\n                        //     onResolved:onResolved,\r\n                        //     onRejected:onRejected\r\n                        // }\r\n                        //保存所有回调函数\r\n                        this.callBacks.push({\r\n                            //处理执行器中异步执行时回调\r\n                            onResolved:function(data){\r\n                                //调用函数\r\n                                callback(onResolved)\r\n                            },\r\n                            onRejected:function(data){\r\n                                //调用函数\r\n                                callback(onRejected)\r\n                            }\r\n                        })\r\n                    }\r\n                })\r\n                \r\n            }\r\n//4. catch方法\r\n            catch(onRejected){\r\n                return this.then(undefined,onRejected);\r\n            }\r\n//5. resolve方法\r\n            static resolve(value){\r\n            //返回promise对象\r\n                return new Promise((resolve,reject)=>{\r\n                    if(value instanceof Promise){\r\n                        value.then(v=>{\r\n                            resolve(v);\r\n                        },r=>{\r\n                            reject(r);\r\n                        });\r\n                    }else{\r\n                        resolve(value);\r\n                    }\r\n                })\r\n            }\r\n//6. reject方法\r\n            static reject(reason){\r\n                return new Promise((resolve,reject)=>{\r\n                    reject(reason)\r\n                })\r\n            }\r\n// 7. all方法\r\n            static all(Promises=[]){\r\n                return new Promise((resolve,reject)=>{\r\n            //声明计数器\r\n                    let count = 0\r\n            //成功结果数字\r\n                    let results = []\r\n                    for(let i =0 ; i<Promises.length;i++)\r\n                    Promises[i].then(value=>{\r\n            //自增计数器\r\n                        count++;\r\n            //存入结果值\r\n                        results[i]=value\r\n            //判断是否所有都成功\r\n                        if(count == Promises.length){\r\n            //返回结果\r\n                            resolve(results)\r\n                        }\r\n                    },reason=>{\r\n            //若有任何一个结果为失败，则all返回的也是失败\r\n                        reject(reason);\r\n                    })\r\n                })\r\n            }\r\n// 8. race方法\r\n            static race(Promises=[]){\r\n            // 返回\r\n                return new Promise((resolve,reject)=>{\r\n            // 遍历\r\n                    for(let i=0 ; i<Promises.length;i++){\r\n            // 谁先改变状态，谁就能决定返回值的状态\r\n                        Promises[i].then(value=>{\r\n                            resolve(value)\r\n                        },reason=>{\r\n                            reject(reason)\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n       let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## 封装成类\r\n```js\r\n//1. 类名\r\n        class Promise{\r\n//2. 构造函数\r\n            constructor(executor){\r\n                //添加属性\r\n                this.PromsieState = 'pending';\r\n                this.PromsieResult = null ;\r\n                // 声明属性用于保存回调函数\r\n                // this.callBack = {}\r\n                //修改为保存数组\r\n                this.callBacks = []\r\n\r\n                //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n                const self = this;//self _this that\r\n\r\n                //执行器函数executor在构造函数中是同步调用的:\r\n                // executor();\r\n\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                // executor(resolve,reject);\r\n\r\n                //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n                try{\r\n                    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                    executor(resolve,reject);\r\n                }catch(error){\r\n                    reject(error)\r\n                }\r\n\r\n\r\n                //resolve()是一个函数，应当有一个形式参数\r\n                function resolve(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //修改实例化对象的状态值(属性名：promiseState)\r\n                    self.PromsieState = \"fulfilled\"\r\n                    //修改实例化对象的结果值(属性名：promiseResult)\r\n                    self.PromsieResult = data;\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onResolved)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onResolved(data)\r\n                    // }\r\n                    //执行所有成功的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onResolved(data)\r\n                    })\r\n                }\r\n                //reject()是一个函数，应当有一个形式参数\r\n                function reject(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //reject()函数同resolve一样\r\n                    self.PromsieState = \"rejected\"\r\n                    self.PromsieResult = data;\r\n\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onRejected)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onRejected(data)\r\n                    // }\r\n                    //执行所有失败的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onRejected(data)\r\n                    })\r\n                }\r\n        }\r\n//3. then方法\r\n            then(onResolved,onRejected){\r\n                //then的返回值是一个promise\r\n                return new Promise((resolve,reject)=>{\r\n                    //声明变量\r\n                    let self = this\r\n                    //处理失败回调函数为undefined的情况（省略没有写）\r\n                    if(onRejected !== \"function\"){\r\n                        onRejected = (reason)=>{\r\n                            throw reason;\r\n                        }\r\n                    }\r\n                    //处理成功回调函数为undefined的情况（省略没有写）\r\n                    if(onResolved !== \"function\"){\r\n                        onResolved = value=>value\r\n                    }\r\n                    // 定义函数\r\n                    function callback(type){\r\n                        //使得回调函数异步执行\r\n                        setTimeout(() => {\r\n                            try{\r\n                                //获取返回值\r\n                                let result = type(self.PromsieResult);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        }, 0);\r\n\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"fulfilled\")\r\n                    {\r\n                        //传递value\r\n                        // onResolved(this.PromsieResult);\r\n                        //调用函数\r\n                        callback(onResolved)\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"rejected\")\r\n                    {\r\n                        //传递reason\r\n                        // onRejected(this.PromsieResult);\r\n                        //rejected处理过程类似\r\n                        //调用函数\r\n                        callback(onRejected)\r\n                    }\r\n                    //处理当执行器中存在异步语句的情形\r\n                    if(this.PromsieState == \"pending\")\r\n                    {\r\n                        // 保存回调函数\r\n                        // this.callBack = {\r\n                        //     onResolved:onResolved,\r\n                        //     onRejected:onRejected\r\n                        // }\r\n                        //保存所有回调函数\r\n                        this.callBacks.push({\r\n                            //处理执行器中异步执行时回调\r\n                            onResolved:function(data){\r\n                                //调用函数\r\n                                callback(onResolved)\r\n                            },\r\n                            onRejected:function(data){\r\n                                //调用函数\r\n                                callback(onRejected)\r\n                            }\r\n                        })\r\n                    }\r\n                })\r\n                \r\n            }\r\n//4. catch方法\r\n            catch(onRejected){\r\n                return this.then(undefined,onRejected);\r\n            }\r\n//5. resolve方法\r\n            static resolve(value){\r\n            //返回promise对象\r\n                return new Promise((resolve,reject)=>{\r\n                    if(value instanceof Promise){\r\n                        value.then(v=>{\r\n                            resolve(v);\r\n                        },r=>{\r\n                            reject(r);\r\n                        });\r\n                    }else{\r\n                        resolve(value);\r\n                    }\r\n                })\r\n            }\r\n//6. reject方法\r\n            static reject(reason){\r\n                return new Promise((resolve,reject)=>{\r\n                    reject(reason)\r\n                })\r\n            }\r\n// 7. all方法\r\n            static all(Promises=[]){\r\n                return new Promise((resolve,reject)=>{\r\n            //声明计数器\r\n                    let count = 0\r\n            //成功结果数字\r\n                    let results = []\r\n                    for(let i =0 ; i<Promises.length;i++)\r\n                    Promises[i].then(value=>{\r\n            //自增计数器\r\n                        count++;\r\n            //存入结果值\r\n                        results[i]=value\r\n            //判断是否所有都成功\r\n                        if(count == Promises.length){\r\n            //返回结果\r\n                            resolve(results)\r\n                        }\r\n                    },reason=>{\r\n            //若有任何一个结果为失败，则all返回的也是失败\r\n                        reject(reason);\r\n                    })\r\n                })\r\n            }\r\n// 8. race方法\r\n            static race(Promises=[]){\r\n            // 返回\r\n                return new Promise((resolve,reject)=>{\r\n            // 遍历\r\n                    for(let i=0 ; i<Promises.length;i++){\r\n            // 谁先改变状态，谁就能决定返回值的状态\r\n                        Promises[i].then(value=>{\r\n                            resolve(value)\r\n                        },reason=>{\r\n                            reject(reason)\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n       let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```"}