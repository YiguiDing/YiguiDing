{"shortInfo":{"title":"《数据结构与算法分析》第4章_4.二叉查找树","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-27T13:22:27.000Z","modified":"2022-05-31T06:05:19.539Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":3241617381,"countWords":2219,"readSeconds":221.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_4.二叉查找树\r\n\r\n## 二叉树的应用\r\n* 表达式树\r\n* 查找\r\n* 编译器设计\r\n\r\n## 查找树ADT————二叉查找树binary search tree\r\n* **二叉查找树binary search tree**\r\n* 查找是二叉树的重要应用\r\n* 使二叉树成为查找树的性质是：\r\n  + 树中每个节点X的**左子树**中的**所有(包括子树的子树)** 关键字**小于**节点X的关键字\r\n  + 树中每个节点X的**右子树**中的**所有(包括子树的子树)** 关键字**大于**节点X的关键字\r\n  + ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-21-40-24.png)\r\n\r\n## 二叉查找树ADT\r\n  + 由于树的递归定义，其例程通常也是递归编写的\r\n  + 由于二叉树的平均深度是O(log N),也不必担心栈空间耗尽\r\n  + 其删除操作可能导致树的不平衡，因为在处理**被删除的节点有两个子节点的情况**时，其删除策略总是从左或右子树中挑选一个最大或最小的元素删除。\r\n    + 解决办法：通过随机决定\r\n\r\n### 几个需要简略讨论一下的操作\r\n* **MakeEmpty**操作\r\n  + 用于初始化\r\n  + 根据树的递归定义，该操作倾向于认为树没有头节点，所以其操作过程为，先递归为左右两子树释放内存，然后再释放当前节点的内存。\r\n* **Find**操作\r\n  + 返回树种具有某关键字的节点的指针\r\n  + 如果该节点不存在则返回NULL\r\n  + 需要首先对当前所在树的指针进行测试，判断是否为一个空树\r\n  + 其余测试应该安排最不可能的情况最后进行\r\n* **FindMin**和**FindMax**操作\r\n  + 为了与**Find**操作相统一,其返回值是元素的地址而不是元素的值\r\n* **Insert**操作\r\n  + 插入过程是递归进行的；\r\n  + 若插入的元素已经存在，可以什么都不做，也可以提前使节点记录中保留一个域用于记录插入的次数。\r\n  + 若插入的元素不存在，找到了合适的位置就为新树分配内存，初始化该树，赋值\r\n  + 返回值时新树的地址\r\n  + 返回值为树地址意味着可以用该函数创建一棵树\r\n* **Delete**操作\r\n  + 书中delete函数的写法`SearchTree Delete(ElementType X,SearchTree T);`\r\n  + 我的delete函数的写法`SearchTree Delete(ElementType X,SearchTree T,Position Parent);`\r\n    + 主要是考虑到父节的指针域需要修改\r\n  + 需要谨慎考虑返回值，因为如果删除了根节点，整颗树的地址将丢失，所以定义返回值被删除后所在位置元素的地址\r\n  + 和许多数据结构一样，删除操作是最难的。需要考虑多种情况\r\n  + **如果被删除的节点是一个树叶**\r\n    1. 查找值为9的节点\r\n    1. 发现没有子节点，所以直接删除该节点\r\n    1. 同时将其父节点相应的指针域设置NULL\r\n    1. 返回值：NULL\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-29-02-25-13.png)\r\n  + **如果被删除的节点有一个子节点**\r\n    1. 查找值为7的节点\r\n    1. 发现有一个子节点，所以记录下其子节点的指针，然后删除当前所在节点\r\n    1. 同时将其父节点相应的指针域设置为当前所在节点的子节点的指针\r\n    1. 返回值为：子节点地址\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-29-02-38-32.png)\r\n  + **如果被删除的节点有两个子节点**\r\n    1. 查找值为7的节点\r\n    1. 发现有两个子节点，所以找到其继承人，将继承人的值复制到当前位置，然后通过递归调用删除继承人节点\r\n        + 寻找继承人就是在左子树中寻找最大值也就是4，或者就是在右子树中寻找最小值也就是8\r\n        + 递归调用删除元素8的过程，会按照**如果被删除的节点有一个子节点的情况**处理，总之元素8会被删除，元素10的左树指针域将会指向元素9\r\n    1. 返回值为：当前所在节点的地址\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-29-02-43-48.png)\r\n\r\n### 二叉查找树ADT实现\r\n```c\r\n//SearchTree.h\r\n#ifndef _Tree_H_\r\n#define _Tree_H_\r\ntypedef int ElementType;\r\nstruct TreeNode;\r\ntypedef struct TreeNode* Position;\r\ntypedef struct TreeNode* SearchTree;\r\n\r\nSearchTree MakeEmpty(SearchTree T);\r\nPosition Find(ElementType X,SearchTree T);\r\nPosition FindMin(SearchTree T);\r\nPosition FindMax(SearchTree T);\r\nSearchTree Insert(ElementType X,SearchTree T);\r\nSearchTree Delete(ElementType X,SearchTree T,Position Parent);\r\nElementType Retrieve(Position P);\r\n#endif\r\n\r\n```\r\n\r\n```c\r\n//SearchTree.c\r\n#include \"SearchTree.h\"\r\n#include<stdlib.h>\r\nstruct TreeNode\r\n{\r\n    ElementType Element;\r\n    SearchTree Left;\r\n    SearchTree Right;\r\n};\r\n\r\nSearchTree MakeEmpty(SearchTree T)\r\n{\r\n    if (T!=NULL)\r\n    {\r\n        MakeEmpty(T->Left);\r\n        MakeEmpty(T->Right);\r\n        free(T);\r\n    }\r\n}\r\nPosition Find(ElementType X,SearchTree T)\r\n{\r\n    if (T==NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (X < T->Element)\r\n    {\r\n        return Find(X,T->Left);\r\n    }else\r\n    if (X > T->Element)\r\n    {\r\n        return Find(X,T->Right);\r\n    }\r\n    else\r\n        return T;\r\n}\r\nPosition FindMin(SearchTree T)//递归实现\r\n{\r\n    if(T==NULL)\r\n        return NULL;\r\n\r\n    if (T->Left==NULL)//没有左子树，说明已经到达该树的最深处\r\n        return T;\r\n    else\r\n        return FindMin(T->Left);\r\n}\r\nPosition FindMax(SearchTree T)//非递归方式实现\r\n{\r\n    if (T==NULL)\r\n        return NULL;\r\n\r\n    while (T->Right!=NULL)\r\n        T=T->Right;\r\n    return T;\r\n}\r\nSearchTree Insert(ElementType X,SearchTree T)\r\n{\r\n    if (T==NULL)\r\n    {\r\n        T = malloc(sizeof(struct TreeNode));\r\n        if (T == NULL)\r\n            Error(\"out of memory\");\r\n        T->Element = X;\r\n        T->Left = NULL;\r\n        T->Right = NULL;\r\n        return T;\r\n    }\r\n\r\n    if (X < T->Element)\r\n        return Insert(X,T->Left);\r\n    else\r\n    if (X > T->Element)\r\n        return Insert(X,T->Right);\r\n    else//X==T->Element\r\n        ;//T->Element.Count++\r\n\r\n    return T;\r\n}\r\nSearchTree Delete(ElementType X,SearchTree T,Position Parent)\r\n{\r\n    if (T==NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (X < T->Element)\r\n    {\r\n        return Delete(X,T->Left,T);\r\n    }else\r\n    if(X > T->Element)\r\n    {\r\n        return Delete(X,T->Right,T);\r\n    }else//查找到该节点\r\n    {\r\n        if (T->Left && T->Right)//如果该节点有两个子节点\r\n        {\r\n            Position successor;//继承人\r\n            successor=FindMin(T->Right);//继承人就是左子树中最大值，或者就是右子树中最小值\r\n            T->Element=successor->Element;//替换值\r\n            Delete(successor->Element,T->Right,T);//查找并删除继承人原先的所在的位置(递归调用)\r\n            return T;//想象删除的是整颗树的根节点，返回值应该是什么？不管是什么，一定不会是其父节点的地址\r\n        }\r\n        else//如果该节点有0个子节点,那么使当前父节点相应的指针域为NULL,同时释放当前节点的内存\r\n        if(T->Left==NULL && T->Right==NULL)\r\n        {\r\n            if (Parent!=NULL)//重新指定父节点指针\r\n            {\r\n                if(Parent->Left==T)\r\n                    Parent->Left=NULL;\r\n                else\r\n                    Parent->Right=NULL;\r\n            }\r\n            free(T);\r\n            T=NULL;\r\n            return T;\r\n        }else//否则就是只有一个子节点,那么找出当前节点的唯一子节点，使当前节点的父节点的相应的指针域指向当前所在节点的子节点，然后删除当前所在子节点\r\n        {\r\n            Position onlyChild=T->Left==NULL? T->Right:T->Left;\r\n            if (Parent!=NULL)//重新指定父节点指针\r\n            {\r\n                if(Parent->Left==T)\r\n                    Parent->Left=onlyChild;\r\n                else\r\n                    Parent->Right=onlyChild;\r\n            }\r\n            free(T);\r\n            T=onlyChild;\r\n            return T;\r\n        }\r\n    }\r\n}\r\nElementType Retrieve(Position P)\r\n{\r\n    if (P!=NULL)\r\n    {\r\n        return P->Element;\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\n### 我写的Delete例程\r\n```c\r\nSearchTree Delete(ElementType X,SearchTree T,Position Parent)\r\n{\r\n    if (T==NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (X < T->Element)\r\n    {\r\n        return Delete(X,T->Left,T);\r\n    }else\r\n    if(X > T->Element)\r\n    {\r\n        return Delete(X,T->Right,T);\r\n    }else//查找到该节点\r\n    {\r\n        if (T->Left && T->Right)//如果该节点有两个子节点\r\n        {\r\n            Position successor;//继承人\r\n            successor=FindMin(T->Right);//继承人就是左子树中最大值，或者就是右子树中最小值\r\n            T->Element=successor->Element;//替换值\r\n            Delete(successor->Element,T->Right,T);//查找并删除继承人原先的所在的位置(递归调用)\r\n            return T;//想象删除的是整颗树的根节点，返回值应该是什么？不管是什么，一定不会是其父节点的地址\r\n        }\r\n        else//如果该节点有0个子节点,那么使当前父节点相应的指针域为NULL,同时释放当前节点的内存\r\n        if(T->Left==NULL && T->Right==NULL)\r\n        {\r\n            if (Parent!=NULL)//重新指定父节点指针\r\n            {\r\n                if(Parent->Left==T)\r\n                    Parent->Left=NULL;\r\n                else\r\n                    Parent->Right=NULL;\r\n            }\r\n            free(T);\r\n            T=NULL;\r\n            return T;\r\n        }else//否则就是只有一个子节点,那么找出当前节点的唯一子节点，使当前节点的父节点的相应的指针域指向当前所在节点的子节点，然后删除当前所在子节点\r\n        {\r\n            Position onlyChild=T->Left==NULL? T->Right:T->Left;\r\n            if (Parent!=NULL)//重新指定父节点指针\r\n            {\r\n                if(Parent->Left==T)\r\n                    Parent->Left=onlyChild;\r\n                else\r\n                    Parent->Right=onlyChild;\r\n            }\r\n            free(T);\r\n            T=onlyChild;\r\n            return T;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 书中给出的Delete例程(难以理解)\r\n```c\r\n        SearchTree\r\n        Delete( ElementType X, SearchTree T )\r\n        {\r\n            Position TmpCell;\r\n\r\n            if( T == NULL )\r\n                Error( \"Element not found\" );\r\n            else\r\n            if( X < T->Element )  /* Go left */\r\n                T->Left = Delete( X, T->Left );\r\n            else\r\n            if( X > T->Element )  /* Go right */\r\n                T->Right = Delete( X, T->Right );\r\n            else  /* Found element to be deleted */\r\n            if( T->Left && T->Right )  /* Two children */\r\n            {\r\n                /* Replace with smallest in right subtree */\r\n                TmpCell = FindMin( T->Right );\r\n                T->Element = TmpCell->Element;\r\n                T->Right = Delete( T->Element, T->Right );//？？？？？？难以理解？？？？？？\r\n            }\r\n            else  /* One or zero children */\r\n            {\r\n                TmpCell = T;\r\n                if( T->Left == NULL ) \r\n                    T = T->Right;\r\n                else if( T->Right == NULL )\r\n                    T = T->Left;\r\n                //上述两个if将会使得T的值被修改，如果T没有子树，T的值为NULL,如果T有一个子树，T的值为子树的地址\r\n                free( TmpCell );\r\n            }\r\n\r\n            return T;\r\n        }\r\n```\r\n\r\n"}