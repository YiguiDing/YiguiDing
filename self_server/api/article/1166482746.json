{"shortInfo":{"title":"《数据结构与算法分析》第4章_8.伸展树","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-06-06T02:00:05.000Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":1166482746,"countWords":581,"readSeconds":58.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# 伸展树\r\n* **基本想法：** 访问一个节点后，通过一系列的旋转操作将该节点放到根节点上，这样这个节点和这条路径上的所有节点的深度就会降低，下一次访问所花费的时间就会更少。\r\n* 不需要保存或计算高度信息和平衡信息\r\n* 它保证从空树开始任意连续M次对树的操作最多花费 $O(MlogN)$ \r\n* 但不保证某次操作花费$O(N)$时间的可能，\r\n* 这种单次最坏$O(N)$的时间花费虽不如平均最坏花费$O(logN)$时间短，但实际效果是一样的：不存在坏的输入序列\r\n* 当M次操作的序列总的最坏情形运行时间为$O(MF(N))$时，称它的摊还运行时间为$O(F(N))$,因此一颗伸展树每次操作的摊还代价是$O(logN)$\r\n    * 摊还分析用来评价某个数据结构的一系列操作的平均代价，有时可能某个操作的代价特别高，但总体上来看也并非那么糟糕，可以形象的理解为把高代价的操作“分摊”到其他操作上去了，要求的就是均摊后的平均代价。\r\n\r\n## 展开操作Splaying\r\n* 展开操作类似于AVL的旋转操作\r\n* 不过在旋转如何实施上稍微有了选择的余地\r\n* 仍然**从底部向上沿着访问路径旋转**\r\n* 令X是在访问路径上的一个（非根）节点，在这个路径上实施旋转操作。\r\n* 如果X的父节点是根节点，则只需要旋转X和根节点。这就是沿着访问路径上的最后的旋转。\r\n* 否则,X就有父节点P和祖父节点G,这样就有四种情形\r\n    * zig-zig X是P的左子树，P是G的左子树\r\n    * zag-zag X是P的右子树，P是G的右子树\r\n    * zig-zag X是P的右子树，P是G的左子树\r\n    * zag-zig X是P的左子树，P是G的右子树\r\n* ![](./images/《数据结构与算法分析》学习笔记/2022-06-06-15-15-30.png)\r\n\r\n* 对节点1做展开操作的示例\r\n![](./images/《数据结构与算法分析》学习笔记/2022-06-06-15-16-22.png)"}