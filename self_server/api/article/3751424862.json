{"shortInfo":{"title":"nodejs学习笔记","date":"2022-08-28T13:13:00.000Z","cover":"\\self_server\\assets\\images\\nodejs学习笔记\\2022-12-04-01-24-17.png","tags":["nodejs"],"categories":"后端","id":3751424862,"countWords":3031,"readSeconds":303.1,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/nodejs学习笔记/2022-12-04-01-24-17.png) -->\r\n\r\n\r\n# nodejs学习笔记\r\n## 目录\r\n- [nodejs学习笔记](#nodejs学习笔记)\r\n  - [目录](#目录)\r\n  - [基本概念](#基本概念)\r\n  - [模块](#模块)\r\n    - [概念](#概念)\r\n    - [通过`module.exports`实现模块化](#通过moduleexports实现模块化)\r\n    - [npm包管理工具](#npm包管理工具)\r\n  - [内置模块](#内置模块)\r\n    - [fs模块](#fs模块)\r\n    - [path路径模块](#path路径模块)\r\n    - [http模块](#http模块)\r\n  - [尝试自定义模块](#尝试自定义模块)\r\n  - [第三方模块](#第三方模块)\r\n    - [moment.js 三方模块](#momentjs-三方模块)\r\n    - [i5ting\\_toc 第三方模块](#i5ting_toc-第三方模块)\r\n    - [express模块](#express模块)\r\n\r\n\r\n## 基本概念\r\n* <red>**Nodejs是基于ChromeV8的js解析引擎**</red>\r\n* **js解析引擎**\r\n    * Chrome 浏览器 -> V8 **性能最好**\r\n    * Firefox 浏览器 ->   OdinMonkey 奥丁猴\r\n    * Safri 浏览器 -> JSCore\r\n    * IE 浏览器 -> Chakra查克拉\r\n* **运行环境区别**\r\n    * **Nodejs**是js的**后端**运行环境,能调用**nodejs的内置API**\r\n    * **浏览器**是js的**前端**运行环境,能调用**浏览器的内置API**\r\n    * ![图 3](./images/nodejs学习笔记/afb25ede4b5e464b04d2e39ded97f116b68c751c3bb781cd329d73e78c10ca58.png)  \r\n    * ![图 2](./images/nodejs学习笔记/7aa213781d4b45aa5495200255be62941fb36990715cf6fc70c800ca6d6ee2dd.png)  \r\n* **nodejs用途**\r\n  * 基于 **Express** 框架,可快速构建 **Web应用**\r\n  * 基于 **Express** 框架,可快速构建 **跨平台桌面应用**\r\n  * 基于 **restify** 框架,可快速构建 **API接口项目**\r\n  * 读写和操作数据库;创建实用的命令行辅助前端开发;......\r\n* 学习路径\r\n  * js基础语法\r\n  * nodejs内置API\r\n  * 第三方API:express mysql\r\n\r\n\r\n## 模块\r\n\r\n### 概念\r\n**模块的分类**\r\n* 内置模块\r\n* 第三方模块\r\n* 自定义模块\r\n\r\n**CommonJS模块化规范**\r\n* 一个 `.js` 文件就是一个模块,每个模块内部的 **module变量** 代表 **当前模块**\r\n* `module` 变量是一个 **对象** ,其 exports属性 是 对外的接口\r\n* 使用 `require()` 加载模块时,就是在加载 `module.exports` 属性\r\n\r\n>注意: 现已新增 **exports 变量** ,其默认指向`module.exports`所指向的对象,能够被覆盖,即当:`exports={}`时, `exports`便不再指向`module.exports`所指向的对象.\r\n\r\n**模块的加载机制**\r\n> 注意: 使用`require()`引入模块 `XXX.js` 时,会执行 `XXX.js` 中的代码  \r\n> 但模块在第一次引入后会被缓存,后续再次引入不会执行其中代码\r\n* 引入**内置模块**\r\n    ```js\r\n    const fs = require(fs)\r\n    ```\r\n    > 内置模块的优先级最高,即使`./node_modules/`下有`./fs/` 同名模块文件,也会优先加载内置模块\r\n* 引入**第三方模块**\r\n    ```js\r\n    const app = require(express)\r\n    ```\r\n    > 先到当前目录的`./node_modules/`查找模块,若没有则进入到上一级目录的`../node_modules/`,直到文件系统的根目录`/node_modules/`\r\n* 引入**自定义模块**\r\n    ```js\r\n    // 可以省略.js后缀\r\n    const demo1 = require(./demo/demo1.js)\r\n    const demo/demo1 = require(./demo/demo1)\r\n\r\n    // 若/demo2/目录下有package.json文件 则会从main属性找到模块的入口\r\n    const demo2 = require(./demo/demo2/demo2.js)\r\n    const demo2 = require(./demo/demo2)\r\n    ```\r\n    > 注意:引入**自定义模块**时必须使用`./`或`../`的相对路径,可以省略 `.js` 的文件名,  \r\n    > **require会自动按一下顺序补全后缀名**\r\n    > * 不补全\r\n    > * 补全`.js`\r\n    > * 补全`.json`\r\n    > * 补全`.node`\r\n    > * 任然无法定位文件则报错\r\n* **自定义模块:引入目录**\r\n    ```js\r\n    const demo2 = require(./demo/demo2)\r\n    ```\r\n    > 若引入的是一个目录,则有三种情况\r\n    > * 优先在查找**被引入目录**下的`package.json`的`main`属性所指向的文件\r\n    > * 若失败则查找**被引入目录**下的`index.js`文件\r\n    > * 若仍然无法找到,则报错\r\n\r\n\r\n### 通过`module.exports`实现模块化\r\n**使用示例**\r\n```js\r\n// demo1.js\r\nmodule.exports.name = \"DingYigui\"\r\nmodule.exports.sayHi = function(){\r\n    console.log(\"Hi\")\r\n}\r\n```\r\n```js\r\n// demo2.js\r\nconst demo1 = require(\"./demo1\")\r\ndemo1.sayHi();\r\n```\r\n\r\n\r\n### npm包管理工具\r\n\r\n**包的分类**\r\n* 项目包 存放在`./node_modules/`\r\n* 全局包 只有工具性质的包才有安装到全局的必要,因为其提供了终端命令工具\r\n\r\n**包的规范结构**\r\n* 包必须以单独的目录存在\r\n* 包的根目录下必须包含`package.js`\r\n* `package.js`必须包含 `name` `version` `main` 三个属性,其中main表示包的入口\r\n    > 通过`require(express)`引入包的过程: `./node_modules/express/package.js` -> `main` -> `./express.js` -> `module.exports`\r\n\r\n**使用npm安装第三方包后多出的文件夹和文件**\r\n* `node_modules/` 存放以安装的包, **require** 的搜索路径\r\n* `package-lock.json` 记录 **node_modules** 目录下每一个包的下载信息,包名,版本,下载地址.\r\n> 不要手动修改`node_modules/`和`package-lock.json`中的内容\r\n\r\n\r\n**包管理配置文件package.js**\r\n* 记录项目名称,版本,描述等\r\n* 记录项目中用到的其他包\r\n* 记录仅在开发期间用到的包\r\n* 记录仅在开发和部署期间用到的包\r\n> 该文件可通过`npm init -y` 命令生成  \r\n> 该文件中的 `dependencies` 项 会在执行 `npm install/uninstall packageName` 后更新  \r\n> 若省略包名,即执行 `npm install` 则会安装 `package.js` 中 `dependencies` 节点所记录的**所有包**\r\n\r\n**npm命令**\r\n* `npm init -y` 初始化当前项目\r\n* `npm install/uninstall pkgName` 安装/卸载包名\r\n* `npm install/uninstall pkgName@1.0.0` 安装/卸载包名\r\n  * `-g` 执行全局的操作\r\n  * `-D` `--save-dev` 所安装的包仅开发过程中使用到,记录到 `devDependencise` 节点中\r\n* `npm config set registry=https://registry.npmmirror.com/` 换源\r\n* `npm config get registry` 查看源设置情况\r\n* `npm login` 登陆npm帐号\r\n* `npm publish` 发布当前包\r\n* `npm unpublish  包名 --force` 删除发布的包\r\n  * 只能删除72小时以内发布的包\r\n  * 不能重新发布24小时内删除的包\r\n\r\n\r\n**版本号规范X.X.X**\r\n* 第一位数字 大版本,从底层重构\r\n* 第二位数字 功能版本,添加了新功能\r\n* 第三位数字 Bug修复版本,修复了Bug \r\n> 版本号提升规则: 某一位数字提升,该位之后的所有位归零\r\n\r\n\r\n\r\n**搜索包的官网**<br>\r\n搜索包:[npmjs.com](npmjs.com) <br>\r\n下载包:[registry.npmjs.org](registry.npmjs.org)\r\n\r\n\r\n**nrm工具**\r\n* 安装: `npm install nrm -g`\r\n* 查看可用镜像 nrm ls\r\n* 切换镜像 nrm use taobao\r\n\r\n\r\n\r\n\r\n\r\n## 内置模块\r\n\r\n\r\n### fs模块\r\n* `fs.readFile(path[,options],callback(err,data))` 读取指定文件,options默认为`utf-8`\r\n* `fs.writeFile(path,data[,options],callback(err))` 写入指定文件,options默认为`utf-8`\r\n  * 注意该函数只能创建文件不能创建文件夹\r\n  * 重复调用会覆盖上一次写入文件的内容\r\n\r\n**简单案例**\r\n```js\r\nconst fs = require(\"fs\")\r\n\r\nfs.readFile(\"./1.fs.js\",\"utf-8\",(err,data)=>{\r\n    if (err) {\r\n        console.log(err);\r\n    }else{\r\n        console.log(data);\r\n    }\r\n})\r\n\r\nfs.writeFile(\"./1.readfile.js\",\"这是写入的数据\",err=>{\r\n    if (err) {\r\n        console.log(err);\r\n    }\r\n})\r\n```\r\n\r\n**实际案例:数据格式化**\r\n```js\r\n/*\r\n将原数据:\r\n语文=100 数学=100 英语=100\r\n转换为: \r\n语文:100\r\n数学:100\r\n英语:100\r\n*/\r\n\r\nconst fs = require(\"fs\")\r\n\r\nfs.readFile(\"./src/成绩.txt\",\"utf-8\",(err,data)=>{\r\n    if (err) {\r\n        console.log(\"文件读取错误\" + err.message);\r\n    }else{\r\n        console.log(\"文件读取成功:\" + data);\r\n\r\n        var list = data.split(\" \")\r\n        var newList = []\r\n        var target = \"\"\r\n\r\n        console.log(\"处理数据中......\");\r\n        list.forEach((value,index)=>{\r\n            newList.push(value.replace(\"=\",\":\"))\r\n        })\r\n        target = newList.join(\"\\r\\n\")\r\n\r\n        console.log(\"处理数据完毕:\");\r\n        console.log(target);\r\n\r\n        console.log(\"写入数据中......\");\r\n        fs.writeFile(\"./src/成绩-output.txt\",target,err=>{\r\n            if (err) {\r\n                console.log(err);\r\n            }else{\r\n                console.log(\"写入完毕.\");\r\n            }\r\n        })\r\n    }\r\n})\r\n```\r\n\r\n\r\n**路径拼接的问题**<br>\r\n在使用相对路径读取文件时,`./`表示**当前目录**,在程序中,该**当前目录**默认为node命令执行时所在的目录,而不是程序文件所在的目录\r\n<br>\r\n**解决方案**\r\n* 使用 绝对路径\r\n* 使用字符串拼接 `__dirname` + 相对路径(不能带有 `./` 或 `../`)\r\n  * __dirname表示当前`.js`文件所在目录 \r\n  * 这种方式仍然存在一些问题\r\n\r\n\r\n### path路径模块\r\n* `path.join([...paths])` 用来将多个路径片段拼接成一个完整的路径字符串\r\n* `path.basename(/path/to/fileName.txt)` 用来获取路径中的`文件名.扩展名`\r\n* `path.extname(/path/to/fileName.txt)` 用来获取路径中的`.扩展名`\r\n\r\n**简单案例**\r\n```js\r\nconst path = require(\"path\")\r\n\r\nvar temp1 = path.join(\"/home\",\"/dyg\",\"./\",\"../\",\"/admin\",\"test.txt\")\r\nconsole.log(temp1);\r\n/*\r\n输出:\r\n/home/admin/test.txt\r\n*/\r\n\r\nvar temp2 = path.join(__dirname,\"test.txt\")\r\nconsole.log(temp2);\r\n/*\r\n输出:\r\n/mnt/D/GitProject/YiguiDing.github.ioV2/source/_posts/nodejs学习笔记/demos/test.txt\r\n*/\r\n```\r\n\r\n```js\r\nvar temp3 = path.basename(\"/path/to/fileName.txt\")\r\nconsole.log(temp3);\r\n/*\r\n输出:\r\nfileName.txt\r\n*/\r\n\r\nvar temp4 = path.basename(\"/path/to/fileName.12345\",\"345\")\r\nconsole.log(temp4);\r\n/*\r\n输出:\r\nfileName.12\r\n*/\r\n```\r\n\r\n\r\n```js\r\nvar temp5 = path.extname(\"/path/to/fileName.12345\")\r\nconsole.log(temp5);\r\n/*\r\n输出:\r\n.12345\r\n*/\r\n```\r\n\r\n**综合案例**\r\n```js\r\nconst fs = require(\"fs\")\r\nconst path = require(\"path\")\r\n\r\n\r\nfs.readFile(path.join(__dirname,\"./src/待拆分文件.html\"),\"utf-8\",(err,data)=>{\r\n    if(err){\r\n        console.log(err);\r\n    }else{\r\n        // console.log(data);\r\n        resolveCSS(data);\r\n        resolveJS(data);\r\n        resolveHTML(data);\r\n    }\r\n})\r\n\r\n\r\nfunction resolveCSS(html){\r\n    const reg = /<style>[\\s\\S]*<\\/style>/\r\n    var value = reg.exec(html)[0].replace(/<style>/g,\"\").replace(/<\\/style>/g,\"\")\r\n    // console.log(value);\r\n    fs.writeFile(path.join(__dirname,\"./src/index.css\"),value,err=>{\r\n        if(err)\r\n            console.log(\"resolveCSS failed:\"+err);\r\n        else\r\n            console.log(\"resolveCSS success\");\r\n    })\r\n}\r\n\r\nfunction resolveJS(html){\r\n    const reg = /<script>[\\s\\S]*<\\/script>/\r\n    var value = reg.exec(html)[0].replace(/<script>/g,\"\").replace(/<\\/script>/g,\"\")\r\n    // console.log(value);\r\n    fs.writeFile(path.join(__dirname,\"./src/index.js\"),value,err=>{\r\n        if(err)\r\n            console.log(\"resolveJS failed:\"+err);\r\n        else\r\n            console.log(\"resolveJS success\");\r\n    })\r\n    return value;\r\n}\r\n\r\nfunction resolveHTML(html){\r\n    var value = html\r\n    .replace(/<style>[\\s\\S]*<\\/style>/,\"\")\r\n    .replace(/<script>[\\s\\S]*<\\/script>/,\"\")\r\n    .replace(/<\\/title>/,`</title>\r\n        <link rel=\"stylesheet\" href=\"./index.css\" \\>\r\n        <script src=\"./index.js\"></script>\r\n    `)\r\n    fs.writeFile(path.join(__dirname,\"./src/index.html\"),value,err=>{\r\n        if(err)\r\n        console.log(\"resolveHTML failed:\"+err);\r\n        else\r\n        console.log(\"resolveHTML success:\"+value);\r\n    })\r\n}\r\n```\r\n**./src/待拆分文件.html**\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        #id_1{\r\n            width: 200px;\r\n            height: 100px;\r\n            background-color: skyblue;\r\n            color: red;\r\n        }\r\n    </style>\r\n        <style>\r\n            #id_2{\r\n                width: 200px;\r\n                height: 100px;\r\n                background-color: skyblue;\r\n                color: red;\r\n            }\r\n        </style>\r\n    <script>\r\n        console.log(\"this is js code\")\r\n    </script>\r\n</head>\r\n<body>\r\n    <div id=\"id_1\">\r\n        测试文字\r\n        测试文字\r\n        测试文字\r\n        测试文字\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n### http模块\r\n**request 的属性和方法**\r\n* `request.url` 如:`/`;`/index.html` \r\n* `request.method` 如 `GET` `POST`\r\n\r\n**response 的属性和方法**\r\n* `response.end(string)` 向客户端响应内容\r\n* `response.setHeader(\"key\",\"value\")` 设置响应头\r\n  * 防止中文乱码`response.setHeader(\"Content-Type\",\"text/url;charset=utf-8\")`\r\n\r\n\r\n**简易案例**\r\n```js\r\n//导入http模块\r\nconst http = require(\"http\")\r\n\r\n//创建实例对象\r\nconst server = http.createServer()\r\n\r\n//绑定request事件\r\nserver.on(\"request\",(req,res)=>{\r\n    console.log(\"收到了一个http请求...\");\r\n})\r\n\r\n//启动服务\r\nserver.listen(8000,()=>{\r\n    console.log(\"服务器已启动,正在监听8000端口...\");\r\n})\r\n```\r\n**简易动态响应(路由)的实现**\r\n```js\r\n//导入http模块\r\nconst http = require(\"http\")\r\n\r\n//创建实例对象\r\nconst server = http.createServer()\r\n\r\n//绑定request事件\r\nserver.on(\"request\",(req,res)=>{\r\n    const url = req.url\r\n    let content = `<h1>404</h1>`\r\n    \r\n    if(url===\"/\" || url===\"/index\" || url===\"/index.html\"){\r\n        content = `<h1>index</h1>`\r\n    }else\r\n    if(url===\"/about\" ||  url===\"/about.html\"){\r\n        content = `<h1>about</h1>`\r\n    }\r\n\r\n    res.setHeader(\"Content-Type\",\"text/html;charset=utf-8\")\r\n    res.end(content)\r\n})\r\n\r\n//启动服务\r\nserver.listen(8000,()=>{\r\n    console.log(\"服务器已启动,正在监听8000端口...\");\r\n})\r\n```\r\n\r\n**实现简易Web服务器**\r\n```js\r\n//导入http模块\r\nconst fs = require(\"fs\")\r\nconst path = require(\"path\")\r\nconst http = require(\"http\")\r\n\r\n//创建实例对象\r\nconst server = http.createServer()\r\n\r\n//绑定request事件\r\nserver.on(\"request\",(req,res)=>{\r\n    const rootUrl = \"./src\"\r\n    let url = req.url\r\n    let content = `<h1>404</h1>`\r\n    \r\n    if(url===\"/\" || url===\"/index\" || url===\"/index.html\"){\r\n        url=`/index.html`\r\n    }\r\n\r\n    fs.readFile(path.join(__dirname,rootUrl,url),\"utf-8\",(err,data)=>{\r\n        if(err) {\r\n            // content = err.message\r\n        }\r\n        else {\r\n            content = data\r\n        }\r\n        // res.setHeader(\"Content-Type\",\"text/html;charset=utf-8\") //text/html会导致浏览器无法识别css代码\r\n        res.end(content)\r\n    })\r\n})\r\n\r\n//启动服务\r\nserver.listen(8000,()=>{\r\n    console.log(\"服务器已启动,http://127.0.0.1:8000/\");\r\n})\r\n```\r\n\r\n\r\n\r\n## 尝试自定义模块\r\n**目录结构**\r\n* 自定义模块根目录\r\n  * index.js\r\n  * package.json\r\n  * README.md\r\n* test.js\r\n\r\n\r\n\r\n\r\n**index.js**\r\n```js\r\n// 实现html转义\r\nfunction htmlEncode(content){//编码\r\n    return content.replace(/<|>|\"|&/g,march=>{\r\n        switch(march){\r\n            case '<':\r\n                return '&lt;';\r\n            case '>':\r\n                return '&gt;';\r\n            case '\"':\r\n                return '&quot;';\r\n            case '&':\r\n                return \"&amp;\";\r\n         }\r\n    })\r\n}\r\nfunction htmlDecode(content){//解码\r\n    return content.replace(/&lt;|&gt;|&quot;|&amp;/g,march=>{\r\n        switch(march){\r\n            case '&lt;':\r\n                return '<';\r\n            case '&gt;':\r\n                return '>';\r\n            case '&quot;':\r\n                return '\"';\r\n            case '&amp;':\r\n                return \"&\";\r\n         }\r\n    })\r\n}\r\nmodule.exports.htmlEncode = htmlEncode\r\nmodule.exports.htmlDecode = htmlDecode\r\n```\r\n\r\n**package.json**\r\n```json\r\n{\r\n  \"name\": \"demo-test\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"描述\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\"\r\n}\r\n\r\n```\r\n\r\n**test.js**\r\n```js\r\nconst test = require(\"./6.自定义模块\")\r\n\r\nvar html = `<h1 style=\"color:skyblue\">测试</h1>`\r\nvar encode = test.htmlEncode(html)\r\nvar decode = test.htmlDecode(encode)\r\n\r\nconsole.log(encode);\r\nconsole.log(decode);\r\n```\r\n\r\n\r\n## 第三方模块\r\n\r\n**为什么需要第三方包?**<br>\r\nnodejs内置模块仅提供了底层API,使用内置模块开发效率低,<br>\r\n第三方模块是基于内置模块开发的,提供了更高级更方便的API,提高了开发效率\r\n\r\n\r\n\r\n### moment.js 三方模块\r\n```js\r\nconst moment = require(\"moment\")\r\n\r\nvar tm = moment().format(\"YYYY-MM-DD HH-mm-ss\")\r\nconsole.log(tm);\r\n```\r\n\r\n### i5ting_toc 第三方模块\r\n(用处不大)<br>\r\ni5ting_toc 是md转html的命令行工具,需全局安装<br>\r\n**使用**\r\n```\r\ni5ting_toc -f ./fileName.md -o \r\n```\r\n\r\n\r\n### express模块\r\n<red>详细笔记:[express学习笔记]()</red>  \r\nexpress作用和nodejs的http模块类似,用于创建web服务器<br>\r\nexpress是基于http模块封装的,使用起来比http模块简单,效率更高\r\n\r\n\r\n<style>\r\n    red{\r\n        color:red;\r\n    }\r\n    sky{\r\n        color:skyblue;\r\n    }\r\n    \r\n</style>"}