{"shortInfo":{"title":"wite构建工具学习","date":"2022-11-28T12:00:00.000Z","cover":"\\self_server\\assets\\images\\vite构建工具学习\\2022-12-04-01-30-16.png","tags":["笔记"],"categories":"笔记","hideAtIndex":true,"id":4170453952,"countWords":1882,"readSeconds":188.2,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/vite构建工具学习/2022-12-04-01-30-16.png) -->\r\n\r\n# wite构建工具学习\r\n## 目录\r\n- [wite构建工具学习](#wite构建工具学习)\r\n  - [目录](#目录)\r\n  - [脚手架`create-vite`与构建工具`vite`的区别](#脚手架create-vite与构建工具vite的区别)\r\n  - [配置文件`vite.config.js`](#配置文件viteconfigjs)\r\n    - [指定配置文件](#指定配置文件)\r\n    - [编写配置文件](#编写配置文件)\r\n    - [使配置文件支持语法提示](#使配置文件支持语法提示)\r\n  - [选项式配置vite](#选项式配置vite)\r\n  - [环境变量](#环境变量)\r\n    - [`.env`文件](#env文件)\r\n    - [`mode`模式](#mode模式)\r\n    - [正确的使用](#正确的使用)\r\n    - [`实际的dotenv`与`vite中的dotenv`](#实际的dotenv与vite中的dotenv)\r\n\r\n\r\n## 脚手架`create-vite`与构建工具`vite`的区别\r\n\r\n> 简单来说，脚手架就是一个模板，是一个写好的HelloWorld项目，该项目使用vite构建，有基本的约定俗成目录结构和一些基本的vite配置\r\n\r\n**安装脚手架，并通过脚手架创建项目**\r\n```bash\r\nyarn create vite \r\nnpm create vite\r\n# 帮我们全局安装一个东西: create-vite (vite的脚手架)\r\n# 直接运行这个create-vite bin目录的下的一个执行配置\r\n```\r\n\r\n**安装构建工具**\r\n```bash\r\nnpm install vite -D # 在开发环境安装vite\r\n```\r\n\r\n## 配置文件`vite.config.js`\r\n\r\n### 指定配置文件\r\n```bash\r\n# 通过--config指定vite配置文件的文件名\r\nvite --config custom-config.js\r\n\r\n# 默认配置文件为执行该命令目录下的vite.config.js\r\nvite\r\n```\r\n\r\n### 编写配置文件\r\n```js\r\n// vite.config.js\r\nexport default {\r\n  // 配置选项，直接默认导出一个配置对象即可\r\n}\r\n```\r\n\r\n### 使配置文件支持语法提示\r\n\r\n方法一：通过`jsdoc`注释配合`IDE`完成\r\n\r\n原理：`UserConfig`是用`typeScript`定义的接口类,包含了支持的各个字段的名称和类型信息\r\n```js\r\n/** @type {import('vite').UserConfig} */\r\nexport default {\r\n  // ...\r\n}\r\n```\r\n\r\n方法二：使用 `defineConfig` 工具函数\r\n原理：`defineConfig` 函数接收一个对象并返回这个对象本身，接收的对象类型是`UserConfigExport = UserConfig` 而`UserConfig`是在`ts`中定义的接口对象\r\n```js\r\n\r\nimport { defineConfig } from 'vite'\r\n\r\nexport default defineConfig({\r\n  // ...\r\n})\r\n```\r\n\r\n## 选项式配置vite\r\n> 根据不同的环境配置vite,\r\n> * 如希望在开发环境启用sourceMap,用于方便定位报错所在行数，在生产环境关闭sorceMap\r\n> * 如希望在开发环境开启代理服务器，访问本地服务器，而在生产环境则不用这样的配置\r\n\r\n**三个配置文件（文件名任意）**\r\n* `vite.base.config` 基本环境vite配置\r\n* `vite.dev.config`  开发环境vite配置\r\n* `vite.prod.config` 生产环境vite配置\r\n* `vite.config` 用于根据环境启用上述三个配置文件\r\n\r\n**编写配置文件**  \r\n`vite.base.config.js`  \r\n`vite.dev.config.js`  \r\n`vite.prod.config.js`  \r\n```js\r\nimport { defineConfig } from 'vite'\r\n\r\nexport default defineConfig({\r\n  // ... 正常写的配置文件\r\n})\r\n```\r\n\r\n`vite.config.js`\r\n```js\r\nimport {defineConfig} from \"vite\";\r\nimport viteBaseConfig from \"./vite.base.config\";// 基本环境vite配置\r\nimport viteDevConfig  from \"./vite.dev.config\"; // 开发环境vite配置\r\nimport viteProdConfig from \"./vite.prod.config\";// 生产环境vite配置\r\n\r\n// 策略模式\r\nconst envResolver = {\r\n    \"build\":{ ...viteBaseConfig, ...viteProdConfig }, // 对象式写法,覆盖base中的配置\r\n    \"serve\":{ ...viteBaseConfig, ...viteProdConfig },\r\n    // \"build\": () => {\r\n    //     console.log(\"当前在生产环境\");\r\n    //     return ({ ...viteBaseConfig, ...viteProdConfig }) // 函数式写法，返回对象\r\n    // },\r\n}\r\nexport default defineConfig(({ command, mode }) => {\r\n    // 当执行命名： vite 或 vite dev 或 vite serve 时 command 的值为 serve\r\n    // 当执行命名： vite build 时 command的值为 build\r\n    // 根据源码，command只有两种可能的取值: 'build' | 'serve';\r\n    return envResolver[command];\r\n})\r\n```\r\n\r\n> 为什么可以传递一个函数到defineConfig？   \r\n> 根据下列源码可知， `defineConfig` 可以接收一个函数，该函数会接收三个参数： `command` `mode` `ssrBuild`\r\n```ts\r\nexport declare function defineConfig(config: UserConfigExport): UserConfigExport;\r\nexport declare type UserConfigExport = UserConfig | Promise<UserConfig> | UserConfigFn;\r\nexport declare type UserConfigFn = (env: ConfigEnv) => UserConfig | Promise<UserConfig>;\r\nexport declare interface ConfigEnv {\r\n    command: 'build' | 'serve';\r\n    mode: string;\r\n    ssrBuild?: boolean; // 实验性功能\r\n}\r\n```\r\n\r\n\r\n## 环境变量\r\n这里的`环境`变量是指\r\n1. 开发环境\r\n2. 测试环境\r\n3. 预发布环境\r\n4. 灰度环境\r\n5. 生产环境\r\n\r\n> 不同的`环境`需要用到不同的`变量`,  \r\n> 如在写axios的baseURL时，开发环境填写的地址和生产环境填写的地址是不一样的\r\n\r\n\r\n### `.env`文件\r\n默认情况下，Vite 使用 第三方插件`dotenv` 将项目根目录下的下列文件中定义的环境变量，挂载到`import.meta.env`上\r\n```bash\r\n.env                # 所有情况下都会加载\r\n.env.local          # 所有情况下都会加载，但会被 git 忽略（因为脚手架自带的.gitignore文件中有配置）\r\n.env.[mode]         # 只在指定模式下加载\r\n.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略，存一些敏感信息，如数据库密码\r\n```\r\n\r\n### `mode`模式\r\n```bash\r\n# serve和build的默认模式分别为development和production：\r\nvite serve --mode development\r\nvite build --mode production\r\n```\r\n\r\n### 正确的使用\r\n```js\r\nvar env = import.meta.env // import.meta.env将被替换成一个{key:value}的字面量对象\r\nvar baseUrl = env.baseUrl // 正确使用\r\n\r\n// 错误使用,在生产环境中，这些环境变量会在构建时被静态替换\r\nvar baseUrl = import.meta.env['baseUrl']\r\n```\r\n\r\n### `实际的dotenv`与`vite中的dotenv`\r\n\r\n**`实际的dotenv`的执行过程**\r\n\r\ndotenv会自动读取`.env`文件, 解析这个文件中的对应环境变量，并将其注入到`process`对象下\r\n```js\r\nimport {resolve} from 'path'\r\nvar dotenv = require('dotenv') \r\ndotenv.config()\r\nconsole.log(process.env);\r\n```\r\n\r\n\r\n**`vite中的dotenv`的执行过程**\r\n* 但在vite项目中，`dotenv`解析到的环境变量不会直接注入到`process.env`对象下 \r\n* 因为在网页中根本无法访问到`process`这个变量，\r\n* 所以他实际是注入到`import.meta.env`变量上，在生产环境，该变量会被替换为对象字面量\r\n* 在注入的过程中，vite默认还会做一次拦截，如果你的环境变量不是以`VITE`开头的, 他就不会帮你注入到客户端中去\r\n* vite给我们提供了一些补偿措施:我们可以调用`vite`的`loadEnv`来手动确认`env`文件\r\n\r\n\r\n手动加载`.env`\r\n```js\r\nimport {defineConfig} from \"vite\";\r\nimport viteBaseConfig from \"./vite.base.config\";\r\nimport viteDevConfig  from \"./vite.dev.config\";\r\nimport viteProdConfig from \"./vite.prod.config\";\r\n\r\n// 策略模式\r\nconst envResolver = {\r\n    \"build\":{ ...viteBaseConfig, ...viteProdConfig },\r\n    \"serve\":{ ...viteBaseConfig, ...viteProdConfig },\r\n}\r\nexport default defineConfig(({ command, mode }) => {\r\n    // 手动加载环境变量,\r\n        //参数一用来确定加载哪一个文件\r\n        //参数二相当于配置 envDir \r\n        //参数三相当于配置 envPrefix\r\n  var envs = loadEnv(mode,process.cwd(),\"Public_\");\r\n    return envResolver[command];\r\n})\r\n```\r\n\r\n通过配置`vite`自动加载`.env`\r\n```js\r\n/**\r\n * @type {import 'vite'.UserConfig}\r\n */\r\nexport default defineConfig({\r\n    // 环境变量配置文件所在目录,默认值为'./'\r\n    envDir:\"./\", \r\n    \r\n    // 指定仅当以下划线开头的环境变量才会暴露到客户端 默认为VITE\r\n    envPrefix:\"_\"\r\n  })\r\n```\r\n\r\n\r\n**几个环境变量文件**\r\n* `.env`: 所有环境都需要用到的环境变量\r\n* `.env.development`: 开发环境需要用到的环境变量(默认情况下vite将我们的开发环境取名为development)\r\n* `.env.production`: 生产环境需要用到的环境变量(默认情况下vite将我们的生产环境取名为production)\r\n\r\n**`loadenv`执行过程**\r\n当我们调用`loadenv`的时候, 他会做如下几件事:\r\n1. 直接找到`.env`文件不解释 并解析其中的环境变量 并放进一个对象里\r\n2. 会将传进来的mode这个变量的值进行拼接: ```.env.development```,  并根据我们提供的目录去取对应的配置文件并进行解析, 并放进一个对象\r\n3. 我们可以理解为\r\n   ```js\r\n    const baseEnvConfig = 读取.env的配置\r\n    const modeEnvConfig = 读取env相关配置\r\n    const lastEnvConfig = { ...baseEnvConfig, ...modeEnvConfig }\r\n   ```\r\n\r\n\r\n\r\n\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>"}