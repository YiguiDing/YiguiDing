{"shortInfo":{"title":"js游戏制作学习笔记","date":"2023-01-10T05:57:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["笔记"],"categories":"笔记","id":127855843,"countWords":3364,"readSeconds":336.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 1. js 2D游戏制作学习笔记\r\n\r\n## 1.1. 地址： [ShadowDog 试玩版本：0.0.1](./demo/index.html)\r\n\r\n\r\n## 1.2. 目录\r\n\r\n- [1. js 2D游戏制作学习笔记](#1-js-2d游戏制作学习笔记)\r\n\t- [1.1. 地址： ShadowDog 试玩版本：0.0.1](#11-地址-shadowdog-试玩版本001)\r\n\t- [1.2. 目录](#12-目录)\r\n\t- [1.3. Canvas 绘图基本步骤](#13-canvas-绘图基本步骤)\r\n\t\t- [1.3.1. 原理](#131-原理)\r\n\t\t- [1.3.2. 优化及渲染所有动图](#132-优化及渲染所有动图)\r\n\t\t- [1.3.3. 封装和抽象](#133-封装和抽象)\r\n\t\t- [1.3.3.1. 对动画对象 Animater 的封装](#1331-对动画对象-animater-的封装)\r\n\t\t- [1.3.4. 继续定义一些列接口并定义 Animal 类](#134-继续定义一些列接口并定义-animal-类)\r\n\t\t- [1.3.5. 使用](#135-使用)\r\n\t- [1.4. 视差背景原理](#14-视差背景原理)\r\n\t\t- [1.4.1. 无限滚动的背景原理](#141-无限滚动的背景原理)\r\n\t\t- [1.4.2. 视差背景的实现](#142-视差背景的实现)\r\n\t\t- [1.4.3. 最终的抽象、封装、实现、和使用](#143-最终的抽象封装实现和使用)\r\n\t\t\t- [1.4.3.1. 抽象、封装、实现](#1431-抽象封装实现)\r\n\t\t\t- [1.4.3.2. 使用](#1432-使用)\r\n\r\n\r\n## 1.3. Canvas 绘图基本步骤\r\n\r\n### 1.3.1. 原理\r\n\r\n[原理.index](./practices/1.canvas%EF%BC%9A%E5%8E%9F%E7%90%86/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\n// 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 600);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 600);\r\n\r\n// 单帧宽高\r\nconst Sprite_WIDTH = 575;\r\nconst Sprite_HEIGHT = 523;\r\n\r\nconst imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./shadow_dog.png\";\r\n\r\nlet frameX = 0;\r\nlet frameY = 0;\r\nlet frameCount = 0; // 第几帧\r\nlet stageFrame = 5; // 交错帧，每隔5帧 切换图片\r\n\r\nfunction animate() {\r\n  // 计算当前要绘制的帧的index\r\n  frameCount = ++frameCount % stageFrame;\r\n  if (!frameCount) frameX = ++frameX % 7;\r\n\r\n  //清除上一次绘图痕迹\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer, // img\r\n    frameX * Sprite_WIDTH, //源坐标x\r\n    frameY * Sprite_HEIGHT, //源坐标y\r\n    Sprite_WIDTH, //源图像宽\r\n    Sprite_HEIGHT, //源图像高\r\n    0, // 目的坐标x\r\n    0, // 目的坐标y\r\n    CANVAS_WIDTH, // 绘制宽度w\r\n    CANVAS_HEIGHT // 绘制高度h\r\n  );\r\n  // requestAnimationFrame原理上相当于60fps的setInterval\r\n  requestAnimationFrame(animate);\r\n}\r\nanimate();\r\n```\r\n\r\n### 1.3.2. 优化及渲染所有动图\r\n\r\n[优化.html](./practices/2.animate：优化/index.html)\r\n\r\n<canvas id=\"myCanvas_2j0923ru48\"></canvas>\r\n\r\n<div class=\"animation-box\">\r\n\t<label for=\"animations\">select animation:</label>\r\n\t<select name=\"\" id=\"animations_djf9498\">\r\n\t\t<option value=\"idle\">idle</option>\r\n\t\t<option value=\"jump\">jump</option>\r\n\t\t<option value=\"fall\">fall</option>\r\n\t\t<option value=\"run\">run</option>\r\n\t\t<option value=\"dizzy\">dizzy</option>\r\n\t\t<option value=\"sit\">sit</option>\r\n\t\t<option value=\"roll\">roll</option>\r\n\t\t<option value=\"bite\">bite</option>\r\n\t\t<option value=\"ko\">ko</option>\r\n\t\t<option value=\"gethit\">gethit</option>\r\n\t</select>\r\n</div>\r\n<img src=\"./images/shadow_dog.png\">\r\n<script>\r\nvar myCanvas = document.querySelector(\"#myCanvas_2j0923ru48\");\r\nvar ctx = myCanvas.getContext(\"2d\"); // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n// canvas的默认大小为300x150px 需手动修改\r\nvar CANVAS_WIDTH = (myCanvas.width = 250);\r\nvar CANVAS_HEIGHT = (myCanvas.height = 250);\r\nvar Sprite_WIDTH = 575;\r\nvar Sprite_HEIGHT = 523;\r\nvar imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./images/shadow_dog.png\";\r\nvar playerState = \"idle\";\r\nvar selector = document.querySelector(\"#animations_djf9498\");\r\nselector.addEventListener(\"change\", function () {\r\n  playerState = selector.value;\r\n});\r\nvar animations = {\r\n  idle: { rows: 0,  cols: 7},\r\n  jump: { rows: 1,  cols: 7}, \r\n  fall: { rows: 2,  cols: 7}, \r\n  run: {  rows: 3,  cols: 9}, \r\n  dizzy:{ rows: 4,  cols: 11},\r\n  sit: {  rows: 5,  cols: 5}, \r\n  roll: { rows: 6,  cols: 7}, \r\n  bite:{  rows: 7,  cols: 7}, \r\n  ko: {   rows: 8,  cols: 12},\r\n  gethit:{rows: 9,  cols: 4,  }\r\n};\r\nvar animaIndex = 0; // 动画索引\r\nvar frameIndex = 0; // 帧索引\r\nvar frameCount = 0; // 总的帧数\r\nvar stageFrame = 5; // 交错帧，每隔5帧 切换关键帧\r\nfunction animate() {\r\n  frameIndex =\r\n    Math.floor(frameCount++ / stageFrame) % animations[playerState].cols;\r\n  animaIndex = animations[playerState].rows;\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer,\r\n    frameIndex * Sprite_WIDTH,\r\n    animaIndex * Sprite_HEIGHT,\r\n    Sprite_WIDTH,\r\n    Sprite_HEIGHT,\r\n    0,\r\n    0,\r\n    CANVAS_WIDTH,\r\n    CANVAS_HEIGHT\r\n  );\r\n  // requestAnimationFrame效果上相当于60fps的setInterval\r\n  requestAnimationFrame(animate); \r\n}\r\nanimate();\r\n</script>\r\n\r\n```html\r\n<canvas id=\"myCanvas_2j0923ru48\"></canvas>\r\n\r\n<div class=\"animation-box\">\r\n\t<label for=\"animations\">select animation:</label>\r\n\t<select name=\"\" id=\"animations_djf9498\">\r\n\t\t<option value=\"idle\">idle</option>\r\n\t\t<option value=\"jump\">jump</option>\r\n\t\t<option value=\"fall\">fall</option>\r\n\t\t<option value=\"run\">run</option>\r\n\t\t<option value=\"dizzy\">dizzy</option>\r\n\t\t<option value=\"sit\">sit</option>\r\n\t\t<option value=\"roll\">roll</option>\r\n\t\t<option value=\"bite\">bite</option>\r\n\t\t<option value=\"ko\">ko</option>\r\n\t\t<option value=\"gethit\">gethit</option>\r\n\t</select>\r\n</div>\r\n<img src=\"./images/shadow_dog.png\">\r\n<script>\r\nvar myCanvas = document.querySelector(\"#myCanvas_2j0923ru48\");\r\nvar ctx = myCanvas.getContext(\"2d\"); // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n// canvas的默认大小为300x150px 需手动修改\r\nvar CANVAS_WIDTH = (myCanvas.width = 250);\r\nvar CANVAS_HEIGHT = (myCanvas.height = 250);\r\nvar Sprite_WIDTH = 575;\r\nvar Sprite_HEIGHT = 523;\r\nvar imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./images/shadow_dog.png\";\r\nvar playerState = \"idle\";\r\nvar selector = document.querySelector(\"#animations_djf9498\");\r\nselector.addEventListener(\"change\", function () {\r\n  playerState = selector.value;\r\n});\r\nvar animations = {\r\n  idle: { rows: 0,  cols: 7},\r\n  jump: { rows: 1,  cols: 7},\r\n  fall: { rows: 2,  cols: 7},\r\n  run: {  rows: 3,  cols: 9},\r\n  dizzy:{ rows: 4,  cols: 11},\r\n  sit: {  rows: 5,  cols: 5},\r\n  roll: { rows: 6,  cols: 7},\r\n  bite:{  rows: 7,  cols: 7},\r\n  ko: {   rows: 8,  cols: 12},\r\n  gethit:{rows: 9,  cols: 4,  }\r\n};\r\nvar animaIndex = 0; // 动画索引\r\nvar frameIndex = 0; // 帧索引\r\nvar frameCount = 0; // 总的帧数\r\nvar stageFrame = 5; // 交错帧，每隔5帧 切换关键帧\r\nfunction animate() {\r\n  frameIndex =\r\n    Math.floor(frameCount++ / stageFrame) % animations[playerState].cols;\r\n  animaIndex = animations[playerState].rows;\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer,\r\n    frameIndex * Sprite_WIDTH,\r\n    animaIndex * Sprite_HEIGHT,\r\n    Sprite_WIDTH,\r\n    Sprite_HEIGHT,\r\n    0,\r\n    0,\r\n    CANVAS_WIDTH,\r\n    CANVAS_HEIGHT\r\n  );\r\n  // requestAnimationFrame效果上相当于60fps的setInterval\r\n  requestAnimationFrame(animate);\r\n}\r\nanimate();\r\n```\r\n\r\n### 1.3.3. 封装和抽象\r\n\r\n### 1.3.3.1. 对动画对象 Animater 的封装\r\n\r\n```ts\r\nimport { RandomRange } from \"./utils.js\";\r\n// 动画对象\r\nexport class Animater {\r\n  posX = 0; // 位置x\r\n  posY = 0; // 位置y\r\n  drawWidth: number; // 实际绘制的宽度\r\n  drawHeight: number; // 实际绘制的高度\r\n  img: HTMLImageElement; // 图片\r\n  imgFrameWidth: number; // 一帧的宽度\r\n  imgFrameHeight: number; // 一帧的高度\r\n  animateFramesTotal: Array<number>; // [动画1的总帧数,动画2的总帧数,动画3的...]\r\n  animateNameIndexMap: Array<string>; // 数据结构：{动画名称:该动画是第几个动画}\r\n  animateFrameIndexX = 0; // 当前绘制的是第几帧\r\n  animateFrameIndexY = 0; // 当前绘制的是第几个动画\r\n  animateFrameTimer = 0;\r\n  private _animateFrameFps = 60;\r\n  private animateFrameChangeInterval = 1000 / 60;\r\n  private get animateFrameFps() {\r\n    return this._animateFrameFps;\r\n  }\r\n  private set animateFrameFps(fps) {\r\n    this._animateFrameFps = fps;\r\n    this.animateFrameChangeInterval = 1000 / fps;\r\n  }\r\n  public setFps(fps: number) {\r\n    this.animateFrameFps = fps;\r\n  }\r\n  stopAnimateAtLastFlag = false;\r\n  RewindAnimateFrameFlag = false;\r\n  constructor(\r\n    imgSrc: string,\r\n    imgFrameWidth: number,\r\n    imgFrameHeight: number,\r\n    size: number,\r\n    animateFramesTotal: Array<number>,\r\n    animateNameIndexMap: Array<string>\r\n  ) {\r\n    this.img = new Image();\r\n    this.img.src = imgSrc;\r\n    this.animateFramesTotal = animateFramesTotal;\r\n    this.animateNameIndexMap = animateNameIndexMap;\r\n    this.imgFrameWidth = imgFrameWidth;\r\n    this.imgFrameHeight = imgFrameHeight;\r\n    this.drawWidth = this.imgFrameWidth * size;\r\n    this.drawHeight = this.imgFrameHeight * size;\r\n    this.setFps(60);\r\n  }\r\n  // 更新数据\r\n  update(timeInterval: number): void {\r\n    // 最后一帧则停止切换帧\r\n    if (this.stopAnimateAtLastFlag == true && this.isLastAnimateFrame()) return;\r\n    // 计算下一帧\r\n    if (this.animateFrameTimer >= this.animateFrameChangeInterval) {\r\n      this.animateFrameTimer = 0;\r\n      this.animateFrameIndexX += 1;\r\n      this.animateFrameIndexX %=\r\n        this.animateFramesTotal[this.animateFrameIndexY];\r\n    } else this.animateFrameTimer += timeInterval;\r\n  }\r\n  // 绘制帧\r\n  draw(Context2D: CanvasRenderingContext2D): void {\r\n    Context2D.drawImage(\r\n      this.img,\r\n      this.animateFrameIndexX * this.imgFrameWidth,\r\n      this.animateFrameIndexY * this.imgFrameHeight,\r\n      this.imgFrameWidth,\r\n      this.imgFrameHeight,\r\n      this.posX,\r\n      this.posY,\r\n      this.drawWidth,\r\n      this.drawHeight\r\n    );\r\n  }\r\n  changeAnimateByName(animateName: string) {\r\n    // 根据名称切换动画\r\n    if (this.animateNameIndexMap.includes(animateName))\r\n      this.animateFrameIndexY = this.animateNameIndexMap.indexOf(animateName);\r\n    else throw new Error(`animateName:'${animateName}' is not exist.`);\r\n    this.init();\r\n  }\r\n  // 判断是否为最后一帧\r\n  isLastAnimateFrame() {\r\n    return (\r\n      this.animateFrameIndexX ==\r\n      this.animateFramesTotal[this.animateFrameIndexY] - 1\r\n    );\r\n  }\r\n  // 判断是否为第一帧\r\n  isFirstAnimateFrame() {\r\n    return this.animateFrameIndexX == 0;\r\n  }\r\n  // 初始化状态\r\n  init() {\r\n    this.animateFrameIndexX = 0; // 设置从第一帧开始\r\n  }\r\n  // 请求在渲染到最后一帧的时候停止更新动画\r\n  requestStopAnimateFrameAtLastFrame() {\r\n    this.stopAnimateAtLastFlag = true;\r\n  }\r\n  isOutOfLeftScreem() {\r\n    return this.posX + this.drawWidth < 0;\r\n  }\r\n}\r\n```\r\n\r\n### 1.3.4. 继续定义一些列接口并定义 Animal 类\r\n\r\n```ts\r\nimport { Animater } from \"./Animater.js\";\r\nimport { transformAble } from \"./transformAble.js\";\r\n\r\n// 可移动的\r\ninterface MoveAble {\r\n  moveSpeedX: number; // x轴移动速度 单位：像素/毫秒\r\n  moveSpeedY: number; // x轴移动速度 单位：像素/毫秒\r\n  move(timeInterval: number): void; // 移动\r\n}\r\n// 活的\r\ninterface AliveAble {\r\n  aliveFlag: boolean;\r\n  getAliveFlag(): boolean; // 用于判断是否存活\r\n  setAliveFlag(newVal: boolean): void;\r\n}\r\n// 圆形碰撞检测\r\ninterface CollisionCheckAble {\r\n  collisionCheckPosX: number;\r\n  collisionCheckPosY: number;\r\n  collisionCheckWidth: number;\r\n  collisionCheckHeight: number;\r\n  collisionCheckRadius: number;\r\n  collisionCheckUpdate(): void;\r\n  isCollision(obj: CollisionCheckAble): boolean; // 碰撞检测\r\n}\r\ninterface NameAble {\r\n  Name: string;\r\n  getName(): string;\r\n}\r\n\r\n// 抽象类 Animal 继承动画类 实现Moveable AliveAble 接口\r\nexport abstract class Animal\r\n  extends Animater\r\n  implements MoveAble, AliveAble, CollisionCheckAble, NameAble, transformAble\r\n{\r\n  // 移动\r\n  moveSpeedX = 0;\r\n  moveSpeedY = 0;\r\n  abstract move(timeInterval: number): void;\r\n  // 存活\r\n  aliveFlag = true;\r\n  setAliveFlag(newVal: boolean): void {\r\n    this.aliveFlag = newVal;\r\n  }\r\n  getAliveFlag(): boolean {\r\n    return this.aliveFlag;\r\n  }\r\n  // 可碰撞检测\r\n  collisionCheckPosX = 0;\r\n  collisionCheckPosY = 0;\r\n  collisionCheckWidth = 0;\r\n  collisionCheckHeight = 0;\r\n  collisionCheckRadius = 0;\r\n  collisionCheckUpdate(): void {\r\n    // 圆形碰撞检测\r\n    this.collisionCheckPosX = this.posX + this.drawWidth / 2;\r\n    this.collisionCheckPosY = this.posY + this.drawHeight / 2;\r\n    this.collisionCheckRadius =\r\n      (Math.min(this.drawWidth, this.drawHeight) / 2) * 0.8;\r\n  }\r\n  isCollision(obj: CollisionCheckAble): boolean {\r\n    this.collisionCheckUpdate();\r\n    obj.collisionCheckUpdate();\r\n    const dX = this.collisionCheckPosX - obj.collisionCheckPosX;\r\n    const dY = this.collisionCheckPosY - obj.collisionCheckPosY;\r\n    const distance = Math.sqrt(dX * dX + dY * dY);\r\n    return distance < this.collisionCheckRadius + obj.collisionCheckRadius;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.collisionCheckUpdate();\r\n    super.update(timeInterval);\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D): void {\r\n    // Context2D.beginPath();\r\n    // Context2D.arc(this.collisionCheckPosX, this.collisionCheckPosY, this.collisionCheckRadius, 0, Math.PI * 2);\r\n    // Context2D.stroke();\r\n    // Context2D.strokeRect(this.posX, this.posY, this.drawWidth, this.drawHeight);\r\n    super.draw(Context2D);\r\n  }\r\n  // put it on ground();\r\n  setOnGround(groundPosY: number): Animal {\r\n    this.posY = groundPosY - this.drawHeight;\r\n    return this;\r\n  }\r\n  // 水平和垂直平移\r\n  transform(stepX: number, stepY: number) {\r\n    this.posX += stepX;\r\n    this.posY += stepY;\r\n  }\r\n  abstract Name: string;\r\n  getName(): string {\r\n    this.Name;\r\n    return this.Name;\r\n  }\r\n}\r\n```\r\n\r\n### 1.3.5. 使用\r\n\r\n于是，定义一个游戏角色：蠕虫，就会变得如此简单\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Worm extends Animal {\r\n  Name = \"Worm\";\r\n  constructor(posX: number, posY: number) {\r\n    super(\"./imgs/Worm.png\", 229, 171, 0.5, [6], [\"idle\"]);\r\n    this.posX = posX;\r\n    this.posY = posY;\r\n    this.moveSpeedX = RandomRange(0.05, 0.1);\r\n  }\r\n  move(timeInterval: number) {\r\n    this.posX -= this.moveSpeedX * timeInterval;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.move(timeInterval);\r\n    super.update(timeInterval);\r\n  }\r\n}\r\n```\r\n\r\n## 1.4. 视差背景原理\r\n\r\n### 1.4.1. 无限滚动的背景原理\r\n\r\n[](./practices/3.%E8%A7%86%E5%B7%AE%E8%83%8C%E6%99%AF%EF%BC%9A%E5%8E%9F%E7%90%86/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\n// 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 800);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 700);\r\n\r\nlet gameScrollSpeed = 10;\r\n\r\n// 层\r\nconst backgroundLayer1 = new Image();\r\nbackgroundLayer1.src = \"./imgs/layer-1.png\";\r\nconst backgroundLayer2 = new Image();\r\nbackgroundLayer2.src = \"./imgs/layer-2.png\";\r\nconst backgroundLayer3 = new Image();\r\nbackgroundLayer3.src = \"./imgs/layer-3.png\";\r\nconst backgroundLayer4 = new Image();\r\nbackgroundLayer4.src = \"./imgs/layer-4.png\";\r\nconst backgroundLayer5 = new Image();\r\nbackgroundLayer5.src = \"./imgs/layer-5.png\";\r\n\r\nlet Layer4offsetX1 = 0;\r\nlet Layer4offsetX2 = 2400;\r\n(function animate() {\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(backgroundLayer4, Layer4offsetX1, 0);\r\n  ctx.drawImage(backgroundLayer5, Layer4offsetX2, 0);\r\n  // 如果第一张图滚动展示完毕，就将其放到第二张图的后面\r\n  if (Layer4offsetX1 < -2400) Layer4offsetX1 = Layer4offsetX2 + 2400;\r\n  // 如果第二张图滚动展示完毕，就将其放到第一张图的后面\r\n  if (Layer4offsetX2 < -2400) Layer4offsetX2 = Layer4offsetX1 + 2400;\r\n  Layer4offsetX1 -= gameScrollSpeed; // 更新位置\r\n  Layer4offsetX2 -= gameScrollSpeed; // 更新位置\r\n  requestAnimationFrame(animate); // 刷新\r\n})();\r\n```\r\n\r\n### 1.4.2. 视差背景的实现\r\n\r\n[视差背景.html](./practices/4.视差背景：优化/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D; // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 1080);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 720);\r\n\r\nlet gameScrollSpeed = 10;\r\n\r\nconst backgroundLayer1 = new Image();\r\nbackgroundLayer1.src = \"./imgs/layer-1.png\";\r\nconst backgroundLayer2 = new Image();\r\nbackgroundLayer2.src = \"./imgs/layer-2.png\";\r\nconst backgroundLayer3 = new Image();\r\nbackgroundLayer3.src = \"./imgs/layer-3.png\";\r\nconst backgroundLayer4 = new Image();\r\nbackgroundLayer4.src = \"./imgs/layer-4.png\";\r\nconst backgroundLayer5 = new Image();\r\nbackgroundLayer5.src = \"./imgs/layer-5.png\";\r\n\r\nlet baclkgroundlayers = [\r\n  {\r\n    name: \"layer1\",\r\n    img: backgroundLayer1,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.1,\r\n  },\r\n  {\r\n    name: \"layer2\",\r\n    img: backgroundLayer2,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.3,\r\n  },\r\n  {\r\n    name: \"layer3-cloud\",\r\n    img: backgroundLayer3,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.5,\r\n  },\r\n  {\r\n    name: \"layer4\",\r\n    img: backgroundLayer4,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.65,\r\n  },\r\n  {\r\n    name: \"layer5-floor\",\r\n    img: backgroundLayer5,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 1.0,\r\n  },\r\n];\r\n\r\nfunction refreshBackgroundLayers() {\r\n  // 渲染背景\r\n  baclkgroundlayers.forEach((layerItem) => {\r\n    // 逐层渲染背景\r\n    ctx.drawImage(layerItem.img, layerItem.Xoffset1, 0);\r\n    ctx.drawImage(layerItem.img, layerItem.Xoffset2, 0);\r\n    if (layerItem.Xoffset1 < -layerItem.imgWidth)\r\n      layerItem.Xoffset1 = layerItem.Xoffset2 + layerItem.imgWidth; // 如果第一张图滚动展示完毕，就将其放到第二张图的后面\r\n    if (layerItem.Xoffset2 < -layerItem.imgWidth)\r\n      layerItem.Xoffset2 = layerItem.Xoffset1 + layerItem.imgWidth; // 如果第二张图滚动展示完毕，就将其放到第一张图的后面\r\n    layerItem.Xoffset1 -= gameScrollSpeed * layerItem.speedModify; // 更新位置\r\n    layerItem.Xoffset2 -= gameScrollSpeed * layerItem.speedModify; // 更新位置\r\n  });\r\n}\r\n\r\n(function animate() {\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // 清除\r\n  refreshBackgroundLayers(); // 渲染背景\r\n  requestAnimationFrame(animate); // 刷新\r\n})();\r\n```\r\n\r\n### 1.4.3. 最终的抽象、封装、实现、和使用\r\n\r\n#### 1.4.3.1. 抽象、封装、实现\r\n\r\n```ts\r\n// 可滚动的背景层\r\nexport class Layer {\r\n  readonly CANVAS_WIDTH: number;\r\n  readonly CANVAS_HEIGHT: number;\r\n  img: HTMLImageElement;\r\n  imgWidth: number;\r\n  imgHeight: number;\r\n  pos1_X: number;\r\n  pox1_Y: number;\r\n  pos2_X: number;\r\n  pox2_Y: number;\r\n  private layerMoveSpeedX = 0; // 层的移动速度,一个背景的所有层的移动速度应当是一致的\r\n  private layerMoveSpeedFactor = 1.0; // 层的移动速度的系数，一个背景有多个层，多个层的移动速度一致，但移动速度的系数可能不一致\r\n  constructor(\r\n    CANVAS_WIDTH: number,\r\n    CANVAS_HEIGHT: number,\r\n    imgSrc: string,\r\n    imgWidth: number,\r\n    imgHeight: number,\r\n    layerMoveSpeedFactor: number\r\n  ) {\r\n    this.CANVAS_WIDTH = CANVAS_WIDTH;\r\n    this.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n    this.img = new Image();\r\n    this.img.src = imgSrc;\r\n    this.imgWidth = imgWidth;\r\n    this.imgHeight = imgHeight;\r\n    this.layerMoveSpeedFactor = layerMoveSpeedFactor;\r\n    this.pos1_X = 0;\r\n    this.pox1_Y = 0;\r\n    this.pos2_X = this.imgWidth;\r\n    this.pox2_Y = 0;\r\n  }\r\n  update(timeInterval: number) {\r\n    this.pos1_X +=\r\n      this.layerMoveSpeedX * this.layerMoveSpeedFactor * timeInterval;\r\n    this.pos2_X +=\r\n      this.layerMoveSpeedX * this.layerMoveSpeedFactor * timeInterval;\r\n    // 图层向左移动，图层出界，向后添加新图层\r\n    if (this.layerMoveSpeedX < 0 && this.pos1_X + this.imgWidth <= 0)\r\n      this.pos1_X = this.pos2_X + this.imgWidth; // 图1出界就将其放置到图2之后\r\n    if (this.layerMoveSpeedX < 0 && this.pos2_X + this.imgWidth <= 0)\r\n      this.pos2_X = this.pos1_X + this.imgWidth; // 图2出界就将其放置到图1之后\r\n    // 图层向右移动，图层出界，向前添加新图层\r\n    if (this.layerMoveSpeedX > 0 && this.pos1_X >= 0)\r\n      this.pos2_X = this.pos1_X - this.imgWidth; // 图1出界就将其放置到图2之后\r\n    if (this.layerMoveSpeedX > 0 && this.pos2_X >= 0)\r\n      this.pos1_X = this.pos2_X - this.imgWidth; // 图2出界就将其放置到图1之后\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D) {\r\n    Context2D.drawImage(\r\n      this.img,\r\n      0,\r\n      0,\r\n      this.imgWidth,\r\n      this.imgHeight,\r\n      this.pos1_X,\r\n      this.pox1_Y,\r\n      this.imgWidth,\r\n      this.CANVAS_HEIGHT\r\n    );\r\n    Context2D.drawImage(\r\n      this.img,\r\n      0,\r\n      0,\r\n      this.imgWidth,\r\n      this.imgHeight,\r\n      this.pos2_X,\r\n      this.pox2_Y,\r\n      this.imgWidth,\r\n      this.CANVAS_HEIGHT\r\n    );\r\n  }\r\n  setSpeed(newSpeed: number) {\r\n    this.layerMoveSpeedX = newSpeed;\r\n  }\r\n}\r\n\r\n// 可滚动的背景，该背景包含多个层\r\nexport abstract class Background {\r\n  private _backgroundMoveSpeedX = 0; // 背景移动速度\r\n  layers: Array<Layer> = []; // 背景\r\n  constructor() {\r\n    this.setSpeed(0);\r\n  }\r\n  update(timeInterval: number) {\r\n    this.layers.forEach((layer) => layer.update(timeInterval));\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D) {\r\n    this.layers.forEach((layer) => layer.draw(Context2D));\r\n  }\r\n  getSpeed() {\r\n    return this._backgroundMoveSpeedX;\r\n  }\r\n  // 修改背景的速度就是修改要所有层的移动速度，这里做等值判断是防止for循环浪费性能\r\n  setSpeed(newSpeed: number) {\r\n    if (this._backgroundMoveSpeedX != newSpeed) {\r\n      this.layers.forEach((item) => item.setSpeed(newSpeed)); // 更新所有层的速度\r\n      this._backgroundMoveSpeedX = newSpeed; // 更新背景速度\r\n    }\r\n  }\r\n  abstract getGroundPosY(): number;\r\n}\r\n```\r\n\r\n#### 1.4.3.2. 使用\r\n\r\n从此实现一张视差背景只需要几行最关键的代码\r\n\r\n```ts\r\nimport { Background, Layer } from \"./Background.js\";\r\n// 背景city，由1层构成\r\nexport class BackgroundCity extends Background {\r\n  CANVAS_WIDTH: number;\r\n  CANVAS_HEIGHT: number;\r\n  constructor(CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n    super();\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-1.png\",\r\n        2400,\r\n        720,\r\n        0.0\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-2.png\",\r\n        2400,\r\n        720,\r\n        0.1\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-3.png\",\r\n        2400,\r\n        720,\r\n        0.3\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-4.png\",\r\n        2400,\r\n        720,\r\n        0.5\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-5.png\",\r\n        2400,\r\n        720,\r\n        1.0\r\n      )\r\n    );\r\n    this.CANVAS_WIDTH = CANVAS_WIDTH;\r\n    this.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n  }\r\n  getGroundPosY(): number {\r\n    return this.CANVAS_HEIGHT - 120;\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>\r\n"}