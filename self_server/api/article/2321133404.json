{"shortInfo":{"title":"JavaScript的2d游戏实现细节记录","date":"2023-01-10T05:57:00.000Z","cover":"\\self_server\\assets\\images\\shadowDogCover.gif","tags":["笔记"],"categories":"笔记","id":2321133404,"countWords":6745,"readSeconds":674.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# 1. JavaScript的2d游戏实现细节记录\r\n\r\n## 1.1. 试玩版本地址： [ShadowDog:0.0.1](./demo/index.html)\r\n\r\n## 1.2. 笔记目录\r\n\r\n- [1. JavaScript的2d游戏实现细节记录](#1-javascript的2d游戏实现细节记录)\r\n\t- [1.1. 试玩版本地址： ShadowDog:0.0.1](#11-试玩版本地址-shadowdog001)\r\n\t- [1.2. 笔记目录](#12-笔记目录)\r\n\t- [1.3. Canvas 绘图基本步骤](#13-canvas-绘图基本步骤)\r\n\t\t- [1.3.1. 原理](#131-原理)\r\n\t\t- [1.3.2. 优化及渲染所有动图](#132-优化及渲染所有动图)\r\n\t\t- [1.3.3. 封装和抽象](#133-封装和抽象)\r\n\t\t- [1.3.4. 对动画对象 Animater 的封装](#134-对动画对象-animater-的封装)\r\n\t\t- [1.3.5. 继续定义一些列接口并定义 Animal 类](#135-继续定义一些列接口并定义-animal-类)\r\n\t\t- [1.3.6. 使用](#136-使用)\r\n\t- [1.4. 敌人的移动模式](#14-敌人的移动模式)\r\n\t\t- [1.4.1. 原地静止的物体](#141-原地静止的物体)\r\n\t\t- [1.4.2. 水平直线运动的蠕虫](#142-水平直线运动的蠕虫)\r\n\t\t- [1.4.3. 上下摆动的蝙蝠](#143-上下摆动的蝙蝠)\r\n\t\t- [1.4.4. 随机无规律移动的齿轮](#144-随机无规律移动的齿轮)\r\n\t- [1.5. 视差背景原理](#15-视差背景原理)\r\n\t\t- [1.5.1. 无限滚动的背景原理](#151-无限滚动的背景原理)\r\n\t\t- [1.5.2. 视差背景的实现](#152-视差背景的实现)\r\n\t\t- [1.5.3. 最终的抽象、封装、实现](#153-最终的抽象封装实现)\r\n\t\t- [1.5.4. 使用封装好的类实现一个视差背景](#154-使用封装好的类实现一个视差背景)\r\n\t- [1.6. 输入监听和状态管理的实现](#16-输入监听和状态管理的实现)\r\n\t\t- [1.6.1. 输入监听](#161-输入监听)\r\n\t\t- [1.6.2. 状态管理](#162-状态管理)\r\n\t\t- [1.6.3. 使用状态设计模式实现状态管理Player类的部分代码](#163-使用状态设计模式实现状态管理player类的部分代码)\r\n\t\t- [1.6.4. 使用状态设计模式实现状态管理Game类的部分代码](#164-使用状态设计模式实现状态管理game类的部分代码)\r\n\t- [1.7. Scene场景](#17-scene场景)\r\n\t- [1.8. UI](#18-ui)\r\n\t- [1.9. 字体](#19-字体)\r\n\t- [1.10. Canvas铺满页面屏幕的实现](#110-canvas铺满页面屏幕的实现)\r\n\t- [1.11. 自写工具类](#111-自写工具类)\r\n\r\n\r\n## 1.3. Canvas 绘图基本步骤\r\n\r\n### 1.3.1. 原理\r\n\r\n[原理.html](./practices/1.canvas%EF%BC%9A%E5%8E%9F%E7%90%86/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\n// 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 600);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 600);\r\n\r\n// 单帧宽高\r\nconst Sprite_WIDTH = 575;\r\nconst Sprite_HEIGHT = 523;\r\n\r\nconst imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./shadow_dog.png\";\r\n\r\nlet frameX = 0;\r\nlet frameY = 0;\r\nlet frameCount = 0; // 第几帧\r\nlet stageFrame = 5; // 交错帧，每隔5帧 切换图片\r\n\r\nfunction animate() {\r\n  // 计算当前要绘制的帧的index\r\n  frameCount = ++frameCount % stageFrame;\r\n  if (!frameCount) frameX = ++frameX % 7;\r\n\r\n  //清除上一次绘图痕迹\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer, // img\r\n    frameX * Sprite_WIDTH, //源坐标x\r\n    frameY * Sprite_HEIGHT, //源坐标y\r\n    Sprite_WIDTH, //源图像宽\r\n    Sprite_HEIGHT, //源图像高\r\n    0, // 目的坐标x\r\n    0, // 目的坐标y\r\n    CANVAS_WIDTH, // 绘制宽度w\r\n    CANVAS_HEIGHT // 绘制高度h\r\n  );\r\n  // requestAnimationFrame原理上相当于60fps的setInterval\r\n  requestAnimationFrame(animate);\r\n}\r\nanimate();\r\n```\r\n\r\n### 1.3.2. 优化及渲染所有动图\r\n\r\n[优化.html](./practices/2.animate：优化/index.html)\r\n\r\n<canvas id=\"myCanvas_2j0923ru48\"></canvas>\r\n\r\n<div class=\"animation-box\">\r\n\t<label for=\"animations\">select animation:</label>\r\n\t<select name=\"\" id=\"animations_djf9498\">\r\n\t\t<option value=\"idle\">idle</option>\r\n\t\t<option value=\"jump\">jump</option>\r\n\t\t<option value=\"fall\">fall</option>\r\n\t\t<option value=\"run\">run</option>\r\n\t\t<option value=\"dizzy\">dizzy</option>\r\n\t\t<option value=\"sit\">sit</option>\r\n\t\t<option value=\"roll\">roll</option>\r\n\t\t<option value=\"bite\">bite</option>\r\n\t\t<option value=\"ko\">ko</option>\r\n\t\t<option value=\"gethit\">gethit</option>\r\n\t</select>\r\n</div>\r\n<img src=\"./images/shadow_dog.png\">\r\n<script>\r\nvar myCanvas = document.querySelector(\"#myCanvas_2j0923ru48\");\r\nvar ctx = myCanvas.getContext(\"2d\"); // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n// canvas的默认大小为300x150px 需手动修改\r\nvar CANVAS_WIDTH = (myCanvas.width = 250);\r\nvar CANVAS_HEIGHT = (myCanvas.height = 250);\r\nvar Sprite_WIDTH = 575;\r\nvar Sprite_HEIGHT = 523;\r\nvar imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./images/shadow_dog.png\";\r\nvar playerState = \"idle\";\r\nvar selector = document.querySelector(\"#animations_djf9498\");\r\nselector.addEventListener(\"change\", function () {\r\n  playerState = selector.value;\r\n});\r\nvar animations = {\r\n  idle: { rows: 0,  cols: 7},\r\n  jump: { rows: 1,  cols: 7}, \r\n  fall: { rows: 2,  cols: 7}, \r\n  run: {  rows: 3,  cols: 9}, \r\n  dizzy:{ rows: 4,  cols: 11},\r\n  sit: {  rows: 5,  cols: 5}, \r\n  roll: { rows: 6,  cols: 7}, \r\n  bite:{  rows: 7,  cols: 7}, \r\n  ko: {   rows: 8,  cols: 12},\r\n  gethit:{rows: 9,  cols: 4,  }\r\n};\r\nvar animaIndex = 0; // 动画索引\r\nvar frameIndex = 0; // 帧索引\r\nvar frameCount = 0; // 总的帧数\r\nvar stageFrame = 5; // 交错帧，每隔5帧 切换关键帧\r\nfunction animate() {\r\n  frameIndex =\r\n    Math.floor(frameCount++ / stageFrame) % animations[playerState].cols;\r\n  animaIndex = animations[playerState].rows;\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer,\r\n    frameIndex * Sprite_WIDTH,\r\n    animaIndex * Sprite_HEIGHT,\r\n    Sprite_WIDTH,\r\n    Sprite_HEIGHT,\r\n    0,\r\n    0,\r\n    CANVAS_WIDTH,\r\n    CANVAS_HEIGHT\r\n  );\r\n  // requestAnimationFrame效果上相当于60fps的setInterval\r\n  requestAnimationFrame(animate); \r\n}\r\nanimate();\r\n</script>\r\n\r\n```html\r\n<canvas id=\"myCanvas_2j0923ru48\"></canvas>\r\n\r\n<div class=\"animation-box\">\r\n\t<label for=\"animations\">select animation:</label>\r\n\t<select name=\"\" id=\"animations_djf9498\">\r\n\t\t<option value=\"idle\">idle</option>\r\n\t\t<option value=\"jump\">jump</option>\r\n\t\t<option value=\"fall\">fall</option>\r\n\t\t<option value=\"run\">run</option>\r\n\t\t<option value=\"dizzy\">dizzy</option>\r\n\t\t<option value=\"sit\">sit</option>\r\n\t\t<option value=\"roll\">roll</option>\r\n\t\t<option value=\"bite\">bite</option>\r\n\t\t<option value=\"ko\">ko</option>\r\n\t\t<option value=\"gethit\">gethit</option>\r\n\t</select>\r\n</div>\r\n<img src=\"./images/shadow_dog.png\">\r\n<script>\r\nvar myCanvas = document.querySelector(\"#myCanvas_2j0923ru48\");\r\nvar ctx = myCanvas.getContext(\"2d\"); // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n// canvas的默认大小为300x150px 需手动修改\r\nvar CANVAS_WIDTH = (myCanvas.width = 250);\r\nvar CANVAS_HEIGHT = (myCanvas.height = 250);\r\nvar Sprite_WIDTH = 575;\r\nvar Sprite_HEIGHT = 523;\r\nvar imgPlayer = new Image(); // image对象类型为 HTMLImageElement 可以附加到dom中\r\nimgPlayer.src = \"./images/shadow_dog.png\";\r\nvar playerState = \"idle\";\r\nvar selector = document.querySelector(\"#animations_djf9498\");\r\nselector.addEventListener(\"change\", function () {\r\n  playerState = selector.value;\r\n});\r\nvar animations = {\r\n  idle: { rows: 0,  cols: 7},\r\n  jump: { rows: 1,  cols: 7},\r\n  fall: { rows: 2,  cols: 7},\r\n  run: {  rows: 3,  cols: 9},\r\n  dizzy:{ rows: 4,  cols: 11},\r\n  sit: {  rows: 5,  cols: 5},\r\n  roll: { rows: 6,  cols: 7},\r\n  bite:{  rows: 7,  cols: 7},\r\n  ko: {   rows: 8,  cols: 12},\r\n  gethit:{rows: 9,  cols: 4,  }\r\n};\r\nvar animaIndex = 0; // 动画索引\r\nvar frameIndex = 0; // 帧索引\r\nvar frameCount = 0; // 总的帧数\r\nvar stageFrame = 5; // 交错帧，每隔5帧 切换关键帧\r\nfunction animate() {\r\n  frameIndex =\r\n    Math.floor(frameCount++ / stageFrame) % animations[playerState].cols;\r\n  animaIndex = animations[playerState].rows;\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(\r\n    imgPlayer,\r\n    frameIndex * Sprite_WIDTH,\r\n    animaIndex * Sprite_HEIGHT,\r\n    Sprite_WIDTH,\r\n    Sprite_HEIGHT,\r\n    0,\r\n    0,\r\n    CANVAS_WIDTH,\r\n    CANVAS_HEIGHT\r\n  );\r\n  // requestAnimationFrame效果上相当于60fps的setInterval\r\n  requestAnimationFrame(animate);\r\n}\r\nanimate();\r\n```\r\n\r\n### 1.3.3. 封装和抽象\r\n\r\n### 1.3.4. 对动画对象 Animater 的封装\r\n\r\n```ts\r\nimport { RandomRange } from \"./utils.js\";\r\n// 动画对象\r\nexport class Animater {\r\n  posX = 0; // 位置x\r\n  posY = 0; // 位置y\r\n  drawWidth: number; // 实际绘制的宽度\r\n  drawHeight: number; // 实际绘制的高度\r\n  img: HTMLImageElement; // 图片\r\n  imgFrameWidth: number; // 一帧的宽度\r\n  imgFrameHeight: number; // 一帧的高度\r\n  animateFramesTotal: Array<number>; // [动画1的总帧数,动画2的总帧数,动画3的...]\r\n  animateNameIndexMap: Array<string>; // 数据结构：{动画名称:该动画是第几个动画}\r\n  animateFrameIndexX = 0; // 当前绘制的是第几帧\r\n  animateFrameIndexY = 0; // 当前绘制的是第几个动画\r\n  animateFrameTimer = 0;\r\n  private _animateFrameFps = 60;\r\n  private animateFrameChangeInterval = 1000 / 60;\r\n  private get animateFrameFps() {\r\n    return this._animateFrameFps;\r\n  }\r\n  private set animateFrameFps(fps) {\r\n    this._animateFrameFps = fps;\r\n    this.animateFrameChangeInterval = 1000 / fps;\r\n  }\r\n  public setFps(fps: number) {\r\n    this.animateFrameFps = fps;\r\n  }\r\n  stopAnimateAtLastFlag = false;\r\n  RewindAnimateFrameFlag = false;\r\n  constructor(\r\n    imgSrc: string,\r\n    imgFrameWidth: number,\r\n    imgFrameHeight: number,\r\n    size: number,\r\n    animateFramesTotal: Array<number>,\r\n    animateNameIndexMap: Array<string>\r\n  ) {\r\n    this.img = new Image();\r\n    this.img.src = imgSrc;\r\n    this.animateFramesTotal = animateFramesTotal;\r\n    this.animateNameIndexMap = animateNameIndexMap;\r\n    this.imgFrameWidth = imgFrameWidth;\r\n    this.imgFrameHeight = imgFrameHeight;\r\n    this.drawWidth = this.imgFrameWidth * size;\r\n    this.drawHeight = this.imgFrameHeight * size;\r\n    this.setFps(60);\r\n  }\r\n  // 更新数据\r\n  update(timeInterval: number): void {\r\n    // 最后一帧则停止切换帧\r\n    if (this.stopAnimateAtLastFlag == true && this.isLastAnimateFrame()) return;\r\n    // 计算下一帧\r\n    if (this.animateFrameTimer >= this.animateFrameChangeInterval) {\r\n      this.animateFrameTimer = 0;\r\n      this.animateFrameIndexX += 1;\r\n      this.animateFrameIndexX %=\r\n        this.animateFramesTotal[this.animateFrameIndexY];\r\n    } else this.animateFrameTimer += timeInterval;\r\n  }\r\n  // 绘制帧\r\n  draw(Context2D: CanvasRenderingContext2D): void {\r\n    Context2D.drawImage(\r\n      this.img,\r\n      this.animateFrameIndexX * this.imgFrameWidth,\r\n      this.animateFrameIndexY * this.imgFrameHeight,\r\n      this.imgFrameWidth,\r\n      this.imgFrameHeight,\r\n      this.posX,\r\n      this.posY,\r\n      this.drawWidth,\r\n      this.drawHeight\r\n    );\r\n  }\r\n  changeAnimateByName(animateName: string) {\r\n    // 根据名称切换动画\r\n    if (this.animateNameIndexMap.includes(animateName))\r\n      this.animateFrameIndexY = this.animateNameIndexMap.indexOf(animateName);\r\n    else throw new Error(`animateName:'${animateName}' is not exist.`);\r\n    this.init();\r\n  }\r\n  // 判断是否为最后一帧\r\n  isLastAnimateFrame() {\r\n    return (\r\n      this.animateFrameIndexX ==\r\n      this.animateFramesTotal[this.animateFrameIndexY] - 1\r\n    );\r\n  }\r\n  // 判断是否为第一帧\r\n  isFirstAnimateFrame() {\r\n    return this.animateFrameIndexX == 0;\r\n  }\r\n  // 初始化状态\r\n  init() {\r\n    this.animateFrameIndexX = 0; // 设置从第一帧开始\r\n  }\r\n  // 请求在渲染到最后一帧的时候停止更新动画\r\n  requestStopAnimateFrameAtLastFrame() {\r\n    this.stopAnimateAtLastFlag = true;\r\n  }\r\n  isOutOfLeftScreem() {\r\n    return this.posX + this.drawWidth < 0;\r\n  }\r\n}\r\n```\r\n\r\n### 1.3.5. 继续定义一些列接口并定义 Animal 类\r\n\r\n```ts\r\nimport { Animater } from \"./Animater.js\";\r\nimport { transformAble } from \"./transformAble.js\";\r\n\r\n// 可移动的\r\ninterface MoveAble {\r\n  moveSpeedX: number; // x轴移动速度 单位：像素/毫秒\r\n  moveSpeedY: number; // x轴移动速度 单位：像素/毫秒\r\n  move(timeInterval: number): void; // 移动\r\n}\r\n// 活的\r\ninterface AliveAble {\r\n  aliveFlag: boolean;\r\n  getAliveFlag(): boolean; // 用于判断是否存活\r\n  setAliveFlag(newVal: boolean): void;\r\n}\r\n// 圆形碰撞检测\r\ninterface CollisionCheckAble {\r\n  collisionCheckPosX: number;\r\n  collisionCheckPosY: number;\r\n  collisionCheckWidth: number;\r\n  collisionCheckHeight: number;\r\n  collisionCheckRadius: number;\r\n  collisionCheckUpdate(): void;\r\n  isCollision(obj: CollisionCheckAble): boolean; // 碰撞检测\r\n}\r\ninterface NameAble {\r\n  Name: string;\r\n  getName(): string;\r\n}\r\n\r\n// 抽象类 Animal 继承动画类 实现Moveable AliveAble 接口\r\nexport abstract class Animal\r\n  extends Animater\r\n  implements MoveAble, AliveAble, CollisionCheckAble, NameAble, transformAble\r\n{\r\n  // 移动\r\n  moveSpeedX = 0;\r\n  moveSpeedY = 0;\r\n  abstract move(timeInterval: number): void;\r\n  // 存活\r\n  aliveFlag = true;\r\n  setAliveFlag(newVal: boolean): void {\r\n    this.aliveFlag = newVal;\r\n  }\r\n  getAliveFlag(): boolean {\r\n    return this.aliveFlag;\r\n  }\r\n  // 可碰撞检测\r\n  collisionCheckPosX = 0;\r\n  collisionCheckPosY = 0;\r\n  collisionCheckWidth = 0;\r\n  collisionCheckHeight = 0;\r\n  collisionCheckRadius = 0;\r\n  collisionCheckUpdate(): void {\r\n    // 圆形碰撞检测\r\n    this.collisionCheckPosX = this.posX + this.drawWidth / 2;\r\n    this.collisionCheckPosY = this.posY + this.drawHeight / 2;\r\n    this.collisionCheckRadius =\r\n      (Math.min(this.drawWidth, this.drawHeight) / 2) * 0.8;\r\n  }\r\n  isCollision(obj: CollisionCheckAble): boolean {\r\n    this.collisionCheckUpdate();\r\n    obj.collisionCheckUpdate();\r\n    const dX = this.collisionCheckPosX - obj.collisionCheckPosX;\r\n    const dY = this.collisionCheckPosY - obj.collisionCheckPosY;\r\n    const distance = Math.sqrt(dX * dX + dY * dY);\r\n    return distance < this.collisionCheckRadius + obj.collisionCheckRadius;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.collisionCheckUpdate();\r\n    super.update(timeInterval);\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D): void {\r\n    // Context2D.beginPath();\r\n    // Context2D.arc(this.collisionCheckPosX, this.collisionCheckPosY, this.collisionCheckRadius, 0, Math.PI * 2);\r\n    // Context2D.stroke();\r\n    // Context2D.strokeRect(this.posX, this.posY, this.drawWidth, this.drawHeight);\r\n    super.draw(Context2D);\r\n  }\r\n  // put it on ground();\r\n  setOnGround(groundPosY: number): Animal {\r\n    this.posY = groundPosY - this.drawHeight;\r\n    return this;\r\n  }\r\n  // 水平和垂直平移\r\n  transform(stepX: number, stepY: number) {\r\n    this.posX += stepX;\r\n    this.posY += stepY;\r\n  }\r\n  abstract Name: string;\r\n  getName(): string {\r\n    this.Name;\r\n    return this.Name;\r\n  }\r\n}\r\n```\r\n\r\n### 1.3.6. 使用\r\n\r\n于是，定义一个游戏角色：蠕虫，就会变得如此简单\r\n\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Worm extends Animal {\r\n  Name = \"Worm\";\r\n  constructor(posX: number, posY: number) {\r\n    super(\"./imgs/Worm.png\", 229, 171, 0.5, [6], [\"idle\"]);\r\n    this.posX = posX;\r\n    this.posY = posY;\r\n    this.moveSpeedX = RandomRange(0.05, 0.1);\r\n  }\r\n  move(timeInterval: number) {\r\n    this.posX -= this.moveSpeedX * timeInterval;\r\n  }\r\n  update(timeInterval: number): void {\r\n    this.move(timeInterval);\r\n    super.update(timeInterval);\r\n  }\r\n}\r\n```\r\n\r\n## 1.4. 敌人的移动模式\r\n\r\n\r\n### 1.4.1. 原地静止的物体\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 鬼\r\nexport class Plant extends Animal {\r\n\tName = \"Plant\";\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(\"./imgs/enemy_plant.png\", 60, 87, 1.5, [2], [\"default\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.setFps(10);\r\n\t}\r\n\tmove(timeInterval: number): void {\r\n\t\treturn;\r\n\t}\r\n}\r\n```\r\n\r\n### 1.4.2. 水平直线运动的蠕虫\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Worm extends Animal {\r\n\tName = \"Worm\";\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(\"./imgs/Worm.png\", 229, 171, 0.5, [6], [\"idle\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.moveSpeedX = RandomRange(0.05, 0.1);\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX -= this.moveSpeedX * timeInterval;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.move(timeInterval);\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n### 1.4.3. 上下摆动的蝙蝠\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Bat extends Animal {\r\n\tName = \"Bat\";\r\n\tshakeAngle = 0; // 摆动角度,初始摆动角度 单位: 弧度\r\n\tshakeDeltaAngle: number; // 摆动增量 单位:弧度/毫秒\r\n\tshakeGapRadius: number; // 摆动范围半径 单位：像素\r\n\tconstructor(posX: number, posY: number) {\r\n\t\tsuper(\"./imgs/Bat.png\", 266, 188, 0.5, [6], [\"idle\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.moveSpeedX = RandomRange(0.05, 0.1);\r\n\r\n\t\tthis.shakeAngle = RandomRange(Math.asin(-1), Math.asin(1));\r\n\t\tthis.shakeDeltaAngle = RandomRange(Math.asin(0.001), Math.asin(0.003));\r\n\t\tthis.shakeGapRadius = RandomRange(2, 5);\r\n\t}\r\n\tshake(timeInterval: number) {\r\n\t\tthis.posY += this.shakeGapRadius * Math.sin(this.shakeAngle);\r\n\t\tthis.shakeAngle += this.shakeDeltaAngle * timeInterval;\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX -= this.moveSpeedX * timeInterval;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.move(timeInterval);\r\n\t\tthis.shake(timeInterval);\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n```\r\n\r\n**周期线性运动的蝙蝠**\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class GhostBird extends Animal {\r\n\tName = \"GhostBird\";\r\n\r\n\tasline: { angle: number; angleIncreaseSpeed: number; factorX: number; factorY: number } = {\r\n\t\tangle: 0,\r\n\t\tangleIncreaseSpeed: 0,\r\n\t\tfactorX: 0,\r\n\t\tfactorY: 0\r\n\t};\r\n\r\n\tCANVAS_WIDTH: number;\r\n\tCANVAS_HEIGHT: number;\r\n\toffsetY: number;\r\n\toffsetX: number;\r\n\r\n\tconstructor(posX: number, posY: number, CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n\t\tsuper(\"./imgs/GhostBird.png\", 218, 177, 0.5, [6], [\"idle\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.CANVAS_WIDTH = CANVAS_WIDTH;\r\n\t\tthis.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n\t\tthis.moveSpeedX = RandomRange(0.4, 1);\r\n\t\t// for asline\r\n\t\tthis.offsetX = 0; // 相对于屏幕右上角0，0位置的偏移量\r\n\t\tthis.offsetY = 0;\r\n\t\tthis.asline.angle = (Math.PI / 365) * RandomRange(-365, 365); // 初相角 -1 ~ 1\r\n\t\tthis.asline.angleIncreaseSpeed = (Math.PI / 365) * RandomRange(30, 90) * Math.sign(RandomRange(-1, 1)); // 移动周期 30~90 感觉不错\r\n\t\tthis.asline.factorX = (Math.PI / 365) * 0.45;\r\n\t\tthis.asline.factorY = (Math.PI / 365) * 0.35;\r\n\t}\r\n\ttransform(stepX: number, stepY: number): void {\r\n\t\t// this.offsetX += stepX;\r\n\t\t// this.offsetY += stepY;\r\n\t}\r\n\tmove_asline(timeInterval: number) {\r\n\t\t// 线性运动\r\n\t\tthis.posX =\r\n\t\t\tthis.offsetX + (this.CANVAS_WIDTH / 2) * Math.cos(this.asline.angle * this.asline.factorX) + (this.CANVAS_WIDTH / 2 - this.drawWidth / 2);\r\n\t\tthis.posY =\r\n\t\t\tthis.offsetY + (this.CANVAS_HEIGHT / 2) * Math.sin(this.asline.angle * this.asline.factorY) + (this.CANVAS_HEIGHT / 2 - this.drawHeight / 2);\r\n\t\tconst angleStep = this.asline.angleIncreaseSpeed * timeInterval;\r\n\t\tthis.asline.angle += angleStep;\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX -= this.moveSpeedX * timeInterval;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.move_asline(timeInterval);\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n```\r\n\r\n### 1.4.4. 随机无规律移动的齿轮\r\n```ts\r\nimport { Animal } from \"./Animal.js\";\r\nimport { RandomRange } from \"./utils.js\";\r\n\r\n// 蠕虫 继承 Animal 类\r\nexport class Gear extends Animal {\r\n\tName = \"Gear\";\r\n\treArrange_NewPosX: number;\r\n\treArrange_NewPosY: number;\r\n\treArrange_MoveSpeed: number; // 移动速度\r\n\treArrange_Timer = 0;\r\n\treArrange_TimeInterval: number;\r\n\tCANVAS_WIDTH: number;\r\n\tCANVAS_HEIGHT: number;\r\n\r\n\tconstructor(posX: number, posY: number, CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n\t\tsuper(\"./imgs/Gear.png\", 213, 212, 0.5, [6], [\"idle\"]);\r\n\t\tthis.posX = posX;\r\n\t\tthis.posY = posY;\r\n\t\tthis.CANVAS_WIDTH = CANVAS_WIDTH;\r\n\t\tthis.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n\r\n\t\tthis.moveSpeedX = RandomRange(0.4, 1);\r\n\r\n\t\t// randomReArrange_ment\r\n\t\tthis.reArrange_NewPosX = this.posX;\r\n\t\tthis.reArrange_NewPosY = this.posY;\r\n\t\tthis.reArrange_TimeInterval = Math.floor(RandomRange(500, 2000)); // 0.5 ~ 2 秒\r\n\t\tthis.reArrange_MoveSpeed = RandomRange(0.5, 2.0);\r\n\t}\r\n\t// 平移\r\n\ttransform(stepX: number, stepY: number): void {\r\n\t\treturn;\r\n\t\t// 决定其是否跟随场景移动的代码\r\n\t\tthis.posX += stepX;\r\n\t\tthis.posY += stepY;\r\n\t\tthis.reArrange_NewPosX += stepX; // dx要根据这个来计算，所以也要平移\r\n\t\tthis.reArrange_NewPosY += stepY;\r\n\t}\r\n\treArrange(timeInterval: number) {\r\n\t\t// 重新排列\r\n\t\tif ((this.reArrange_Timer += timeInterval) >= this.reArrange_TimeInterval) {\r\n\t\t\tthis.reArrange_Timer = 0;\r\n\t\t\t// 随机位置，注意其范围区间\r\n\t\t\tthis.reArrange_NewPosX = RandomRange(0, this.CANVAS_WIDTH);\r\n\t\t\tthis.reArrange_NewPosY = RandomRange(0, this.CANVAS_HEIGHT);\r\n\t\t\tconsole.log(this.reArrange_NewPosX);\r\n\t\t\tconsole.log(this.reArrange_NewPosY);\r\n\t\t}\r\n\t\tconst dx = (this.reArrange_NewPosX - this.posX) / 1000;\r\n\t\tconst dy = (this.reArrange_NewPosY - this.posY) / 1000;\r\n\t\tconst moveStep = this.reArrange_MoveSpeed * timeInterval;\r\n\t\tthis.posX += dx * moveStep;\r\n\t\tthis.posY += dy * moveStep;\r\n\t}\r\n\tmove(timeInterval: number) {\r\n\t\tthis.posX -= this.moveSpeedX * timeInterval;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\tthis.reArrange(timeInterval);\r\n\t\t// this.move(timeInterval);\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n```\r\n\r\n\r\n## 1.5. 视差背景原理\r\n\r\n### 1.5.1. 无限滚动的背景原理\r\n\r\n[](./practices/3.%E8%A7%86%E5%B7%AE%E8%83%8C%E6%99%AF%EF%BC%9A%E5%8E%9F%E7%90%86/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\n// 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 800);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 700);\r\n\r\nlet gameScrollSpeed = 10;\r\n\r\n// 层\r\nconst backgroundLayer1 = new Image();\r\nbackgroundLayer1.src = \"./imgs/layer-1.png\";\r\nconst backgroundLayer2 = new Image();\r\nbackgroundLayer2.src = \"./imgs/layer-2.png\";\r\nconst backgroundLayer3 = new Image();\r\nbackgroundLayer3.src = \"./imgs/layer-3.png\";\r\nconst backgroundLayer4 = new Image();\r\nbackgroundLayer4.src = \"./imgs/layer-4.png\";\r\nconst backgroundLayer5 = new Image();\r\nbackgroundLayer5.src = \"./imgs/layer-5.png\";\r\n\r\nlet Layer4offsetX1 = 0;\r\nlet Layer4offsetX2 = 2400;\r\n(function animate() {\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\r\n  ctx.drawImage(backgroundLayer4, Layer4offsetX1, 0);\r\n  ctx.drawImage(backgroundLayer5, Layer4offsetX2, 0);\r\n  // 如果第一张图滚动展示完毕，就将其放到第二张图的后面\r\n  if (Layer4offsetX1 < -2400) Layer4offsetX1 = Layer4offsetX2 + 2400;\r\n  // 如果第二张图滚动展示完毕，就将其放到第一张图的后面\r\n  if (Layer4offsetX2 < -2400) Layer4offsetX2 = Layer4offsetX1 + 2400;\r\n  Layer4offsetX1 -= gameScrollSpeed; // 更新位置\r\n  Layer4offsetX2 -= gameScrollSpeed; // 更新位置\r\n  requestAnimationFrame(animate); // 刷新\r\n})();\r\n```\r\n\r\n### 1.5.2. 视差背景的实现\r\n\r\n[视差背景.html](./practices/4.视差背景：优化/index.html)\r\n\r\n```ts\r\nvar myCanvas = document.querySelector(\"#myCanvas\") as HTMLCanvasElement;\r\nvar ctx = myCanvas.getContext(\"2d\") as CanvasRenderingContext2D; // 获取2d的上下文环境对象，该对象包含画笔设置和一些方法\r\n\r\n// canvas的默认大小为300x150px 需手动修改\r\nconst CANVAS_WIDTH = (myCanvas.width = 1080);\r\nconst CANVAS_HEIGHT = (myCanvas.height = 720);\r\n\r\nlet gameScrollSpeed = 10;\r\n\r\nconst backgroundLayer1 = new Image();\r\nbackgroundLayer1.src = \"./imgs/layer-1.png\";\r\nconst backgroundLayer2 = new Image();\r\nbackgroundLayer2.src = \"./imgs/layer-2.png\";\r\nconst backgroundLayer3 = new Image();\r\nbackgroundLayer3.src = \"./imgs/layer-3.png\";\r\nconst backgroundLayer4 = new Image();\r\nbackgroundLayer4.src = \"./imgs/layer-4.png\";\r\nconst backgroundLayer5 = new Image();\r\nbackgroundLayer5.src = \"./imgs/layer-5.png\";\r\n\r\nlet baclkgroundlayers = [\r\n  {\r\n    name: \"layer1\",\r\n    img: backgroundLayer1,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.1,\r\n  },\r\n  {\r\n    name: \"layer2\",\r\n    img: backgroundLayer2,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.3,\r\n  },\r\n  {\r\n    name: \"layer3-cloud\",\r\n    img: backgroundLayer3,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.5,\r\n  },\r\n  {\r\n    name: \"layer4\",\r\n    img: backgroundLayer4,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 0.65,\r\n  },\r\n  {\r\n    name: \"layer5-floor\",\r\n    img: backgroundLayer5,\r\n    imgWidth: 2400,\r\n    Xoffset1: 0,\r\n    Xoffset2: 2400,\r\n    speedModify: 1.0,\r\n  },\r\n];\r\n\r\nfunction refreshBackgroundLayers() {\r\n  // 渲染背景\r\n  baclkgroundlayers.forEach((layerItem) => {\r\n    // 逐层渲染背景\r\n    ctx.drawImage(layerItem.img, layerItem.Xoffset1, 0);\r\n    ctx.drawImage(layerItem.img, layerItem.Xoffset2, 0);\r\n    if (layerItem.Xoffset1 < -layerItem.imgWidth)\r\n      layerItem.Xoffset1 = layerItem.Xoffset2 + layerItem.imgWidth; // 如果第一张图滚动展示完毕，就将其放到第二张图的后面\r\n    if (layerItem.Xoffset2 < -layerItem.imgWidth)\r\n      layerItem.Xoffset2 = layerItem.Xoffset1 + layerItem.imgWidth; // 如果第二张图滚动展示完毕，就将其放到第一张图的后面\r\n    layerItem.Xoffset1 -= gameScrollSpeed * layerItem.speedModify; // 更新位置\r\n    layerItem.Xoffset2 -= gameScrollSpeed * layerItem.speedModify; // 更新位置\r\n  });\r\n}\r\n\r\n(function animate() {\r\n  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // 清除\r\n  refreshBackgroundLayers(); // 渲染背景\r\n  requestAnimationFrame(animate); // 刷新\r\n})();\r\n```\r\n\r\n### 1.5.3. 最终的抽象、封装、实现\r\n\r\n```ts\r\n// 可滚动的背景层\r\nexport class Layer {\r\n  readonly CANVAS_WIDTH: number;\r\n  readonly CANVAS_HEIGHT: number;\r\n  img: HTMLImageElement;\r\n  imgWidth: number;\r\n  imgHeight: number;\r\n  pos1_X: number;\r\n  pox1_Y: number;\r\n  pos2_X: number;\r\n  pox2_Y: number;\r\n  private layerMoveSpeedX = 0; // 层的移动速度,一个背景的所有层的移动速度应当是一致的\r\n  private layerMoveSpeedFactor = 1.0; // 层的移动速度的系数，一个背景有多个层，多个层的移动速度一致，但移动速度的系数可能不一致\r\n  constructor(\r\n    CANVAS_WIDTH: number,\r\n    CANVAS_HEIGHT: number,\r\n    imgSrc: string,\r\n    imgWidth: number,\r\n    imgHeight: number,\r\n    layerMoveSpeedFactor: number\r\n  ) {\r\n    this.CANVAS_WIDTH = CANVAS_WIDTH;\r\n    this.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n    this.img = new Image();\r\n    this.img.src = imgSrc;\r\n    this.imgWidth = imgWidth;\r\n    this.imgHeight = imgHeight;\r\n    this.layerMoveSpeedFactor = layerMoveSpeedFactor;\r\n    this.pos1_X = 0;\r\n    this.pox1_Y = 0;\r\n    this.pos2_X = this.imgWidth;\r\n    this.pox2_Y = 0;\r\n  }\r\n  update(timeInterval: number) {\r\n    this.pos1_X +=\r\n      this.layerMoveSpeedX * this.layerMoveSpeedFactor * timeInterval;\r\n    this.pos2_X +=\r\n      this.layerMoveSpeedX * this.layerMoveSpeedFactor * timeInterval;\r\n    // 图层向左移动，图层出界，向后添加新图层\r\n    if (this.layerMoveSpeedX < 0 && this.pos1_X + this.imgWidth <= 0)\r\n      this.pos1_X = this.pos2_X + this.imgWidth; // 图1出界就将其放置到图2之后\r\n    if (this.layerMoveSpeedX < 0 && this.pos2_X + this.imgWidth <= 0)\r\n      this.pos2_X = this.pos1_X + this.imgWidth; // 图2出界就将其放置到图1之后\r\n    // 图层向右移动，图层出界，向前添加新图层\r\n    if (this.layerMoveSpeedX > 0 && this.pos1_X >= 0)\r\n      this.pos2_X = this.pos1_X - this.imgWidth; // 图1出界就将其放置到图2之后\r\n    if (this.layerMoveSpeedX > 0 && this.pos2_X >= 0)\r\n      this.pos1_X = this.pos2_X - this.imgWidth; // 图2出界就将其放置到图1之后\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D) {\r\n    Context2D.drawImage(\r\n      this.img,\r\n      0,\r\n      0,\r\n      this.imgWidth,\r\n      this.imgHeight,\r\n      this.pos1_X,\r\n      this.pox1_Y,\r\n      this.imgWidth,\r\n      this.CANVAS_HEIGHT\r\n    );\r\n    Context2D.drawImage(\r\n      this.img,\r\n      0,\r\n      0,\r\n      this.imgWidth,\r\n      this.imgHeight,\r\n      this.pos2_X,\r\n      this.pox2_Y,\r\n      this.imgWidth,\r\n      this.CANVAS_HEIGHT\r\n    );\r\n  }\r\n  setSpeed(newSpeed: number) {\r\n    this.layerMoveSpeedX = newSpeed;\r\n  }\r\n}\r\n\r\n// 可滚动的背景，该背景包含多个层\r\nexport abstract class Background {\r\n  private _backgroundMoveSpeedX = 0; // 背景移动速度\r\n  layers: Array<Layer> = []; // 背景\r\n  constructor() {\r\n    this.setSpeed(0);\r\n  }\r\n  update(timeInterval: number) {\r\n    this.layers.forEach((layer) => layer.update(timeInterval));\r\n  }\r\n  draw(Context2D: CanvasRenderingContext2D) {\r\n    this.layers.forEach((layer) => layer.draw(Context2D));\r\n  }\r\n  getSpeed() {\r\n    return this._backgroundMoveSpeedX;\r\n  }\r\n  // 修改背景的速度就是修改要所有层的移动速度，这里做等值判断是防止for循环浪费性能\r\n  setSpeed(newSpeed: number) {\r\n    if (this._backgroundMoveSpeedX != newSpeed) {\r\n      this.layers.forEach((item) => item.setSpeed(newSpeed)); // 更新所有层的速度\r\n      this._backgroundMoveSpeedX = newSpeed; // 更新背景速度\r\n    }\r\n  }\r\n  abstract getGroundPosY(): number;\r\n}\r\n```\r\n\r\n### 1.5.4. 使用封装好的类实现一个视差背景\r\n\r\n现在实现一张视差背景只需要几行最关键的代码\r\n\r\n```ts\r\nimport { Background, Layer } from \"./Background.js\";\r\n// 背景city，由1层构成\r\nexport class BackgroundCity extends Background {\r\n  CANVAS_WIDTH: number;\r\n  CANVAS_HEIGHT: number;\r\n  constructor(CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n    super();\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-1.png\",\r\n        2400,\r\n        720,\r\n        0.0\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-2.png\",\r\n        2400,\r\n        720,\r\n        0.1\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-3.png\",\r\n        2400,\r\n        720,\r\n        0.3\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-4.png\",\r\n        2400,\r\n        720,\r\n        0.5\r\n      )\r\n    );\r\n    this.layers.push(\r\n      new Layer(\r\n        CANVAS_WIDTH,\r\n        CANVAS_HEIGHT,\r\n        \"./imgs/cityLayers/layer-5.png\",\r\n        2400,\r\n        720,\r\n        1.0\r\n      )\r\n    );\r\n    this.CANVAS_WIDTH = CANVAS_WIDTH;\r\n    this.CANVAS_HEIGHT = CANVAS_HEIGHT;\r\n  }\r\n  getGroundPosY(): number {\r\n    return this.CANVAS_HEIGHT - 120;\r\n  }\r\n}\r\n```\r\n\r\n## 1.6. 输入监听和状态管理的实现\r\n\r\n原本写的很复杂，最终优化后就成这样了，把状态管理和输入监听解耦了，目前来看还是写的比较精简的\r\n\r\n\r\n### 1.6.1. 输入监听\r\n```ts\r\nimport { ValueOf } from \"./utils.js\";\r\n\r\ntype KeyMapsValues = ValueOf<typeof InputListener.KeyMaps>;\r\nexport class InputListener {\r\n\t// 定义一些静态常量\r\n\tstatic KeyMaps = {\r\n\t\tPressRight: \"ArrowRight\",\r\n\t\tPressLeft: \"ArrowLeft\",\r\n\t\tPressUp: \"ArrowUp\",\r\n\t\tPressDown: \"ArrowDown\",\r\n\t\tPressSpase: \" \",\r\n\t\tEnter: \"Enter\",\r\n\t\tEscape: \"Escape\"\r\n\t} as const; // const 可以保证ValueOf能起作用\r\n\tinputs: Array<KeyMapsValues> = [];\r\n\tconstructor() {\r\n\t\tthis.listenning();\r\n\t}\r\n\tlistenning() {\r\n\t\twindow.addEventListener(\"keydown\", event => {\r\n\t\t\tif (Object.values(InputListener.KeyMaps).includes(event.key as KeyMapsValues)) {\r\n\t\t\t\t// this.inputs.pop(); // 弹出栈顶\r\n\t\t\t\tthis.inputs.unshift(event.key as KeyMapsValues); // 放到开头\r\n\t\t\t}\r\n\t\t});\r\n\t\twindow.addEventListener(\"keyup\", event => {\r\n\t\t\tthis.inputs = []; // 弹出栈顶\r\n\t\t});\r\n\t}\r\n}\r\n```\r\n\r\n### 1.6.2. 状态管理\r\n\r\n状态管理指的是一种设计模式，是一个比较宽泛的概念，这里是我用ts写的，目前来看比较满意的一种写法\r\n```ts\r\nimport { InputListener } from \"./InputListener.js\";\r\nimport { ValueOf } from \"./utils.js\";\r\nexport abstract class State {\r\n\tstateName: string | number | symbol;\r\n\tconstructor(stateName: string | number | symbol) {\r\n\t\tthis.stateName = stateName;\r\n\t}\r\n\tabstract enter(): void;\r\n\tabstract update(timeInterval: number): void;\r\n\tabstract inputsHandler(inputs: Array<ValueOf<typeof InputListener.KeyMaps>>): void;\r\n}\r\n```\r\n\r\n### 1.6.3. 使用状态设计模式实现状态管理Player类的部分代码\r\n\r\n```ts\r\nexport class ShadowDog extends Animal {\r\n\tName = \"ShadowDog\";\r\n\t// 静态属性 状态枚举\r\n\tstatic StateNamesEnum = {\r\n\t\tRunning: \"Running\",\r\n\t\tJumping: \"Jumping\",\r\n\t\tGetHit: \"GetHit\",\r\n\t\tPreDizzy: \"PreDizzy\",\r\n\t\tDizzy: \"Dizzy\",\r\n\t\tDiving: \"Falling\",\r\n\t\tSitting: \"Sitting\",\r\n\t\tBarkting: \"Barkting\",\r\n\t\tDying: \"Dying\"\r\n\t} as const;\r\n\t// 状态map\r\n\tStateMap: { [value in ValueOf<typeof ShadowDog.StateNamesEnum>]?: State } = {};\r\n\t// 当前状态\r\n\tcurrentState!: State;\r\n\tconstructor(){\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Running] = new RunningState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Jumping] = new JumpingState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Diving] = new DivingState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Sitting] = new SittingState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Barkting] = new BarktingState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.GetHit] = new GetHitState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.PreDizzy] = new PreDizzyState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Dizzy] = new DizzyState(this);\r\n\t\tthis.StateMap[ShadowDog.StateNamesEnum.Dying] = new DyingState(this);\r\n\r\n\t\t// setState 要放到最后\r\n\t\tthis.setState(ShadowDog.StateNamesEnum.Running);\r\n\t}\r\n\t\t// 改变状态\r\n\tsetState(stateName: ValueOf<typeof ShadowDog.StateNamesEnum>) {\r\n\t\tthis.currentState = this.StateMap[stateName] as State;\r\n\t\tthis.currentState.enter();\r\n\t}\r\n\t// 更新\r\n\tupdate(timeInterval: number): void {\r\n\t\t// 处理输入\r\n\t\tthis.currentState.inputsHandler(this.Game.InputListener.inputs);\r\n\t\t// 更新\r\n\t\tthis.currentState.update(timeInterval);\r\n\t\t// 基类的更新\r\n\t\tsuper.update(timeInterval);\r\n\t}\r\n}\r\n\r\nclass RunningState extends State {\r\n\tshadowDog: ShadowDog;\r\n\tconstructor(shadowDog: ShadowDog) {\r\n\t\tsuper(ShadowDog.StateNamesEnum.Running);\r\n\t\tthis.shadowDog = shadowDog;\r\n\t}\r\n\tenter(): void {\r\n\t\t// 进入该状态，初始化到该状态\r\n\t\tthis.shadowDog.moveSpeedX = 0;\r\n\t\tthis.shadowDog.moveSpeedY = 0;\r\n\t\tthis.shadowDog.setOnGround();\r\n\t\tthis.shadowDog.changeAnimateByName(\"run\");\r\n\t\t// 场景移动速度\r\n\t\tthis.shadowDog.Game.Scene.setSceneSpeed(-this.shadowDog.maxMoveSpeedX * 0.5);\r\n\t}\r\n\t// 状态的更新\r\n\tupdate(timeInterval: number): void {\r\n\t\t// 添加粒子特效\r\n\t\tthis.shadowDog.Game.Scene.particles.unshift(\r\n\t\t\tnew Dust(this.shadowDog.posX + this.shadowDog.drawWidth / 2, this.shadowDog.posY + this.shadowDog.drawHeight)\r\n\t\t);\r\n\t\t// 检测是否收到伤害\r\n\t\tif (this.shadowDog.isGetHit(this.shadowDog.Game.Scene.enemys)) {\r\n\t\t\tthis.shadowDog.setState(ShadowDog.StateNamesEnum.GetHit);\r\n\t\t\tthis.shadowDog.Game.lives--; // 生命值减一\r\n\t\t}\r\n\t}\r\n\t// 输入处理\r\n\tinputsHandler(inputs: Array<ValueOf<typeof InputListener.KeyMaps>>): void {\r\n\t\t// 如果按下右键，改变速度等的值\r\n\t\tif (inputs.includes(InputListener.KeyMaps.PressRight)) {\r\n\t\t\tthis.shadowDog.moveSpeedX = this.shadowDog.maxMoveSpeedX * 0.5;\r\n\t\t\tthis.shadowDog.Game.Scene.setSceneSpeed(-this.shadowDog.maxMoveSpeedX * 1.0);\r\n\t\t} else if (inputs.includes(InputListener.KeyMaps.PressLeft)) {\r\n\t\t\tthis.shadowDog.moveSpeedX = -this.shadowDog.maxMoveSpeedX * 0.5;\r\n\t\t\tthis.shadowDog.Game.Scene.setSceneSpeed(this.shadowDog.maxMoveSpeedX * 0.5);\r\n\t\t} \r\n\t\t// 按下上键，进入jump状态\r\n\t\telse if (inputs.includes(InputListener.KeyMaps.PressUp)) {\r\n\t\t\tthis.shadowDog.setState(ShadowDog.StateNamesEnum.Jumping);\r\n\t\t} \r\n\t\t// 按下上键，进入sitting状态\r\n\t\telse if (inputs.includes(InputListener.KeyMaps.PressDown)) this.shadowDog.setState(ShadowDog.StateNamesEnum.Sitting);\r\n\t\t// 松开左右按键，恢复速度等的值\r\n\t\telse {\r\n\t\t\tthis.shadowDog.moveSpeedX = 0;\r\n\t\t\tthis.shadowDog.Game.Scene.setSceneSpeed(-this.shadowDog.maxMoveSpeedX * 0.5);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n\r\n\r\n### 1.6.4. 使用状态设计模式实现状态管理Game类的部分代码\r\n\r\n```ts\r\ntype GameStateEnum = ValueOf<typeof Game.StateEnum>;\r\nexport class Game {\r\n\t// 定义一些静态常量表示状态\r\n\tstatic StateEnum = {\r\n\t\tPreview: \"Preview\",\r\n\t\tBeforeRunning: \"BeforeRunning\",\r\n\t\tRunning: \"Running\",\r\n\t\tStop: \"Stop\",\r\n\t\tGameOver: \"GameOver\"\r\n\t} as const;\r\n\tallStates: { [key in GameStateEnum]?: State } = {};\r\n\tcurrentState!: State;\r\n\tInputListener: InputListener;\r\n\tconstructor(Context2D: CanvasRenderingContext2D, CANVAS_WIDTH: number, CANVAS_HEIGHT: number) {\r\n\t\tthis.InputListener = new InputListener();\r\n\t\tthis.UI = new UI(this);\r\n\r\n\t\tthis.allStates[Game.StateEnum.Preview] = new PreviewStatus(this);\r\n\t\tthis.allStates[Game.StateEnum.BeforeRunning] = new BeforeRunning(this);\r\n\t\tthis.allStates[Game.StateEnum.Running] = new RunningStatus(this);\r\n\t\tthis.allStates[Game.StateEnum.Stop] = new StopStatus(this);\r\n\t\tthis.allStates[Game.StateEnum.GameOver] = new GameOverStatus(this);\r\n\t\tthis.setState(Game.StateEnum.Preview);\r\n\t}\r\n\t// 改变状态\r\n\tsetState(StateName: ValueOf<typeof Game.StateEnum>) {\r\n\t\tconsole.log(\"current:\" + StateName);\r\n\t\tthis.currentState = this.allStates[StateName] as State;\r\n\t\tthis.currentState.enter();\r\n\t}\r\n\tupdate(timeInterval: number) {\r\n\t\t// 当前状态对输入的处理\r\n\t\tthis.currentState.inputsHandler(this.InputListener.inputs);\r\n\t\t// 当前状态的更新\r\n\t\tthis.currentState.update(timeInterval);\r\n\t\tthis.UI.update(timeInterval);\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D) {\r\n\t\tthis.Scene.draw(Context2D);\r\n\t\tthis.player.draw(Context2D);\r\n\t\tthis.UI.draw(Context2D);\r\n\t}\r\n\tstart() {\r\n\t\tlet lastTimeStampFromStart = 0;\r\n\t\tconst refreshDisplay = (currentTimeStampFromStart: number) => {\r\n\t\t\tconst timeInterval = currentTimeStampFromStart - lastTimeStampFromStart; // 计算时间间隔\r\n\t\t\tlastTimeStampFromStart = currentTimeStampFromStart;\r\n\t\t\tthis.update(timeInterval);\r\n\t\t\tthis.draw(this.Context2D);\r\n\t\t\trequestAnimationFrame(refreshDisplay);\r\n\t\t};\r\n\t\trefreshDisplay(0);\r\n\t\tconsole.log(\"game is started.\");\r\n\t}\r\n}\r\n\r\n\r\nclass PreviewStatus extends State {\r\n\tGame: Game;\r\n\tconstructor(game: Game) {\r\n\t\tsuper(Game.StateEnum.Preview);\r\n\t\tthis.Game = game;\r\n\t}\r\n\tenter(): void {\r\n\t\t// 进入该状态\r\n\t\tthis.Game.Music.currentTime = 0; // 从头开始播放\r\n\t\tthis.Game.score = 0;\r\n\t\tthis.Game.lives = 1000000000;\r\n\t\tthis.Game.player.setState(ShadowDog.StateNamesEnum.Running);\r\n\t\tthis.Game.UI.addScoreInfos = [];\r\n\t\tthis.Game.Scene.enemys = [];\r\n\t\tthis.Game.Scene.particles = [];\r\n\t\tthis.Game.Scene.explosions = [];\r\n\t\tthis.Game.Scene.spakParticles = [];\r\n\t\treturn;\r\n\t}\r\n\tupdate(timeInterval: number): void {\r\n\t\t// 该状态需要更新的信息，如在stopGame状态，则以下两个信息都不更新就好了\r\n\t\tthis.Game.Scene.update(timeInterval);\r\n\t\tthis.Game.player.update(timeInterval);\r\n\t}\r\n\tinputsHandler(inputs: Array<ValueOf<typeof InputListener.KeyMaps>>) {\r\n\t\t// 输入处理，按下enter开始游戏\r\n\t\tif (inputs.includes(InputListener.KeyMaps.Enter)) {\r\n\t\t\tthis.Game.setState(Game.StateEnum.BeforeRunning);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 1.7. Scene场景\r\n\r\n主要是用来处理当背景移动，游戏中敌人应当随着背景一起移动的问题，\r\n\r\n这里我写了一个场景类，把需要跟随场景移动的东西都放进去，\r\n\r\n由该类来处理场景的移动速度和场景中物体坐标更新的问题\r\n\r\n以下是部分代码\r\n\r\n```ts\r\nexport class Scene {\r\n\tGame: Game;\r\n\tprivate SceneSpeed = 0;\r\n\tbackground: Background;\r\n\tconstructor(Game: Game) {\r\n\t\tthis.Game = Game;\r\n\t\tthis.background = new BackgroundCity(this.Game.GAME_WIDTH, this.Game.GAME_HEIGHT);\r\n\t}\r\n\t// 这一步最关键，处理死亡的敌人，\r\n\t// 另外还要更具场景移动速度，重新计算场景中敌人的位置\r\n\tupdate(timeInterval: number) {\r\n\t\t// handles\r\n\t\tthis.enemysHandle(timeInterval);\r\n\t\t// 最值处理，限制粒子特效的数量\r\n\t\tif (this.particles.length > this.particlesMaxLength) this.particles.length = this.particlesMaxLength;\r\n\t\tif (this.spakParticles.length > this.spakParticlesMaxLength) this.spakParticles.length = this.spakParticlesMaxLength;\r\n\t\t// 更新\r\n\t\t// 更新背景的移动速度\r\n\t\tthis.background.setSpeed(this.SceneSpeed);\r\n\t\tthis.background.update(timeInterval);\r\n\t\t// 移除死亡和超出屏幕的敌人\r\n\t\tthis.enemys = this.enemys.filter(item => {\r\n\t\t\treturn !item.isOutOfLeftScreem() && item.getAliveFlag();\r\n\t\t});\r\n\t\t// 更新和重新计算敌人的坐标\r\n\t\tthis.enemys.forEach(item => {\r\n\t\t\titem.update(timeInterval);\r\n\t\t\titem.transform(this.SceneSpeed * timeInterval, 0);\r\n\t\t});\r\n\t\t// 更新和重新计算粒子特效的坐标\r\n\t\tthis.particles.forEach(item => {\r\n\t\t\titem.update(timeInterval);\r\n\t\t\titem.posX += this.SceneSpeed * timeInterval;\r\n\t\t});\r\n\t\tthis.explosions = this.explosions.filter(item => {\r\n\t\t\titem.update(timeInterval);\r\n\t\t\titem.posX += this.SceneSpeed * timeInterval;\r\n\t\t\treturn !item.isLastAnimateFrame();\r\n\t\t});\r\n\t\tthis.spakParticles.forEach(item => {\r\n\t\t\titem.update(timeInterval);\r\n\t\t\titem.posX += this.SceneSpeed * timeInterval;\r\n\t\t});\r\n\t}\r\n\t// 绘制场景中的物体\r\n\tdraw(Context2D: CanvasRenderingContext2D) {\r\n\t\tthis.background.draw(Context2D);\r\n\t\tthis.enemys.forEach(item => item.draw(Context2D));\r\n\t\tthis.explosions.forEach(item => item.draw(Context2D));\r\n\t\tthis.particles.forEach(item => item.draw(Context2D));\r\n\t\tthis.spakParticles.forEach(item => item.draw(Context2D));\r\n\t}\r\n\t// 设置场景移动速度\r\n\tsetSceneSpeed(newSpeed: number) {\r\n\t\tthis.SceneSpeed = newSpeed;\r\n\t\treturn;\r\n\t}\r\n\tenemysHandle(timeInterval: number) {\r\n\t\t// 周期添加敌人\r\n\t\tif ((this.addEnemyTimer += timeInterval) >= this.addEnemyIntermval) {\r\n\t\t\tthis.addEnemyTimer = 0;\r\n\t\t\tswitch (Math.floor(RandomRange(0, 6))) {\r\n\t\t\t\tcase 0: // 略\r\n\t\t\t\tcase 1:\r\n\t\t\t\tcase 2:\r\n\t\t\t\tcase 3:\r\n\t\t\t\tcase 4:\r\n\t\t\t\tcase 5:\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 1.8. UI\r\n\r\nUI这部分代码写的又长又丑，只看结构\r\n```ts\r\nimport { Game } from \"./Game.js\";\r\n\r\ntype addScoreInfo = { posX: number; posY: number; score: string };\r\nexport class UI {\r\n\tGame: Game;\r\n\tlivesImg: HTMLImageElement;\r\n\timgWidth: number;\r\n\timgHeight: number;\r\n\timgDrawWidth: number;\r\n\timgDrawHeight: number;\r\n\taddScoreInfos: Array<addScoreInfo> = [];\r\n\r\n\tconstructor(Game: Game) {\r\n\t\tthis.Game = Game;\r\n\t\tthis.livesImg = new Image();\r\n\t\tthis.livesImg.src = \"./imgs/heart.png\";\r\n\t\tthis.imgWidth = 50;\r\n\t\tthis.imgHeight = 50;\r\n\t\tthis.imgDrawWidth = 40; //this.imgWidth * 0.5;\r\n\t\tthis.imgDrawHeight = 40; // this.imgHeight * 0.5;\r\n\t}\r\n\t// 对漂浮的分数的坐标的计算\r\n\tupdate(timeInterval: number) {\r\n\t\tconst targetPosX = 200;\r\n\t\tconst moveSpeedX = 0.1;\r\n\t\tconst targetPosY = 80;\r\n\t\tconst moveSpeedY = 0.1;\r\n\t\t// 这里做的操作是更新数组中的坐标，使其朝着 targetPos 所在的坐标移动\r\n\t\tthis.addScoreInfos = this.addScoreInfos\r\n\t\t\t.map(item => {\r\n\t\t\t\tconst stepX = moveSpeedX * timeInterval;\r\n\t\t\t\tconst stepY = moveSpeedY * timeInterval;\r\n\t\t\t\tif (item.posX - targetPosX >= stepX) item.posX -= stepX;\r\n\t\t\t\telse if (item.posY - targetPosY <= stepX) item.posX += stepX;\r\n\t\t\t\tif (item.posY - targetPosY >= stepY) item.posY -= stepY;\r\n\t\t\t\telse if (item.posY - targetPosY <= stepY) item.posY += stepY;\r\n\r\n\t\t\t\tconst gapX = Math.abs(item.posX - targetPosX);\r\n\t\t\t\tconst gapY = Math.abs(item.posY - targetPosY);\r\n\t\t\t\tif (gapX < stepY && gapY < stepX) {\r\n\t\t\t\t\t// 当前坐标和目标坐标之间的距离小于步长，则移除该项\r\n\t\t\t\t\treturn null as unknown as addScoreInfo;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn item;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.filter(item => item != null);\r\n\t}\r\n\tdraw(Context2D: CanvasRenderingContext2D) {\r\n\t\tContext2D.save();\r\n\t\tconst txtSize = 40;\r\n\t\tconst ShadowWidth = 2;\r\n\t\tContext2D.font = `${txtSize}px HanaleiFill`;\r\n\r\n\t\tif (this.Game.currentState.stateName == Game.StateEnum.Preview) {\r\n\t\t\t// 预览界面：显示按下什么键开始游戏\r\n\t\t} else if (this.Game.currentState.stateName == Game.StateEnum.Running) {\r\n\t\t\t// 游戏运行界面\r\n\t\t\t// 绘制剩余的生命\r\n\t\t\tfor (let index = 0; index < this.Game.lives; index++) {\r\n\t\t\t\tContext2D.drawImage(\r\n\t\t\t\t\tthis.livesImg,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\t0,\r\n\t\t\t\t\tthis.imgWidth,\r\n\t\t\t\t\tthis.imgHeight,\r\n\t\t\t\t\tindex * (this.imgDrawWidth + 10) + 10,\r\n\t\t\t\t\t5,\r\n\t\t\t\t\tthis.imgDrawWidth,\r\n\t\t\t\t\tthis.imgDrawHeight\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\t// 绘制漂浮的得分数字\r\n\t\t\tthis.addScoreInfos.forEach(item => {\r\n\t\t\t\tContext2D.textAlign = \"left\";\r\n\t\t\t\tContext2D.fillStyle = \"white\";\r\n\t\t\t\tContext2D.fillText(item.score, item.posX, item.posY);\r\n\t\t\t\tContext2D.fillStyle = \"black\";\r\n\t\t\t\tContext2D.fillText(item.score, item.posX + ShadowWidth, item.posY + ShadowWidth);\r\n\t\t\t});\r\n\t\t} else if (this.Game.currentState.stateName == Game.StateEnum.Stop) {\r\n\t\t\t// 游戏暂停界面\r\n\t\t\t// 显示按下什么键继续游戏\r\n\t\t\t\r\n\t\t} else if (this.Game.currentState.stateName == Game.StateEnum.GameOver) {\r\n\t\t\t// 游戏结束界面，显示分数\r\n\t\t}\r\n\t\tContext2D.restore();\r\n\t}\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 1.9. 字体\r\n```css\r\n// 这一步相当于是注册了一个字体，而后页面中就可以使用 `HanaleiFill` 这个字体\r\n@font-face {\r\n\tfont-family: \"HanaleiFill\";\r\n\tsrc: url(../font/HanaleiFill-Regular.ttf);\r\n}\r\n```\r\n\r\n**如**\r\n```ts\r\nContext2D.font = `${txtSize}px HanaleiFill`;\r\n```\r\n\r\n**监听页面加载完毕事件和字体加载事件**\r\n\r\n`document.fonts` 的值是文档的 FontFaceSet 接口。FontFaceSet 接口 用于 对 加载新字体、检查已加载字体的加载状态。\r\n\r\n```ts\r\nwindow.addEventListener(\"load\", () => {\r\n\t// 字体加载完成后的逻辑\r\n\tdocument.fonts.ready.then(() => {\r\n\t\t// 此时DOM中的资源和字体就以加载完毕了\r\n\t}\r\n}\r\n```\r\n\r\n## 1.10. Canvas铺满页面屏幕的实现\r\n```less\r\n* {\r\n\tpadding: 0;\r\n\tmargin: 0;\r\n\tbox-sizing: border-box;\r\n\toverflow: hidden;\r\n}\r\nhtml,\r\nbody {\r\n\tposition: relative;\r\n\twidth: 100vw;\r\n\theight: 100vh;\r\n\t#myCanvas,\r\n\t#loading {\r\n\t\t// 居中\r\n\t\tposition: absolute;\r\n\t\tleft: 50%;\r\n\t\ttop: 50%;\r\n\t\ttransform: translate(-50%, -50%);\r\n\t\t// 关键：设置最大宽度为屏幕宽高的100%\r\n\t\tmax-width: 100vw;\r\n\t\tmax-height: 100vh;\r\n\t}\r\n}\r\n```\r\n\r\n\r\n## 1.11. 自写工具类\r\n\r\n没什么好讲的，主要看注释和用例\r\n\r\n```ts\r\nexport function RandomRange(from: number, to: number) {\r\n\treturn Math.random() * (to - from) + from;\r\n}\r\n\r\n// 注意传入的T需用as const修饰，否则被当做字符串\r\nexport type ValueOf<T> = T[keyof T];\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>\r\n\r\n"}