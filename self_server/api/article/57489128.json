{"shortInfo":{"title":"js返回顶部","date":"2022-07-06T13:33:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["返回顶部","js"],"hideAtIndex":true,"categories":"笔记","id":57489128,"countWords":766,"readSeconds":76.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# js返回顶部\r\n\r\n## 主要思路\r\n* 需要有动态效果\r\n* 需要重新封装animate动画函数\r\n* `window.scroll(x,y)` 函数用于设置页面窗口滚动位置\r\n* `window.pageYOffset` 窗口滚动内容的上边距\r\n\r\n## 结束条件的问题\r\n由于鼠标滚动的原因，`window.pageYOffset`是含小数部分的，且目标位置`target`是整数，计算的步长`step`也是取整数，  \r\n这就导致`window.pageYOffset+step`永远也不会等于target   \r\n所以结束的判断条件只判断整数部分就好了：  \r\n```js\r\nif(parseInt(window.pageYOffset)==parseInt(targetY))\r\n{\r\n\r\n}\r\n```\r\n\r\n## 防止目标值过大的问题\r\n如果body的高度只有1000px，而指定target到2000px，这是不可能实现的，这会导致页面滚动到底部，且无法拖动滚动条，所以需要计算出target的最大值，以对其进行限制\r\n\r\n**相关属性**\r\n* `window.innerHeight`表示窗口内容区域的高度，这是不包括边框、菜单栏的。\r\n* `window.outerHeight`是窗口的整体高度，包括边框、菜单栏等。\r\n* `document.body.offsetHeight` 可以获得页面的高度\r\n\r\n所以，可以计算出当页面滚动条在底部时，pageYOffset的高度为：`document.body.offsetHeight-window.innerHeight`\r\n\r\n## 保持X轴的滚动条位置不变\r\n\r\n只需要把X偏移保持就好了\r\n\r\n```js\r\n\r\nwindow.scroll(window.pageXOffset, x的偏移 )\r\n\r\n```\r\n\r\n\r\n## 效果及源码\r\n\r\n<button id=\"returnTop\">动态返回顶部</button>\r\n<button id=\"returnMiddle\">动态返回中部</button>\r\n<button id=\"returnBottom\">动态返回底部</button>\r\n<script>\r\n    var returnTop = document.querySelector(\"#returnTop\")\r\n    var returnBottom = document.querySelector(\"#returnBottom\")\r\n    var returnMiddle = document.querySelector(\"#returnMiddle\")\r\n    returnTop.addEventListener(\"click\", function () {\r\n        //返回顶部\r\n        animateWinScrollToY(0);\r\n    })\r\n    returnBottom.addEventListener(\"click\", function () {\r\n        //返回底部\r\n        animateWinScrollToY(document.body.offsetHeight - window.innerHeight);\r\n    })\r\n    returnMiddle.addEventListener(\"click\", function () {\r\n        //返回中部\r\n        animateWinScrollToY( (document.body.offsetHeight - window.innerHeight) /2);\r\n    })\r\n    function animateWinScrollToY(targetY, callback) {\r\n        if (document.body.offsetHeight - window.innerHeight >= targetY) {//防止targetY过大导致死循环\r\n            clearInterval(window.returnTopTimer)//防止被反复调用\r\n            window.returnTopTimer = setInterval(function () {\r\n                if (parseInt(window.pageYOffset) == parseInt(targetY))//因为滚动的距离存在小数，所以这里只判断整数部分是否接近就好了\r\n                {\r\n                    clearInterval(window.returnTopTimer);\r\n                    callback && callback();\r\n                    // console.log(\"到达目标位置\");\r\n                }\r\n                else\r\n                {\r\n                    window.step = (targetY - window.pageYOffset) / 10 //根据公式计算步长\r\n                    window.step = window.step <= 0 ? Math.floor(window.step) : Math.ceil(window.step); //上下取整，防止小数\r\n                    window.scroll(window.pageXOffset, window.pageYOffset + window.step);\r\n                }\r\n            }, 15)\r\n        }\r\n    }\r\n</script>\r\n\r\n```html\r\n<button id=\"returnTop\">动态返回顶部</button>\r\n<button id=\"returnMiddle\">动态返回中部</button>\r\n<button id=\"returnBottom\">动态返回底部</button>\r\n<script>\r\n    var returnTop = document.querySelector(\"#returnTop\")\r\n    var returnBottom = document.querySelector(\"#returnBottom\")\r\n    var returnMiddle = document.querySelector(\"#returnMiddle\")\r\n    returnTop.addEventListener(\"click\", function () {\r\n        //返回顶部\r\n        animateWinScrollToY(0);\r\n    })\r\n    returnBottom.addEventListener(\"click\", function () {\r\n        //返回底部\r\n        animateWinScrollToY(document.body.offsetHeight - window.innerHeight);\r\n    })\r\n    returnMiddle.addEventListener(\"click\", function () {\r\n        //返回中部\r\n        animateWinScrollToY( (document.body.offsetHeight - window.innerHeight) /2);\r\n    })\r\n    function animateWinScrollToY(targetY, callback) {\r\n        if (document.body.offsetHeight - window.innerHeight >= targetY) {//防止targetY过大导致死循环\r\n            clearInterval(window.returnTopTimer)//防止被反复调用\r\n            window.returnTopTimer = setInterval(function () {\r\n                if (parseInt(window.pageYOffset) == parseInt(targetY))//因为滚动的距离存在小数，所以这里只判断整数部分是否接近就好了\r\n                {\r\n                    clearInterval(window.returnTopTimer);\r\n                    callback && callback();\r\n                    // console.log(\"到达目标位置\");\r\n                }\r\n                else\r\n                {\r\n                    window.step = (targetY - window.pageYOffset) / 10 //根据公式计算步长\r\n                    window.step = window.step <= 0 ? Math.floor(window.step) : Math.ceil(window.step); //上下取整，防止小数\r\n                    window.scroll(window.pageXOffset, window.pageYOffset + window.step);\r\n                }\r\n            }, 15)\r\n        }\r\n    }\r\n</script>\r\n```"}