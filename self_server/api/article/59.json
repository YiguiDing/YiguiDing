{"shortInfo":{"title":"《数据结构与算法分析》第3章_2.表","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-24T05:16:26.000Z","modified":"2022-05-28T11:45:44.760Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":59,"countWords":2422,"readSeconds":242.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第3章_2.表\r\n### 表ADT\r\n* 形如A1、A2、A3、A4......Ax的表 表的大小是N\r\n* 大小为0的表为空表\r\n* 对于除空表以为外的任何表，称Ai+1后继Ai 或者说 Ai+1继Ai之后 同时称Ai-1 前驱Ai\r\n* 表中第一个元素是A1 最后一个元素是A_N\r\n* 不定义A1的前驱元，也不定义A_N的后继元\r\n* 元素Ai在表中的位置为i\r\n\r\n### 表ADT的数据操作\r\n一些常见的操作\r\n* printList 打印输出这个表的内容\r\n* makeEmpty 创建一个空表\r\n* Find 返回关键字首次出现的位置\r\n* Insert 在指定位置之后插入某个关键字\r\n* Delete 删除指定位置的关键字\r\n* FindKth 返回某个位置上的元素\r\n* Next 返回其后继元的位置\r\n* Previous 返回期前继元的位置\r\n\r\n## 表的简单数组实现\r\n* 空间代价：\r\n  + 数组可以是动态指定的 （malloc）\r\n  + 需要对表的大小进行最大值估计 通常会估计的大一些，会浪费大量空间，是严重的局限\r\n* 时间代价：\r\n  + printList和Find操作花费线性时间\r\n  + FindKth花费常数时间\r\n  + 插入操作花费昂贵，如果插入一个元素在0的位置，那么其余所有元素将向后挪（复制）\r\n  + 删除操作花费昂贵，如果删除第一个元素，那么其余所有元素将全部向前挪（复制）\r\n  + 平均来看，插入和删除操作都需要移动一半的元素，要花费线性时间\r\n  + 通过N次插入操作来建立一个表需要花费二次时间。\r\n\r\n## 表的链表实现\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-25-20-38-41.png)\r\n* 为避免插入和删除的线性开销，需要允许表可以不连续存储（避免表部分或整体全部移动）。\r\n* 链表结构不必在内存中连续\r\n* 每一个结构含有一个**表元素**和一个**后继元的结构的指针**，称为Next指针\r\n* 最后一个单元的Next指向NULL（具体值由c定义，ansiC规定NULL为0）\r\n* 空间代价：\r\n  + 数组的元素可以在需要插入元素的时候再从内存开辟空间\r\n* 时间代价：\r\n  + PrintList(L)和Find(L,key)花费线性时间\r\n  + FindKth(L,i)花费O(i)时间\r\n  + 删除操作通过修改指针完成\r\n  + 插入操作通过执行两次指针调整完成（需先为新元素分配内存）\r\n* 问题\r\n  + 仅从链表的定义出发，无法在一个元素的前面插入一个元素，因为你只能知道当前表的内容和后继表的指针\r\n  + 在第一个元素位置做表的删除操作，可能导致整个表的丢失。\r\n  + 删除算法要求知道被删除元素的前一个元素的指针，因为需要将前一个元素的Next指针指向后一个元素的地址\r\n* 解决方法：增添表头\r\n  + 表头（header）或哑节点（dummy node）\r\n  + 表头位置为0 第一个元素的位置为1\r\n  + 是否使用头节点是有争议的，但使用头节点将不用再去考虑一些特殊情况\r\n  + 为避免删除算法的问题，需编写一个FindPrevious 将返回被删除元素的前一个元素，这样删除第一个元素时将返回表头的位置\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-25-20-38-23.png)\r\n\r\n### 例程\r\n* 按照C的约定，类型声明以及函数的原型都写在.h头文件中。\r\n* 具体的类型定义写在.c文件中。\r\n\r\n```c\r\n//List.h\r\n#ifndef _List_H_\r\n#define _List_H_\r\n\r\ntypedef int ElementType;\r\n\r\ntypedef struct Node* PtrToNode;\r\ntypedef PtrToNode List;\r\ntypedef PtrToNode Position;\r\n\r\nList MakeEmpty(List L);\r\nint isEmpty(List L);\r\nint isLast(Position P,List L);\r\nPosition Find(ElementType X,List L);\r\nvoid Delete(ElementType X,List L);\r\nPosition FindPrevious(ElementType X,List L);\r\nvoid Insert(ElementType X,List L,Position P);\r\nvoid DeleteList(List L);\r\nPosition Header(List L);\r\nPosition First(List L);\r\nPosition Advance(Position P);\r\nElementType Retrieve(Position P);\r\n\r\n#endif\r\n```\r\n* 注意，Insert例程和IsLast例程都传入了表L参数，尽管它从未被使用过。之所以这么做，是因为别的实现方法可能会需要这些信息，因此，若不传递表L有可能使得使用ADT的想法失败。\r\n\r\n```c\r\n// List.c\r\n#include\"List.h\"\r\n#include<stdlib.h>\r\nstruct Node\r\n{\r\n  ElementType Element;\r\n  Position Next;\r\n};\r\n\r\nList MakeEmpty(List L)\r\n{\r\n    if (L->Next)\r\n    {\r\n        MakeEmpty(L->Next);\r\n        free(L->Next);\r\n    }\r\n    return L;\r\n}\r\nint IsEmpty(List L)//测试空表\r\n{\r\n  return L->Next==NULL;\r\n}\r\nint IsLast(Position P,List L)//测试当前位置是否为链表尾部\r\n{\r\n  return P->Next == NULL;\r\n}\r\nPosition Find(ElementType X,List L)//查找一个元素，返回他的地址\r\n{\r\n  Position P;\r\n  P=L->Next;\r\n  while(P!=NULL && P->Element!=X)//避免用递归来实现\r\n    P=P->Next;\r\n  return P;//特殊情况：如果为空表将返回表头地址，如果查找不到将返回尾部元素地址\r\n}\r\nvoid Delete(ElementType X,List L)//查找并删除一个元素\r\n{\r\n  Position P,tempCell;\r\n  P = FindPrevious(X,L);\r\n\r\n  if(!isLast(P,L))\r\n  {\r\n    tempCell=P->Next;\r\n    P->Next=tempCell->Next;\r\n    free(tempCell);\r\n  }\r\n}\r\nPosition FindPrevious(ElementType X,List L)\r\n{\r\n  Position P;\r\n  P=L;//从表头开始查找\r\n  while(P->Next!=NULL && P->Next->Element!=X)\r\n    P=P->Next;\r\n  return P;//特殊情况：如果为空表则返回表头的地址，如果查找不到则返回最后一个元素的地址\r\n}\r\nvoid Insert(ElementType X,List L,Position P)//插入一个元素到P之后\r\n{\r\n  Position TempCell;\r\n  TempCell=malloc(sizeof(struct Node));\r\n  if(TempCell==NULL)\r\n    ;//out of space\r\n  TempCell->Element=X;\r\n\r\n  TempCell=P->Next;\r\n  P->Next=TempCell;\r\n}\r\nvoid DeleteList(List L)\r\n{\r\n  Position P,temp;\r\n  P=L->Next;\r\n  L->Next=NULL;//头元素不删除\r\n  while(P!=NULL)\r\n  {\r\n    temp=P->Next;\r\n    free(P);\r\n    P=temp;\r\n  }\r\n}\r\nPosition Header(List L)\r\n{\r\n  return L;\r\n}\r\nPosition First(List L)\r\n{\r\n  return L->Next;\r\n}\r\nPosition Advance(Position P)\r\n{\r\n  return P->Next;\r\n}\r\nElementType Retrieve(Position P)\r\n{\r\n  return P->Element;\r\n}\r\n```\r\n\r\n### 双链表\r\n* 解决问题：解决单链表无法倒序扫描的问题\r\n* 代价\r\n  + 空间代价：数据结构中增添的一个指针域\r\n  + 时间代价：\r\n    + 简化了删除操作，原先无法得知前驱元素的指针，现在这个指针是现成的\r\n    + 插入和删除操作的开销增加了一倍，因为多了一倍量的指针需要定位\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-25-20-34-07.png)\r\n\r\n### 循环链表\r\n* 一种流行的做法\r\n* 让最后一个元素的指针域指向第一个元素\r\n* 可以有表头，也可以没有\r\n* 如果有表头，最后一个元素的指针域指向表头\r\n* 可以同时也是双向链表\r\n* 下图为无头循环双链表\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-25-20-46-45.png)\r\n\r\n## 三个使用链表的例子\r\n* 一元多项式\r\n* 基数排序（以线性时间进行）\r\n* 学生课程选课系统\r\n\r\n### 一元多项式(结构体+数组方式实现)\r\n* 如果一个一元的多项式的系数大部分为非零（稠密多项式），那么可以用一个数组来存储这些系数，同时用一个变量来记录这个多项式的最高次项的指数，将其用一个结构体存储，继而可以写出其加减乘微分的操作函数。\r\n\r\n```c\r\n#define MaxDegree 100\r\n\r\nstruct polynomial{//存储一个多项式\r\n  int coeffArray[MaxDegree];//存储各项系数，coeffArray[0] 存储x^0项的系数\r\n  int HighPower;//存储最高此项的指数\r\n};\r\n\r\ntypedef struct polynomial Polynomial;\r\ntypedef struct polynomial* PPolynomial;\r\n\r\nvoid ZeroPolynomial(PPolynomial Poly)//初始化一个多项式\r\n{\r\n  int i;\r\n  for(i=0;i<MaxDegree;i++)\r\n    Poly->coeffArray[i]=0;\r\n  Poly->HighPower=0;\r\n}\r\nvoid AddPolynomial(PPolynomial A1,PPolynomial A2,PPolynomial Result)//加法\r\n{\r\n  int i,j;\r\n  for(i=0;i<MaxDegree;i++)\r\n        Result->coeffArray[i] = A1->coeffArray[i] + A2->coeffArray[j] ;\r\n  Result->HighPower = (A1->HighPower > A2->HighPower)? A1->HighPower : A2->HighPower ;\r\n}\r\nvoid multiplePolynomial(PPolynomial A1,PPolynomial A2,PPolynomial Result)//乘法\r\n{\r\n  if(A1->HighPower + A2->HighPower  >= MaxDegree)\r\n  {\r\n    //out of memory\r\n    return;\r\n  }\r\n  int i,j;\r\n  for(i=0;i<MaxDegree;i++)\r\n  {\r\n    for(j=0;j<MaxDegree;j++)\r\n    {\r\n      Result->coeffArray[i+j] += A1->coeffArray[i] * A2->coeffArray[j] ;\r\n    }\r\n  }\r\n  Result->HighPower = A1->HighPower + A2->HighPower;\r\n}\r\n```\r\n\r\n### 一元多项式(链表方式实现)\r\n* 非稠密多项式用上述方式实现会遇到很多问题，\r\n  + 如当多项式的最高次项为1000，那么用上述方式就需要保存1001个系数，造成空间资源的浪费；\r\n  + 如果这个多项式的系数只有最高次项和最低次项有值其余次项的系数基本上全都是0，那么在做加法运算的时候程序会去计算系数为零的项，造成计算资源的浪费。\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-26-18-46-12.png)\r\n\r\n```c\r\n\r\nstruct Node{\r\n  int Coeff;\r\n  int Exponent;\r\n  struct Node Next;\r\n};\r\ntypedef Node* PPolynomial;\r\ntypedef Node Polynomial;\r\n\r\nvoid addPolynomial(PPolynomial A1,PPolynomial A2,PPolynomial Result)\r\n{\r\n  \r\n}\r\n\r\n\r\n```\r\n\r\n### 基数排序\r\n* 预备知识：桶排序\r\n* 基数排序是桶排序的推广\r\n* 通过从低到高比较基数大小来进行多次桶排序\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-26-20-24-04.png)\r\n\r\n桶排序概念实现\r\n```c\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<time.h>\r\nint main()\r\n{\r\n  int count[100]={0};\r\n  int num[100];\r\n\r\n  int i,j;\r\n  for(i=0;i<100;i++)//随机赋值0~100\r\n    num[i]=(srand(rand()+clock()),rand()%100);\r\n  \r\n  for(i=0;i<100;i++)//桶排序\r\n    count[num[i]]++;\r\n  \r\n  for(i=0;i<100;i++)//输出\r\n    for(j=0;j<count[i];j++)\r\n      printf(\"%4d\",i);\r\n}\r\n\r\n```\r\n\r\n基数排序实现\r\n```c\r\n//略\r\n```\r\n\r\n### 多重表\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-26-22-47-09.png)\r\n\r\n### 链表的游标实现\r\n* 解决一些语言中没有指针的问题\r\n* 需要提前申请一个足够长的数组\r\n* 需要另外一个数组记录内存的分配情况\r\n* 编写函数模拟malloc() 和free()操作\r\n* malloc()就是从数组中查找出一个未被使用的位置，标记其为被占用，返回该元素的索引位置\r\n* free()操作就是标记一个区域为未被占用\r\n* 链表的指针域存储的是索引值\r\n```c\r\n//略\r\n```\r\n\r\n"}