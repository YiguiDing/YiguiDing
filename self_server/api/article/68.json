{"shortInfo":{"title":"《数据结构与算法分析》第4章_7.AVL树的实现","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-06-01T13:54:05.000Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":68,"countWords":748,"readSeconds":74.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_7.AVL树的实现\r\n* **AvlTree.h**\r\n```c\r\n#ifndef _AvlTree_H_\r\n#define _AvlTree_H_\r\n\r\ntypedef int ElementType;\r\nstruct AvlTreeNode;\r\ntypedef struct AvlTreeNode *Position;\r\ntypedef struct AvlTreeNode *AvlTree;\r\n\r\nAvlTree MakeEmpty(AvlTree T);\r\nAvlTree Insert(ElementType X,AvlTree T);//插入操作应该返回根节点地址，所以返回值是树\r\nAvlTree Delete(ElementType X,AvlTree T);//同上\r\nPosition Find(ElementType X,AvlTree T);\r\nPosition FindMax(AvlTree T);\r\nPosition FindMin(AvlTree T);\r\nElementType Retrieve(Position P);\r\n#endif\r\n```\r\n\r\n* **AvlTree.c**\r\n```c\r\n//      不是标准答案，可能会有错\r\n//      另外Delete操作会比Insert操作还要复杂，书中暂未讨论\r\n//      如果Delete操作采用懒惰删除的话，需要注意修改查找和插入操作的判断条件\r\n#include \"AvlTree.h\"\r\n#include <stdlib.h>\r\nstruct AvlTreeNode\r\n{\r\n    ElementType Element;\r\n    int Hight;\r\n    AvlTree Left;\r\n    AvlTree Right;\r\n};\r\n\r\nAvlTree MakeEmpty(AvlTree T)\r\n{\r\n    if (T != NULL)\r\n    {\r\n        MakeEmpty(T->Left);\r\n        MakeEmpty(T->Right);\r\n        free(T);\r\n    }\r\n    return T;\r\n}\r\nAvlTree Insert(ElementType X, AvlTree T) //插入操作应该返回根节点地址，所以返回值是树\r\n{\r\n    if (T==NULL)\r\n    {\r\n        T=malloc(sizeof(struct AvlTreeNode));\r\n        if(T==NULL)\r\n            FatalError(\"out of memory\");\r\n        T->Element=X;\r\n        T->Hight=0;\r\n    }else if(X<T->Element)\r\n    {\r\n        T->Left=Insert(X,T->Left); //插入进左子树\r\n        if(Hight(T->Left)-Hight(T->Right)==2) //左子树高减右子树高\r\n            if(X<T->Left->Element) //判断是否插入在了左子树的左子树\r\n                T=singleRotateToRight(T);\r\n            else //否则插入在了左子树的右子树\r\n                T=doubleRotateToRight(T);\r\n    }else if(X>T->Element)\r\n    {\r\n        T->Right=Insert(X,T->Right);\r\n        if(Hight(T->Right)-Hight(T->Left)==2)\r\n            if(X>T->Right->Element)\r\n                T=singleRotateToLeft(T);\r\n            else\r\n                T=doubleRotateToLeft(T);\r\n    }else if(X==T->Element)\r\n        ;\r\n    \r\n    // 如果其最高子树是一颗空树(-1) 那么当前树的高度应该是-1+1=0\r\n    // 如果其最高子树是一片叶子(0) 那么当前树的高度应该是0+1=1\r\n    // 如果其最高子树有一片叶子(1) 那么当前树的高度应该是1+1=1\r\n    T->Hight = MAX(Hight(T->Left),Hight(T->Right)) + 1;\r\n    return T;\r\n}\r\nAvlTree Delete(ElementType X, AvlTree T)\r\n{\r\n}\r\nPosition Find(ElementType X, AvlTree T)\r\n{\r\n    if (T == NULL)\r\n        return T;\r\n    else if (X < T->Element)\r\n        return Find(X, T->Left);\r\n    else if (X > T->Element)\r\n        return Find(X, T->Right);\r\n    else\r\n        return T;\r\n}\r\nPosition FindMax(AvlTree T)\r\n{\r\n    if (T == NULL)\r\n        return T;\r\n    else if (T->Right == NULL)\r\n        return T;\r\n    else\r\n        return FindMax(T->Right);\r\n}\r\nPosition FindMin(AvlTree T)\r\n{\r\n    if (T == NULL)\r\n        return T;\r\n    else if (T->Left == NULL)\r\n        return T;\r\n    else\r\n        return FindMin(T->Left);\r\n}\r\nElementType Retrieve(Position P)\r\n{\r\n    return P != NULL ? P->Element : 0;\r\n}\r\nstatic int MAX(int a,int b)\r\n{\r\n    return a>b? a:b;\r\n}\r\nstatic int Hight(AvlTree T)\r\n{\r\n    if (T==NULL)\r\n        return -1;\r\n    else\r\n        return T->Hight;\r\n}\r\n\r\nstatic AvlTree singleRotateToRight(AvlTree T)\r\n{   //调整指针\r\n    AvlTree newRoot=T->Left;\r\n    T->Left=newRoot->Right;\r\n    newRoot->Right=T;\r\n    //更新高度时应该先更新子节点再更新根节点\r\n    T->Hight=MAX(Hight(T->Left),Hight(T->Right))+1;\r\n    newRoot->Hight=MAX(Hight(newRoot->Left),Hight(newRoot->Right))+1;\r\n    return newRoot;\r\n}\r\n\r\nstatic AvlTree singleRotateToLeft(AvlTree T)\r\n{   //调整指针\r\n    AvlTree newRoot=T->Right;\r\n    T->Right=newRoot->Left;\r\n    newRoot->Left=T;\r\n    //更新高度时应该先更新子节点再更新根节点\r\n    T->Hight=MAX(Hight(T->Left),Hight(T->Right))+1;\r\n    newRoot->Hight=MAX(Hight(newRoot->Left),Hight(newRoot->Right))+1;\r\n    return newRoot;\r\n}\r\n\r\nstatic AvlTree doubleRotateToRight(AvlTree T)\r\n{\r\n    T->Left=singleRotateToLeft(T->Left);//先对根节点的左子树做右旋操作\r\n    return singleRotateToRight(T);//再对根节点做左旋操作\r\n}\r\n\r\nstatic AvlTree doubleRotateToLeft(AvlTree T)\r\n{\r\n    T->Right=singleRotateToRight(T->Right);//先对根节点的左子树做左旋操作\r\n    return singleRotateToLeft(T);//再对根节点做右旋操作\r\n}\r\n```"}