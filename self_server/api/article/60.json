{"shortInfo":{"title":"《数据结构与算法分析》第3章_3.栈","cover":"/self_server/assets/images/《数据结构与算法分析》学习笔记/cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-26T06:50:00.000Z","modified":"2022-05-26T21:34:18.337Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":60,"countWords":954,"readSeconds":95.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第3章_3.栈\r\n* 栈(stack)是限制插入和删除只能在一个位置上进行的表\r\n* 栈有时也被叫做LIFO表（先进后出）\r\n* 栈的基本操作\r\n  + Push进栈（压入）\r\n  + Pop出栈（弹出）\r\n* 对空栈进行Pop操作被认为是栈ADT的错误\r\n* Push操作直到空间用尽被认为是现实错误，但不是ADT错误\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-01-52-09.png)\r\n\r\n## 栈的链表实现\r\n* 优点：所有操作花费常数时间\r\n* 缺点：对malloc和free的开销是昂贵的\r\n  + 解决办法：使用第二个栈来避免，当弹出第一个栈中元素时，将被弹出元素放到第二个栈中，待到下一次第一个栈中需要压入元素时，先去检查第二个栈是否为空，不为空则拿出一个存储空间来使用，以此节省调用malloc的开销。\r\n* Stack.h\r\n\r\n```c\r\n#ifndef _Stack_h\r\n#define _Stack_h\r\n\r\n#define ElementType int\r\n\r\nstruct Node;\r\ntypedef struct Node* ptrToNode;\r\ntypedef ptrToNode Stack;\r\n\r\n\r\nint IsEmpty(Stack S);\r\nStack CreatStack(void);\r\nvoid DisposeStack(Stack S);\r\nvoid MakeEmpty(Stack S);\r\nvoid Push(ElementType X,Stack S);\r\nElementType Top(Stack S);\r\nvoid Pop(Stack S); \r\n\r\n#endif\r\n```\r\n\r\n* Stack.c\r\n\r\n```c\r\n#include\"Stack.h\"\r\n#include<stdlib.h>\r\nstruct Node\r\n{\r\n    ElementType Element;\r\n    ptrToNode Next;\r\n};\r\n\r\nint IsEmpty(Stack S)\r\n{\r\n    return S->Next==NULL;\r\n}\r\nStack CreatStack(void)\r\n{\r\n    Stack temp;\r\n    temp = malloc(sizeof(struct Node));\r\n    if (temp==NULL)\r\n        return FatalError(\"error:out of space!!!\");\r\n    temp->Next=NULL;\r\n    MakeEmpty(temp);\r\n    return temp;\r\n}\r\nvoid DisposeStack(Stack S);\r\nvoid MakeEmpty(Stack S)\r\n{\r\n    if (S==NULL)\r\n        return FatalError(\"error:must use creatStack first\");\r\n    while (!IsEmpty(S))\r\n        Pop(S);\r\n}\r\nvoid Push(ElementType X,Stack S)//S是头元素的指针\r\n{\r\n    Stack newElement=malloc(sizeof(struct Node));\r\n    if (newElement==NULL)\r\n        return FatalError(\"error:out of space!!!\");\r\n    newElement->Element=X;\r\n    newElement->Next=S->Next;\r\n    S->Next=newElement;\r\n}\r\nElementType Top(Stack S)\r\n{\r\n    if (isEmpty(S))\r\n    {\r\n        FatalError(\"Empty Stack\");\r\n        return 0;//return value used to avoid warning\r\n    }\r\n    return S->Element;\r\n}\r\nvoid Pop(Stack S)\r\n{\r\n    ptrToNode first;\r\n    if (isEmpty(S))\r\n    {\r\n        FatalError(\"Empty Stack\");\r\n        return;\r\n    }\r\n    first=S->Next;\r\n    S->Next=S->Next->Next;\r\n    free(first);\r\n} \r\n\r\nFatalError(char*p)\r\n{\r\n    printf(\"%s\\n\",p);\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n## 栈的数组实现\r\n* 是一种比较流行的方法\r\n* 优点：避免了使用指针\r\n* 缺点：需要提前指定数组的大小\r\n* `TopOfStack`为-1表示空栈\r\n* 压入元素时`TopOfStack+=1`，`stack[TopOfStack]=X`\r\n* 弹出元素时`return stack[TopOfStack--]`\r\n* 栈应该不止一个，栈的元素应该对其他程序不可见，所以栈应该避免使用全局变量表示。\r\n* 栈的执行效率非常高\r\n* 栈的错误检测影响栈的执行效率\r\n* 除了一些对栈的错误处理非常重要的场合（操作系统），省略栈的错误检测是惯用手法\r\n* 可以声明一个很大的栈使其不至于POP一个空栈，但在当程序非常庞大时，忽略错误检测是不妥的，因为对于整个程序而言栈的错误检测花费的时间很少\r\n\r\n* Stack.h\r\n```c\r\n#ifndef Stack_H\r\n#define Stack_H\r\n\r\n#define ElementType int\r\n\r\nstruct StackRecord;\r\ntypedef struct StackRecord* Stack;\r\n\r\nint IsEmpty(Stack S);\r\nint IsFull(Stack S);\r\nStack CreatStack(int MaxElements);\r\nvoid DisposeStack(Stack S);\r\nvoid MakeEmpty(Stack S);\r\nvoid Push(ElementType X,Stack S);\r\nElementType Top(Stack S);\r\nvoid Pop(Stack S);\r\nElementType TopAndPop(Stack S);\r\n\r\n#endif\r\n```\r\n* Stack.c\r\n```c\r\n#include\"Stack.h\"\r\n#include<stdio.h>\r\n#define EmptyTOS (-1)\r\n#define MinStackSize (5)\r\n\r\nstruct StackRecord\r\n{\r\n    int Capacity;\r\n    int TopOfStack;\r\n    ElementType *Arry;\r\n};\r\n\r\nint IsEmpty(Stack S)\r\n{\r\n    return S->TopOfStack<=EmptyTOS;\r\n}\r\nint IsFull(Stack S)\r\n{\r\n    return S->TopOfStack>=S->Capacity-1;\r\n}\r\nStack CreatStack(int MaxElements)\r\n{\r\n    Stack S;\r\n    if(MaxElements<MinStackSize)\r\n    {\r\n        Error(\"Stack size is too small\");\r\n        return 0;\r\n    }\r\n    S = malloc(sizeof(struct StackRecord));\r\n    if(S==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return 0;\r\n    }\r\n    S->Arry=malloc(sizeof(ElementType)*MaxElements);\r\n    if (S->Arry==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return 0;\r\n    }\r\n    S->Capacity=MaxElements;\r\n    MakeEmpty(S);\r\n    return S;\r\n}\r\nvoid DisposeStack(Stack S)\r\n{\r\n    if (S!=NULL)\r\n    {\r\n        free(S->Arry);\r\n        free(S);\r\n    }\r\n}\r\nvoid MakeEmpty(Stack S)\r\n{\r\n    S->TopOfStack=EmptyTOS;\r\n}\r\nvoid Push(ElementType X,Stack S)\r\n{\r\n    if (isFull(S))\r\n    {\r\n        Error(\"Full Stack\");\r\n        return;\r\n    }else\r\n        S->Arry[++S->TopOfStack]=X;\r\n}\r\nElementType Top(Stack S)\r\n{\r\n    if (isEmpty(S))\r\n    {\r\n        Error(\"Empty Stack\");\r\n        return 0;\r\n    }\r\n    return S->Arry[S->TopOfStack];\r\n}\r\nvoid Pop(Stack S)\r\n{\r\n    if (isEmpty(S))\r\n    {\r\n        Error(\"Empty Stack\");\r\n        return;\r\n    }\r\n    S->TopOfStack--;\r\n}\r\nElementType TopAndPop(Stack S)\r\n{\r\n    if (isEmpty(S))\r\n    {\r\n        Error(\"Empty Stack\");\r\n        return 0;\r\n    }\r\n    return S->Arry[S->TopOfStack--];\r\n}\r\nError(char*p)\r\n{\r\n    printf(\"%s\\n\",p);\r\n}\r\n```\r\n\r\n### 应用\r\n* 平衡符号\r\n* 后缀表达式\r\n* 函数调用\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 栈ADT的递归运用\r\n# 队列ADT\r\n# 队列ADT在操作系统和算法设计中的应用\r\n\r\n\r\n"}