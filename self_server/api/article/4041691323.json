{"shortInfo":{"title":"java学习笔记","date":"2022-10-22T08:22:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["笔记","java"],"categories":"笔记","id":4041691323,"countWords":59376,"readSeconds":5937.6,"assetsbaseUrl":"/self_server/assets/"},"content":"<details>\r\n<summary>显示/隐藏\r\n\r\n## 目录\r\n</summary>\r\n\r\n- [目录](#目录)\r\n- [学习及笔记更新日志](#学习及笔记更新日志)\r\n- [概述](#概述)\r\n- [基础语法](#基础语法)\r\n  - [注释](#注释)\r\n  - [字面量](#字面量)\r\n  - [基本数据类型](#基本数据类型)\r\n  - [标识符命名要求](#标识符命名要求)\r\n- [类型转换](#类型转换)\r\n  - [自动类型转换](#自动类型转换)\r\n  - [强制类型转换](#强制类型转换)\r\n- [运算符](#运算符)\r\n  - [算数运算符](#算数运算符)\r\n  - [字符串连接运算符](#字符串连接运算符)\r\n  - [自增自减运算符](#自增自减运算符)\r\n  - [赋值运算符](#赋值运算符)\r\n  - [关系运算符(条件运算符)](#关系运算符条件运算符)\r\n  - [逻辑运算符](#逻辑运算符)\r\n  - [三元运算符](#三元运算符)\r\n  - [运算符优先级](#运算符优先级)\r\n- [键盘录入API](#键盘录入api)\r\n- [流程控制](#流程控制)\r\n  - [分支](#分支)\r\n  - [循环](#循环)\r\n- [随机数](#随机数)\r\n- [引用数据类型](#引用数据类型)\r\n  - [数组](#数组)\r\n  - [在内存中的占用情况](#在内存中的占用情况)\r\n- [方法](#方法)\r\n  - [定义、调用](#定义调用)\r\n  - [方法在内存中的调用流程](#方法在内存中的调用流程)\r\n  - [方法参数传递机制](#方法参数传递机制)\r\n  - [方法重载](#方法重载)\r\n- [基础知识巩固练习案例](#基础知识巩固练习案例)\r\n  - [买飞机票算票价](#买飞机票算票价)\r\n  - [找素数](#找素数)\r\n  - [生成验证码](#生成验证码)\r\n  - [数字加密](#数字加密)\r\n  - [双色球系统案例](#双色球系统案例)\r\n- [面向对象](#面向对象)\r\n  - [类](#类)\r\n  - [构造器](#构造器)\r\n  - [this关键字](#this关键字)\r\n  - [封装](#封装)\r\n  - [标准javaBean实体类](#标准javabean实体类)\r\n  - [成员变量和局部变量的区别](#成员变量和局部变量的区别)\r\n  - [对象数组在内存中的占用情况](#对象数组在内存中的占用情况)\r\n- [String字符串类及其常用API](#string字符串类及其常用api)\r\n  - [相关概念](#相关概念)\r\n  - [APis](#apis)\r\n    - [构造器](#构造器-1)\r\n    - [常用成员方法](#常用成员方法)\r\n  - [案例](#案例)\r\n- [ArraryList集合容器类及其常用API](#arrarylist集合容器类及其常用api)\r\n  - [相关概念](#相关概念-1)\r\n  - [APIs](#apis-1)\r\n    - [构造器](#构造器-2)\r\n    - [常用成员方法](#常用成员方法-1)\r\n  - [一些案例](#一些案例)\r\n- [面向对象高级](#面向对象高级)\r\n  - [static关键字](#static关键字)\r\n  - [代码块](#代码块)\r\n  - [继承extends](#继承extends)\r\n  - [继承后的方法重写](#继承后的方法重写)\r\n  - [继承后子类构造器的特点](#继承后子类构造器的特点)\r\n  - [this和super的使用](#this和super的使用)\r\n- [单例设计模式](#单例设计模式)\r\n  - [设计模式](#设计模式)\r\n  - [饿汉单例](#饿汉单例)\r\n  - [懒汉单例模式](#懒汉单例模式)\r\n- [包Package](#包package)\r\n- [权限修饰符](#权限修饰符)\r\n- [final修饰符](#final修饰符)\r\n- [常量](#常量)\r\n- [枚举](#枚举)\r\n- [抽象类、抽象方法](#抽象类抽象方法)\r\n  - [final和abstract关系](#final和abstract关系)\r\n- [接口](#接口)\r\n- [多态](#多态)\r\n  - [抽象类的多态实现测试](#抽象类的多态实现测试)\r\n- [内部类](#内部类)\r\n  - [静态内部类](#静态内部类)\r\n  - [成员内部类](#成员内部类)\r\n  - [局部内部类](#局部内部类)\r\n  - [匿名内部类【重点】](#匿名内部类重点)\r\n- [Object类及其常用APIs](#object类及其常用apis)\r\n  - [toString()](#tostring)\r\n  - [equals(Object)](#equalsobject)\r\n- [Objects类及其常用APIs](#objects类及其常用apis)\r\n  - [Objects.equals](#objectsequals)\r\n  - [Objects.inNull](#objectsinnull)\r\n- [StringBuilder类及其常用APIs](#stringbuilder类及其常用apis)\r\n  - [StringBuilder()构造器](#stringbuilder构造器)\r\n  - [append(任意类型)](#append任意类型)\r\n  - [reverse()](#reverse)\r\n  - [length()](#length)\r\n  - [toString()](#tostring-1)\r\n  - [测试](#测试)\r\n- [Math类及其常用APIs](#math类及其常用apis)\r\n  - [常用APIs](#常用apis)\r\n- [System类及其常用APIs](#system类及其常用apis)\r\n  - [常用APIs](#常用apis-1)\r\n- [BigDecimal类及其常用APIs](#bigdecimal类及其常用apis)\r\n  - [BigDecimal构造函数](#bigdecimal构造函数)\r\n  - [常用APIs](#常用apis-2)\r\n  - [精度问题](#精度问题)\r\n  - [二次封装](#二次封装)\r\n- [Date日期对象及常用APIs](#date日期对象及常用apis)\r\n  - [构造器](#构造器-3)\r\n  - [常用方法](#常用方法)\r\n- [SimpleDateFormat 日期对象及常用APIs](#simpledateformat-日期对象及常用apis)\r\n  - [构造器](#构造器-4)\r\n  - [常用方法](#常用方法-1)\r\n- [Calendar 日历对象及常用APIs](#calendar-日历对象及常用apis)\r\n  - [APIs](#apis-2)\r\n- [JDK8新增时间类](#jdk8新增时间类)\r\n  - [`LocalDate`、`LocalTime`、`LocalDateTime`类及其APIs](#localdatelocaltimelocaldatetime类及其apis)\r\n    - [构造函数](#构造函数)\r\n    - [常用成员函数APIs](#常用成员函数apis)\r\n  - [`Instant`类及APIs](#instant类及apis)\r\n    - [Instant创建实例对象](#instant创建实例对象)\r\n    - [一些方法](#一些方法)\r\n  - [`Instant`类及APIs](#instant类及apis-1)\r\n    - [实例化](#实例化)\r\n    - [方法](#方法-1)\r\n  - [Period类](#period类)\r\n  - [Duration类](#duration类)\r\n  - [ChronoUnit类](#chronounit类)\r\n- [包装类](#包装类)\r\n- [正则表达式](#正则表达式)\r\n  - [API](#api)\r\n  - [正则语法](#正则语法)\r\n  - [案例测试](#案例测试)\r\n- [Arrays数组的工具类](#arrays数组的工具类)\r\n  - [tostring](#tostring-2)\r\n  - [sort](#sort)\r\n  - [自定义sort排序](#自定义sort排序)\r\n  - [binarySearch二分查找](#binarysearch二分查找)\r\n- [Lambda表达式](#lambda表达式)\r\n- [Collection集合](#collection集合)\r\n  - [Collection集合概念](#collection集合概念)\r\n  - [Collection集合常用API](#collection集合常用api)\r\n  - [Collection集合遍历](#collection集合遍历)\r\n    - [迭代器](#迭代器)\r\n    - [加强版for循环](#加强版for循环)\r\n    - [结合forEach方法和lambda表达式](#结合foreach方法和lambda表达式)\r\n  - [List系列的集合](#list系列的集合)\r\n    - [ArrayList](#arraylist)\r\n    - [LinkedList](#linkedlist)\r\n    - [迭代时删除元素的问题](#迭代时删除元素的问题)\r\n  - [Set系列集合](#set系列集合)\r\n    - [HashSet](#hashset)\r\n    - [LinkedHashSet](#linkedhashset)\r\n    - [TreeSet](#treeset)\r\n- [可变参数](#可变参数)\r\n- [集合的工具类：Collections类](#集合的工具类collections类)\r\n- [扑克牌洗牌分牌](#扑克牌洗牌分牌)\r\n- [泛型](#泛型)\r\n  - [自定义泛型类](#自定义泛型类)\r\n  - [自定义泛型方法](#自定义泛型方法)\r\n  - [自定义泛型接口](#自定义泛型接口)\r\n  - [泛型通配符](#泛型通配符)\r\n- [Map集合](#map集合)\r\n  - [概念](#概念)\r\n  - [API](#api-1)\r\n  - [特点](#特点)\r\n  - [遍历](#遍历)\r\n  - [案例](#案例-1)\r\n  - [集合和Map的嵌套](#集合和map的嵌套)\r\n- [不可变集合](#不可变集合)\r\n- [Stream流](#stream流)\r\n  - [概念](#概念-1)\r\n  - [获取Stream流](#获取stream流)\r\n  - [Stream的常用中间方法](#stream的常用中间方法)\r\n  - [Stream的常用终极方法](#stream的常用终极方法)\r\n  - [Stream流的收集](#stream流的收集)\r\n  - [案例](#案例-2)\r\n- [异常处理](#异常处理)\r\n  - [概念](#概念-2)\r\n  - [常见异常](#常见异常)\r\n  - [默认异常处理机制](#默认异常处理机制)\r\n  - [处理异常](#处理异常)\r\n  - [自定义异常](#自定义异常)\r\n  - [案例](#案例-3)\r\n- [日志框架](#日志框架)\r\n  - [概念](#概念-3)\r\n  - [日志框架体系结构](#日志框架体系结构)\r\n- [Logback日志框架](#logback日志框架)\r\n  - [概念](#概念-4)\r\n  - [使用与配置](#使用与配置)\r\n- [电影商城实现](#电影商城实现)\r\n- [字符集编码解码](#字符集编码解码)\r\n- [File文件](#file文件)\r\n  - [构造器](#构造器-5)\r\n  - [常用方法](#常用方法-2)\r\n- [流](#流)\r\n  - [基础IO流](#基础io流)\r\n    - [FileInputStream](#fileinputstream)\r\n    - [FileOutputStream](#fileoutputstream)\r\n    - [FileReader](#filereader)\r\n    - [FileWriter](#filewriter)\r\n  - [缓冲IO流](#缓冲io流)\r\n    - [缓冲文件流 BufferedOutputStream BufferedInputStream](#缓冲文件流-bufferedoutputstream-bufferedinputstream)\r\n    - [缓冲字符流 BufferedReader BufferedWriter](#缓冲字符流-bufferedreader-bufferedwriter)\r\n    - [字符输入/输出转换流](#字符输入输出转换流)\r\n  - [对象序列化(对象字节输出流)](#对象序列化对象字节输出流)\r\n  - [打印流](#打印流)\r\n  - [Properties属性集对象](#properties属性集对象)\r\n  - [IO框架：commons-io](#io框架commons-io)\r\n- [中文进制转十进制](#中文进制转十进制)\r\n- [多线程](#多线程)\r\n  - [方法1: **继承**`Thread类`](#方法1-继承thread类)\r\n  - [**方法2**：**实现**`Runnable接口`](#方法2实现runnable接口)\r\n  - [方法3：实现`Callable接口`](#方法3实现callable接口)\r\n  - [Thread类](#thread类)\r\n- [线程安全问题](#线程安全问题)\r\n  - [synchronized同步](#synchronized同步)\r\n    - [synchronized同步代码块](#synchronized同步代码块)\r\n    - [synchronized同步方法](#synchronized同步方法)\r\n  - [Lock锁](#lock锁)\r\n  - [线程通信](#线程通信)\r\n- [线程池](#线程池)\r\n  - [概念](#概念-5)\r\n  - [实现类ThreadPoolExecutor](#实现类threadpoolexecutor)\r\n  - [Executors工具类创建线程池](#executors工具类创建线程池)\r\n- [定时器](#定时器)\r\n  - [Timer定时器](#timer定时器)\r\n  - [ScheduledExecutorService定时器](#scheduledexecutorservice定时器)\r\n- [并发与并行](#并发与并行)\r\n  - [Thread线程生命周期6种状态](#thread线程生命周期6种状态)\r\n- [网络变成](#网络变成)\r\n  - [InetAddress的使用](#inetaddress的使用)\r\n  - [UDP数据包](#udp数据包)\r\n  - [DatagramSocket通信接口对象](#datagramsocket通信接口对象)\r\n  - [UDP的单播、组播、广播](#udp的单播组播广播)\r\n  - [TCP](#tcp)\r\n    - [Socket类](#socket类)\r\n    - [ServerSocket类](#serversocket类)\r\n    - [TCP通信测试：连接的建立与通信](#tcp通信测试连接的建立与通信)\r\n    - [TCP通信测试：服务端通过临时创建子线程服务多个客户端](#tcp通信测试服务端通过临时创建子线程服务多个客户端)\r\n  - [TCP通信测试：服务端通过线程池服务多个客户端](#tcp通信测试服务端通过线程池服务多个客户端)\r\n  - [TCP通信测试：实现简易群聊](#tcp通信测试实现简易群聊)\r\n  - [TCP通信测试：简易BS架构原理测试](#tcp通信测试简易bs架构原理测试)\r\n- [单元测试：Junit单元测试框架](#单元测试junit单元测试框架)\r\n- [反射](#反射)\r\n  - [获取Class对象](#获取class对象)\r\n  - [获取Class对象的构造器函数](#获取class对象的构造器函数)\r\n  - [使用获取到的构造函数创建对象](#使用获取到的构造函数创建对象)\r\n  - [获取Class类的属性对象](#获取class类的属性对象)\r\n  - [使用获取到的属性对象修改实例对象的属性值](#使用获取到的属性对象修改实例对象的属性值)\r\n  - [获取Class类的方法](#获取class类的方法)\r\n  - [通过获取到的类的方法来执行实例对象的方法](#通过获取到的类的方法来执行实例对象的方法)\r\n  - [应用：存储任意对象的属性值到文件](#应用存储任意对象的属性值到文件)\r\n- [注解](#注解)\r\n  - [自定义注解](#自定义注解)\r\n  - [元注解](#元注解)\r\n  - [注解的解析](#注解的解析)\r\n- [结合`反射`和`注解`实现简易`junit框架`](#结合反射和注解实现简易junit框架)\r\n- [对象的动态代理](#对象的动态代理)\r\n- [XML](#xml)\r\n  - [概述](#概述-1)\r\n  - [解析](#解析)\r\n    - [Dom4J](#dom4j)\r\n  - [检索:xPath](#检索xpath)\r\n- [工厂设计模式](#工厂设计模式)\r\n- [装饰设计模式](#装饰设计模式)\r\n\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>显示/隐藏\r\n\r\n## 学习及笔记更新日志\r\n</summary>\r\n\r\n+ 10月22日 73/200集 73集 概述 环境搭建 执行原理 注释 字面量 变量 数据类型 关键字 标识符 自动及强制类型转换 运算符 键盘录入 顺序分支循环 数组 方法 方法内存原理 方法值传递机制 方法重载 案例\r\n+ 10月23日 100/200集 27集 面向对象 面向对象内存机制 构造器 this ArrayList String常量与变量 ArrayList遍历 ATM系统项目实现 修饰符 工具类 代码块 static 单例模式\r\n+ 10月24日 110/200集 10集 继承 包 权限修饰符 final 常量 枚举 抽象类 接口 多态 内部类 匿名内部类 \r\n+ 10月25日 117/200集 7集 Objets工具类 StringBuilder Math System BigDecimal Date SimpleDateFormate Calendar JDK8新增日期API\r\n+ 10月26日 124/200集 7集 正则表达式 Arrays 选择排序 二分查找 Lambda表达式 集合Collection 集合遍历\r\n+ 10月27日 131/200集 7集 List 泛型 自定义泛型 泛型通配符 泛型上下限 Set集合 可变参数 集合操作工具类Collections\r\n+ 10月28日 136/200集 5集 洗牌发牌系统案例 Map集合 MapAPI Map遍历 Map其他实现类 集合嵌套 不可变集合 Stream流 异常分类 异常处理机制 自定义异常  \r\n+ 10月29日 147/200集 11集 Logback日志框架 电影商城项目\r\n+ 10月30日 152/200集 5集  文件 方法递归 文件搜索 IO流 文件字节输入流 \r\n+ 10月31日 157/200集 5集 文件字节输出流 缓冲流 字节缓冲流 \r\n+ 11月1日  166/200集 9集 对象序列化 反序列化 打印流 Properties commons-io 线程三种创建方式 线程方法 线程安全问题 线程同步 同步代码块 同步方法 同步锁 线程通信 线程池  \r\n+ 11月2日  175/200集 9集  线程池处理Runnable任务 线程池处理Callable任务 Executors工具类构建线程池对象 定时器 线程并发 并行 线程生命周期6种状态 网络通信 UDP单播广播组播 TCP通信结合线程池 TCP即时通讯案例 BS架构模拟\r\n+ 11月3日  187/200集 12集 Junit框架单元测试 反射获取类对象 反射获取类属性 反射获取类方法 反射获取类构造器 反射修改类属性 反射调用类方法 反射执行类构造器\r\n+ 11月4日  200/200集 13集 注解 自定义注解 元注解 注解解析 使用注解和反射实现junit框架 动态代理 XML XML文档约束 Dom4J XPath 工厂设计模式 装饰设计模式 \r\n\r\n</details>\r\n\r\n\r\n## 概述\r\n![](./images/java学习笔记/2022-10-22-08-32-16.png)\r\n\r\n![](./images/java学习笔记/2022-10-22-08-33-28.png)\r\n\r\n![](./images/java学习笔记/2022-10-22-08-36-55.png)\r\n\r\n![](./images/java学习笔记/2022-10-22-08-38-00.png)\r\n\r\n![](./images/java学习笔记/2022-10-22-08-40-13.png)\r\n\r\n## 基础语法\r\n\r\n### 注释\r\n```java\r\n// 单行注释\r\n/*\r\n    多行注释\r\n    多行注释\r\n    多行注释\r\n    多行注释\r\n */\r\n/**\r\n    文档注释\r\n    @param\t说明一个方法的参数，一般用于方法注释\t@param parameter-name explanation\r\n    @return\t说明返回值类型，一般用于方法注释，不能出现再构造方法中\t@return explanation\r\n    @author\t标识一个类的作者，一般用于类注释\r\n    @version\t指定类的版本，一般用于类注释\t@version info\r\n */\r\n```\r\n\r\n### 字面量\r\n* 数值 `123` `-321`\r\n  * 二进制 `0B11111111` => `255` `0B11111111111111111111111111111111` => `-1`\r\n  * 八进制 `0777` `0001`\r\n  * 十六进制 `0xff` `0X01`\r\n* 浮点数 `1.23` \r\n* 字符 `'a'` =>97 `'A'` =>65 `'0'` =>48  `'\\n'` `'\\t'` `'汉'`\r\n* 字符串 `\"123\"` `\"ABC\"`\r\n* 布尔值 `true` `false`\r\n* 空值 `null`\r\n\r\n### 基本数据类型\r\n* **整型** byte(1B) short(2B) int(4B,默认) long(8B)\r\n* **浮点型** float(4B) double(8B,默认)\r\n* **字符** <gold>char(2B)</gold>\r\n* **布尔** boolean(1B)\r\n\r\n* 注意点\r\n  * 变量先声明后使用\r\n  * 变量声明可无初值，**使用时必须有初值**\r\n  * 变量不能存储和声明类型不一致的数据\r\n  * <green>同一作用域及其 **子作用域** **不能有两同名变量**</green>\r\n\r\n### 标识符命名要求\r\n* 组成：字母+数字+**下划线**+**美元符**\r\n* 不能以数字开头，不能是关键字\r\n* 命名规范\r\n    * 变量名：小驼峰命名法\r\n    * 类名：大驼峰命名法\r\n\r\n## 类型转换 \r\n\r\n### 自动类型转换\r\n* **赋值时的自动类型转换：根据所占存储空间小转大：** \r\n  * byte -> short -> int -> long -> float -> double\r\n  * <green>char -> int<green>\r\n  * <warn>char -x-> float</warn>\r\n* 在表达式运算过程中的自动类型转换\r\n  * byte、short、char =(直接)=> int -> long -> float -> double\r\n```java\r\n    byte a = 1 , b = 2;\r\n    byte c = a + b; //报错\r\n    int d = a + b; //不报错\r\n```\r\n\r\n### 强制类型转换\r\n* 整型间强转：**截取低位字节**直接赋值，可能导致数据丢失\r\n* 浮点型间强转：丢掉小数部分，保留整数部分然后按**整型间强转**赋值 99.5 -> 99\r\n* \r\n![](./images/java学习笔记/2022-10-22-13-27-17.png)\r\n\r\n##  运算符\r\n### 算数运算符\r\n* 加 +\r\n* 减 -\r\n* 乘 *\r\n* 除 / 整型间相除结果仍是整型 \r\n* 余 %\r\n\r\n### 字符串连接运算符\r\n```java\r\nSystem.out.println(\"hhhh\"+\"xx\") //结果: \"hhhhxx\"\r\nSystem.out.println(\"hhhh\"+'x')  //结果: \"hhhhx\"\r\nSystem.out.println(\"hhhh\"+ 5 )  //结果: \"hhhh5\"\r\n```\r\n\r\n### 自增自减运算符\r\n```java\r\nint c = 10;\r\nint d = 5;\r\nint result = c++ + ++c - --d - ++d + 1 + c--;\r\nSystem.out.println(result);\r\n//c 10 11 12    13\r\n//d 5        4\r\n//r = 10 + 12 - 4 + 1 + 12 = 26\r\n```\r\n\r\n\r\n### 赋值运算符\r\n**基本赋值运算符**\r\n```java\r\na = 1;\r\n```\r\n\r\n**扩展运算符**：<gold>自带强制转换功能</gold>\r\n```java\r\na += 1; // 等价于 a = a(a的数据类型) + 1\r\na -= 1; // 等价于 a = a(a的数据类型) - 1\r\na *= 1; // 等价于 a = a(a的数据类型) * 1\r\na /= 1; // 等价于 a = a(a的数据类型) / 1\r\na %= 1; // 等价于 a = a(a的数据类型) % 1\r\n```\r\n\r\n\r\n```java\r\nbyte result = 1 ;\r\nbyte step = 1 ;\r\nresult =  result + step ; //报错，右侧结果为int类型，左侧变量为byte类型\r\nresult = (byte) ( result + step );//不报错\r\nresult += step;//不报错，和上面等效\r\n```\r\n\r\n### 关系运算符(条件运算符)\r\n```java\r\n/*\r\n    a == b\r\n    a != b\r\n    a >= b\r\n    a <= b\r\n    a >  b\r\n    a <  b\r\n*/\r\n```\r\n\r\n\r\n### 逻辑运算符\r\n```java\r\n/*\r\n    & 逻辑 与       左右两边都会执行\r\n    | 逻辑 或       左右两边都会执行\r\n    ! 逻辑 非       左右两边都会执行\r\n    ^ 逻辑 异或     左右两边都会执行\r\n\r\n    && 逻辑 与      左边false则不执行右边(短路)\r\n    || 逻辑 或      左边true 则不执行右边(短路)\r\n*/\r\n```\r\n\r\n### 三元运算符\r\n```java\r\nboolean result = (条件表达式)? 表达式1 : 表达式2 ;\r\n```\r\n\r\n### 运算符优先级\r\n![](./images/java学习笔记/2022-10-22-14-17-37.png)\r\n\r\n\r\n## 键盘录入API\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Scanner;//导入包\r\n\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);//创建scanner实例\r\n\r\n        System.out.println(\"请输入年龄\");\r\n        int age = sc.nextInt();//调用相关函数\r\n\r\n        System.out.println(\"请输入姓名\");\r\n        String name = sc.next();\r\n\r\n        System.out.println(\"你的姓名是：\" + name);\r\n        System.out.println(\"你的年龄是：\" + age);\r\n    }\r\n}\r\n```\r\n\r\n## 流程控制\r\n* 顺序：默认\r\n* 分支(选择)： `if` `switch` \r\n* 循环：`for(;;){}` `while(){}` `do{}while();` \r\n\r\n### 分支\r\n\r\n**if**\r\n\r\n```java\r\nif(){\r\n\r\n}else if(){\r\n\r\n}else{\r\n\r\n}\r\n```\r\n**switch**\r\n* `switch(表达式)` 表达式只能是byte char short int 枚举(jdk5) string(jdk7) \r\n* `switch(表达式)` 表达式不能是long float double\r\n* `case 值:` 中的值只能是字面量\r\n```java\r\nswitch(表达式){//表达式只能是byte char short int 枚举(jdk5) string(jdk7) 不能是：long float double\r\n    case 字面量://只能是字面量\r\n        语句;\r\n        break;//跳出switch执行\r\n    default:\r\n        语句;\r\n        break;\r\n}\r\n```\r\n\r\n```java\r\npackage com.yiguiding.package1;\r\nimport java.util.Scanner;\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        int month =  sc.nextInt();\r\n        switch (month) {\r\n            case 1:\r\n            case 3:\r\n            case 5:\r\n            case 7:\r\n            case 8:\r\n            case 10:\r\n            case 12:\r\n                System.out.println(\"32天\");\r\n                break;\r\n            case 4:\r\n            case 6:\r\n            case 9:\r\n            case 11:\r\n                System.out.println(\"30天\");\r\n                break;\r\n            case 2:\r\n                System.out.println(\"瑞年29天，非瑞年28天\");\r\n                break;\r\n            default:\r\n                System.out.println(\"输入月份不正确\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 循环\r\n\r\nfor\r\n```java\r\nfor(int i = 0; i<100 ;i++){\r\n\r\n}\r\n```\r\n\r\nwhile\r\n```java\r\nwhile(){\r\n\r\n}\r\n```\r\n\r\ndo...while();\r\n```java\r\ndo{\r\n\r\n}while();\r\n```\r\n\r\nbreak;continue;\r\n\r\n```java\r\ncontinue;//跳出本次循环，进入下一次循环\r\nbreak;//跳出并结束本次循环\r\n```\r\n\r\n\r\n## 随机数\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;//导包\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Random random = new Random();//实例化\r\n        System.out.println(random.nextInt(5,11));//获取5-10的随机数\r\n        System.out.println(random.nextInt(11));//获取0-10的随机数\r\n        System.out.println(random.nextInt(10)+1);//获取1-10的随机数\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 引用数据类型\r\n### 数组\r\n\r\n数组是引用数据类型，数组变量名存的是数组在内存中的地址。\r\n![](./images/java学习笔记/2022-10-22-15-17-19.png)\r\n\r\n**静态初始化：数组长度固定**\r\n```java\r\n// 完整写法\r\n    int[] scores = new int[]{123,456,789,101,102,103};//等效写法\r\n    int scores[] = new int[]{123,456,789,101,102,103};//等效写法\r\n// 简化写法\r\n    int[] scores = {123,456,789,101,102,103};//等效写法\r\n    int scores[] = {123,456,789,101,102,103};//等效写法\r\n```\r\n\r\n**动态初始化：数组长度可在程序中指定**\r\n```java\r\n// 完整写法\r\n    int[] empty = new int[10];\r\n    int empty[] = new int[10];\r\n// 简化写法：没有简化写法！！！\r\n    int[10] score;//错误写法\r\n    int score[10];//错误写法\r\n```\r\n\r\n**数组静态初始化和动态初始化写法相互独立不可混用**\r\n```java\r\nint[] score = new int[10]{123,456,789,101,102,103};//错误写法\r\n```\r\n\r\n\r\n**动态初始化数组元素的初始值**：\r\n* 数值型初始值： `0`\r\n* 浮点型初始值： `0.0`\r\n* `boolean`初始值： `false`\r\n* 引用类型初始值： `null`\r\n\r\n![](./images/java学习笔记/2022-10-22-15-50-47.png)\r\n\r\n\r\n**访问数组元素**\r\n```java\r\npackage com.yiguiding.package1;\r\nimport java.util.Random;\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Random random = new Random();\r\n        int[] score = new int[10];\r\n        for (int i = 0; i < score.length; i++) {\r\n            score[i] = random.nextInt(10);\r\n        }\r\n        for (int i = 0; i < score.length; i++) {\r\n            System.out.println(score[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**案例:输入一组数，按随机顺序输出这组数**\r\n方法1：\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        //案例：输入一组数，按随机顺序输出这组数\r\n        Scanner sc = new Scanner(System.in);\r\n        Random random = new Random();//实例化\r\n        int[] arr= new int[5];\r\n        for (int i = 0; i < arr.length; i++) {\r\n            System.out.println(\"请输入第\"+i+1+\"位员工的工号：\");\r\n            arr[i] = sc.nextInt();\r\n        }\r\n        System.out.println(\"员工上台演讲的顺序为：\");\r\n        for (int i = 0; i < arr.length; i++) {\r\n            while (true){\r\n                int index = random.nextInt(arr.length);\r\n                if (arr[index]!=-1){\r\n                    System.out.println(arr[index]);\r\n                    arr[index] = -1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n方法2：\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        //案例：输入一组数，按随机顺序输出这组数\r\n        Scanner sc = new Scanner(System.in);\r\n        Random random = new Random();//实例化\r\n        int[] arr= new int[5];\r\n        for (int i = 0; i < arr.length; i++) {\r\n            System.out.println(\"请输入第\"+i+1+\"位员工的工号：\");\r\n            arr[i] = sc.nextInt();\r\n        }\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            //获取随机两个下标\r\n            int indexA = random.nextInt(arr.length);\r\n            int indexB = random.nextInt(arr.length);\r\n            //交换\r\n            int temp = arr[indexA];\r\n            arr[indexA] = arr[indexB];\r\n            arr[indexB] = temp;\r\n        }\r\n        System.out.println(\"员工上台演讲的顺序为：\");\r\n        for (int i = 0; i < arr.length; i++) {\r\n            System.out.println(arr[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 在内存中的占用情况\r\n**内存区域**\r\n* 栈内存：正在执行的函数、变量\r\n* 堆内存：动态分配内存时所使用的内存区域，`new object[100]`\r\n* 方法区：程序运行时，编译后的字节码文件被加载到的区域\r\n* 本地方法区:\r\n* 寄存器:\r\n\r\n**栈、堆、方法区在程序运行过程中的使用情况**\r\n![](./images/java学习笔记/2022-10-22-16-29-56.png)\r\n\r\n\r\n**两个数组指向同一个数组对象**\r\n\r\n![](./images/java学习笔记/2022-10-22-16-32-54.png)\r\n\r\n\r\n\r\n## 方法\r\n\r\n### 定义、调用\r\n* 形参列表可有可无\r\n* 方法需严格按照形参类型传入值\r\n* 方法不需要返回值则返回类型可为void，此时则不能使用return语句;\r\n* 方法的定义顺序无所谓\r\n* 方法不能嵌套定义\r\n```java\r\n/* 格式\r\n修饰符 返回值类型 方法名(形参列表){\r\n    // 代码\r\n    return 返回值;\r\n}\r\n*/\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(sum(1,5));\r\n    }\r\n    public static int sum(int a,int b) {\r\n        return a + b;\r\n    }\r\n}\r\n```\r\n\r\n### 方法在内存中的调用流程\r\n![](./images/java学习笔记/2022-10-22-17-16-04.png)\r\n\r\n\r\n### 方法参数传递机制\r\n形式参数传递机制：值传递\r\n* 基本数据类型：传递值\r\n* 引用数据类型：传递地址\r\n\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        int[] arr1 = {111,222,333,444};\r\n        int[] arr2 = {111,222,333,444};\r\n        System.out.println(compareArrList(arr1,arr2));\r\n    }\r\n    public static boolean compareArrList(int[] arr1,int[] arr2){\r\n        if(arr1==null || arr2==null)//任意一个是空值都判断为不等\r\n            return false;\r\n        if (arr1 == arr2)//比较地址是否相同\r\n            return true;\r\n        if (arr1.length == arr2.length){\r\n            for (int i = 0; i < arr1.length; i++) {\r\n                if (arr1[i] != arr2[i])\r\n                    return false;\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 方法重载\r\n方法名称相同形参列表不同\r\n\r\n![](./images/java学习笔记/2022-10-22-17-41-32.png)\r\n\r\n\r\n## 基础知识巩固练习案例\r\n\r\n### 买飞机票算票价\r\n![](./images/java学习笔记/2022-10-22-18-06-18.png)\r\n```java\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n        double price=0.0;\r\n        int month=1;\r\n        int type=2;\r\n        double result = 0.0;\r\n        do {\r\n            System.out.println(\"请输入机票原价格：\");\r\n            price = scanner.nextDouble();\r\n            System.out.println(\"请输入当前月份：(1-12)\");\r\n            month = scanner.nextInt();\r\n            System.out.println(\"请输入仓位类型：1.头等舱；2.经济舱：(1-2)\");\r\n            type = scanner.nextInt();\r\n        }while (price<=0 || month< 1 || month >12 || !( type==1 || type==2) );\r\n\r\n        if (5 <= month && month <= 10){//旺季\r\n            if (type == 1)//头等舱\r\n                result = 0.9 * price;\r\n            else //经济舱\r\n                result = 0.85 * price;\r\n        } else {//淡季\r\n            if (type == 1)//头等舱\r\n                result = 0.7 * price;\r\n            else //经济舱\r\n                result = 0.65 * price;\r\n        }\r\n        System.out.println(\"你的机票价格为：\"+result);\r\n    }\r\n}\r\n```\r\n\r\n### 找素数\r\n![](./images/java学习笔记/2022-10-22-18-07-51.png)\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n//        Scanner scanner = new Scanner(System.in);\r\n        int count = 0;\r\n        for (int i = 101; i <= 200; i++) {\r\n            if (isPrime(i)){\r\n                System.out.print(i + \"\\t\");\r\n                count++;\r\n            }\r\n        }\r\n        System.out.println(\"\\n共有素数\" + count + \"个\");\r\n    }\r\n    public static boolean isPrime(int num){\r\n        if (num <= 2)\r\n            return false;\r\n        int sqrt = (int)Math.sqrt(num);\r\n        for (int i = 2; i <= sqrt; i++) {\r\n            if (num%i == 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n结果\r\n![](./images/java学习笔记/2022-10-22-18-17-10.png)\r\n\r\n\r\n### 生成验证码\r\n![](./images/java学习笔记/2022-10-22-18-30-17.png)\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(creatCode(5));\r\n    }\r\n    public static String creatCode(int length){\r\n        String code = \"\";\r\n        Random rd = new Random();\r\n        for (int i = 0; i < length; i++) {\r\n            switch (rd.nextInt(3)){//随机0-2\r\n                case 0:\r\n                    code+=(char)(rd.nextInt('A','Z') + 1);//随机获取一个大写字母并拼接给code\r\n                    break;\r\n                case 1:\r\n                    code+=(char)(rd.nextInt('a','z') + 1);//随机获取一个小写字母并拼接给code\r\n                    break;\r\n                case 2:\r\n                    code+=(char)(rd.nextInt('0','9') + 1);\r\n                    break;\r\n            }\r\n        }\r\n        return code;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 数字加密\r\n![](./images/java学习笔记/2022-10-22-18-36-17.png)\r\n\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        int[] arr = {1,9,8,3};\r\n        printArrList(arr);//输出\r\n        enCode(arr);//加密\r\n        printArrList(arr);//输出\r\n        enCode(arr);//再次加密就是解密\r\n        printArrList(arr);//输出\r\n\r\n    }\r\n    public static int[] enCode(int[] arrList){\r\n        for (int i = 0; i < arrList.length; i++) {\r\n            arrList[i] = (arrList[i] + 5) % 10 ;\r\n        }\r\n        return reverse(arrList);\r\n    }\r\n    public static int[] reverse(int[] arrList){//翻转\r\n        for (int i = 0,j=arrList.length-1; i < arrList.length/2; i++,j--) {\r\n            int temp = arrList[i];\r\n            arrList[i] = arrList[j];\r\n            arrList[j] = temp;\r\n        }\r\n        return arrList;\r\n    }\r\n    public static void printArrList(int[] arrList){\r\n        System.out.print('[');\r\n        if (arrList != null && arrList.length != 0){\r\n            for (int i = 0; i < arrList.length; i++) {\r\n                System.out.print( (i == arrList.length-1)? arrList[i] : arrList[i]+\",\");\r\n            }\r\n        }\r\n        System.out.println(']');\r\n    }\r\n}\r\n\r\n```\r\n输出\r\n![2022-10-23-02-55](./images/java学习笔记/2022-10-22-18-54-32.png)\r\n\r\n\r\n### 双色球系统案例\r\n![](./images/java学习笔记/2022-10-23-03-44-25.png)\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        int count = 0;\r\n        int[] users = createLuckNumbers();//守号\r\n        while (true){\r\n            count++;\r\n            int[] gen = createLuckNumbers();//开奖\r\n            System.out.println(\"开奖号码：\");\r\n            printArrList( gen );//输出\r\n            System.out.println(\"你的号码：\");\r\n            printArrList( users );//输出\r\n            int result = luckType(gen,users);//返回是几等奖\r\n            if (result<=2){//若中了1或2等奖则输出\r\n                System.out.println(\"连续购买\"+ count +\"次,恭喜获得\"+result+\"等奖\");\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    public static int[] createLuckNumbers(){\r\n        int[] luckNumbers = new int[6+1];//用于存放6个红球1个蓝球的空间\r\n        int[] reds = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33};//红球33个\r\n        int[] blues = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};//蓝球16个\r\n        Random rd = new Random();\r\n        for (int i = 0; i < luckNumbers.length-1; i++) {//随机选六个红球\r\n            while (true){\r\n                int index = rd.nextInt(reds.length);\r\n                if (reds[index]!=-1){//判断是否已经被拿出\r\n                    luckNumbers[i] = reds[index];//拿出红球\r\n                    reds[index] = -1;//标记为已经拿出\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        while (true){//随机选一个个篮球\r\n            int index = rd.nextInt(blues.length);\r\n            if (blues[index]!=-1){//判断是否已经被拿出\r\n                luckNumbers[luckNumbers.length-1] = blues[index];//拿出蓝球,放到最后一个位置\r\n                reds[index] = -1;//标记为已经拿出\r\n                break;\r\n            }\r\n        }\r\n        return luckNumbers;\r\n    }\r\n    public static int luckType(int[] luckNumsTarget,int[] luckNumsUsers){\r\n        int countRed = 0;//记录红球一致个数\r\n        int countBlue = 0;//记录蓝球一致个数\r\n        for (int i = 0; i < luckNumsUsers.length-1; i++) {\r\n            for (int j = 0; j < luckNumsTarget.length-1; j++) {\r\n                if (luckNumsUsers[i] == luckNumsTarget[j])\r\n                    countRed++;\r\n            }\r\n        }\r\n        if (luckNumsUsers[luckNumsUsers.length-1] == luckNumsTarget[luckNumsTarget.length-1]){//判断最后一个球是不是一致\r\n            countBlue ++;\r\n        }\r\n        if (countRed == 6 && countBlue == 1)\r\n            return  1;//一等奖\r\n\r\n        if (countRed == 6 && countBlue == 0)\r\n            return 2;//二等奖\r\n\r\n        if (countRed == 5 && countBlue == 1)\r\n            return 3;//三等奖\r\n\r\n        if (countRed == 5 && countBlue == 0)\r\n            return 4;//四等奖\r\n        if (countRed == 4 && countBlue == 1)\r\n            return 4;//四等奖\r\n\r\n        if (countRed == 4 && countBlue == 0)\r\n            return 5;//五等奖\r\n        if (countRed == 3 && countBlue == 1)\r\n            return 5;//五等奖\r\n        if (countRed == 2 && countBlue == 1)\r\n            return 5;//五等奖\r\n\r\n        if (countRed == 1 && countBlue == 1)\r\n            return 6;//六等奖\r\n        if (countRed == 0 && countBlue == 1)\r\n            return 6;//六等奖\r\n        else\r\n            return 7;//未中奖\r\n    }\r\n    public static void printArrList(int[] arrList){\r\n        System.out.print('[');\r\n        if (arrList != null && arrList.length != 0){\r\n            for (int i = 0; i < arrList.length; i++) {\r\n                System.out.print( (i == arrList.length-1)? arrList[i] : arrList[i]+\",\");\r\n            }\r\n        }\r\n        System.out.println(']');\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-10-23-03-45-25.png)\r\n\r\n\r\n## 面向对象\r\n\r\n### 类\r\n* **类是对象的设计图**\r\n* **对象是根据设计图创建出的实体**\r\n* **注意**：\r\n    * <green>一个java文件中可以定义多个类，但只能有一个public类</green>\r\n    * <green>public修饰的类名必须为java的文件名</green>\r\n    * <green>一般不用为成员变量赋初始值</green>\r\n    * java存在自动垃圾回收器,会定期清理堆内存中没有被引用的对象\r\n\r\n**类的语法构成**\r\n```java\r\npublic class 类名{\r\n    1.成员变量，名词\r\n        语法格式：修饰符 变量类型 变量名 = 初始值(可不指定初始值);\r\n    2.成员方法，动词\r\n    3.构造器\r\n    4.代码块\r\n    5.内部类\r\n}\r\n```\r\n\r\n**类的尝试编写**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person(\"DYG\",22);\r\n        p1.sayHi();\r\n    }\r\n}\r\n class Person{\r\n    String name;//车名\r\n    int age;//年龄\r\n    Person(String name,int age){//构造函数\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    public void sayHi(){\r\n        System.out.println(\"你好，我的名字是\"+name+\"。\");\r\n    }\r\n}\r\n```\r\n\r\n**对象在内存中的执行机制**\r\n![](./images/java学习笔记/2022-10-23-04-27-47.png)\r\n\r\n\r\n**购物车案例实现**\r\n\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        GoodsShopCar shopCar = new GoodsShopCar(1024);\r\n        Scanner sc = new Scanner(System.in);\r\n        while (true){\r\n            System.out.println(\"------------------------请输入操作类型------------------------\");\r\n            System.out.println(\"添加商品（add）\");\r\n            System.out.println(\"查看商品（shw）\");\r\n            System.out.println(\"删除商品（del）\");\r\n            System.out.println(\"修改数量（upd）\");\r\n            System.out.println(\"计算金额（pay）\");\r\n            System.out.println(\"退出程序（ext）\");\r\n            switch (sc.next()){\r\n                case \"add\":\r\n                    shopCar.add_(sc);\r\n                    break;\r\n                case \"shw\":\r\n                    shopCar.show_();\r\n                    break;\r\n                case \"del\":\r\n                    shopCar.delete_(sc);\r\n                    break;\r\n                case \"upd\":\r\n                    shopCar.update_(sc);\r\n                    break;\r\n                case \"pay\":\r\n                    shopCar.pay_();\r\n                    break;\r\n                case \"ext\":\r\n                    return;\r\n                default:\r\n                    System.out.println(\"未知操作类型，请重新输入\");\r\n                    continue;\r\n            }\r\n        }\r\n    }\r\n}\r\nclass Goods{\r\n    int id;\r\n    String name;\r\n    double price;\r\n    int buyNum;\r\n    Goods(int id,String name,double price,int buyNum){\r\n        this.id = id;\r\n        this.name = name;\r\n        this.price = price;\r\n        this.buyNum = buyNum;\r\n    }\r\n    public void changeNum(int num){\r\n        this.buyNum = num;\r\n    }\r\n}\r\nclass GoodsShopCar{\r\n    Goods[] buyList;\r\n    GoodsShopCar(int size){\r\n        this.buyList = new Goods[size];\r\n    }\r\n    public void add_(Scanner sc){\r\n        System.out.println(\"请输入要添加的商品信息......\");\r\n        System.out.println(\"请输入商品id\");\r\n        int id = sc.nextInt();\r\n        System.out.println(\"请输入商品name\");\r\n        String name = sc.next();\r\n        System.out.println(\"请输入商品price\");\r\n        double price = sc.nextDouble();\r\n        System.out.println(\"请输入商品number\");\r\n        int num = sc.nextInt();\r\n        if(this.addGoods(new Goods(id,name,price,num)) == \"OK\"){\r\n            System.out.println(\"添加商品成功\");\r\n        } else {\r\n            System.out.println(\"添加商品成功\");\r\n        }\r\n    }\r\n    private String addGoods(Goods goods) {\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            if (buyList[i] == null) {\r\n                buyList[i] = goods;\r\n                return \"OK\";\r\n            }\r\n        }\r\n        return \"ERROR\";\r\n    }\r\n    public void delete_(Scanner sc){\r\n        System.out.println(\"请输入要删除的商品id\");\r\n\r\n        if (this.deleteById(sc.nextInt()) == \"OK\") {\r\n            System.out.println(\"删除成功\");\r\n        }else{\r\n            System.out.println(\"删除失败\");\r\n        }\r\n    }\r\n    private String deleteById(int id){\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            Goods item = buyList[i];\r\n            if (item.id == id){\r\n                buyList[i] = null;\r\n                return \"OK\";\r\n            }\r\n        }\r\n        return \"ERROR\";\r\n    }\r\n    public void update_(Scanner sc){\r\n        while(true) {\r\n            System.out.println(\"请输入要执行的操作：\");\r\n            System.out.println(\"0.返回上一级\");\r\n            System.out.println(\"1.更新商品数量\");\r\n            switch (sc.nextInt()){\r\n                case 0:\r\n                    return;\r\n                case 1:\r\n                    System.out.println(\"请输入要更新的商品的id\");\r\n                    int id = sc.nextInt();\r\n                    System.out.println(\"请输入要更新的数量\");\r\n                    int num = sc.nextInt();\r\n                    if (this.updateNumById(id,num) == \"OK\"){\r\n                        System.out.println(\"更新成功\");\r\n                        return;\r\n                    }else{\r\n                        System.out.println(\"更新失败,请重新输入\");\r\n                        break;\r\n                    }\r\n                default:\r\n                    System.out.println(\"未知操作类型,请重新输入\");\r\n            }\r\n        }\r\n    }\r\n    private String updateNumById(int id,int num){\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            Goods item = buyList[i];\r\n            if (item!=null && item.id == id){\r\n                item.changeNum(num);\r\n                return \"OK\";\r\n            }\r\n        }\r\n        return \"ERROR\";\r\n    }\r\n    public void show_(){\r\n        System.out.println(\"id\\t\\tname\\t\\tprice\\t\\tnumber\\t\\t\");\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            Goods item = buyList[i];\r\n            if (item != null){\r\n                System.out.println(item.id+\"\\t\\t\"+item.name+\"\\t\\t\"+item.price+\"\\t\\t\"+item.buyNum);\r\n            }\r\n        }\r\n    }\r\n    public void pay_(){\r\n        System.out.println(\"购物车总价为：\"+this.getSumPrice()+\"元\");\r\n    }\r\n    private double getSumPrice(){\r\n        double sumPrice = 0.0;\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            Goods item = buyList[i];\r\n            if (item!=null)\r\n                sumPrice += item.price * item.buyNum;\r\n        }\r\n        return sumPrice;\r\n    }\r\n}\r\n```\r\n\r\n\r\n```text\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nadd\r\n请输入要添加的商品信息......\r\n请输入商品id\r\n111\r\n请输入商品name\r\n泡面\r\n请输入商品price\r\n4.5\r\n请输入商品number\r\n10\r\n添加商品成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nadd\r\n请输入要添加的商品信息......\r\n请输入商品id\r\n222\r\n请输入商品name\r\n火腿肠\r\n请输入商品price\r\n1\r\n请输入商品number\r\n10\r\n添加商品成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nadd\r\n请输入要添加的商品信息......\r\n请输入商品id\r\n333\r\n请输入商品name\r\n辣条\r\n请输入商品price\r\n0.5\r\n请输入商品number\r\n10\r\n添加商品成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nshw\r\nid\t\tname\t\tprice\t\tnumber\t\t\r\n111\t\t泡面\t\t4.5\t\t10\r\n222\t\t火腿肠\t\t1.0\t\t10\r\n333\t\t辣条\t\t0.5\t\t10\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\ndel\r\n请输入要删除的商品id\r\n222\r\n删除成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nupd\r\n请输入要执行的操作：\r\n0.返回上一级\r\n1.更新商品数量\r\n1\r\n请输入要更新的商品的id\r\n333\r\n请输入要更新的数量\r\n5\r\n更新成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nshw\r\nid\t\tname\t\tprice\t\tnumber\t\t\r\n111\t\t泡面\t\t4.5\t\t10\r\n333\t\t辣条\t\t0.5\t\t5\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\npay\r\n购物车总价为：47.5元\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\next\r\n\r\nProcess finished with exit code 0\r\n```\r\n\r\n\r\n\r\n### 构造器\r\n* 作用: 初始化对象，返回实例化对象的地址\r\n* 分类\r\n  * 有参构造器\r\n  * 无参构造器\r\n* 任何类在定义时 **默认拥有一个无参构造器**\r\n* <green>一旦定义了有参构造器，默认的无参构造器就会消失，若任要使用无参构造器，需自己定义</green>\r\n\r\n**语法格式**\r\n```java\r\nclass 类名{\r\n    public 类名(参数列表){//有参构造器\r\n    }\r\n    public 类名(){//无参构造器\r\n    }\r\n}\r\n```\r\n\r\n**调用构造器**\r\n```java\r\n类名 变量名 = new 构造器(参数列表);\r\n类名 变量名 = new 构造器();\r\n```\r\n\r\n### this关键字\r\n* this表示当前实例对象的地址\r\n* this的值和`new 构造器()`的返回值一致\r\n* 通过this可以访问到当前实例对象的属性和方法\r\n```java\r\nclass Person{\r\n    private String name;\r\n    private int age;\r\n    public Person(String name,int age){\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 封装\r\n**面向对象的三大特征**\r\n* 封装：按一定原则设计对象的属性和方法\r\n* 继承\r\n* 多态\r\n\r\n**封装原则**\r\n* 对象代表什么，就封装对应的数据并提供数据对应的行为\r\n* 案例：人对象 圆对象 门对象\r\n  * 人画圆 draw()方法应当封装到圆对象中，因为画圆需要得知圆半径，而该属性在圆对象中\r\n  * 人开门 open()方法应当封装到门对象中，\r\n\r\n**更安全的封装对象**\r\n* 把成员变量用private属性修饰，使得外部不能直接访问\r\n* 提供getter setter方法向外暴露接口\r\n\r\n```java\r\nclass Person{\r\n    private String name;//私有属性\r\n    private int age;//私有属性\r\n    public setAge(int age){//修改属性值\r\n        if(0<=age && age<= 200){//判断属性值是否合法\r\n            this.age = age;//赋值\r\n        }else{//报错\r\n            System.out.print(\"ERROR\")\r\n        }\r\n    }\r\n    public getAge(){//获取属性值\r\n        return this.age;\r\n    }\r\n}\r\n```\r\n\r\n### 标准javaBean实体类\r\n\r\n**书写要求**\r\n* **必须**有一个无参构造器\r\n* **应当**使用private修饰成员变量\r\n* **应当**提供成员变量对应的setXXX() getXXX()方法\r\n\r\n```java\r\nclass Person{\r\n    private String name;//私有属性\r\n    private int age;//私有属性\r\n    Person(){\r\n        //必须有一个无参构造器\r\n    }\r\n    public setAge(int age){//修改属性值\r\n        if(0<=age && age<= 200){//判断属性值是否合法\r\n            this.age = age;//赋值\r\n        }else{//报错\r\n            System.out.print(\"ERROR\")\r\n        }\r\n    }\r\n    public getAge(){//获取属性值\r\n        return this.age;\r\n    }\r\n    public setName(int name){//修改属性值\r\n        this.name = name;//赋值\r\n    }\r\n    public getName(){//获取属性值\r\n        return this.name;\r\n    }\r\n}\r\n```\r\n\r\n### 成员变量和局部变量的区别\r\n![](./images/java学习笔记/2022-10-23-14-06-19.png)\r\n\r\n\r\n### 对象数组在内存中的占用情况\r\n<green>数组中存储的不是对象而是对象的地址<green>\r\n![](./images/java学习笔记/2022-10-23-14-09-53.png)\r\n\r\n\r\n\r\n\r\n## String字符串类及其常用API\r\n### 相关概念\r\n**`\"常量字符串\"`与`new String()`的区别**\r\n* <green>String类也称不可变字符串类型，在对象创建后不能修改</green>\r\n* 以`\"这是一个字符串常量\"`形式出现的字符串常量对象存储在**堆内存**的**字符串常量池**中\r\n* 字符串的链接操作实际是在堆中开辟了新的空间\r\n* 字符串间的`==`运算 比较的是内存地址\r\n* 相同的字符串常量的地址相同 `==运算` 结果为true\r\n* 以`String s1 = new String(chars);`方式创建的相同的字符串其地址不同 `==运算` 结果为false\r\n\r\n**字符串的链接操作实际是在堆中开辟了新的空间**\r\n![](./images/java学习笔记/2022-10-23-14-38-30.png)\r\n\r\n**相同的字符串常量的地址相同**\r\n![](./images/java学习笔记/2022-10-23-14-42-42.png)\r\n\r\n**以`String s1 = new String(chars);`方式创建的相同的字符串其地址不同**\r\n![](./images/java学习笔记/2022-10-23-14-43-44.png)\r\n\r\n\r\n### APis\r\n#### 构造器\r\n**几种使用`new String()`构造方式创建字符串对象的方法**\r\n```java\r\nString str = \"abc\"\r\nchar[] chars = {'中','国'};\r\nbyte[] bytes = {97,98};\r\n\r\nString s1 = new String();//s1 => \"\"\r\nString s2 = new String(str);//s1 => \"abc\"\r\nString s3 = new String(chars);//s1 => \"中国\"\r\nString s4 = new String(bytes);//s1 => \"ab\"\r\n```\r\n\r\n**面试题**\r\n![](./images/java学习笔记/2022-10-23-15-04-02.png)\r\n![](./images/java学习笔记/2022-10-23-15-09-05.png)\r\n![](./images/java学习笔记/2022-10-23-15-11-20.png)\r\n\r\n#### 常用成员方法\r\n**常用方法**\r\n```java\r\nString strObj1 = \"测试字符串\"\r\nboolean bo = strObj1.equals(strObj2);             //比较字符串内容是否相等\r\nboolean bo = strObj1.equalsIgnoreCase(strObj2);   //比较字符串内容是否相等（忽略大小写）\r\n\r\nint length = strObj1.length();//获取字符串长度\r\n\r\nchar ch = strObj1.charAt(0);//获取第0个字符\r\n\r\nchar[] chars = strObj1.toCharArray();//字符串转char类型数组\r\n\r\nString subStr1 = strObj1.substring(beginIndex,endIndex)//截取内容，index包括前不包括后\r\nString subStr2 = strObj1.substring(beginIndex)//截取内容，从一个下标一直截取到末尾\r\n\r\n\r\nString repStr1 = strObj1.replace(charSequence target,charSequence replacement)//子串替换 不会影响原值\r\nString repStr1 = strObj1.replace(\"金三胖\",\"***\")//敏感词替换\r\n\r\nboolean bo = strObj1.contains(\"金三胖\");//子串包含检测\r\n\r\nboolean bo = strObj1.startsWith(\"金三胖\");//检测是否以某段字符串开头\r\n\r\nString name = \"姓名1,姓名2,姓名3\";\r\nString[] names = name.split(\",\");//根据标点符号分割数组\r\n```\r\n![](./images/java学习笔记/2022-10-23-15-44-19.png)\r\n\r\n\r\n**遍历字符串**\r\n```java\r\nfor(int i = 0;i<str.length();i++ ){\r\n    char ch = charAt(i);\r\n}\r\n```\r\n\r\n### 案例\r\n**生成验证码**\r\n```java\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(genCode(10));\r\n    }\r\n    public static String genCode(int length){\r\n        String chars = \"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0123456789\";\r\n        String code = \"\";\r\n        Random rd = new Random();\r\n        for (int i = 0; i < length; i++) {\r\n            code += chars.charAt( rd.nextInt( chars.length() ) );\r\n        }\r\n        return code;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-23-15-57-23.png)\r\n\r\n**屏蔽手机号中间四位**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(encodeTel(\"17600001729\"));\r\n    }\r\n    public static String encodeTel(String telNum){\r\n        String result = \"\";\r\n        //手机号11位\r\n        result += telNum.substring(0,3);//保留前3位\r\n        result += \"****\";//屏蔽中间4位\r\n        result += telNum.substring(7);//保留最后4位\r\n        return result;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-23-16-19-52.png)\r\n\r\n\r\n## ArraryList集合容器类及其常用API\r\n### 相关概念\r\n* ArraryList是一个支持索引的集合类，和数组类似\r\n* ArraryList集合的类型不固定，大小可变\r\n* ArraryList集合支持增删改查 \r\n* ArraryList集合支持泛型\r\n* 集合（及泛型）中只能存储引用数据类型，不能存基本数据类型 \r\n  * int是基本数据类型 Integer是int的引用数据类型\r\n* <green>但集合类的大小是不固定的(优点)</green>\r\n\r\n### APIs\r\n#### 构造器\r\n```java\r\nnew ArrayList();\r\nnew ArrayList(容量大小);\r\nnew ArrayList(泛型);\r\n```\r\n\r\n**添加元素**\r\n```java\r\nobj.add(element);//添加元素到末尾,返回boolean\r\nobj.add(index,element);//添加元素到指定位置\r\n```\r\n\r\n**测试案例**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        ArrayList list = new ArrayList();\r\n        list.add(\"字符串\");\r\n        list.add('汉');\r\n        list.add(123);\r\n        list.add(0.125);\r\n        list.add(new ArrayList());\r\n        list.add(2,\"新插入的元素\");\r\n        System.out.println(list);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-23-16-23-25.png)\r\n\r\n**支持泛型**\r\n```java\r\nArrayList list1 = new ArrayList();//默认的泛型，支持所有类型\r\nArrayList<Object> list1 = new ArrayList<Object>();//默认的泛型，支持所有类型 Object所有的类型都继承自Object\r\nArrayList<String> list1 = new ArrayList<String>();//仅支持字符串类型的泛型\r\nArrayList<String> list2 = new ArrayList<>();//jdk1.7开始的可以省略后部分泛型类型声明\r\nArrayList<Integer> list3 = new ArrayList<>();//ArrayList存储的是引用数据类型\r\n// ArrayList<int> list4 = new ArrayList<>();//ArrayList不能存储基本数据类型，报错\r\n\r\nlist.add(\"只能添加字符串类型\");\r\n```\r\n#### 常用成员方法\r\n* `add(element)`//在末尾添加元素,返回true/false\r\n* `add(index,element)`//插入元素到指定位置\r\n* `get(index)`\r\n* `size()`\r\n* `E remove(index)` //返回被删除的对象\r\n* `Boolean remove(obj)` //直接删除对象(默认删第一个)，返回true/false \r\n* `E set(index,element)` //修改某位置的值，返回原数值\r\n\r\n![](./images/java学习笔记/2022-10-23-16-36-50.png)\r\n\r\n**遍历ArraryList集合**\r\n```java\r\nfor(int i = 0 ; arr.size();i++){\r\n    list.get(i);\r\n}\r\n```\r\n\r\n### 一些案例\r\n![](./images/java学习笔记/2022-10-23-16-49-06.png)\r\n```java\r\npackage com.yiguiding.package1;\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Random rd = new Random();\r\n        ArrayList<Integer> scores = new ArrayList<>();\r\n        for (int i = 0; i < 40; i++) {//40个学生\r\n            scores.add(rd.nextInt(101));//随机赋值0-100的分数\r\n        }\r\n        System.out.println(\"全班分数为：\");\r\n        System.out.println(scores);//输出\r\n        for (int i = scores.size()-1; i >= 0; i--) {\r\n            //若采用从前往后的遍历方式，删除当前所在位置的元素后，下一个元素的下标将变成本次删除元素的下标，同时下标会自增，这将导致有一个元素没有判断到。要避免这样的问题应当从后往前遍历\r\n            if (scores.get(i)<80) {\r\n                scores.remove(i);\r\n            }\r\n        }\r\n        System.out.println(\"筛选结果为：\");\r\n        System.out.println(scores);//输出\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-23-17-03-01.png)\r\n\r\n\r\n**ArrayList存取、遍历自定义对象**\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        ArrayList<Student> students = new ArrayList<>();\r\n\r\n        students.add(new Student(001,\"张三\",20));\r\n        students.add(new Student(002,\"李四\",20));\r\n        students.add(new Student(003,\"王五\",20));\r\n\r\n        System.out.println(\"id\\t\\tname\\t\\tage\");\r\n        for (int i = 0; i < students.size(); i++) {\r\n            Student stu = students.get(i);\r\n            System.out.println(stu.getId()+\"\\t\\t\"+stu.getName()+\"\\t\\t\"+stu.getAge());\r\n        }\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private int id;\r\n    private String name;\r\n    private int age;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(int id, String name, int age) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n## 面向对象高级\r\n### static关键字\r\n**static静态修饰符的作用**\r\n* 用于修饰`成员变量`和`成员方法`\r\n* <green>静态成员变量表示该成员只在内存中存储一份，可以被共享的访问和修改</green>\r\n\r\n**成员变量的分类**\r\n* 静态成员变量：由static修饰，属于类，加载一次，可被共享\r\n  * **建议**用`类名.静态成员变量名`访问，\r\n  * 也能通过`实例对象名.静态成员变量`访问\r\n* 实例成员变量：无static修饰，属于对象，\r\n  * **只能**用`实例对象名.静态成员变量名`访问\r\n\r\n**成员方法的分类**\r\n* **静态成员方法**:由static修饰，**归属于类**，\r\n  * **建议**用`类名.方法名()`访问，\r\n  * 也能通过`实例对象名.方法名()`访问\r\n* **实例成员方法**:**无**static修饰，**归属于实例对象**，\r\n  * **只能**用`实例对象名.方法名()`访问\r\n\r\n<warn>**注意事项**</warn>\r\n* 静态成员方法 **只能** 访问`静态成员方法`和`静态成员变量`\r\n* 实例方法可以访问静态成员、静态方法\r\n* 静态方法内部不存在`this`\r\n\r\n**定义和使用**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n\r\n        //通过类名访问静态变量和方法（推荐）\r\n        System.out.println(Person.count);\r\n        System.out.println(Person.getTotal());\r\n\r\n        //通过实例化对象访问静态变量和方法（不推荐）\r\n        Person person = new Person();\r\n        System.out.println(person.count);\r\n        System.out.println(person.getTotal());\r\n    }\r\n}\r\nclass Person{\r\n    public static int count=1;//向外暴露的静态变量，外部可直接访问，属于类的成员不属于实例对象的成员\r\n    private static int total=2;//私有的静态变量\r\n    public static int getTotal(){///向外暴露的静态方法，属于原型类，可以通过`类名.方法名()`调用 也可以通过 `实例对象.方法名()`\r\n        return total;//访问同一个类中的静态成员变量可以省略类名\r\n//        return Person.total;//完整写法\r\n//        return this.total;//错误写法:this无法访问到经static修饰的变量,因为静态变量属于原型类不属于实例对象\r\n    }\r\n}\r\n```\r\n\r\n**静态成员变量的内存机制**\r\n![](./images/java学习笔记/2022-10-24-00-45-07.png)\r\n\r\n**静态成员函数的内存机制**\r\n![](./images/java学习笔记/2022-10-24-01-05-49.png)\r\n\r\n\r\n**应用:工具类静态方法**\r\n```java\r\nclass Util{\r\n    static void 函数名(){//复用的静态方法\r\n        //方法\r\n    }\r\n    private Util(){//高级用法：由于工具类无需闯将对象，所以将其构造函数私有化，使其失去创建对象的能力\r\n    }\r\n}\r\n```\r\n\r\n### 代码块\r\n代码块的分类\r\n* 静态代码块 static修饰 属于类 与类一起优先加载 自动触发执行\r\n  * 作用：用于初始化静态资源\r\n* (实例)构造代码块，每次调用构造器函数前都会执行的代码块\r\n  * 作用：初始化实例资源\r\n\r\n```java\r\nclass Person{\r\n    private String name;\r\n    private int age;\r\n    static int PersonCount;\r\n    static{\r\n        System.out.print(\"------------1.静态代码块被执行-------------\");\r\n        PersonCount = 0 ;//初始化personCount\r\n    }\r\n    {\r\n        System.out.print(\"------------ 2.(实例)构造代码块被执行-------------\");\r\n        PersonCount++ ;//自增\r\n    }\r\n    Person(){\r\n        System.out.print(\"------------ 3.构造器被执行-------------\");\r\n        //构造器\r\n    }\r\n}\r\n```\r\n\r\n### 继承extends\r\n使用该关键字可以让一个类和另一个类建立父子关系，子类继承父类的成员变量和方法\r\n\r\n**基本语法**\r\n```java\r\npublic class Student extends People{}\r\nStudent 称为 子类 或 派生类\r\nPeople 称为 父类 或 基类 或 超类\r\n```\r\n\r\n**设计规范**\r\n子类们的相同的属性和方法可以放到父类中定义，子类独有的属性和方法定义在子类中。\r\n\r\n**继承的特点**\r\n* <green>子类可以继承父类的属性和行为<green>\r\n* <green>子类可以继承父类的私有属性和方法，但不能直接访问(可以暴力访问)</green>\r\n  * (是否属于继承是有争议的)\r\n* <green>子类可以访问到父类的静态属性和方法（父类共享给了子类）</green>\r\n  * （是否属于继承是有争议的，因为父类的静态属性和方法任然属于父类，子类只是能够访问它）\r\n* <green>子类不能继承父类的构造器</green>\r\n* 继承遵循**单继承模式** **一个类只能继承一个直接父类**，\r\n  * 因为如果能继承多个父类且父类中有同名的方法，子类就不知道该继承哪一个\r\n* 不支持一次继承多个类，但支持**多层继承**\r\n* java的所有类都是`Object`类的子类\r\n  * 要么默认继承 `public class Student{}`\r\n  * 要么直接继承 `public class Student extends Object{}`\r\n  * 要么间接继承 `public class newStudent extends Student{}`\r\n\r\n**继承的内存分配机制**\r\n![](./images/java学习笔记/2022-10-24-11-24-06.png)\r\n\r\n**继承后成员的访问特点**\r\n* 就近原则\r\n* 访问顺序： `局部变量名、局部函数名` => `子类成员变量名、子类成员函数名` => `父类成员变量名、父类成员函数名`\r\n\r\n**测试案例**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Student std = new Student();\r\n        std.getName();\r\n    }\r\n}\r\nclass Person{\r\n    String name = \"personName\";\r\n}\r\nclass Student extends Person{\r\n    String name = \"studentName\";\r\n    public String getName(){\r\n        String name = \"reagenName\";\r\n        System.out.println(name);//局部变量\r\n        System.out.println(this.name);//子类成员变量\r\n        System.out.println(super.name);//父类成员变量\r\n        return this.name;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-24-12-43-32.png)\r\n\r\n\r\n### 继承后的方法重写\r\n* 重写的方法名称、形参列表必须和被重写的方法一致\r\n* 一般在重写方法时，**声明不变，重新实现**\r\n* <green>父类的私有方法不能被重写</green>\r\n* 子类重写父类方法时，访问权限必须大于等于父类\r\n  * 访问权限( `默认` < `protected` < `public` )\r\n* 子类不能重写父类的静态方法\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Student std = new Student();\r\n        std.test();\r\n    }\r\n}\r\nclass Person{\r\n    String name = \"personName\";\r\n    public void sayHi(){\r\n        System.out.println(\"Hi,my name is \"+name);\r\n    }\r\n}\r\nclass Student extends Person{\r\n    String name = \"studentName\";\r\n    @Override\r\n    //@Override是重写校验注解，java建议程序员在重新的方法上加上注解，加上注解后若函数没有被以重写的方式编译，编译器会报错\r\n    //提高代码可读性\r\npublic void sayHi(){//方法重写\r\n        System.out.println(\"Hi,my name is \"+name);\r\n    }\r\n    public void test(){\r\n        sayHi();//默认调用子类成员方法\r\n        this.sayHi();//显式调用子类成员方法\r\n        super.sayHi();//显式调用父类成员方法\r\n    }\r\n}\r\n```\r\n\r\n### 继承后子类构造器的特点\r\n* 子类的任何构造器(有参/无参)被调用时，默认会先调用父类的无参构造器(若父类没有无参构造器则会报错)\r\n    ```java\r\n    //原理\r\n    class Person{\r\n\r\n    }\r\n    class Student extends Person{\r\n        Student(){\r\n            super();//写不写都有的语句，子类构造器中会默认调用父类的无参构造器\r\n        }\r\n    }\r\n    ```\r\n* 可以重新指定调用父类的有参构造器\r\n    ```java\r\n    class Person{\r\n        String name;\r\n        int age;\r\n        \r\n        Person(String name,int age){\r\n            this.name = name;\r\n            this.age = age;\r\n        }\r\n    }\r\n    class Student extends Person{\r\n        Student(String name,int age){\r\n            super(name,age);//显式调用父类构造器\r\n        }\r\n    }\r\n    ```\r\n\r\n### this和super的使用\r\n![](./images/java学习笔记/2022-10-24-13-33-25.png)\r\n\r\n**注意事项**\r\n* this()和super()都只能放在第一行，所以两者不能共同存在于一个构造器\r\n```java\r\nclass Person{\r\n    String name;\r\n    int age;\r\n\r\n    Person(String name,int age){\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\nclass Student extends Person{\r\n    Student(String name){\r\n        this(name,18);//默认18岁\r\n    }\r\n    Student(String name,int age){\r\n        super(name,age);//显式调用父类构造器\r\n    }\r\n}\r\n```\r\n\r\n## 单例设计模式\r\n### 设计模式\r\n* 开发中遇到的一些问题这些问题每个都有n种解决方案，但只有一种最优解，这些解法的总结就是设计模式\r\n* 设计模式有20种，对应20多种软件开发过程中遇到的问题\r\n* 学设计模式主要学两点\r\n    * 该模式是解决什么问题？\r\n    * 该模式是如何解决的该问题？ 该模式怎么写的？\r\n\r\n**单例模式**\r\n* 保证系统中应用该模式的这个类永远只有一个实例，也就是一个类只能实例化一个对象\r\n* 单例模式的实现方式\r\n  * 饿汉单例模式\r\n  * 懒汉...\r\n\r\n### 饿汉单例\r\n* 私有化构造器\r\n* 定义一个公开的静态成员变量，初始化为一个实例对象\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n\r\n        singleInstance s1 = singleInstance.instance;\r\n        singleInstance s2 = singleInstance.instance;\r\n        System.out.println(s1==s2);//true\r\n    }\r\n}\r\n//饿汉单例：在用户获取对象前，对象已经准备好的\r\nclass singleInstance{\r\npublic static singleInstance instance = new singleInstance(); // 由于静态成员变量只会在类加载时初始化一次，所以当通过`类名.静态属性名`访问变量时，该变量早已初始化好了\r\n    private singleInstance(){//私有化构造器后只有类自己能调用构造器,否则用户可通过构造器创建很多地址不同的对象\r\n    }\r\n}\r\n```\r\n\r\n### 懒汉单例模式\r\n* 私有化构造器\r\n* 定义一个用于保存单例对象的**私有化静态成员变量**\r\n* 公开一个静态成员方法用于获取（在第一次调用时创建）实例对象\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        singleInstance s1 = singleInstance.getInstance();\r\n        singleInstance s2 = singleInstance.getInstance();\r\n        System.out.println(s1==s2);//true\r\n    }\r\n}\r\n//饿汉单例：在用户第一次获取时，创建实例对象\r\nclass singleInstance{\r\n    private static singleInstance instance;//私有化\r\n    private singleInstance(){//私有化构造器后只有类自己能调用构造器,否则用户可通过构造器创建很多地址不同的对象\r\n    }\r\n    public static singleInstance getInstance(){\r\n        if (instance==null){\r\n            instance = new singleInstance();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n## 包Package\r\n**概念、作用**\r\n* 用于分类管理不同的`类`,利于程序的管理和维护\r\n\r\n\r\n**建包**\r\n* 建议的建包语法格式：倒写公司域名.模块名称\r\n* 建议的键包命名规范：小写英文，有意义\r\n```java\r\npackage com.huawei.school;\r\npublic class Student{\r\n}\r\n```\r\n\r\n**导包**\r\n* 相同包下的类可以直接访问\r\n* 不同包下的类必须导包才能使用\r\n* 导包格式：`import 包名.类名;`\r\n* 若要引入两个同名的类，第二个导入的类只能使用完整包名访问类\r\n```java\r\nimport java.util.Scanner;\r\n\r\npackage com.yiguiding.package1.Student;\r\nStudent stu1 = new Student();\r\n\r\npackage com.yiguiding.package2.Student;\r\ncom.yiguiding.package2.Student stu2 =new com.yiguiding.package2.Student();\r\n```\r\n\r\n\r\n## 权限修饰符\r\n**概念**\r\n* 用于修饰成员属性，成员方法,构造器,内部类，不同的修饰符代表不同的访问权限。\r\n* 权限修饰符作用范围：（ `private` -> `默认` -> `protected` -> `public` ）\r\n* 总结\r\n\r\n| 权限修饰符名 | 同类的作用域可访问 | 同包不同类的作用域可访问 | 不同包但为其父类的作用域可访问 | 不同包不同类的作用域可访问 |\r\n| :----------: | :----------------: | :----------------------: | :----------------------------: | :------------------------: |\r\n|   private    |         √          |                          |                                |                            |\r\n|   default    |         √          |            √             |                                |                            |\r\n|  protected   |         √          |            √             |               √                |                            |\r\n|    public    |         √          |            √             |               √                |             √              |\r\n\r\n## final修饰符\r\n* final是关键字，\r\n* 意为最终\r\n* 可修饰 **类** **方法** **变量**\r\n* 作用：\r\n  * 修饰类： 类不能被继承\r\n  * 修饰方法：方法不能被重写\r\n  * 修饰变量：变量被第一次赋值后不能被修改\r\n    * 若修饰的是基本数据类型，变量存储的**数据**值不能改变\r\n    * 若修饰的是引用数据类型，变量存储的**地址**值不能改变，但地址指向的对象内容可变\r\n  \r\n**实例**\r\n```java\r\nclass Person{\r\n    final public void sayHi(){//不能被子类重写的方法\r\n        System.out.println(\"Hi~~\");\r\n    }\r\n}\r\nfinal class  Student extends Person{//不能被继承的对象\r\n    final int id;//不能被修改的变量，只能在第一次赋值\r\n    Student(int id){\r\n        this.id = id;\r\n    }\r\n}\r\n```\r\n\r\n## 常量\r\n* 常量是由`public static final`修饰的变量\r\n* 常量会在编译阶段做宏替换，程序中使用常量的地方都会被替换为字面量\r\n* 好处是执行性能和直接使用字面量一致\r\n* 命名规范是推荐单词全大写多个单词用下划线分隔\r\n```java\r\npublic static final String USER_NAME = \"admin\"\r\n```\r\n\r\n## 枚举\r\n```java\r\n修饰符 enum 枚举名称{\r\n    名称1,名称2,名称3,名称4,名称5;\r\n}\r\n\r\nenum Season{\r\n    SPRING,SUMMER,AUTUMN,WINTER;\r\n}\r\n```\r\n\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Season temp = Season.AUTUMN;\r\n        if (temp == Season.AUTUMN){\r\n            //do something\r\n        }\r\n        switch (temp){//switch中可省略`Season.AUTUMN`的访问方式\r\n            case AUTUMN:\r\n                //do something\r\n                break;\r\n            case SPRING:\r\n                //do something\r\n                break;\r\n        }\r\n    }\r\n}\r\nenum Season{\r\n    SPRING,SUMMER,AUTUMN,WINTER;\r\n}\r\n```\r\n\r\n根据编译再反编译的结果可知：\r\n* 枚举是一个类，\r\n* 枚举是最终类，不能被继承\r\n* 枚举类继承自枚举类型`java.lang.Enum`\r\n* 构造器的构造器都是私有的，对外不能创建对象\r\n* 枚举类的第一行默认是罗列枚举对象的名称\r\n* 枚举类相当于是**多例模式**\r\n\r\n![](./images/java学习笔记/2022-10-24-20-00-56.png)\r\n\r\n## 抽象类、抽象方法\r\n* 在java中abstract是抽象的意思，可以修饰类、成员方法。\r\n* abstract修饰的**类**称为**抽象类**。\r\n* abstract修饰的**方法**称为**抽象方法**。\r\n* <green>抽象方法表示这个方法的具体功能由子类来实现</green>\r\n* <green>含有抽象方法的类必须也声明为抽象类</green>\r\n* 抽象类中可以没有抽象方法，**但有抽象方法的类必为抽象类**\r\n* <warn>一个类继承了抽象类，则该类必须重写该类的所以抽象方法,否则该类必须也是抽象类</warn>\r\n* 抽象类不能修饰构造函数、代码块、成员变量\r\n* **抽象类没有实例化对象的能力（不能创建对象）**\r\n  * 面试题，为什么？\r\n  * 因为：假如抽象类可以创建对象，当用其执行`实例对象.抽象方法名()`，将执行一个没有函数体的方法，这是不合理的\r\n\r\n案例\r\n```java\r\nabstract class Person{//抽象类\r\n    abstract public void sayHi();//抽象方法：不用写方法体\r\n}\r\nclass Student extends Person{\r\n    @Override\r\n    public void sayHi(){//重写方法\r\n        System.out.println(\"你好，我是学生\");\r\n    }\r\n}\r\nclass Teacher extends Person{\r\n    @Override\r\n    public void sayHi(){//重写方法\r\n        System.out.println(\"你好，我是老师\");\r\n    }\r\n}\r\n```\r\n\r\n### final和abstract关系\r\n* final和abstract为互斥关系\r\n* final修饰的类不能被继承，abstract修饰的类需要被继承\r\n* final修饰的方法不能被重写，abstract修饰的方法需要被重写\r\n* final修饰的变量不能被修改，abstract不能修饰变量\r\n\r\n\r\n## 接口\r\n* 接口是一种规范\r\n* **接口是定义来让类实现的，**\r\n* 规范一定是公开的（默认由public修饰）\r\n* <green>实现接口的类称为**实现（implements）类**</green>\r\n* <green>**实现类**可认为是**子类**，接口可认为是实现类的**父类**</green>\r\n* <green>实现类应当重写所有接口的方法，否则实现类就应当是一个抽象类</green>\r\n* <green>接口可以**多实现**：一个实现类可以实现多个接口</green>\r\n* <green>接口可以**多继承**：一个接口可以继承多个接口</green>\r\n\r\n**jdk1.8之后的新特性**\r\n* 接口中可以定义**实例方法**，\r\n  * 必须显式由 `default` 修饰 同时默认还将被`public`修饰\r\n  * 当其被`实现类`继承时，通过`实现类`的`实例对象.实例方法名()`调用\r\n* 接口中可以定义**静态方法**，\r\n  * 必须显式由 `static` 修饰 同时默认还将被`public`修饰\r\n  * 只能通过`接口名.静态方法名()`调用,**不能**通过`实现类`调用，不能通过`实例对象`调用\r\n\r\n**jdk1.9之后的新特性**\r\n* 接口中可以定义**私有方法**，\r\n  * 实际上相当于是一个`私有的`**实例方法**\r\n  * 必须显式由 `private` 修饰 同时默认**不会**被`public`修饰\r\n  * 只能在接口内部通过`方法名()`调用\r\n\r\n**<warn>注意事项(极端语法知识、面试题)<warn>**\r\n* 接口不能创建对象（常识，接口没有构造方法）\r\n* 一个类实现多个接口，被实现的多个接口中的同名**静态方法**不会冲突（因为实现类不会继承接口的静态方法）。\r\n* 一个类实现多个接口，被实现的对各接口中的同名**默认方法**不会冲突，默认也不会继承，子类需要重写该方法\r\n* 一个类继承了父类,同时又实现了一个接口，父类方法名和接口方法名重名时，不会产生冲突，子类会默认继承父类的方法\r\n  *  `修饰符 class 实现类 extends 被继承的类名 implements 接口1,接口2,接口3{}`\r\n* 一个接口继承多个接口时，一般是没问题的，但若被继承的接口中存在声明不一致（返回值，形参列表）的同名方法时，会报错\r\n\r\n**接口定义的语法格式**\r\n```java\r\n//接口格式\r\npublic interface 接口名{\r\n    //1.常量        jdk1.8之前 默认由 `public static final` 修饰\r\n    //2.抽象方法    jdk1.8之前 默认由 `public abstract` 修饰\r\n    //3.实例方法    jdk1.8之后新增的方法 必须显式由 default 修饰，默认 还将 被public修饰\r\n    //4.静态方法    jdk1.8之后新增的方法 必须显式由 static  修饰，默认 还将 被public修饰\r\n    //4.静态方法    jdk1.9之后新增的方法 必须显式由 private 修饰，默认_不会_被public修饰\r\n\r\n    public static final String USER_NAME = \"admin\";//public 和 final都是接口默认自动添加的 可以省略不写\r\n    public abstract void getUuserName(); //public abstract 是接口默认自动添加的 可以省略不写\r\n    default void sayHi(){\r\n        System.out.println(\"在抽象方法中直接新增的实例方法，必须由default修饰\" +\r\n                \"当其被`实现类`继承时，通过`实现类`的`实例对象.实例方法名()`调用\");\r\n    }\r\n}\r\n//接口的实现（或多实现）\r\n修饰符 class 实现类 implements 接口1,接口2,接口3{\r\n    @Override\r\n    // 重写接口的所有方法\r\n}\r\n//接口的多继承\r\npublic interface 接口名 extends 其他接口1,其他接口2,其他接口3,其他接口4 {\r\n    // 新的常量\r\n    // 新的方法\r\n}\r\n```\r\n\r\n**接口的实现**\r\n```java\r\ninterface School{\r\n    void goToSchool();\r\n    void study();\r\n}\r\n\r\nclass Student implements Person,School{\r\n    @Override\r\n    public void run(){\r\n        System.out.println(\"run....\");\r\n    }\r\n    @Override\r\n    public void say(){\r\n        System.out.println(\"say.....\");\r\n    }\r\n    @Override\r\n    public void goToSchool(){\r\n        System.out.println(\"goToSchool.....\");\r\n    }\r\n    @Override\r\n    public void study(){\r\n        System.out.println(\"study.....\");\r\n    }\r\n}\r\n```\r\n\r\n## 多态\r\n>同类型的对象，调用同一个方法，表现出不同的行为\r\n\r\n**多态的前提**\r\n* 有继承/实现关系\r\n* 有父类引用指向子类引用\r\n* 有方法重写\r\n\r\n**使用形式**\r\n```java\r\n父类类型 对象名称 = new 子类构造器名();\r\n接口 对象名称  =  new 实现类构造器();\r\n```\r\n\r\n**多态的成员访问特点**\r\n* 访问成员变量,根据对象的类型访问\r\n* 访问成员方法,根据构造器返回的地址访问<green>(多态侧重于行为)</green>\r\n\r\n\r\n**多态的优势**\r\n* 在多态形式下，子类对象可以实现解耦合，便于扩展和维护\r\n    ```java\r\n    Animal cat = new Cat();\r\n    Animal tiger = new Tiger();\r\n    cat.run();//若cat的run方法的实现需要修改，只需要修改Cat类中的方法，不需要改Tiger的run方法\r\n    tiger.run();\r\n    ```\r\n* 定义方式时，函数的形参用父类型作为参数类型，便可以接收该父类的所有子类\r\n    ```java\r\n    void run(Animal animal){\r\n        //do something...\r\n    }\r\n    run(cat);\r\n    run(tiger);\r\n    ```\r\n\r\n**多态的缺点**\r\n* 多态时，不能访问子类独有的方法\r\n    ```java\r\n    Animal cat = new Cat();\r\n    Animal tiger = new Tiger();\r\n    cat.run();\r\n    tiger.run();\r\n    cat.miaoMiao();//无法调用\r\n    ```\r\n* 若要访问需要进行强制类型转换(强制转换前可用 `instalceof` 判断真实类型)\r\n    ```java\r\n    Animal cat = new Cat();\r\n    Animal tiger = new Tiger();\r\n    cat.run();\r\n    tiger.run();\r\n    if(cat instanceof Cat)//可用 `instalceof` 判断真实类型\r\n      ((Cat)cat).sayMiaoMiao();//强制转换后调用\r\n    ```\r\n\r\n### 抽象类的多态实现测试\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Animal dog = new Dog();\r\n        Animal cat = new Cat();\r\n\r\n        //多态调用，调用子类属性\r\n        dog.run();\r\n        cat.run();\r\n        //强制转换，调用子类方法\r\n        ((Dog)dog).sayWangWangWang();\r\n        ((Cat)cat).sayMiaoMiaoMiao();\r\n\r\n        //多态调用，调用父类属性\r\n        System.out.println(dog.name+\"在跑...\");\r\n        System.out.println(cat.name+\"在跑...\");\r\n\r\n        //强制转换，调用子类属性\r\n        System.out.println(((Dog)dog).name+\"在跑...\");\r\n        System.out.println(((Cat)cat).name+\"在跑...\");\r\n\r\n    }\r\n}\r\nabstract class Animal{\r\n    public String name = \"Animal\";\r\n    abstract public void run();\r\n}\r\nclass Dog extends Animal{\r\n    public String name = \"Dog\";\r\n    public void run(){\r\n        System.out.println(name+\"在跑...\");\r\n    }\r\n    public void sayWangWangWang(){\r\n        System.out.println(\"汪汪汪....\");\r\n    }\r\n}\r\nclass Cat extends Animal{\r\n    public String name = \"Cat\";\r\n    public void run(){\r\n        System.out.println(name+\"在跑...\");\r\n    }\r\n    public void sayMiaoMiaoMiao(){\r\n        System.out.println(\"喵喵喵....\");\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-25-15-43-31.png)\r\n\r\n## 内部类\r\n**内部类就是在一个类的内部又定义了一个类**\r\n\r\n**作用**\r\n* 当一个类的内部,有一部分需要一个完成的结构来描述，且这个完整的结构又只为外部事务提供服务，那么这整个内部的完整结构可以使用内部类来设计。\r\n内部类可以方便\r\n* 内部类可以方便的访问外部类的成员，甚至是私有成员\r\n* 内部类提供了更好的封装性，内部类本身可以使用private protected来修饰\r\n\r\n**一般语法格式**\r\n```java\r\npublic class People{\r\n    public class Heart{\r\n\r\n    }\r\n}\r\n```\r\n\r\n**分类**\r\n* 静态内部类【了解】\r\n* 成员内部类(非静态)【了解】\r\n* 局部内部类【了解】\r\n* 匿名内部类【重点】\r\n\r\n### 静态内部类\r\n**特点**\r\n* 经static修饰\r\n* 属于外部类本身\r\n* 特点和普通类的特点完全一致\r\n* 在静态内部类中能够访问外部类的静态属性和静态方法，但不能访问外部类的实例属性和方法。\r\n\r\n**使用示例**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person.Heart ht = new Person.Heart();\r\n\r\n        ht.getBeatRate();\r\n        ht.setBeatRate(123);\r\n\r\n        ht.getPersonHeight();\r\n        ht.setPersonHeight(321);\r\n    }\r\n}\r\nclass Person{\r\n    public static int height = 170;//外部类的静态属性\r\n    public static void setHeight(int height){//外部类的静态方法\r\n        Person.height = height;\r\n    }\r\n    public static class Heart{\r\n        private int beatRate = 60;\r\n\r\n        public int getBeatRate() {\r\n            return beatRate;\r\n        }\r\n\r\n        public void setBeatRate(int beatRate) {\r\n            this.beatRate = beatRate;\r\n        }\r\n        public int getPersonHeight(){\r\n//            return Person.height; //完整写法\r\n            return height;//省略写法\r\n        }\r\n        public void setPersonHeight(int height_){\r\n//            Person.height = height; //完整写法\r\n            height = height_; //省略写法\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 成员内部类\r\n* 未经static修饰\r\n* 属于外部类的对象\r\n* jdk16之前`成员内部类`不能定义静态成员，之后就可以了\r\n* 在成员内部类中可以访问外部类的静态属性静态方法，也能访问成员属性和成员方法。\r\n\r\n```java\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person.Heart ht = new Person().new Heart();\r\n\r\n        ht.getBeatRate();\r\n        ht.setBeatRate(123);\r\n\r\n        ht.getPersonHeight();\r\n        ht.setPersonHeight(321);\r\n\r\n        ht.getPersonWeight();\r\n        ht.setPersonWeight(111);\r\n        \r\n        Person ps = ht.getThisPerson();\r\n    }\r\n}\r\nclass Person{\r\n    public static int height = 170;//外部类的静态属性\r\n    public int weight = 90;//外部类的实例属性\r\n    public static void setHeight(int height){//外部类的静态方法\r\n        Person.height = height;\r\n    }\r\n    public void setWeight(int weight){\r\n        this.weight = weight;\r\n    }\r\n    public class Heart{\r\n        private int beatRate = 60;\r\n        private static  int size = 100;//jdk 16之后开始支持在成员内部类中定义静态成员\r\n\r\n        public int getBeatRate() {\r\n            return beatRate;\r\n        }\r\n\r\n        public void setBeatRate(int beatRate) {\r\n            this.beatRate = beatRate;\r\n        }\r\n        public int getPersonHeight(){\r\n            return height;//省略写法\r\n        }\r\n        public void setPersonHeight(int height_){\r\n            height = height_; //省略写法\r\n        }\r\n        public int getPersonWeight(){\r\n            return weight;//可以访问外部类的实例属性\r\n        }\r\n        public void setPersonWeight(int weight_){\r\n            setWeight(weight_);//可以访问外部实例方法\r\n        }\r\n        public Person getThisPerson(){\r\n            return People.this;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**面试题**\r\n\r\n![](./images/java学习笔记/2022-10-25-22-44-08.png)\r\n\r\n### 局部内部类\r\n在局部（局部作用域，函数，代码块）定义的类\r\n\r\n**实例**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        class Position{\r\n            public int x;\r\n            public int y;\r\n            Position(int x,int y){\r\n                this.x = x;\r\n                this.y = y;\r\n            }\r\n        }\r\n        \r\n        Position p1 = new Position(123,456);\r\n        Position p2 = new Position(321,654);\r\n\r\n        System.out.println(p1.x);\r\n        System.out.println(p2.y);\r\n    }\r\n}\r\n```\r\n\r\n### 匿名内部类【重点】\r\n* 本质上，匿名内部类是一个没有名字的局部内部类\r\n* 方便创建子类对象，目的是简化代码编写\r\n* 匿名内部类相当于写了一个没有名字子类继承自一个父类，同时返回了这个子类的实例对象\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Animal cat = new Animal() {\r\n            @Override\r\n            void say() {\r\n                System.out.println(\"喵喵喵.....\");\r\n            }\r\n        };\r\n        cat.say();\r\n    }\r\n}\r\nabstract class Animal{\r\n    abstract void say();\r\n}\r\n```\r\n\r\n**匿名内部类的测试案例**\r\n```java\r\nimport javax.swing.*;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        // 创建窗口\r\n        JFrame window = new JFrame(\"测试匿名内部类的窗口\");\r\n        // 创建面板\r\n        JPanel panel = new JPanel();\r\n        // 创建按钮\r\n        JButton btn = new JButton(\"测试按钮\");\r\n\r\n        //把按钮添加到面板\r\n        panel.add(btn);\r\n        //把面板添加到窗口\r\n        window.add(panel);\r\n\r\n        //设置窗口\r\n        window.setSize(400,500);\r\n        window.setLocationRelativeTo(null);//居中显示窗口\r\n        window.setVisible(true);//显示窗口\r\n\r\n//        该函数要求提供一个ActionListener类型的方法，并重写actionPerformed()方法\r\n//        btn.addActionListener(new ActionListener() { // 匿名内部类\r\n//            @Override\r\n//            public void actionPerformed(ActionEvent e) {\r\n//                JOptionPane.showMessageDialog(window,\"按钮的点击事件发生了，且触发了事件回调函数\");\r\n//            }\r\n//        });\r\n\r\n        //简化版\r\n        btn.addActionListener( e -> JOptionPane.showMessageDialog(window,\"按钮的点击事件发生了，且触发了事件回调函数\") );\r\n\r\n    }\r\n}\r\n```\r\n**运行效果**\r\n\r\n![](./images/java学习笔记/2022-10-25-23-45-07.png)\r\n\r\n\r\n## Object类及其常用APIs\r\nObject类是所有类的祖宗类\r\n\r\n### toString()\r\n* **默认**返回该对象在堆内存中的地址\r\n* 一般用法是让子类对其重写\r\n\r\n**默认toString**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person();\r\n        System.out.println(p1.toString());//toString返回地址\r\n        System.out.println(p1);//默认调用toString()\r\n    }\r\n}\r\nclass Person{\r\n    public String name = \"name...\";\r\n    public int age = 22;\r\n}\r\n```\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-01-36-34.png)\r\n\r\n\r\n**重写toString**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person();\r\n        System.out.println(p1.toString());//toString返回地址\r\n        System.out.println(p1);//默认调用toString()\r\n    }\r\n}\r\nclass Person{\r\n    public String name = \"name...\";\r\n    public int age = 22;\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Person{\" +\r\n                \"name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                '}';\r\n    }\r\n}\r\n```\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-01-36-52.png)\r\n\r\n\r\n### equals(Object) \r\n* **默认**比较两地址是否相同\r\n* 可让子类对其重写使其比较两对象成员属性是否相同\r\n\r\n\r\n**默认equals**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person(\"Dyg\",22);\r\n        Person p2 = new Person(\"Dyg\",22);\r\n        System.out.println(p1.equals(p2));//equals()判断对象的所有元素是否相同\r\n        System.out.println(p1==p2);//判断其地址是否相同\r\n    }\r\n}\r\nclass Person{\r\n    public String name;\r\n    public int age;\r\n\r\n    Person(String name,int age){\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n**结果**\r\n![](./images/java学习笔记/2022-10-26-08-24-15.png)\r\n\r\n**重写equals**\r\n\r\n```java\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person(\"Dyg\",22);\r\n        Person p2 = new Person(\"Dyg\",22);\r\n        System.out.println(p1.equals(p2));//equals()判断对象的所有元素是否相同\r\n        System.out.println(p1==p2);//判断其地址是否相同\r\n    }\r\n}\r\nclass Person{\r\n    public String name;\r\n    public int age;\r\n\r\n    Person(String name,int age){\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;//若地址相等则直接返回true\r\n        if (o == null || getClass() != o.getClass()) return false;//若o地址为空，或两者类型不相同 返回false\r\n        Person person = (Person) o;//强制类型转换\r\n        return age == person.age && Objects.equals(name,person.name);//返回他们所有属性是否相同的条件表达式\r\n\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(name, age);\r\n    }\r\n}\r\n```\r\n\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-08-23-23.png)\r\n\r\n\r\n## Objects类及其常用APIs\r\n\r\n### Objects.equals\r\n一种更安全的比较两对象是否相等的方法   \r\n防止在调用`A.equals(B)`时 `A`为`null`产生报错\r\n\r\n**源码**\r\n```java\r\npublic static boolean equals(Object a, Object b) {\r\n    return (a == b) || (a != null && a.equals(b));\r\n}\r\n```\r\n\r\n### Objects.inNull\r\n判断一个对象是否为空\r\n\r\n**源码**\r\n```java\r\n    public static boolean isNull(Object obj) {\r\n        return obj == null;\r\n    }\r\n```\r\n\r\n## StringBuilder类及其常用APIs\r\n* String类创建的对象是一个不可变字符串\r\n* `StringBuilder类`创建的对象是一个**可变字符串**\r\n* **`StringBuilder类`创建的对象在字符串的拼接、修改操作上效率很高**\r\n\r\n\r\n### StringBuilder()构造器\r\n```java\r\n//两种常用构造器\r\nStringBuilder sb1 = new StringBuilder();\r\nStringBuilder sb2 = new StringBuilder(\"测试字符串\");\r\nSystem.out.println(sb1);\r\nSystem.out.println(sb2);\r\n```\r\n\r\n### append(任意类型)\r\n**特点**\r\n* append(形参支持任何类型) \r\n* 返回值为this，支持链式编程\r\n\r\n```java\r\nsb1.append(\"测试\");\r\nsb1.append(123);\r\nsb1.append(123.5).append(true).append(new Object());//链式编程：因为append返回this\r\nSystem.out.println(sb1);\r\nSystem.out.println(sb2);\r\n```\r\n\r\n### reverse()\r\n**特点**\r\n* 反转字符串\r\n* 返回this，支持链式\r\n\r\n```java\r\n//reverse()反转字符串，支持链式\r\nsb1.reverse().reverse();\r\nsb2.reverse();\r\nSystem.out.println(sb1);\r\nSystem.out.println(sb2);\r\n```\r\n\r\n### length()\r\n**特点**\r\n* 返回字符串长度\r\n\r\n```java\r\n//length()返回字符串长度\r\nSystem.out.println(sb1.length());\r\nSystem.out.println(sb2.length());\r\n```\r\n\r\n### toString()\r\n**特点**\r\n* 返回String字符串对象\r\n\r\n```java\r\n//toString()已被其重写，将返回字符串\r\nSystem.out.println(sb1.toString());//调用println则默认会调用toString()\r\nSystem.out.println(sb2.toString());\r\n```\r\n\r\n### 测试\r\n\r\n**输出任意数组值**\r\n```java\r\nimport java.util.Objects;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(intArrtoString(new int[]{1,2,3,4,5,6}));\r\n    }\r\n    public static String intArrtoString(int[] arr){\r\n        if (Objects.isNull(arr)) return null;\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append('[');\r\n        for (int i = 0; i < arr.length; i++) {\r\n            sb.append(arr[i]).append(i==arr.length-1? \"\":',');\r\n        }\r\n        sb.append(']');\r\n        return sb.toString();//返回string\r\n    }\r\n}\r\n```\r\n\r\n**结果**\r\n![](./images/java学习笔记/2022-10-26-11-09-09.png)\r\n\r\n\r\n\r\n**综合测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        //两种常用构造器\r\n        StringBuilder sb1 = new StringBuilder();\r\n        StringBuilder sb2 = new StringBuilder(\"测试字符串\");\r\n        System.out.println(sb1);\r\n        System.out.println(sb2);\r\n\r\n        //append(形参支持任何类型) 返回值为this，支持链式编程\r\n        sb1.append(\"测试\");\r\n        sb1.append(123);\r\n        sb1.append(123.5).append(true).append(new Object());//链式编程：因为append返回this\r\n        System.out.println(sb1);\r\n        System.out.println(sb2);\r\n\r\n        //reverse()反转字符串，支持链式\r\n        sb1.reverse().reverse();\r\n        sb2.reverse();\r\n        System.out.println(sb1);\r\n        System.out.println(sb2);\r\n\r\n        //toString()已被其重写，将返回字符串\r\n        System.out.println(sb1.toString());//调用println则默认会调用toString()\r\n        System.out.println(sb2.toString());\r\n\r\n        //length()返回字符串长度\r\n        System.out.println(sb1.length());\r\n        System.out.println(sb2.length());\r\n    }\r\n}\r\n```\r\n\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-10-49-46.png)\r\n\r\n\r\n## Math类及其常用APIs\r\n* Math是一个工具类\r\n* Math类没有向外提供构造函数，不能创建对象\r\n* **Math向外提供的成员属性和成员变量全部是静态的**\r\n* 使用方式\r\n  * `Math.属性名`\r\n  * `Math.方法名()`\r\n\r\n### 常用APIs\r\n\r\n| 方法名                                       | 说明                                  |\r\n| -------------------------------------------- | ------------------------------------- |\r\n| public static int abs(int a)                 | 获取参数绝对值                        |\r\n| public static double ceil(double a)          | 向上取整                              |\r\n| public static double floor( double a)        | 向下取整                              |\r\n| public static int round(float a)             | 四舍五入                              |\r\n| public static int max(int a,int b)           | 获取两个int值中的较大值               |\r\n| public static double pow( double a,double b) | 返回a的b次幂的值                      |\r\n| public static double random()                | 返回值为double的随机值，范围[0.0,1.0) |\r\n\r\n## System类及其常用APIs\r\n* System类没有向外提供构造函数，不能创建对象\r\n\r\n### 常用APIs\r\n\r\n| 方法名                                                                         | 说明                                       |\r\n| ------------------------------------------------------------------------------ | ------------------------------------------ |\r\n| public static void exit(int status)                                            | 终止当前运行的Java虚拟机，非零表示异常终止 |\r\n| public static long currentTimeMillis()                                         | 返回当前系统的时间毫秒值形式               |\r\n| public static void arraycopy(数据源数组,起始索引,目的地数组,起始索引,拷贝个数) | 数组拷贝                                   |\r\n\r\n\r\n**测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        //代码性能测试\r\n        long startTime = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            System.out.println(i);\r\n        }\r\n        long endedTime = System.currentTimeMillis();\r\n        long gap = endedTime - startTime;\r\n        System.out.println(\"耗时\"+gap/1000.0+\"s\");\r\n\r\n        //数组拷贝\r\n        int[] arr1 = {111,222,333,444,555};\r\n        int[] arr2 = new int[20];// [0,0,0,0,0,0,0,0,......]\r\n        System.arraycopy(arr1,0,arr2,10,5);\r\n        System.out.println(intArrtoString(arr2));\r\n\r\n        //提前结束java虚拟机\r\n        System.exit(123);\r\n        System.out.println(\"？？？\");\r\n    }\r\n    public static String intArrtoString(int[] arr){\r\n        if (Objects.isNull(arr)) return null;\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append('[');\r\n        for (int i = 0; i < arr.length; i++) {\r\n            sb.append(arr[i]).append(i==arr.length-1? \"\":',');\r\n        }\r\n        sb.append(']');\r\n        return sb.toString();//返回string\r\n    }\r\n}\r\n```\r\n**运行结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-11-48-57.png)\r\n\r\n\r\n## BigDecimal类及其常用APIs\r\n**用于解决浮点数运算精度失真的问题:**\r\n```java\r\nSystem.out.println(0.09+0.01);\r\n```\r\n**失真的输出结果：**\r\n\r\n![](./images/java学习笔记/2022-10-26-12-38-31.png)\r\n\r\n\r\n### BigDecimal构造函数\r\n* **BigDecimal提供了多个构造函数**\r\n* **BigDecimal构造函数使用<warn>注意事项</warn>**\r\n    * BigDecimal提供了`BigDecimal(double)`的构造函数,**通过这种方式传递浮点数仍然存在浮点数的精度问题**\r\n    * 应当使用的创建BigDecimal对象的方式\r\n      * `BigDecimal(String)`\r\n      * `BigDecimal.valueOf(double)` 该方法内部使用了Double.toString方法，此方法按照double实际能表示的精度对尾数进行了截取\r\n```java\r\n//实际推荐的用法\r\nBigDecimal b1 = new BigDecimal(\"0.135\");\r\nBigDecimal b1 = new BigDecimal(0.135.toString());\r\nBigDecimal b1 = BigDecimal.valueOf(0.135);\r\n```\r\n\r\n### 常用APIs\r\n | 方法名                                                                   | 说明         |\r\n | ------------------------------------------------------------------------ | ------------ |\r\n | public BigDecimal add(BigDecimal b)                                      | 加法         |\r\n | public BigDecimal subtract(BigDecimal b)                                 | 减法         |\r\n | public BigDecimal multiply(BigDecimal b)                                 | 乘法         |\r\n | public BigDecimal divide(BigDecimal b)                                   | 除法         |\r\n | public Double doubleValue()                                              | 获取double值 |\r\n | BigDecimal.valueOf(money).setScale(2,RoundingMode.HALF_UP).doubleValue() | 四舍五入     |\r\n\r\n**add()方法使用测试**\r\n```java\r\nimport java.math.BigDecimal;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        BigDecimal b1 = BigDecimal.valueOf(0.123);\r\n        BigDecimal b2 = BigDecimal.valueOf(0.123);\r\n\r\n        BigDecimal result = b1.add(b2);\r\n        Double result_db = result.doubleValue();\r\n\r\n        System.out.println(result);\r\n        System.out.println(result_db);\r\n    }\r\n}\r\n```\r\n\r\n### 精度问题\r\nBigDecimal只能处理**有限小数**\r\n\r\n**BigDecimal无法处理无限小数**\r\n```java\r\nBigDecimal b1 = BigDecimal.valueOf(10.0);\r\nBigDecimal b2 = BigDecimal.valueOf(3.0);\r\n\r\nBigDecimal result = b1.divide(b2);//    10.0/3.0 == 0.333333333333333 报错\r\nDouble result_db = result.doubleValue();\r\n\r\nSystem.out.println(result);\r\nSystem.out.println(result_db);\r\n```\r\n![](./images/java学习笔记/2022-10-26-13-14-44.png)\r\n\r\n**正确写法:**\r\n```java\r\nBigDecimal b1 = BigDecimal.valueOf(10.0);\r\nBigDecimal b2 = BigDecimal.valueOf(3.0);\r\n\r\nBigDecimal result = b1.divide(b2,3, RoundingMode.CEILING);//    指定保留的小数位数和最后一位小数的进位模式（四舍五入、向上取整，向下取整......）\r\nDouble result_db = result.doubleValue();\r\n\r\nSystem.out.println(result);\r\nSystem.out.println(result_db);\r\n```\r\n![](./images/java学习笔记/2022-10-26-13-14-23.png)\r\n\r\n### 二次封装\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(0.09+0.01);\r\n        System.out.println(add(0.09,0.01));\r\n    }\r\n    public static double add(double a,double b){\r\n        return BigDecimal.valueOf(a).add(BigDecimal.valueOf(b)).doubleValue();\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-13-06-14.png)\r\n\r\n## Date日期对象及常用APIs\r\n\r\n### 构造器\r\n| 构造器名称      | 描述                             |\r\n| --------------- | -------------------------------- |\r\n| Date()          | 返回一个代表当前时间Date对象     |\r\n| Date(long date) | 根据传入的毫秒数返回一个Date对象 |\r\n\r\n\r\n```java\r\nDate d1 = new Date();\r\nSystem.out.println(d1);//输出值不是对象的地址，表示其toString方法被重写了\r\n```\r\n![](./images/java学习笔记/2022-10-26-13-36-10.png)\r\n\r\n\r\n### 常用方法\r\n| API名称          | 描述             |\r\n| ---------------- | ---------------- |\r\n| getTime()        | 获取毫秒值       |\r\n| setTime()        | 设置毫秒值       |\r\n| a.before(Date b) | 判断是否a在b之前 |\r\n| a.after(Date b)  | 判断是否a在b之后 |\r\n\r\n```java\r\nDate d1 = new Date();\r\nSystem.out.println(d1.getTime());\r\n```\r\n![](./images/java学习笔记/2022-10-26-13-38-06.png)\r\n\r\n\r\n## SimpleDateFormat 日期对象及常用APIs\r\n### 构造器\r\n| 构造器名称                       | 描述     |\r\n| -------------------------------- | -------- |\r\n| SimpleDateFormat()               | 默认格式 |\r\n| SimpleDateFormat(String pattern) | 指定格式 |\r\n\r\n格式\r\n| 年  | 月  | 日  | 时  | 分  | 秒  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| y   | M   | d   | H   | m   | s   |\r\n\r\n**案例**\r\n```java\r\nSimpleDateFormat sfm1 = new SimpleDateFormat();//按默认格式化\r\nSimpleDateFormat sfm2 = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss EEE a\");//按指定形式格式化\r\n```\r\n\r\n### 常用方法\r\n| API名称                   | 描述                      |\r\n| ------------------------- | ------------------------- |\r\n| setTime(Object time)      | 将毫秒数格式化            |\r\n| String format(Data data)  | 将日期对象格式化          |\r\n| Data parse(String source) | e解析日期字符串为Data对象 |\r\n\r\n**测试format的案例**\r\n```java\r\nSimpleDateFormat sfm1 = new SimpleDateFormat();//按默认格式化\r\nSimpleDateFormat sfm2 = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss EEE a\");//按指定形式格式化\r\nSystem.out.println(sfm1.format(new Date()));//按默认格式化输出\r\nSystem.out.println(sfm2.format(new Date()));//按指定形式格式化输出\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-14-13-27.png)\r\n\r\n**测试parse解析日期字符串的案例（面试题）**\r\n![](./images/java学习笔记/2022-10-26-14-14-40.png)\r\n\r\n\r\n```java\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) throws ParseException {\r\n        String source = \"2021年08月06日11点11分11秒\";\r\n        String result = \"\";\r\n\r\n        System.out.println(\"原时间：\" + source);\r\n\r\n        SimpleDateFormat sfm3 = new SimpleDateFormat(\"yyyy年MM月dd日HH点mm分ss秒\");//按指定形式格式化\r\n        Date d1 = sfm3.parse(source);\r\n        System.out.println( \"时间解析完毕：\" + d1);\r\n\r\n        //定义一些基本单位\r\n        int s = 1000;\r\n        int m = 60*s;\r\n        int h = 60*m;\r\n        int d = 24*h;\r\n        long newTime = d1.getTime() + 2 * d + 14 * h +  49 * m + 6 * s;//2天 14小时 49分 6秒 后\r\n        result = sfm3.format(new Date(newTime));\r\n\r\n        System.out.println(\"2天 14小时 49分 6秒 后的新时间为：\");\r\n        System.out.println(result);\r\n    }\r\n}\r\n\r\n```\r\n**运行结果为：**  \r\n![](./images/java学习笔记/2022-10-26-14-48-12.png)\r\n\r\n\r\n## Calendar 日历对象及常用APIs\r\n* Calendar是一个抽象类，无法直接实例化对象\r\n\r\n### APIs\r\n\r\n| API名称                               | 描述                            |\r\n| ------------------------------------- | ------------------------------- |\r\n| static Calendar getInstance()         | 获取实例化对象（默认当前时间）  |\r\n| public int get(int field)             | 获取日期中的某个字段信息。      |\r\n| public void set(int field,int value)  | 修改日历的某个字段信息。        |\r\n| public void add(int field,int amount) | 为某个字段**增加/减少**指定的值 |\r\n| public final Date getTime()           | **拿到此刻日期对象。**          |\r\n| setTime(Date)                         | **设置日历为某日期对象**        |\r\n| public long getTimeInMillis()         | 拿到此刻时间毫秒值              |\r\n\r\n**测试**\r\n```java\r\nimport java.util.Calendar;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        //获取实例化对象\r\n        Calendar ca = Calendar.getInstance();\r\n        //输出实例化对象\r\n        System.out.println(ca);\r\n\r\n        //获取日期中的某个字段信息。\r\n        System.out.println(ca.get(Calendar.YEAR));\r\n        System.out.println(ca.get(Calendar.MONTH));\r\n        System.out.println(ca.get(Calendar.DAY_OF_MONTH));\r\n\r\n        //修改日历的某个字段信息。\r\n        ca.set(Calendar.YEAR,2023);\r\n        ca.set(Calendar.MONTH,2);\r\n        ca.set(Calendar.DAY_OF_MONTH,2);\r\n\r\n        //为某个字段**增加/减少**指定的值\r\n        ca.add(Calendar.YEAR,2);\r\n        ca.add(Calendar.MONTH,2);\r\n        ca.add(Calendar.DAY_OF_MONTH,2);\r\n\r\n        //拿到此刻日期对象。\r\n        System.out.println(ca.getTime());\r\n        //修改日历时间\r\n//      ca.setTime(new Date());\r\n\r\n        //拿到此刻时间毫秒值\r\n        System.out.println(ca.getTimeInMillis());\r\n\r\n        //再次输出实例化对象\r\n        System.out.println(ca);\r\n    }\r\n}\r\n\r\n```\r\n\r\n输出结果\r\n```\r\njava.util.GregorianCalendar[time=1666769236461,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,MONTH=9,WEEK_OF_YEAR=44,WEEK_OF_MONTH=5,DAY_OF_MONTH=26,DAY_OF_YEAR=299,DAY_OF_WEEK=4,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=27,SECOND=16,MILLISECOND=461,ZONE_OFFSET=28800000,DST_OFFSET=0]\r\n2022\r\n9\r\n26\r\nSun May 04 15:27:16 CST 2025\r\n1746343636461\r\njava.util.GregorianCalendar[time=1746343636461,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2025,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=4,DAY_OF_YEAR=124,DAY_OF_WEEK=1,DAY_OF_WEEK_IN_MONTH=1,AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=27,SECOND=16,MILLISECOND=461,ZONE_OFFSET=28800000,DST_OFFSET=0]\r\n\r\nProcess finished with exit code 0\r\n```\r\n\r\n\r\n## JDK8新增时间类\r\n### `LocalDate`、`LocalTime`、`LocalDateTime`类及其APIs\r\n\r\n**新API特点**\r\n* 严格区分了 `日期` 、 `时间` 、 `日期及时间` 对象\r\n* 对日期和时间的运算更方便\r\n* 新API的类型几乎是不变的，不必担心被修改\r\n\r\n**新增的日期类**\r\n| 类名              | 描述                       |\r\n| ----------------- | -------------------------- |\r\n| **LocalDate**     | 不包含具体时间的日期。     |\r\n| **LocalTime**     | 不含日期的时间。           |\r\n| **LocalDateTime** | 包含了日期及时间。         |\r\n| Instant           | 代表的是时间戳。           |\r\n| DateTimeFormatter | 用于做时间的格式化和解析的 |\r\n| Duration          | 用于计算两个“时间”间隔     |\r\n| Period            | 用于计算两个“日期”间隔     |\r\n\r\n\r\n\r\n\r\n#### 构造函数\r\n| 方法名 | 描述                 |\r\n| ------ | -------------------- |\r\n| now()  | 根据当前时间创建对象 |\r\n| of()   | 根据指定时间创建对象 |\r\n\r\n**使用测试**\r\n```java\r\nimport java.time.LocalDate;\r\nimport java.time.LocalDateTime;\r\nimport java.time.LocalTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDate localDate = LocalDate.now();\r\n        LocalTime localTime = LocalTime.now();\r\n        LocalDateTime localDateTime = LocalDateTime.now();\r\n\r\n        System.out.println(localDate);\r\n        System.out.println(localTime);\r\n        System.out.println(localDateTime);\r\n\r\n        LocalDate localDate1 = LocalDate.of(2022,11,11);\r\n        LocalTime localTime1 = LocalTime.of(11,11,11);\r\n        LocalDateTime localDateTime1 = LocalDateTime.of(2020,10,6,13,23,43);\r\n\r\n        System.out.println(localDate1);\r\n        System.out.println(localTime1);\r\n        System.out.println(localDateTime1);\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-16-34-10.png)\r\n\r\n\r\n#### 常用成员函数APIs\r\n\r\n | 方法名                          | 说明               |\r\n | ------------------------------- | ------------------ |\r\n | public int geYear()             | 获取年             |\r\n | public int getMonthValue()      | 获取月份（1-12)    |\r\n | Public int getDayOfMonth()      | 获取月中第几天乘法 |\r\n | Public int getDayOfYear()       | 获取年中第几天     |\r\n | Public DayOfWeek getDayofweek() | 获取星期           |\r\n\r\n\r\n**成员函数调用测试**\r\n```java\r\nimport java.time.LocalDateTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime localDateTime = LocalDateTime.now();\r\n        System.out.println(localDateTime.getYear());\r\n        System.out.println(localDateTime.getMonthValue());\r\n        System.out.println(localDateTime.getDayOfMonth());\r\n        System.out.println(localDateTime.getHour());\r\n        System.out.println(localDateTime.getMinute());\r\n        System.out.println(localDateTime.getSecond());\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-17-09-23.png)\r\n\r\n**`LocalDate` `LocalTime` `LocalDateTime`之间的类型转换**\r\n| 方法名                         | 说明                    |\r\n| ------------------------------ | ----------------------- |\r\n| public LocalDate toLocalDate() | 转换成一个LocalDate对象 |\r\n| public LocalTime toLocalTime() | 转换成一个LocalTime对象 |\r\n\r\n![](./images/java学习笔记/2022-10-26-17-05-35.png)\r\n\r\n\r\n**类型转换函数测试**\r\n```java\r\nimport java.time.LocalDate;\r\nimport java.time.LocalDateTime;\r\nimport java.time.LocalTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime ldt = LocalDateTime.now();\r\n        LocalDate ld = ldt.toLocalDate();\r\n        LocalTime lt = ldt.toLocalTime();\r\n\r\n        System.out.println(ldt);\r\n        System.out.println(ld);\r\n        System.out.println(lt);\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-17-12-08.png)\r\n\r\n**时间修改的方法**\r\n* **这些方法不会修改原对象的内容**\r\n* **方法会返回一个新对象**\r\n\r\n| 方法名                                             | 说明                                                                  |\r\n| -------------------------------------------------- | --------------------------------------------------------------------- |\r\n| plusDays, plusweeks, plusMonths, plusYears         | 向当前LocalDate对象添加几天、几周、几个月、几年                       |\r\n| minusDays, minusWeeks, minusMonths, minusYears     | 从当前LocalDate 对象减去几天、几周、几个月、几年                      |\r\n| withDayOfMonth, withDayOfYear, withMonth, withYear | 将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate对象 |\r\n| isBefore, isAfter                                  | 比较两个LocalDate                                                     |\r\n| equals                                             | 相等判断                                                              |\r\n\r\n**plus...()测试**\r\n```java\r\nimport java.time.LocalDateTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime ldt = LocalDateTime.now();\r\n\r\n        System.out.println(ldt);\r\n        System.out.println(ldt.plusYears(1));\r\n        System.out.println(ldt.plusMonths(1));\r\n        System.out.println(ldt.plusDays(1));\r\n        System.out.println(ldt.plusHours(1));\r\n        System.out.println(ldt.plusMinutes(1));\r\n        System.out.println(ldt.plusSeconds(1));\r\n        System.out.println(ldt.plusNanos(1));\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-18-26-29.png)\r\n\r\n**isBefore()、isAfter()测试**\r\n```java\r\nimport java.time.LocalDateTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime ldt1 = LocalDateTime.now();\r\n        LocalDateTime ldt2 = LocalDateTime.now();\r\n        \r\n        ldt1 = ldt1.minusDays(1);\r\n        ldt2 = ldt2.plusDays(1);\r\n        \r\n        System.out.println(ldt1);\r\n        System.out.println(ldt2);\r\n\r\n        System.out.println(ldt1.isBefore(ldt2));\r\n        System.out.println(ldt2.isAfter(ldt1));\r\n\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-26-18-38-54.png)\r\n\r\n\r\n### `Instant`类及APIs\r\n\r\n**新API特点**\r\n* 新API的类型几乎是不变的，不必担心被修改\r\n\r\n**新增的日期类**\r\n| 类名              | 描述                       |\r\n| ----------------- | -------------------------- |\r\n| LocalDate         | 不包含具体时间的日期。     |\r\n| LocalTime         | 不含日期的时间。           |\r\n| LocalDateTime     | 包含了日期及时间。         |\r\n| **Instant**       | 代表的是时间戳。           |\r\n| DateTimeFormatter | 用于做时间的格式化和解析的 |\r\n| Duration          | 用于计算两个“时间”间隔     |\r\n| Period            | 用于计算两个“日期”间隔     |\r\n\r\n\r\n#### Instant创建实例对象\r\n**Instant创建实例对象测试**\r\n```java\r\nimport java.time.Instant;\r\nimport java.time.ZoneId;\r\nimport java.time.ZonedDateTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Instant instant = Instant.now();//获取世界标准时间\r\n        System.out.println(instant);\r\n\r\n        ZonedDateTime zdt = instant.atZone(ZoneId.systemDefault());//获取系统默认所在地区时间\r\n        System.out.println(zdt);\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-19-46-41.png)\r\n\r\n#### 一些方法\r\n> 事实上，instant就是jdk8之前的Date\r\n**Date 和 Instant 互相转换**\r\n```java\r\nimport java.time.Instant;\r\nimport java.util.Date;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Instant instant = Instant.now();//获取世界标准时间\r\n\r\n        System.out.println(instant);\r\n\r\n        //Date 和 Instant 互相转换\r\n        Date date = Date.from(instant);\r\n        instant = date.toInstant();\r\n\r\n        System.out.println(instant);\r\n        \r\n    }\r\n}\r\n```\r\n**输出**\r\n\r\n![](./images/java学习笔记/2022-10-26-20-04-12.png)\r\n\r\n\r\n### `Instant`类及APIs\r\n\r\n**新API特点**\r\n* 新API的类型几乎是不变的，不必担心被修改\r\n\r\n**新增的日期类**\r\n| 类名                  | 描述                       |\r\n| --------------------- | -------------------------- |\r\n| LocalDate             | 不包含具体时间的日期。     |\r\n| LocalTime             | 不含日期的时间。           |\r\n| LocalDateTime         | 包含了日期及时间。         |\r\n| Instant               | 代表的是时间戳。           |\r\n| **DateTimeFormatter** | 用于做时间的格式化和解析的 |\r\n| Duration              | 用于计算两个“时间”间隔     |\r\n| Period                | 用于计算两个“日期”间隔     |\r\n\r\n#### 实例化\r\n```java\r\nDateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\r\n```\r\n\r\n#### 方法\r\n\r\n**format()方法**\r\n```java\r\nimport java.time.LocalDateTime;\r\nimport java.time.format.DateTimeFormatter;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime localDateTime = LocalDateTime.now();\r\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n        System.out.println(dateTimeFormatter.format(localDateTime));//正反都能调用\r\n        System.out.println(localDateTime.format(dateTimeFormatter));//正反都能调用\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-26-20-21-46.png)\r\n\r\n**解析时间字符串**\r\n```java\r\nimport java.time.LocalDateTime;\r\nimport java.time.format.DateTimeFormatter;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\r\n        LocalDateTime time = LocalDateTime.parse(\"2011-11-11 11:11:11\",dateTimeFormatter);\r\n        System.out.println(time);\r\n        System.out.println(time.getYear());//解析后可以很方便的获取年 月 日\r\n        System.out.println(time.getMonthValue());\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-26-20-26-33.png)\r\n\r\n\r\n### Period类\r\n**基本作用**\r\n* <green>**用于计算日期间隔**</green>\r\n* 提供的方法主要有`getYears() getMonths() getDays()`,**只能精确到天**\r\n* 用于`LocalDate`对象之间的计算\r\n```java\r\nimport java.time.LocalDate;\r\nimport java.time.Period;\r\n\r\npublic class HelloWorld {\r\n\r\n    public static void main(String[] args)  {\r\n        LocalDate now = LocalDate.now();\r\n        LocalDate birth = LocalDate.of(2001,9,16);\r\n        Period period = Period.between(birth,now);\r\n\r\n        System.out.println(\"你的年龄：\" + period.getYears());\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-26-20-33-38.png)\r\n\r\n\r\n### Duration类\r\n**基本作用**\r\n* <green>**用于计算时间间隔**</green>\r\n* 用于LocalDateTime之间的比较\r\n* 用于Instant之间的比较\r\n\r\n**测试**\r\n```java\r\nimport java.time.Duration;\r\nimport java.time.LocalDateTime;\r\n\r\npublic class HelloWorld {\r\n\r\n    public static void main(String[] args)  {\r\n        LocalDateTime now = LocalDateTime.now();\r\n        LocalDateTime birth = LocalDateTime.of(2001,9,16,0,0,0);\r\n        Duration duration = Duration.between(birth,now);\r\n\r\n        System.out.println(\"你至今已活天数：\" + duration.toDays());\r\n        System.out.println(\"你至今已活小时数：\" + duration.toHours());\r\n        System.out.println(\"你至今已活分钟数：\" + duration.toMinutes());\r\n        System.out.println(\"你至今已活秒数：\" + duration.toSeconds());\r\n    }\r\n}\r\n```\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-20-49-39.png)\r\n\r\n\r\n### ChronoUnit类\r\n\r\n**可用于比较所有单位**\r\n\r\n```java\r\nimport java.time.LocalDateTime;\r\nimport java.time.temporal.ChronoUnit;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime today = LocalDateTime.now( ) ;\r\n        System.out.println(today);\r\n        LocalDateTime birthDate = LocalDateTime.of(1921,1,1,1,1,1);\r\n        System.out.println(birthDate);\r\n        System.out.println(\"相差的年数:\" + ChronoUnit.YEARS.between(birthDate,today));\r\n        System.out.println(\"相差的月数:\"+ChronoUnit.MONTHS.between(birthDate,today));\r\n        System.out.println(\"相差的周数:\" +ChronoUnit.WEEKS.between(birthDate,today));\r\n        System.out. println(\"相差的天数:\" +ChronoUnit.DAYS.between(birthDate,today));\r\n        System.out. println(\"相差的时数:\"+ChronoUnit.HOURS.between(birthDate,today));\r\n        System.out.println(\"相差的分数:\"+ChronoUnit.MINUTES.between(birthDate, today));\r\n        System.out.println(\"相差的秒数:\"+ChronoUnit.SECONDS.between(birthDate,today));\r\n        System.out.println(\"相差的毫秒数:\" +ChronoUnit.MILLIS.between(birthDate,today));\r\n        System.out.println(\"相差的微秒数:\"+ChronoUnit.NANOS.between(birthDate,today));\r\n        System.out.println(\"相差的纳秒数:\" + ChronoUnit.NANOS.between(birthDate,today));\r\n        System.out.println(\"相差的半天数:\"+ChronoUnit.HALF_DAYS.between(birthDate,today));\r\n        System.out.println(\"相差的十年数:\" +ChronoUnit.DECADES.between(birthDate,today));\r\n        System.out.println(\"相差的世纪（百年）数: \" +ChronoUnit.CENTURIES.between(birthDate,today));\r\n        System.out.println(\"相差的千年数:\" +ChronoUnit.MILLENNIA.between(birthDate,today));\r\n        System.out.println(\"相差的纪元数:\" +ChronoUnit.ERAS.between(birthDate,today));\r\n    }\r\n}\r\n```\r\n\r\n## 包装类\r\n\r\n**概念**\r\n* **包装类就是8中基本类型的引用类型**\r\n* java为实现一切皆对象，将基本数据类型进行了包装，抽象成了类\r\n* 集合与泛型只支持包装类型，不支持基本数据类型\r\n\r\n**包装类的特点**\r\n* 自动装包：基本数据类型可直接赋值给包装数据类型\r\n* 自动解包：包装数据类型可直接赋值给基本数据类型\r\n* 包装类的默认值可为null，**容错率更高**\r\n* 可以字符串转包装类(有用)\r\n  * `Integer.parseInt(\"123\")`\r\n  * `Double.parseDouble(\"12.3\")`\r\n  * `Integer.valueOf(\"123\")`\r\n  * `Double.valueOf(\"12.3\")`\r\n* 可以包装类转字符串\r\n  * `obj.toString()`\r\n  * `包装类名.toString()`\r\n\r\n\r\n| 基本数据类型 | 引用数据类型 |\r\n| ------------ | ------------ |\r\n| byte         | Byte         |\r\n| short        | Short        |\r\n| int          | Integer      |\r\n| long         | Long         |\r\n| char         | Character    |\r\n| float        | Float        |\r\n| double       | Double       |\r\n| boolean      | Boolean      |\r\n\r\n**基本使用测试**\r\n```java\r\n        int a = 10;\r\n        Integer aa = 10;\r\n//        Integer aa = new Integer(10);//写法自9起弃用\r\n        System.out.println(a);\r\n        System.out.println(aa);\r\n```\r\n\r\n## 正则表达式\r\n\r\n\r\n### API\r\n**字符串提供的匹配正则表达式的方法**\r\n| API                                                     | 描述                                                                   |\r\n| ------------------------------------------------------- | ---------------------------------------------------------------------- |\r\n| `public Boolean matches(String regex);`                 | 匹配正则成功返回true                                                   |\r\n| `public String replaceAll(String regex,String newStr);` | 对匹配到的内容替换并返回                                               |\r\n| `public String[] split(String regex);`                  | 将匹配到的内容看做分隔符，把被分割符分割的部分提取放到一个字符串数组中 |\r\n\r\n\r\n### 正则语法\r\n\r\n**单字符匹配**\r\n| 正则写法        | 意义                                               |\r\n| --------------- | -------------------------------------------------- |\r\n| `[abc]`         | 只能是a, b,或c                                     |\r\n| `[^abc]`        | 除了a, b, c之外的任何字符                          |\r\n| `[a-zA-Z]`      | (可理解为是：`[[a-z]+[A-Z]]`) a到zA到Z，           |\r\n| `[a-d[m-p]]`    | (可理解为是： `[[a-d]\\|\\|[m-p]]` ) a到d，或m通过p: |\r\n| `[a-z&&[def]]`  | (可理解为是：`[[a-z]&&[def]]`) d,e,或f             |\r\n| `[a-z&&[^bc]]`  | (可理解为是：`[[a-z]&&[^bc]]`) a到z，除了b和c:     |\r\n| `[a-z&&[Am-p]]` | (可理解为是：`[[a-z]&&[Am-p]]`) a到z，除了m到p:    |\r\n\r\n\r\n**预定义单字符匹配**\r\n| 正则写法 | 意义                            |\r\n| -------- | ------------------------------- |\r\n| `.`      | 任意字符                        |\r\n| `\\t`     | 水平制表符                      |\r\n| `\\x0b`   | 垂直制表符                      |\r\n| `\\b`     | backspace退格                   |\r\n| `\\f`     | 换页符                          |\r\n| `\\r`     | 回车CR(carriage return)0x0D     |\r\n| `\\n`     | 换行LF(Line Feed)0x0A           |\r\n| `\\d`     | 数字`[0-9]`                     |\r\n| `\\D`     | 非数字`[^0-9]`                  |\r\n| `\\s`     | 空白字符`[\\t\\x0b\\f\\b\\r\\n]`      |\r\n| `\\S`     | 非空白字符`[^\\t\\x0b\\f\\b\\r\\n]`   |\r\n| `\\w`     | 英文数字下划线`[_a-zA-Z0-9]`    |\r\n| `\\W`     | 非英文数字下划线`[^_a-zA-Z0-9]` |\r\n\r\n**关于回车换行**\r\n* **回车**是传统英文打字机的打字小车回到本行开头但不换行\r\n* **换行**是传统英文打字机的打字小车换到当前位置的下一行\r\n* windows下enter是 `\\r\\n`; \r\n* linux/unix下enter是`\\n`; \r\n* mac下enter是`\\r`\r\n\r\n\r\n\r\n**贪婪匹配**\r\n| 正则写法 | 意义               |\r\n| -------- | ------------------ |\r\n| `X?`     | X 0次或1次         |\r\n| `X*`     | X 0次或多次        |\r\n| `X+`     | X 1次或多次        |\r\n| `X{n}`   | X 正好n次          |\r\n| `X{n,}`  | X 至少n次          |\r\n| `X{n,m}` | X 至少n次不超过m次 |\r\n\r\n\r\n### 案例测试\r\n\r\n**基本使用**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        System.out.println(\"2122312311\".matches(\"[\\\\d]{5,20}\"));//匹配qq号\r\n        System.out.println(\"21223_1ajewor212311\".matches(\"[\\\\w]{6,}\"));//匹配密码：数字字母下换线至少6位\r\n        System.out.println(\"12_1\".matches(\"[0-9a-zA-Z]{4}\"));//匹配验证码：数字+字母，必须四位\r\n        System.out.println(\"12k1\".matches(\"[\\\\w&&[^_]]{4}\"));//匹配验证码：数字+字母，必须四位\r\n    }\r\n}\r\n```\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-27-00-45-16.png)\r\n\r\n\r\n**匹配手机号、匹配邮箱、座机号码、校验金额**\r\n```java\r\npublic class HelloWorld {\r\n\r\n    public static void main(String[] args)  {\r\n        //匹配手机号\r\n        System.out.println(\"13345678901\".matches(\"[1][3-9][\\\\d]{9}\"));//第一位是1 第二位是3~9 剩下9位数字\r\n        //匹配邮箱\r\n        System.out.println(\"176251@qq.com\".matches(\"[\\\\w]{1,}[@][\\\\w]{2,}([\\\\.][\\\\w]{2,}){1,}\"));// 至少一个字符的用户名 + @ + 至少两个字符的域名 + ( 点 + 一级/二级域名 ){至少1次, }\r\n        System.out.println(\"176251@qq.com.cn\".matches(\"[\\\\w]{1,}[@][\\\\w]{2,}([\\\\.][\\\\w]{2,}){1,}\"));\r\n        //匹配座机号码\r\n        System.out.println(\"012-111111111\".matches(\"[0][0-9]{2,5}[-]?[\\\\d]{5,}\"));//0开头 + 2~5位区号 + 可有可无的-符号 + 至少5位的数字\r\n\r\n        //校验金额\r\n        System.out.println(\"12.32\".matches(\"[\\\\d]{1,}([\\\\.][\\\\d]{1,2})?\")); //至少一位数 + 可有可无的(一个小数点 + 至少一个最多两个的数字)\r\n        System.out.println(\"12123123\".matches(\"[\\\\d]{1,}([\\\\.][\\\\d]{1,2})?\")); //至少一位数 + 可有可无的(一个小数点 + 至少一个最多两个的数字)\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-01-18-56.png)\r\n\r\n**splice测试**\r\n```java\r\npublic class HelloWorld {\r\n\r\n    public static void main(String[] args)  {\r\n        String res = \"测试文字一jie0wfj03290测试文字二fjwf2rwdf0测试文字三\";\r\n        String[] tests = res.split(\"\\\\w+\");\r\n        for (int i = 0; i < tests.length; i++) {\r\n            System.out.println(tests[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-01-28-47.png)\r\n\r\n\r\n**replaceAll测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        String res = \"测试文字一jie0wfj03290测试文字二fjwf2rwdf0测试文字三\".replaceAll(\"\\\\w+\",\"\\t\");\r\n        System.out.println(res);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-01-31-04.png)\r\n\r\n\r\n**爬取手机号邮箱号电话号**\r\n```java\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        //内容\r\n        String context = \"电话020-43422424邮箱176251@qq.com电话17625191722,17625191721\";\r\n        \r\n        //定义正则表达式\r\n        String regex = \"([1][3-9][\\\\d]{9})|\" +//匹配手机号\r\n                \"([\\\\w]{1,}[@][\\\\w]{2,}([\\\\.][\\\\w]{2,}){1,})|\" +//匹配邮箱\r\n                \"([0][0-9]{2,5}[-]?[\\\\d]{5,})\";//匹配座机号码\r\n        \r\n        //将正则表达式编译为匹配规则\r\n        Pattern pattern = Pattern.compile(regex);\r\n        \r\n        //根据匹配规则和待匹配的文本得到一个匹配器对象\r\n        Matcher matcher = pattern.matcher(context);\r\n        \r\n        //匹配\r\n        while (matcher.find()){//匹配到\r\n            String finded = matcher.group();//提取\r\n            System.out.println(finded);//输出\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-11-05-30.png)\r\n\r\n\r\n## Arrays数组的工具类\r\n用于操作数组的工具类，\r\n\r\n| 方法名                                                          | 说明                                                                                 |\r\n| --------------------------------------------------------------- | ------------------------------------------------------------------------------------ |\r\n| `public static String tostring(类型[] a)`                       | 将数组转换成字符串                                                                   |\r\n| `public static void sort(类型[]a)    `                          | 对数组进行排序，默认升序排序                                                         |\r\n| `public static <T> void sort(类型[]a, Comparator<? super T> c)` | 使用比较器对象自定义排序                                                             |\r\n| `public static int binarySearch(int[]a, int key)`               | 二分搜索数组中的数据，存在返回索引，不存在返回负数（表示应当插入位置的坐标的负数-1） |\r\n\r\n### tostring\r\n**Arrays.tostring测试**\r\n```java\r\nimport java.util.Arrays;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        int[] arr1 = {1,2,3,4,5,6,7,8,9,10};\r\n        System.out.println(arr1);\r\n        System.out.println(Arrays.toString(arr1));\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-12-18-53.png)\r\n\r\n\r\n### sort\r\n\r\n**Arrays.sort测试**\r\n```java\r\nimport java.util.Arrays;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        int[] arr1 = {10,9,8,7,6,5,4,3,2,1,0};\r\n        Arrays.sort(arr1);\r\n        System.out.println(Arrays.toString(arr1));\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-12-23-19.png)\r\n\r\n\r\n### 自定义sort排序\r\n\r\n**Arrays.sort的自定义排序测试**\r\n```java\r\nimport java.util.Arrays;\r\nimport java.util.Comparator;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Integer[] arr1 = {0,1,2,3,4,5,6,7,8,9,10};//Comparator仅支持引用数据类型\r\n        Arrays.sort(arr1, new Comparator<Integer>() {//Comparator仅支持引用数据类型\r\n            @Override //实际这里是实现了一个接口，重写了接口的compare方法，new了一个匿名的比较器类对象，sort使用了这个比较器对象compare()方法\r\n            public int compare(Integer o1, Integer o2) {\r\n                //return o1-o2;//默认的排序方式 升序排序\r\n                return -(o1-o2);//自定义的 降序排序\r\n            }\r\n        });\r\n        System.out.println(Arrays.toString(arr1));\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-12-49-33.png)\r\n\r\n\r\n**对学生数组根据年龄排序**\r\n\r\n使用Arrays.sort()通过实现Comparator接口类并重写compare()函数实现根据学生年龄排序学生对象数组的测试\r\n```java\r\nimport java.util.Arrays;\r\nimport java.util.Comparator;\r\nimport java.util.Random;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Random rd = new Random();\r\n        Student[] students = new Student[5];\r\n        for (int i = 0; i < students.length; i++) {\r\n            students[i] = new Student(\"随便写的名字\", rd.nextInt(1,50));\r\n        }\r\n        System.out.println(Arrays.toString(students));\r\n\r\n        Arrays.sort(students, new Comparator<Student>() {\r\n            @Override\r\n            public int compare(Student o1, Student o2) {\r\n                //return o1.getAge() - o2.getAge();//按年龄升序排序\r\n                //return -(o1.getAge() - o2.getAge());//按年龄降序排序\r\n                //return -Integer.compare(o1.getAge(),o2.getAge());//按年龄降序排序\r\n                return Integer.compare(o1.getAge(),o2.getAge());//按年龄升序排序\r\n            }\r\n        });\r\n        System.out.println(Arrays.toString(students));\r\n    }\r\n}\r\nclass Student{\r\n    private int age;\r\n    private String name;\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"age=\" + age +\r\n                \", name='\" + name + '\\'' +\r\n                '}';\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-13-06-55.png)\r\n\r\n\r\n\r\n### binarySearch二分查找\r\n\r\n**Arrays.binarySearch()测试**\r\n```java\r\nimport java.util.Arrays;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        int[] arr1 = {100,99,88,77,66,55,44,33,33,11,0};\r\n        int index;\r\n        Arrays.sort(arr1);\r\n        System.out.println(Arrays.toString(arr1));\r\n\r\n        index = Arrays.binarySearch(arr1,99);\r\n        System.out.println(index);\r\n\r\n        index = Arrays.binarySearch(arr1,55);\r\n        System.out.println(index);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-12-27-17.png)\r\n\r\n\r\n## Lambda表达式\r\n* Lambda表达式为jdk8开始的新语法特效\r\n* 作用：简化函数式接口匿名内部类的代码写法\r\n* 注意：\r\n  * 只能简化函数式接口的匿名内部类的写法\r\n  * 函数式接口：有且只有一个抽象方法的接口\r\n\r\nLambda表达式格式\r\n```java\r\n(匿名内部类要重写方法的形参列表)->{\r\n    被重写方法的方法体\r\n}\r\n\r\n单个形参 -> 单条语句同时作为函数返回值\r\n```\r\n\r\n**用法测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Animal cat = () -> {//Lambda表达式\r\n            System.out.println(\"喵喵喵\");\r\n        };\r\n        Animal dog = new Animal() {//完整写法\r\n            @Override\r\n            public void say() {\r\n                System.out.println(\"汪汪汪\");\r\n            }\r\n        };\r\n        cat.say();\r\n        dog.say();\r\n    }\r\n}\r\n@FunctionalInterface //函数式接口\r\ninterface Animal{\r\n    void say();\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-13-44-37.png)\r\n\r\n\r\n**简化测试**\r\n```java\r\nInteger[] arr1 = {0,1,2,3,4,5,6,7,8,9,10};\r\n\r\n//原始写法\r\nArrays.sort(arr1, new Comparator<Integer>() {\r\n    @Override\r\n    public int compare(Integer o1, Integer o2) {\r\n        return -(o1-o2);\r\n    }\r\n});\r\n\r\n//Lambda表达式写法\r\nArrays.sort((Integer o1, Integer o2)->{\r\n        return -(o1-o2);\r\n    }\r\n);\r\n\r\n//Lambda表达式的进一步简化写法\r\nArrays.sort(    (o1,o2)-> -(o1-o2)  );\r\n```\r\n\r\n\r\n## Collection集合\r\n\r\n### Collection集合概念\r\n\r\n**概念**\r\n* **集合是用于存储对象的容器**\r\n* **集合大小不固定，适合做元素的增删改查**\r\n* 集合只能存储引用数据类型的数据，不能存储基本数据类型，但可以存储基本数据类型的包装类\r\n\r\n**两种集合体系**\r\n* Collection单列集合，每个元素只包含一个值\r\n* Map双列集合，每个元素包含两个值（键值对）\r\n![](./images/java学习笔记/2022-10-27-14-36-24.png)\r\n\r\n\r\n\r\n**Collection集合体系**\r\n* `Collection` 是一个接口类\r\n* `List` `Set` 也是接口类, **继承** 自 `Collection` 接口\r\n* `ArrayList` 等类 是实现类\r\n* 集合的实现类**支持泛型**\r\n* 图中是一些**常见**的子接口和实现类\r\n![](./images/java学习笔记/2022-10-27-14-40-19.png)\r\n\r\n\r\n**Collection集合特点**\r\n\r\n**List集合特点：** \r\n* `ArrayList` 添加的元素**有序**、**可重复**、**有索引**\r\n* `LinkedList` 添加的元素**有序**、**可重复**、**有索引**\r\n\r\n**Set集合特点：** \r\n* `HashSet`添加的元素**无序**、**不重复**、**无索引**\r\n* `LinkedHashSet`添加的元素`有序`、**不重复**、**无索引**\r\n* `TreeSet`添加的元素`默认按大小升序排序`、**不重复**、**无索引**\r\n\r\n\r\n\r\n**ArrayList集合特点测试**\r\n* 有序\r\n* 可重复\r\n* 有索引\r\n```java\r\nimport java.util.ArrayList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n        System.out.println(al);//可重复\r\n        System.out.println(al.get(5));//有索引，有顺序\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-15-06-19.png)\r\n\r\n\r\n\r\n**HashSet集合特点测试**\r\n* 无序\r\n* 不可重复\r\n* 无索引\r\n```java\r\nimport java.util.HashSet;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        HashSet al = new HashSet<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n        System.out.println(al);//不可重复，无序\r\n        //System.out.println(al.get(5));//无索引，无法调用\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-15-10-41.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Collection集合常用API\r\n\r\nCollection接口类是单列集合的祖宗类，其中定义的抽象函数，其子接口和子类都会对这些抽象函数重写\r\n\r\n于是，学习Collection接口类中提供的抽象函数，就是在学习其子类们所共有的成员方法。\r\n\r\n\r\n**Collection常用API**\r\n| 方法名称                              | 说明                             |\r\n| ------------------------------------- | -------------------------------- |\r\n| `public boolean add(E e)`             | 把给定的对象添加到当前集合中     |\r\n| `public void clear()`                 | 清空集合中所有的元素             |\r\n| `public boolean remove(E e)`          | 把给定的对象在当前集合中删除     |\r\n| `public boolean contains(Object obj)` | 判断当前集合中是否包含给定的对象 |\r\n| `public boolean isEmpty()`            | 判断当前集合是否为空             |\r\n| `public int size()`                   | 返回集合中元素的个数。           |\r\n| `public Object[] toArray()`           | 把集合中的元素，存储到数组中     |\r\n\r\n\r\n\r\n\r\n### Collection集合遍历\r\n**三种常用遍历集合的方式**\r\n* 迭代器\r\n* 利用加强版`for(ElementType item:obj){}`语法特性\r\n* 结合`集合的forEach方法`和`lambda表达式`\r\n\r\n**原理**\r\n* 三种方式的**本质原理**都是`Collection的子类`**实现了**`Iterable接口`\r\n* 三种方式的依赖关系为 **对Iterable接口的实现** <- **获取Iterator迭代器** <- **使用加强版for(ElementType item:obj){}** <- **使用集合的forEach()方法**\r\n\r\n#### 迭代器\r\n* **迭代器是集合专用遍历方式**\r\n* 迭代器是指`Iterator`对象\r\n* `Iterable`本身是一个接口类，该接口类中定义了`iterator()`方法,该方法返回一个`Iterator`迭代器对象\r\n* `Collection`也是一个接口类，实现该接口类的类实现了这个`Iterable`接口类\r\n* 通过`Collection的实例对象`的`iterator()`方法可以得到一个`Iterator`迭代器实例\r\n\r\n**Collection实例对象创建Iterator的函数**\r\n| 函数名              | 描述                                   |\r\n| ------------------- | -------------------------------------- |\r\n| Iterator iterator() | 返回一个调用者（集合对象）的迭代器对象 |\r\n\r\n**Iterator的方法**\r\n| 函数名                                       | 描述                                                                                                                           |\r\n| -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\r\n| forEachRemaining(Consumer<? super E> action) | Performs the given action for each remaining element until all elements have been processed or the action throws an exception. |\r\n| boolean hasNext()                            | Returns true if the iteration has more elements.                                                                               |\r\n| E next()                                     | Returns the next element in the iteration.                                                                                     |\r\n\r\n**迭代器使用测试**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList<String> al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n\r\n        Iterator<String> iterator = al.iterator(); //创建`Iterator`对象\r\n        while (iterator.hasNext()){//判断是否遍历完成`.hasNext()` \r\n            System.out.println(iterator.next());//获取元素`.next()`\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-16-34-03.png)\r\n\r\n#### 加强版for循环\r\n\r\n**加强版for循环**\r\n* 实现了`iterable`接口的类才能使用`加强版for循环`，而Collection是继承自`iterable`的\r\n* `加强版for循环`**可以遍历集合**，**也能遍历数组**\r\n* 内部原理依然是迭代器对象\r\n  * **猜测应该是**for循环隐式调用了这一系列方法：\r\n    * 1.创建`Iterator`对象`obj.iterator()` \r\n    * 2.判断是否遍历完成`.hasNext()` \r\n    * 3.获取元素`.next()`\r\n* 该语法特性出现于jdk5\r\n\r\n**for新特性语法格式**\r\n```java\r\nfor(ElementType item:obj){\r\n    System.out.println(item);\r\n}\r\n```\r\n\r\n**`加强版for循环`语法特性测试**\r\n```java\r\nimport java.util.ArrayList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList<String> al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n\r\n        for (String item : al) {\r\n            System.out.println(item);\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-16-48-05.png)\r\n\r\n\r\n#### 结合forEach方法和lambda表达式\r\n**关于forEach方法**\r\n* `Iterable接口类`中定义了`forEach方法`,\r\n* 而`Collection接口类`继承自`Iterable接口类`,\r\n* 所以实现了`Collection接口类`的类中也实现了`forEach方法`\r\n* 该方法接收一个**实现函数式接口类**的`匿名对象`\r\n* forEach方法的本质是利用了for的新语法特性\r\n\r\n**测试Collection集合的forEach方法**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.function.Consumer;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Collection<String> al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n\r\n        al.forEach(new Consumer<String>() {\r\n            @Override\r\n            public void accept(String s) {\r\n                System.out.println(s);\r\n            }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n**测试结合Collection集合的forEach方法和lambda表达式**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Collection<String> al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n\r\n        al.forEach( s -> {\r\n                System.out.println(s);\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n\r\n**几种遍历集合方式的总结**\r\n```java\r\n        List<String> list = new LinkedList<>();\r\n        list.add(\"Java\");\r\n        list.add(\"JavaScript\");\r\n        list.add(\"css\");\r\n        list.add(\"html\");\r\n        list.add(\"jquery\");\r\n//1.使用迭代器遍历集合\r\n    //1.1使用迭代器+while循环遍历集合\r\n        //遍历一个集合的最原始做法就是通过集合类实现的Iterator对象来遍历\r\n        Iterator<String> iterator = list.iterator();\r\n        while (iterator.hasNext()){\r\n            String item = iterator.next();\r\n            System.out.println(item);\r\n        }\r\n    //1.2使用迭代器+for循环遍历集合，和原理上述while循环等效\r\n        for (Iterator<String> iterator2 = list.iterator(); iterator2.hasNext();  ) {\r\n            String item = iterator2.next();\r\n            System.out.println(item);\r\n        }\r\n//2.使用增强for遍历集合\r\n        //使用这种方式要求被遍历的集合必须是可迭代的\r\n        //其实实际就是上述 for循环+迭代器 的简化版\r\n        for (String item : list) {\r\n            System.out.println(item);\r\n        }\r\n//3.使用 forEach 遍历集合\r\n        //根据源代码，forEach的本质实际上是使用了 增强版的for的语法\r\n        //所以 使用forEach遍历集合 = 使用增强for遍历集合\r\n        list.forEach(item->{\r\n            System.out.println(item);\r\n        });\r\n//4.使用 for + index下标 + get() 遍历集合，\r\n        // 效率低，且只能遍历有序集合\r\n        for (int index=0 ;index<list.size();index++){\r\n            String item = list.get(index);\r\n            System.out.println(item);\r\n        }\r\n```\r\n\r\n### List系列的集合\r\n\r\n![](./images/java学习笔记/2022-10-28-19-46-48.png)\r\n\r\n**List系列特点：** \r\n* **有序**: 存和取元素的顺序一致\r\n* **可重复**: 存储的元素可以重复\r\n* **有索引**: 可以通过索引操作元素\r\n\r\n**List系列的集合共有方法**\r\n| 方法名称                      | 说明                                   |\r\n| ----------------------------- | -------------------------------------- |\r\n| void add(int index,E element) | 在此集合中的指定位置插入指定的元素     |\r\n| E remove(int index)           | 删除指定索引处的元素，返回被删除的元素 |\r\n| E set(int index,E element)    | 修改指定索引处的元素，返回被修改的元素 |\r\n| E get(int index)              | 返回指定索引处的元素                   |\r\n\r\n**List类共有方法测试**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<String> list = new ArrayList<>();\r\n        list.add(\"Java\");\r\n        list.add(\"JavaScript\");\r\n        list.add(\"css\");\r\n        list.add(\"html\");\r\n        list.add(\"jquery\");//add\r\n        System.out.println(list);\r\n        System.out.println(list.get(3));//get\r\n        list.set(4,\"jQuery\");//set\r\n        System.out.println(list);\r\n        list.remove(1);//romove\r\n        System.out.println(list);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-23-09-02.png)\r\n\r\n\r\n#### ArrayList\r\n\r\n**ArrayList特点**\r\n* 底层基于数组实现\r\n* 根据索引定位元素快、增删慢\r\n* 初始容量为10，之后按1.5倍扩容\r\n\r\n\r\n\r\n#### LinkedList\r\n\r\n**LinkedList特点**\r\n* 底层基于双链表实现\r\n* 查询慢，首尾操作速度快，增删块\r\n* 能当做栈和队列来用\r\n* 有一些特有的首尾操作API\r\n  * addFirst addLast  push offerFirst\r\n  * romoveFirst removeLast pop offerLast\r\n  * getFirst getLast \r\n\r\n**LinkedList特有的首尾操作API测试**\r\n```java\r\nimport java.util.LinkedList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        //栈\r\n        LinkedList<String> stack = new LinkedList<>();\r\n        stack.push(\"111\");\r\n        stack.push(\"222\");\r\n        stack.push(\"333\");\r\n        System.out.println(stack);\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack);\r\n\r\n        //队列\r\n        LinkedList<String> queue = new LinkedList<>();\r\n        queue.add(\"111\");\r\n        queue.add(\"222\");\r\n        queue.add(\"333\");\r\n        System.out.println(queue);\r\n        System.out.println(queue.poll());\r\n        System.out.println(queue.poll());\r\n        System.out.println(queue.poll());\r\n        System.out.println(queue);\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-10-28-09-08-31.png)\r\n\r\n\r\n#### 迭代时删除元素的问题\r\n不能在迭代的过程中直接删除元素，需要利用迭代器的romove方法\r\n\r\n```java\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<String> list = new LinkedList<>();\r\n        list.add(\"111\");\r\n        list.add(\"222\");\r\n        list.add(\"222\");\r\n        list.add(\"333\");\r\n        System.out.println(list);\r\n\r\n        Iterator<String> iterator = list.iterator();\r\n        while (iterator.hasNext()){\r\n            String item = iterator.next();\r\n            System.out.println(item);\r\n            if (item.equals(\"222\")){\r\n                //list.remove(item);//错误写法，会使得数组中元素前移，导致迭代器获取下一个元素时错过一个元素\r\n                iterator.remove();//正确写法，移除当前元素\r\n            }\r\n        }\r\n        System.out.println(list);\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-10-28-09-28-14.png)\r\n\r\n\r\n### Set系列集合\r\n\r\n![](./images/java学习笔记/2022-10-28-19-45-29.png)\r\n\r\n\r\n**Set集合特点：** \r\n* 无序：存取顺序不一致\r\n* 不重复：可以去除重复\r\n* 无索引：<green>不能通过索引访问,没有`get(index)`方法</green>，只能通过迭代器遍历\r\n\r\n\r\n**三种集合实现类特点**\r\n| 实现类类名    | 存储顺序                                           | 重复   | 索引   |\r\n| ------------- | -------------------------------------------------- | ------ | ------ |\r\n| HashSet       | 无序：和输入顺序无关                               | 不重复 | 无索引 |\r\n| LinkedHashSet | **有序：和输入顺序有关**                           | 不重复 | 无索引 |\r\n| TreeSet       | **有序：默认按内容升序排序** <green>可排序</green> | 不重复 | 无索引 |\r\n\r\n\r\n#### HashSet\r\n\r\n**底层原理**\r\n* jdk8之前，**数组**+**链表**(没有最大长度限制)\r\n    ![](./images/java学习笔记/2022-10-28-20-37-00.png)\r\n* jdk8开始，**数组**+**链表**(允许最大长度为8)/**红黑树**(根据hash按大小排序)\r\n    ![](./images/java学习笔记/2022-10-28-20-37-41.png)\r\n* 数组初始长度为16，名为table，即hash表,\r\n* 元素的在hash表中的存储位置根据hashCode函数计算，\r\n* hash冲突时按链式存储，存储过程会调用equals()判断是否重复\r\n* 数组的加载因子为0.75，即当数组存满到16*0.75=12时，自动扩容，扩容两倍\r\n\r\n\r\n**哈希值**\r\n* JDK根据对象的**地址**，按某种规则生成的整型数值\r\n* Object类的API：`public int hashCode();`返回对象的hash值，多次调用，值一致\r\n\r\n**<warn>注意</warn>**  \r\n若希望Set集合认为2个内容一样的自定义对象是重复的，则\r\n* <warn>必须重写`hashCode()`</warn>\r\n* <warn>必须重写`equals()`</warn>\r\n\r\n**HashSet特点测试**\r\n```java\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new HashSet(); //无序：和输入顺序无关\r\n        set.add(\"java\");\r\n        set.add(\"java\");\r\n        set.add(\"HTML\");\r\n        set.add(\"js\");\r\n        set.add(\"css\");\r\n        set.add(\"css\");\r\n        System.out.println(set);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-20-13-02.png)\r\n\r\n\r\n**测试将自定义类（`不重写`hashCode、equals）存入hashset，**\r\n* **无法**实现对内容相同的元素去重\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new HashSet();\r\n        Student student1 = new Student(123,\"DYG\",21,'男');\r\n        Student student2 = new Student(123,\"DYG\",21,'男');\r\n        Student student3 = new Student(123,\"DYG\",21,'男');\r\n        Student student4 = new Student(124,\"DYG\",21,'男');\r\n\r\n        set.add(student1);\r\n        set.add(student2);\r\n        set.add(student3);\r\n        set.add(student4);\r\n\r\n        System.out.println(set);\r\n    }\r\n}\r\nclass Student{\r\n    int id;\r\n    String name;\r\n    int age;\r\n    char sex;\r\n\r\n    public Student(int id, String name, int age, char sex) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nStudent{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                \", sex=\" + sex +\r\n                '}';\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-21-32-58.png)\r\n\r\n\r\n**测试将自定义类（`重写`hashCode、equals）存入hashset，**\r\n* **能够**实现对内容相同的元素去重\r\n\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new HashSet();\r\n        Student student1 = new Student(123,\"DYG\",21,'男');\r\n        Student student2 = new Student(123,\"DYG\",21,'男');\r\n        Student student3 = new Student(123,\"DYG\",21,'男');\r\n        Student student4 = new Student(124,\"DYG\",21,'男');\r\n\r\n        set.add(student1);\r\n        set.add(student2);\r\n        set.add(student3);\r\n        set.add(student4);\r\n\r\n        System.out.println(set);\r\n    }\r\n}\r\nclass Student{\r\n    int id;\r\n    String name;\r\n    int age;\r\n    char sex;\r\n\r\n    public Student(int id, String name, int age, char sex) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nStudent{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                \", sex=\" + sex +\r\n                '}';\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        Student student = (Student) o;\r\n        return id == student.id && age == student.age && sex == student.sex && Objects.equals(name, student.name);\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(id, name, age, sex);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-21-34-26.png)\r\n\r\n\r\n\r\n#### LinkedHashSet\r\n\r\n**底层原理**\r\n* hash表+链表+双链表\r\n* 使用双链表记录添加和删除的顺序\r\n    ![](./images/java学习笔记/2022-10-28-21-42-18.png)\r\n\r\n\r\n**LinkedHashSet特点测试**\r\n\r\n\r\n\r\n```java\r\nimport java.util.LinkedHashSet;\r\nimport java.util.Set;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new LinkedHashSet(); //有序：和输入顺序有关\r\n        set.add(\"java\");\r\n        set.add(\"java\");\r\n        set.add(\"HTML\");\r\n        set.add(\"js\");\r\n        set.add(\"css\");\r\n        set.add(\"css\");\r\n        System.out.println(set);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-20-14-03.png)\r\n\r\n\r\n#### TreeSet\r\n\r\n**底层原理**\r\n* 红黑树\r\n* 增删改查性能好\r\n\r\n**注意**\r\n* 红黑树默认支持排序\r\n* 对于Integer Double,字符串，默认按升序排序\r\n* <warn>对于自定义数据类型，默认无法排序，必须提供自定义排序规则</warn>\r\n* 默认按升序排序，也可按指定规则排序\r\n\r\n**自定义比较规则**\r\n* 方法一：使 **自定义类** 实现Comparable接口\r\n  ```java\r\n    class Student implements Comparable<Student>{\r\n        int id;\r\n        String name;\r\n        int age;\r\n        char sex;\r\n        @Override\r\n        public int compareTo(Student o) {//重写Comparable的compareTo方法\r\n            //return this.id - o.id;\r\n            return Integer.compare(this.id,o.id);//对于集合来说，此处返回0则表示重复，于是便会丢弃该元素\r\n        }\r\n    }\r\n    ```\r\n* 方法二：通过传入**TreeSet()构造器**一个**比较器对象**实现\r\n    ```java\r\n    Set set  = new TreeSet<Student>(new Comparator<Student>() {\r\n        @Override\r\n        public int compare(Student o1, Student o2) {\r\n            return Integer.compare(o1.id,o2.id);\r\n        }\r\n    });\r\n\r\n    Set set  = new TreeSet<Student>((o1,o2)->Integer.compare(o1.id, o2.id));\r\n\r\n    Set set  = new TreeSet<Student>(Comparator.comparingInt(o -> o.id));\r\n    ```\r\n* <warn>注意</warn>：方法一和方法二同时被实现时，程序优先使用**TreeSet()构造器**得到的**比较器对象**\r\n\r\n\r\n**TreeSet特点测试**\r\n```java\r\nimport java.util.Set;\r\nimport java.util.TreeSet;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new TreeSet(); //有序：默认按内容升序排序\r\n        set.add(\"java\");\r\n        set.add(\"java\");\r\n        set.add(\"HTML\");\r\n        set.add(\"js\");\r\n        set.add(\"css\");\r\n        set.add(\"css\");\r\n        System.out.println(set);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-20-15-21.png)\r\n\r\n\r\n**自定义比较规则方法一测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new TreeSet();\r\n        Student student1 = new Student(123,\"DYG\",21,'男');\r\n        Student student2 = new Student(123,\"DYG\",21,'男');\r\n        Student student3 = new Student(123,\"DYG\",21,'男');\r\n        Student student4 = new Student(124,\"DYG\",21,'男');\r\n\r\n        set.add(student1);\r\n        set.add(student2);\r\n        set.add(student3);\r\n        set.add(student4);\r\n\r\n        System.out.println(set);\r\n    }\r\n}\r\nclass Student implements Comparable<Student>{\r\n    int id;\r\n    String name;\r\n    int age;\r\n    char sex;\r\n\r\n    public Student(int id, String name, int age, char sex) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nStudent{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                \", sex=\" + sex +\r\n                '}';\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Student o) {\r\n        //return this.id - o.id;\r\n        return Integer.compare(this.id,o.id);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-22-44-10.png)\r\n\r\n**自定义比较规则方法二测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new TreeSet<Student>((o1,o2)->Integer.compare(o1.id, o2.id));\r\n        Student student1 = new Student(123,\"DYG\",21,'男');\r\n        Student student2 = new Student(123,\"DYG\",21,'男');\r\n        Student student3 = new Student(123,\"DYG\",21,'男');\r\n        Student student4 = new Student(124,\"DYG\",21,'男');\r\n\r\n        set.add(student1);\r\n        set.add(student2);\r\n        set.add(student3);\r\n        set.add(student4);\r\n\r\n        System.out.println(set);\r\n    }\r\n}\r\nclass Student{\r\n    int id;\r\n    String name;\r\n    int age;\r\n    char sex;\r\n\r\n    public Student(int id, String name, int age, char sex) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nStudent{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                \", sex=\" + sex +\r\n                '}';\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-22-58-04.png)\r\n\r\n\r\n## 可变参数\r\n\r\n**概念**\r\n* 用于接收任意`[0-n]`个函数参数\r\n* 在函数内部，可变参数本质为一个数组\r\n\r\n**注意事项**\r\n* 一个函数的形参列表只能有一个可变参数\r\n* 可变参数必须是函数形参列表的最后一个参数\r\n\r\n**语法格式**  \r\n```java\r\n修饰符 返回值 函数名(其他形参的数据类型 其他形参的形参名,可变参数的数据类型...可变参数的参数名称){\r\n\r\n}\r\npublic static void funName(int other,String...strings){\r\n\r\n}\r\n```\r\n\r\n**测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        println();//不传递参数\r\n        println(\"123\");//传入一个\r\n        println(\"123\",\"1234\");//传入两个\r\n        println(new String[]{\"123\",\"456\",\"789\"});//传入一个字符串数组，携带三个元素\r\n    }\r\n    public static void println(String...strings){//strings本质为一个数组\r\n        for (String item:strings) {\r\n            System.out.print(item);\r\n        }\r\n        System.out.print('\\n');\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-23-22-12.png)\r\n\r\n\r\n## 集合的工具类：Collections类\r\n**概念**\r\n* 所在位置：java.utils.Collections\r\n* `Collections类`不属于`Collection类`，\r\n* `Collections类`是用来操作`Collection类`的**工具类**\r\n\r\n**常用API**\r\n| 函数名                                                                     | 解释                                                       |\r\n| -------------------------------------------------------------------------- | ---------------------------------------------------------- |\r\n| `public static <T> boolean addAll(Collection<? super T> c，T... elements)` | 给Collection集合对象批量添加元素                           |\r\n| `public static void shuffle(List<?> list)`                                 | 打乱List集合顺序。                                         |\r\n| `public static<T> void sort(List<T> list)`                                 | 将List集合中元素(实现了Comparable接口的)按照默认规则排序。 |\r\n| `public static<T> void sort(List<T> list，Comparator<? super T> c)`        | 将List集合中元素按照指定规则排序。                         |\r\n\r\n**常用API测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<String> names = new LinkedList<>();\r\n        Collections.addAll(names,\"DYG1\",\"DYG22\",\"DYG333\",\"LRH\",\"CYX\");\r\n        System.out.println(\"批量添加元素后：\"+names);\r\n\r\n        Collections.shuffle(names);\r\n        System.out.println(\"随机打乱后：\"+names);\r\n\r\n        Collections.sort(names);\r\n        System.out.println(\"按默认规则排序后：\"+names);\r\n\r\n        Collections.sort(names, ((o1, o2) -> o1.length()-o2.length()));\r\n        System.out.println(\"按自定规则(长度)排序后：\"+names);\r\n    }\r\n}\r\n```\r\n\r\n## 扑克牌洗牌分牌\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ASetOfCards aSetOfCards = new ASetOfCards();\r\n        aSetOfCards.wash();//洗牌\r\n        List Cars = aSetOfCards.getCars();\r\n        Cars.forEach(item->{\r\n            System.out.println(item);\r\n        });\r\n    }\r\n}\r\n\r\nenum CARD_TYPE{//扑克牌花色：Spade黑桃♠、Heart红心♥、Diamond方块♦、Club梅花♣,JOKER_minor小王,JOKER_major大王\r\n    Spade(\"♠\",0),Heart(\"♥\",1),Diamond(\"♦\",2),Club(\"♣\",3),JOKER_minor(\"小王\\uD83C\\uDCCF\",4),JOKER_major(\"大王\\uD83C\\uDCCF\",5);\r\n    String name;\r\n    int value;\r\n    private CARD_TYPE(String name,int value){\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n\r\n    public int getValue() {\r\n        return this.value;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return  this.name;\r\n    }\r\n}\r\nenum CARD_NUM {//花色\r\n    A(\"A\",12),Two(\"2\",13),Three(\"3\",1),Four(\"4\",2),Five(\"5\",3),Six(\"6\",4),Seven(\"7\",5),Eight(\"8\",6),Nine(\"9\",7),Ten(\"10\",8),J(\"J\",9),Q(\"Q\",10),K(\"K\",11);\r\n    String name;\r\n    int value;\r\n    CARD_NUM(String name,int value){\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n    public int getValue(){\r\n        return this.value;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return  this.name;\r\n    }\r\n}\r\nclass Card implements Comparable<Card>{//一张牌\r\n    CARD_TYPE type;\r\n    CARD_NUM num;\r\n    public Card(CARD_TYPE type, CARD_NUM num) {\r\n        this.type = type;\r\n        this.num = num;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        if (num!=null){\r\n            return num.toString() + type.toString();\r\n        }else{\r\n            return type.toString();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Card o) {\r\n        if (this.type!=CARD_TYPE.JOKER_minor && this.type!=CARD_TYPE.JOKER_major &&\r\n                o.type!=CARD_TYPE.JOKER_minor && o.type!=CARD_TYPE.JOKER_major\r\n        ){//不是大小王则根据牌面值排序\r\n            return -Integer.compare(this.num.getValue(),o.num.getValue());\r\n        }else{//是大小王则根据牌类型排序\r\n            return -Integer.compare(this.type.getValue(),o.type.getValue());\r\n        }\r\n    }\r\n}\r\nclass ASetOfCards{//一副牌\r\n    List cards;//存放所有牌\r\n    ASetOfCards(){\r\n        cards = new LinkedList();\r\n        for(CARD_TYPE type:CARD_TYPE.values()){\r\n            if (type!=CARD_TYPE.JOKER_minor && type!=CARD_TYPE.JOKER_major){\r\n                for (CARD_NUM num:CARD_NUM.values()){\r\n                    cards.add(new Card(type,num));\r\n                }\r\n            }else{\r\n                cards.add(new Card(type,null));\r\n            }\r\n        }\r\n    }\r\n    void wash(){//洗牌\r\n        Collections.shuffle(cards);\r\n    }\r\n    public List getCars(){\r\n\r\n        List result = new LinkedList();\r\n\r\n        List player1 = cards.subList(0,17);\r\n        List player2 = cards.subList(17,34);\r\n        List player3 = cards.subList(34,51);\r\n        List player4 = cards.subList(51,54);//地主的三张牌\r\n\r\n        Collections.sort(player1);//排序\r\n        Collections.sort(player2);//排序\r\n        Collections.sort(player3);//排序\r\n\r\n        Collections.addAll(result,player1,player2,player3,player4);\r\n\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return cards.toString();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-03-51-44.png)\r\n\r\n## 泛型\r\n**泛型概述**\r\n* 泛型:是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。\r\n* 泛型的格式:<数据类型>;注意:泛型只能支持引用数据类型。\r\n* 集合体系的全部接口和实现类都是支持泛型的使用的。\r\n\r\n### 自定义泛型类\r\n**泛型类语法格式**\r\n```java\r\nclass 类名<范式类型T>{\r\n\r\n}\r\n```\r\n\r\n**使用泛型自定义的线性栈的案例**\r\n* 能自动扩容\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        myArrayStack<Object> stack = new myArrayStack<Object>();\r\n        stack.push(1);\r\n        stack.push(2);\r\n        stack.push(3);\r\n        stack.push(4);\r\n        stack.push(5);\r\n        stack.push(6);\r\n        stack.push(7);\r\n        stack.push(8);\r\n        stack.push(9);\r\n        stack.push(10);\r\n        stack.push(11);\r\n        stack.push(12);\r\n        stack.push(13);\r\n        System.out.println(stack);\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack);\r\n    }\r\n}\r\nclass myArrayStack<T>{\r\n    int capacity;\r\n    int position;\r\n    int length;\r\n    T[] stack;\r\n    myArrayStack(){\r\n        capacity=10;\r\n        position=0;\r\n        length = 0;\r\n        stack = (T[]) new Object[capacity];\r\n    }\r\n    void getNewStack(){\r\n        capacity = (int)(capacity*1.5);//1.5倍扩容\r\n        T[] newStack =  (T[]) new Object[capacity];//1.5倍扩容\r\n        for (int i = 0; i < length; i++) {//拷贝\r\n            newStack[i] = stack[i];\r\n        }\r\n        stack = newStack;\r\n    }\r\n    void push(T E){\r\n        if (length!=capacity) {//判断栈满\r\n            length++;\r\n            stack[position++] = E;\r\n        }else{\r\n            getNewStack();//1.5倍扩容,并赋值\r\n            push(E);//重新压入栈\r\n        }\r\n    }\r\n    T pop(){\r\n        if (length!=0){//栈中没有元素了\r\n            length--;\r\n            return stack[--position];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String result=\"\";\r\n        result+='[';\r\n        for (int i = 0; i < length; i++) {\r\n            result+= i==length-1? stack[i]:(stack[i]+\",\");\r\n        }\r\n        result+=']';\r\n        return result;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-10-24-16.png)\r\n\r\n\r\n### 自定义泛型方法\r\n\r\n**泛型方法语法格式**\r\n```java\r\n函数修饰符 <范式类型> 返回类型 函数名(形式参数列表){\r\n\r\n}\r\n```\r\n\r\n**自定义泛型测试**\r\n```java\r\nimport java.util.ArrayList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList names = new ArrayList<>();\r\n        names.add(\"000\");\r\n        names.add(\"111\");\r\n        names.add(\"222\");\r\n        names.add(\"333\");\r\n        names.add(\"444\");\r\n        names.add(\"555\");\r\n\r\n        System.out.println(toString(names.toArray()));\r\n    }\r\n     public static  <T> String toString(T[] res){\r\n         String result=\"\";\r\n         result+='[';\r\n         for (int i = 0; i < res.length; i++) {\r\n             result+= i==res.length-1? res[i].toString():(res[i]+\",\");\r\n         }\r\n         result+=']';\r\n         return result;\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-10-28-12-40-00.png)\r\n\r\n### 自定义泛型接口\r\n\r\n泛型接口可以让实现类选择当前功能需要操作的数据类型\r\n\r\n**泛型接口语法格式**\r\n```java\r\n修饰符 interface 接口名 <范式类型>{\r\n\r\n}\r\n```\r\n\r\n**使用案例测试**\r\n```java\r\ninterface Data<T>{\r\n    void insert(T E);\r\n    void remove(T E);\r\n    void querry(T E);\r\n    void updata(T E);\r\n}\r\n\r\nclass List implements Data<String>{\r\n\r\n    @Override\r\n    public void insert(String E) {\r\n        \r\n    }\r\n\r\n    @Override\r\n    public void remove(String E) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void querry(String E) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void updata(String E) {\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 泛型通配符\r\n**概念**\r\n* ?表示任意泛型\r\n* ?extends Car表示泛型的上限（祖宗类）\r\n* ?super Car表示泛型的下限（子类）\r\n\r\n**应用测试**\r\n\r\n案例中，`carGo`的形式参数应当能够允许接收`ArrayList<BWM>`类和`ArrayList<Benz>`类，但是`carGo`的形式参数不能填`ArrayList<Car>`类，因为这三种类型没有任何关系，即`ArrayList<Car>`类，不是`ArrayList<BWM>`类和`ArrayList<Benz>`类的子类。\r\n\r\n`carGo`的形式参数也不能填`ArrayList<?>`类,因为这意味着,`ArrayList<Dog>`也能被传入`carGo`，这意味着 动物类 也能够参与 汽车类 的处理函数，所以还应当指定**泛型通配符的上限**，即形参应当写`ArrayList<? extends Car>`\r\n\r\n```java\r\nimport java.util.ArrayList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList<BWM> bwms = new ArrayList<>();\r\n        bwms.add(new BWM());\r\n        bwms.add(new BWM());\r\n        bwms.add(new BWM());\r\n        carGo(bwms);\r\n\r\n        ArrayList<Benz> benzs = new ArrayList<>();\r\n        benzs.add(new Benz());\r\n        benzs.add(new Benz());\r\n        benzs.add(new Benz());\r\n        carGo(benzs);\r\n    }\r\n    public static void carGo(ArrayList<? extends Car> cars){\r\n        cars.forEach(e->{\r\n            e.go();\r\n        });\r\n    }\r\n}\r\nabstract class Car{\r\n    abstract void go();\r\n}\r\nclass BWM extends Car{\r\n    @Override\r\n    void go(){\r\n        System.out.println(\"BWM go......\");\r\n    }\r\n}\r\nclass Benz extends Car{\r\n    @Override\r\n    void go(){\r\n        System.out.println(\"Benz go......\");\r\n    }\r\n}\r\nabstract class Animal{\r\n    abstract void go();\r\n}\r\nclass Dog extends Animal {\r\n    @Override\r\n    void go(){\r\n        System.out.println(\"Dog go.......\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n## Map集合\r\n\r\n### 概念\r\n* Map集合是<green>键值对集合</green>\r\n* Map集合独立于Collection集合\r\n* 两种集合区别\r\n  * `Map{key1:value1,key2:value2,key3:value3}`\r\n  * `Collection{value1,value2,value3}`\r\n\r\n**使用场景**\r\n```java\r\n// 购物车内的商品信息\r\nMap{商品id1:商品数量,商品id2:商品数量,商品id3:商品数量}\r\n```\r\n\r\n\r\n\r\n\r\n**Map集合体系**\r\n* ![](./images/java学习笔记/2022-10-29-11-28-37.png)\r\n* 重点为\r\n  * HashMap\r\n  * LinkedHashMap\r\n  * TreeMap\r\n\r\n### API\r\n**Map集合的共有API**\r\n| 方法名称                            | 说明                                 |\r\n| ----------------------------------- | ------------------------------------ |\r\n| v put(K key,v value)                | 添加元素                             |\r\n| v putAll(K key,v value)             | 添加另一个集合中的所有元素           |\r\n| v get(K key)                        | 获取元素，返回元素value或null        |\r\n| V remove(object key)                | 根据键删除键值对元素                 |\r\n| int size()                          | 集合的长度，也就是集合中键值对的个数 |\r\n| void clear()                        | 移除所有的键值对元素                 |\r\n| boolean isEmpty()                   | 判断集合是否为空                     |\r\n| boolean containsKey(object key)     | 判断集合是否包含指定的键             |\r\n| boolean containsValue(0bject value) | 判断集合是否包含指定的值             |\r\n| `public Set<K> keySet()`            | 获取键的集合（不重复）               |\r\n| `public Collection<V> values()`     | 获取值的集合（重复）                 |\r\n\r\n### 特点\r\n\r\n**Map集合特点**：\r\n* 由键决定\r\n* 键是无序，不重复，无索引，值不作要求\r\n* 键值可为null\r\n\r\n**实现类特点**\r\n| 类名          | 存储顺序           | 重复   | 索引   | 值         | 底层原理                                                                                                               | 特有方法 |\r\n| ------------- | ------------------ | ------ | ------ | ---------- | ---------------------------------------------------------------------------------------------------------------------- | -------- |\r\n| HashMap       | 无序               | 不重复 | 无索引 | 值不做要求 | hash表+链表，（HashSet的底层原理就是这里的HashMap）,依赖**键对象**重写的hashCode()和equals()来判断是否唯一             | 无       |\r\n| LinkedHashMap | **和存入顺序有关** | 不重复 | 无索引 | 值不做要求 | hash表+链表+双链表（LinkedHashSet的底层原理就是这里的LinkedHashMap）![](./images/java学习笔记/2022-10-29-13-34-54.png) |          |\r\n| TreeMap       | **自排序**         | 不重复 | 无索引 | 值不做要求 | 红黑树  需要`继承comparable`并重写的**compareTo**方法 **或** 需在排序时传入一个`Comparator`比较器对象                  |          |\r\n\r\n\r\n\r\n\r\n### 遍历\r\n\r\n**Map集合的遍历**\r\n* **方法1**:通过`keySet()`获取的**键的集合**,来找**值**\r\n* **方法2**:通过`entrySet()`将Map转Set，再用Set的**Iterator迭代器**遍历\r\n  * 原理是把`Map`中的**一组键值对**转换成一个包含键值的**Entry对象**`Entry{key,value}`,然后把这些对象放到Set集合中，然后通过**Iterator迭代器**遍历这个集合\r\n* **<green>方法3</green>**:直接使用jdk8提供的`forEach((key,value)->{})`方法\r\n  * 根据源码，原理实际上就是对`方法2`进行了封装\r\n\r\n**方法1测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,Integer> map = new HashMap<>();\r\n        map.put(\"java书\",1);\r\n        map.put(\"java书\",4);\r\n        map.put(\"c++\",3);\r\n        map.put(\"html\",2);\r\n        map.put(\"css\",1);\r\n        map.put(null,null);\r\n\r\n        for(String key:map.keySet()){\r\n            Integer value = map.get(key);\r\n            System.out.println(key + \"--->\" + value);\r\n        }\r\n\r\n        System.out.println(\"-------------------------------------\");\r\n\r\n        map.keySet().forEach(key->{\r\n            Integer value = map.get(key);\r\n            System.out.println(key + \"--->\" + value);\r\n        });\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-12-12-20.png)\r\n\r\n\r\n**方法2测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,Integer> map = new HashMap<>();\r\n        map.put(\"java书\",1);\r\n        map.put(\"java书\",4);\r\n        map.put(\"c++\",3);\r\n        map.put(\"html\",2);\r\n        map.put(\"css\",1);\r\n        map.put(null,null);\r\n\r\n// entrySet + Iterator + while\r\n        Set< Map.Entry<String,Integer> > entrys = map.entrySet();//map<key,value> =转换=> entrys<map元素对象{key,value}>\r\n        Iterator<Map.Entry<String,Integer>> iterator = entrys.iterator();//迭代器<map元素对象{key,value}>\r\n        while ( iterator.hasNext() ){\r\n            Map.Entry<String,Integer> item = iterator.next();//获取 map元素对象{key,value}\r\n            String key = item.getKey();\r\n            Integer value = item.getValue();\r\n            System.out.println(key + \"--->\" + value);\r\n        }\r\n\r\n        System.out.println(\"-------------------------------------\");\r\n\r\n//entrySet + 增强for\r\n        for(Map.Entry<String,Integer> item : map.entrySet()){//此处是对上述while循环的简化版\r\n            String key = item.getKey();\r\n            Integer value = item.getValue();\r\n            System.out.println(key + \"--->\" + value);\r\n        }\r\n\r\n        System.out.println(\"-------------------------------------\");\r\n\r\n//entrySet + forEach\r\n        map.entrySet().forEach(item->{//此处是对上述for循环的简化版\r\n            String key = item.getKey();\r\n            Integer value = item.getValue();\r\n            System.out.println(key + \"--->\" + value);\r\n        });\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-12-33-31.png)\r\n\r\n\r\n**方法3测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,Integer> map = new HashMap<>();\r\n        map.put(\"java书\",1);\r\n        map.put(\"java书\",4);\r\n        map.put(\"c++\",3);\r\n        map.put(\"html\",2);\r\n        map.put(\"css\",1);\r\n        map.put(null,null);\r\n\r\n        map.forEach((key,value)->{\r\n            System.out.println(key + \"--->\" + value);\r\n        });\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-12-49-46.png)\r\n\r\n\r\n### 案例\r\n**统计班级内80个人选择旅游景点ABCD的情况**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Random rd = new Random();\r\n        String[] select = {\"A\",\"B\",\"C\",\"D\"};\r\n        StringBuilder selectData = new StringBuilder();\r\n        for (int i = 0; i < 80; i++) {\r\n            selectData.append(select[rd.nextInt(select.length)]);\r\n        }\r\n        System.out.println(selectData);\r\n\r\n        Map<Character,Integer> map = new HashMap<>();\r\n        for (int i = 0; i < selectData.length(); i++) {\r\n            char key = selectData.charAt(i);\r\n            map.put(key,map.get(key)==null? 1: map.get(key)+1);\r\n        }\r\n        System.out.println(map);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-13-12-01.png)\r\n\r\n### 集合和Map的嵌套\r\n**统计班级内80个人选择旅游景点ABCD的情况**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,List<Character>> data = new HashMap<>();//数据格式：[{姓名1=['A','B','C']},{姓名2=['A','B','C']},{姓名3=['A','B','C']}]\r\n\r\n        List<Character> select1 = new ArrayList<>();//数据格式：['A','B','C']\r\n        Collections.addAll(select1,'A','B','C');\r\n        data.put(\"人名1\",select1);\r\n\r\n        List<Character> select2 = new ArrayList<>();//数据格式：['A','B','C']\r\n        Collections.addAll(select2,'A','B');\r\n        data.put(\"人名2\",select2);\r\n\r\n        List<Character> select3 = new ArrayList<>();//数据格式：['A','B','C']\r\n        Collections.addAll(select3,'A');\r\n        data.put(\"人名3\",select3);\r\n\r\n        System.out.println(\"投票结果:\"+data);\r\n\r\n        Map<Character,Integer> result = new HashMap<>();//数据格式：[A=123,B=123,C=123]\r\n        data.forEach((name,select)->{//遍历 投票结果\r\n            select.forEach(selectedItem->{//遍历 选项\r\n                if (result.containsKey(selectedItem)){//统计情况各选项\r\n                    result.put(selectedItem,result.get(selectedItem)+1);\r\n                }else {\r\n                    result.put(selectedItem,1);\r\n                }\r\n            });\r\n        });\r\n        System.out.println(\"统计结果:\"+result);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-14-05-32.png)\r\n\r\n\r\n## 不可变集合\r\n**概念**\r\n* 不可变集合就是不可以被修改的集合\r\n* 集合的数据项在创建的时候被预先提供，并在整个生命周期不可变，否则报错\r\n* 通过`List、Set、Map的构造器`提供的`of(E...elements)方法`可以创建不可变集合\r\n\r\n| 方法名称                                 | 说明                               |\r\n| ---------------------------------------- | ---------------------------------- |\r\n| `static <E> List<E> of(E...elements)`    | 创建一个具有指定元素的List集合对象 |\r\n| `static<E> Set<E> of(E...elements)`      | 创建一个具有指定元素的Set集合对象  |\r\n| `static <K,V> Map<K，V>of(E...elements)` | 创建一个具有指定元素的Map集合对象  |\r\n\r\n**List不可变集合创建、初始化、修改测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<Integer> list = List.of(111,222,333,444);\r\n        System.out.println(list);\r\n\r\n        list.add(555);//报错\r\n        System.out.println(list);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-14-36-54.png)\r\n\r\n**Set不可变集合创建、初始化、修改测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set<Integer> set = Set.of(111,222,333,444);\r\n        System.out.println(set);\r\n\r\n        set.add(555);//报错\r\n        System.out.println(set);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-14-37-49.png)\r\n\r\n\r\n**Map不可变集合创建、初始化、修改测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,Integer> map = Map.of(\"人名1\",18,\"人名2\",20,\"人名3\",22,\"人名4\",14);\r\n        System.out.println(map);\r\n\r\n        map.put(\"人名5\",17);//报错\r\n        System.out.println(map);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-14-41-51.png)\r\n\r\n## Stream流\r\n### 概念\r\n* 用于简化集合和数组操作的一系列API\r\n* Stream流的三类方法\r\n  * **获取Stream流**:相当于创建一条流水线，并把元素依次放到流水线上\r\n  * **中间方法**：对流水线上的元素进行操作\r\n  * **终极方法**：流水线的最后操作，一个Stream流只能有一个终极方法\r\n* **注意**：在流中无法直接修改原集合、Map、数组中的元素\r\n* **流的收集**：把Stream流操作后的结果收集到集合、Map、数组中\r\n\r\n### 获取Stream流\r\n\r\n**几种获取Stream流的方式**\r\n* 集合获取Stream流：调用实例对象的`.stream()`方法\r\n* Map获取Stream流：调用实例对象的`.entrySet().stream()`方法\r\n* 数组获取Stream流\r\n    | 名称                                             | 所属类 | 说明                                    |\r\n    | ------------------------------------------------ | ------ | --------------------------------------- |\r\n    | `public static <T> Stream<T> stream(T[ ] array)` | Arrays | 获取当前数组的Stream流                  |\r\n    | `public static<T> Stream<T> of(T... values)`     | Stream | 获取当前**数组**/**可变数据**的Stream流 |\r\n\r\n**获取Stream流测试**\r\n```java\r\nimport java.util.*;\r\nimport java.util.stream.Stream;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        /*----------------------------集合获取Stream流----------------------------*/\r\n        Collection<String> collection_names = new LinkedList<>();\r\n        Collections.addAll(collection_names,\"李四\",\"张三\",\"王五\",\"张三丰\",\"张麻子\");\r\n        Stream<String>collection_names_stream = collection_names.stream();\r\n\r\n        /*----------------------------Map获取Stream流----------------------------*/\r\n        Map<String,Integer> map_names = new HashMap<>();\r\n        map_names.put(\"李四\",22);\r\n        map_names.put(\"张三\",18);\r\n        map_names.put(\"王五\",35);\r\n        map_names.put(\"张三丰\",16);\r\n        map_names.put(\"张麻子\",14);\r\n        map_names.put(\"李四\",15);\r\n        Stream<Map.Entry<String,Integer>> map_names_stream = map_names.entrySet().stream();\r\n\r\n        /*----------------------------数组获取Stream流----------------------------*/\r\n        String[] arrary_names = {\"李四\",\"张三\",\"王五\",\"张三丰\",\"张麻子\"};\r\n        Stream<String> arrary_names_stream1 = Arrays.stream(arrary_names);//利用数组对象的静态方法stream()\r\n        Stream<String> arrary_names_stream2 = Stream.of(arrary_names);////利用Stream对象的静态方法of()\r\n    }\r\n}\r\n```\r\n\r\n### Stream的常用中间方法\r\n\r\n| 名称                                                | 说明                                                              |\r\n| --------------------------------------------------- | ----------------------------------------------------------------- |\r\n| `Stream<T> filter(Predicate<? super T> predicate)`  | 用于对流中的数据进行**过滤**。                                    |\r\n| ` Stream<T> limit( long maxSize)`                   | **获取**前几个元素                                                |\r\n| `Stream<T> skip( long n)`                           | **跳过**前几个元素                                                |\r\n| `Stream<T> distinct()`                              | **去除流中重复**的元素。<green>依赖(hashCode和equals方法)</green> |\r\n| **static**`<T> Stream<T> concat(Stream a,Stream b)` | **合并**a和b两个流为一个流                                        |\r\n| `map()`                                             | <green>加工方法</green>                                           |\r\n| `max(比较器对象)`                                   | 将获取到最大值                                                    |\r\n| `sorted(比较器对象)`                                | 排序                                                              |\r\n\r\n**Stream的常用中间方法测试**\r\n```java\r\nimport java.util.*;\r\nimport java.util.stream.Stream;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Collection<String> collection_names = new LinkedList<>();\r\n        Collections.addAll(collection_names,\"李四\",\"张三\",\"王五\",\"张三丰\",\"张麻子\",\"张麻子\");\r\n        System.out.println(\"/*----------------------------collection_names----------------------------*/\");\r\n        System.out.println(collection_names);\r\n\r\n        System.out.println(\"/*----------------------------filter测试----------------------------*/\");\r\n        collection_names.stream().filter(name->name.startsWith(\"张\")&&name.length()==3).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n\r\n        System.out.println(\"/*----------------------------limit测试----------------------------*/\");\r\n        collection_names.stream().limit(2).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n\r\n        System.out.println(\"/*----------------------------skip测试----------------------------*/\");\r\n        collection_names.stream().skip(3).forEach(System.out::println);//方法引用\r\n\r\n        System.out.println(\"/*----------------------------distinct测试----------------------------*/\");\r\n        collection_names.stream().distinct().forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n        System.out.println(\"/*----------------------------map测试----------------------------*/\");\r\n        collection_names.stream().map(name->{\r\n            return \"爱新觉罗 * \" + name;\r\n        }).map(name->{\r\n            return new Person(name);\r\n        }).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n\r\n        System.out.println(\"/*----------------------------static Stream concat测试----------------------------*/\");\r\n        Stream.concat(\r\n                collection_names.stream().limit(2),\r\n                collection_names.stream().skip(2)\r\n        ).distinct().forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n    }\r\n}\r\nclass Person{\r\n    String name;\r\n\r\n    public Person(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Person{\" +\r\n                \"name='\" + name + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-16-52-59.png)\r\n\r\n\r\n\r\n### Stream的常用终极方法\r\n| 名称                          | 说明                                 |\r\n| ----------------------------- | ------------------------------------ |\r\n| void forEach(Consumer action) | 对此流的每个元素执行遍历操作         |\r\n| long count()                  | 返回此流中的元素数                   |\r\n| E get()                       | 当前一级使用了max()时这里可以使用get |\r\n\r\n\r\n### Stream流的收集\r\n**作用**  \r\n把Stream流操作后的结果收集到集合、Map、数组中\r\n\r\n**注意**  \r\n<warn>流只能使用一次<warn>\r\n\r\n\r\n**Stream流的收集方法**\r\n| 名称                             | 说明                         |\r\n| -------------------------------- | ---------------------------- |\r\n| `R collect(collector collector)` | 开始收集Stream流，指定收集器 |\r\n| `Object[] toArray()`             | 转成数组                     |\r\n\r\n**Collectors工具类提供了具体的收集方式**\r\n| 名称                                                                       | 说明                   |\r\n| -------------------------------------------------------------------------- | ---------------------- |\r\n| `public static <T> collector toList()`                                     | 把元素收集到List集合中 |\r\n| `public static <T> collector toSet()`                                      | 把元素收集到Set集合中  |\r\n| `public static collector toMap(Function keyMapper , Function valueMapper)` | 把元素收集到Map集合中  |\r\n\r\n**具体使用步骤**\r\n```java\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.Stream;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<String> names = new ArrayList<>();\r\n        Collections.addAll(names,\"李四\",\"张三\",\"王五\",\"张三丰\",\"张麻子\",\"张麻子\");\r\n//将Stream流收集为List集合\r\n        Stream<String> stream1_names_zhang = names.stream().filter(n->n.startsWith(\"张\")&&n.length()==3);\r\n        List<String> list_names_zhang = stream1_names_zhang.collect(Collectors.toList());//转List集合\r\n        System.out.println(list_names_zhang);\r\n\r\n//将Stream流收集为Set集合\r\n        Stream<String> stream2_names_zhang = names.stream().filter(n->n.startsWith(\"张\")&&n.length()==3);//流只能使用一次，所以要再创建一次\r\n        Set<String> set_names_zhang = stream2_names_zhang.collect(Collectors.toSet());//转Set集合\r\n        System.out.println(set_names_zhang);\r\n\r\n//将Stream流收集为Array数组\r\n        Stream<String> stream3_names_zhang = names.stream().filter(n->n.startsWith(\"张\")&&n.length()==3);\r\n        Object[] arraryName_names_zhang = stream3_names_zhang.toArray();//转Array数组\r\n        System.out.println(Arrays.toString(arraryName_names_zhang));\r\n\r\n//将Stream流收集为Map集合\r\n        Map<String,Integer> persons = new HashMap<>();\r\n        persons.put(\"李四\",17);\r\n        persons.put(\"张三\",13);\r\n        persons.put(\"王五\",14);\r\n        persons.put(\"张三丰\",15);\r\n        persons.put(\"张麻子\",17);\r\n        persons.put(\"张麻子\",18);\r\n        Stream<Map.Entry<String,Integer>> stream4_persons_zhang = persons.entrySet().stream().filter(entry->entry.getKey().startsWith(\"张\")&&entry.getKey().length()==3);\r\n        Map<String,Integer> mapPersons_zhang = stream4_persons_zhang.collect( Collectors.toMap(person->person.getKey(),person->person.getValue()) );\r\n        System.out.println(mapPersons_zhang);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-20-51-08.png)\r\n\r\n\r\n### 案例\r\n\r\n**输出姓张且名字长度为3的人名**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set<String> names = new HashSet();\r\n        Collections.addAll(names,\"张三\",\"李四\",\"王五\",\"张三丰\",\"张麻子\");\r\n        System.out.println(names);\r\n\r\n        System.out.println(\"------------------------------------\");\r\n//使用集合的API获取姓张且名字长度为3的人名\r\n        names.forEach(name->{\r\n            if (name.startsWith(\"张\")&&name.length()==3){\r\n                System.out.println(name);\r\n            }\r\n        });\r\n//stream流式编程：filter支持链式编程\r\n        System.out.println(\"------------------------------------\");\r\n        names.stream().filter(name->name.startsWith(\"张\")).filter(name->name.length()==3).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n\r\n//stream流式编程：filter精简版\r\n        System.out.println(\"------------------------------------\");\r\n        names.stream().filter(name->name.startsWith(\"张\") && name.length()==3).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-15-39-38.png)\r\n\r\n**部门员工工资数据分析**\r\n![](./images/java学习笔记/2022-10-29-19-15-58.png)\r\n```java\r\npackage com.yiguiding.package1;\r\nimport java.math.BigDecimal;\r\nimport java.math.RoundingMode;\r\nimport java.util.*;\r\nimport java.util.stream.Stream;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<Employee> department1 = new LinkedList<>();\r\n        department1.add(new Employee(\"猪八戒\",'男',30000,25000,null));\r\n        department1.add(new Employee(\"孙悟空\",'男',25000,1000,\"顶撞上司\"));\r\n        department1.add(new Employee(\"沙僧\",'男',20000,20000,null));\r\n        department1.add(new Employee(\"小白龙\",'男',20000,25000,null));\r\n\r\n        List<Employee> department2 = new LinkedList<>();\r\n        department2.add(new Employee(\"武松\",'男',15000,9000,null));\r\n        department2.add(new Employee(\"李逵\",'男',20000,10000,null));\r\n        department2.add(new Employee(\"西门庆\",'男',50000,100000,\"被打\"));\r\n        department2.add(new Employee(\"潘金莲\",'女',3500,1000,\"被打\"));\r\n        department2.add(new Employee(\"武大郎\",'男',20000,0,\"下毒\"));\r\n\r\n//1.分别筛选两部门的最高工资的员工信息\r\n        Employee dep1_max_salary = department1\r\n                .stream()\r\n                .max((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .get();\r\n        System.out.println(\"部门1最高工资的员工信息：\"+dep1_max_salary);\r\n        Employee dep2_max_salary = department2\r\n                .stream()\r\n                .max((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .get();\r\n        System.out.println(\"部门2最高工资的员工信息：\"+dep2_max_salary);\r\n\r\n//2.分别统计两部门的平局工资，要求过滤最高和最低工资\r\n        List<Double> dep1_salarys = new LinkedList();\r\n        double dep1_salary_average = 0;\r\n        department1\r\n                .stream()\r\n                .sorted((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)//排序后去除第一个\r\n                .sorted((o1, o2) -> -Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)//反排序后去再掉第一个，实现去除最高和最低工资\r\n                .forEach(employee -> {\r\n                    dep1_salarys.add(employee.getBonus()+employee.getSalary());\r\n                });\r\n        for (double salary : dep1_salarys){\r\n            dep1_salary_average+=salary;\r\n        }\r\n        BigDecimal a = BigDecimal.valueOf(dep1_salary_average);\r\n        BigDecimal b = BigDecimal.valueOf(dep1_salarys.size());\r\n        BigDecimal c ;\r\n        if (dep1_salarys.size()!=0)\r\n            c = a.divide(b,2, RoundingMode.HALF_UP);//计算平均值\r\n        else\r\n            c = a;\r\n        System.out.println(\"部门1的平局工资为：\"+c);\r\n\r\n\r\n        List<Double> dep2_salarys = new LinkedList();\r\n        double dep2_salary_average = 0;\r\n        department2\r\n                .stream()\r\n                .sorted((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)//排序后去除第一个\r\n                .sorted((o1, o2) -> -Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)//反排序后去再掉第一个，实现去除最高和最低工资\r\n                .forEach(employee -> {\r\n                    dep2_salarys.add(employee.getBonus()+employee.getSalary());\r\n                });\r\n        for (double salary : dep2_salarys){\r\n            dep2_salary_average+=salary;\r\n        }\r\n         a = BigDecimal.valueOf(dep2_salary_average);\r\n         b = BigDecimal.valueOf(dep2_salarys.size());\r\n        if (dep2_salarys.size()!=0)\r\n            c = a.divide(b,2, RoundingMode.HALF_UP);//计算平均值\r\n        else\r\n            c = a;\r\n        System.out.println(\"部门2的平局工资为：\"+c);\r\n\r\n//3.统计两个部门的平均工资，要求过滤最高和最低工资\r\n        List<Double> dep1_2_salarys = new LinkedList();\r\n        double dep1_2_salary_average = 0;\r\n        Stream<Employee> dep1_stream = department1.stream();\r\n        Stream<Employee> dep2_stream = department2.stream();\r\n        Stream.concat(dep1_stream,dep2_stream)\r\n                .sorted((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)\r\n                .sorted((o1, o2) -> -Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)\r\n                .forEach(employee->{\r\n                    dep1_2_salarys.add(employee.getSalary()+employee.getBonus());\r\n                });\r\n        for (double salary : dep1_2_salarys){\r\n            dep1_2_salary_average+=salary;\r\n        }\r\n        a = BigDecimal.valueOf(dep1_2_salary_average);\r\n        b = BigDecimal.valueOf(dep1_2_salarys.size());\r\n        if (dep1_2_salarys.size()!=0)\r\n            c = a.divide(b,2, RoundingMode.HALF_UP);//计算平均值\r\n        else\r\n            c = a;\r\n        System.out.println(\"两部门的平局工资为：\"+c);\r\n    }\r\n}\r\nclass Employee{\r\n    String name;\r\n    char sex;\r\n    double salary;\r\n    double bonus;\r\n    String punish;\r\n    public Employee(String name, char sex, double salary, double bonus, String punish) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n        this.salary = salary;\r\n        this.bonus = bonus;\r\n        this.punish = punish;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public char getSex() {\r\n        return sex;\r\n    }\r\n\r\n    public void setSex(char sex) {\r\n        this.sex = sex;\r\n    }\r\n\r\n    public double getSalary() {\r\n        return salary;\r\n    }\r\n\r\n    public void setSalary(double salary) {\r\n        this.salary = salary;\r\n    }\r\n\r\n    public double getBonus() {\r\n        return bonus;\r\n    }\r\n\r\n    public void setBonus(double bonus) {\r\n        this.bonus = bonus;\r\n    }\r\n\r\n    public String getPunish() {\r\n        return punish;\r\n    }\r\n\r\n    public void setPunish(String punish) {\r\n        this.punish = punish;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Employee{\" +\r\n                \"name='\" + name + '\\'' +\r\n                \", sex=\" + sex +\r\n                \", salary=\" + salary +\r\n                \", bonus=\" + bonus +\r\n                \", punish='\" + punish + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-19-15-15.png)\r\n\r\n\r\n## 异常处理\r\n### 概念\r\n* 异常程序在**编译**或**执行阶段**可能出现的问题\r\n* **语法错误不是异常**\r\n* 如：数组索引越界、空指针异常、日期格式化异常......\r\n* **若异常出现但不处理，程序会退出JVM虚拟机**\r\n* 研究异常、避免异常、提前处理异常、保证程序的安全健壮\r\n\r\n**异常体系**\r\n* `Throwable`是所有异常的**祖宗类**\r\n* `Error`是**系统级别的异常**，JVM退出等，<green>**程序无法干预控制**</green>\r\n* `Exception`，在java.lang包下，称为异常类，<green>**程序可以干预的异常**</green>\r\n  * `RuntimeExpection及其子类`：<green>**运行时异常**</green>，编译阶段不会报错\r\n  * `是Exception的子类但不是RuntimeExpection的子类的异常`：<green>**编译时异常**</green>，编译期必须处理的异常，否则程序不能通过编译，一般用于提醒程序员这里很容易出错\r\n\r\n![](./images/java学习笔记/2022-10-29-22-49-57.png)\r\n\r\n\r\n\r\n### 常见异常\r\n\r\n**常见运行时异常**\r\n* `ArrayIndexOutOfBoundsException` 数组访问越界异常 `arr[99999]`\r\n* `NullPointerException` 空指针访问异常 `null.getValue()`\r\n* `ClassCastException` 类型转换异常 `String a = (String) (Object) 123;`\r\n* `ArithmeticException` 数学操作异常 `a = 123/0`\r\n* `NumberFormatException` 数学转换异常 `Double.valueOf(\"abcd123.123\")`\r\n\r\n**常见编译阶段异常**\r\n```java\r\nString data = \"2021-12.25 12:24:11\";\r\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\r\nDate dt = sdf.parse(data);//无论写的对不对，parse会抛出编译时异常\r\nSystem.out.println(dt);\r\n```\r\n\r\n### 默认异常处理机制\r\n\r\n**默认编译时异常处理机制**\r\n* **不会自动向外抛出异常**\r\n* 必须手动处理\r\n\r\n**默认运行时异常处理机制**\r\n* 在出现异常的地方创建异常对象\r\n* **在这个地方抛出异常返回给调用者，层层抛出，直到抛出给JVM虚拟机**(默认会自动抛出异常)\r\n* 虚拟机输出异常的栈信息\r\n* 直接在异常点结束虚拟机\r\n\r\n`try{}cache(){}`的使用\r\n```java\r\ntry{\r\n    return;\r\n\r\n}cache(Expection e){\r\n    return -1;\r\n}cache(Expection e){\r\n    System.exit(0);//退出jvm虚拟机\r\n    return -1;\r\n}finally{//无论是否有异常（除非jvm虚拟机退出）,即使程序提前return，一定会执行的代码块，用于资源释放\r\n    //这里写return -1，则程序的结果永远是-1\r\n}\r\n```\r\n\r\n`try(resource){}cache(){}`的使用\r\n```java\r\n//jdk9语法\r\ntry(\r\n    // 资源\r\n    文件流 io = new 文件流;// 无论程序是否出现异常，程序会把此处的定义的资源（实现了[auto]Closeable接口的类）释放掉\r\n    文件流 io = new 文件流;\r\n){\r\n    操作\r\n}cache(Expection e){\r\n\r\n}\r\n```\r\n\r\n\r\n### 处理异常\r\n\r\n**对编译时异常的处理**\r\n* 通过`throws`**显式**抛给调用者\r\n* 自己捕获并处理异常`try{}cache(){}`\r\n```java\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  throws ParseException //需要在这里 `显式` 抛出编译时异常\r\n    {\r\n        String data = \"2021-12.25 12:24:11\";\r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\r\n        Date dt = sdf.parse(data);//无论写的对不对，parse会抛出编译时异常\r\n        System.out.println(dt);\r\n    }\r\n}\r\n```\r\n\r\n**对编译时异常的处理**\r\n* 出现异常直接抛给调用者，调用者也继续向外抛 **(默认自动抛出)**\r\n* 自己捕获并处理异常`try{}cache(){}`\r\n* 结合前两者，**被调者**抛出异常，**调用者**捕获**被调者**抛出的异常并**处理异常**\r\n* **异常处理的案例**\r\n    ```java\r\n    public class HelloWorld {\r\n        public static void main(String[] args)\r\n        {\r\n            try{\r\n                divide(123,0);\r\n            }catch (Exception e){//捕获异常\r\n                e.printStackTrace();//打印栈信息\r\n                System.out.println(\"捕获了异常\");//处理异常\r\n            }\r\n        }\r\n        public static int divide(int a ,int b) //抛出数学异常\r\n        {\r\n            return a/b;\r\n        }\r\n    }\r\n    ```\r\n\r\n### 自定义异常\r\n* 自定义编译时异常可以提醒程序员某处容易出错\r\n* 自定义异常可以通过`printStackTrace`打印栈信息，快速定位错误出现在第几行\r\n\r\n**自定义编译时异常**\r\n* 定义一个异常类，继承<green>Exception</green>\r\n* 重写构造器\r\n* 在出现异常的地方用`throw new 自定义异常构造器(参数);`抛出异常\r\n* 必须在函数声明处通过`throws 自定义异常名`手动抛出给调用者 \r\n\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) throws AgeError{ //编译时异常必须手动处理\r\n    \r\n        checkAge(-100);\r\n    }\r\n    public static void  checkAge(int age) throws AgeError{//编译时异常必须手动处理\r\n        if (age>200||age<0){\r\n            throw new AgeError(age);\r\n        }\r\n        System.out.println(\"年龄校验成功\");\r\n    }\r\n}\r\n\r\nclass AgeError extends Exception{//继承Exception\r\n    public AgeError() {\r\n    }\r\n\r\n    public AgeError(int age) {\r\n        super(\"年龄： \" + age + \" 取值范围不合理！！！\");\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-30-01-03-19.png)\r\n\r\n\r\n\r\n**自定义运行时异常**\r\n* 定义一个异常类，继承 <green>RuntimeException</green>\r\n* 重写构造器\r\n* 在出现异常的地方用`throw new 自定义异常构造器(参数);`抛出异常\r\n* 无需手动使用`throws 自定义异常名`抛出异常给调用者\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) //运行时异常将被自动抛出\r\n    {\r\n        checkAge(-100);\r\n    }\r\n    public static void  checkAge(int age){//运行时异常将被自动抛出\r\n        if (age>200||age<0){\r\n            throw new AgeRuntimeError(age);\r\n        }\r\n        System.out.println(\"年龄校验成功\");\r\n    }\r\n}\r\n\r\nclass AgeRuntimeError extends RuntimeException{//继承运行时异常\r\n    public AgeRuntimeError() {\r\n    }\r\n\r\n    public AgeRuntimeError(int age) {\r\n        super(\"年龄： \" + age + \" 取值范围不合理！！！\");\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-30-01-10-41.png)\r\n\r\n### 案例\r\n\r\n**通过异常处理使程序更稳健的案例**\r\n```java\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)\r\n    {\r\n        Scanner sc = new Scanner(System.in);\r\n        while (true){\r\n            try {\r\n                System.out.println(\"请输入一个合理的价格：\");\r\n                Double price = Double.valueOf(sc.nextLine());\r\n                if (price<0){\r\n                    System.out.println(\"价格不能为负数，请重新输入\");\r\n                }else {\r\n                    System.out.println(\"定价成功：价格为：\"+price);\r\n                    break;\r\n                }\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n                System.out.println(\"请输入合法数据！！！\");\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-30-00-37-56.png)\r\n\r\n\r\n\r\n## 日志框架\r\n\r\n### 概念\r\n* 系统在开发阶段或者上线后，一旦业务出现问题，需要有信息去定位，如何记录程序的运行信息?\r\n* 日志框架相当于飞机的黑匣子，记录程序中出现的问题\r\n\r\n**日志技术具备的优势**\r\n* 可以将系统执行的信息选择性的记录到指定的位置（控制台、文件中、数据库中）。\r\n* 可以随时以开关的形式控制是否记录日志，无需修改源代码。\r\n\r\n**日志框架和输出语句相比的具体优势**\r\n| 项目     | 输出语句                       | 日志框架                             |\r\n| -------- | ------------------------------ | ------------------------------------ |\r\n| 输出位置 | 只能是控制台                   | 可以将日志信息写入到文件或者数据库中 |\r\n| 关闭日志 | 需要修改代码，灵活性比较差     | 不需要修改代码，灵活性比较好         |\r\n| 多线程   | 性能较差，会拖累程序的业务逻辑 | 性能较好                             |\r\n\r\n\r\n### 日志框架体系结构\r\n\r\n**日志规范接口:** 一些接口，提供给日志的实现框架设计的标准。\r\n* JUL (Commons Logging)\r\n* slf4j (simple Logging Facade for java)\r\n\r\n**日志实现框架:** 牛人或者第三方公司已经做好的日志记录实现代码，后来者直接可以拿去使用。\r\n* Log4j\r\n* JCL (java.util.Logging)\r\n* **Logback**\r\n* 其他实现\r\n\r\n**发展历程**\r\n* 接口规范: Commons Logging -> slf4j\r\n* 实现框架: Log4j -> Logback\r\n\r\n## Logback日志框架\r\n\r\n### 概念\r\n* Logback是由Log4j创始人设计的另一个开源日志框架，性能更好。\r\n* 基于slf4j规范结构\r\n\r\n**Logback主要分为三个技术模块**:\r\n* **logback-core**: logback-core模块为其他两个模块奠定了基础，必须有。\r\n* **logback-classic**:它是log4j的一个改良版本，同时它完整实现了 slf4j-API.\r\n* logback-access模块与Tomcat和Jetty 等Servlet容器集成，以提供HTTP访问日志功能\r\n\r\n**使用Logback需要的模块**\r\n* **slf4j-api**: 日志规范\r\n* logback-core\r\n* logback-classic\r\n\r\n### 使用与配置\r\n* 项目下新建lib文件夹，\r\n* 导入`slf4j-api.jar`、`logback-core.jar`、`logback-classic.jar`三个文件\r\n* 添加到项目依赖库 ![](./images/java学习笔记/2022-10-30-02-13-34.png)\r\n* 将Logback的核心配置文件`logback.xml`直接拷贝到src目录下（必须是src)\r\n* 在代码中获取日志的对象\r\n    ```java\r\n    import org.slf4j.Logger;\r\n    import org.slf4j.LoggerFactory;\r\n    public class Main {\r\n        public static final Logger LOGGER = LoggerFactory.getLogger(Main.class);\r\n        public static void main(String[] args) {\r\n            LOGGER.debug(\"哈哈哈哈\");\r\n        }\r\n    }\r\n    ```\r\n* 将`logback.xml`配置文件放到`src`或`合适的目录`\r\n\r\n**logback.xml**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<configuration>\r\n    <!--\r\n        CONSOLE ：表示当前的日志信息是可以输出到控制台的。\r\n    -->\r\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n        <!--输出流对象 默认 System.out 可改为 System.err-->\r\n        <target>System.out</target>\r\n        <encoder>\r\n            <!--\r\n                格式化输出：\r\n                    %d表示日期，\r\n                    %thread表示线程名，\r\n                    %-5level：级别从左显示5个字符宽度\r\n                    %msg：日志消息，\r\n                    %n是换行符\r\n            -->\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n</pattern>\r\n        </encoder>\r\n    </appender>\r\n    <!-- File是输出的方向通向文件的 -->\r\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\r\n        <encoder>\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\r\n            <charset>utf-8</charset>\r\n        </encoder>\r\n        <!--日志输出路径-->\r\n        <file>D:/code/data.log</file>\r\n        <!--指定日志文件拆分和压缩规则-->\r\n        <rollingPolicy\r\n                class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\r\n            <!--通过指定压缩文件名称，来确定分割文件方式-->\r\n            <fileNamePattern>D:/code/data2-%d{yyyy-MM-dd}.log%i.gz</fileNamePattern>\r\n            <!--文件拆分大小-->\r\n            <maxFileSize>1MB</maxFileSize>\r\n        </rollingPolicy>\r\n    </appender>\r\n    <!--\r\n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF\r\n   ， 默认debug\r\n    <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。\r\n    -->\r\n    <root level=\"ALL\">\r\n        <appender-ref ref=\"CONSOLE\"/>\r\n        <appender-ref ref=\"FILE\" />\r\n    </root>\r\n</configuration>\r\n```\r\n\r\n## 电影商城实现\r\n\r\n**核心功能**\r\n* 用户注册:商家注册，客户注册\r\n* 用户登录:商家登录，客户登录\r\n* 商家发布，下架，修改，电影票信息\r\n* 客户浏览，下单，支付，电影票\r\n* 客户打分，给已下单的影片打分\r\n\r\n<details>\r\n<summary> <strong>源代码<strong> </summary>\r\n\r\n```java\r\nimport java.math.BigDecimal;\r\nimport java.math.MathContext;\r\nimport java.math.RoundingMode;\r\nimport java.text.SimpleDateFormat;\r\nimport java.time.Instant;\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.Stream;\r\nimport org.slf4j.Logger;//日志系统，可以删除\r\nimport org.slf4j.LoggerFactory;//日志系统，可以删除\r\n\r\npublic class Main {\r\n\r\n  public static final Logger LOGGER = LoggerFactory.getLogger(Main.class);\r\n  public static final Map<String, List<Movie>> MOVIESINFO_DB = new HashMap<>(); // 电影信息数据库\r\n  public static final Map<String, User> USERS_DB = new HashMap<>(); // 用户信息数据库\r\n  public static final Scanner SCANNER = new Scanner(System.in);\r\n  public static final SimpleDateFormat sdf = new SimpleDateFormat(\r\n    \"yyyy-MM-dd HH:mm\"\r\n  );\r\n\r\n  public static void main(String[] args) {\r\n    USERS_DB.put(\r\n      \"123\",\r\n      new Business(\r\n        \"123\",\r\n        \"DDYYGG\",\r\n        '女',\r\n        \"123\",\r\n        \"110\",\r\n        0,\r\n        \"好看影视公司\",\r\n        \"北京新工业园区创业路1号\"\r\n      )\r\n    );\r\n    USERS_DB.put(\r\n      \"1234\",\r\n      new Customer(\"1234\", \"DingYigui\", '男', \"1234\", \"110\", 1000000)\r\n    );\r\n    MOVIESINFO_DB.put(\"123\", new LinkedList<>());\r\n\r\n    while (true) {\r\n      try {\r\n        System.out.println(\r\n          \"----------------------------重光电影院----------------------------\"\r\n        );\r\n        System.out.println(\"1.登录用户。\");\r\n        System.out.println(\"2.注册用户。\");\r\n        System.out.println(\"0.退出。\");\r\n        System.out.println(\"请输入操作类型：\");\r\n        String operator = SCANNER.nextLine();\r\n        switch (operator) {\r\n          case \"1\":\r\n            login();\r\n            break;\r\n          case \"2\":\r\n            register();\r\n            break;\r\n          case \"0\":\r\n            return;\r\n          default:\r\n            printLine();\r\n            System.out.println(\"未知操作符，请重新输入\");\r\n            break;\r\n        }\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"操作异常，请重试！！！\");\r\n        LOGGER.warn(e.toString());\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void register() {\r\n    while (true) {\r\n      System.out.println(\r\n        \"----------------------------用户注册----------------------------\"\r\n      );\r\n      System.out.println(\"1.注册商家。\");\r\n      System.out.println(\"2.注册顾客。\");\r\n      System.out.println(\"0.退出。\");\r\n      System.out.println(\"请输入操作类型：\");\r\n      String operator = SCANNER.nextLine();\r\n      switch (operator) {\r\n        case \"1\":\r\n          regUser(true);\r\n          return;\r\n        case \"2\":\r\n          regUser(false);\r\n          return;\r\n        case \"0\":\r\n          return;\r\n        default:\r\n          printLine();\r\n          System.out.println(\"未知操作符，请重新输入。\");\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void login() {\r\n    System.out.println(\r\n      \"----------------------------登录----------------------------\"\r\n    );\r\n    System.out.println(\"请输入用户名：\");\r\n    String userName = SCANNER.nextLine();\r\n    System.out.println(\"请输入密码：\");\r\n    String passwd = SCANNER.nextLine();\r\n    User user = USERS_DB.get(userName);\r\n\r\n    printLine();\r\n    if (user != null && user.getPasswd().equals(passwd)) {\r\n      System.out.println(\"登录成功！！！\");\r\n      UserMenu(user);\r\n    } else {\r\n      System.out.println(\"登录失败...\");\r\n    }\r\n  }\r\n\r\n  public static void UserMenu(User user) {\r\n    System.out.println(\r\n      \"----------------------------欢迎----------------------------\"\r\n    );\r\n    System.out.println(\"欢迎你, \" + user.getName() + \" ,别来无恙。\");\r\n    System.out.println(\"账户余额：\" + user.getMoney() + \"元\");\r\n\r\n    if (user instanceof Customer) {\r\n      customerMenu((Customer) user);\r\n    } else if (user instanceof Business) {\r\n      businessMenu((Business) user);\r\n    }\r\n  }\r\n\r\n  public static void businessMenu(Business business) {\r\n    while (true) {\r\n      System.out.println(\r\n        \"----------------------------商家菜单页----------------------------\"\r\n      );\r\n      System.out.println(\"1.用户信息。\");\r\n      System.out.println(\"2.上架影片。\");\r\n      System.out.println(\"3.修改影片。\");\r\n      System.out.println(\"4.下架影片。\");\r\n      System.out.println(\"5.影片信息。\");\r\n      System.out.println(\"6.订单信息。\");\r\n      System.out.println(\"0.返回菜单。\");\r\n      String operator = SCANNER.nextLine();\r\n      switch (operator) {\r\n        case \"1\":\r\n          showBusinessInfo(business);\r\n          break;\r\n        case \"2\":\r\n          addFilm(business);\r\n          break;\r\n        case \"3\":\r\n          updateFilmInfo(business);\r\n          break;\r\n        case \"4\":\r\n          delFilm(business);\r\n          break;\r\n        case \"5\":\r\n          showMoviesInfo(MOVIESINFO_DB.get(business.getUserName()));\r\n          break;\r\n        case \"6\":\r\n          showOrderInfo(business.getOrders());\r\n          break;\r\n        case \"0\":\r\n          return;\r\n        default:\r\n          printLine();\r\n          System.out.println(\"未知操作符，请重新输入。\");\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void updateFilmInfo(Movie movie) {\r\n    while (true) {\r\n      System.out.println(\r\n        \"----------------------影片信息修改----------------------------\"\r\n      );\r\n      System.out.println(\"1.修改影片名称\");\r\n      System.out.println(\"2.修改主演名称\");\r\n      System.out.println(\"3.修改影片时长\");\r\n      System.out.println(\"4.修改影片票价\");\r\n      System.out.println(\"5.修改影片总票数\");\r\n      System.out.println(\"0.退出\");\r\n      System.out.println(\"请输入要修改的字段：\");\r\n      String operator = SCANNER.nextLine();\r\n      switch (operator) {\r\n        case \"1\":\r\n          movie.setMovieName(Movie.genMovieName(SCANNER));\r\n          break;\r\n        case \"2\":\r\n          movie.setActors(Movie.genActors(SCANNER));\r\n          break;\r\n        case \"3\":\r\n          movie.setTimeLong(Movie.genTimeLong(SCANNER));\r\n          break;\r\n        case \"4\":\r\n          movie.setPrice(Movie.genPrice(SCANNER));\r\n          break;\r\n        case \"5\":\r\n          movie.setTotalTicket(Movie.genTotalTicket(SCANNER));\r\n          break;\r\n        case \"0\":\r\n          return;\r\n        default:\r\n          printLine();\r\n          System.out.println(\"未知操作符，请重新输入。\");\r\n          continue;\r\n      }\r\n      printLine();\r\n      System.out.println(\"修改成功\");\r\n    }\r\n  }\r\n\r\n  public static void updateFilmInfo(Business business) {\r\n    List<Movie> movies = MOVIESINFO_DB.get(business.getUserName());\r\n    if (movies.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"没有已上架电影的信息。\");\r\n      return;\r\n    }\r\n    showMoviesInfo(movies);\r\n    int index;\r\n    while (true) {\r\n      try {\r\n        printLine();\r\n        System.out.println(\"请输入要修改的影片的序号：\");\r\n        index = Integer.valueOf(SCANNER.nextLine());\r\n        if (0 <= index && index < movies.size()) {\r\n          break;\r\n        }\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"异常,请重新输入。\");\r\n      }\r\n    }\r\n    Movie movie = movies.get(index);\r\n    printLine();\r\n    if (movie == null) {\r\n      System.out.println(\"获取影片实例失败。\");\r\n    } else {\r\n      System.out.println(\"获取影片实例成功。\");\r\n      updateFilmInfo(movie);\r\n    }\r\n  }\r\n\r\n  public static void printLine() {\r\n    System.out.println(\r\n      \"-----------------------------操作结果----------------------------------\"\r\n    );\r\n  }\r\n\r\n  public static void printLineWithTitle(String title) {\r\n    System.out.println(\r\n      \"----------------------------\" + title + \"----------------------------\"\r\n    );\r\n  }\r\n\r\n  public static void addFilm(Business business) {\r\n    MOVIESINFO_DB\r\n      .get(business.getUserName())\r\n      .add(\r\n        new Movie(\r\n          Movie.genMovieName(SCANNER),\r\n          Movie.genActors(SCANNER),\r\n          Movie.genTimeLong(SCANNER),\r\n          Movie.genPrice(SCANNER),\r\n          Movie.genTotalTicket(SCANNER),\r\n          Movie.genBeOn(SCANNER),\r\n          business.getUserName()\r\n        )\r\n      );\r\n    printLine();\r\n    System.out.println(\"电影上架成功！\");\r\n  }\r\n\r\n  public static void delFilm(Business business) {\r\n    List movies = MOVIESINFO_DB.get(business.getUserName());\r\n    if (movies.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"没有已上架电影的信息。\");\r\n      return;\r\n    }\r\n    showMoviesInfo(movies);\r\n    int index;\r\n    while (true) {\r\n      try {\r\n        printLine();\r\n        System.out.println(\"请输入要下架影片的序号：\");\r\n        index = Integer.valueOf(SCANNER.nextLine());\r\n        if (0 <= index && index < movies.size()) {\r\n          break;\r\n        }\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"异常,请重新输入。\");\r\n      }\r\n    }\r\n    printLine();\r\n    if (movies.remove(index) == null) {\r\n      System.out.println(\"影片下架失败\");\r\n    } else {\r\n      System.out.println(\"影片下架成功\");\r\n    }\r\n  }\r\n\r\n  public static void showMoviesInfo(List<Movie> movies) {\r\n    if (movies == null || movies.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"\\t无影片信息\");\r\n      return;\r\n    }\r\n    String leftAlignFormat =\r\n      \"| %-5s | %-20s | %-20s | %-10s | %-10s | %-10s | %-10s | %-10s | %-15s |%n\";\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+------------+------------+------------+------------+------------+-----------------+%n\"\r\n    );\r\n    System.out.format(\r\n      \"|  序号  |       影片名称        |          主演         |     评分    |     时长    |    票价    |     余票    |     总票    |       上映       |%n\"\r\n    );\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+------------+------------+------------+------------+------------+-----------------+%n\"\r\n    );\r\n\r\n    int index = 0;\r\n    for (Movie movie : movies) {\r\n      System.out.format(\r\n        leftAlignFormat,\r\n        index++,\r\n        movie.getMovieName(),\r\n        movie.getActorsToStr(),\r\n        movie.getScore(),\r\n        movie.getTimeLong(),\r\n        movie.getPrice(),\r\n        movie.getRestTicket(),\r\n        movie.getTotalTicket(),\r\n        sdf.format(movie.getBeOn())\r\n      );\r\n    }\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+------------+------------+------------+------------+------------+-----------------+%n\"\r\n    );\r\n  }\r\n\r\n  public static void showBusinessInfo(Business business) {\r\n    printLineWithTitle(\"商家信息\");\r\n    System.out.println(\"用户名：\" + business.getUserName());\r\n    System.out.println(\"账户余额：\" + business.getMoney());\r\n    System.out.println(\"姓名：\" + business.getName());\r\n    System.out.println(\"性别：\" + business.getSex());\r\n    System.out.println(\"手机号：\" + business.getTelNum());\r\n    System.out.println(\"公司名称：\" + business.getCompanyName());\r\n    System.out.println(\"公司地址：\" + business.getCompanyAddress());\r\n  }\r\n\r\n  public static void showCustomInfo(Customer customer) {\r\n    printLineWithTitle(\"客户信息\");\r\n    System.out.println(\"用户名：\" + customer.getUserName());\r\n    System.out.println(\"账户余额：\" + customer.getMoney());\r\n    System.out.println(\"姓名：\" + customer.getName());\r\n    System.out.println(\"性别：\" + customer.getSex());\r\n    System.out.println(\"手机号：\" + customer.getTelNum());\r\n  }\r\n\r\n  public static void showOrderInfo(List<Order> orders) {\r\n    if (orders == null || orders.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"\\t无订单信息\");\r\n      return;\r\n    }\r\n    String leftAlignFormat =\r\n      \"| %-5s | %-20s | %-20s | %-20s | %-10s | %-10s | %-15s |%n\";\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+----------------------+------------+------------+-----------------+%n\"\r\n    );\r\n    System.out.format(\r\n      \"|  序号  |        电影名         |       商家用户名       |       客户用户名       |    票价     |    票数    |       订单总额    |%n\"\r\n    );\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+----------------------+------------+------------+-----------------+%n\"\r\n    );\r\n    int index = 0;\r\n    for (Order order : orders) {\r\n      System.out.format(\r\n        leftAlignFormat,\r\n        index++,\r\n        order.getMovieName(),\r\n        order.getBusinessUserName(),\r\n        order.getCustomUserName(),\r\n        order.getTicketPrice(),\r\n        order.getTicketNum(),\r\n        order.getTotalPrice()\r\n      );\r\n    }\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+----------------------+------------+------------+-----------------+%n\"\r\n    );\r\n  }\r\n\r\n  public static void customerMenu(Customer custom) {\r\n    while (true) {\r\n      System.out.println(\r\n        \"----------------------------客户菜单页----------------------------\"\r\n      );\r\n      System.out.println(\"1.用户信息。\");\r\n      System.out.println(\"2.买电影票。\");\r\n      System.out.println(\"3.查看订单。\");\r\n      System.out.println(\"4.影片评分。\");\r\n      System.out.println(\"5.余额充值。\");\r\n      System.out.println(\"0.退出。\");\r\n      String operator = SCANNER.nextLine();\r\n      switch (operator) {\r\n        case \"1\":\r\n          showCustomInfo(custom);\r\n          break;\r\n        case \"2\":\r\n          buyTicket(custom);\r\n          break;\r\n        case \"3\":\r\n          showOrderInfo(custom.getOrders());\r\n          break;\r\n        case \"4\":\r\n          evaluateMovie(custom);\r\n          break;\r\n        case \"5\":\r\n          addMoney(custom);\r\n          break;\r\n        case \"0\":\r\n          return;\r\n        default:\r\n          System.out.println(\"未知操作符，请重新输入。\");\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void addMoney(Customer customer) {\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入充值金额：\");\r\n        Double addMoney = Double.valueOf(SCANNER.nextLine());\r\n        if (addMoney < 0) {\r\n          System.out.println(\"输入金额不能为负数。\");\r\n          continue;\r\n        }\r\n        customer.setMoney(customer.getMoney() + addMoney);\r\n        printLine();\r\n        System.out.println(\"充值成功。\");\r\n        System.out.println(\"当前余额：\" + customer.getMoney());\r\n        break;\r\n      } catch (Exception e) {\r\n        System.out.println(\"异常，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static List<Movie> getMoviesInOrders(List<Order> orders) {\r\n    Stream<Movie> movieStream = orders\r\n      .stream()\r\n      .map(targetOrder -> {\r\n        for (Movie movie : MOVIESINFO_DB.get(\r\n          targetOrder.getBusinessUserName()\r\n        )) {\r\n          if (\r\n            movie.getMovieBirthHash_id() == targetOrder.getMovieId()\r\n          ) return movie;\r\n        }\r\n        return null;\r\n      })\r\n      .filter(movie -> movie != null);\r\n    return movieStream.collect(Collectors.toList());\r\n  }\r\n\r\n  public static void evaluateMovie(Movie movie) {\r\n    while (true) {\r\n      try {\r\n        System.out.println(\r\n          \"请输入你评分（0.0 - 10.0 ）,低于0分判定为0，高于10分判定为10：\"\r\n        );\r\n        movie.evaluateScore(Double.valueOf(SCANNER.nextLine()));\r\n        printLine();\r\n        System.out.println(\"评分成功\");\r\n        return;\r\n      } catch (Exception e) {\r\n        System.out.println(\"非法字符，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void evaluateMovie(Customer customer) {\r\n    List<Order> customOrders = customer.getOrders();\r\n\r\n    if (customOrders.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"订单为空，无观看影片信息。\");\r\n      return;\r\n    }\r\n    List<Movie> moviesInOrders = getMoviesInOrders(customOrders);\r\n    showMoviesInfo(moviesInOrders);\r\n\r\n    int index;\r\n    while (true) {\r\n      try {\r\n        printLine();\r\n        System.out.println(\"请输入要评分的影片的序号：\");\r\n        index = Integer.valueOf(SCANNER.nextLine());\r\n        if (0 <= index && index < moviesInOrders.size()) {\r\n          break;\r\n        }\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"异常,请重新输入。\");\r\n      }\r\n    }\r\n    Movie movie = moviesInOrders.get(index);\r\n    printLine();\r\n    if (movie == null) {\r\n      System.out.println(\"获取影片实例失败。\");\r\n    } else {\r\n      System.out.println(\"获取影片实例成功。\");\r\n      evaluateMovie(movie);\r\n    }\r\n  }\r\n\r\n  public static List<Movie> getAllMovies() {\r\n    List<Movie> list_movie = new LinkedList<>();\r\n    MOVIESINFO_DB\r\n      .values()\r\n      .forEach(movies -> {\r\n        list_movie.addAll(movies);\r\n      });\r\n    return list_movie;\r\n  }\r\n\r\n  public static void buyTicket(Customer customer) {\r\n    List<Movie> allMovies = getAllMovies();\r\n    while (true) {\r\n      try {\r\n        printLineWithTitle(\"购票子系统\");\r\n        if (allMovies.size() == 0) {\r\n          System.out.println(\"无法购票\");\r\n          return;\r\n        }\r\n        showMoviesInfo(allMovies);\r\n\r\n        Movie selectMovie;\r\n\r\n        int index;\r\n        while (true) {\r\n          try {\r\n            System.out.println(\"请输入要购买的影片序号：\");\r\n            index = Integer.valueOf(SCANNER.nextLine());\r\n            if (0 <= index && index < allMovies.size()) {\r\n              selectMovie = allMovies.get(index);\r\n              break;\r\n            }\r\n          } catch (Exception e) {\r\n            System.out.println(\"输入数字不合法，请重试\");\r\n          }\r\n        }\r\n\r\n        int ticketNum;\r\n        System.out.println(\"请输入要购买的张数：\");\r\n        while (true) {\r\n          ticketNum = Integer.valueOf(SCANNER.nextLine());\r\n          if (0 < ticketNum && index <= selectMovie.getRestTicket()) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        // 创建订单\r\n        Order order = new Order(\r\n          customer.getUserName(),\r\n          selectMovie.getPiblisherUserName(),\r\n          selectMovie.getMovieBirthHash_id(),\r\n          selectMovie.getMovieName(),\r\n          ticketNum,\r\n          selectMovie.getPrice()\r\n        );\r\n        printLineWithTitle(\"订单信息\");\r\n        System.out.println(\"影片名称：\" + order.getMovieName());\r\n        System.out.println(\"票价：\" + order.getTicketPrice());\r\n        System.out.println(\"购票数量：\" + order.getTicketNum());\r\n        System.out.println(\"购票总价：\" + order.getTotalPrice());\r\n        System.out.println(\"购票方用户名：\" + order.getCustomUserName());\r\n        System.out.println(\"账户余额：\" + customer.getMoney());\r\n\r\n        System.out.println(\"是否确认订单(y/n)：\");\r\n        String operator = SCANNER.nextLine();\r\n\r\n        printLine();\r\n\r\n        if (operator == \"n\") {\r\n          System.out.println(\"订单取消成功\");\r\n          break;\r\n        }\r\n        if (customer.getMoney() < order.getTotalPrice()) {\r\n          System.out.println(\"购票失败,账户余额不足。\");\r\n          break;\r\n        }\r\n        if (selectMovie.getRestTicket() < order.getTicketNum()) {\r\n          System.out.println(\"购票失败,余票不足。\");\r\n          break;\r\n        }\r\n\r\n        User business = USERS_DB.get(order.getBusinessUserName());\r\n        business.getOrders().add(order);\r\n        business.setMoney(business.getMoney() + order.getTotalPrice());\r\n\r\n        customer.getOrders().add(order);\r\n        customer.setMoney(customer.getMoney() - order.getTotalPrice());\r\n\r\n        selectMovie.setSaledTicket(\r\n          selectMovie.getSaledTicket() + order.getTicketNum()\r\n        );\r\n\r\n        System.out.println(\"购票成功!\");\r\n        break;\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入字段不合法，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void regUser(boolean isBusiness) {\r\n    while (true) {\r\n      try {\r\n        if (isBusiness) {\r\n          System.out.println(\r\n            \"----------------------------商家注册----------------------------\"\r\n          );\r\n        } else {\r\n          System.out.println(\r\n            \"----------------------------顾客注册----------------------------\"\r\n          );\r\n        }\r\n\r\n        String userName = \"\";\r\n        while (true) {\r\n          System.out.println(\"请输入用户名:\");\r\n          userName = SCANNER.nextLine();\r\n          if (userName.length() < 4) {\r\n            System.out.println(\"用户名过短,请重新输入！！！\");\r\n          } else if (isRegistered(userName)) { // 检查用户名是否已被注册\r\n            System.out.println(\"用户名已被注册,请重新输入！！！\");\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        String passwd = \"\";\r\n        String checkpasswd = \"\";\r\n        while (true) {\r\n          System.out.println(\"请输入密码:\");\r\n          passwd = SCANNER.nextLine();\r\n          System.out.println(\"请输入确认密码:\");\r\n          checkpasswd = SCANNER.nextLine();\r\n          if (!passwd.equals(checkpasswd)) {\r\n            System.out.println(\"两次输入密码不一致，请重新输入。\");\r\n            continue;\r\n          }\r\n          if (passwd.length() < 6) {\r\n            System.out.println(\"密码不得小于6位，请重新输入。\");\r\n            continue;\r\n          }\r\n          break;\r\n        }\r\n\r\n        String name = \"\";\r\n        while (true) {\r\n          printLine();\r\n          System.out.println(\"请输入真实姓名:\");\r\n          name = SCANNER.nextLine();\r\n          if (name.length() == 0) {\r\n            System.out.println(\"姓名不得为空，请重新输入.\");\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        char sex = '男';\r\n        while (true) {\r\n          printLine();\r\n          System.out.println(\"请输入性别:\");\r\n          String sex_str = SCANNER.nextLine();\r\n          if ((sex_str != \"男\" && sex_str != \"女\")) {\r\n            System.out.println(\"性别字段不合法,请重新输入！！！\");\r\n          } else {\r\n            sex = sex_str.charAt(0);\r\n            break;\r\n          }\r\n        }\r\n\r\n        String telNum = \"\";\r\n        while (true) {\r\n          printLine();\r\n          System.out.println(\"请输入手机号:\");\r\n          telNum = SCANNER.nextLine();\r\n          if (!telNum.matches(\"[\\\\d]{5,15}\")) {\r\n            System.out.println(\"请输入合法手机号。\");\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        // System.out.println(\"请输入账户余额:\");\r\n        double money = 0;\r\n\r\n        if (isBusiness) { // 商家注册\r\n          String companyName = \"\";\r\n          while (true) {\r\n            printLine();\r\n            System.out.println(\"请输入公司名称:\");\r\n            companyName = SCANNER.nextLine();\r\n            if (companyName.length() == 0) {\r\n              System.out.println(\"公司名称不能为空，请重新输入。\");\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n          String companyAddress = \"\";\r\n          while (true) {\r\n            printLine();\r\n            System.out.println(\"请输入公司地址:\");\r\n            companyAddress = SCANNER.nextLine();\r\n            if (companyAddress.length() == 0) {\r\n              System.out.println(\"公司地址不能为空，请重新输入。\");\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n          USERS_DB.put(\r\n            userName,\r\n            new Business(\r\n              userName,\r\n              name,\r\n              sex,\r\n              passwd,\r\n              telNum,\r\n              money,\r\n              companyName,\r\n              companyAddress\r\n            )\r\n          );\r\n          MOVIESINFO_DB.put(userName, new LinkedList());\r\n        } else { // 顾客注册\r\n          USERS_DB.put(\r\n            userName,\r\n            new Customer(userName, name, sex, passwd, telNum, money)\r\n          );\r\n        }\r\n        printLine();\r\n        System.out.println(\"注册成功！！！\");\r\n        break;\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"检测到不合法输入，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static boolean isRegistered(String userName) { // 检测用户名是否已注册\r\n    return USERS_DB.containsKey(userName);\r\n  }\r\n}\r\n\r\nclass User {\r\n\r\n  String userName;\r\n  String passwd;\r\n  String name; // 真实姓名\r\n  char sex;\r\n  String telNum; // 手机号\r\n  double money; // 账户余额\r\n  List<Order> orders = new LinkedList<>();\r\n\r\n  public User(\r\n    String userName,\r\n    String name,\r\n    char sex,\r\n    String passwd,\r\n    String telNum,\r\n    double money\r\n  ) {\r\n    this.userName = userName;\r\n    this.name = name;\r\n    this.sex = sex;\r\n    this.passwd = passwd;\r\n    this.telNum = telNum;\r\n    this.money = money;\r\n  }\r\n\r\n  @Override\r\n  public boolean equals(Object o) { // 根据用户名判断是否为同一用户\r\n    if (this == o) return true;\r\n    if (o == null || !(o instanceof User)) return false; // o不能为空，o需为User类或其子类\r\n    User user = (User) o;\r\n    return Objects.equals(userName, user.userName);\r\n  }\r\n\r\n  @Override\r\n  public int hashCode() { // 根据用户名计算hash\r\n    return Objects.hash(userName);\r\n  }\r\n\r\n  public List<Order> getOrders() {\r\n    return orders;\r\n  }\r\n\r\n  public String getUserName() {\r\n    return userName;\r\n  }\r\n\r\n  public void setUserName(String userName) {\r\n    this.userName = userName;\r\n  }\r\n\r\n  public String getName() {\r\n    return name;\r\n  }\r\n\r\n  public void setName(String name) {\r\n    this.name = name;\r\n  }\r\n\r\n  public char getSex() {\r\n    return sex;\r\n  }\r\n\r\n  public void setSex(char sex) {\r\n    this.sex = sex;\r\n  }\r\n\r\n  public String getPasswd() {\r\n    return passwd;\r\n  }\r\n\r\n  public void setPasswd(String passwd) {\r\n    this.passwd = passwd;\r\n  }\r\n\r\n  public String getTelNum() {\r\n    return telNum;\r\n  }\r\n\r\n  public void setTelNum(String telNum) {\r\n    this.telNum = telNum;\r\n  }\r\n\r\n  public double getMoney() {\r\n    return BigDecimal\r\n      .valueOf(money)\r\n      .setScale(2, RoundingMode.HALF_UP)\r\n      .doubleValue();\r\n  }\r\n\r\n  public void setMoney(double money) {\r\n    this.money =\r\n      BigDecimal.valueOf(money).setScale(2, RoundingMode.HALF_UP).doubleValue();\r\n  }\r\n}\r\n\r\nclass Business extends User {\r\n\r\n  String companyName; // 公司名\r\n  String companyAddress; // 公司地址\r\n\r\n  Business(\r\n    String userName,\r\n    String name,\r\n    char sex,\r\n    String passwd,\r\n    String telNum,\r\n    double money,\r\n    String companyName,\r\n    String companyAddress\r\n  ) {\r\n    super(userName, name, sex, passwd, telNum, money);\r\n    this.companyName = companyName;\r\n    this.companyAddress = companyAddress;\r\n  }\r\n\r\n  public String getCompanyName() {\r\n    return companyName;\r\n  }\r\n\r\n  public void setCompanyName(String companyName) {\r\n    this.companyName = companyName;\r\n  }\r\n\r\n  public String getCompanyAddress() {\r\n    return companyAddress;\r\n  }\r\n\r\n  public void setCompanyAddress(String companyAddress) {\r\n    this.companyAddress = companyAddress;\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return (\r\n      \"Business{\" +\r\n      \"companyName='\" +\r\n      companyName +\r\n      '\\'' +\r\n      \", companyAddress='\" +\r\n      companyAddress +\r\n      '\\'' +\r\n      \", userName='\" +\r\n      userName +\r\n      '\\'' +\r\n      \", passwd='\" +\r\n      passwd +\r\n      '\\'' +\r\n      \", name='\" +\r\n      name +\r\n      '\\'' +\r\n      \", sex=\" +\r\n      sex +\r\n      \", telNum='\" +\r\n      telNum +\r\n      '\\'' +\r\n      \", money=\" +\r\n      money +\r\n      '}'\r\n    );\r\n  }\r\n}\r\n\r\nclass Customer extends User {\r\n\r\n  public Customer(\r\n    String userName,\r\n    String name,\r\n    char sex,\r\n    String passwd,\r\n    String telNum,\r\n    double money\r\n  ) {\r\n    super(userName, name, sex, passwd, telNum, money);\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return (\r\n      \"Customer{\" +\r\n      \"userName='\" +\r\n      userName +\r\n      '\\'' +\r\n      \", passwd='\" +\r\n      passwd +\r\n      '\\'' +\r\n      \", name='\" +\r\n      name +\r\n      '\\'' +\r\n      \", sex=\" +\r\n      sex +\r\n      \", telNum='\" +\r\n      telNum +\r\n      '\\'' +\r\n      \", money=\" +\r\n      money +\r\n      '}'\r\n    );\r\n  }\r\n}\r\n\r\nclass Movie {\r\n\r\n  String movieName;\r\n  String[] actors;\r\n  double score = 5.0;\r\n  int timeLong; // 时长\r\n  double price; // 价格\r\n  int totalTicket; // 总票数\r\n  int saledTicket = 0; // 卖出票数\r\n  Date beOn;\r\n  String piblisherUserName; //发布者用户名\r\n\r\n  String movieBirthHash;\r\n\r\n  {\r\n    movieBirthHash = Integer.toString(Objects.hash(Instant.now().toString()));\r\n  }\r\n\r\n  public Movie(\r\n    String movieName,\r\n    String[] actors,\r\n    int timeLong,\r\n    double price,\r\n    int totalTicket,\r\n    Date beOn,\r\n    String piblisherUserName\r\n  ) {\r\n    this.movieName = movieName;\r\n    this.actors = actors;\r\n    this.timeLong = timeLong;\r\n    this.price = price;\r\n    this.totalTicket = totalTicket;\r\n    this.beOn = beOn;\r\n    this.piblisherUserName = piblisherUserName;\r\n  }\r\n\r\n  public String getMovieBirthHash_id() {\r\n    return movieBirthHash;\r\n  }\r\n\r\n  public int getRestTicket() {\r\n    return totalTicket - saledTicket;\r\n  }\r\n\r\n  public String getPiblisherUserName() {\r\n    return piblisherUserName;\r\n  }\r\n\r\n  public int getSaledTicket() {\r\n    return saledTicket;\r\n  }\r\n\r\n  public void setSaledTicket(int saledTicket) {\r\n    this.saledTicket = saledTicket;\r\n  }\r\n\r\n  public Date getBeOn() {\r\n    return beOn;\r\n  }\r\n\r\n  public void setBeOn(Date beOn) {\r\n    this.beOn = beOn;\r\n  }\r\n\r\n  public String getMovieName() {\r\n    return movieName;\r\n  }\r\n\r\n  public void setMovieName(String movieName) {\r\n    this.movieName = movieName;\r\n  }\r\n\r\n  public String[] getActors() {\r\n    return actors;\r\n  }\r\n\r\n  public String getActorsToStr() {\r\n    StringBuilder sb = new StringBuilder();\r\n    for (String name : actors) {\r\n      sb.append(name);\r\n      sb.append(\" \");\r\n    }\r\n    return sb.toString();\r\n  }\r\n\r\n  public void setActors(String[] actors) {\r\n    this.actors = actors;\r\n  }\r\n\r\n  public double getScore() {\r\n    return BigDecimal\r\n      .valueOf(score)\r\n      .round(new MathContext(3, RoundingMode.HALF_UP))\r\n      .doubleValue();\r\n  }\r\n\r\n  public void setScore(double score) {\r\n    this.score = normalizScore(score);\r\n  }\r\n\r\n  private double normalizScore(double score) {\r\n    return score >= 10 ? 10 : score <= 0 ? 0 : score;\r\n  }\r\n\r\n  public void evaluateScore(double customScore) {\r\n    customScore = normalizScore(customScore);\r\n    double newScore = score + (customScore - score) * 0.001;\r\n    setScore(newScore);\r\n  }\r\n\r\n  public int getTimeLong() {\r\n    return timeLong;\r\n  }\r\n\r\n  public void setTimeLong(int timeLong) {\r\n    this.timeLong = timeLong;\r\n  }\r\n\r\n  public double getPrice() {\r\n    return price;\r\n  }\r\n\r\n  public void setPrice(double price) {\r\n    this.price = price;\r\n  }\r\n\r\n  public int getTotalTicket() {\r\n    return totalTicket;\r\n  }\r\n\r\n  public void setTotalTicket(int totalTicket) {\r\n    this.totalTicket = totalTicket;\r\n  }\r\n\r\n  public static String genMovieName(Scanner SCANNER) {\r\n    String movieName;\r\n    while (true) {\r\n      System.out.println(\"请输入影片名：\");\r\n      movieName = SCANNER.nextLine();\r\n      if (movieName.length() == 0) {\r\n        System.out.println(\"影片名不能为空,请重新输入。\");\r\n      } else {\r\n        return movieName;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static String[] genActors(Scanner SCANNER) {\r\n    String[] actors;\r\n    while (true) {\r\n      System.out.println(\"请输入主演名并以空格分隔\");\r\n      String names_str = SCANNER.nextLine();\r\n      if (names_str.length() == 0) {\r\n        System.out.println(\"主演名称不能为空，请重新输入。\");\r\n      } else {\r\n        actors = names_str.split(\"[\\\\s]\");\r\n        return actors;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static int genTimeLong(Scanner SCANNER) {\r\n    int timeLong;\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入电影时长（分钟）:\");\r\n        timeLong = Integer.valueOf(SCANNER.nextLine());\r\n        if (timeLong < 0) {\r\n          System.out.println(\"时长不能为负，请重新输入。\");\r\n        } else {\r\n          return timeLong;\r\n        }\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入数据有误，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static double genPrice(Scanner SCANNER) {\r\n    double price;\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入电影票价:\");\r\n        price = Double.valueOf(SCANNER.nextLine());\r\n        if (price < 0) {\r\n          System.out.println(\"票价不能为负，请重新输入。\");\r\n        } else {\r\n          return price;\r\n        }\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入数据有误，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static int genTotalTicket(Scanner SCANNER) {\r\n    int totalTicket;\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入电影票总票数\");\r\n        totalTicket = Integer.valueOf(SCANNER.nextLine());\r\n        if (totalTicket <= 0) {\r\n          System.out.println(\"票数不能为负.不能为0，请重新输入。\");\r\n        } else {\r\n          return totalTicket;\r\n        }\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入数据有误，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static Date genBeOn(Scanner SCANNER) {\r\n    Date beOn;\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入上映日期（格式：2022-12-15 23:30）：\");\r\n        beOn =\r\n          new SimpleDateFormat(\"yyyy-MM-dd hh:mm\").parse(SCANNER.nextLine());\r\n        return beOn;\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入日期格式有误，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass Order {\r\n\r\n  String customUserName;\r\n  String businessUserName;\r\n  String movieId;\r\n  String movieName;\r\n  int ticketNum;\r\n  double ticketPrice;\r\n\r\n  public Order(\r\n    String customUserName,\r\n    String businessUserName,\r\n    String movieId,\r\n    String movieName,\r\n    int ticketNum,\r\n    double ticketPrice\r\n  ) {\r\n    this.customUserName = customUserName;\r\n    this.businessUserName = businessUserName;\r\n    this.movieId = movieId;\r\n    this.movieName = movieName;\r\n    this.ticketNum = ticketNum;\r\n    this.ticketPrice = ticketPrice;\r\n  }\r\n\r\n  public double getTotalPrice() {\r\n    return BigDecimal\r\n      .valueOf(\r\n        BigDecimal\r\n          .valueOf(ticketPrice)\r\n          .multiply(BigDecimal.valueOf(ticketNum))\r\n          .doubleValue()\r\n      )\r\n      .doubleValue();\r\n  }\r\n\r\n  public void setCustomUserName(String customUserName) {\r\n    this.customUserName = customUserName;\r\n  }\r\n\r\n  public String getCustomUserName() {\r\n    return customUserName;\r\n  }\r\n\r\n  public String getBusinessUserName() {\r\n    return businessUserName;\r\n  }\r\n\r\n  public void setBusinessUserName(String businessUserName) {\r\n    this.businessUserName = businessUserName;\r\n  }\r\n\r\n  public String getMovieId() {\r\n    return movieId;\r\n  }\r\n\r\n  public void setMovieId(String movieId) {\r\n    this.movieId = movieId;\r\n  }\r\n\r\n  public String getMovieName() {\r\n    return movieName;\r\n  }\r\n\r\n  public void setMovieName(String movieName) {\r\n    this.movieName = movieName;\r\n  }\r\n\r\n  public int getTicketNum() {\r\n    return ticketNum;\r\n  }\r\n\r\n  public void setTicketNum(int ticketNum) {\r\n    this.ticketNum = ticketNum;\r\n  }\r\n\r\n  public double getTicketPrice() {\r\n    return ticketPrice;\r\n  }\r\n\r\n  public void setTicketPrice(double ticketPrice) {\r\n    this.ticketPrice = ticketPrice;\r\n  }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n\r\n**使用测试**\r\n\r\n![](./images/java学习笔记/2022-10-31-14-21-14.png)\r\n![](./images/java学习笔记/2022-10-31-14-21-45.png)\r\n![](./images/java学习笔记/2022-10-31-14-22-55.png)\r\n![](./images/java学习笔记/2022-10-31-14-23-48.png)\r\n![](./images/java学习笔记/2022-10-31-14-24-29.png)\r\n![](./images/java学习笔记/2022-10-31-14-25-30.png)\r\n![](./images/java学习笔记/2022-10-31-14-26-03.png)\r\n![](./images/java学习笔记/2022-10-31-14-26-28.png)\r\n![](./images/java学习笔记/2022-10-31-14-26-47.png)\r\n![](./images/java学习笔记/2022-10-31-14-28-40.png)\r\n![](./images/java学习笔记/2022-10-31-14-28-59.png)\r\n![](./images/java学习笔记/2022-10-31-14-29-48.png)\r\n\r\n[源代码](./upload/javaDemo_movie.java)\r\n\r\n\r\n## 字符集编码解码\r\n**String编码**\r\n| 方法名称                            | 说明                                                                    |\r\n| ----------------------------------- | ----------------------------------------------------------------------- |\r\n| byte[] getBytes()                   | 使用平台的默认字符集将该String编码为一系列字节， 将结果存储到新的字节数 | 组中 |\r\n| byte[] getBytes(String charsetName) | 使用指定的字符集将该String编码为一系列字节， 将结果存储到新的字节数组中 |\r\n\r\n**String解码**\r\n| String的构造器                                  | 说明                                                       |\r\n| ----------------------------------------------- | ---------------------------------------------------------- |\r\n| String(byte[] bytes)                            | 通过使用平台的默认字符集解码指定的字节数组来构造新的String |\r\n| String String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来构造新的String         |\r\n\r\n\r\n\r\n**编解码测试**\r\n```java\r\nimport java.util.Arrays;\r\n\r\npublic class File_test {\r\n    public static void main(String[] args) throws Exception {\r\n        //编码\r\n        String str = \"123abc中文\";\r\n        byte[] default_encode_str = str.getBytes();//以平台默认的字符集编码\r\n        byte[] GBK_encode_str = str.getBytes(\"GBK\");//以GBK编码\r\n\r\n        System.out.println(default_encode_str.length);// 10\r\n        System.out.println(Arrays.toString(default_encode_str));//[49, 50, 51, 97, 98, 99, -42, -48, -50, -60]\r\n        System.out.println(GBK_encode_str.length);// 10\r\n        System.out.println(Arrays.toString(GBK_encode_str));//[49, 50, 51, 97, 98, 99, -42, -48, -50, -60]\r\n\r\n        //解码\r\n        String defString = new String(default_encode_str);//以平台默认的字符集解码\r\n        String gBKString = new String(GBK_encode_str,\"GBK\");//以GBK解码\r\n\r\n        System.out.println(defString);// 123abc中文\r\n        System.out.println(gBKString);// 123abc中文\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## File文件\r\n**概述**\r\n* File类用于根据文件的**绝对路径**或**相对路径**打开文件\r\n* **File类不能读写文件内容**\r\n* **读写文件需要使用IO流**\r\n\r\n### 构造器\r\n| 函数名                               | 使用案例                                                 |\r\n| ------------------------------------ | -------------------------------------------------------- |\r\n| File(File parent, String \"相对路径\") | File(new File(\"父文件夹路径\"), String \"相对路径\")        |\r\n| File(String pathname)                | `File(\".\\\\images\\\\123.jpg\")`  `File(\"./images/123.jpg\")` |\r\n| File(String parent, String child)    |\r\n| File(URI uri)                        |\r\n\r\n**注意**：\r\n* **File可以是文件可以是文件夹**\r\n* **传入的路径可以不存在，可以用exists()判断是否存在**\r\n\r\n\r\n### 常用方法\r\n| 方法名称                        | 说明                                       |\r\n| ------------------------------- | ------------------------------------------ |\r\n| public boolean isDirectory( )   | 测试此抽象路径名表示的File是否为文件夹     |\r\n| public boolean isFile()         | 测试此抽象路径名表示的File是否为文件       |\r\n| public boolean exists()         | 测试此抽象路径名表示的File是否存在         |\r\n| public String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串         |\r\n| public String getPath()         | 将此抽象路径名转换为路径名字符串           |\r\n| public String getName()         | 返回由此抽象路径名表示的文件或文件夹的名称 |\r\n| public long lastModified()      | 返回文件最后修改的时间毫秒值               |\r\n\r\n**File类创建文件的功能**\r\n| 方法名称                        | 说明                 |\r\n| ------------------------------- | -------------------- |\r\n| public boolean createNewFile( ) | 创建一个新的空的文件 |\r\n| public boolean mkdir( )         | 只能创建一级文件夹   |\r\n| public boolean mkdirs()         | 可以创建多级文件夹   |\r\n\r\n**File类删除文件的功能**\r\n| 方法名称                | 说明                                         |\r\n| ----------------------- | -------------------------------------------- |\r\n| public boolean delete() | 删除由此抽象路径名表示的文件或空文件夹(默认) |\r\n\r\n\r\n**File类的遍历功能**\r\n| 方法名称                        | 说明                                                                                                                                     |\r\n| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |\r\n| public String[] list()          | 获取当前目录下所有的\"一级文件名称\"到一个字符串数组中去返回。                                                                             |\r\n| public File[] listFiles()(常用) | 获取当前目录下所有的\"一级文件对象\"到一个文件对象数组中去返回(重点,若调用者不存在或者是文件则函数返回null，调用者是空文件夹则返回长度为0) |\r\n\r\n\r\n**递归遍历查找指定文件夹下的文件名**\r\n```java\r\npublic class File_test {\r\n    public static void main(String[] args) {\r\n        searchFireName(new File(\"./com\"),\"Student\");\r\n    }\r\n    public static void searchFireName(File father,String fileName){\r\n        if(father==null || father.isFile())\r\n            return;\r\n        for (File file : father.listFiles()) {\r\n            if(file.isFile() && file.getName().contains(fileName))\r\n                System.out.println(file.getAbsolutePath());\r\n            if(file.isDirectory())\r\n                searchFireName(file, fileName);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 流\r\n\r\n流的种类\r\n* 基础IO流\r\n* 缓冲流\r\n* 转换流\r\n* 打印流\r\n\r\n### 基础IO流\r\n**IO流的概念**\r\n* I: input,输入，将数据读取到内存\r\n* O: output,输出，将数据写入到磁盘\r\n\r\n**IO流分类**\r\n* 按流的方向\r\n  * 输入流\r\n  * 输出流\r\n* 按流的内容\r\n  * 字节流，读写数据，图片，视频，音乐\r\n  * 字符流，读写文本\r\n* 按读写性能\r\n  * 基础流\r\n  * 缓冲流\r\n\r\n\r\n**IO流体系图**\r\n![](./images/java学习笔记/2022-11-01-10-24-41.png)\r\n\r\n#### FileInputStream\r\n\r\n| 构造器                                  | 说明                               |\r\n| --------------------------------------- | ---------------------------------- |\r\n| public FileInputStream(File file)       | 创建字节输入流管道与源文件对象接通 |\r\n| public FilelnputStream(String pathname) | 创建字节输入流管道与源文件路径接通 |\r\n\r\n\r\n| 方法名称                       | 说明                                                                       |\r\n| ------------------------------ | -------------------------------------------------------------------------- |\r\n| public int read()              | 每次读取一个字节,返回读取到的字节的值，如果字节已经没有可读的返回-1        |\r\n| public int read(byte[] buffer) | 每次读取一个字节数组，返回读取到的字节的长度，如果字节已经没有可读的返回-1 |\r\n\r\n\r\n```java\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\n\r\npublic class File_test {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建输入流\r\n        InputStream inStream = new FileInputStream(new File(\"./File_test.java\"));\r\n\r\n        //一次读取1字节\r\n        byte bt;\r\n        while((bt = (byte)inStream.read())!=-1){ // 如果用来读取字符文件，无法避免中文乱码\r\n            System.out.print((char)bt);\r\n        }\r\n\r\n        byte[] buffer = new byte[1024];//一次读取1kB     \r\n        int length;\r\n        while((length = inStream.read(buffer))!=-1){// 如果用来读取字符文件，无法避免中文乱码\r\n            System.out.print(new String(buffer,0,length));\r\n        }\r\n\r\n        byte[] buffer =inStream.readAllBytes();//一次读取全部（实际调用了 readNBytes(Integer.MAX_VALUE) 只能读取Integer.MAX_VALUE个字节）\r\n        System.out.println(new String(buffer,\"UTF-8\"));\r\n    }\r\n}\r\n```\r\n\r\n#### FileOutputStream\r\n| 构造器                                                   | 说明                                               |\r\n| -------------------------------------------------------- | -------------------------------------------------- |\r\n| public FileOutputStream(File file)                       | 创建字节输出流管道与源文件对象接通                 |\r\n| public FileOutputStream(File file, boolean append)       | 创建字节输出流管道与源文件对象接通，可**追加**数据 |\r\n| public FileOutputStream(String filepath)                 | 创建字节输出流管道与源文件路径接通                 |\r\n| public FileOutputStream(String filepath, boolean append) | 创建字节输出流管道与源文件路径接通，可**追加**数据 |\r\n\r\n| 方法名称                                            | 说明                         |\r\n| --------------------------------------------------- | ---------------------------- |\r\n| public void write(int a)                            | 写一个字节出去               |\r\n| public void write(byte[] buffer)                    | 写一个字节数组出去           |\r\n| public void write(byte[] buffer ，int pos，int len) | 写一个字节数组的一部分出去。 |\r\n| flush()                                             | 写入                         |\r\n| close()                                             | 关闭                         |\r\n\r\n\r\n\r\n\r\n\r\n**构造器、方法测试**\r\n```java\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStream;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建输入流\r\n        OutputStream os = new FileOutputStream(new File(\"./123.java\"));\r\n        os.write('a');\r\n        os.write('b');\r\n        os.write('c');\r\n        os.write(\"中文字符串\".getBytes(\"UTF-8\"));//写入 byte[] :  \"中文字符串\"\r\n        os.write(\"\\r\\n\".getBytes());//换行\r\n        os.write(\"中文字符串\".getBytes(\"UTF-8\"),3,6);//写入 byte[] 的部分 : \"文字\"\r\n        os.flush();//写入\r\n        os.close();//关闭流（包含flush）\r\n    }\r\n}\r\n```\r\n\r\n**文件拷贝**\r\n```java\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        OutputStream os = new FileOutputStream(new File(\"./123.java\"));//文件输出流\r\n        InputStream is = new FileInputStream(new File(\"./Main.java\"));//文件输出流\r\n\r\n        byte[] buffer = new byte[1024];\r\n        int length = 0 ;//用于记录每次读取的字节长度\r\n        while((length = is.read(buffer))!=-1){\r\n            os.write(buffer,0,length);\r\n        }\r\n        os.close();\r\n        is.close();\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### FileReader\r\n\r\n| 构造器                             | 说明                               |\r\n| ---------------------------------- | ---------------------------------- |\r\n| public FileReader(File file)       | 创建字符输入流管道与源文件对象接通 |\r\n| public FileReader(String pathname) | 创建字符输入流管道与源文件路径接通 |\r\n\r\n| 方法名称                      | 说明                                                                   |\r\n| ----------------------------- | ---------------------------------------------------------------------- |\r\n| public int read()             | 每次读取一个字符返回，如果字符已经没有可读的返回-1                     |\r\n| public int read(char[ buffer) | 每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1 |\r\n\r\n\r\n**测试**\r\n```java\r\nimport java.io.FileReader;\r\nimport java.io.Reader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Reader  read = new FileReader(\"./Main.java\");\r\n        int ch;\r\n        while((ch=read.read())!=-1){\r\n            System.out.print((char)ch);//一次获取一个字符，无论其实际在文件中到底占几个字节\r\n        }\r\n        read.close();\r\n    }\r\n}\r\n```\r\n\r\n#### FileWriter\r\n\r\n| 构造器                             | 说明                               |\r\n| public FileWriter(String filepath, boolean append) | 道与源文件路径接通，可追加数据 |\r\n\r\n\r\n| 方法名称                                  | 说明                 |\r\n| ----------------------------------------- | -------------------- |\r\n| void write(int c)                         | 写一个字符           |\r\n| void write(char[] cbuf)                   | 写入一个字符数组     |\r\n| void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |\r\n| void write(String str)                    | 写一个字符串         |\r\n| void write(\"\\r\\n\")                        | 写一个字符           |\r\n| void write(String str, int off, int len)  | 写一个字符串的一部分 |\r\n| void write(int c)                         | 写一个字符           |\r\n| flush()                                   | 写入                 |\r\n| close()                                   | 关闭                 |\r\n\r\n\r\n\r\n### 缓冲IO流\r\n* 缓冲流也称高效流，高级流\r\n* 缓冲流就是将基础流包装了一层\r\n* 缓冲流**自带缓冲区（长度8192，8kB,2000H），可以提高原始字节流、字符流读写数据的性能**\r\n\r\n![](./images/java学习笔记/2022-11-01-20-58-44.png)\r\n\r\n#### 缓冲文件流 BufferedOutputStream BufferedInputStream\r\n\r\n**复制文件**\r\n```java\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        OutputStream os = new FileOutputStream(new File(\"./123.java\"));//文件输出流\r\n        InputStream is = new FileInputStream(new File(\"./Main.java\"));//文件输出流\r\n\r\n        OutputStream fuffered_os = new BufferedOutputStream(os);//文件输出流\r\n        InputStream buffered_is = new BufferedInputStream(is);//文件输出流\r\n\r\n        byte[] buffer = new byte[1024];\r\n        int length = 0 ;//用于记录每次读取的字节长度\r\n        while((length = buffered_is.read(buffer))!=-1){\r\n            fuffered_os.write(buffer,0,length);\r\n        }\r\n        fuffered_os.close();\r\n        buffered_is.close();\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### 缓冲字符流 BufferedReader BufferedWriter\r\n\r\n**BufferedReader**\r\n| BufferedReader构造器           | 说明                                                                                       |\r\n| ------------------------------ | ------------------------------------------------------------------------------------------ |\r\n| public String BufferedReader() | 可以把低级的字符读取流包装成-一个高级的缓 冲字符读取流管道，从而提高字符读取流写数据的性能 |\r\n\r\n\r\n| BufferedReader方法         | 说明                  |\r\n| -------------------------- | --------------------- |\r\n| `public String readLine()` | Reads a line of text. |\r\n\r\n**BufferedWriter**\r\n| BufferedWriter构造器            | 说明                                                                                       |\r\n| ------------------------------- | ------------------------------------------------------------------------------------------ |\r\n| public BufferedWriter(Writer w) | 可以把低级的字符输出流包装成-一个高级的缓 冲字符输出流管道，从而提高字符输出流写数据的性能 |\r\n\r\n\r\n| BufferedWriter方法      | 说明     |\r\n| ----------------------- | -------- |\r\n| `public void newline()` | 换行操作 |\r\n\r\n\r\n\r\n**测试**\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.Reader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Reader  read = new FileReader(\"./Main.java\",java.nio.charset.Charset.forName(\"UTF-8\"));\r\n        Reader  read_bf = new BufferedReader(read);\r\n\r\n        char[] buffer = new char[1024];\r\n        int length = 0 ;//用于记录每次读取的字节长度\r\n        while((length = read_bf.read(buffer))!=-1){\r\n            System.out.println(String.copyValueOf(buffer, 0, length));\r\n        }\r\n        read_bf.close();\r\n    }\r\n}\r\n```\r\n\r\n**独有方法测试**\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.Reader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Reader  read = new FileReader(\"./Main.java\",java.nio.charset.Charset.forName(\"UTF-8\"));\r\n        BufferedReader  read_bf = new BufferedReader(read);\r\n\r\n        String line;\r\n        while((line = read_bf.readLine())!=null){// 独有方法，读取一行\r\n            System.out.println(line);\r\n        }\r\n        read_bf.close();\r\n    }\r\n}\r\n```\r\n\r\n#### 字符输入/输出转换流\r\n![](./images/java学习笔记/2022-11-02-00-18-50.png)\r\n\r\n| 构造器                                                     | 说明                                                                                   |\r\n| ---------------------------------------------------------- | -------------------------------------------------------------------------------------- |\r\n| public InputStreamReader(InputStream is)                   | 可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader一样。 |\r\n| `public InputStreamReader(InputStream is，String charset)` | 可以把原始的字节流**按照指定编码转换成字符输入流**，这样字符流中的字符就不乱码了(重点) |\r\n\r\n| 构造器                                                       | 说明                                                               |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------------ |\r\n| public OutputStreamWriter(OutputStream os)                   | 可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。 |\r\n| `public OutputStreamWriter(OutputStream os, String charset)` | 可以把原始的字节输出流**按照指定编码转换成字符输出流**(重点)       |\r\n\r\n**综合案例：用指定编码读写文件**\r\n```java\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Writer;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 用UTF-8编码读取并解析文件\r\n        // 用GBK编码写入文件\r\n        Reader file1 = new InputStreamReader(new BufferedInputStream(new FileInputStream(\"./Main.java\")),\"UTF-8\");\r\n        Writer file2 = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"./123.txt\")),\"GBK\");\r\n\r\n        char[] buffer = new char[1024];\r\n        int length = 0;\r\n        while((length = file1.read(buffer)) != -1){\r\n            file2.write(buffer, 0, length);\r\n        }\r\n\r\n        file1.close();\r\n        file2.close();\r\n    }\r\n}\r\n```\r\n\r\n### 对象序列化(对象字节输出流)\r\n* 简单来说，就是把java中的通过关键字 `new` 创建的对象保存到硬盘上。\r\n* 作用:以内存为基准，把内存中的对象存储到磁盘文件中去,称为对象序列化。\r\n* 使用到的流是对象字节输出流: ObjectOutputStream\r\n* <green> 把一个对象写入到文件中，该对象必须实现了序列化接口`Serializable` </green>\r\n  * 其中实现类中`static final long serialVersionUID`用于指定在反序列化是的版本标记\r\n\r\n![](./images/java学习笔记/2022-11-02-01-02-58.png)\r\n\r\n**测试**\r\n```java\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.util.LinkedList;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建一个java对象，写入到文件\r\n        ObjectOutputStream file1 = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(\"./123.temp\")));\r\n        file1.writeObject(new LinkedList<>());;\r\n        file1.close();\r\n\r\n        //从文件读取写入的java对象\r\n        ObjectInputStream  file2 = new ObjectInputStream(new BufferedInputStream(new FileInputStream(\"./123.temp\")));\r\n        LinkedList  list =  (LinkedList)file2.readObject();\r\n        file2.close();\r\n\r\n        System.out.println(list.size());\r\n    }\r\n}\r\n```\r\n\r\n### 打印流\r\n打印流\r\n* 作用:打印流可以实现方便、高效的打印数据到文件中去。打印流一般是指: PrintStream, PrintWriter两个类。\r\n* 可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97,打印boolean的true，写出去就是true。\r\n\r\n![](./images/java学习笔记/2022-11-02-01-29-14.png)\r\n\r\n**`PrintStream`和`PrintWriter`的区别**\r\n* 打印数据功能上是一模一样的，都是使用方便，性能高效(核心优势)\r\n* PrintStream继承自字节输出流OutputStream, 支持写**字节数据**的方法。\r\n* PrintWriter继承自字符输出流Writer, 支持写**字符数据**出去。\r\n\r\n\r\n\r\n**PrintStream**\r\n| 构造器                                     | 说明                                 |\r\n| ------------------------------------------ | ------------------------------------ |\r\n| public PrintStream( OutputStream os)       | 打印流直接通向字节输出流管道         |\r\n| public PrintStream(File f)                 | 打印流直接通向文件对象               |\r\n| public PrintStream(File f,Charset charset) | 打印流直接通向文件对象(以指定字符集) |\r\n| public PrintStream(String filepath)        | 打印流直接通向文件路径               |\r\n  \r\n| 方法                      | 说明                   |\r\n| ------------------------- | ---------------------- |\r\n| public void print(Xxx xx) | 打印任意类型的数据出去 |\r\n\r\n\r\n**PrintWriter**\r\n| 构造器                               | 说明                         |\r\n| ------------------------------------ | ---------------------------- |\r\n| public PrintWriter(OutputStream os ) | 打印流直接通向字节输出流管道 |\r\n| public PrintWriter (Writer w)        | 打印流直接通向字符输出流管道 |\r\n| public PrintWriter (File f)          | 打印流直接通向文件对象       |\r\n| public PrintWriter (String filepath) | 打印流直接通向文件路径       |\r\n\r\n\r\n| 方法                      | 说明                   |\r\n| ------------------------- | ---------------------- |\r\n| public void print(Xxx xX) | 打印任意类型的数据出去 |\r\n\r\n\r\n**两种打印流的使用**\r\n```java\r\nimport java.io.File;\r\nimport java.io.PrintStream;\r\nimport java.io.PrintWriter;\r\nimport java.nio.charset.Charset;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        PrintStream pStream = new PrintStream(new File(\"./123.txt\"),Charset.forName(\"GBK\"));\r\n        pStream.print(123);\r\n        pStream.print(123.123);\r\n        pStream.print(true);\r\n        pStream.print(\"1231212312312中文\");\r\n        pStream.print(new Object());\r\n        pStream.write(\"1231221312332\".getBytes());      //打印字节流的write只能写字节\r\n        pStream.close();\r\n\r\n        PrintWriter pWriter = new PrintWriter(new File(\"./123.txt\"),Charset.forName(\"GBK\"));\r\n        pWriter.print(123);\r\n        pWriter.print(123.123);\r\n        pWriter.print(true);\r\n        pWriter.print(\"1231212312312中文\");\r\n        pWriter.print(new Object());\r\n        pWriter.write(\"1231221312332\");         //打印字符流的write能写字节也能写字符\r\n        pWriter.close();\r\n    }\r\n}\r\n```\r\n\r\n**重定向控制台输出到打印流**\r\n```java\r\nimport java.io.File;\r\nimport java.io.PrintStream;\r\nimport java.nio.charset.Charset;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        PrintStream pStream = new PrintStream(new File(\"./123.txt\"),Charset.forName(\"GBK\"));\r\n        System.setOut(pStream);//重定向控制台输出到打印流\r\n\r\n        System.out.println(\"12312123\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Properties属性集对象\r\n\r\n**作用**\r\n* **Properties本质为一个Map集合，但其实际常用于配置文件的读取、写入操作**\r\n* Properties对象表示一个属性文件\r\n* 用于存储对象中的键值对信息到一个属性文件中\r\n* 属性文件：后缀为`.properties` 内容为`key=value`,用于做系统配置\r\n\r\n| 方法                                                | 说明                                                                                                |\r\n| --------------------------------------------------- | --------------------------------------------------------------------------------------------------- |\r\n| void load(InputStream inStream)                     | 从输入字节流读取属性列表(键和元素对)                                                                |\r\n| **void load(Reader reader)**                        | 从输入字符流读取属性列表(键和元素对)、                                                              |\r\n| void store(OutputStream out, String comments)       | 将此属性列表(键和元素对)写入此Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流 |\r\n| **void store(Writer writer, String comments )**     | 将此属性列表(键和元素对)写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流        |\r\n| public object setProperty(String key, String value) | 保存键值对(put)                                                                                     |\r\n| public String getProperty(String key)               | 使用此属性列表中指定的键搜索属性值(get)                                                             |\r\n| `public Set<String> stringPropertyNames()`          | 所有键的名称的集合(keySet())                                                                        |\r\n\r\n\r\n使用测试\r\n```java\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.OutputStreamWriter;\r\nimport java.nio.charset.Charset;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建\r\n        Properties properties = new Properties();\r\n        System.out.println(properties);\r\n\r\n        //写入\r\n        properties.setProperty(\"用户名\", \"admin\");\r\n        properties.setProperty(\"密码\", \"admin\");\r\n        properties.store(new FileWriter(\"./123.properties\",Charset.forName(\"UTF-8\")), \"注释\");\r\n\r\n        //加载\r\n        properties.load(new FileReader(\"./123.properties\",Charset.forName(\"UTF-8\")));\r\n        System.out.println(properties);\r\n        System.out.println(properties.getProperty(\"用户名\"));\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-02-17-21-50.png)\r\n\r\n\r\n### IO框架：commons-io\r\n**概述**\r\n* commons-io是apache开源基金组织提供的一组有关I0操作的类库，可以提高I0功能开发的效率。\r\n* commons-io工具包提供了很多有关io操作的类。有两个主要的类 `FileUtils` , `lOUtils`\r\n* \r\nFileUtils主要方法:\r\n| 方法名                                                   | 说明                         |\r\n| -------------------------------------------------------- | ---------------------------- |\r\n| String readFileToString(File file, String encoding)      | 读取文件中的数据，返回字符串 |\r\n| void copyFile(File srcFile, File destFile)               | 复制文件。                   |\r\n| void copyDirectoryToDirectory(File srcDir, File destDir) | 复制文件夹。                 |\r\n\r\n**测试**\r\n```java\r\nimport java.io.File;\r\nimport java.util.*;\r\n\r\nimport org.apache.commons.io.FileUtils;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //读取文件内容\r\n        String str = FileUtils.readFileToString(new File(\"./123.txt\"), \"UTF-8\");\r\n        System.out.println(str);\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 中文进制转十进制\r\n\r\n<details>\r\n<summary> <strong> 源代码 </strong> </summary>\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.Reader;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        String str = \"一千万零四十五\";\r\n        System.out.println(str);\r\n        System.out.println(HanToNum(str));\r\n    }\r\n\r\n    public static final Map<Character,Integer> HanNum_charset = new HashMap();\r\n    static{\r\n        HanNum_charset.put('零',0);\r\n        HanNum_charset.put('一',1);\r\n        HanNum_charset.put('二',2);\r\n        HanNum_charset.put('三',3);\r\n        HanNum_charset.put('四',4);\r\n        HanNum_charset.put('五',5);\r\n        HanNum_charset.put('六',6);\r\n        HanNum_charset.put('七',7);\r\n        HanNum_charset.put('八',8);\r\n        HanNum_charset.put('九',9);\r\n        HanNum_charset.put('十',10);\r\n\r\n        HanNum_charset.put('壹',1);\r\n        HanNum_charset.put('贰',2);\r\n        HanNum_charset.put('叁',3);\r\n        HanNum_charset.put('肆',4);\r\n        HanNum_charset.put('伍',5);\r\n        HanNum_charset.put('陆',6);\r\n        HanNum_charset.put('柒',7);\r\n        HanNum_charset.put('捌',8);\r\n        HanNum_charset.put('玖',9);\r\n        HanNum_charset.put('拾',10);\r\n    }\r\n    public static final Map<Character,Integer> HanNum_unit = new HashMap();\r\n    static{\r\n        HanNum_unit.put('十',10);\r\n        HanNum_unit.put('拾',10);\r\n\r\n        HanNum_unit.put('百',100);\r\n        HanNum_unit.put('佰',100);\r\n        HanNum_unit.put('陌',100);\r\n\r\n        HanNum_unit.put('千',1000);\r\n        HanNum_unit.put('仟',1000);\r\n        HanNum_unit.put('阡',1000);\r\n\r\n        HanNum_unit.put('万',10000);\r\n        HanNum_unit.put('亿',100000000);\r\n    }\r\n    public static int HanToNum(String Han_num){// 一千五百 零 四 万亿 零 五千 零 八百\r\n        int result = 0 ;\r\n        int stackNum = 0;\r\n        for (int i = 0; i < Han_num.length(); i++) {\r\n            char ch = Han_num.charAt(i);\r\n            Integer value =  HanNum_charset.get(ch);\r\n            Integer unit =  HanNum_unit.get(ch);\r\n\r\n            if(unit!=null && unit==10 && stackNum==0){\r\n                stackNum = 10;\r\n                continue;\r\n            }\r\n            if(unit!=null && unit==10 && stackNum!=0){\r\n                stackNum *= 10;\r\n                continue;\r\n            }\r\n\r\n            if(unit!=null && value!=null && value==0){\r\n                result+=value;\r\n                value=0;\r\n                continue;\r\n            }\r\n\r\n            if(value!=null){\r\n                stackNum+=value;\r\n                continue;\r\n            }\r\n            if(unit!=null){\r\n                stackNum*=unit;\r\n                continue;\r\n            }\r\n            \r\n        }\r\n        result+=stackNum;\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n**实现效果**\r\n![](./images/java学习笔记/2022-11-02-00-13-17.png)\r\n\r\n## 多线程\r\n\r\n| 方式             | 优点                                                                 | 缺点                                                             |\r\n| ---------------- | -------------------------------------------------------------------- | ---------------------------------------------------------------- |\r\n| 继承Thread类     | 编程比较简单，可以直接使用Thread                                     | 扩展性较差，不能再继承其他的类，不能返回类中的方法线程执行的结果 |\r\n| 实现Runnable接口 | 扩展性强，实现该接口的同时还可以继承其他的类。                       | 编程相对复杂，不能返回线程执行的结果                             |\r\n| 实现Callable接口 | 扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果 | 编程相对复杂                                                     |\r\n\r\n\r\n\r\n### 方法1: **继承**`Thread类`\r\n* 步骤\r\n    * **继承**`Thread类`\r\n    * 重写`run()方法`\r\n    * 创建`实例对象`\r\n    * 调用`start()类`,内部会创建线程，并在线程中调用重写的`run()方法`\r\n* 缺点：由于一个类只能继承一个父类，无法继承其他类，不利于扩展\r\n\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Thread myThread1 = new MyThread();\r\n        myThread1.start();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"\\t主线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\nclass MyThread extends Thread{\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"子线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-02-19-20-53.png)\r\n\r\n\r\n### **方法2**：**实现**`Runnable接口`\r\n* 步骤\r\n    * **实现**`Runnable接口`\r\n    * **实现**`run()方法`\r\n    * 创建实例对象，丢给Thread的构造函数\r\n    * 调用`start()方法`\r\n* 优点，**可以继承其他类**\r\n* 缺点，**线程的执行结果不能直接返回**\r\n\r\n**写法一：实现`Runnable接口`**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Thread myThread1 = new Thread(new MyThread());\r\n        myThread1.start();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"\\t主线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\nclass MyThread implements Runnable{\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"子线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\n```\r\n**写法二：匿名类**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        \r\n        Thread myThread1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i < 10; i++) {\r\n                    System.out.println(\"子线程输出：\"+i);\r\n                }\r\n            }\r\n        }\r\n        );\r\n\r\n        myThread1.start();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"\\t主线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\n```\r\n**写法三：Lambda表达式写法**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        \r\n        Thread myThread1 = new Thread(()->{\r\n            for (int i = 0; i < 10; i++) {\r\n                System.out.println(\"子线程输出：\"+i);\r\n            }\r\n        });\r\n\r\n        myThread1.start();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"\\t主线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\n```\r\n***写法四：最简写法**\r\n```java\r\nnew Thread(()->{\r\n    for (int i = 0; i < 10; i++) {\r\n        System.out.println(\"子线程输出：\"+i);\r\n    }\r\n}).start();\r\n```\r\n\r\n### 方法3：实现`Callable接口`\r\n\r\n* 步骤\r\n  * 实现`Callable接口`\r\n  * 重写`call()方法`\r\n  * 用FutrueTask把Callable对象封装成**线程任务对象**\r\n  * 把**线程任务对象**丢给`Thread的构造器`\r\n  * 调用`Thread`的`start方法`\r\n  * 主线程中调用`FutureTask`的`get方法`等待并获取`call方法`的**返回结果**\r\n* 优点\r\n  * 可继承一个实现类\r\n  * 可获取方法的返回值\r\n* **FutureTask**方法\r\n    | 方法名称                           | 说明                                 |\r\n    | ---------------------------------- | ------------------------------------ |\r\n    | public FutureTask<>(Callable call) | 把Callable对象封装成FutureTask对象。 |\r\n    | public V get() throws Exception    | 获取线程执行call方法返回的结果。     |\r\n\r\n**写法**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.FutureTask;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        MyCallable myCallable = new MyCallable();\r\n        FutureTask<String> ft = new FutureTask<>(myCallable);\r\n        Thread mytThread = new Thread(ft);\r\n        \r\n        mytThread.start();\r\n\r\n        String result = ft.get();//get也会抛出线程的异常\r\n\r\n        System.out.println(\"result: \"+result);\r\n    }\r\n}\r\nclass MyCallable implements Callable<String>{\r\n\r\n    @Override\r\n    public String call() throws Exception {\r\n        for (int i = 0; i < 1000; i++) {\r\n            System.out.println(\"子线程执行...\"+i);\r\n        }\r\n        return \"子线程执行完毕\";\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-02-20-59-28.png)\r\n\r\n\r\n### Thread类\r\n\r\n\r\n**Thread的构造器**\r\n| 方法名称                                      | 说明                                         |\r\n| --------------------------------------------- | -------------------------------------------- |\r\n| public Thread(String name)                    | 可以为当前线程指定名称                       |\r\n| public Thread(Runnable target)                | 封装Runnable对象成为线程对象                 |\r\n| public Thread( Runnable target ,String name ) | 封装Runnable对象成为线程对象，并指定线程名称 |\r\n\r\n**Thread的主要方法**\r\n| 方法名称            | 说明         |\r\n| ------------------- | ------------ |\r\n| public void run( )  | 线程任务方法 |\r\n| public void start() | 线程启动方法 |\r\n\r\n**Thread获取和设置线程名称**\r\n| 方法名称                   | 说明                                                         |\r\n| -------------------------- | ------------------------------------------------------------ |\r\n| String getName()           | 获取当前线程的名称，默认线程名称是Thread-索引                |\r\n| void setName(String name ) | 将此线程的名称更改为指定的名称，通过构造器也可以设置线程名称 |\r\n\r\n**Thread类获得当前线程的对象**\r\n| 方法名称                             | 说明                               |\r\n| ------------------------------------ | ---------------------------------- |\r\n| public static Thread currentThread() | 返回对当前正在执行的线程对象的引用 |\r\n\r\n**Thread类的线程休眠方法**\r\n| 方法名称                            | 说明                                               |\r\n| ----------------------------------- | -------------------------------------------------- |\r\n| public static void sleep(long time) | 让当前线程休眠指定的时间后再继续执行，单位为毫秒。 |\r\n\r\n\r\n\r\n\r\nThread常用API说明\r\n* **区分线程**：获取线程名称getName()、 设置名称setName()、获取当前线程对象currentThread()（**静态**）\r\n* **其他方法**：至于Thread类 提供的诸如: yield、join、interrupt、 不推荐的方法stop、守护线程、线程优先级等线程的控制方法，\r\n\r\n**区分线程**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.FutureTask;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n       Thread thread1 = new Thread(()->{\r\n        Thread self = Thread.currentThread();\r\n        for(int i =0 ;i<5;i++)\r\n            System.out.println(self.getName() +  \"子线程执行...\"+i);\r\n       });\r\n       thread1.setName(\"thread1:\");\r\n       \r\n       Thread thread2 = new Thread(()->{\r\n        Thread self = Thread.currentThread();\r\n        for(int i =0 ;i<5;i++)\r\n            System.out.println(self.getName() +  \"子线程执行...\"+i);\r\n       });\r\n       thread2.setName(\"thread2:\");\r\n\r\n       thread1.start();\r\n       thread2.start();\r\n\r\n        Thread self = Thread.currentThread();\r\n        for(int i =0 ;i<5;i++)\r\n            System.out.println(self.getName() +  \"主线程执行...\"+i);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-02-21-30-10.png)\r\n\r\n\r\n\r\n## 线程安全问题\r\n\r\n**出现原因**\r\n* 并发线程\r\n* 同时访问共享的资源\r\n* 同时修改共享的资源\r\n\r\n**线程安全问题演示:**\r\n\r\n`public_resource`的值被修改成了负数\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static double public_resource = 100.0;// 公共资源\r\n\r\n    public static void changeResource(double newVal) {\r\n\r\n        if (public_resource > 0) {// 只准在public_resource大于0的时候操作数值\r\n            public_resource -= newVal;\r\n\r\n            String threadName = Thread.currentThread().getName();\r\n            System.out.println(threadName + \"线程改变了内容\");\r\n            System.out.println(\"public_resource\" + \"的值变为\" + public_resource);\r\n        }\r\n\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        Thread thread1 = new Thread(() -> {\r\n            while (true) {\r\n                Main.changeResource(100);\r\n            }\r\n        });\r\n\r\n        Thread thread2 = new Thread(() -> {\r\n            while (true) {\r\n                Main.changeResource(100);\r\n            }\r\n        });\r\n\r\n        thread1.start();\r\n        thread2.start();\r\n\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-00-52-42.png)\r\n\r\n\r\n### synchronized同步\r\n\r\n\r\n#### synchronized同步代码块\r\n* 作用：把出现线程安全问题的核心代码上锁\r\n* 原理：每次只允许一个线程进入，执行完毕后自动解锁，解锁后其他线程才能进入\r\n* 对于实例方法，同步代码块建议使用`this`作为锁的对象\r\n* 对于静态方法，同步代码块建议使用`类名.class`作为锁对象\r\n```java\r\nsynchronized(同步锁对象){//锁住一个共享资源对象，当不同的线程同时访问时，只有一个能访问，其他的要等待\r\n    操作共享资源的代码\r\n}\r\n```\r\n\r\n**使用同步代码块来锁定公共资源**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static Double public_resource = 100.0;//公共资源\r\n    public static void changeResource(double newVal){\r\n        synchronized(public_resource){// 同步代码块：锁住 public_resource ，只允许一个线程来操作,等一个线程操作完毕后，其他线程才能访问\r\n            if(public_resource>0){// 只准在public_resource大于0的时候操作数值\r\n                public_resource-=newVal;\r\n    \r\n                String threadName = Thread.currentThread().getName();\r\n                System.out.println(threadName + \"线程改变了内容\");\r\n                System.out.println(\"public_resource\"+\"的值变为\"+public_resource);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-00-54-51.png)\r\n\r\n#### synchronized同步方法\r\n\r\n* 每次只能一个线程进入方法，执行完毕后自动解锁\r\n* 作用：把出现线程问题的核心**方法**上锁。\r\n* 原理：每次只能一个线程进入，进入就上锁，执行完毕后自动解锁，解锁后其他线程才能进入。\r\n* 底层原理是有一个隐式的锁（锁的对象），锁的范围是整个方法的代码\r\n* 对于实例方法，同步方法默认用`this`作为**锁的对象**\r\n* 对于静态方法，同步方法默认用`类名.class`作为**锁的对象**\r\n```java\r\n修饰符 synchronized 返回值类型 方法名称(形参){\r\n    操作共享资源的代码\r\n}\r\n```\r\n\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static Double public_resource = 100.0;//公共资源\r\n    public synchronized static void changeResource(double newVal){ // 同步方法：锁住了整个方法的代码 ，只允许一个线程来操作,等一个线程操作完毕后，其他线程才能访问\r\n        if(public_resource>0){// 只准在public_resource大于0的时候操作数值\r\n            public_resource-=newVal;\r\n\r\n            String threadName = Thread.currentThread().getName();\r\n            System.out.println(threadName + \"线程改变了内容\");\r\n            System.out.println(\"public_resource\"+\"的值变为\"+public_resource);\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-00-59-54.png)\r\n\r\n\r\n\r\n\r\n### Lock锁\r\n\r\n* 为了更清晰的表达如何加锁和释放锁，JDK5以后提供了新的锁对象Lock\r\n* **Lock是接口类不是实现类**\r\n* Lock的实现类为`ReentrantLock`\r\n\r\n| 构造器名称             | 说明                   |\r\n| ---------------------- | ---------------------- |\r\n| public ReentrantLock() | 获得Lock锁的实例类对象 |\r\n\r\n| 方法名        | 说明   |\r\n| ------------- | ------ |\r\n| void lock()   | 获得锁 |\r\n| void unlock() | 释放锁 |\r\n\r\n**官方文档推荐用法**\r\n```java\r\n class X {\r\n   private final ReentrantLock lock = new ReentrantLock();//防止被修改，被撬锁\r\n   // ...\r\n\r\n   public void m() {\r\n     lock.lock();  // 上锁\r\n     try {\r\n       // ... method body\r\n     } finally {\r\n        //finally可以保证即使方法异常，也会解锁\r\n       lock.unlock();//解锁\r\n     }\r\n   }\r\n }\r\n```\r\n\r\n**测试**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\npublic class Main {\r\n   private static final ReentrantLock lock = new ReentrantLock();//定义一个锁，用final修饰防止被修改，被撬锁\r\n    public static Double public_resource = 100.0;//公共资源\r\n\r\n    public static void changeResource(double newVal){\r\n        lock.lock();  //上锁 // 只允许一个线程来操作,等一个线程操作完毕后，其他线程才能访问\r\n        try{\r\n\r\n            if(public_resource>0){// 只准在public_resource大于0的时候操作数值\r\n                public_resource-=newVal;\r\n                String threadName = Thread.currentThread().getName();\r\n                System.out.println(threadName + \"线程改变了内容\");\r\n                System.out.println(\"public_resource\"+\"的值变为\"+public_resource);\r\n            }\r\n\r\n        }catch(Exception e){\r\n            e.printStackTrace();\r\n        }finally{\r\n            lock.unlock();//放在finally中，保证函数一定被解锁\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-01-23-53.png)\r\n\r\n\r\n### 线程通信\r\n**Object类的等待和唤醒方法**:\r\n\r\n**这些方法应当使用当前`同步锁对象`调用**\r\n* 实例方法的**锁对象**是`this`\r\n* 静态方法的**锁对象**是`类名.class`\r\n* 只有锁对象知道有哪些线程在排队\r\n\r\n| 方法名称         | 说明                                                                         |\r\n| ---------------- | ---------------------------------------------------------------------------- |\r\n| void wait()      | 让当前线程等待并释放所占锁，直到另一个线程调用notify( )方法或notifyAll()方法 |\r\n| void notify()    | 唤醒正在等待的单个线程                                                       |\r\n| void notifyAll() | 唤醒正在等待的所有线程                                                       |\r\n\r\n\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static Double public_resource = 100.0;// 公共资源\r\n\r\n    public synchronized static void getResource(double newVal){ // 获取资源\r\n        try{\r\n            Object locker = Main.class;//当前的锁是 Main.class\r\n            if(public_resource > newVal){// 只准在资源足够的时候获取资源\r\n                public_resource-=newVal;\r\n    \r\n                String threadName = Thread.currentThread().getName();\r\n                System.out.println(\"\" + threadName + \"线程改变了内容,\" + \"public_resource\"+\"资源被获取\"+public_resource);\r\n    \r\n                //唤醒其他线程，告知资源已经操作完毕\r\n                locker.notifyAll();\r\n                //自身线程进入等待状态,等待被其他线程唤醒\r\n                locker.wait();\r\n            }else{\r\n                //唤醒其他线程，告知其他线程来补充资源\r\n                locker.notifyAll();\r\n                //自身线程进入等待状态,等待被其他线程唤醒\r\n                locker.wait();\r\n            }\r\n        }catch(Exception exception){\r\n            exception.fillInStackTrace();\r\n        }\r\n    }\r\n\r\n    public synchronized static void addResource(double newVal){ // 获取资源\r\n\r\n        try{\r\n            Object locker = Main.class;//当前的锁是 Main.class\r\n\r\n            if(public_resource < 1000){// 只在资源快将耗尽的时候补充资源\r\n                public_resource+=newVal;\r\n\r\n                String threadName = Thread.currentThread().getName();\r\n                System.out.println(\"\\t\" + threadName + \"线程改变了内容,\" + \"public_resource\"+\"资源被补充\"+public_resource);\r\n\r\n                //唤醒其他线程，告知资源已经补充完毕\r\n                locker.notifyAll();\r\n                //自身线程进入等待状态,等待被其他线程唤醒\r\n                locker.wait();\r\n            }else{\r\n                //唤醒其他线程，告知其他线程来获取资源\r\n                locker.notifyAll();\r\n                //自身线程进入等待状态,等待被其他线程唤醒\r\n                locker.wait();\r\n            }\r\n        }catch(Exception exception){\r\n            exception.fillInStackTrace();\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        new Thread(() -> {\r\n            while (true) {\r\n                Main.getResource(100);\r\n            }\r\n        }).start();\r\n\r\n        new Thread(() -> {\r\n            while (true) {\r\n                Main.addResource(1000);\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-02-07-58.png)\r\n\r\n\r\n\r\n## 线程池\r\n\r\n### 概念\r\n* **一种线程的复用技术，因为线程的创建开销很大。**\r\n* JDK5.0起，`ExecutorService接口类`代表线程池\r\n\r\n\r\n**线程池工作原理**\r\n![](./images/java学习笔记/2022-11-03-02-15-46.png)\r\n\r\n**线程池的创建**\r\n* 方式一:使用`ExecutorService接口类`的`实现类ThreadPoolExecutor`创建线程池对象\r\n* 方式二:使用`Executors线程池工具类`调用方法返回不同特点的线程池对象\r\n\r\n\r\n### 实现类ThreadPoolExecutor\r\n**ExecutorService的常用方法**\r\n| 方法名称                             | 说明                                                               |\r\n| ------------------------------------ | ------------------------------------------------------------------ |\r\n| `void execute( Runnable command)`    | 执行任务/命令，没有返回值，一般用来执行Runnable 任务               |\r\n| `Future<T> submit(Cal1ab1e<T> task)` | 执行任务，返回未来任务对象获取线程结果，一般拿来执行 Callable 任务 |\r\n| `void shutdown()`                    | 等任务执行完毕后关闭线程池                                         |\r\n| `List<Runnab1e> shutdownNow()`       | 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务             |\r\n\r\n**新任务拒绝策略**\r\n| 策略                                   | 详解                                                             |\r\n| -------------------------------------- | ---------------------------------------------------------------- |\r\n| ThreadPoolExecutor.AbortPolicy         | 丢弃任务并抛出`RejectedExecutionException`异常。**是默认的策略** |\r\n| ThreadPoolExecutor.DiscardPolicy:      | 丢弃任务，但是不抛出异常这是不推荐的做法                         |\r\n| ThreadPoolExecutor.Discard0ldestPolicy | 抛弃队列中等待最久的任务然后把当前任务加入队列中                 |\r\n| ThreadPoolExecutor.CallerRunsPolicy    | 由主线程负责调用任务的run()方法从而绕过线程池直接执行            |\r\n\r\n\r\n**实现类ThreadPoolExecutor的构造器**\r\n```java\r\npublic ThreadPoolExecutor(int corePoolSize,//核心线程数，固定线程数\r\n                          int maximumPoolSize,//最大线程数，动态线程数\r\n                          long keepAliveTime,//动态线程的生命期\r\n                          TimeUnit unit,//生命期单位，秒，分，时，天\r\n                          BlockingQueue<Runnable> workQueue,//任务队列\r\n                          ThreadFactory threadFactory,//创建线程的工厂\r\n                          RejectedExecutionHandler handler//指定线程忙，任务队列慢的回调\r\n                          ) \r\n                          {\r\n}\r\n```\r\n**线程池常见面试题**\r\n* 临时线程什么时候创建啊?\r\n* 新任务提交时发现核心线程都在忙,**任务队列也满了**，并且还可以创建临时线程，此时才会创建临时线程。\r\n* 什么时候会开始拒绝任务?\r\n* 核心线程和临时线程都在忙,任务队列也满了，新的任务过来的时候才会开始任务拒绝。\r\n\r\n**ThreadPoolExecutor测试:处理Runnable对象**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建线程池\r\n        ThreadPoolExecutor threads = new ThreadPoolExecutor(\r\n            3,//核心线程数，固定线程数\r\n         6,//总线程数（核心+临时线程）\r\n         10,TimeUnit.SECONDS, //临时线程的生命周期，及单位\r\n         new ArrayBlockingQueue<>(5),// 任务队列\r\n         new ThreadPoolExecutor.AbortPolicy()// 拒绝策略（默认）\r\n         );\r\n\r\n         //创建一个可执行的任务\r\n        Runnable runnable1 = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i < 1; i++) {\r\n                    System.out.println(Thread.currentThread().getName() + \"执行了HelloWord X \" + i + \"次\");\r\n                }    \r\n            }\r\n        };\r\n        Runnable runnable2 = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i < 1; i++) {\r\n                    System.out.println(Thread.currentThread().getName() + \"执行了HelloWord X \" + i + \"次\");\r\n                }\r\n                try{\r\n                    System.out.println(Thread.currentThread().getName() + \"该线程即将被休眠......\");\r\n                    Thread.sleep(1000000000);//休眠线程\r\n                }catch(Exception e){\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        };\r\n\r\n        //把可执行的任务丢入线程池的任务队列处理\r\n        threads.execute(runnable1);//核心线程将被占用一个，但任务执行完毕后，线程将会交给其他任务\r\n        threads.execute(runnable1);//核心线程将被占用一个，但任务执行完毕后，线程将会交给其他任务\r\n        threads.execute(runnable1);//核心线程将被占用一个，但任务执行完毕后，线程将会交给其他任务\r\n\r\n        threads.execute(runnable2);//核心线程将被占用一个，线程将被休眠 任务队列共有5个空位，当前占用1个位置\r\n        threads.execute(runnable2);//核心线程将被占用一个，线程将被休眠 任务队列共有5个空位，当前占用2个位置\r\n        threads.execute(runnable2);//核心线程将被占用一个，线程将被休眠 任务队列共有5个空位，当前占用3个位置\r\n\r\n        threads.execute(runnable2);//三个核心线程都被占用了，但任务队列共有5个空位，当前占用4个位置，未满，不会创建临时线程，该任务不会执行\r\n        threads.execute(runnable2);//三个核心线程都被占用了，但任务队列共有5个空位，当前占用5个位置，未满，不会创建临时线程，该任务不会执行\r\n        threads.execute(runnable2);//三个核心线程都被占用了，任务队列的5个位置已满，将创建临时线程，该任务不会执行，但会执行任务队列中第一个任务。\r\n\r\n        // threads.shutdown();//待任务队列中的任务执行完毕后再关闭线程池\r\n        // threads.shutdownNow();//立即关闭线程池\r\n    }\r\n}\r\n```\r\n\r\n**ThreadPoolExecutor测试:处理Runnable对象**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.Future;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建线程池\r\n        ThreadPoolExecutor threads = new ThreadPoolExecutor(\r\n            3,//核心线程数，固定线程数\r\n         6,//总线程数（核心+临时线程）\r\n         10,TimeUnit.SECONDS, //临时线程的生命周期，及单位\r\n         new ArrayBlockingQueue<>(5),// 任务队列\r\n         new ThreadPoolExecutor.AbortPolicy()// 拒绝策略（默认）\r\n         );\r\n\r\n         //创建一个可执行的任务\r\n         Callable<String>  callable1 = new Callable<String>() {\r\n            @Override\r\n            public String call() {\r\n                for (int i = 0; i < 5; i++) {\r\n                    System.out.println(Thread.currentThread().getName() + \"执行了HelloWord X \" + i + \"次\");\r\n                }\r\n                return Thread.currentThread().getName() + \"线程执行完毕\";  \r\n            }\r\n        };\r\n        \r\n        //把可执行的任务丢入线程池的任务队列处理\r\n        Future<String> future1 = threads.submit(callable1);\r\n        Future<String> future2 = threads.submit(callable1);\r\n        Future<String> future3 = threads.submit(callable1);\r\n        Future<String> future4 = threads.submit(callable1);\r\n        Future<String> future5 = threads.submit(callable1);\r\n        Future<String> future6 = threads.submit(callable1);\r\n        Future<String> future7 = threads.submit(callable1);\r\n\r\n        System.out.println(future1.get());\r\n        System.out.println(future2.get());\r\n        System.out.println(future3.get());\r\n        System.out.println(future4.get());\r\n        System.out.println(future5.get());\r\n        System.out.println(future6.get());\r\n        System.out.println(future7.get());\r\n\r\n        // threads.shutdown();//待任务队列中的任务执行完毕后再关闭线程池\r\n        // threads.shutdownNow();//立即关闭线程池\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-03-51-59.png)\r\n\r\n\r\n### Executors工具类创建线程池\r\n* Executors: 线程池的工具类通过调用方法返回不同类型的线程池对象。\r\n* 注意: Executors的底层其实也是`基于线程池的实现类ThreadPoolExecutor`创建线程池对象的。\r\n* <green>这种方式创建线程在大型并发项目中存在多种弊端，被阿里巴巴公约禁止，建议使用原始方式<green>\r\n\r\n**Executors得到线程池对象的常用方法**\r\n| 方法名称                                                                        | 说明                                                                                            |\r\n| ------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |\r\n| public static ExecutorService newCachedThreadPool()                             | 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。                  |\r\n| public static ExecutorService newF ixedThreadPool( int nThreads )               | 创建有固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个 新线程替代它。 |\r\n| public static ExecutorService newSingleThreadExecutor ()                        | 创建只有一个线程的线程池对象， 如果该线程出现异常而结束，那么线程池会补充一个新线程。           |\r\n| public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) | 创建一个线程池， 可以实现在给定的延迟后运行任务，或者定期执行任务。                             |\r\n\r\n**在大型并发项目中使用Executors所存在的问题**\r\n![](./images/java学习笔记/2022-11-03-08-02-44.png)\r\n\r\n\r\n\r\n## 定时器\r\n\r\n### Timer定时器\r\n\r\nTimer定时器的特点和存在的问题\r\n* 1、Timer是**单线程**，处理多个任务按照**顺序执行**，存在延时与设置定时器的时间有出入。\r\n* 2、<green>可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行</green>\r\n\r\n\r\n| 构造器         | 说明                |\r\n| -------------- | ------------------- |\r\n| public Timer() | 创建Timer定时器对象 |\r\n\r\n| 方法                                                          | 说明                                      |\r\n| ------------------------------------------------------------- | ----------------------------------------- |\r\n| public void schedule(TimerTask task, long delay)              | 开启一个定时器，按照计划处理TimerTask任务 |\r\n| public void schedule(TimerTask task, long delay, long period) | 开启一个定时器，按照计划处理TimerTask任务 |\r\n\r\n\r\n**测试代码**\r\n```java\r\nimport java.util.Timer;\r\nimport java.util.TimerTask;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Timer timer = new Timer();//定时器是一个单线程任务,处理多个任务按顺序执行\r\n        Runnable task1 = new TimerTask() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(Thread.currentThread().getName() + \"执行了.\");    \r\n                try {\r\n                    Thread.sleep(2000);//某条任务的执行时间过长会导致任务队列中的其余任务持续等待。\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }            \r\n            }\r\n        };\r\n        timer.schedule( (TimerTask) task1, 500, 500);\r\n    }\r\n}\r\n```\r\n\r\n### ScheduledExecutorService定时器\r\n* ScheduledExecutorService是一个线程池\r\n* \r\n\r\n| Executors工具类的方法                                                           | 说明           |\r\n| ------------------------------------------------------------------------------- | -------------- |\r\n| public static ScheduledExecutorService newScheduledThreadPoo1(int corePoolSize) | 得到线程池对象 |\r\n\r\n| ScheduledExecutorService的方法                                                                                 | 说明                                                                           |\r\n| -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |\r\n| public ScheduledFuture<?> scheduleAtFixedRate( Runnable command, long initialDelay, long period,TimeUnit unit) | 周期调度方法，循环执行：先延迟initialDelay时间，而后以period时间为周期循环执行 |\r\n| public ScheduledFuture<?> schedule(Runnable command,long delay, TimeUnit unit);                                | 只执行一次：先延迟后执行                                                       |\r\n\r\n```java\r\nimport java.util.Timer;\r\nimport java.util.TimerTask;\r\nimport java.util.concurrent.Executor;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(10);\r\n        Runnable task1 =  new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(Thread.currentThread().getName()+\"线程执行了该任务1...\");\r\n                try {\r\n                    System.out.println(Thread.currentThread().getName()+\"线程被休眠5秒....\");\r\n                    Thread.sleep(5000);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }//\r\n            }\r\n        };\r\n        Runnable task2 =  new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(Thread.currentThread().getName()+\"线程执行了该任务2...\");\r\n            }\r\n        };\r\n        // newScheduledThreadPool.schedule(task1, 2, TimeUnit.SECONDS);//只执行一次：先延迟后执行\r\n        newScheduledThreadPool.scheduleAtFixedRate(task1, 0, 1, TimeUnit.SECONDS);// 循环执行：先延迟2秒，而后以4秒为周期循环执行\r\n        newScheduledThreadPool.scheduleAtFixedRate(task2, 0, 1, TimeUnit.SECONDS);// 循环执行：先延迟2秒，而后以4秒为周期循环执行\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-09-37-55.png)\r\n\r\n\r\n## 并发与并行\r\n**并发**: CPU的单个核心，计算资源有限，**分时**轮询为多个线程提供服务，称为并发。\r\n**并行**: 多核CPU,计算资源富余，一个核心负责一个线程，多个核心上执行的线程为**同时**执行，称为并行。\r\n\r\n### Thread线程生命周期6种状态\r\n* java线程有6种状态\r\n* 6种状态都定义在Thread类的n内部枚举类中\r\n  ```java\r\n  public enum Thread.State {\r\n        NEW,//新建状态\r\n        RUNNABLE,//可运行状态\r\n        BLOCKED,//阻塞状态（被锁住） \r\n        WAITING,//无限等待状态\r\n        TIMED_WAITING,//计时状态\r\n        TERMINATED;//被终止状态\r\n    }\r\n  ```\r\n* ![](./images/java学习笔记/2022-11-03-11-54-54.png)\r\n\r\n| 线程状态                | 描述                                                                                                                             |\r\n| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------- |\r\n| NEW(新建)               | 线程刚被创建，但是并未启动。                                                                                                     |\r\n| Runnable(可运行)        | 线程已经调用了start()等待CPU调度                                                                                                 |\r\n| Blocked(锁阻塞)         | 线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态;。                                                                       |\r\n| Waiting(无限等待)       | 一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒                                                         |\r\n| Timed Waiting(计时等待) | 同waiting状态，有几个方法有超时参数,调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep(num)、Object.wait(num) |\r\n| Teminated(被终止)       | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。                                                           |\r\n\r\n\r\n## 网络变成\r\n\r\n### InetAddress的使用\r\n* 此类表示Internet协议 (IP) 地址。\r\n**InetAddress API如下**\r\n\r\n| 名称                                              | 说明                                             |\r\n| ------------------------------------------------- | ------------------------------------------------ |\r\n| public static InetAddress getLocalHost()          | 返回本主机的地址对象                             |\r\n| public static InetAddress getByName(String host ) | 得到指定主机的IP地址对象，参数是域名或者IP地址   |\r\n| public String getHostName()                       | 获取此IP地址的主机名                             |\r\n| public String getHostAddress()                    | 返回IP地址字符串                                 |\r\n| public boolean isReachable(int timeout )          | 在指定毫秒内连通该IP地址对应的主机，连通返回true |\r\n\r\n**测试**\r\n```java\r\nimport java.net.InetAddress;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //获取InetAddress\r\n        InetAddress localHost_host = InetAddress.getLocalHost();\r\n        InetAddress localHost_baidu = InetAddress.getByName(\"baidu.com\");//填域名或ip\r\n\r\n        System.out.println(localHost_host);\r\n        System.out.println(localHost_baidu);\r\n\r\n        //获取域名\r\n        System.out.println(localHost_host.getHostName());\r\n        System.out.println(localHost_baidu.getHostName());\r\n\r\n        //获取IP地址\r\n        System.out.println(localHost_host.getHostAddress());\r\n        System.out.println(localHost_baidu.getHostAddress());\r\n\r\n        //测试连通性\r\n        System.out.println(localHost_host.isReachable(1000));\r\n        System.out.println(localHost_baidu.isReachable(1000));\r\n\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-12-35-17.png)\r\n\r\n\r\n### UDP数据包\r\n| DatagramPacket数据包对象构造器                                               | 说明                                                                                                                     |\r\n| ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |\r\n| public DatagramPacket(byte[] buf, int length, InetAddress address, int port) | 创建发送端数据包对象buf:要发送的内容，字节数组 length:要发送内容的字节长度 address:接收端的IP地址对象port:接收端的端口号 |\r\n| public DatagramPacket(byte[] buf, int length)                                | 创建接收端的数据包对象buf:用来存储接收的内容 length:能够接收内容的长度                                                   |\r\n\r\n**DatagramPacket常用方法**\r\n| 方法                          | 说明                                  |\r\n| ----------------------------- | ------------------------------------- |\r\n| public int getLength()        | 获得实际接收到的字节个数              |\r\n| public int getSocketAddress() | 获得实际接收到的数据包中的InetAddress |\r\n\r\n### DatagramSocket通信接口对象\r\n**DatagramSocket(UDP通信接口对象)**\r\n| DatagramSocket构造器                              | 说明                                                               |\r\n| ------------------------------------------------- | ------------------------------------------------------------------ |\r\n| public DatagramSocket()                           | 创建发送端的Socket对象，系统会随机分配一个端口号。                 |\r\n| public DatagramSocket(int port)                   | 创建接收端的Socket对象并指定端口号                                 |\r\n| public DatagramSocket(int port,InetAddress laddr) | **简单来说就是要说明数据从哪一个端口出去，从哪一个ip网卡接口出去** |\r\n\r\n**DatagramSocket类成员方法**\r\n| 方法                                  | 说明       |\r\n| ------------------------------------- | ---------- |\r\n| public void send(DatagramPacket dp)   | 发送数据包 |\r\n| public void receive(DatagramPacket p) | 接收数据包 |\r\n\r\n使用多线程模拟服务端和客户端的UDP的通信\r\n```java\r\nimport java.io.IOException;\r\nimport java.net.DatagramPacket;\r\nimport java.net.DatagramSocket;\r\nimport java.net.InetAddress;\r\nimport java.time.LocalTime;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        // 接收端\r\n        new Thread(() -> {\r\n            try (DatagramSocket socket = new DatagramSocket(9999, InetAddress.getLocalHost())) {\r\n                byte[] buffer = new byte[64 * 1024];// UDP包最大64KB\r\n                DatagramPacket packet = new DatagramPacket(\r\n                        buffer,\r\n                        0, buffer.length// buffer\r\n                );\r\n\r\n                while (true) {\r\n                    socket.receive(packet);\r\n\r\n                    String context = new String(buffer, 0, packet.getLength());\r\n                    System.out.println(\"接收到来自\"+packet.getSocketAddress()+\"的数据：\" + context);\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n\r\n        // 发送端\r\n        new Thread(() -> {\r\n            try (// 创建UDP数据报的发送接口\r\n            DatagramSocket socket = new DatagramSocket(8888, InetAddress.getLocalHost())) {\r\n                // 发送数据包\r\n                while (true) {\r\n                    String message =  \"当前时间为:\" + LocalTime.now().toString();\r\n                    byte[] buffer = message.getBytes();\r\n\r\n                    //// 封装数据包: 数据，数据长度，目标地址，目标端口\r\n                    socket.send(new DatagramPacket(buffer,buffer.length,\r\n                        InetAddress.getByName(\"255.255.255.255\"),9999//向局域网所有主机的9999端口广播\r\n                        ));\r\n                    \r\n                    Thread.sleep(1000);//延迟\r\n                }\r\n            } catch (IOException | InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-14-53-41.png)\r\n\r\n### UDP的单播、组播、广播\r\n\r\n**总结**\r\n| 类型 | 概念                                       | 目的ip地址，                                                                  | 目的端口地址                                 |\r\n| ---- | ------------------------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------- |\r\n| 单播 | 一台主机向另**一台**主机发送数据包         | 目的地址为目标主机地址                                                        | 端口一致（目的端口为对方主机程序的监听端口） |\r\n| 组播 | 一台主机向另**一组**主机发送数据包         | **目的地址**为**目标主机**所**绑定**的**组播地址**`224.0.0.0-239.255.255.255` | 端口一致                                     |\r\n| 广播 | 一台主机向**所在网络的所有主机**发送数据包 | 目的地址为广播地址`255.255.255.255`                                           | 端口一致                                     |\r\n\r\n![](./images/java学习笔记/2022-11-03-15-37-11.png)\r\n\r\n**组播通信测试**\r\n```java\r\nimport java.io.IOException;\r\nimport java.net.DatagramPacket;\r\nimport java.net.DatagramSocket;\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.MulticastSocket;\r\nimport java.net.NetworkInterface;\r\nimport java.time.LocalTime;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        // 接收端1\r\n        new Thread(() -> {\r\n\r\n            try (\r\n                MulticastSocket socket = new MulticastSocket(9999);\r\n\r\n                ) {\r\n                // 把当前socket加入到组播地址，网段为当前所在网段\r\n                socket.joinGroup(\r\n                    new InetSocketAddress(InetAddress.getByName(\"224.0.0.1\"), 0), \r\n                    NetworkInterface.getByInetAddress(InetAddress.getLocalHost())//网段为本机网段\r\n                );\r\n\r\n                byte[] buffer = new byte[64 * 1024];// UDP包最大64KB\r\n                DatagramPacket packet = new DatagramPacket(\r\n                        buffer,\r\n                        0, buffer.length// buffer\r\n                );\r\n\r\n                while (true) {\r\n                    socket.receive(packet);\r\n\r\n                    String context = new String(buffer, 0, packet.getLength());\r\n                    System.out.println( Thread.currentThread().getName() + \"线程 \" + \"接收到来自\"+packet.getSocketAddress()+\"的数据：\" + context);\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n\r\n\r\n        // 发送端\r\n        new Thread(() -> {\r\n            try (// 创建UDP数据报的发送接口\r\n            DatagramSocket socket = new DatagramSocket(8888, InetAddress.getLocalHost())) {\r\n                // 发送数据包\r\n                while (true) {\r\n                    String message =  \"当前时间为:\" + LocalTime.now().toString();\r\n                    byte[] buffer = message.getBytes();\r\n\r\n                    //// 封装数据包: 数据，数据长度，目标地址，目标端口\r\n                    socket.send(new DatagramPacket(buffer,buffer.length,\r\n                        InetAddress.getByName(\"224.0.0.1\"),9999         //向局域网的一个组播地址发送数据\r\n                        ));\r\n                    Thread.sleep(1000);//延迟\r\n                }\r\n            } catch (IOException | InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-17-47-45.png)\r\n\r\n### TCP\r\n\r\n#### Socket类\r\n| Socket构造器                         | 说明                                                             |\r\n| ------------------------------------ | ---------------------------------------------------------------- |\r\n| public Socket(String host，int port) | 创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。 |\r\n\r\n\r\n| Socket类成员方法               | 说明               |\r\n| ------------------------------ | ------------------ |\r\n| OutputStream getoutputStream() | 获得字节输出流对象 |\r\n| InputStream getInputStream( )  | 获得字节输入流对象 |\r\n\r\n#### ServerSocket类\r\n\r\n| ServerSocket类构造器          | 说明           |\r\n| ----------------------------- | -------------- |\r\n| public ServerSocket(int port) | 注册服务端端口 |\r\n\r\n| ServerSocket类方法     | 说明                                                                       |\r\n| ---------------------- | -------------------------------------------------------------------------- |\r\n| public Socket accept() | 等待接收客户端的Socket通信连接连接成功返回Socket对象与客户端建立端到端通信 |\r\n\r\n#### TCP通信测试：连接的建立与通信\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.time.LocalDateTime;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        // 服务端\r\n        new Thread(() -> {\r\n            try {\r\n                System.out.println(\"服务端启动\");\r\n                ServerSocket server = new ServerSocket(8888);//创建一个TCP服务器\r\n\r\n                //等待并获取一个TCP请求\r\n                Socket socket = server.accept();\r\n\r\n                //获取字节流数据\r\n                OutputStream os = socket.getOutputStream();\r\n                InputStream is = socket.getInputStream();\r\n\r\n                //包装成字符流\r\n                BufferedReader request_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                String message_req;\r\n                while ((message_req = request_Reader.readLine()) != null) {\r\n                    System.out.println(\"服务端收到客户端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n\r\n                    reponse_Writer.write(\"你发来的数据是：\"+message_req);//响应\r\n                    reponse_Writer.newLine();\r\n                    reponse_Writer.flush();\r\n                }\r\n\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n\r\n        }).start();\r\n\r\n        // 客户端\r\n        new Thread(() -> {\r\n            try {\r\n\r\n                Thread.sleep(1000);\r\n                System.out.println(\"客户端启动\");\r\n\r\n                Socket socket = new Socket(\"127.0.0.1\", 8888);\r\n\r\n                OutputStream os = socket.getOutputStream();\r\n                InputStream is = socket.getInputStream();\r\n\r\n                BufferedReader rsponse_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                BufferedWriter request_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                new Thread(()->{//获取服务端的响应\r\n                    try {\r\n                        String message_req;\r\n                        while ((message_req = rsponse_Reader.readLine()) != null) {\r\n                            System.out.println(\"\\t客户端收到服务端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n                        }\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }).start();\r\n\r\n                while(true){\r\n                    request_Writer.write(\"helloWorld \" + LocalDateTime.now() );//请求\r\n                    request_Writer.newLine();\r\n                    request_Writer.flush();\r\n                    Thread.sleep(1000);\r\n                }\r\n\r\n            } catch (IOException | InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-04-00-22-20.png)\r\n\r\n#### TCP通信测试：服务端通过临时创建子线程服务多个客户端\r\n`Server.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class Server {\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"服务端启动\");\r\n            ServerSocket server = new ServerSocket(8888);\r\n            while (true) {\r\n                Socket socket = server.accept();//获取到一个链接就创建一个子线程来处理\r\n                System.out.println(\"新连接已建立...\\n交由子线程处理...\");\r\n                new Thread(() -> {\r\n                    try {\r\n                        OutputStream os = socket.getOutputStream();\r\n                        InputStream is = socket.getInputStream();\r\n\r\n                        BufferedReader request_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                        BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                        String message_req;\r\n                        while ((message_req = request_Reader.readLine()) != null) {\r\n                            System.out.println(\"服务端收到客户端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n\r\n                            reponse_Writer.write(\"你发来的数据是：\" + message_req);// 响应\r\n                            reponse_Writer.newLine();\r\n                            reponse_Writer.flush();\r\n                        }\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n\r\n                }).start();\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`Client.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.Socket;\r\nimport java.time.LocalDateTime;\r\nimport java.util.Scanner;\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        try {\r\n            Thread.sleep(1000);\r\n            System.out.println(\"客户端启动\");\r\n\r\n            Socket socket = new Socket(\"127.0.0.1\", 8888);\r\n\r\n            OutputStream os = socket.getOutputStream();\r\n            InputStream is = socket.getInputStream();\r\n\r\n            BufferedReader rsponse_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n            BufferedWriter request_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n            new Thread(()->{//获取服务端的响应\r\n                try {\r\n                    String message_req;\r\n                    while ((message_req = rsponse_Reader.readLine()) != null) {\r\n                        System.out.println(\"\\t客户端收到服务端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n\r\n            while(true){\r\n                System.out.println(\"请输入要发送的数据：\");\r\n                request_Writer.write( sc.nextLine() + LocalDateTime.now() );//请求\r\n                request_Writer.newLine();\r\n                request_Writer.flush();\r\n            }\r\n\r\n        } catch (IOException | InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**服务端**\r\n\r\n![](./images/java学习笔记/2022-11-04-00-59-07.png)\r\n\r\n**客户端1**\r\n\r\n![](./images/java学习笔记/2022-11-04-00-59-38.png)\r\n\r\n**客户端2**\r\n\r\n![](./images/java学习笔记/2022-11-04-00-59-49.png)\r\n\r\n### TCP通信测试：服务端通过线程池服务多个客户端\r\n`Server.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.BlockingQueue;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Server {\r\n    public static void main(String[] args) {\r\n        try {\r\n            ServerSocket server = new ServerSocket(8888);\r\n            ThreadPoolExecutor Pool = new ThreadPoolExecutor(//创建线程池\r\n                10, 20,//核心线程数，最大线程数量\r\n                 10, TimeUnit.SECONDS,//空闲时间\r\n                 new ArrayBlockingQueue<>(20),//任务队列大小\r\n                 new ThreadPoolExecutor.AbortPolicy()//任务队列满后又有新任务时的策略\r\n                 );\r\n            System.out.println(\"服务端启动了\");\r\n            while (true) {\r\n                Socket socket = server.accept();//获取到一个链接就创建一个子线程来处理\r\n                System.out.println(\"新连接已建立...\\n交由线程池处理...\");\r\n\r\n                //把任务交给线程池\r\n                Pool.execute(()->{\r\n                    try {\r\n                        OutputStream os = socket.getOutputStream();\r\n                        InputStream is = socket.getInputStream();\r\n\r\n                        BufferedReader request_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                        BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                        String message_req;\r\n                        while ((message_req = request_Reader.readLine()) != null) {\r\n                            System.out.println(\"服务端收到客户端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n\r\n                            reponse_Writer.write(\"你发来的数据是：\" + message_req);// 响应\r\n                            reponse_Writer.newLine();\r\n                            reponse_Writer.flush();\r\n                            if(message_req.equals(\"exit\")){\r\n                                reponse_Writer.write(message_req);// 响应\r\n                                reponse_Writer.newLine();\r\n                                reponse_Writer.flush();\r\n                                break;\r\n                            }\r\n                        }\r\n                        System.out.println(\"线程资源被释放...\");\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                });\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`Client.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.Socket;\r\nimport java.time.LocalDateTime;\r\nimport java.util.Scanner;\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        try {\r\n            Thread.sleep(1000);\r\n            System.out.println(\"客户端启动\");\r\n\r\n            Socket socket = new Socket(\"127.0.0.1\", 8888);\r\n\r\n            OutputStream os = socket.getOutputStream();\r\n            InputStream is = socket.getInputStream();\r\n\r\n            BufferedReader rsponse_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n            BufferedWriter request_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n            new Thread(()->{//获取服务端的响应\r\n                try {\r\n                    String message_req;\r\n                    while ((message_req = rsponse_Reader.readLine()) != null) {\r\n                        System.out.println(\"\\t客户端收到服务端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n                        if(message_req.equals(\"exit\"))\r\n                            break;\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n\r\n            while(true){\r\n                System.out.println(\"请输入要发送的数据：\");\r\n                String messageString = sc.nextLine();\r\n                request_Writer.write( messageString );//请求\r\n                request_Writer.newLine();\r\n                request_Writer.flush();\r\n                if(messageString.equals(\"exit\"))\r\n                    break;\r\n            }\r\n\r\n        } catch (IOException | InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-04-02-03-14.png)\r\n\r\n![](./images/java学习笔记/2022-11-04-02-03-34.png)\r\n\r\n![](./images/java学习笔记/2022-11-04-02-04-00.png)\r\n\r\n\r\n### TCP通信测试：实现简易群聊\r\n\r\n`Server.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.BlockingQueue;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Server {\r\n    public static Set<Socket> ALL_ONLINE_USERS = new HashSet<>();\r\n    public static void main(String[] args) {\r\n        try {\r\n            ServerSocket server = new ServerSocket(8888);\r\n            ThreadPoolExecutor Pool = new ThreadPoolExecutor(//创建线程池\r\n                10, 20,//核心线程数，最大线程数量\r\n                 10, TimeUnit.SECONDS,//空闲时间\r\n                 new ArrayBlockingQueue<>(20),//任务队列大小\r\n                 new ThreadPoolExecutor.AbortPolicy()//任务队列满后又有新任务时的策略\r\n                 );\r\n            System.out.println(\"服务端启动了\");\r\n            while (true) {\r\n                Socket socket = server.accept();//获取到一个链接就创建一个子线程来处理\r\n                System.out.println(\"新连接已建立...\\n交由线程池处理...\");\r\n                \r\n                //把任务交给线程池执行\r\n                Pool.execute(()->{\r\n                    try {\r\n                        ALL_ONLINE_USERS.add(socket);//保存线程\r\n                        OutputStream os = socket.getOutputStream();\r\n                        InputStream is = socket.getInputStream();\r\n\r\n                        BufferedReader request_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                        BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                        String message_req;\r\n                        while ((message_req = request_Reader.readLine()) != null) {\r\n                            System.out.println(\"收到客户端的消息：\"+ message_req);\r\n                            if(message_req.equals(\"exit\")){\r\n                                ALL_ONLINE_USERS.remove(socket);//移除socket\r\n                                socket.close();//关闭连接\r\n                                System.out.println(\"线程资源被释放...\");\r\n                                break;\r\n                            }\r\n                            \r\n                            reponse_Writer.write(\"已收到你的消息，开始群发\");\r\n                            reponse_Writer.newLine();\r\n                            reponse_Writer.flush();\r\n                            sendMsgToAll(message_req);\r\n                            \r\n                        }\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                });\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public static void sendMsgToAll(String msg) throws Exception{\r\n        for(Socket socket:ALL_ONLINE_USERS){\r\n            BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), \"UTF-8\"));\r\n            reponse_Writer.write(msg);\r\n            reponse_Writer.newLine();\r\n            reponse_Writer.flush();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`Client.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.Socket;\r\nimport java.time.LocalDateTime;\r\nimport java.util.Scanner;\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        try {\r\n            Thread.sleep(1000);\r\n            System.out.println(\"客户端启动\");\r\n\r\n            Socket socket = new Socket(\"127.0.0.1\", 8888);\r\n\r\n            OutputStream os = socket.getOutputStream();\r\n            InputStream is = socket.getInputStream();\r\n\r\n            BufferedReader rsponse_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n            BufferedWriter request_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n            new Thread(()->{//获取服务端的响应\r\n                try {\r\n                    String message_req;\r\n                    while ((message_req = rsponse_Reader.readLine()) != null) {\r\n                        System.out.println(\"\\t客户端收到服务端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n                    }\r\n                } catch (IOException e) {\r\n                    System.out.println(\"你已退出群聊。\");\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n\r\n            while(true){\r\n                System.out.println(\"请输入要群发的数据：\");\r\n                String messageString = sc.nextLine();\r\n                request_Writer.write( messageString );//请求\r\n                request_Writer.newLine();\r\n                request_Writer.flush();\r\n                if(messageString.equals(\"exit\"))\r\n                    break;\r\n            }\r\n\r\n        } catch (IOException | InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**服务端**\r\n\r\n![](./images/java学习笔记/2022-11-04-02-44-38.png)\r\n\r\n**客户端1**\r\n\r\n![](./images/java学习笔记/2022-11-04-02-44-52.png)\r\n\r\n**客户端2**\r\n\r\n![](./images/java学习笔记/2022-11-04-02-45-03.png)\r\n\r\n**客户端3**\r\n\r\n![](./images/java学习笔记/2022-11-04-02-45-18.png)\r\n\r\n### TCP通信测试：简易BS架构原理测试\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Server {\r\n    public static Set<Socket> ALL_ONLINE_USERS = new HashSet<>();\r\n    public static void main(String[] args) {\r\n        try {\r\n            ServerSocket server = new ServerSocket(8888);\r\n            ThreadPoolExecutor Pool = new ThreadPoolExecutor(10, 20,10, TimeUnit.SECONDS,new ArrayBlockingQueue<>(20),new ThreadPoolExecutor.AbortPolicy());\r\n            System.out.println(\"服务端启动了......\");\r\n            while (true) {\r\n                Socket socket = server.accept();//获取到一个链接就创建一个子线程来处理\r\n                System.out.println(\"新连接已建立...\\n交由线程池处理...\");\r\n                Pool.execute(socketHandle(socket));//把任务交给线程池执行\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public static Runnable socketHandle(Socket socket){\r\n        return ()->{\r\n            try{\r\n                BufferedReader request_Reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\r\n                BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), \"UTF-8\"));\r\n\r\n                reponse_Writer.write(\"HTTP/1.1 200 OK\");\r\n                reponse_Writer.newLine();//换行\r\n                reponse_Writer.write(\"Content-Type:text/html;charset=UTF-8\");\r\n                reponse_Writer.newLine();//换行\r\n                reponse_Writer.newLine();//空行\r\n\r\n                reponse_Writer.write(\"<h1>Hello B/S </h1>\");\r\n                reponse_Writer.newLine();//换行\r\n\r\n                reponse_Writer.flush();//发送\r\n                reponse_Writer.close();//关闭\r\n                socket.close();//关闭连接\r\n                System.out.println(\"执行完毕，线程释放\");\r\n            }catch(Exception e){\r\n            }\r\n        };\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-04-03-17-53.png)\r\n\r\n\r\n## 单元测试：Junit单元测试框架\r\n* Java程序的最小单元是函数，单元测试就是测试这些函数\r\n* Junit单元测试框架是开源框架，用java编写的\r\n\r\n测试案例\r\n\r\n`FunctionA.java`\r\n```java\r\npackage functiona;\r\n\r\npublic class FunctionA {\r\n    public String getUserNameById(int userId){\r\n        if(userId==0)\r\n            return \"admin\";\r\n        else\r\n        return \"DingYigui\";\r\n    }\r\n    public int devide(int a,int b){\r\n        return a/b;\r\n    }\r\n}\r\n```\r\n\r\n`TestFunctionA.java`\r\n```java\r\npackage functiona;\r\n\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n\r\npublic class TestFunctionA{\r\n    // 测试方法必须是public void\r\n    // 测试方法必须导入Test，然后用@Test修饰,表示这是一个测试方法\r\n\r\n    @Test \r\n    public void testGetUserNameById(){\r\n        FunctionA funA = new FunctionA();\r\n        Assert.assertEquals(\"admin\", funA.getUserNameById(0));\r\n        Assert.assertEquals(\"DingYigui\", funA.getUserNameById(1));\r\n    }\r\n\r\n    @Test\r\n    public void testDevide(){\r\n        FunctionA funA = new FunctionA();\r\n        Assert.assertEquals(5, funA.devide(10,2));\r\n        Assert.assertEquals(0, funA.devide(1,0));//异常\r\n    }\r\n}\r\n```\r\n\r\n**测试效果**\r\n![](./images/java学习笔记/2022-11-04-04-07-47.png)\r\n\r\n**Junit常用注解Uunit 4.xxxx版本)**\r\n| 注解         | 说明                                                         |\r\n| ------------ | ------------------------------------------------------------ |\r\n| @Test        | 测试方法                                                     |\r\n| @Before      | 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。 |\r\n| @After       | 用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。 |\r\n| @BeforeClass | 用来静态修饰方法，该方法会在所有测试方法之前只执行一次。     |\r\n| @AfterClass  | 用来静态修饰方法，该方法会在所有测试方法之后只执行一次。     |\r\n\r\n\r\n**Junit常用注解Uunit 5.xxxx版本)**\r\n| 注解        | 说明                                                          |\r\n| ----------- | ------------------------------------------------------------- |\r\n| @Test       | 测试方法                                                      |\r\n| @BeforeEach | 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。  |\r\n| @AfterEach  | 用来修饰实例方法，该方法会在每一一个测试方法执行之后执行 次。 |\r\n| @BeforeAll  | 用来静态修饰方法，该方法会在所有测试方法之前只执行一次。      |\r\n| @AfterAll   | 用来静态修饰方法，该方法会在所有测试方法之后只执行一次。      |\r\n\r\n## 反射\r\n通过反射可以在程序的运行的过程中,通过类的Class字节码文件对象，获取到一个类的全部**属性Field**、**构造器Constructor**、**方法Method**的对象，无论是私有的还是公开的。\r\n\r\n通过反射可以获取任意一个实例对象的所有属性，所有方法，所有构造函数，并且可以查看、设置、调用他们，无论他们是否是私有的。\r\n\r\n反射的最主要应用是做企业通用框架\r\n\r\n### 获取Class对象\r\n**获取Class对象的三种方式**\r\n* 通过 `Class类` 的`forName()方法`,`形参className`填 `包名.类名`\r\n  * tips: `Class.forName(\"xx.xxx.xxx\")`的另一个作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。\r\n* 通过 `Student抽象类` 的 `Class属性 `获取\r\n* 通过 `Student实例对象` 的 `getClass方法` 获取\r\n\r\n```java\r\nimport java.lang.Class;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //获取Class对象的三种方式\r\n        Class class1 = Class.forName(\"Student\");//1.通过 Class类 的forName()方法,形参className填 包名.类名\r\n        Class class2 = Student.class;//通过 Student抽象类 的Class属性获取\r\n        Class class3 = new Student().getClass();//通过 Student实例对象 的getClass方法\r\n        System.out.println(class1);\r\n        System.out.println(class2);\r\n        System.out.println(class3);\r\n    }\r\n}\r\nclass Student{\r\n    String name;\r\n    int age;\r\n    char sex;\r\n}\r\n\r\n```\r\n\r\n### 获取Class对象的构造器函数\r\n| 方法                                                                | 说明                                         |\r\n| ------------------------------------------------------------------- | -------------------------------------------- |\r\n| Constructor<?>[] getConstructors( )                                 | 返回**所有**构造器对象的数组(只能拿public的) |\r\n| Constructor<?>[] getDeclaredConstructors()                          | 返回**所有**构造器对象的数组(能拿私有的)     |\r\n| `Constructor<T> getConstructor(Class<?>... parameterTypes)`         | 返回单个构造器对象(只能拿public的)           |\r\n| `Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)` | 返回单个构造器对象(能拿私有的)               |\r\n\r\n\r\n**测试**\r\n```java\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Constructor;\r\nimport java.util.Arrays;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Class class1 = Student.class;//通过 Student抽象类 的Class属性获取\r\n\r\n        //获取所有公开的构造函数\r\n        Constructor[] constructors1 =  class1.getConstructors();\r\n        System.out.println(Arrays.toString(constructors1));\r\n        // 输出：   [public Student(java.lang.String,int,char)]\r\n\r\n        //获取所有构造函数（包括私有）\r\n        Constructor[] constructors2 =  class1.getDeclaredConstructors();\r\n        System.out.println(Arrays.toString(constructors2));\r\n        //输出：    [private Student(java.lang.String,int), public Student(java.lang.String,int,char)]\r\n\r\n        //根据形式参数类型获取单个公开的构造函数\r\n        Constructor constructor1 = class1.getConstructor(String.class,int.class,char.class);//形式参数必须完全匹配\r\n        System.out.println(constructor1);\r\n        //输出：    public Student(java.lang.String,int,char)\r\n\r\n        //根据形式参数类型获取单个构造函数（包括私有）\r\n        Constructor constructor2 = class1.getDeclaredConstructor(String.class,int.class);//形式参数必须完全匹配\r\n        System.out.println(constructor2);\r\n        //输出：    private Student(java.lang.String,int)\r\n    }\r\n}\r\nclass Student{\r\n    String name;\r\n    int age;\r\n    char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-08-22-09.png)\r\n\r\n### 使用获取到的构造函数创建对象\r\n\r\n**Constructor实例对象的用于创建对象的方法**\r\n| 符号                                    | 说明                                           |\r\n| --------------------------------------- | ---------------------------------------------- |\r\n| T newInstance(Object... initargs)       | 根据指定的构造器创建对象                       |\r\n| public void setAccessible(boolean flag) | 设置为true,表示取消访问检查进行暴力反射,也就是 |\r\n\r\n**测试**\r\n```java\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Constructor;\r\nimport java.util.Arrays;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //通过 Student抽象类 的Class属性获取\r\n        Class class1 = Student.class;\r\n\r\n        //根据形式参数类型获取单个构造函数（包括私有）\r\n        Constructor constructor = class1.getDeclaredConstructor(String.class,int.class,char.class);//形式参数必须完全匹配\r\n        constructor.setAccessible(true);//设置允许强制访问私有构造器\r\n        Student student = (Student) constructor.newInstance(\"DYG\",20,'男');\r\n        System.out.println(student);// 输出 Student [name=DYG, age=20, sex=男]\r\n    }\r\n}\r\nclass Student{\r\n    String name;\r\n    int age;\r\n    char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Student [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-08-40-03.png)\r\n\r\n### 获取Class类的属性对象\r\n\r\n| 函数名                              | 描述                                       |\r\n| ----------------------------------- | ------------------------------------------ |\r\n| Field[] getFields()                 | 返回所有成员变量对象的数组(只能拿public的) |\r\n| Field[ getDeclaredFields()          | 返回所有成员变量对象的数组，存在就能拿到   |\r\n| Field getField(String name)         | 返回单个成员变量对象(只能拿public的)       |\r\n| Field getDeclaredField(String name) | 返回单个成员变量对象，存在就能拿到         |\r\n\r\n```java\r\nimport java.io.ObjectInputStream.GetField;\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Arrays;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //通过 Student抽象类 的Class属性获取\r\n        Class class1 = Student.class;\r\n\r\n        Field[] stu_Fields = class1.getFields();\r\n        Field[] stu_Fields_all = class1.getDeclaredFields();\r\n\r\n        System.out.println(Arrays.toString(stu_Fields));        // [public java.lang.String Student.name]\r\n        System.out.println(Arrays.toString(stu_Fields_all));    // [public java.lang.String Student.name, int Student.age, char Student.sex]\r\n\r\n        Field student_namField =  class1.getField(\"name\");          \r\n        Field student_ageField =  class1.getDeclaredField(\"age\");   \r\n\r\n        System.out.println(student_namField);   //public java.lang.String Student.name\r\n        System.out.println(student_ageField);   //int Student.age\r\n\r\n    }\r\n}\r\nclass Student{\r\n    public String name;\r\n    int age;\r\n    char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Student [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n### 使用获取到的属性对象修改实例对象的属性值\r\n\r\n```java\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Field;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //通过 Student抽象类 的Class属性获取\r\n        Class class1 = Student.class;\r\n\r\n        Student student =new Student(\"DYG\",20,'男');\r\n        System.out.println(student);// 输出 Student [name=DYG, age=20, sex=男]\r\n\r\n        Field student_namField =  class1.getField(\"name\");\r\n        Field student_ageField =  class1.getDeclaredField(\"age\");\r\n        Field student_sexField =  class1.getDeclaredField(\"sex\");\r\n        \r\n        System.out.println((String)student_namField.get(student));// DYG\r\n        System.out.println((int)student_ageField.get(student));//20\r\n        student_sexField.setAccessible(true);//允许强制访问\r\n        System.out.println((char)student_sexField.get(student));//'男'\r\n\r\n        student_namField.set(student, \"DingYigui\");\r\n        student_ageField.set(student, 20);\r\n        student_sexField.setAccessible(true);//允许强制访问\r\n        student_sexField.set(student, '女');\r\n\r\n        System.out.println(student);// Student [name=DingYigui, age=20, sex=女]\r\n    }\r\n}\r\n\r\nclass Student{\r\n    public String name;\r\n    int age;\r\n    private char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Student [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-10-02-45.png)\r\n\r\n### 获取Class类的方法\r\n\r\n| 方法                                                              | 说明                                       |\r\n| ----------------------------------------------------------------- | ------------------------------------------ |\r\n| Method[] getMethods()                                             | 返回所有成员方法对象的数组(只能拿public的) |\r\n| Method[] getDeclaredMethods()                                     | 返回所有成员方法对象的数组，存在就能拿到   |\r\n| Method getMethod(String name, Class<?>... parameterTypes )        | 返回单个成员方法对象(只能拿public的)       |\r\n| Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到         |\r\n\r\n\r\n### 通过获取到的类的方法来执行实例对象的方法\r\n\r\n| 函数名                                    | 说明                         | 运行方法                                                                                                   |\r\n| ----------------------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------- |\r\n| object invoke(Object obj, object... args) | Method类中用于触发执行的方法 | 参数一:用obj对象调用该方法 参数二:调用方法的传递的参数(如果没有就不写) 返回值:方法的返回值(如果没有就不写) |\r\n\r\n\r\n```java\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Method;\r\nimport java.util.Arrays;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //通过 Student抽象类 的Class属性获取\r\n        Class class1 = Student.class;\r\n\r\n        Student student =new Student(\"DYG\",20,'男');\r\n        System.out.println(student);// 输出 Student [name=DYG, age=20, sex=男]\r\n\r\n        Method toStrMethod = class1.getMethod(\"toString\",null);\r\n        System.out.println(toStrMethod.getName());\r\n        System.out.println(toStrMethod.getReturnType());\r\n        System.out.println(Arrays.toString(toStrMethod.getParameterTypes()));\r\n        System.out.println(Arrays.toString(toStrMethod.getParameters()));\r\n\r\n        System.out.println( toStrMethod.invoke(student, null));// 输出 Student [name=DYG, age=20, sex=男]\r\n    }\r\n}\r\n\r\nclass Student{\r\n    public String name;\r\n    int age;\r\n    private char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Student [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n### 应用：存储任意对象的属性值到文件\r\n```java\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.PrintStream;\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.lang.reflect.Field;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        Student student =new Student(\"DYG\",20,'男',\"110\",\"银河系太阳系地球\");\r\n        saveObjAttrToFile(student,new File(\"./123.txt\"));\r\n    }\r\n    static void saveObjAttrToFile(Object obj,File file) throws UnsupportedEncodingException, FileNotFoundException, IllegalArgumentException, IllegalAccessException{\r\n        PrintStream ps = new PrintStream(new BufferedOutputStream(new FileOutputStream(file)),true,\"UTF-8\");\r\n        for(Field field:obj.getClass().getDeclaredFields())\r\n        {\r\n            field.setAccessible(true);\r\n            ps.println(field.getName() + \"=\" + field.get(obj).toString());\r\n            ps.flush();\r\n        }\r\n        ps.close();\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private String name;\r\n    private int age;\r\n    private char sex;\r\n    private String tel;\r\n    private String add;\r\n    public Student(String name, int age, char sex, String tel, String add) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n        this.tel = tel;\r\n        this.add = add;\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-10-36-20.png)\r\n\r\n\r\n## 注解\r\n* Java注解Annotation,也叫Java标注，\r\n* JDK5.0之后的标准\r\n* 类、构造器、属性、方法、成员变量、参数、都可以加注解\r\n* 作用：对标记的部分做特殊处理\r\n* 如：`@Override`标记的函数表示重写。编译阶段将检测是否正确重写\r\n\r\n### 自定义注解\r\n```java\r\npublic @interface 注解名称{\r\n    public 属性类型 属性名() default 默认值;\r\n}\r\n\r\n@注解名称(属性名1=123,属性名2=\"123\",属性名3={\"123\",\"123\"},属性名4={1,2,3})\r\n@注解名称(属性名=123)\r\n@注解名称(123)\r\npublic void main(){\r\n}\r\n```\r\n\r\n**使用测试**\r\n```java\r\npublic class Main {\r\n    @MyNote(tittle = \"测试0\")\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        @MyNote(tittle = \"输出\",context = \"测试输出语句\")\r\n        String str = \"12312\";\r\n        System.out.println(123213123);\r\n    }\r\n    @MyNote(tittle = \"测试1\")\r\n    public static void test(){\r\n\r\n    }\r\n}\r\n@interface MyNote{\r\n    public String tittle() default \"none\";\r\n    public String context() default \"none\";\r\n}\r\n```\r\n\r\n### 元注解\r\n元注解是注解的注解\r\n\r\n元注解有两：\r\n*` @Target` 约束自定义注解只能在哪些地方使用\r\n*` @Retention` 约束自定义注解的存活范围\r\n\r\n**写法**\r\n```java\r\n@Target\r\n@Target({ElementType.????,ElementType.????}) //Target使得MyNote只能注解什么类型\r\n@Retention(RetentionPolicy.????)//指定注解作用在什么阶段\r\npublic @interface 注解名称{\r\n    public 属性类型 属性名() default 默认值;\r\n}\r\n\r\n@Target({ElementType.METHOD,ElementType.FIELD}) //Target使得MyNote只能注解方法METHOD、成员属性FIELD\r\n@Retention(RetentionPolicy.RUNTIME)//指定注解作用在运行阶段\r\npublic @interface 注解名称{\r\n    public 属性类型 属性名() default 默认值;\r\n}\r\n```\r\n\r\n`@Target`中可使用的值定义在`ElementType枚举类`中，常用值如下\r\n* `TYPE`,类,接口\r\n* `FIELD`,成员变量\r\n* `METHOD`,成员方法\r\n* `PARAMETER`,方法参数\r\n* `CONSTRUCTOR`,构造器\r\n* `LOCAL_VARIABLE`,局部变量\r\n\r\n`@Retention`中可使用的值定义在`RetentionPolicy枚举类`中，常用值如下\r\n* `SOURCE` : 注解只作用在**源码阶段**，生成的字节码文件中不存在\r\n* `CLASS` : 注解作用在**源码阶段**，**字节码文件阶段**,运行阶段不存在，默认值.\r\n* `RUNTIME` : 注解作用在**源码阶段**,**字节码文件阶段**,**运行阶段**(开发常用)\r\n\r\n### 注解的解析\r\n注解的操作中经常需要进行解析，**注解的解析就是判断是否存在注解**，**存在注解就解析出内容**。\r\n\r\n**Annotation接口**\r\n* Annotation: 注解的顶级接口，\r\n* 注解都是Annotation类型的对象\r\n\r\n**AnnotatedElement接口**\r\n* 定义了与注解解析相关的**解析方法**\r\n\r\n**反射与注解**\r\n\r\n所有的**反射**的**类的成分** `Class`, `Method` , `Field` , `Constructor`, 都实现了`AnnotatedElement接口`他们都拥**有解析注解的能力**\r\n\r\n| 方法                                                               | 说明                                                                 |\r\n| ------------------------------------------------------------------ | -------------------------------------------------------------------- |\r\n| `Annotation[] getDeclaredAnnotations()`                            | 获得当前对象上使用的**所有注解**，返回注解数组。                     |\r\n| `T getDeclaredAnnotation(Class <T> annotationClass)`               | 根据**注解类型**获得对应注解对象                                     |\r\n| `boolean isAnnotationPresent(Class < Annotation> annotationClass)` | **判断**当前对象是否使用了指定的注解，如果使用了则返回true,否则false |\r\n  \r\n**解析类和方法上的注解测试**\r\n```java\r\nimport java.lang.annotation.Annotation;\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\nimport java.lang.reflect.Method;\r\nimport java.util.Arrays;\r\n\r\npublic class Main  {\r\n    static{\r\n        //解析类上的MyNote注解\r\n        Class stu = Student.class;\r\n        if (stu.isAnnotationPresent(MyNote.class)) {//判断是否存在指定注解\r\n            MyNote myNote = (MyNote) stu.getDeclaredAnnotation(MyNote.class);//获取指定注解\r\n            System.out.println(\"类上的注解属性: \" + myNote.tittle());\r\n            System.out.println(\"类上的注解属性: \" + myNote.context());\r\n        }\r\n\r\n        //解析方法上的MyNote注解\r\n        Method[] stuMethods = Student.class.getDeclaredMethods();//获取类的所有方法\r\n        for(Method sMethod:stuMethods){//遍历方法\r\n            if(sMethod.isAnnotationPresent(MyNote.class)){//判断是否存在指定注解\r\n                MyNote myNote = (MyNote) sMethod.getDeclaredAnnotation(MyNote.class);//获取指定注解\r\n                System.out.println(\"方法上的注解属性: \" + myNote.tittle());\r\n                System.out.println(\"方法上的注解属性: \" + myNote.context());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n    }\r\n\r\n}\r\n\r\n@Target({ElementType.TYPE,ElementType.METHOD}) //Target使得MyNote只能注解类和方法 \r\n@Retention(RetentionPolicy.RUNTIME)//指定注解作用在运行阶段\r\n@interface MyNote{\r\n    public String tittle() default \"none\";\r\n    public String context() default \"none\";\r\n}\r\n\r\n@MyNote(tittle = \"名称\",context = \"内容\")\r\nclass Student{\r\n    String name;\r\n    int age;\r\n    char sex;\r\n    String tel;\r\n\r\n    public Student(String name, int age, char sex, String tel) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n        this.tel = tel;\r\n    }\r\n\r\n    @MyNote(tittle = \"名称\",context = \"内容\")\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public char getSex() {\r\n        return sex;\r\n    }\r\n\r\n    public void setSex(char sex) {\r\n        this.sex = sex;\r\n    }\r\n\r\n    public String getTel() {\r\n        return tel;\r\n    }\r\n\r\n    public void setTel(String tel) {\r\n        this.tel = tel;\r\n    }\r\n    \r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-04-13-00-59.png)\r\n\r\n## 结合`反射`和`注解`实现简易`junit框架`\r\n```java\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\nimport java.lang.reflect.Method;\r\n\r\n\r\npublic class Test{\r\n\r\n    @MyTest\r\n    public void test1(){\r\n        System.out.println(\"测试代码块1\");\r\n    }\r\n\r\n    public void test2(){\r\n        System.out.println(\"测试代码块2\");\r\n    }\r\n\r\n    @MyTest\r\n    public void test3(){\r\n        System.out.println(\"测试代码块3\");\r\n    }\r\n\r\n    public void test4(){\r\n        System.out.println(\"测试代码块4\");\r\n    }\r\n\r\n    @MyTest\r\n    public void test5(){\r\n        System.out.println(\"测试代码块5\");\r\n        System.out.println(100/0);//计算除0\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception{\r\n        //解析方法上的MyNote注解\r\n        Method[] testMethods = Test.class.getMethods();//获取类的所有公开方法\r\n        for(Method testMethod:testMethods){//遍历方法\r\n            if(testMethod.isAnnotationPresent(MyTest.class)){//判断是否存在指定注解\r\n                try {\r\n                    testMethod.invoke(new Test(), (Object[])null);//执行方法\r\n                    System.out.println(testMethod.getName() + \"测试通过!!!\");\r\n                } catch (Exception e) {\r\n                    System.out.println(testMethod.getName() + \"捕获到下列异常,测试未通过!!!\");\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n@Target({ElementType.METHOD}) //使得 MyTest 只能注解方法 \r\n@Retention(RetentionPolicy.RUNTIME)//指定注解作用在运行阶段\r\n@interface MyTest{\r\n    \r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-13-32-58.png)\r\n\r\n## 对象的动态代理\r\n代理就是一个**对象**，用来为**被代理对象**的**行为**做一些辅助工作。\r\n\r\n**实现步骤**\r\n* 把要对外公开的功能**定义接口类**\r\n* 被代理对象要**实现接口**\r\n* 使用 `Proxy.newProxyInstance(被代理对象的加载器,要向外公开的接口,代理的处理函数)` 来获取代理对象的实例\r\n* 可以使用泛型或直接使用Object来作为返回值和形参列表使得代理支持任意类型的被代理对象\r\n\r\n**应用场景**\r\n\r\n![](./images/java学习笔记/2022-11-04-15-59-48.png)\r\n\r\n```java\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Programmer programmer = new Programmer(\"DYG\", 20, '男');//程序员\r\n        ProgrammerActions programmerActionsProxy = ProgrammerActionsProxy.getProxy(programmer);//程序员的行为的代理\r\n\r\n        System.out.println(\"我是需求方，我需要做一个项目...\");\r\n        String result = (String) programmerActionsProxy.coding();//调用代理的coding\r\n        System.out.println(\"我是需求方，我拿到了项目的源代码...:\" + result);\r\n    }\r\n}\r\ninterface ProgrammerActions{//Programmer程序员对象的行为\r\n    Object coding();//敲代码\r\n}\r\nclass Programmer implements ProgrammerActions{//Programmer程序员对象\r\n    String name;\r\n    int age;\r\n    char sex;\r\n    public Programmer(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public Object coding() {\r\n        System.out.println(\"我是程序员，我负责敲代码...\");\r\n        System.out.println(\"我是程序员，代码敲完了...\");\r\n        return \"{Hello,World}\";\r\n    }\r\n    private void eat() {//私有方法 吃饭\r\n        System.out.println(\"吃饭...\");        \r\n    }\r\n    private void sleep() {//私有方法 睡觉\r\n        System.out.println(\"睡觉...\");        \r\n    }\r\n}\r\nclass ProgrammerActionsProxy{//Programmer程序员行为的代理对象\r\n    public static ProgrammerActions getProxy(Programmer programmer){\r\n        return (ProgrammerActions) Proxy.newProxyInstance(//获取代理实例对象\r\n            programmer.getClass().getClassLoader(),//获取程序员对象的加载器\r\n            programmer.getClass().getInterfaces(),//获取程序员对象的行为的接口\r\n            new InvocationHandler() {//代理对程序员行为的处理函数\r\n                @Override\r\n                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                    System.out.println(\"我是代理，我负责接项目...\");//预处理\r\n                    Object result = method.invoke(programmer, args);//处理\r\n                    System.out.println(\"我是代理，我负责项目的交付...\");//收尾工作\r\n                    return result;//返回结果\r\n                }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n## XML\r\n\r\n### 概述\r\n* 纯文本，默认UTF-8\r\n* Extensiable Markup Language 可扩展标记语言\r\n* 是一种数据表示格式 可描述非常复杂的数据结构 常用于传输和存储数据 网络消息传输 配置文件\r\n\r\n**基本语法**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"   ?>\r\n<!-- 文档声明必须第一行 -->\r\n\r\n<root comment=\"必须包含一个根标签，有且只能有一个\" >\r\n\r\n    <!-- 这个是注释 -->\r\n    <important>version必须存在</important>\r\n\r\n    <name>标签必须成对出现</name>\r\n\r\n    <br>特殊标签可以不成对</br>\r\n    <br/>\r\n    <br/>\r\n\r\n    <attr id=\"标签中可有属性,属性值必须引号包裹\" name='男'>测试</attr>\r\n    \r\n    <test1>\r\n        <span> 特殊符号 </span>\r\n        <span> &lt; 小于</span>\r\n        <span> &gt;  大于</span>\r\n        <span> &amp; and号</span>\r\n        <span> &apos; 单引号</span>\r\n        <span> &quot; 双引号</span>\r\n    </test1>\r\n\r\n    <![CDATA[\r\n            特殊字符: > < & ' \"  \r\n    ]]>\r\n\r\n</root>\r\n```\r\n\r\n**DTD文档约束**\r\n* 可以约束XML的标签\r\n* 不能约束XML标签的内容\r\n\r\n```DTD\r\n<!ELEMENT 书架 (书+)>\r\n<!ELEMENT 书 (书名,作者,价格)>\r\n<!ELEMENT 书名 (#PCDATA)>\r\n<!ELEMENT 作者 (#PCDATA)>\r\n<!ELEMENT 价格 (#PCDATA)>\r\n```\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE 书架 SYSTEM \"test.dtd\"> <!-- 引入DTD约束文件 -->\r\n<书架>\r\n    <书>\r\n        <书名>123</书名>\r\n        <作者>123</作者>\r\n        <价格>不能约束数据类型</价格>\r\n    </书>\r\n    <书>\r\n        <书名>123</书名>\r\n        <作者>123</作者>\r\n        <价格>不能约束数据类型</价格>\r\n    </书>\r\n    <书>\r\n        <书名>123</书名>\r\n        <作者>123</作者>\r\n        <价格>不能约束数据类型</价格>\r\n    </书>\r\n    <书>\r\n        <书名>123</书名>\r\n        <作者>123</作者>\r\n        <价格>不能约束数据类型</价格>\r\n    </书>\r\n</书架>\r\n```\r\n\r\n**schema约束**\r\n* schema用来约束其他xml文件的数据类型\r\n* schema本身是一个xml文件,schema能被其他文件约束\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<书架 xmlns=\"http://www.itcast.cn\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"http://www.itcast.cn data.xsd\">\r\n    <!-- xmlns=\"http://www.itcast.cn\"  基本位置\r\n         xsi:schemaLocation=\"http://www.itcast.cn books02.xsd\" 具体的位置 -->\r\n    <书>\r\n        <书名>神雕侠侣</书名>\r\n        <作者>金庸</作者>\r\n        <售价>399.9</售价>\r\n    </书>\r\n    <书>\r\n        <书名>神雕侠侣</书名>\r\n        <作者>金庸</作者>\r\n        <售价>19.5</售价>\r\n    </书>\r\n\r\n</书架>\r\n```\r\n\r\n`data.xsd`\r\n```xsd\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<schema xmlns=\"http://www.w3.org/2001/XMLSchema\"\r\n        targetNamespace=\"http://www.itcast.cn\"\r\n        elementFormDefault=\"qualified\" >\r\n    <!-- targetNamespace:申明约束文档的地址（命名空间）-->\r\n    <element name='书架'>\r\n        <!-- 写子元素 -->\r\n        <complexType>\r\n            <!-- maxOccurs='unbounded': 书架下的子元素可以有任意多个！-->\r\n            <sequence maxOccurs='unbounded'>\r\n                <element name='书'>\r\n                    <!-- 写子元素 -->\r\n                    <complexType>\r\n                        <sequence>\r\n                            <element name='书名' type='string'/>\r\n                            <element name='作者' type='string'/>\r\n                            <element name='售价' type='double'/>\r\n                        </sequence>\r\n                    </complexType>\r\n                </element>\r\n            </sequence>\r\n        </complexType>\r\n    </element>\r\n</schema>\r\n```\r\n\r\n\r\n### 解析\r\n常见解析工具\r\n| 解析工具  | 描述                                                                                                                                                                           |\r\n| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| JAXP      | SUN公司提供的一套XML的解析的API                                                                                                                                                |\r\n| JDOM      | JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。                                                                              |\r\n| **dom4j** | 是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。 |\r\n| jsoup     | 功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便                                                                                                                         |\r\n\r\n**两种解析方式**\r\n* SAX解析 一行一行解析\r\n* DOM解析 整个文件读入内存解析\r\n\r\n![](./images/java学习笔记/2022-11-04-19-10-54.png)\r\n\r\n\r\n\r\n#### Dom4J\r\n\r\n![](./images/java学习笔记/2022-11-04-19-38-23.png)\r\n![](./images/java学习笔记/2022-11-04-19-39-41.png)\r\n**dom4j解析xml文档**\r\n\r\n```java\r\nimport java.io.InputStream;\r\nimport org.dom4j.Document;\r\nimport org.dom4j.Element;\r\nimport org.dom4j.io.SAXReader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args)throws Exception {\r\n        SAXReader saxReader = new SAXReader();\r\n        InputStream is = Main.class.getResourceAsStream(\"/test.xml\");//当前目录下搜索\r\n        Document document = saxReader.read(is);//读取文档\r\n\r\n        Element root = document.getRootElement();//获取根标签\r\n        System.out.println(root);\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-20-21-17.png)\r\n\r\n\r\n\r\n### 检索:xPath\r\n![](./images/java学习笔记/2022-11-04-19-56-34.png)\r\n![](./images/java学习笔记/2022-11-04-19-58-01.png)\r\n\r\n**xPath**\r\n* 检索XML文件中的信息\r\n* 绝对路径: `/根元素/子元素/孙元素`\r\n* 相对路径: `./子元素/孙元素`\r\n* 全文检索: `//contact`\r\n* 属性查找: `//@属性名`、`//元素[@属性名]`、`//元素//[@属性名='值']`\r\n\r\n**绝对路径检索**\r\n![](./images/java学习笔记/2022-11-04-20-22-47.png)\r\n\r\n**绝对路径检索**\r\n![](./images/java学习笔记/2022-11-04-20-23-34.png)\r\n\r\n**全文检索检索**\r\n\r\n![](./images/java学习笔记/2022-11-04-20-27-39.png)\r\n![](./images/java学习笔记/2022-11-04-20-24-39.png)\r\n\r\n**属性查找检索**\r\n![](./images/java学习笔记/2022-11-04-20-25-32.png)\r\n\r\n\r\n\r\n## 工厂设计模式\r\n**概念**\r\n* 工厂模式(Factory Pattern) 是Java中最常用的设计模式之一 ，这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。\r\n* 工厂的方法可以封装对象的创建细节，比如:为该对象进行加工和数据注入。\r\n* 可以实现类与类之间的解耦操作(核心思想)\r\n\r\n**工厂设计模式：封装对象的创建细节**\r\n```java\r\nimport java.util.Objects;\r\n\r\npublic class Main {\r\n    public static void main(String[] args)throws Exception {\r\n        Computer mac = ComputerFactory.gComputer(\"Mac\");\r\n        Computer huawei = ComputerFactory.gComputer(\"HuaWei\");\r\n    }\r\n}\r\n\r\nclass ComputerFactory{\r\n    public static Computer gComputer(String brand) {//工厂模式\r\n        if(Objects.equals(brand,\"Mac\")){\r\n            return new Mac(\"Mac\", 9000, 18, 40, 50);\r\n        }else\r\n        if(Objects.equals(brand,\"HuaWei\")){\r\n            return new Mac(\"HuaWei\", 5000, 20, 30, 45);\r\n        }\r\n        return null;\r\n    }\r\n}\r\nclass Computer{\r\n    String brand;//品牌\r\n    double price;//价格\r\n    int size;//尺寸\r\n    int length;//长度\r\n    int width;//宽度\r\n    public Computer(String brand, double price, int size, int length, int width) {\r\n        this.brand = brand;\r\n        this.price = price;\r\n        this.size = size;\r\n        this.length = length;\r\n        this.width = width;\r\n    }\r\n}\r\nclass Mac extends Computer{\r\n    public Mac(String brand, double price, int size, int length, int width){\r\n        super(brand,price,size,length,width);\r\n    }\r\n}\r\n\r\nclass HuaWei extends Computer{\r\n    public HuaWei(String brand, double price, int size, int length, int width){\r\n        super(brand,price,size,length,width);\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 装饰设计模式\r\n什么是装饰设计模式?\r\n* **创建一个新类**，**包装原始类**,从而在新类中提升原来类的功能。\r\n* 装饰模式指的是在**不改变原类的基础**.上,动态地扩展-个类的功能\r\n\r\n**装饰设计模式的作用**:\r\n* 装饰模式指的是在不改变原类的基础上,动态地扩展-个类的功能。\r\n> InputStream (抽象父类)\r\n> FileInputStream (实现子类，但读写性能较差)\r\n> BufferedInputStream (实现子类，装饰类，读写性能高)\r\n\r\n**创建步骤**\r\n* 定义父类。\r\n* 定义原始类,继承父类,定义功能。\r\n* 定义装饰类,继承父类,包装原始类,增强功能! !\r\n\r\n\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>"}