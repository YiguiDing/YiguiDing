{"shortInfo":{"title":"ES6-ES11新特性学习笔记","date":"2022-09-04T04:00:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["ES6","javaScript"],"hideAtIndex":true,"categories":"笔记","id":3683242962,"countWords":7032,"readSeconds":703.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# ES6-ES11新特性学习笔记\r\n## 目录\r\n- [ES6-ES11新特性学习笔记](#es6-es11新特性学习笔记)\r\n  - [目录](#目录)\r\n  - [概念](#概念)\r\n  - [ES6-let](#es6-let)\r\n  - [ES6-const](#es6-const)\r\n  - [ES6-解构赋值](#es6-解构赋值)\r\n  - [ES6-模板字符串](#es6-模板字符串)\r\n  - [ES6-简化对象写法](#es6-简化对象写法)\r\n  - [ES6-箭头函数](#es6-箭头函数)\r\n  - [ES6-函数形式参数初值](#es6-函数形式参数初值)\r\n  - [ES6-函数的rest剩余参数(...)](#es6-函数的rest剩余参数)\r\n  - [ES6-spread扩展运算符(...)](#es6-spread扩展运算符)\r\n  - [ES6-Symbol](#es6-symbol)\r\n  - [ES6-迭代器(Iterator)](#es6-迭代器iterator)\r\n  - [ES6-生成器](#es6-生成器)\r\n  - [ES6-Promise](#es6-promise)\r\n  - [ES6-Set集合](#es6-set集合)\r\n  - [ES6-Map](#es6-map)\r\n  - [ES6-Class](#es6-class)\r\n  - [ES6-新的数值方法](#es6-新的数值方法)\r\n  - [ES6-新的对象方法](#es6-新的对象方法)\r\n  - [ES6-模块化](#es6-模块化)\r\n  - [ES7-新运算符`**`](#es7-新运算符)\r\n  - [ES7-数组对象新方法`listA.includes()`](#es7-数组对象新方法listaincludes)\r\n  - [ES8-`async`/`await`](#es8-asyncawait)\r\n  - [ES8-`Obj.eys()`/`values()`/`entries()`](#es8-objeysvaluesentries)\r\n  - [ES9-针对于对象的`...`扩展运算符](#es9-针对于对象的扩展运算符)\r\n  - [ES9-正则-提取内容新方法](#es9-正则-提取内容新方法)\r\n  - [ES9-正则-反向断言](#es9-正则-反向断言)\r\n  - [ES9-正则-dotAll模式](#es9-正则-dotall模式)\r\n  - [ES10-二维数组或Map转对象](#es10-二维数组或map转对象)\r\n  - [ES10-trimStart,trimEnd](#es10-trimstarttrimend)\r\n  - [ES10-flat,flatMap](#es10-flatflatmap)\r\n  - [ES10-`Symbol.prototype.description`](#es10-symbolprototypedescription)\r\n  - [ES11-类的私有属性](#es11-类的私有属性)\r\n  - [ES11-Promise.allSettled()](#es11-promiseallsettled)\r\n  - [ES11-`String.prototype.matchAll()`](#es11-stringprototypematchall)\r\n  - [ES11-`?.`可选链操作符](#es11-可选链操作符)\r\n  - [ES11-动态`import()`](#es11-动态import)\r\n  - [ES11-BigInt大整型](#es11-bigint大整型)\r\n  - [ES11-globalThis](#es11-globalthis)\r\n\r\n\r\n## 概念\r\n**用处**\r\n* 语法简洁 功能丰富\r\n* `vue` `react` 框架开发中大量使用ES6语法\r\n* 岗位要求\r\n\r\n\r\n## ES6-let\r\n**声明格式**\r\n```js\r\nlet a;\r\nlet a,b,c;\r\nlet a=1,b=2,c=3;\r\n```\r\n**特性:**\r\n**1.块级作用域**\r\n```js\r\nvar a=1\r\n{//for if\r\n    let a=2;\r\n}\r\nconsole.log(a);// 输出1\r\n```\r\n\r\n**2. 不存在变量提升**\r\n```js\r\n//var\r\nconsole.log(a) //a为undefine\r\nvar a=123\r\n\r\n//let\r\nconsole.log(a) //报错:声明错误\r\nlet a=123\r\n```\r\n\r\n**3. 不影响作用域链**\r\n```js\r\n{\r\n    let a=1;\r\n    function(){\r\n        console.log(a) //能正常访问a\r\n    }\r\n}\r\n```\r\n\r\n**4. 不能重复声明**\r\n```js\r\nlet a=1;\r\nlet b=2;\r\n```\r\n\r\n**案例**\r\n```js\r\nfor(var i=0;i<10;i++)\r\n{\r\n    items[i].onclick = function(){\r\n        console.log(i)//i的值始终为10\r\n    }\r\n}\r\n\r\nfor(let i=0;i<10;i++)\r\n{\r\n    items[i].onclick = function(){\r\n        console.log(i)//i的值为其所在循环的值\r\n    }\r\n}\r\n```\r\n\r\n\r\n## ES6-const\r\n**声明格式**\r\n```js\r\nconst TEST = \"123\"\r\n```\r\n\r\n**注意事项**\r\n1. 必须赋初值\r\n2. 一般常量名大写\r\n3. 常量值不能修改,但能对数组的元素或对象的属性值修改,因为常量指向的地址没有发生改变\r\n4. 是块级作用于 \r\n\r\n\r\n## ES6-解构赋值\r\n**数组的解构赋值**\r\n```js\r\nvar test = [1,2,3,4]\r\nvar [a,b,c,d] = test\r\nconsole.log(a)\r\nconsole.log(b)\r\nconsole.log(c)\r\nconsole.log(d)\r\n```\r\n\r\n**对象的解构赋值**\r\n```js\r\nvar test = {a:1,b:2,c:3}\r\nvar {a,b,c} = test\r\n\r\nconsole.log(a)\r\nconsole.log(b)\r\nconsole.log(c)\r\n```\r\n\r\n\r\n## ES6-模板字符串\r\n**语法**\r\n```js\r\nvar test =`这是一个用反引号包裹的字符串`\r\n```\r\n\r\n**特性**\r\n1. 内容中可直接换行\r\n2. 内容中可直接拼接变量\r\n    ```js\r\n    var str = \"hhhhhhhhhhhhh\"\r\n    var test =`\r\n    <ul>\r\n        <li>12313123</li>\r\n        <li>12313123</li>\r\n        <li>12313123</li>\r\n        <li>${str}</li>\r\n    </ul>\r\n    `\r\n    ```\r\n\r\n## ES6-简化对象写法\r\n**语法**\r\n```js\r\nvar test1=1,test2=2,test3=3;\r\n\r\nvar obj1={\r\n    test1:test1,\r\n    test2:test2,\r\n    test3:test3,\r\n    test4:function(){\r\n        console.log(\"hhh\")\r\n    }\r\n}\r\n\r\nvar obj2 ={//obj1 和 obj2 写法等效\r\n    test1,\r\n    test2,\r\n    test3,\r\n    test4(){\r\n        console.log(\"hhh\")\r\n    }\r\n}\r\n```\r\n\r\n## ES6-箭头函数\r\n**语法**\r\n```js\r\nvar test1 = function(){\r\n    console.log(\"123\")\r\n}\r\n\r\nvar test2 = ()=>{ //test1 和 test2 等效\r\n    console.log(\"123\")\r\n}\r\n\r\n```\r\n\r\n\r\n**特性**\r\n1. this是静态的，始终指向函数声明时所在作用域的this的值\r\n2. 不能作为构造函数来示例化对象\r\n3. 箭头函数内不能使用arguments变量\r\n4. 当形式参数只有一个时可以省略小括号\r\n5. 当代码体只有一条语句时可省略大括号，函数的返回值为语句v的返回值，且return也必须省略。\r\n   ```js\r\n   let pow = x => x*x\r\n   console.log(pow(2)) //4\r\n   ```\r\n\r\n**案例1**\r\n```js\r\nad.addEventListener(\"click\",function(){\r\n    //由于this指向window，将报错\r\n    // setTimeout(function(){\r\n    //     this.style.background = \"pink\" \r\n    // },1000)\r\n\r\n    setTimeout(()=>{\r\n        this.style.background = \"pink\" //this指向ad 不报错\r\n    },1000)\r\n})\r\n```\r\n\r\n**案例2:筛选偶数**\r\n```js\r\n//不使用箭头函数\r\nconst arr =[1,2,3,4,5,6,7]\r\nconst result = arr.filter(function(item){\r\n    if(item%2==0) return true\r\n    else return false;\r\n})\r\nconsole.log(result)\r\n\r\n\r\n\r\n//使用箭头函数\r\nconst arr =[1,2,3,4,5,6,7]\r\nconst result = arr.filter(item => item%2==0 )\r\nconsole.log(result)\r\n```\r\n\r\n**总结**\r\n箭头函数适合与this无关的回调：定时器，数组的方法回调\r\n箭头函数不适合与this有关的回调：事件回调，对象方法\r\n\r\n\r\n## ES6-函数形式参数初值\r\n**语法**\r\n```js\r\nfunction add(a=0,b=0,c=0){\r\n    return a+b+c\r\n}\r\n```\r\n\r\n**特性**\r\n1. 有默认值的形式参数位置靠后\r\n2. 可以和结构赋值结合使用\r\n\r\n```js\r\nfunction connect({host=\"1270.0.0.1\",username=\"root\",password=\"root\",port=3394}){\r\n    console.log(host)\r\n    console.log(username)\r\n    console.log(password)\r\n    console.log(port)\r\n}\r\n\r\nconnect({\r\n    host: \"localhost\",\r\n    username: \"root\",\r\n    password: \"root\",\r\n    port: \"3394\",\r\n})\r\n```\r\n\r\n\r\n## ES6-函数的rest剩余参数(...)\r\n\r\n```js\r\nfunction f1(a,b,c){\r\n    console.log(arguments) //arguments是伪数组,存有所有参数\r\n}\r\nf1(1,2,3,4,5,6)\r\n\r\n\r\nvar f2 = (a,b,c,...rest)=>{//(rest可以是其他变量名)\r\n    console.log(rest) //rest 是真的数组，存有剩余的参数\r\n}\r\nf2(1,2,3,4,5,6)\r\n```\r\n\r\n\r\n## ES6-spread扩展运算符(...)\r\n扩展运算符(...)会调用默认的 `Iterator` 接口\r\n\r\n**基本使用**\r\n```js\r\nvar list = [\"123\",\"321\",\"456\"]\r\n\r\nfun1(list) //等效于 fun1([\"123\",\"321\",\"456\"])\r\n\r\nfun2(...list) //等效于 fun2(\"123\",\"321\",\"456\")\r\n```\r\n\r\n**应用**\r\n1. 数组合并\r\n   ```js\r\n   const a=[1,2,3]\r\n   const b=[4,5,6]\r\n   const c=[...a,...b] //c:[1,2,3,4,5,6]\r\n   ```\r\n2. 数组拷贝\r\n   ```js\r\n   const a=[\"A\",\"B\",\"C\"]\r\n   const b=[...a]           //浅拷贝\r\n   ```\r\n\r\n3. 伪数组转换真数组\r\n   ```js\r\n   const divs = document.querrySelectorAll(\"div\")\r\n   const divArr = [...divs]\r\n   ```\r\n\r\n\r\n## ES6-Symbol\r\n**概念**\r\n* Symbol是ES6引入的新的数据类型,不能用 new 命令，因为其不是对象。\r\n* 表示独一无二的值,最大的用法是用来定义对象的唯一属性名\r\n* ES6 数据类型\r\n  * Number  \r\n  * String  \r\n  * Boolean  \r\n  * Object \r\n  * null \r\n  * undefined \r\n  * **Symbol**\r\n\r\n**特点**\r\n* 值唯一,用于解决命名冲突的问题\r\n* 不能与其他数据类型运算\r\n* 不能使用for in 遍历,但可以使用Reflect.ownkeys获取对象的所有键名\r\n\r\n**一些内置属性(共11个)**\r\n* Symbol.match\r\n* Symbol.isConcatSpreadable\r\n\r\n```js\r\nlet s1 = Symbol();\r\nlet s2 = Symbol(\"标志名称\");\r\nlet s3 = Symbol(\"标志名称\");        // s2 !=  s3\r\n\r\nlet s4 = Symbol.for(\"标志名称2\")    // 由.for()这种函数创建的symbol称为函数对象\r\nlet s5 = Symbol.for(\"标志名称2\")    // s4 == s5\r\n```\r\n\r\n\r\n**案例1**\r\n```js\r\nconst game = {\r\n    up : function(){ console.log(\"up\") },\r\n    down : function(){ console.log(\"down\") }\r\n}\r\nconst myMethods = {\r\n    up:Symbol(\"myUp\"),\r\n    down:Symbol(\"myDown\")\r\n}\r\n\r\n\r\ngame[myMethods.up] = function(){ console.log(\"myUp\") }\r\ngame[myMethods.down] = function(){ console.log(\"myDown\") }\r\n\r\nconsole.log(game)\r\n// 输出:\r\n// {\r\n//   up: [Function: up],\r\n//   down: [Function: down],\r\n//   [Symbol(myUp)]: [Function],\r\n//   [Symbol(myDown)]: [Function]\r\n// }\r\n```\r\n\r\n**案例2**\r\n```js\r\nconst game = {\r\n    up : function(){ console.log(\"up\") },\r\n    down : function(){ console.log(\"down\") },\r\n    [Symbol(\"myUp\")]:function(){ console.log(\"myUp\") }, //这样定义后似乎无法调用\r\n    [Symbol(\"myDown\")]:function(){ console.log(\"myDown\") },\r\n}\r\nconsole.log(game)\r\n\r\n// > console.log(game)\r\n// 输出:\r\n// {\r\n//   up: [Function: up],\r\n//   down: [Function: down],\r\n//   [Symbol(myUp)]: [Function: [myUp]],\r\n//   [Symbol(myDown)]: [Function: [myDown]]\r\n// }\r\n```\r\n\r\n## ES6-迭代器(Iterator)\r\n**主要用于遍历元素,实现原理和python中的yield类似**\r\n* 可自定义遍历数据\r\n* 迭代器提供的接口可供 `for [item] of [obj]` 使用\r\n* 原生具备迭代器接口的数据类型\r\n  * Arrary\r\n  * Arguments\r\n  * Set\r\n  * Map\r\n  * String\r\n  * TypedArray\r\n  * NodeList\r\n\r\n```js\r\nvar listA = [\"111\",\"222\",\"333\"]\r\n\r\n\r\n// let iterator = listA[Symbol.iterator]();\r\n// console.log(iterator.next())// next第一次指向第一个元素,第二次调用指向第二个元素...\r\n\r\n\r\nfor(let item of listA){\r\n    console.log(item) \r\n    //输出结果为\r\n    // \"111\"\r\n    // \"222\"\r\n    // \"333\"\r\n}\r\n\r\nfor(let key of listA){\r\n    console.log(key) \r\n    //输出结果为\r\n    // 0\r\n    // 1\r\n    // 2\r\n}\r\n```\r\n\r\n**自定义遍历数据**\r\n```js\r\nvar classA = {\r\n    name: \"1234班\",\r\n    students: [\r\n        \"小明\",\r\n        \"小红\",\r\n        \"小黄\",\r\n        \"小蓝\",\r\n        \"小绿\",\r\n        \"小白\",\r\n    ],\r\n    [Symbol.iterator]: function () {//不能使用剪头函数,否则this指向window\r\n        let index = 0;\r\n        return {\r\n            next: () => {\r\n                if (index < this.students.length) {\r\n                    return { value: this.students[index++], done: false }\r\n                } else {\r\n                    return { value: undefined, done: true }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfor (item of classA) {\r\n    console.log(item)\r\n}\r\n```\r\n\r\n\r\n## ES6-生成器\r\n**主要用于异步编程**\r\n\r\n**特性演示**\r\n```js\r\nfunction * test1(){\r\n    for (let index = 0; index < 100; index++) {\r\n        if(index%2==1)\r\n            yield index;\r\n    }\r\n}\r\n// const iterator = test1()\r\n    //test1()返回值是一个生成器对象\r\n\r\n// console.log(iterator.next());\r\n    // 输出:\r\n    // {value:1,done:false}\r\n\r\n// console.log(iterator.next().value);\r\n    // 输出:\r\n    // 1\r\n\r\nfor (item of test1()) {\r\n    console.log(item) \r\n    //输出:\r\n    // 1\r\n    // 3\r\n    // 5\r\n    // ... ...\r\n}\r\n```\r\n\r\n\r\n**参数传递**\r\n```js\r\nfunction * test2(arg1){\r\n    console.log(arg1)\r\n\r\n    var result = yield \"1111\"; \r\n    console.log(result)\r\n    \r\n    var result = yield \"2222\";\r\n    console.log(result)\r\n\r\n    var result = yield \"3333\";\r\n    console.log(result)\r\n}\r\n\r\nconst iterator = test2(\"AAA\")\r\n\r\nconsole.log(iterator.next(\"BBB\").value); // \"BBB\"将不会输出\r\nconsole.log(iterator.next(\"CCC\").value); //next的形式参数会作为前一个yield语句的返回值\r\nconsole.log(iterator.next(\"DDD\").value); //\"DDD\"将会作为 yield \"1111\" 的返回值\r\n```\r\n\r\n\r\n**异步编程案例**\r\n```js\r\nfunction A(){\r\n    setTimeout(() => {\r\n        console.log(\"111\");\r\n        iterator.next()\r\n    }, 1000);\r\n}\r\nfunction B(){\r\n    setTimeout(() => {\r\n        console.log(\"222\");\r\n        iterator.next()\r\n    }, 1000);\r\n}\r\nfunction C(){\r\n    setTimeout(() => {\r\n        console.log(\"333\");\r\n        iterator.next()\r\n    }, 1000);\r\n}\r\nfunction * test3(){\r\n    yield A()\r\n    yield B()\r\n    yield C()\r\n}\r\n\r\nconst iterator = test3()\r\n\r\niterator.next()\r\n//输出:\r\n// 111\r\n// 222\r\n// 333\r\n```\r\n\r\n\r\n**实际案例模拟**\r\n```js\r\nfunction getUserInfo(){\r\n    setTimeout(() => {\r\n        let UserInfo = \"用户信息\"\r\n        console.log(\"成功获取: \"+UserInfo);\r\n        iterator.next(UserInfo)\r\n    }, 1000);\r\n}\r\nfunction getOrders(){\r\n    setTimeout(() => {\r\n        let ordersInfo = \"用户订单\"\r\n        console.log(\"成功获取: \"+ordersInfo);\r\n        iterator.next(ordersInfo)\r\n    }, 1000);\r\n}\r\nfunction getGoods(){\r\n    setTimeout(() => {\r\n        let goodsInfo = \"订单商品\"\r\n        console.log(\"成功获取: \"+goodsInfo);\r\n        iterator.next(goodsInfo)\r\n    }, 1000);\r\n}\r\nfunction * test4(){\r\n    let UserInfo = yield getUserInfo() //获取用户信息\r\n    let ordersInfo = yield getOrders(UserInfo) //根据用户信息获取订单信息\r\n    let goodsInfo = yield getGoods(ordersInfo) //根据订单信息获取商品信息\r\n}\r\n\r\nconst iterator = test4()\r\niterator.next()\r\n    // 输出结果:\r\n    // 成功获取: 用户信息\r\n    // 成功获取: 用户订单\r\n    // 成功获取: 订单商品\r\n```\r\n\r\n\r\n## ES6-Promise\r\n**详细笔记见《Promise学习笔记》**\r\n\r\n**基本使用**\r\n```js\r\nconst a = new Promise((resolve,reject)=>{\r\n    setTimeout(()=>{\r\n        var data = \"从服务器获取数据\" \r\n        resolve(data)\r\n    },1000)\r\n}) \r\n\r\na.then(value=>{\r\n    console.log(value)\r\n},reason=>{\r\n    console.log(reason)\r\n})\r\n```\r\n\r\n## ES6-Set集合\r\nSet类型类似于数组,但其成员的值是唯一的,不会有重复的属性值  \r\nSet类型支持扩展运算符`...`  \r\nSet类型实现了 `iterator` 接口,可以通过 `for(A of B){}` 遍历\r\n**内置方法和属性**\r\n* size\r\n* add()\r\n* delete()\r\n* has()\r\n* clear()\r\n\r\n```js\r\nlet setA = new Set()\r\nconsole.log(setA) //Set(0){}\r\n\r\n\r\n// let setB = new Set(可迭代的数据)\r\nlet setB = new Set([1,2,3,4,5,6,7,7,7,7,7,\"8\"])\r\nconsole.log(setB) //Set(8){1,2,3,4,5,6,7,\"8\"}\r\n\r\n\r\nconsole.log(setB.size) //集合元素个数\r\nsetB.add(\"9\") //新增元素\r\nsetB.delete(\"9\") //删除元素\r\nsetB.has(1) //检测元素\r\n// setB.clear() //清空集合元素\r\n\r\nfor(item of setB){\r\n    console.log(item)\r\n}\r\n```\r\n\r\n\r\n**实用案例**\r\n```js\r\n// 数组去重\r\nvar listA = [1,2,3,4,5,6,7,8,1,1,1,2,2,2,3,3,3,4,4,4,5]\r\nvar result1 = [...new Set(listA)]\r\nconsole.log(result1);\r\n\r\n\r\n//交集运算\r\nvar ListB = [1,2,3,4,5,6,6,6,6,6]\r\nvar ListC = [4,5,6,7,8,9,9,9,9,9]\r\nvar result2 = [...new Set(ListB)].filter(item => ( new Set(ListC) ).has(item))\r\nconsole.log(result2)\r\n\r\n\r\n//并集运算\r\nvar ListD = [1,2,3,4,5,6,6,6,6,6]\r\nvar ListE = [4,5,6,7,8,9,9,9,9,9]\r\nvar result3 = [...new Set([...ListD,...ListE])]\r\nconsole.log(result3)\r\n\r\n\r\n//差集 \r\nvar ListF = [1,2,3,4,5,6,6,6,6,6]\r\nvar ListE = [4,5,6,7,8,9,9,9,9,9]\r\nvar result4 = [...new Set(ListF)].filter(item => !( new Set(ListE) ).has(item)) //F和E的差集\r\nvar result5 = [...new Set(ListE)].filter(item => !( new Set(ListF) ).has(item)) //E和F的差集\r\nconsole.log(result4)\r\nconsole.log(result5)\r\n```\r\n\r\n\r\n## ES6-Map\r\nMap类型类似于对象,是键值对的集合,但其\"键\"不只是字符串,各种数据类型甚至是对象都能作为\"键\"  \r\nMap类型支持扩展运算符`...`   \r\nMap类型实现了 `iterator` 接口,可以通过 `for(A of B){}` 遍历\r\n**内置方法和属性**\r\n* size\r\n* set(key,value)\r\n* get(key)\r\n* delete(key)\r\n* has(key)\r\n* clear()\r\n* ......\r\n\r\n\r\n```js\r\n// let MapA = new Map([[A,B],[C,D],[E,F]])\r\nlet MapA = new Map()\r\nconsole.log(MapA.set(\"123\",321))\r\nconsole.log(MapA.get(\"123\"))\r\nconsole.log(MapA.has(\"123\"))\r\nconsole.log(MapA.delete(\"123\"))\r\nconsole.log(MapA.clear())\r\n```\r\n\r\n\r\n## ES6-Class\r\n\r\n通过ES6的class关键字可以定义对象,但其绝大部分功能都可通过ES5的语法实现(构造函数,this关键字),新写法只是让其看起来更像面向对象编程\r\n\r\n**基本用法**\r\n```js\r\nclass Cat {\r\n    constructor(name, sex) {\r\n        this.name = name\r\n        this.sex = sex\r\n    }\r\n    bark() {\r\n        console.log(\"喵喵喵\")\r\n    }\r\n}\r\n\r\nnew Cat(\"小黄猫\", \"公猫\").bark() //输出: 喵喵喵\r\nconsole.log(new Cat(\"小黄猫\", \"公猫\").sex) //输出5\r\n```\r\n\r\n\r\n**static静态属性和成员**\r\n```js\r\n// **ES5原版写法**\r\n\r\n//构造函数\r\nfunction Dog(name, sex) {\r\n    this.name = name\r\n    this.sex = sex\r\n}\r\n//为构造函数对象添加方法/属性(静态属性)\r\nDog.age = 1\r\nDog.bark = function () {\r\n    console.log(\"汪汪汪~~~\")\r\n}\r\n//为实例对象添加方法/属性\r\nDog.prototype.age = 5\r\nDog.prototype.bark = function () {\r\n    console.log(\"汪汪汪\")\r\n}\r\n\r\nnew Dog(\"小白狗\", \"公狗\").bark() //输出: 汪汪汪\r\nDog.bark() //输出: 汪汪汪~~~\r\nconsole.log(new Dog(\"小白狗\", \"公狗\").age) //输出5\r\nconsole.log(Dog.age)// 输出1\r\n```\r\n\r\n\r\n```js\r\n// **ES6新版写法写法**\r\nclass Cat {\r\n    static age = 1;\r\n    static bark = function () {\r\n        console.log(\"喵喵喵~~~\")\r\n    }\r\n    constructor(name, sex) {\r\n        this.name = name\r\n        this.sex = sex\r\n        this.age = 5;\r\n    }\r\n    bark() {\r\n        console.log(\"喵喵喵\")\r\n    }\r\n}\r\n\r\nnew Cat(\"小黄猫\", \"公猫\").bark() //输出: 喵喵喵\r\nconsole.log(new Cat(\"小黄猫\", \"公猫\").age) //输出5\r\nCat.bark() //输出: 喵喵喵~~~\r\nconsole.log(Cat.age) //输出1\r\n```\r\n\r\n\r\n**继承**\r\n\r\n```js\r\n// ES5特性的继承\r\nfunction Phone(brand, prise) {\r\n    this.brand = brand\r\n    this.prise = prise\r\n}\r\nPhone.prototype.tele = function () {//为实例化后的对象添加方法\r\n    console.log(\"call......\");\r\n}\r\n\r\n\r\nfunction SmartPhone(brand, prise, size, color) {\r\n    Phone.call(this, brand, prise) // 初始化父级对象\r\n    this.size = size\r\n    this.color = color\r\n}\r\n\r\n// 设置子级构造函数原型\r\nSmartPhone.prototype = new Phone //使得SmartPhone的实例对象拥有Phone实例对象上的属性和方法\r\nSmartPhone.prototype.constructor = SmartPhone //使得SmartPhone的实例对象的构造函数是SmartPhone() 而不是Phone()\r\n\r\nSmartPhone.prototype.playGame = function () {//为实例化后的对象添加方法\r\n    console.log(\"playGame......\")\r\n}\r\n\r\nvar huawei = new SmartPhone(\"华为\", 4799, \"12-inch\", \"黑色\")\r\nhuawei.tele()\r\nhuawei.playGame()\r\n```\r\n\r\n```js\r\n// ES6特性的继承\r\nclass Phone {\r\n    constructor(brand, prise) {\r\n        this.brand = brand\r\n        this.prise = prise\r\n    }\r\n    call() {\r\n        console.log(\"call......\");\r\n    }\r\n}\r\nclass SmartPhone extends Phone {\r\n    constructor(brand, prise, size, color) {\r\n        super(brand, prise)\r\n        this.size = size\r\n        this.color = color\r\n    }\r\n    playGame() {\r\n        console.log(\"playGame......\")\r\n    }\r\n}\r\n\r\n\r\nvar huawei = new SmartPhone(\"花为\", 4799, \"12-inch\", \"黑色\")\r\nhuawei.call()\r\nhuawei.playGame()\r\n```\r\n\r\n**重写父类方法**\r\n```js\r\n// ES6特性的继承\r\nclass Phone {\r\n    constructor(brand, prise) {\r\n        this.brand = brand\r\n        this.prise = prise\r\n    }\r\n    call() {\r\n        console.log(\"call......\");\r\n    }\r\n}\r\nclass SmartPhone extends Phone {\r\n    constructor(brand, prise, size, color) {\r\n        super(brand, prise)\r\n        this.size = size\r\n        this.color = color\r\n    }\r\n    playGame() {\r\n        console.log(\"playGame......\")\r\n    }\r\n    call() {\r\n        console.log(\"call2......\");//重写父类的方法\r\n    }\r\n}\r\n\r\nvar huawei = new SmartPhone(\"花为\", 4799, \"12-inch\", \"黑色\")\r\nhuawei.call()\r\nhuawei.playGame()\r\n```\r\n\r\n**get与set**\r\n```js\r\nclass Phone {\r\n    constructor(brand, prise) {\r\n        this.brand = brand\r\n        this.prise = prise\r\n    }\r\n    get value(){\r\n        console.log(\"获取了价格\")\r\n        return this.prise\r\n    }\r\n    set value(value){\r\n        console.log(\"设置了价格\")\r\n        this.prise = value\r\n    }\r\n}\r\n\r\nvar xiaomi = new Phone(\"xiaomi\",999)\r\nconsole.log(xiaomi.value);\r\nconsole.log(xiaomi.value=0.01);\r\n```\r\n\r\n\r\n## ES6-新的数值方法\r\n\r\n**`Number.EPSILON`浮点数最小精度**\r\n```js\r\nconsole.log(Number.EPSILON); //2.220446049250313e-16   2.22*10^(-16) 是js浮点数的最小精度单位 ,用于比较浮点数是否相等\r\n\r\nfunction equal(a,b){\r\n    return Math.abs(a-b) < Number.EPSILON\r\n}\r\n\r\nconsole.log(0.1+0.2); // 输出 0.30000000000000004\r\nconsole.log(0.1+0.2 == 0.3); // 输出 false\r\nconsole.log(equal(0.1+0.2 , 0.3)); // 输出 true\r\n```\r\n\r\n**二进制,八进制,十六进制**\r\n```js\r\nvar b = 0b1111\r\nvar o = 0o7777\r\nvar d = 999999\r\nvar x = 0xffff\r\n\r\nconsole.log(b); //输出: 15\r\nconsole.log(o); //输出: 4095\r\nconsole.log(d); //输出: 999999\r\nconsole.log(x); //输出: 65535\r\n```\r\n\r\n**判断有限数**\r\n```js\r\nconsole.log(Number.isFinite(1));        //输出: true\r\nconsole.log(Number.isFinite(1/0));      //输出: false\r\nconsole.log(Number.isFinite(Infinity)); //输出: false\r\n```\r\n\r\n**判断非数**\r\n```js\r\n//在es5中isNaN()是一个单独的函数,在ES6中将其作为了Number对象的方法\r\nconsole.log(Number.isNaN(123)); //输出: false\r\nconsole.log(Number.isNaN(NaN)); //输出: true\r\n```\r\n\r\n**判断整数**\r\n```js\r\nconsole.log(Number.isInteger(123)); //输出: true\r\nconsole.log(Number.isInteger(123.123)); //输出: false\r\n```\r\n\r\n**字符串转数字**\r\n```js\r\n//在ES6中将其作为了Number对象的方法,之前是一个单独的函数\r\nconsole.log(Number.parseFloat(\"3.1415元\")); //输出: 3.1415\r\nconsole.log(Number.parseInt(\"3.1415元\")); //输出: 3\r\n```\r\n\r\n**抹掉小数部分**\r\n```js\r\nconsole.log(Math.trunc(3.1415)); //输出: 3\r\n```\r\n\r\n\r\n**sign()函数**\r\n```js\r\nconsole.log(Math.sign(100));    //输出: 1\r\nconsole.log(Math.sign(0));      //输出: 0\r\nconsole.log(Math.sign(-100));   //输出: -1\r\n```\r\n\r\n## ES6-新的对象方法\r\n\r\n**`Object.is()`判断两个值是否完全相等**\r\n```js\r\n        console.log(Object.is(123,123));        //输出: true\r\n        console.log(Object.is(\"123\",\"123\"));    //输出: true\r\n        console.log(Object.is(NaN,NaN));        //输出: true\r\n        console.log(123 === 123);               //输出: true\r\n        console.log(\"123\" === \"123\");           //输出: true\r\n        console.log(NaN === NaN);               //输出: false\r\n```\r\n\r\n**`Object.assign(a,b)`合并对象**\r\n```js\r\nconst defaultConfg = {\r\n    host:\"localhost\",\r\n    port:80,\r\n    username:\"admin\",\r\n    password:\"admin\"\r\n}\r\nconst customConfg = {\r\n    port:8080,\r\n    username:\"dyg\",\r\n    password:\"123456\"\r\n}\r\n\r\nconst resultConfg = Object.assign(defaultConfg,customConfg)\r\nconsole.log(resultConfg);\r\n//输出:\r\n//{\r\n//     host:\"localhost\",\r\n//     port:8080,\r\n//     username:\"dyg\",\r\n//     password:\"123456\"\r\n// }\r\n```\r\n\r\n\r\n**获取/设置原型对象**\r\n```js\r\nconst objA = [\"123\",\"321\"]\r\nconst objB = [123,321]\r\nObject.setPrototypeOf(objA,objB) //也就是使得objA.__prpto___ 指向objB\r\nconsole.log(objA);\r\nconsole.log(Object.getPrototypeOf(objA));\r\n```\r\n\r\n\r\n\r\n## ES6-模块化\r\n**原先的社区版模块化规范**\r\n* commonJs规范标准 服务端标准 现实实现: nodejs Browserify \r\n* AMD规范标准 浏览器端标准 现实实现: requirejs \r\n* CMD规范标准 浏览器端标准 现实实现: seaJS \r\n\r\n**ES6模块化规范语法**\r\n* `export{XXX,XXX,XXX}` 导出模块接口\r\n* `import{XXX,XXX,XXX} from \"url\"` 导入模块接口,顺序无妨,名称需一致\r\n* `import{XXX as XXX} from \"url\"`   \r\n* `export default{XXX,XXX,XXX}` 向外暴露的成员，可以使用任意变量来接收,不需要`{}`。\r\n* `import AAA from \"url with default export\"` 导入\r\n\r\n**特点**\r\n* ES6 的模块**自动开启严格模式**，不管你有没有在模块头部加上 use strict;。\r\n* 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。\r\n\r\n**注意**\r\n要在nodejs中使用ES6模块化规范,要求在package.json中添加type:module\r\n\r\n**基本使用:导出**\r\n```js\r\n//第一种 按需导出\r\nexport var a = 123;\r\nexport function funA(){\r\n    console.log(\"111111111111111111111111\")\r\n}\r\n\r\n//第二种\r\nvar a = 123;\r\nfunction funA(){\r\n    console.log(\"111111111111111111111111\")\r\n}\r\nexport{a,funA}\r\n//或\r\nexport{abc:a,cde:funA}\r\n\r\n\r\n\r\n//第三种\r\nvar a = 123;\r\nfunction funA(){\r\n    console.log(\"111111111111111111111111\")\r\n}\r\nexport default{a,funA}\r\n```\r\n\r\n**基本使用:导入**\r\n```js\r\n//第一种 : 通用方式\r\nimport * as test1 from \"./_demo.js\" \r\n\r\n\r\n//第二种\r\nimport {a,funA} from \"./_demo.js\"  //名称需一致顺序无妨\r\nimport {a as a2,funA} from \"./_demo.js\"  //防止变量名冲突,使用as\r\n\r\n//第三种 : 导入默认赋值\r\nimport {default as temp1} from \"./_demo.js\"\r\n\r\n//第四种 : 导入默认赋值\r\nimport temp2 from \"./_demo.js\"\r\n\r\n//第五种 : 多种相结合\r\nimport temp2,{a as a2,funA} from \"./_demo.js\"\r\n```\r\n\r\n**注意**\r\n在script标签中写js代码，或者使用src引入js文件时，默认不能使用module形式，即不能使用import导入文件，\r\n需要再script标签上加上 `type=\"module\"`\r\n```html\r\n<script type=\"module\" src=\"./??\">\r\n</script>\r\n```\r\n\r\n\r\n## ES7-新运算符`**`\r\n```js\r\nconsole.log(2**10) //1024\r\n```\r\n\r\n## ES7-数组对象新方法`listA.includes()`\r\n```js\r\nvar listA = [\"AAA\",\"BBB\",\"CCC\"]\r\nconsole.log(listA.includes(\"CCC\"))  // true\r\n\r\n//旧版的判断元素是否存在\r\nvar listA = [\"AAA\",\"BBB\",\"CCC\"]\r\nconsole.log(listA.indexOf(\"CCC\"))  // 返回下标,若不存在则返回 -1 \r\n```\r\n\r\n## ES8-`async`/`await`\r\n* `async`修饰的函数的返回值为**promise对象**,promise对象的结果为函数`return`的值\r\n* `await`修饰一个promsie对象,\r\n\r\n\r\n\r\n\r\n**`async`修饰的函数**\r\n* 返回的是一个promise的对象\r\n* promise对象的值和状态\r\n  * 若函数直接return XXX; 则函数返回的promise对象的值为XXX,状态为成功 \r\n  * 若函数直接抛出错误; 则函数返回的promise对象的值为抛出的错误对象,状态为失败 \r\n  * 若函数return new Promise(???); 则函数返回的的promise对象的值和状态与return的promise状态一致\r\n```js\r\nasync function test() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            console.log(\"hhhhhhh\");\r\n            resolve(\"hhhhhhh\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nconsole.log(test());\r\n```\r\n\r\n**`await`修饰的语句**\r\n* `await` 必须写在 `async` 修饰的函数中,但 `async` 中不一定要包含 `await`\r\n* `await` 一般用于修饰一个promise对象 即 `await new Promise(略) `\r\n* `await`修饰的promise对象的状态为成功, 则表达式的值为promise对象的value值\r\n* `await`修饰的promise对象的状态为失败, 则表达式抛出错误,需 `try{}catch(err){}` 捕获\r\n\r\n\r\n```js\r\nasync function test1() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(\"111111\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function test2() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(\"222222\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function test3() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(\"333333\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function main() {\r\n    let a = await test1()\r\n    let b = await test2()\r\n    let c = await test3()\r\n    console.log(a+b+c); \r\n}\r\nmain()\r\n```\r\n\r\n**结合 `axios` `async` `awite`**\r\n```html\r\n<script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n<script>\r\n    async function main() {\r\n        let sentences = await axios.get(\"https://api.apiopen.top/api/sentences\")\r\n        console.log(sentences.data.result);\r\n    }\r\n    main()\r\n</script>\r\n```\r\n\r\n\r\n**执行顺序的问题**\r\n在async修饰的函数中,语句是在主线程中执行的,当遇到第一个await语句并执行完后,函数中的剩余语句将交给异步执行栈,而后函数将直接返回一个promsie对象,\r\n\r\n```js\r\nasync function test4() {\r\n    return new Promise((resolve, reject) => {\r\n        console.log(\"2222222222222222222222\");\r\n        setTimeout(() => {                          //该行代码将交由异步执行栈执行\r\n            console.log(\"4444444444444444444444\");\r\n            resolve(\"5555555555555555555555\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function main() {\r\n    console.log(\"1111111111111111111111\");\r\n    let d = await test4()                   //执行该行之后,后续代码交给异步执行栈执行,函数main直接return\r\n    console.log(d);\r\n}\r\n\r\nconsole.log(\"0000000000000000000000\");\r\nmain()\r\nconsole.log(\"3333333333333333333333\"); \r\n\r\n//输出结果\r\n//  0000000000000000000000\r\n//  1111111111111111111111\r\n//  2222222222222222222222\r\n//  3333333333333333333333\r\n//  4444444444444444444444\r\n//  5555555555555555555555\r\n```\r\n\r\n\r\n\r\n## ES8-`Obj.eys()`/`values()`/`entries()`\r\n* `Object.keys(testObj)` 获取所有键\r\n* `Object.values(testObj)` 获取所以值\r\n* `Object.entries(testObj)` 获取所有键值组成的列表\r\n* `Object.getOwnPropertyDescriptors(testObj)` 获取对象属性的描述对象\r\n```js\r\nlet testObj = {\r\n    key1: \"value1\",\r\n    key2: \"value2\",\r\n    key3: \"value3\",\r\n    key4: [1, 2, 3, 4, 5],\r\n}\r\n\r\nconsole.log(Object.keys(testObj));\r\n//输出: [key1,key2,key3,key4]\r\nconsole.log(Object.values(testObj));\r\n//输出: [value1,value2,value3,value4]\r\nconsole.log(Object.entries(testObj));\r\n/*\r\n    输出: \r\n    [\r\n        [\"key1\",\"value1\"],\r\n        [\"key2\",\"value2\"],\r\n        [\"key3\",\"value3\"],\r\n        [\"key4\",[1,2,3,4,5]]\r\n    ]\r\n*/\r\nconsole.log(Object.getOwnPropertyDescriptors(testObj));\r\n// 输出:\r\n// {\r\n//     \"key1\": {\r\n//         \"value\": \"value1\",\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     },\r\n//     \"key2\": {\r\n//         \"value\": \"value2\",\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     },\r\n//     \"key3\": {\r\n//         \"value\": \"value3\",\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     },\r\n//     \"key4\": {\r\n//         \"value\": [\r\n//             1,\r\n//             2,\r\n//             3,\r\n//             4,\r\n//             5\r\n//         ],\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     }\r\n// }\r\n```\r\n\r\n**结合map的应用**\r\n```js\r\nlet map = new Map(Object.entries(testObj))\r\nconsole.log(map);\r\n//  输出: Map(4) {'key1' => 'value1', 'key2' => 'value2', 'key3' => 'value3', 'key4' => Array(5)}\r\n```\r\n\r\n## ES9-针对于对象的`...`扩展运算符\r\nES6中的的扩展运算符是针对于数组的,ES9的新扩展运算是针对于对象的\r\n\r\n**用法**\r\n```js\r\n//用法1\r\nlet obj1 = {\r\n    key1: \"value1\",\r\n    key2: \"value2\",\r\n    key3: \"value3\",\r\n    key4: [1, 2, 3, 4, 5],\r\n}\r\nlet obj2 ={...obj1}\r\nconsole.log(obj2);\r\n\r\n\r\n```\r\n\r\n```js\r\n//用法2\r\nfunction test({host,port,...user}){\r\n    console.log(host);\r\n    console.log(port);\r\n    console.log(user);//剩余的属性都会成为user对象的属性\r\n    console.log(user.username);\r\n    console.log(user.password);\r\n}\r\ntest({\r\n    host:\"localhost\",\r\n    port:3306,\r\n    username:\"dyg\",\r\n    password:\"123456\",\r\n})\r\n```\r\n\r\n## ES9-正则-提取内容新方法\r\n**利用旧版标准提取字符串**\r\n```js\r\nlet str = `<a href=\"http://baidu.com\">百度</a>\"`\r\nconst reg = /<a href=\"(.*)\">(.*)<\\/a>/\r\nlet result = reg.exec(str)\r\nconsole.log(result);\r\n    //输出 :  ['<a href=\"http://baidu.com\">百度</a>', 'http://baidu.com', '百度']\r\nconsole.log(result[1]);\r\n    //输出 :  'http://baidu.com'\r\nconsole.log(result[2]);\r\n    //输出 :  '百度'\r\n```\r\n\r\n**利用新版标准提取字符串**\r\n```js\r\nlet str2 = `<a href=\"http://baidu.com\">百度</a>\"`\r\nconst reg2 = /<a href=\"(?<url>.*)\">(?<text>.*)<\\/a>/\r\nlet result2 = reg2.exec(str2)\r\nconsole.log(result2);\r\n    //输出 :  ['<a href=\"http://baidu.com\">百度</a>', 'http://baidu.com', '百度']\r\nconsole.log(result2.groups.url);\r\n    //输出 :  'http://baidu.com'\r\nconsole.log(result2.groups.text);\r\n    //输出 :  '百度'\r\n```\r\n\r\n## ES9-正则-反向断言\r\n```js\r\nlet str = `目标年新: 20W ¥`\r\n// 正向断言\r\nconst reg = /(?<salary>\\d+[a-zA-Z])(?= ¥)/   //提取出:[多个数字+单个字母+' ¥']中的[多个数字+单个字母]\r\nconst result = reg.exec(str)\r\nconsole.log(result.groups.salary); //输出20W\r\n\r\n\r\n//反向断言\r\nconst reg2 = /(?<=: )(?<salary>\\d+[a-zA-Z])/   //提取出:[': '+多个数字+单个字母]中的[多个数字+单个字母]\r\nconst result2 = reg2.exec(str)\r\nconsole.log(result2.groups  .salary); //输出20W\r\n```\r\n\r\n## ES9-正则-dotAll模式\r\n```js\r\n//dot . 元字符 除换行符以外的任意单个字符\r\n//在dotAll 模式 . 将能匹配任意字符包括换行符\r\n\r\n//目标提取出a和p标签的内容\r\nlet str = `\r\n    <ul>\r\n        <li>\r\n            <a>肖申克的救赎</a>\r\n            <p>上映时间:1994-09-10</p>\r\n        </li>\r\n        <li>\r\n            <a>阿甘正传</a>\r\n            <p>上映时间:1994-07-06</p>\r\n        </li>\r\n    </ul>\r\n`\r\n\r\nvar reg_old = /<a>([\\S\\s]*?)<\\/a>[\\S\\s]*?<p>([\\S\\s]*?)<\\/p>/g      // 旧版: `.`仅能匹配任意字符,不包括换行符号\r\nvar data_old = ''\r\nvar result_old = []\r\nwhile (data_old = reg_old.exec(str)) {\r\n    result_old.push([data_old[1], data_old[2],])\r\n}\r\nconsole.log(result_old);\r\n\r\nvar reg_new = /<a>(.*?)<\\/a>.*?<p>(.*?)<\\/p>/gs                    // 新版: `/s`表示是模式修正使得`.`能匹配任意字符,包括换行符号\r\nvar data_new = ''\r\nvar result_new = []\r\nwhile (data_new = reg_new.exec(str)) {\r\n    result_new.push([data_new[1], data_new[2],])\r\n}\r\nconsole.log(result_new);\r\n```\r\n**输出结果**\r\n![图 1](./images/ES6-ES11新特性学习笔记/48142215ed63936854349dcedf19d963bdd31d5ae2e161afac79037e51b07bd8.png)  \r\n\r\n## ES10-二维数组或Map转对象\r\n`Object.fromEntries()`二维数组或Map转对象,实际上是ES8中`Object.entries(testObj)`的**逆运算**\r\n```js\r\nvar result1 = Object.fromEntries([\r\n    [\"Name\", \"DYG\"],\r\n    [\"Age\", \"21\"],\r\n])\r\nconsole.log(result1);\r\n// 输出:\r\n// {Name: 'DYG', Age: '21'}\r\n\r\n\r\n\r\nvar result2 = Object.fromEntries(new Map([\r\n    [\"Name\", \"DYG\"],\r\n    [\"Age\", \"21\"],\r\n]))\r\nconsole.log(result2);\r\n    // 输出:\r\n    // {Name: 'DYG', Age: '21'}\r\n```\r\n\r\n\r\n## ES10-trimStart,trimEnd\r\n* `str.trimStart()` 清除字符串开头处空白\r\n* `str.trimEnd()` 清除字符串结束处空白\r\n```js\r\n        var str = \"   测试文字   \"\r\n        console.log(str.trim())         //ES5 中的方法,输出结果为 : \"测试文字\"\r\n        console.log(str.trimStart())    //ES10中的方法,输出结果为 : \"   测试文字\"\r\n        console.log(str.trimEnd())      //ES10中的方法,输出结果为 : \"测试文字   \"\r\n```\r\n\r\n## ES10-flat,flatMap\r\n\r\n**`flat()`**\r\n```js\r\nvar test1 = [1, 2, 3, 4, 5, [6, 7]]\r\nconsole.log(test1.flat());          //二维数组转一维\r\n//输出 [1,2,3,4,5,6,7]\r\n\r\nvar test2 = [1, 2, 3, 4, 5, [6, 7, [8, 9]]]\r\nconsole.log(test2.flat());          //三维数组转二维\r\n//输出 [1,2,3,4,5,6,7,[8,9]]\r\nconsole.log(test2.flat(2));         //三维数组转一维(指定深度为2)\r\n//输出 [1,2,3,4,5,6,7,8,9]\r\n```\r\n\r\n**`flatMap()`**\r\n```js\r\nvar test3 = [\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n]\r\nconsole.log(test3.map(item => item[5]))\r\n/* 输出: \r\n[\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n]\r\n*/\r\nconsole.log(test3.flatMap(item => item[5]))\r\n// 输出 [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\r\n```\r\n\r\n\r\n## ES10-`Symbol.prototype.description`\r\n```js\r\nvar temp = Symbol(\"这是描述字符串\")\r\nconsole.log(temp.description); //输出: 这是描述字符串\r\n```\r\n\r\n\r\n## ES11-类的私有属性\r\n```js\r\nclass Person{\r\n    name;\r\n    #age;\r\n    constructor(name,age){\r\n        this.name=name\r\n        this.#age=age\r\n    }\r\n}\r\n\r\nvar girl = new Person(\"小红\",18)\r\nconsole.log(girl.name);\r\n// console.log(girl.#age); //无法访问\r\n```\r\n\r\n## ES11-Promise.allSettled()\r\n* `Promise.allSettled([p1,p2])` 始终返回成功的promise对象, 类似于`||`\r\n  * 原先版本中有`Promise.all([p1,p2])`,其返回值成功失败由传入的参数决定,类似于`&&`\r\n```js\r\nvar p1 = new Promise((resolve,reject)=>{\r\n    setTimeout(()=>{\r\n        resolve(\"哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\")\r\n    },1000)\r\n})\r\nvar p2 = new Promise((resolve,reject)=>{\r\n    setTimeout(()=>{\r\n        reject(\"嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻\")\r\n    },1000)\r\n})\r\n\r\nconsole.log(Promise.allSettled([p1,p2]));\r\n```\r\n\r\n![图 3](./images/ES6-ES11新特性学习笔记/073d3d06eb89d441a759837d652fdeb6b5906e913fe25087ecb18b0b96184c74.png)  \r\n\r\n\r\n## ES11-`String.prototype.matchAll()`\r\n\r\n```js\r\nlet str = `\r\n<ul>\r\n    <li>\r\n        <a>肖申克的救赎</a>\r\n        <p>上映时间:1994-09-10</p>\r\n    </li>\r\n    <li>\r\n        <a>阿甘正传</a>\r\n        <p>上映时间:1994-07-06</p>\r\n    </li>\r\n</ul>\r\n`\r\n\r\nvar reg = /<a>(.*?)<\\/a>.*?<p>(.*?)<\\/p>/gs\r\n\r\nvar result1 = str.matchAll(reg)     //返回的是一个可迭代对象\r\nconsole.log([...result1]);          //所以可以使用扩展运算符 获取所有结果\r\n\r\nvar result2 = str.matchAll(reg)     //返回的是一个可迭代对象\r\nfor (let item of result2) {           //所以可以使用of 遍历对象 获取所有结果\r\n    console.log(item);\r\n    console.log({ \"name\": item[1], \"time\": item[2] });\r\n}\r\n```\r\n\r\n\r\n## ES11-`?.`可选链操作符\r\n```js\r\nfunction test(config) {\r\n    // 1\r\n    var dbHost = config.db.host\r\n    // var cacheHost = config.cache.host // 将报错,因为没有 config.cache\r\n    console.log(dbHost);\r\n    console.log(cacheHost);\r\n\r\n    // \r\n    var dbHost = config && config.db && config.db.host              //手动层层判断该对象是否有该属性,不会报错\r\n    var cacheHost = config && config.cache && config.cache.host     //手动层层判断该对象是否有该属性,不会报错\r\n    console.log(dbHost);\r\n    console.log(cacheHost);\r\n\r\n    var dbHost = config?.db?.host           //自动判断问号前的属性是否存在,不会报错\r\n    var cacheHost = config?.cache?.host     //自动判断问号前的属性是否存在,不会报错\r\n    console.log(dbHost);\r\n    console.log(cacheHost);\r\n}\r\n\r\ntest({\r\n    db: {\r\n        host: \"localhost\",\r\n        port: 1234,\r\n        username: \"root\",\r\n        password: \"root\",\r\n    },\r\n    // cache: {                     //不写cache\r\n    //     // host:\"localhost\",\r\n    //     port:4321,\r\n    //     username:\"root\",\r\n    //     password:\"root\",\r\n    // },\r\n})\r\n```\r\n\r\n\r\n## ES11-动态`import()`\r\n* 原先的import是静态的,需要在文件开头把所需模块一次性import导入\r\n* 动态import就是**按需导入**,**懒加载**\r\n\r\n**基本用法**\r\n```html\r\n<button id=\"btn\">点击测试</button>\r\n<script type=\"module\">\r\n    var btn = document.querySelector(\"#btn\")\r\n    btn.addEventListener(\"click\",async function(){\r\n        let hello = await import(\"./_hello.js\")     //import返回promise对象,使用await接受value\r\n        hello.myFun()\r\n    })\r\n</script>\r\n```\r\n\r\n```js\r\n//./_hello.js\r\nexport function myFun(){\r\n    alert(\"hello\")\r\n}\r\n```\r\n\r\n\r\n## ES11-BigInt大整型\r\n**BigInt**\r\n* BigInt常量: `123n`\r\n* BigInt()只能传入整数,不能传入浮点数\r\n* BigInt类型的数只能和BigInt类型数做运算\r\n\r\n**基本使用**\r\n```js\r\n        let test1 = 12345n;\r\n        console.log(test1);          //输出: 12345n\r\n        console.log(typeof test1); //输出: bigint\r\n\r\n        let test2 = BigInt(12345);\r\n        console.log(test2);          //输出: 12345n\r\n        console.log(typeof test2); //输出: bigint\r\n```\r\n\r\n**用处**\r\n```js\r\nlet maxInteger = Number.MAX_SAFE_INTEGER\r\nconsole.log(maxInteger+0);  //输出:     9007199254740991\r\nconsole.log(maxInteger+1);  //输出:     9007199254740992\r\nconsole.log(maxInteger+2);  //输出:     9007199254740992        //无法再加\r\n\r\nconsole.log(BigInt(maxInteger)+BigInt(0))//输出:     9007199254740991n\r\nconsole.log(BigInt(maxInteger)+BigInt(1))//输出:     9007199254740992n\r\nconsole.log(BigInt(maxInteger)+BigInt(2))//输出:     9007199254740993n        //可以再加\r\n```\r\n\r\n\r\n## ES11-globalThis\r\n\r\n```js\r\nconsole.log(globalThis) //在浏览器中指向 window\r\n// Window {window: Window, self: Window, document: document, name: '', location: Location, …}\r\n\r\nconsole.log(globalThis) //在nodejs中指向 global\r\n/*\r\nObject [global] {\r\n    global: [Circular],\r\n    clearInterval: [Function: clearInterval],\r\n    clearTimeout: [Function: clearTimeout],\r\n    setInterval: [Function: setInterval],\r\n    setTimeout: [Function: setTimeout] {\r\n        [Symbol(nodejs.util.promisify.custom)]: [Function]\r\n    },\r\n    queueMicrotask: [Function: queueMicrotask],\r\n    clearImmediate: [Function: clearImmediate],\r\n    setImmediate: [Function: setImmediate] {\r\n        [Symbol(nodejs.util.promisify.custom)]: [Function]\r\n    }\r\n}\r\n*/\r\n```"}