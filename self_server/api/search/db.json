[{"shortInfo":{"title":"23种设计模式","date":"2022-11-30T16:15:00.000Z","cover":"\\self_server\\assets\\images\\23种设计模式\\2022-12-04-01-27-26.png","tags":["笔记"],"categories":"笔记","hideAtIndex":true,"id":4056566168,"countWords":53758,"readSeconds":5375.8,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/23种设计模式/2022-12-04-01-27-26.png) -->\r\n\r\n# 23种设计模式\r\n\r\n> 笔记内容完全来源于黑马程序员课件\r\n\r\n<details>\r\n<summary>\r\n显示/隐藏\r\n\r\n# 目录\r\n</summary>\r\n\r\n- [23种设计模式](#23种设计模式)\r\n- [目录](#目录)\r\n- [1，设计模式概述](#1设计模式概述)\r\n  - [1.1 软件设计模式的产生背景](#11-软件设计模式的产生背景)\r\n  - [1.2 软件设计模式的概念](#12-软件设计模式的概念)\r\n  - [1.3 学习设计模式的必要性](#13-学习设计模式的必要性)\r\n  - [1.4 设计模式分类](#14-设计模式分类)\r\n- [2，UML统一建模语言](#2uml统一建模语言)\r\n  - [2.1 类图概述](#21-类图概述)\r\n  - [2.2 类图的作用](#22-类图的作用)\r\n  - [2.3 类图表示法](#23-类图表示法)\r\n    - [2.3.1 类的表示方式](#231-类的表示方式)\r\n    - [2.3.2 类与类/接口之间关系的表示方式](#232-类与类接口之间关系的表示方式)\r\n      - [2.3.2.1 关联关系](#2321-关联关系)\r\n      - [2.3.2.2 聚合关系](#2322-聚合关系)\r\n      - [2.3.2.3 组合关系](#2323-组合关系)\r\n      - [2.3.2.4 依赖关系](#2324-依赖关系)\r\n      - [2.3.2.5 继承关系](#2325-继承关系)\r\n      - [2.3.2.6 实现关系](#2326-实现关系)\r\n- [3，软件设计原则](#3软件设计原则)\r\n  - [3.1 开闭原则](#31-开闭原则)\r\n  - [3.2 里氏代换原则](#32-里氏代换原则)\r\n  - [3.3 依赖倒转原则](#33-依赖倒转原则)\r\n  - [3.4 接口隔离原则](#34-接口隔离原则)\r\n  - [3.5 迪米特法则](#35-迪米特法则)\r\n  - [3.6 合成复用原则](#36-合成复用原则)\r\n- [4，创建者模式](#4创建者模式)\r\n  - [4.1 单例设计模式](#41-单例设计模式)\r\n    - [4.1.1 单例模式的结构](#411-单例模式的结构)\r\n    - [4.1.2 单例模式的实现](#412-单例模式的实现)\r\n    - [4.1.3 存在的问题](#413-存在的问题)\r\n      - [4.1.3.1 问题演示](#4131-问题演示)\r\n      - [4.1.3.2 问题的解决](#4132-问题的解决)\r\n    - [4.1.4 JDK源码解析-Runtime类](#414-jdk源码解析-runtime类)\r\n- [4，创建型模式](#4创建型模式)\r\n  - [4.2 工厂模式](#42-工厂模式)\r\n    - [4.2.1 概述](#421-概述)\r\n    - [4.2.2 简单工厂模式](#422-简单工厂模式)\r\n      - [4.2.2.1 结构](#4221-结构)\r\n      - [4.2.2.2 实现](#4222-实现)\r\n      - [4.2.2.4 优缺点](#4224-优缺点)\r\n      - [4.2.2.3 扩展](#4223-扩展)\r\n    - [4.2.3 工厂方法模式](#423-工厂方法模式)\r\n      - [4.2.3.1 概念](#4231-概念)\r\n      - [4.2.3.2 结构](#4232-结构)\r\n      - [4.2.3.3 实现](#4233-实现)\r\n      - [4.2.3.4 优缺点](#4234-优缺点)\r\n    - [4.2.4 抽象工厂模式](#424-抽象工厂模式)\r\n      - [4.2.4.1 概念](#4241-概念)\r\n      - [4.2.4.2 结构](#4242-结构)\r\n      - [4.2.4.2 实现](#4242-实现)\r\n      - [4.2.4.3 优缺点](#4243-优缺点)\r\n      - [4.2.4.4 使用场景](#4244-使用场景)\r\n    - [4.2.5 模式扩展](#425-模式扩展)\r\n    - [4.2.6 JDK源码解析-Collection.iterator方法](#426-jdk源码解析-collectioniterator方法)\r\n  - [4.3 原型模式](#43-原型模式)\r\n    - [4.3.1 概述](#431-概述)\r\n    - [4.3.2 结构](#432-结构)\r\n    - [4.3.3 实现](#433-实现)\r\n    - [4.3.4 案例](#434-案例)\r\n    - [4.3.5 使用场景](#435-使用场景)\r\n    - [4.3.6 扩展（深克隆）](#436-扩展深克隆)\r\n  - [4.5 建造者模式](#45-建造者模式)\r\n    - [4.4.1 概述](#441-概述)\r\n    - [4.4.2 结构](#442-结构)\r\n    - [4.4.3 实例](#443-实例)\r\n    - [4.4.4 优缺点](#444-优缺点)\r\n    - [4.4.5 使用场景](#445-使用场景)\r\n    - [4.4.6 模式扩展](#446-模式扩展)\r\n  - [4.6 创建者模式对比](#46-创建者模式对比)\r\n    - [4.6.1 工厂方法模式VS建造者模式](#461-工厂方法模式vs建造者模式)\r\n    - [4.6.2 抽象工厂模式VS建造者模式](#462-抽象工厂模式vs建造者模式)\r\n- [5，结构型模式](#5结构型模式)\r\n  - [5.1 代理模式](#51-代理模式)\r\n    - [5.1.1 概述](#511-概述)\r\n    - [5.1.2 结构](#512-结构)\r\n    - [5.1.3 静态代理](#513-静态代理)\r\n    - [5.1.4 JDK动态代理](#514-jdk动态代理)\r\n    - [5.1.5 CGLIB动态代理](#515-cglib动态代理)\r\n    - [5.1.6 三种代理的对比](#516-三种代理的对比)\r\n    - [5.1.7 优缺点](#517-优缺点)\r\n    - [5.1.8 使用场景](#518-使用场景)\r\n  - [5.2 适配器模式](#52-适配器模式)\r\n    - [5.2.1 概述](#521-概述)\r\n    - [5.2.2 结构](#522-结构)\r\n    - [5.2.3 类适配器模式](#523-类适配器模式)\r\n    - [5.2.4 对象适配器模式](#524-对象适配器模式)\r\n    - [5.2.5 应用场景](#525-应用场景)\r\n    - [5.2.6 JDK源码解析](#526-jdk源码解析)\r\n  - [5.3 装饰者模式](#53-装饰者模式)\r\n    - [5.3.1 概述](#531-概述)\r\n    - [5.3.2 结构](#532-结构)\r\n    - [5.3.3 案例](#533-案例)\r\n    - [5.3.4 使用场景](#534-使用场景)\r\n    - [5.3.5 JDK源码解析](#535-jdk源码解析)\r\n    - [5.3.6 代理和装饰者的区别](#536-代理和装饰者的区别)\r\n  - [5.4 桥接模式](#54-桥接模式)\r\n    - [5.4.1 概述](#541-概述)\r\n    - [5.4.2 结构](#542-结构)\r\n    - [5.4.3 案例](#543-案例)\r\n    - [5.4.4 使用场景](#544-使用场景)\r\n  - [5.5 外观模式](#55-外观模式)\r\n    - [5.5.1 概述](#551-概述)\r\n    - [5.5.2 结构](#552-结构)\r\n    - [5.5.3 案例](#553-案例)\r\n    - [5.5.4 使用场景](#554-使用场景)\r\n    - [5.5.5 源码解析](#555-源码解析)\r\n- [5，结构型模式](#5结构型模式-1)\r\n  - [5.6 组合模式](#56-组合模式)\r\n    - [5.6.1 概述](#561-概述)\r\n    - [5.6.2 结构](#562-结构)\r\n    - [5.6.3 案例实现](#563-案例实现)\r\n    - [5.6.4 组合模式的分类](#564-组合模式的分类)\r\n    - [5.6.5 优点](#565-优点)\r\n    - [5.6.6 使用场景](#566-使用场景)\r\n  - [5.7 享元模式](#57-享元模式)\r\n    - [5.7.1 概述](#571-概述)\r\n    - [5.7.2 结构](#572-结构)\r\n    - [5.7.3 案例实现](#573-案例实现)\r\n    - [5.7.5 优缺点和使用场景](#575-优缺点和使用场景)\r\n    - [5.7.6 JDK源码解析](#576-jdk源码解析)\r\n- [6，行为型模式](#6行为型模式)\r\n  - [6.1 模板方法模式](#61-模板方法模式)\r\n    - [6.1.1 概述](#611-概述)\r\n    - [6.1.2 结构](#612-结构)\r\n    - [6.1.3 案例实现](#613-案例实现)\r\n    - [6.1.3 优缺点](#613-优缺点)\r\n    - [6.1.4 适用场景](#614-适用场景)\r\n    - [6.1.5 JDK源码解析](#615-jdk源码解析)\r\n  - [6.2 策略模式](#62-策略模式)\r\n    - [6.2.1 概述](#621-概述)\r\n    - [6.2.2 结构](#622-结构)\r\n    - [6.2.3 案例实现](#623-案例实现)\r\n    - [6.2.4 优缺点](#624-优缺点)\r\n    - [6.2.5 使用场景](#625-使用场景)\r\n    - [6.2.6 JDK源码解析](#626-jdk源码解析)\r\n  - [6.3 命令模式](#63-命令模式)\r\n    - [6.3.1 概述](#631-概述)\r\n    - [6.3.2 结构](#632-结构)\r\n    - [6.3.3 案例实现](#633-案例实现)\r\n    - [6.3.4 优缺点](#634-优缺点)\r\n    - [6.3.5 使用场景](#635-使用场景)\r\n    - [6.3.6 JDK源码解析](#636-jdk源码解析)\r\n  - [6.4 责任链模式](#64-责任链模式)\r\n    - [6.4.1 概述](#641-概述)\r\n    - [6.4.2 结构](#642-结构)\r\n    - [6.4.3 案例实现](#643-案例实现)\r\n    - [6.4.4 优缺点](#644-优缺点)\r\n    - [6.4.5 源码解析](#645-源码解析)\r\n- [6，行为型模式](#6行为型模式-1)\r\n  - [6.5 状态模式](#65-状态模式)\r\n    - [6.5.1 概述](#651-概述)\r\n    - [6.5.2 结构](#652-结构)\r\n    - [6.5.3 案例实现](#653-案例实现)\r\n    - [6.5.4 优缺点](#654-优缺点)\r\n    - [6.5.5 使用场景](#655-使用场景)\r\n  - [6.6 观察者模式](#66-观察者模式)\r\n    - [6.6.1 概述](#661-概述)\r\n    - [6.6.2 结构](#662-结构)\r\n    - [6.6.3 案例实现](#663-案例实现)\r\n    - [6.6.4 优缺点](#664-优缺点)\r\n    - [6.6.5 使用场景](#665-使用场景)\r\n    - [6.6.6 JDK中提供的实现](#666-jdk中提供的实现)\r\n  - [6.7 中介者模式](#67-中介者模式)\r\n    - [6.7.1 概述](#671-概述)\r\n    - [6.7.2 结构](#672-结构)\r\n    - [6.7.3 案例实现](#673-案例实现)\r\n    - [6.7.4 优缺点](#674-优缺点)\r\n    - [6.7.5 使用场景](#675-使用场景)\r\n  - [6.8 迭代器模式](#68-迭代器模式)\r\n    - [6.8.1 概述](#681-概述)\r\n    - [6.8.2 结构](#682-结构)\r\n    - [6.8.3 案例实现](#683-案例实现)\r\n    - [6.8.4 优缺点](#684-优缺点)\r\n    - [6.8.5 使用场景](#685-使用场景)\r\n    - [6.8.6 JDK源码解析](#686-jdk源码解析)\r\n  - [6.9 访问者模式](#69-访问者模式)\r\n    - [6.9.1 概述](#691-概述)\r\n    - [6.9.2 结构](#692-结构)\r\n    - [6.9.3 案例实现](#693-案例实现)\r\n    - [6.9.4 优缺点](#694-优缺点)\r\n    - [6.9.5  使用场景](#695--使用场景)\r\n    - [6.9.6 扩展](#696-扩展)\r\n  - [6.10 备忘录模式](#610-备忘录模式)\r\n    - [6.10.1 概述](#6101-概述)\r\n    - [6.10.2 结构](#6102-结构)\r\n    - [6.10.3 案例实现](#6103-案例实现)\r\n      - [6.10.3.1 “白箱”备忘录模式](#61031-白箱备忘录模式)\r\n      - [6.10.3.2 “黑箱”备忘录模式](#61032-黑箱备忘录模式)\r\n    - [6.10.4 优缺点](#6104-优缺点)\r\n    - [6.10.5 使用场景](#6105-使用场景)\r\n- [6，行为型模式](#6行为型模式-2)\r\n  - [6.11 解释器模式](#611-解释器模式)\r\n    - [6.11.1 概述](#6111-概述)\r\n    - [6.11.2 结构](#6112-结构)\r\n    - [6.11.3 案例实现](#6113-案例实现)\r\n    - [6.11.4 优缺点](#6114-优缺点)\r\n    - [6.11.5 使用场景](#6115-使用场景)\r\n- [7，自定义Spring框架](#7自定义spring框架)\r\n  - [7.1 spring使用回顾](#71-spring使用回顾)\r\n  - [7.2 spring核心功能结构](#72-spring核心功能结构)\r\n    - [7.1.1 bean概述](#711-bean概述)\r\n  - [7.3 Spring IOC相关接口分析](#73-spring-ioc相关接口分析)\r\n    - [7.3.1 BeanFactory解析](#731-beanfactory解析)\r\n    - [7.3.2 BeanDefinition解析](#732-beandefinition解析)\r\n    - [7.3.3 BeanDefinitionReader解析](#733-beandefinitionreader解析)\r\n    - [7.3.4 BeanDefinitionRegistry解析](#734-beandefinitionregistry解析)\r\n    - [7.3.5 创建容器](#735-创建容器)\r\n  - [7.4 自定义SpringIOC](#74-自定义springioc)\r\n    - [7.4.1 定义bean相关的pojo类](#741-定义bean相关的pojo类)\r\n      - [7.4.1.1 PropertyValue类](#7411-propertyvalue类)\r\n      - [7.4.1.2 MutablePropertyValues类](#7412-mutablepropertyvalues类)\r\n      - [7.4.1.3 BeanDefinition类](#7413-beandefinition类)\r\n    - [7.4.2 定义注册表相关类](#742-定义注册表相关类)\r\n      - [7.4.2.1 BeanDefinitionRegistry接口](#7421-beandefinitionregistry接口)\r\n      - [7.4.2.2 SimpleBeanDefinitionRegistry类](#7422-simplebeandefinitionregistry类)\r\n    - [7.4.3 定义解析器相关类](#743-定义解析器相关类)\r\n      - [7.4.3.1 BeanDefinitionReader接口](#7431-beandefinitionreader接口)\r\n      - [7.4.3.2 XmlBeanDefinitionReader类](#7432-xmlbeandefinitionreader类)\r\n    - [7.4.4 IOC容器相关类](#744-ioc容器相关类)\r\n      - [7.4.4.1 BeanFactory接口](#7441-beanfactory接口)\r\n      - [7.4.4.2 ApplicationContext接口](#7442-applicationcontext接口)\r\n      - [7.4.4.3 AbstractApplicationContext类](#7443-abstractapplicationcontext类)\r\n      - [7.4.4.4 ClassPathXmlApplicationContext类](#7444-classpathxmlapplicationcontext类)\r\n    - [7.4.5 自定义Spring IOC总结](#745-自定义spring-ioc总结)\r\n      - [7.4.5.1 使用到的设计模式](#7451-使用到的设计模式)\r\n      - [7.4.5.2 符合大部分设计原则](#7452-符合大部分设计原则)\r\n      - [7.4.5.3 整个设计和Spring的设计还是有一定的出入](#7453-整个设计和spring的设计还是有一定的出入)\r\n\r\n\r\n</details>\r\n\r\n\r\n# 1，设计模式概述\r\n\r\n## 1.1 软件设计模式的产生背景\r\n\r\n\"设计模式\"最初并不是出现在软件设计中，而是被用于建筑领域的设计中。\r\n\r\n1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任`克里斯托夫·亚历山大（Christopher Alexander）`在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。\r\n\r\n1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。  \r\n\r\n## 1.2 软件设计模式的概念\r\n\r\n`软件设计模式`（Software Design Pattern），又称`设计模式`，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。\r\n\r\n## 1.3 学习设计模式的必要性\r\n\r\n设计模式的`本质`是`面向对象设计原则的实际运用`，是对类的`封装性`、`继承性`和`多态性`以及类的`关联关系`和`组合关系`的充分理解。\r\n\r\n正确使用设计模式具有以下优点。\r\n\r\n- 可以提高程序员的`思维能力`、`编程能力`和`设计能力`。\r\n- 使程序设计更加`标准化`、代码编制更加`工程化`，使软件开发效率大大提高，从而缩短软件的开发周期。\r\n- 使设计的代码`可重用性高`、`可读性强`、`可靠性高`、`灵活性好`、`可维护性强`。\r\n\r\n## 1.4 设计模式分类\r\n\r\n* **创建型模式**\r\n  * 用于描述“`怎样创建对象`”，它的主要特点是“`将对象的创建与使用分离`”。\r\n  * GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。\r\n    * 单例、\r\n    * 原型、\r\n    * 工厂方法、\r\n    * 抽象工厂、\r\n    * 建造者\r\n\r\n* **结构型模式**\r\n  * 用于描述`如何将类或对象按某种布局组成更大的结构`，\r\n  * GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。\r\n    * 代理、\r\n    * 适配器、\r\n    * 桥接、\r\n    * 装饰、\r\n    * 外观、\r\n    * 享元、\r\n    * 组合\r\n\r\n* **行为型模式**\r\n  * 用于描述`类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责`。\r\n  * GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。\r\n    * 模板方法、\r\n    * 策略、\r\n    * 命令、\r\n    * 职责链、\r\n    * 状态、\r\n    * 观察者、\r\n    * 中介者、\r\n    * 迭代器、\r\n    * 访问者、\r\n    * 备忘录、\r\n    * 解释器\r\n\r\n\r\n\r\n# 2，UML统一建模语言\r\n\r\n统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。\r\n\r\nUML 从目标系统的不同角度出发，定义了用例图、**`类图`**、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。\r\n\r\n## 2.1 类图概述\r\n\r\n类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。\r\n\r\n## 2.2 类图的作用\r\n\r\n* 在软件工程中，`类图`是一种`静态`的`结构图`，描述了系统的类的集合，类的属性和类之间的关系，可以`简化了人们对系统的理解`；\r\n* 类图是`系统分析`和`设计阶段`的重要`产物`，是`系统编码`和`测试`的重要`模型`。\r\n\r\n> 说白了 就是以图像化的方式描述程序中的所有类 类的属性 类之间的关系 便于理解\r\n\r\n## 2.3 类图表示法\r\n\r\n### 2.3.1 类的表示方式 \r\n\r\n在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 \r\n\r\n![](img\\Employee.jpg)\r\n\r\n属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有**三种**：\r\n* `+`：表示`public`\r\n* `-`：表示`private`\r\n* `#`：表示`protected`\r\n\r\n属性的完整表示方式是： **`可见性  名称 ：类型 [ = 缺省值]`**  \r\n\r\n方法的完整表示方式是： **`可见性  名称(参数列表) [ ： 返回类型]`**  \r\n\r\n> 注意：\r\n>\r\n> ​\t1，中括号中的内容表示是可选的\r\n>\r\n> ​\t2，也有将类型放在变量名前面，返回值类型放在方法名前面\r\n\r\n**举个栗子：**\r\n\r\n![](img\\demo.png)\r\n\r\n上图Demo类定义了三个方法：\r\n\r\n* method()方法：修饰符为public，没有参数，没有返回值。\r\n* method1()方法：修饰符为private，没有参数，返回值类型为String。\r\n* method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。\r\n\r\n### 2.3.2 类与类/接口之间关系的表示方式\r\n\r\n#### 2.3.2.1 关联关系\r\n\r\n关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。\r\n\r\n关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。\r\n\r\n关联又可以分为单向关联，双向关联，自关联。\r\n\r\n**1，单向关联**\r\n\r\n![](img\\customer_address.png)\r\n\r\n在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。\r\n\r\n**2，双向关联**\r\n\r\n![](img\\customer_product.png)\r\n\r\n从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。\r\n\r\n在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List\\<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。\r\n\r\n**3，自关联**\r\n\r\n![](img\\node.png)\r\n\r\n自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。\r\n\r\n\r\n\r\n#### 2.3.2.2 聚合关系\r\n\r\n聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。\r\n\r\n聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。\r\n\r\n在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：\r\n\r\n![](img\\image-20191229173422328.png)\r\n\r\n#### 2.3.2.3 组合关系\r\n\r\n组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。\r\n\r\n在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。\r\n\r\n在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：\r\n\r\n![](img\\image-20191229173455149.png)\r\n\r\n\r\n\r\n#### 2.3.2.4 依赖关系\r\n\r\n依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。\r\n\r\n在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：\r\n\r\n![](img\\image-20191229173518926.png)\r\n\r\n#### 2.3.2.5 继承关系\r\n\r\n继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。\r\n\r\n在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：\r\n\r\n![](img\\image-20191229173539838.png)\r\n\r\n\r\n\r\n#### 2.3.2.6 实现关系\r\n\r\n实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。\r\n\r\n在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。\r\n\r\n![](img\\image-20191229173554296.png)\r\n\r\n  \r\n\r\n\r\n\r\n# 3，软件设计原则\r\n\r\n在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。\r\n\r\n## 3.1 开闭原则\r\n\r\n**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。\r\n\r\n想要达到这样的效果，我们需要使用接口和抽象类。\r\n\r\n因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\r\n\r\n下面以 `搜狗输入法` 的皮肤为例介绍开闭原则的应用。\r\n\r\n【例】`搜狗输入法` 的皮肤设计。\r\n\r\n分析：`搜狗输入法` 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。\r\n\r\n![](img\\open-close.png)\r\n\r\n\r\n\r\n## 3.2 里氏代换原则\r\n\r\n里氏代换原则是面向对象设计的基本原则之一。\r\n\r\n里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\r\n\r\n如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。\r\n\r\n下面看一个里氏替换原则中经典的一个例子\r\n\r\n【例】正方形不是长方形。\r\n\r\n在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。\r\n\r\n![](img\\正方形不是长方形.png)\r\n\r\n代码如下：\r\n\r\n**长方形类（Rectangle）：**\r\n\r\n```java\r\npublic class Rectangle {\r\n    private double length;\r\n    private double width;\r\n\r\n    public double getLength() {\r\n        return length;\r\n    }\r\n\r\n    public void setLength(double length) {\r\n        this.length = length;\r\n    }\r\n\r\n    public double getWidth() {\r\n        return width;\r\n    }\r\n\r\n    public void setWidth(double width) {\r\n        this.width = width;\r\n    }\r\n}\r\n```\r\n\r\n**正方形（Square）：**\r\n\r\n由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。\r\n\r\n```java\r\npublic class Square extends Rectangle {\r\n    \r\n    public void setWidth(double width) {\r\n        super.setLength(width);\r\n        super.setWidth(width);\r\n    }\r\n\r\n    public void setLength(double length) {\r\n        super.setLength(length);\r\n        super.setWidth(length);\r\n    }\r\n}\r\n```\r\n\r\n类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。\r\n\r\n```java\r\npublic class RectangleDemo {\r\n    \r\n    public static void resize(Rectangle rectangle) {\r\n        while (rectangle.getWidth() <= rectangle.getLength()) {\r\n            rectangle.setWidth(rectangle.getWidth() + 1);\r\n        }\r\n    }\r\n\r\n    //打印长方形的长和宽\r\n    public static void printLengthAndWidth(Rectangle rectangle) {\r\n        System.out.println(rectangle.getLength());\r\n        System.out.println(rectangle.getWidth());\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Rectangle rectangle = new Rectangle();\r\n        rectangle.setLength(20);\r\n        rectangle.setWidth(10);\r\n        resize(rectangle);\r\n        printLengthAndWidth(rectangle);\r\n\r\n        System.out.println(\"============\");\r\n\r\n        Rectangle rectangle1 = new Square();\r\n        rectangle1.setLength(10);\r\n        resize(rectangle1);\r\n        printLengthAndWidth(rectangle1);\r\n    }\r\n}\r\n```\r\n\r\n我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。\r\n我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。\r\n\r\n如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口\r\n\r\n<img src=\"img\\正方形不是长方形改进.png\" style=\"zoom:80%;\" />\r\n\r\n\r\n\r\n## 3.3 依赖倒转原则\r\n\r\n高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\r\n\r\n下面看一个例子来理解依赖倒转原则\r\n\r\n【例】组装电脑\r\n\r\n现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。\r\n\r\n**类图如下：**\r\n\r\n<img src=\"img\\依赖倒转原则.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n**希捷硬盘类（XiJieHardDisk）:**\r\n\r\n```java\r\npublic class XiJieHardDisk implements HardDisk {\r\n\r\n    public void save(String data) {\r\n        System.out.println(\"使用希捷硬盘存储数据\" + data);\r\n    }\r\n\r\n    public String get() {\r\n        System.out.println(\"使用希捷希捷硬盘取数据\");\r\n        return \"数据\";\r\n    }\r\n}\r\n```\r\n\r\n**Intel处理器（IntelCpu）：**\r\n\r\n```java\r\npublic class IntelCpu implements Cpu {\r\n\r\n    public void run() {\r\n        System.out.println(\"使用Intel处理器\");\r\n    }\r\n}\r\n```\r\n\r\n**金士顿内存条（KingstonMemory）：**\r\n\r\n```java\r\npublic class KingstonMemory implements Memory {\r\n\r\n    public void save() {\r\n        System.out.println(\"使用金士顿作为内存条\");\r\n    }\r\n}\r\n```\r\n\r\n**电脑（Computer）：**\r\n\r\n```java\r\npublic class Computer {\r\n\r\n    private XiJieHardDisk hardDisk;\r\n    private IntelCpu cpu;\r\n    private KingstonMemory memory;\r\n\r\n    public IntelCpu getCpu() {\r\n        return cpu;\r\n    }\r\n\r\n    public void setCpu(IntelCpu cpu) {\r\n        this.cpu = cpu;\r\n    }\r\n\r\n    public KingstonMemory getMemory() {\r\n        return memory;\r\n    }\r\n\r\n    public void setMemory(KingstonMemory memory) {\r\n        this.memory = memory;\r\n    }\r\n\r\n    public XiJieHardDisk getHardDisk() {\r\n        return hardDisk;\r\n    }\r\n\r\n    public void setHardDisk(XiJieHardDisk hardDisk) {\r\n        this.hardDisk = hardDisk;\r\n    }\r\n\r\n    public void run() {\r\n        System.out.println(\"计算机工作\");\r\n        cpu.run();\r\n        memory.save();\r\n        String data = hardDisk.get();\r\n        System.out.println(\"从硬盘中获取的数据为：\" + data);\r\n    }\r\n}\r\n```\r\n\r\n**测试类（TestComputer）：**\r\n\r\n测试类用来组装电脑。\r\n\r\n```java\r\npublic class TestComputer {\r\n    public static void main(String[] args) {\r\n        Computer computer = new Computer();\r\n        computer.setHardDisk(new XiJieHardDisk());\r\n        computer.setCpu(new IntelCpu());\r\n        computer.setMemory(new KingstonMemory());\r\n\r\n        computer.run();\r\n    }\r\n}\r\n```\r\n\r\n上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。\r\n\r\n根据依赖倒转原则进行改进：\r\n\r\n代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。\r\n\r\n**类图如下：**\r\n\r\n<img src=\"img/依赖倒转原则改进.png\" alt=\"image-20191229173554296\" style=\"zoom:70%;\" />\r\n\r\n**电脑（Computer）：**\r\n\r\n```java\r\npublic class Computer {\r\n\r\n    private HardDisk hardDisk;\r\n    private Cpu cpu;\r\n    private Memory memory;\r\n\r\n    public HardDisk getHardDisk() {\r\n        return hardDisk;\r\n    }\r\n\r\n    public void setHardDisk(HardDisk hardDisk) {\r\n        this.hardDisk = hardDisk;\r\n    }\r\n\r\n    public Cpu getCpu() {\r\n        return cpu;\r\n    }\r\n\r\n    public void setCpu(Cpu cpu) {\r\n        this.cpu = cpu;\r\n    }\r\n\r\n    public Memory getMemory() {\r\n        return memory;\r\n    }\r\n\r\n    public void setMemory(Memory memory) {\r\n        this.memory = memory;\r\n    }\r\n\r\n    public void run() {\r\n        System.out.println(\"计算机工作\");\r\n    }\r\n}\r\n```\r\n\r\n面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。\r\n\r\n\r\n\r\n## 3.4 接口隔离原则\r\n\r\n客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。\r\n\r\n下面看一个例子来理解接口隔离原则\r\n\r\n【例】安全门案例\r\n\r\n我们需要创建一个`黑马`品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：\r\n\r\n![](img\\接口隔离原则.png)\r\n\r\n上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：\r\n\r\n![](img\\接口隔离原则1.png)\r\n\r\n代码如下：\r\n\r\n**AntiTheft（接口）：**\r\n\r\n```java\r\npublic interface AntiTheft {\r\n    void antiTheft();\r\n}\r\n```\r\n\r\n**Fireproof（接口）：**\r\n\r\n```java\r\npublic interface Fireproof {\r\n    void fireproof();\r\n}\r\n```\r\n\r\n**Waterproof（接口）：**\r\n\r\n```java\r\npublic interface Waterproof {\r\n    void waterproof();\r\n}\r\n```\r\n\r\n**HeiMaSafetyDoor（类）：**\r\n\r\n```java\r\npublic class HeiMaSafetyDoor implements AntiTheft,Fireproof,Waterproof {\r\n    public void antiTheft() {\r\n        System.out.println(\"防盗\");\r\n    }\r\n\r\n    public void fireproof() {\r\n        System.out.println(\"防火\");\r\n    }\r\n\r\n\r\n    public void waterproof() {\r\n        System.out.println(\"防水\");\r\n    }\r\n}\r\n```\r\n\r\n**ItcastSafetyDoor（类）：**\r\n\r\n```java\r\npublic class ItcastSafetyDoor implements AntiTheft,Fireproof {\r\n    public void antiTheft() {\r\n        System.out.println(\"防盗\");\r\n    }\r\n\r\n    public void fireproof() {\r\n        System.out.println(\"防火\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 3.5 迪米特法则\r\n\r\n迪米特法则又叫最少知识原则。\r\n\r\n只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。\r\n\r\n其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\r\n\r\n迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\r\n\r\n下面看一个例子来理解迪米特法则\r\n\r\n【例】明星与经纪人的关系实例\r\n\r\n明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。\r\n\r\n类图如下：\r\n\r\n<img src=\"img/迪米特法则.png\" alt=\"image-20191229173554296\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n**明星类（Star）**\r\n\r\n```java\r\npublic class Star {\r\n    private String name;\r\n\r\n    public Star(String name) {\r\n        this.name=name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\r\n```\r\n\r\n**粉丝类（Fans）**\r\n\r\n```java\r\npublic class Fans {\r\n    private String name;\r\n\r\n    public Fans(String name) {\r\n        this.name=name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\r\n```\r\n\r\n**媒体公司类（Company）**\r\n\r\n```java\r\npublic class Company {\r\n    private String name;\r\n\r\n    public Company(String name) {\r\n        this.name=name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\r\n```\r\n\r\n**经纪人类（Agent）**\r\n\r\n```java\r\npublic class Agent {\r\n    private Star star;\r\n    private Fans fans;\r\n    private Company company;\r\n\r\n    public void setStar(Star star) {\r\n        this.star = star;\r\n    }\r\n\r\n    public void setFans(Fans fans) {\r\n        this.fans = fans;\r\n    }\r\n\r\n    public void setCompany(Company company) {\r\n        this.company = company;\r\n    }\r\n\r\n    public void meeting() {\r\n        System.out.println(fans.getName() + \"与明星\" + star.getName() + \"见面了。\");\r\n    }\r\n\r\n    public void business() {\r\n        System.out.println(company.getName() + \"与明星\" + star.getName() + \"洽淡业务。\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 3.6 合成复用原则\r\n\r\n合成复用原则是指：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。\r\n\r\n通常类的复用分为继承复用和合成复用两种。\r\n\r\n继承复用虽然有简单和易实现的优点，但它也存在以下缺点：\r\n\r\n1. 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。\r\n2. 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。\r\n3. 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。\r\n\r\n\r\n采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：\r\n\r\n1. 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。\r\n2. 对象间的耦合度低。可以在类的成员位置声明抽象。\r\n3. 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。\r\n\r\n下面看一个例子来理解合成复用原则\r\n\r\n【例】汽车分类管理程序\r\n\r\n汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： \r\n\r\n<img src=\"img/合成复用原则.png\" alt=\"image-20191229173554296\" style=\"zoom:80%;\" />\r\n\r\n从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。\r\n\r\n<img src=\"img/合成复用原则1.png\" alt=\"image-20191229173554296\" style=\"zoom:80%;\" />\r\n\r\n\r\n\r\n# 4，创建者模式\r\n\r\n创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。\r\n\r\n这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。\r\n\r\n创建型模式分为：\r\n\r\n* 单例模式\r\n* 工厂方法模式\r\n* 抽象工程模式\r\n* 原型模式\r\n* 建造者模式\r\n\r\n## 4.1 单例设计模式\r\n\r\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\r\n\r\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\r\n\r\n### 4.1.1 单例模式的结构\r\n\r\n单例模式的主要有以下角色：\r\n\r\n* 单例类。只能创建一个实例的类\r\n* 访问类。使用单例类\r\n\r\n### 4.1.2 单例模式的实现\r\n\r\n> 单例设计模式分类两种：\r\n>\r\n> ​\t饿汉式：类加载就会导致该单实例对象被创建\t\r\n>\r\n> ​\t懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建\r\n\r\n1. 饿汉式-方式1（静态变量方式）\r\n\r\n   ```java\r\n   /**\r\n    * 饿汉式\r\n    *      静态变量创建类的对象\r\n    */\r\n   public class Singleton {\r\n       //私有构造方法\r\n       private Singleton() {}\r\n   \r\n       //在成员位置创建该类的对象\r\n       private static Singleton instance = new Singleton();\r\n   \r\n       //对外提供静态方法获取该对象\r\n       public static Singleton getInstance() {\r\n           return instance;\r\n       }\r\n   }\r\n   ```\r\n\r\n   <font color='red'>说明：</font>\r\n\r\n   ​\t该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。\r\n\r\n   \r\n\r\n2. 饿汉式-方式2（静态代码块方式）\r\n\r\n   ```java\r\n   /**\r\n    * 恶汉式\r\n    *      在静态代码块中创建该类对象\r\n    */\r\n   public class Singleton {\r\n   \r\n       //私有构造方法\r\n       private Singleton() {}\r\n   \r\n       //在成员位置创建该类的对象\r\n       private static Singleton instance;\r\n   \r\n       static {\r\n           instance = new Singleton();\r\n       }\r\n   \r\n       //对外提供静态方法获取该对象\r\n       public static Singleton getInstance() {\r\n           return instance;\r\n       }\r\n   }\r\n   ```\r\n\r\n   <font color='red'>说明：</font>\r\n\r\n   ​\t该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。\r\n\r\n   \r\n\r\n3. 懒汉式-方式1（线程不安全）\r\n\r\n   ```java\r\n   /**\r\n    * 懒汉式\r\n    *  线程不安全\r\n    */\r\n   public class Singleton {\r\n       //私有构造方法\r\n       private Singleton() {}\r\n   \r\n       //在成员位置创建该类的对象\r\n       private static Singleton instance;\r\n   \r\n       //对外提供静态方法获取该对象\r\n       public static Singleton getInstance() {\r\n   \r\n           if(instance == null) {\r\n               instance = new Singleton();\r\n           }\r\n           return instance;\r\n       }\r\n   }\r\n   ```\r\n\r\n   <font color='red'>说明：</font>\r\n\r\n   ​\t从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。\r\n\r\n   \r\n\r\n4. 懒汉式-方式2（线程安全）\r\n\r\n   ```java\r\n   /**\r\n    * 懒汉式\r\n    *  线程安全\r\n    */\r\n   public class Singleton {\r\n       //私有构造方法\r\n       private Singleton() {}\r\n   \r\n       //在成员位置创建该类的对象\r\n       private static Singleton instance;\r\n   \r\n       //对外提供静态方法获取该对象\r\n       public static synchronized Singleton getInstance() {\r\n   \r\n           if(instance == null) {\r\n               instance = new Singleton();\r\n           }\r\n           return instance;\r\n       }\r\n   }\r\n   ```\r\n\r\n   <font color='red'>说明：</font>\r\n\r\n   ​\t该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。\r\n\r\n   \r\n\r\n5. 懒汉式-方式3（双重检查锁）\r\n\r\n   再来讨论一下懒汉模式中加锁的问题，对于 `getInstance()` 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式\r\n\r\n   ```java\r\n   /**\r\n    * 双重检查方式\r\n    */\r\n   public class Singleton { \r\n   \r\n       //私有构造方法\r\n       private Singleton() {}\r\n   \r\n       private static Singleton instance;\r\n   \r\n      //对外提供静态方法获取该对象\r\n       public static Singleton getInstance() {\r\n   \t\t//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例\r\n           if(instance == null) {\r\n               synchronized (Singleton.class) {\r\n                   //抢到锁之后再次判断是否为null\r\n                   if(instance == null) {\r\n                       instance = new Singleton();\r\n                   }\r\n               }\r\n           }\r\n           return instance;\r\n       }\r\n   }\r\n   ```\r\n\r\n   双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。\r\n\r\n   要解决双重检查锁模式带来空指针异常的问题，只需要使用 `volatile` 关键字, `volatile` 关键字可以保证可见性和有序性。\r\n\r\n   ```java\r\n   /**\r\n    * 双重检查方式\r\n    */\r\n   public class Singleton {\r\n   \r\n       //私有构造方法\r\n       private Singleton() {}\r\n   \r\n       private static volatile Singleton instance;\r\n   \r\n      //对外提供静态方法获取该对象\r\n       public static Singleton getInstance() {\r\n   \t\t//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际\r\n           if(instance == null) {\r\n               synchronized (Singleton.class) {\r\n                   //抢到锁之后再次判断是否为空\r\n                   if(instance == null) {\r\n                       instance = new Singleton();\r\n                   }\r\n               }\r\n           }\r\n           return instance;\r\n       }\r\n   }\r\n   ```\r\n\r\n   <font color=\"red\">小结：</font>\r\n\r\n   添加 `volatile` 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。\r\n\r\n\r\n\r\n\r\n6. 懒汉式-方式4（静态内部类方式）\r\n\r\n   静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 `static` 修饰，保证只被实例化一次，并且严格保证实例化顺序。\r\n\r\n   ```java\r\n   /**\r\n    * 静态内部类方式\r\n    */\r\n   public class Singleton {\r\n   \r\n       //私有构造方法\r\n       private Singleton() {}\r\n   \r\n       private static class SingletonHolder {\r\n           private static final Singleton INSTANCE = new Singleton();\r\n       }\r\n   \r\n       //对外提供静态方法获取该对象\r\n       public static Singleton getInstance() {\r\n           return SingletonHolder.INSTANCE;\r\n       }\r\n   }\r\n   ```\r\n\r\n   <font color='red'>说明：</font>\r\n\r\n   ​\t第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder\r\n\r\n   并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。\r\n\r\n   <font color=\"red\">小结：</font>\r\n\r\n   ​\t静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。\r\n\r\n   \r\n\r\n7. 枚举方式\r\n\r\n   枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。\r\n\r\n   ```java\r\n   /**\r\n    * 枚举方式\r\n    */\r\n   public enum Singleton {\r\n       INSTANCE;\r\n   }\r\n   ```\r\n\r\n   <font color='red'>说明：</font>\r\n\r\n   ​\t枚举方式属于恶汉式方式。\r\n\r\n\r\n\r\n\r\n### 4.1.3 存在的问题\r\n\r\n#### 4.1.3.1 问题演示\r\n\r\n破坏单例模式：\r\n\r\n使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。\r\n\r\n* 序列化反序列化\r\n\r\n  **Singleton类：**\r\n\r\n  ```java\r\n  public class Singleton implements Serializable {\r\n  \r\n      //私有构造方法\r\n      private Singleton() {}\r\n  \r\n      private static class SingletonHolder {\r\n          private static final Singleton INSTANCE = new Singleton();\r\n      }\r\n  \r\n      //对外提供静态方法获取该对象\r\n      public static Singleton getInstance() {\r\n          return SingletonHolder.INSTANCE;\r\n      }\r\n  }\r\n  ```\r\n\r\n  **Test类：**\r\n\r\n  ```java\r\n  public class Test {\r\n      public static void main(String[] args) throws Exception {\r\n          //往文件中写对象\r\n          //writeObject2File();\r\n          //从文件中读取对象\r\n          Singleton s1 = readObjectFromFile();\r\n          Singleton s2 = readObjectFromFile();\r\n  \r\n          //判断两个反序列化后的对象是否是同一个对象\r\n          System.out.println(s1 == s2);\r\n      }\r\n  \r\n      private static Singleton readObjectFromFile() throws Exception {\r\n          //创建对象输入流对象\r\n          ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt\"));\r\n          //第一个读取Singleton对象\r\n          Singleton instance = (Singleton) ois.readObject();\r\n  \r\n          return instance;\r\n      }\r\n  \r\n      public static void writeObject2File() throws Exception {\r\n          //获取Singleton类的对象\r\n          Singleton instance = Singleton.getInstance();\r\n          //创建对象输出流\r\n          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt\"));\r\n          //将instance对象写出到文件中\r\n          oos.writeObject(instance);\r\n      }\r\n  }\r\n  ```\r\n\r\n  > 上面代码运行结果是`false`，表明序列化和反序列化已经破坏了单例设计模式。\r\n\r\n* 反射\r\n\r\n  **Singleton类：**\r\n\r\n  ```java\r\n  public class Singleton {\r\n  \r\n      //私有构造方法\r\n      private Singleton() {}\r\n      \r\n      private static volatile Singleton instance;\r\n  \r\n      //对外提供静态方法获取该对象\r\n      public static Singleton getInstance() {\r\n  \r\n          if(instance != null) {\r\n              return instance;\r\n          }\r\n  \r\n          synchronized (Singleton.class) {\r\n              if(instance != null) {\r\n                  return instance;\r\n              }\r\n              instance = new Singleton();\r\n              return instance;\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  **Test类：**\r\n\r\n  ```java\r\n  public class Test {\r\n      public static void main(String[] args) throws Exception {\r\n          //获取Singleton类的字节码对象\r\n          Class clazz = Singleton.class;\r\n          //获取Singleton类的私有无参构造方法对象\r\n          Constructor constructor = clazz.getDeclaredConstructor();\r\n          //取消访问检查\r\n          constructor.setAccessible(true);\r\n  \r\n          //创建Singleton类的对象s1\r\n          Singleton s1 = (Singleton) constructor.newInstance();\r\n          //创建Singleton类的对象s2\r\n          Singleton s2 = (Singleton) constructor.newInstance();\r\n  \r\n          //判断通过反射创建的两个Singleton对象是否是同一个对象\r\n          System.out.println(s1 == s2);\r\n      }\r\n  }\r\n  ```\r\n\r\n  > 上面代码运行结果是`false`，表明序列化和反序列化已经破坏了单例设计模式\r\n\r\n> <font color=\"red\">注意：</font>枚举方式不会出现这两个问题。\r\n\r\n\r\n\r\n#### 4.1.3.2 问题的解决\r\n\r\n* 序列化、反序列方式破坏单例模式的解决方法\r\n\r\n  在Singleton类中添加`readResolve()`方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。\r\n\r\n  **Singleton类：**\r\n\r\n  ```java\r\n  public class Singleton implements Serializable {\r\n  \r\n      //私有构造方法\r\n      private Singleton() {}\r\n  \r\n      private static class SingletonHolder {\r\n          private static final Singleton INSTANCE = new Singleton();\r\n      }\r\n  \r\n      //对外提供静态方法获取该对象\r\n      public static Singleton getInstance() {\r\n          return SingletonHolder.INSTANCE;\r\n      }\r\n      \r\n      /**\r\n       * 下面是为了解决序列化反序列化破解单例模式\r\n       */\r\n      private Object readResolve() {\r\n          return SingletonHolder.INSTANCE;\r\n      }\r\n  }\r\n  ```\r\n\r\n  **源码解析：**\r\n\r\n  ObjectInputStream类\r\n\r\n  ```java\r\n  public final Object readObject() throws IOException, ClassNotFoundException{\r\n      ...\r\n      // if nested read, passHandle contains handle of enclosing object\r\n      int outerHandle = passHandle;\r\n      try {\r\n          Object obj = readObject0(false);//重点查看readObject0方法\r\n      .....\r\n  }\r\n      \r\n  private Object readObject0(boolean unshared) throws IOException {\r\n  \t...\r\n      try {\r\n  \t\tswitch (tc) {\r\n  \t\t\t...\r\n  \t\t\tcase TC_OBJECT:\r\n  \t\t\t\treturn checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法\r\n  \t\t\t...\r\n          }\r\n      } finally {\r\n          depth--;\r\n          bin.setBlockDataMode(oldMode);\r\n      }    \r\n  }\r\n      \r\n  private Object readOrdinaryObject(boolean unshared) throws IOException {\r\n  \t...\r\n  \t//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，\r\n      obj = desc.isInstantiable() ? desc.newInstance() : null; \r\n      ...\r\n      // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true\r\n      if (obj != null && handles.lookupException(passHandle) == null && desc.hasReadResolveMethod()) {\r\n      \t// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量\r\n      \t// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。\r\n      \tObject rep = desc.invokeReadResolve(obj);\r\n       \t...\r\n      }\r\n      return obj;\r\n  }\r\n  ```\r\n\r\n* 反射方式破解单例的解决方法\r\n\r\n  ```java\r\n  public class Singleton {\r\n  \r\n      //私有构造方法\r\n      private Singleton() {\r\n          /*\r\n             反射破解单例模式需要添加的代码\r\n          */\r\n          if(instance != null) {\r\n              throw new RuntimeException();\r\n          }\r\n      }\r\n      \r\n      private static volatile Singleton instance;\r\n  \r\n      //对外提供静态方法获取该对象\r\n      public static Singleton getInstance() {\r\n  \r\n          if(instance != null) {\r\n              return instance;\r\n          }\r\n  \r\n          synchronized (Singleton.class) {\r\n              if(instance != null) {\r\n                  return instance;\r\n              }\r\n              instance = new Singleton();\r\n              return instance;\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  <font color=\"red\">说明:</font>\r\n\r\n  ​\t这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。\r\n\r\n\r\n\r\n### 4.1.4 JDK源码解析-Runtime类\r\n\r\nRuntime类就是使用的单例设计模式。\r\n\r\n1. 通过源代码查看使用的是哪儿种单例模式\r\n\r\n   ```java\r\n   public class Runtime {\r\n       private static Runtime currentRuntime = new Runtime();\r\n   \r\n       /**\r\n        * Returns the runtime object associated with the current Java application.\r\n        * Most of the methods of class <code>Runtime</code> are instance\r\n        * methods and must be invoked with respect to the current runtime object.\r\n        *\r\n        * @return  the <code>Runtime</code> object associated with the current\r\n        *          Java application.\r\n        */\r\n       public static Runtime getRuntime() {\r\n           return currentRuntime;\r\n       }\r\n   \r\n       /** Don't let anyone else instantiate this class */\r\n       private Runtime() {}\r\n       ...\r\n   }\r\n   ```\r\n\r\n   从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。\r\n\r\n   \r\n\r\n2. 使用Runtime类中的方法\r\n\r\n   ```java\r\n   public class RuntimeDemo {\r\n       public static void main(String[] args) throws IOException {\r\n           //获取Runtime类对象\r\n           Runtime runtime = Runtime.getRuntime();\r\n   \r\n           //返回 Java 虚拟机中的内存总量。\r\n           System.out.println(runtime.totalMemory());\r\n           //返回 Java 虚拟机试图使用的最大内存量。\r\n           System.out.println(runtime.maxMemory());\r\n   \r\n           //创建一个新的进程执行指定的字符串命令，返回进程对象\r\n           Process process = runtime.exec(\"ipconfig\");\r\n           //获取命令执行后的结果，通过输入流获取\r\n           InputStream inputStream = process.getInputStream();\r\n           byte[] arr = new byte[1024 * 1024* 100];\r\n           int b = inputStream.read(arr);\r\n           System.out.println(new String(arr,0,b,\"gbk\"));\r\n       }\r\n   }\r\n   ```\r\n\r\n# 4，创建型模式\r\n\r\n## 4.2 工厂模式\r\n\r\n### 4.2.1 概述\r\n\r\n需求：设计一个咖啡店点餐系统。  \r\n\r\n设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。\r\n\r\n具体类的设计如下：\r\n\r\n<img src=\"img/工厂设计模式引入.png\" style=\"zoom:80%;\" />\r\n\r\n在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：**解耦**。\r\n\r\n在本教程中会介绍三种工厂的使用\r\n\r\n* 简单工厂模式（不属于GOF的23种经典设计模式）\r\n* 工厂方法模式\r\n* 抽象工厂模式\r\n\r\n\r\n\r\n### 4.2.2 简单工厂模式\r\n\r\n简单工厂不是一种设计模式，反而比较像是一种编程习惯。\r\n\r\n#### 4.2.2.1 结构\r\n\r\n简单工厂包含如下角色：\r\n\r\n* 抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。\r\n* 具体产品 ：实现或者继承抽象产品的子类\r\n* 具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。\r\n\r\n#### 4.2.2.2 实现\r\n\r\n现在使用简单工厂对上面案例进行改进，类图如下：\r\n\r\n<img src=\"img/简单工厂模式.png\" style=\"zoom:70%;\" />\r\n\r\n工厂类代码如下：\r\n\r\n```java\r\npublic class SimpleCoffeeFactory {\r\n\r\n    public Coffee createCoffee(String type) {\r\n        Coffee coffee = null;\r\n        if(\"americano\".equals(type)) {\r\n            coffee = new AmericanoCoffee();\r\n        } else if(\"latte\".equals(type)) {\r\n            coffee = new LatteCoffee();\r\n        }\r\n        return coffee;\r\n    }\r\n}\r\n```\r\n\r\n工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。\r\n\r\n后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。\r\n\r\n#### 4.2.2.4 优缺点\r\n\r\n**优点：**\r\n\r\n封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。\r\n\r\n**缺点：**\r\n\r\n增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。\r\n\r\n#### 4.2.2.3 扩展\r\n\r\n**静态工厂**\r\n\r\n在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：\r\n\r\n```java\r\npublic class SimpleCoffeeFactory {\r\n\r\n    public static Coffee createCoffee(String type) {\r\n        Coffee coffee = null;\r\n        if(\"americano\".equals(type)) {\r\n            coffee = new AmericanoCoffee();\r\n        } else if(\"latte\".equals(type)) {\r\n            coffee = new LatteCoffee();\r\n        }\r\n        return coffe;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 4.2.3 工厂方法模式\r\n\r\n针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。\r\n\r\n#### 4.2.3.1 概念\r\n\r\n定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。\r\n\r\n#### 4.2.3.2 结构\r\n\r\n工厂方法模式的主要角色：\r\n\r\n* 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。\r\n* 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。\r\n* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。\r\n* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。\r\n\r\n#### 4.2.3.3 实现\r\n\r\n使用工厂方法模式对上例进行改进，类图如下：\r\n\r\n<img src=\"img/工厂方法模式.png\" style=\"zoom:70%;\" />\r\n\r\n代码如下：\r\n\r\n抽象工厂：\r\n\r\n```java\r\npublic interface CoffeeFactory {\r\n\r\n    Coffee createCoffee();\r\n}\r\n```\r\n\r\n具体工厂：\r\n\r\n```java\r\npublic class LatteCoffeeFactory implements CoffeeFactory {\r\n\r\n    public Coffee createCoffee() {\r\n        return new LatteCoffee();\r\n    }\r\n}\r\n\r\npublic class AmericanCoffeeFactory implements CoffeeFactory {\r\n\r\n    public Coffee createCoffee() {\r\n        return new AmericanCoffee();\r\n    }\r\n}\r\n```\r\n\r\n咖啡店类：\r\n\r\n```java\r\npublic class CoffeeStore {\r\n\r\n    private CoffeeFactory factory;\r\n\r\n    public CoffeeStore(CoffeeFactory factory) {\r\n        this.factory = factory;\r\n    }\r\n\r\n    public Coffee orderCoffee(String type) {\r\n        Coffee coffee = factory.createCoffee();\r\n        coffee.addMilk();\r\n        coffee.addsugar();\r\n        return coffee;\r\n    }\r\n}\r\n```\r\n\r\n从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。\r\n\r\n工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。\r\n\r\n#### 4.2.3.4 优缺点\r\n\r\n**优点：**\r\n\r\n- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；\r\n- 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；\r\n\r\n**缺点：**\r\n\r\n* 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 4.2.4 抽象工厂模式\r\n\r\n前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。\r\n\r\n这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。\r\n\r\n本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。\r\n\r\n<img src=\"img/image-20200401214509176.png\" style=\"zoom:67%;\" />\r\n\r\n<img src=\"img/image-20200401222951963.png\" style=\"zoom:67%;\" />\r\n\r\n#### 4.2.4.1 概念\r\n\r\n是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\r\n\r\n抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\r\n\r\n#### 4.2.4.2 结构\r\n\r\n抽象工厂模式的主要角色如下：\r\n\r\n* 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。\r\n* 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\r\n* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\r\n* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。\r\n\r\n#### 4.2.4.2 实现\r\n\r\n现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：\r\n\r\n<img src=\"img/抽象工厂模式.png\" style=\"zoom:67%;\" />\r\n\r\n代码如下：\r\n\r\n抽象工厂：\r\n\r\n```java\r\npublic interface DessertFactory {\r\n\r\n    Coffee createCoffee();\r\n\r\n    Dessert createDessert();\r\n}\r\n```\r\n\r\n具体工厂：\r\n\r\n```java\r\n//美式甜点工厂\r\npublic class AmericanDessertFactory implements DessertFactory {\r\n\r\n    public Coffee createCoffee() {\r\n        return new AmericanCoffee();\r\n    }\r\n\r\n    public Dessert createDessert() {\r\n        return new MatchaMousse();\r\n    }\r\n}\r\n//意大利风味甜点工厂\r\npublic class ItalyDessertFactory implements DessertFactory {\r\n\r\n    public Coffee createCoffee() {\r\n        return new LatteCoffee();\r\n    }\r\n\r\n    public Dessert createDessert() {\r\n        return new Tiramisu();\r\n    }\r\n}\r\n```\r\n\r\n如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。\r\n\r\n#### 4.2.4.3 优缺点\r\n\r\n**优点：**\r\n\r\n当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。\r\n\r\n**缺点：**\r\n\r\n当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。\r\n\r\n#### 4.2.4.4 使用场景\r\n\r\n* 当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。\r\n\r\n* 系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。\r\n\r\n* 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。\r\n\r\n如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。\r\n\r\n\r\n\r\n\r\n\r\n### 4.2.5 模式扩展\r\n\r\n**简单工厂+配置文件解除耦合**\r\n\r\n可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。\r\n\r\n第一步：定义配置文件\r\n\r\n为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties\r\n\r\n```properties\r\namerican=com.itheima.pattern.factory.config_factory.AmericanCoffee\r\nlatte=com.itheima.pattern.factory.config_factory.LatteCoffee\r\n```\r\n\r\n第二步：改进工厂类\r\n\r\n```java\r\npublic class CoffeeFactory {\r\n\r\n    private static Map<String,Coffee> map = new HashMap();\r\n\r\n    static {\r\n        Properties p = new Properties();\r\n        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(\"bean.properties\");\r\n        try {\r\n            p.load(is);\r\n            //遍历Properties集合对象\r\n            Set<Object> keys = p.keySet();\r\n            for (Object key : keys) {\r\n                //根据键获取值（全类名）\r\n                String className = p.getProperty((String) key);\r\n                //获取字节码对象\r\n                Class clazz = Class.forName(className);\r\n                Coffee obj = (Coffee) clazz.newInstance();\r\n                map.put((String)key,obj);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public static Coffee createCoffee(String name) {\r\n\r\n        return map.get(name);\r\n    }\r\n}\r\n```\r\n\r\n静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。\r\n\r\n\r\n\r\n### 4.2.6 JDK源码解析-Collection.iterator方法\r\n\r\n```java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        List<String> list = new ArrayList<>();\r\n        list.add(\"令狐冲\");\r\n        list.add(\"风清扬\");\r\n        list.add(\"任我行\");\r\n\r\n        //获取迭代器对象\r\n        Iterator<String> it = list.iterator();\r\n        //使用迭代器遍历\r\n        while(it.hasNext()) {\r\n            String ele = it.next();\r\n            System.out.println(ele);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：\r\n\r\n<img src=\"img/JDK源码解析.png\" style=\"zoom:75%;\" />\r\n\r\nCollection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。\r\n\r\n> 另：\r\n>\r\n> ​\t1,DateForamt类中的getInstance()方法使用的是工厂模式；\r\n>\r\n> ​\t2,Calendar类中的getInstance()方法使用的是工厂模式；\r\n\r\n\r\n\r\n## 4.3 原型模式\r\n\r\n### 4.3.1 概述\r\n\r\n用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。\r\n\r\n### 4.3.2 结构\r\n\r\n原型模式包含如下角色：\r\n\r\n* 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。\r\n* 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。\r\n* 访问类：使用具体原型类中的 clone() 方法来复制新的对象。\r\n\r\n接口类图如下：\r\n\r\n![](img\\原型模式.png)\r\n\r\n### 4.3.3 实现\r\n\r\n原型模式的克隆分为浅克隆和深克隆。\r\n\r\n> 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。\r\n>\r\n> 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。\r\n\r\nJava中的Object类中提供了 `clone()` 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：\r\n\r\n**Realizetype（具体的原型类）：**\r\n\r\n```java\r\npublic class Realizetype implements Cloneable {\r\n\r\n    public Realizetype() {\r\n        System.out.println(\"具体的原型对象创建完成！\");\r\n    }\r\n\r\n    @Override\r\n    protected Realizetype clone() throws CloneNotSupportedException {\r\n        System.out.println(\"具体原型复制成功！\");\r\n        return (Realizetype) super.clone();\r\n    }\r\n}\r\n```\r\n\r\n**PrototypeTest（测试访问类）：**\r\n\r\n```java\r\npublic class PrototypeTest {\r\n    public static void main(String[] args) throws CloneNotSupportedException {\r\n        Realizetype r1 = new Realizetype();\r\n        Realizetype r2 = r1.clone();\r\n\r\n        System.out.println(\"对象r1和r2是同一个对象？\" + (r1 == r2));\r\n    }\r\n}\r\n```\r\n\r\n### 4.3.4 案例\r\n\r\n**用原型模式生成“三好学生”奖状**\r\n\r\n同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。\r\n\r\n类图如下：\r\n\r\n<img src=\"img\\原型模式1.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//奖状类\r\npublic class Citation implements Cloneable {\r\n    private String name;\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return (this.name);\r\n    }\r\n\r\n    public void show() {\r\n        System.out.println(name + \"同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\");\r\n    }\r\n\r\n    @Override\r\n    public Citation clone() throws CloneNotSupportedException {\r\n        return (Citation) super.clone();\r\n    }\r\n}\r\n\r\n//测试访问类\r\npublic class CitationTest {\r\n    public static void main(String[] args) throws CloneNotSupportedException {\r\n        Citation c1 = new Citation();\r\n        c1.setName(\"张三\");\r\n\r\n        //复制奖状\r\n        Citation c2 = c1.clone();\r\n        //将奖状的名字修改李四\r\n        c2.setName(\"李四\");\r\n\r\n        c1.show();\r\n        c2.show();\r\n    }\r\n}\r\n```\r\n\r\n### 4.3.5 使用场景\r\n\r\n* 对象的创建非常复杂，可以使用原型模式快捷的创建对象。\r\n* 性能和安全要求比较高。\r\n\r\n### 4.3.6 扩展（深克隆）\r\n\r\n将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：\r\n\r\n```java\r\n//奖状类\r\npublic class Citation implements Cloneable {\r\n    private Student stu;\r\n\r\n    public Student getStu() {\r\n        return stu;\r\n    }\r\n\r\n    public void setStu(Student stu) {\r\n        this.stu = stu;\r\n    }\r\n\r\n    void show() {\r\n        System.out.println(stu.getName() + \"同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！\");\r\n    }\r\n\r\n    @Override\r\n    public Citation clone() throws CloneNotSupportedException {\r\n        return (Citation) super.clone();\r\n    }\r\n}\r\n\r\n//学生类\r\npublic class Student {\r\n    private String name;\r\n    private String address;\r\n\r\n    public Student(String name, String address) {\r\n        this.name = name;\r\n        this.address = address;\r\n    }\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class CitationTest {\r\n    public static void main(String[] args) throws CloneNotSupportedException {\r\n\r\n        Citation c1 = new Citation();\r\n        Student stu = new Student(\"张三\", \"西安\");\r\n        c1.setStu(stu);\r\n\r\n        //复制奖状\r\n        Citation c2 = c1.clone();\r\n        //获取c2奖状所属学生对象\r\n        Student stu1 = c2.getStu();\r\n        stu1.setName(\"李四\");\r\n\r\n        //判断stu对象和stu1对象是否是同一个对象\r\n        System.out.println(\"stu和stu1是同一个对象？\" + (stu == stu1));\r\n\r\n        c1.show();\r\n        c2.show();\r\n    }\r\n}\r\n```\r\n\r\n运行结果为：\r\n\r\n<img src=\"img\\原型模式2.png\" style=\"zoom:80%;\" />\r\n\r\n<font color=\"red\">说明：</font>\r\n\r\n​\tstu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：\r\n\r\n```java\r\npublic class CitationTest1 {\r\n    public static void main(String[] args) throws Exception {\r\n        Citation c1 = new Citation();\r\n        Student stu = new Student(\"张三\", \"西安\");\r\n        c1.setStu(stu);\r\n\r\n        //创建对象输出流对象\r\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"));\r\n        //将c1对象写出到文件中\r\n        oos.writeObject(c1);\r\n        oos.close();\r\n\r\n        //创建对象出入流对象\r\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"C:\\\\Users\\\\Think\\\\Desktop\\\\b.txt\"));\r\n        //读取对象\r\n        Citation c2 = (Citation) ois.readObject();\r\n        //获取c2奖状所属学生对象\r\n        Student stu1 = c2.getStu();\r\n        stu1.setName(\"李四\");\r\n\r\n        //判断stu对象和stu1对象是否是同一个对象\r\n        System.out.println(\"stu和stu1是同一个对象？\" + (stu == stu1));\r\n\r\n        c1.show();\r\n        c2.show();\r\n    }\r\n}\r\n```\r\n\r\n运行结果为：\r\n\r\n<img src=\"img\\原型模式3.png\" style=\"zoom:80%;\" />\r\n\r\n> 注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。\r\n\r\n\r\n\r\n## 4.5 建造者模式\r\n\r\n### 4.4.1 概述\r\n\r\n将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。\r\n\r\n<img src=\"img/image-20200413225341516.png\" style=\"zoom:60%;\" />\r\n\r\n* 分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。\r\n* 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。\r\n* 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。\r\n\r\n\r\n\r\n### 4.4.2 结构\r\n\r\n建造者（Builder）模式包含如下角色：\r\n\r\n* 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 \r\n\r\n* 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 \r\n\r\n* 产品类（Product）：要创建的复杂对象。\r\n\r\n* 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 \r\n\r\n类图如下：\r\n\r\n<img src=\"img/建造者模式.png\" style=\"zoom:80%;\" />\r\n\r\n\r\n\r\n### 4.4.3 实例\r\n\r\n**创建共享单车**\r\n\r\n生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。\r\n\r\n这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：\r\n\r\n<img src=\"img/建造者模式1.png\" style=\"zoom:80%;\" />\r\n\r\n具体的代码如下：\r\n\r\n```java\r\n//自行车类\r\npublic class Bike {\r\n    private String frame;\r\n    private String seat;\r\n\r\n    public String getFrame() {\r\n        return frame;\r\n    }\r\n\r\n    public void setFrame(String frame) {\r\n        this.frame = frame;\r\n    }\r\n\r\n    public String getSeat() {\r\n        return seat;\r\n    }\r\n\r\n    public void setSeat(String seat) {\r\n        this.seat = seat;\r\n    }\r\n}\r\n\r\n// 抽象 builder 类\r\npublic abstract class Builder {\r\n\r\n    protected Bike mBike = new Bike();\r\n\r\n    public abstract void buildFrame();\r\n    public abstract void buildSeat();\r\n    public abstract Bike createBike();\r\n}\r\n\r\n//摩拜单车Builder类\r\npublic class MobikeBuilder extends Builder {\r\n\r\n    @Override\r\n    public void buildFrame() {\r\n        mBike.setFrame(\"铝合金车架\");\r\n    }\r\n\r\n    @Override\r\n    public void buildSeat() {\r\n        mBike.setSeat(\"真皮车座\");\r\n    }\r\n\r\n    @Override\r\n    public Bike createBike() {\r\n        return mBike;\r\n    }\r\n}\r\n\r\n//ofo单车Builder类\r\npublic class OfoBuilder extends Builder {\r\n\r\n    @Override\r\n    public void buildFrame() {\r\n        mBike.setFrame(\"碳纤维车架\");\r\n    }\r\n\r\n    @Override\r\n    public void buildSeat() {\r\n        mBike.setSeat(\"橡胶车座\");\r\n    }\r\n\r\n    @Override\r\n    public Bike createBike() {\r\n        return mBike;\r\n    }\r\n}\r\n\r\n//指挥者类\r\npublic class Director {\r\n    private Builder mBuilder;\r\n\r\n    public Director(Builder builder) {\r\n        mBuilder = builder;\r\n    }\r\n\r\n    public Bike construct() {\r\n        mBuilder.buildFrame();\r\n        mBuilder.buildSeat();\r\n        return mBuilder.createBike();\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        showBike(new OfoBuilder());\r\n        showBike(new MobikeBuilder());\r\n    }\r\n    private static void showBike(Builder builder) {\r\n        Director director = new Director(builder);\r\n        Bike bike = director.construct();\r\n        System.out.println(bike.getFrame());\r\n        System.out.println(bike.getSeat());\r\n    }\r\n}\r\n```\r\n\r\n**注意：**\r\n\r\n上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合\r\n\r\n```java\r\n// 抽象 builder 类\r\npublic abstract class Builder {\r\n\r\n    protected Bike mBike = new Bike();\r\n\r\n    public abstract void buildFrame();\r\n    public abstract void buildSeat();\r\n    public abstract Bike createBike();\r\n    \r\n    public Bike construct() {\r\n        this.buildFrame();\r\n        this.BuildSeat();\r\n        return this.createBike();\r\n    }\r\n}\r\n```\r\n\r\n**说明：**\r\n\r\n这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。\r\n\r\n### 4.4.4 优缺点\r\n\r\n**优点：**\r\n\r\n- 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。\r\n- 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。\r\n- 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。\r\n- 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。\r\n\r\n**缺点：**\r\n\r\n造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。\r\n\r\n\r\n\r\n### 4.4.5 使用场景\r\n\r\n建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。\r\n\r\n- 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。\r\n- 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。\r\n\r\n\r\n\r\n### 4.4.6 模式扩展\r\n\r\n建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。\r\n\r\n重构前代码如下：\r\n\r\n```java\r\npublic class Phone {\r\n    private String cpu;\r\n    private String screen;\r\n    private String memory;\r\n    private String mainboard;\r\n\r\n    public Phone(String cpu, String screen, String memory, String mainboard) {\r\n        this.cpu = cpu;\r\n        this.screen = screen;\r\n        this.memory = memory;\r\n        this.mainboard = mainboard;\r\n    }\r\n\r\n    public String getCpu() {\r\n        return cpu;\r\n    }\r\n\r\n    public void setCpu(String cpu) {\r\n        this.cpu = cpu;\r\n    }\r\n\r\n    public String getScreen() {\r\n        return screen;\r\n    }\r\n\r\n    public void setScreen(String screen) {\r\n        this.screen = screen;\r\n    }\r\n\r\n    public String getMemory() {\r\n        return memory;\r\n    }\r\n\r\n    public void setMemory(String memory) {\r\n        this.memory = memory;\r\n    }\r\n\r\n    public String getMainboard() {\r\n        return mainboard;\r\n    }\r\n\r\n    public void setMainboard(String mainboard) {\r\n        this.mainboard = mainboard;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Phone{\" +\r\n                \"cpu='\" + cpu + '\\'' +\r\n                \", screen='\" + screen + '\\'' +\r\n                \", memory='\" + memory + '\\'' +\r\n                \", mainboard='\" + mainboard + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //构建Phone对象\r\n        Phone phone = new Phone(\"intel\",\"三星屏幕\",\"金士顿\",\"华硕\");\r\n        System.out.println(phone);\r\n    }\r\n}\r\n```\r\n\r\n上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。\r\n\r\n重构后代码：\r\n\r\n```java\r\npublic class Phone {\r\n\r\n    private String cpu;\r\n    private String screen;\r\n    private String memory;\r\n    private String mainboard;\r\n\r\n    private Phone(Builder builder) {\r\n        cpu = builder.cpu;\r\n        screen = builder.screen;\r\n        memory = builder.memory;\r\n        mainboard = builder.mainboard;\r\n    }\r\n\r\n    public static final class Builder {\r\n        private String cpu;\r\n        private String screen;\r\n        private String memory;\r\n        private String mainboard;\r\n\r\n        public Builder() {}\r\n\r\n        public Builder cpu(String val) {\r\n            cpu = val;\r\n            return this;\r\n        }\r\n        public Builder screen(String val) {\r\n            screen = val;\r\n            return this;\r\n        }\r\n        public Builder memory(String val) {\r\n            memory = val;\r\n            return this;\r\n        }\r\n        public Builder mainboard(String val) {\r\n            mainboard = val;\r\n            return this;\r\n        }\r\n        public Phone build() {\r\n            return new Phone(this);}\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Phone{\" +\r\n                \"cpu='\" + cpu + '\\'' +\r\n                \", screen='\" + screen + '\\'' +\r\n                \", memory='\" + memory + '\\'' +\r\n                \", mainboard='\" + mainboard + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Phone phone = new Phone.Builder()\r\n                .cpu(\"intel\")\r\n                .mainboard(\"华硕\")\r\n                .memory(\"金士顿\")\r\n                .screen(\"三星\")\r\n                .build();\r\n        System.out.println(phone);\r\n    }\r\n}\r\n```\r\n\r\n重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。\r\n\r\n\r\n\r\n## 4.6 创建者模式对比\r\n\r\n### 4.6.1 工厂方法模式VS建造者模式\r\n\r\n工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。\r\n\r\n我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。\r\n\r\n### 4.6.2 抽象工厂模式VS建造者模式\r\n\r\n抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。\r\n\r\n建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。\r\n\r\n如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。\r\n\r\n\r\n# 5，结构型模式\r\n\r\n结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。\r\n\r\n由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。\r\n\r\n结构型模式分为以下 7 种：\r\n\r\n* 代理模式\r\n* 适配器模式\r\n* 装饰者模式\r\n* 桥接模式\r\n* 外观模式\r\n* 组合模式\r\n* 享元模式\r\n\r\n\r\n\r\n## 5.1 代理模式\r\n\r\n### 5.1.1 概述\r\n\r\n由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。\r\n\r\nJava中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。\r\n\r\n### 5.1.2 结构\r\n\r\n代理（Proxy）模式分为三种角色：\r\n\r\n* 抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。\r\n* 真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。\r\n* 代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。\r\n\r\n### 5.1.3 静态代理\r\n\r\n我们通过案例来感受一下静态代理。\r\n\r\n【例】火车站卖票\r\n\r\n如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：\r\n\r\n<img src=\"img\\静态代理.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//卖票接口\r\npublic interface SellTickets {\r\n    void sell();\r\n}\r\n\r\n//火车站  火车站具有卖票功能，所以需要实现SellTickets接口\r\npublic class TrainStation implements SellTickets {\r\n\r\n    public void sell() {\r\n        System.out.println(\"火车站卖票\");\r\n    }\r\n}\r\n\r\n//代售点\r\npublic class ProxyPoint implements SellTickets {\r\n\r\n    private TrainStation station = new TrainStation();\r\n\r\n    public void sell() {\r\n        System.out.println(\"代理点收取一些服务费用\");\r\n        station.sell();\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        ProxyPoint pp = new ProxyPoint();\r\n        pp.sell();\r\n    }\r\n}\r\n```\r\n\r\n从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。\r\n\r\n### 5.1.4 JDK动态代理\r\n\r\n接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。\r\n\r\n代码如下：\r\n\r\n```java\r\n//卖票接口\r\npublic interface SellTickets {\r\n    void sell();\r\n}\r\n\r\n//火车站  火车站具有卖票功能，所以需要实现SellTickets接口\r\npublic class TrainStation implements SellTickets {\r\n\r\n    public void sell() {\r\n        System.out.println(\"火车站卖票\");\r\n    }\r\n}\r\n\r\n//代理工厂，用来创建代理对象\r\npublic class ProxyFactory {\r\n\r\n    private TrainStation station = new TrainStation();\r\n\r\n    public SellTickets getProxyObject() {\r\n        //使用Proxy获取代理对象\r\n        /*\r\n            newProxyInstance()方法参数说明：\r\n                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可\r\n                Class<?>[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口\r\n                InvocationHandler h ： 代理对象的调用处理程序\r\n         */\r\n        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),\r\n                station.getClass().getInterfaces(),\r\n                new InvocationHandler() {\r\n                    /*\r\n                        InvocationHandler中invoke方法参数说明：\r\n                            proxy ： 代理对象\r\n                            method ： 对应于在代理对象上调用的接口方法的 Method 实例\r\n                            args ： 代理对象调用接口方法时传递的实际参数\r\n                     */\r\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n\r\n                        System.out.println(\"代理点收取一些服务费用(JDK动态代理方式)\");\r\n                        //执行真实对象\r\n                        Object result = method.invoke(station, args);\r\n                        return result;\r\n                    }\r\n                });\r\n        return sellTickets;\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //获取代理对象\r\n        ProxyFactory factory = new ProxyFactory();\r\n        \r\n        SellTickets proxyObject = factory.getProxyObject();\r\n        proxyObject.sell();\r\n    }\r\n}\r\n```\r\n\r\n<font color=\"red\">使用了动态代理，我们思考下面问题：</font>\r\n\r\n* ProxyFactory是代理类吗？\r\n\r\n  ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：\r\n\r\n  ```java\r\n  package com.sun.proxy;\r\n  \r\n  import com.itheima.proxy.dynamic.jdk.SellTickets;\r\n  import java.lang.reflect.InvocationHandler;\r\n  import java.lang.reflect.Method;\r\n  import java.lang.reflect.Proxy;\r\n  import java.lang.reflect.UndeclaredThrowableException;\r\n  \r\n  public final class $Proxy0 extends Proxy implements SellTickets {\r\n      private static Method m1;\r\n      private static Method m2;\r\n      private static Method m3;\r\n      private static Method m0;\r\n  \r\n      public $Proxy0(InvocationHandler invocationHandler) {\r\n          super(invocationHandler);\r\n      }\r\n  \r\n      static {\r\n          try {\r\n              m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\r\n              m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]);\r\n              m3 = Class.forName(\"com.itheima.proxy.dynamic.jdk.SellTickets\").getMethod(\"sell\", new Class[0]);\r\n              m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]);\r\n              return;\r\n          }\r\n          catch (NoSuchMethodException noSuchMethodException) {\r\n              throw new NoSuchMethodError(noSuchMethodException.getMessage());\r\n          }\r\n          catch (ClassNotFoundException classNotFoundException) {\r\n              throw new NoClassDefFoundError(classNotFoundException.getMessage());\r\n          }\r\n      }\r\n  \r\n      public final boolean equals(Object object) {\r\n          try {\r\n              return (Boolean)this.h.invoke(this, m1, new Object[]{object});\r\n          }\r\n          catch (Error | RuntimeException throwable) {\r\n              throw throwable;\r\n          }\r\n          catch (Throwable throwable) {\r\n              throw new UndeclaredThrowableException(throwable);\r\n          }\r\n      }\r\n  \r\n      public final String toString() {\r\n          try {\r\n              return (String)this.h.invoke(this, m2, null);\r\n          }\r\n          catch (Error | RuntimeException throwable) {\r\n              throw throwable;\r\n          }\r\n          catch (Throwable throwable) {\r\n              throw new UndeclaredThrowableException(throwable);\r\n          }\r\n      }\r\n  \r\n      public final int hashCode() {\r\n          try {\r\n              return (Integer)this.h.invoke(this, m0, null);\r\n          }\r\n          catch (Error | RuntimeException throwable) {\r\n              throw throwable;\r\n          }\r\n          catch (Throwable throwable) {\r\n              throw new UndeclaredThrowableException(throwable);\r\n          }\r\n      }\r\n  \r\n      public final void sell() {\r\n          try {\r\n              this.h.invoke(this, m3, null);\r\n              return;\r\n          }\r\n          catch (Error | RuntimeException throwable) {\r\n              throw throwable;\r\n          }\r\n          catch (Throwable throwable) {\r\n              throw new UndeclaredThrowableException(throwable);\r\n          }\r\n      }\r\n  }\r\n  ```\r\n\r\n  从上面的类中，我们可以看到以下几个信息：\r\n\r\n  * 代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。\r\n  * 代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。\r\n\r\n* 动态代理的执行流程是什么样？\r\n\r\n  下面是摘取的重点代码：\r\n\r\n  ```java\r\n  //程序运行过程中动态生成的代理类\r\n  public final class $Proxy0 extends Proxy implements SellTickets {\r\n      private static Method m3;\r\n  \r\n      public $Proxy0(InvocationHandler invocationHandler) {\r\n          super(invocationHandler);\r\n      }\r\n  \r\n      static {\r\n          m3 = Class.forName(\"com.itheima.proxy.dynamic.jdk.SellTickets\").getMethod(\"sell\", new Class[0]);\r\n      }\r\n  \r\n      public final void sell() {\r\n          this.h.invoke(this, m3, null);\r\n      }\r\n  }\r\n  \r\n  //Java提供的动态代理相关类\r\n  public class Proxy implements java.io.Serializable {\r\n  \tprotected InvocationHandler h;\r\n  \t \r\n  \tprotected Proxy(InvocationHandler h) {\r\n          this.h = h;\r\n      }\r\n  }\r\n  \r\n  //代理工厂类\r\n  public class ProxyFactory {\r\n  \r\n      private TrainStation station = new TrainStation();\r\n  \r\n      public SellTickets getProxyObject() {\r\n          SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),\r\n                  station.getClass().getInterfaces(),\r\n                  new InvocationHandler() {\r\n                      \r\n                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n  \r\n                          System.out.println(\"代理点收取一些服务费用(JDK动态代理方式)\");\r\n                          Object result = method.invoke(station, args);\r\n                          return result;\r\n                      }\r\n                  });\r\n          return sellTickets;\r\n      }\r\n  }\r\n  \r\n  \r\n  //测试访问类\r\n  public class Client {\r\n      public static void main(String[] args) {\r\n          //获取代理对象\r\n          ProxyFactory factory = new ProxyFactory();\r\n          SellTickets proxyObject = factory.getProxyObject();\r\n          proxyObject.sell();\r\n      }\r\n  }\r\n  ```\r\n\r\n\r\n执行流程如下：\r\n\r\n  1. 在测试类中通过代理对象调用sell()方法\r\n  2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法\r\n  3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法\r\n  4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法\r\n\r\n### 5.1.5 CGLIB动态代理\r\n\r\n同样是上面的案例，我们再次使用CGLIB代理实现。\r\n\r\n如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。\r\n\r\nCGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。\r\n\r\nCGLIB是第三方提供的包，所以需要引入jar包的坐标：\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>cglib</groupId>\r\n    <artifactId>cglib</artifactId>\r\n    <version>2.2.2</version>\r\n</dependency>\r\n```\r\n\r\n代码如下：\r\n\r\n```java\r\n//火车站\r\npublic class TrainStation {\r\n\r\n    public void sell() {\r\n        System.out.println(\"火车站卖票\");\r\n    }\r\n}\r\n\r\n//代理工厂\r\npublic class ProxyFactory implements MethodInterceptor {\r\n\r\n    private TrainStation target = new TrainStation();\r\n\r\n    public TrainStation getProxyObject() {\r\n        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数\r\n        Enhancer enhancer =new Enhancer();\r\n        //设置父类的字节码对象\r\n        enhancer.setSuperclass(target.getClass());\r\n        //设置回调函数\r\n        enhancer.setCallback(this);\r\n        //创建代理对象\r\n        TrainStation obj = (TrainStation) enhancer.create();\r\n        return obj;\r\n    }\r\n\r\n    /*\r\n        intercept方法参数说明：\r\n            o ： 代理对象\r\n            method ： 真实对象中的方法的Method实例\r\n            args ： 实际参数\r\n            methodProxy ：代理对象中的方法的method实例\r\n     */\r\n    public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\r\n        System.out.println(\"代理点收取一些服务费用(CGLIB动态代理方式)\");\r\n        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);\r\n        return result;\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //创建代理工厂对象\r\n        ProxyFactory factory = new ProxyFactory();\r\n        //获取代理对象\r\n        TrainStation proxyObject = factory.getProxyObject();\r\n\r\n        proxyObject.sell();\r\n    }\r\n}\r\n```\r\n\r\n### 5.1.6 三种代理的对比\r\n\r\n* jdk代理和CGLIB代理\r\n\r\n  使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。\r\n\r\n  在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。\r\n\r\n* 动态代理和静态代理\r\n\r\n  动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。\r\n\r\n  如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题\r\n\r\n\r\n\r\n### 5.1.7 优缺点\r\n\r\n**优点：**\r\n\r\n- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；\r\n- 代理对象可以扩展目标对象的功能；\r\n- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；\r\n\r\n**缺点：**\r\n\r\n* 增加了系统的复杂度；\r\n\r\n\r\n\r\n### 5.1.8 使用场景 \r\n\r\n* 远程（Remote）代理\r\n\r\n  本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。\r\n\r\n* 防火墙（Firewall）代理\r\n\r\n  当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。\r\n\r\n* 保护（Protect or Access）代理\r\n\r\n  控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。\r\n\r\n\r\n\r\n## 5.2 适配器模式\r\n\r\n### 5.2.1 概述\r\n\r\n如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。\r\n\r\n![](img\\转接头.png)\r\n\r\n**定义：**\r\n\r\n​\t将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。\r\n\r\n​\t适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。\r\n\r\n### 5.2.2 结构\r\n\r\n适配器模式（Adapter）包含以下主要角色：\r\n\r\n* 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。\r\n* 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。\r\n* 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。\r\n\r\n### 5.2.3 类适配器模式\r\n\r\n实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。\r\n\r\n【例】读卡器\r\n\r\n现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。\r\n\r\n类图如下：\r\n\r\n<img src=\"img/适配器模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//SD卡的接口\r\npublic interface SDCard {\r\n    //读取SD卡方法\r\n    String readSD();\r\n    //写入SD卡功能\r\n    void writeSD(String msg);\r\n}\r\n\r\n//SD卡实现类\r\npublic class SDCardImpl implements SDCard {\r\n    public String readSD() {\r\n        String msg = \"sd card read a msg :hello word SD\";\r\n        return msg;\r\n    }\r\n\r\n    public void writeSD(String msg) {\r\n        System.out.println(\"sd card write msg : \" + msg);\r\n    }\r\n}\r\n\r\n//电脑类\r\npublic class Computer {\r\n\r\n    public String readSD(SDCard sdCard) {\r\n        if(sdCard == null) {\r\n            throw new NullPointerException(\"sd card null\");\r\n        }\r\n        return sdCard.readSD();\r\n    }\r\n}\r\n\r\n//TF卡接口\r\npublic interface TFCard {\r\n    //读取TF卡方法\r\n    String readTF();\r\n    //写入TF卡功能\r\n    void writeTF(String msg);\r\n}\r\n\r\n//TF卡实现类\r\npublic class TFCardImpl implements TFCard {\r\n\r\n    public String readTF() {\r\n        String msg =\"tf card read msg : hello word tf card\";\r\n        return msg;\r\n    }\r\n\r\n    public void writeTF(String msg) {\r\n        System.out.println(\"tf card write a msg : \" + msg);\r\n    }\r\n}\r\n\r\n//定义适配器类（SD兼容TF）\r\npublic class SDAdapterTF extends TFCardImpl implements SDCard {\r\n\r\n    public String readSD() {\r\n        System.out.println(\"adapter read tf card \");\r\n        return readTF();\r\n    }\r\n\r\n    public void writeSD(String msg) {\r\n        System.out.println(\"adapter write tf card\");\r\n        writeTF(msg);\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Computer computer = new Computer();\r\n        SDCard sdCard = new SDCardImpl();\r\n        System.out.println(computer.readSD(sdCard));\r\n\r\n        System.out.println(\"------------\");\r\n\r\n        SDAdapterTF adapter = new SDAdapterTF();\r\n        System.out.println(computer.readSD(adapter));\r\n    }\r\n}\r\n```\r\n\r\n类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。\r\n\r\n\r\n\r\n### 5.2.4 对象适配器模式\r\n\r\n实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。\r\n\r\n【例】读卡器\r\n\r\n我们使用对象适配器模式将读卡器的案例进行改写。类图如下：\r\n\r\n<img src=\"img\\对象适配器模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。\r\n\r\n```java\r\n//创建适配器对象（SD兼容TF）\r\npublic class SDAdapterTF  implements SDCard {\r\n\r\n    private TFCard tfCard;\r\n\r\n    public SDAdapterTF(TFCard tfCard) {\r\n        this.tfCard = tfCard;\r\n    }\r\n\r\n    public String readSD() {\r\n        System.out.println(\"adapter read tf card \");\r\n        return tfCard.readTF();\r\n    }\r\n\r\n    public void writeSD(String msg) {\r\n        System.out.println(\"adapter write tf card\");\r\n        tfCard.writeTF(msg);\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Computer computer = new Computer();\r\n        SDCard sdCard = new SDCardImpl();\r\n        System.out.println(computer.readSD(sdCard));\r\n\r\n        System.out.println(\"------------\");\r\n\r\n        TFCard tfCard = new TFCardImpl();\r\n        SDAdapterTF adapter = new SDAdapterTF(tfCard);\r\n        System.out.println(computer.readSD(adapter));\r\n    }\r\n}\r\n```\r\n\r\n> 注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。\r\n\r\n\r\n\r\n### 5.2.5 应用场景\r\n\r\n* 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。\r\n* 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。\r\n\r\n\r\n\r\n### 5.2.6 JDK源码解析\r\n\r\nReader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。\r\n\r\nInputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：\r\n\r\n```java\r\npublic int read() throws IOException {\r\n    return sd.read();\r\n}\r\n\r\npublic int read(char cbuf[], int offset, int length) throws IOException {\r\n    return sd.read(cbuf, offset, length);\r\n}\r\n```\r\n\r\n如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：\r\n\r\n![](img\\适配器模式-jdk源码解析.png)\r\n\r\n从上图可以看出：\r\n\r\n* InputStreamReader是对同样实现了Reader的StreamDecoder的封装。\r\n* StreamDecoder不是Java SE API中的内容，是Sun  JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。\r\n\r\n<font color=\"red\">结论：</font>\r\n\r\n​\t从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。\r\n\r\n\r\n\r\n## 5.3 装饰者模式\r\n\r\n### 5.3.1 概述\r\n\r\n我们先来看一个快餐店的例子。\r\n\r\n快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。\r\n\r\n<img src=\"D:/传智播客/专题/设计模式/成品/笔记/assets/装饰者模式-使用前.png\" style=\"zoom:80%;\" />\r\n\r\n使用继承的方式存在的问题：\r\n\r\n* 扩展性不好\r\n\r\n  如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。\r\n\r\n* 产生过多的子类\r\n\r\n**定义：**\r\n\r\n​\t指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。\r\n\r\n### 5.3.2 结构\r\n\r\n装饰（Decorator）模式中的角色：\r\n\r\n* 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。\r\n* 具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。\r\n* 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。\r\n* 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。\r\n\r\n\r\n\r\n### 5.3.3 案例\r\n\r\n我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。\r\n\r\n类图如下：\r\n\r\n<img src=\"img/装饰者模式.png\" style=\"zoom:75%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//快餐接口\r\npublic abstract class FastFood {\r\n    private float price;\r\n    private String desc;\r\n\r\n    public FastFood() {\r\n    }\r\n\r\n    public FastFood(float price, String desc) {\r\n        this.price = price;\r\n        this.desc = desc;\r\n    }\r\n\r\n    public void setPrice(float price) {\r\n        this.price = price;\r\n    }\r\n\r\n    public float getPrice() {\r\n        return price;\r\n    }\r\n\r\n    public String getDesc() {\r\n        return desc;\r\n    }\r\n\r\n    public void setDesc(String desc) {\r\n        this.desc = desc;\r\n    }\r\n\r\n    public abstract float cost();  //获取价格\r\n}\r\n\r\n//炒饭\r\npublic class FriedRice extends FastFood {\r\n\r\n    public FriedRice() {\r\n        super(10, \"炒饭\");\r\n    }\r\n\r\n    public float cost() {\r\n        return getPrice();\r\n    }\r\n}\r\n\r\n//炒面\r\npublic class FriedNoodles extends FastFood {\r\n\r\n    public FriedNoodles() {\r\n        super(12, \"炒面\");\r\n    }\r\n\r\n    public float cost() {\r\n        return getPrice();\r\n    }\r\n}\r\n\r\n//配料类\r\npublic abstract class Garnish extends FastFood {\r\n\r\n    private FastFood fastFood;\r\n\r\n    public FastFood getFastFood() {\r\n        return fastFood;\r\n    }\r\n\r\n    public void setFastFood(FastFood fastFood) {\r\n        this.fastFood = fastFood;\r\n    }\r\n\r\n    public Garnish(FastFood fastFood, float price, String desc) {\r\n        super(price,desc);\r\n        this.fastFood = fastFood;\r\n    }\r\n}\r\n\r\n//鸡蛋配料\r\npublic class Egg extends Garnish {\r\n\r\n    public Egg(FastFood fastFood) {\r\n        super(fastFood,1,\"鸡蛋\");\r\n    }\r\n\r\n    public float cost() {\r\n        return getPrice() + getFastFood().getPrice();\r\n    }\r\n\r\n    @Override\r\n    public String getDesc() {\r\n        return super.getDesc() + getFastFood().getDesc();\r\n    }\r\n}\r\n\r\n//培根配料\r\npublic class Bacon extends Garnish {\r\n\r\n    public Bacon(FastFood fastFood) {\r\n\r\n        super(fastFood,2,\"培根\");\r\n    }\r\n\r\n    @Override\r\n    public float cost() {\r\n        return getPrice() + getFastFood().getPrice();\r\n    }\r\n\r\n    @Override\r\n    public String getDesc() {\r\n        return super.getDesc() + getFastFood().getDesc();\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //点一份炒饭\r\n        FastFood food = new FriedRice();\r\n        //花费的价格\r\n        System.out.println(food.getDesc() + \" \" + food.cost() + \"元\");\r\n\r\n        System.out.println(\"========\");\r\n        //点一份加鸡蛋的炒饭\r\n        FastFood food1 = new FriedRice();\r\n\r\n        food1 = new Egg(food1);\r\n        //花费的价格\r\n        System.out.println(food1.getDesc() + \" \" + food1.cost() + \"元\");\r\n\r\n        System.out.println(\"========\");\r\n        //点一份加培根的炒面\r\n        FastFood food2 = new FriedNoodles();\r\n        food2 = new Bacon(food2);\r\n        //花费的价格\r\n        System.out.println(food2.getDesc() + \" \" + food2.cost() + \"元\");\r\n    }\r\n}\r\n```\r\n\r\n**好处：**\r\n\r\n* 饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。\r\n\r\n* 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\r\n\r\n\r\n\r\n### 5.3.4 使用场景\r\n\r\n* 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。\r\n\r\n  不能采用继承的情况主要有两类：\r\n\r\n  * 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；\r\n  * 第二类是因为类定义不能继承（如final类）\r\n\r\n* 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\r\n\r\n* 当对象的功能要求可以动态地添加，也可以再动态地撤销时。\r\n\r\n\r\n\r\n### 5.3.5 JDK源码解析\r\n\r\nIO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。\r\n\r\n我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter\r\n\r\n```java\r\npublic class Demo {\r\n    public static void main(String[] args) throws Exception{\r\n        //创建BufferedWriter对象\r\n        //创建FileWriter对象\r\n        FileWriter fw = new FileWriter(\"C:\\\\Users\\\\Think\\\\Desktop\\\\a.txt\");\r\n        BufferedWriter bw = new BufferedWriter(fw);\r\n\r\n        //写数据\r\n        bw.write(\"hello Buffered\");\r\n\r\n        bw.close();\r\n    }\r\n}\r\n```\r\n\r\n使用起来感觉确实像是装饰者模式，接下来看它们的结构：\r\n\r\n<img src=\"img\\装饰者模式-jdk源码.png\" style=\"zoom:80%;\" />\r\n\r\n> <font color=\"red\">小结：</font>\r\n>\r\n> ​\tBufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。\r\n\r\n\r\n\r\n### 5.3.6 代理和装饰者的区别\r\n\r\n静态代理和装饰者模式的区别：\r\n\r\n* 相同点：\r\n  * 都要实现与目标类相同的业务接口\r\n  * 在两个类中都要声明目标对象\r\n  * 都可以在不修改目标类的前提下增强目标方法\r\n* 不同点：\r\n  * 目的不同\r\n    装饰者是为了增强目标对象\r\n    静态代理是为了保护和隐藏目标对象\r\n  * 获取目标对象构建的地方不同\r\n    装饰者是由外界传递进来，可以通过构造方法传递\r\n    静态代理是在代理类内部创建，以此来隐藏目标对象\r\n\r\n\r\n\r\n## 5.4 桥接模式\r\n\r\n### 5.4.1 概述\r\n\r\n现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：\r\n\r\n![](img\\image-20200207194617620.png)\r\n\r\n我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。\r\n\r\n试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。\r\n\r\n**定义：**\r\n\r\n​\t将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。\r\n\r\n\r\n\r\n### 5.4.2 结构\r\n\r\n桥接（Bridge）模式包含以下主要角色：\r\n\r\n* 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。\r\n* 扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。\r\n* 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。\r\n* 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。\r\n\r\n\r\n\r\n### 5.4.3 案例\r\n\r\n【例】视频播放器\r\n\r\n需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。\r\n\r\n类图如下：\r\n\r\n<img src=\"img\\桥接模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//视频文件\r\npublic interface VideoFile {\r\n    void decode(String fileName);\r\n}\r\n\r\n//avi文件\r\npublic class AVIFile implements VideoFile {\r\n    public void decode(String fileName) {\r\n        System.out.println(\"avi视频文件：\"+ fileName);\r\n    }\r\n}\r\n\r\n//rmvb文件\r\npublic class REVBBFile implements VideoFile {\r\n\r\n    public void decode(String fileName) {\r\n        System.out.println(\"rmvb文件：\" + fileName);\r\n    }\r\n}\r\n\r\n//操作系统版本\r\npublic abstract class OperatingSystemVersion {\r\n\r\n    protected VideoFile videoFile;\r\n\r\n    public OperatingSystemVersion(VideoFile videoFile) {\r\n        this.videoFile = videoFile;\r\n    }\r\n\r\n    public abstract void play(String fileName);\r\n}\r\n\r\n//Windows版本\r\npublic class Windows extends OperatingSystem {\r\n\r\n    public Windows(VideoFile videoFile) {\r\n        super(videoFile);\r\n    }\r\n\r\n    public void play(String fileName) {\r\n        videoFile.decode(fileName);\r\n    }\r\n}\r\n\r\n//mac版本\r\npublic class Mac extends OperatingSystemVersion {\r\n\r\n    public Mac(VideoFile videoFile) {\r\n        super(videoFile);\r\n    }\r\n\r\n    public void play(String fileName) {\r\n\t\tvideoFile.decode(fileName);\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        OperatingSystem os = new Windows(new AVIFile());\r\n        os.play(\"战狼3\");\r\n    }\r\n}\r\n```\r\n\r\n**好处：**\r\n\r\n* 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。\r\n\r\n  如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。\r\n\r\n* 实现细节对客户透明\r\n\r\n### 5.4.4 使用场景\r\n\r\n* 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。\r\n* 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。\r\n* 当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。\r\n\r\n\r\n\r\n## 5.5 外观模式\r\n\r\n### 5.5.1 概述\r\n\r\n有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。\r\n\r\n**定义：**\r\n\r\n​\t又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。\r\n\r\n​\t外观（Facade）模式是“迪米特法则”的典型应用\r\n\r\n![](img\\外观模式引入.jpg)\r\n\r\n\r\n\r\n### 5.5.2 结构\r\n\r\n外观（Facade）模式包含以下主要角色：\r\n\r\n* 外观（Facade）角色：为多个子系统对外提供一个共同的接口。\r\n* 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。\r\n\r\n\r\n\r\n### 5.5.3 案例\r\n\r\n【例】智能家电控制\r\n\r\n小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：\r\n\r\n<img src=\"img/外观模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//灯类\r\npublic class Light {\r\n    public void on() {\r\n        System.out.println(\"打开了灯....\");\r\n    }\r\n\r\n    public void off() {\r\n        System.out.println(\"关闭了灯....\");\r\n    }\r\n}\r\n\r\n//电视类\r\npublic class TV {\r\n    public void on() {\r\n        System.out.println(\"打开了电视....\");\r\n    }\r\n\r\n    public void off() {\r\n        System.out.println(\"关闭了电视....\");\r\n    }\r\n}\r\n\r\n//控制类\r\npublic class AirCondition {\r\n    public void on() {\r\n        System.out.println(\"打开了空调....\");\r\n    }\r\n\r\n    public void off() {\r\n        System.out.println(\"关闭了空调....\");\r\n    }\r\n}\r\n\r\n//智能音箱\r\npublic class SmartAppliancesFacade {\r\n\r\n    private Light light;\r\n    private TV tv;\r\n    private AirCondition airCondition;\r\n\r\n    public SmartAppliancesFacade() {\r\n        light = new Light();\r\n        tv = new TV();\r\n        airCondition = new AirCondition();\r\n    }\r\n\r\n    public void say(String message) {\r\n        if(message.contains(\"打开\")) {\r\n            on();\r\n        } else if(message.contains(\"关闭\")) {\r\n            off();\r\n        } else {\r\n            System.out.println(\"我还听不懂你说的！！！\");\r\n        }\r\n    }\r\n\r\n    //起床后一键开电器\r\n    private void on() {\r\n        System.out.println(\"起床了\");\r\n        light.on();\r\n        tv.on();\r\n        airCondition.on();\r\n    }\r\n\r\n    //睡觉一键关电器\r\n    private void off() {\r\n        System.out.println(\"睡觉了\");\r\n        light.off();\r\n        tv.off();\r\n        airCondition.off();\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //创建外观对象\r\n        SmartAppliancesFacade facade = new SmartAppliancesFacade();\r\n        //客户端直接与外观对象进行交互\r\n        facade.say(\"打开家电\");\r\n        facade.say(\"关闭家电\");\r\n    }\r\n}\r\n```\r\n\r\n**好处：**\r\n\r\n* 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。\r\n* 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。\r\n\r\n**缺点：**\r\n\r\n* 不符合开闭原则，修改很麻烦\r\n\r\n\r\n\r\n### 5.5.4 使用场景\r\n\r\n* 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。\r\n* 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。\r\n* 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。\r\n\r\n\r\n\r\n### 5.5.5 源码解析\r\n\r\n使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。\r\n\r\n<img src=\"img/image-20200207234545691.png\" style=\"zoom:60%;\" />\r\n\r\nRequestFacade类就使用了外观模式。先看结构图：\r\n\r\n<img src=\"img/外观模式-jdk源码解析.png\" style=\"zoom:70%;\" />\r\n\r\n**为什么在此处使用外观模式呢？**\r\n\r\n​\t定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。\r\n\r\n# 5，结构型模式\r\n\r\n## 5.6 组合模式\r\n\r\n### 5.6.1 概述\r\n\r\n<img src=\"img/image-20200208180417291.png\" style=\"zoom:60%;\" />\r\n\r\n​\t对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。\r\n\r\n**定义：**\r\n\r\n​\t又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。\r\n\r\n\r\n\r\n### 5.6.2 结构\r\n\r\n组合模式主要包含三种角色：\r\n\r\n* 抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。\r\n* 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。\r\n* 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。\r\n\r\n\r\n\r\n### 5.6.3 案例实现\r\n\r\n【例】软件菜单\r\n\r\n如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。\r\n\r\n<img src=\"img/image-20200208182322313.png\" style=\"zoom:80%;\" />\r\n\r\n要实现该案例，我们先画出类图：\r\n\r\n<img src=\"img/组合模式.png\" style=\"zoom:80%;\" />\r\n\r\n**代码实现：**\r\n\r\n不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。\r\n\r\n```java\r\n//菜单组件  不管是菜单还是菜单项，都应该继承该类\r\npublic abstract class MenuComponent {\r\n\r\n    protected String name;\r\n    protected int level;\r\n\r\n    //添加菜单\r\n    public void add(MenuComponent menuComponent){\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    //移除菜单\r\n    public void remove(MenuComponent menuComponent){\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    //获取指定的子菜单\r\n    public MenuComponent getChild(int i){\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n    //获取菜单名称\r\n    public String getName(){\r\n        return name;\r\n    }\r\n\r\n    public void print(){\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\r\n```\r\n\r\n这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。\r\n\r\n```java\r\npublic class Menu extends MenuComponent {\r\n\r\n    private List<MenuComponent> menuComponentList;\r\n\r\n    public Menu(String name,int level){\r\n        this.level = level;\r\n        this.name = name;\r\n        menuComponentList = new ArrayList<MenuComponent>();\r\n    }\r\n\r\n    @Override\r\n    public void add(MenuComponent menuComponent) {\r\n        menuComponentList.add(menuComponent);\r\n    }\r\n\r\n    @Override\r\n    public void remove(MenuComponent menuComponent) {\r\n        menuComponentList.remove(menuComponent);\r\n    }\r\n\r\n    @Override\r\n    public MenuComponent getChild(int i) {\r\n        return menuComponentList.get(i);\r\n    }\r\n\r\n    @Override\r\n    public void print() {\r\n\r\n        for (int i = 1; i < level; i++) {\r\n            System.out.print(\"--\");\r\n        }\r\n        System.out.println(name);\r\n        for (MenuComponent menuComponent : menuComponentList) {\r\n            menuComponent.print();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nMenu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。\r\n\r\n```java\r\npublic class MenuItem extends MenuComponent {\r\n\r\n    public MenuItem(String name,int level) {\r\n        this.name = name;\r\n        this.level = level;\r\n    }\r\n\r\n    @Override\r\n    public void print() {\r\n        for (int i = 1; i < level; i++) {\r\n            System.out.print(\"--\");\r\n        }\r\n        System.out.println(name);\r\n    }\r\n}\r\n```\r\n\r\nMenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。\r\n\r\n\r\n\r\n### 5.6.4 组合模式的分类\r\n\r\n在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。\r\n\r\n* 透明组合模式\r\n\r\n  透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 `MenuComponent` 声明了 `add`、`remove` 、`getChild` 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。\r\n\r\n  透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）\r\n\r\n* 安全组合模式\r\n\r\n  在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 `Menu` 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。\r\n\r\n  <img src=\"img/组合模式-安全性.png\" style=\"zoom:80%;\" />\r\n\r\n\r\n\r\n### 5.6.5 优点\r\n\r\n* 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。\r\n* 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。\r\n* 在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。\r\n* 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。\r\n\r\n\r\n\r\n### 5.6.6 使用场景\r\n\r\n组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。\r\n\r\n\r\n\r\n## 5.7 享元模式\r\n\r\n### 5.7.1 概述\r\n\r\n**定义：**\r\n\r\n​\t运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。\r\n\r\n\r\n\r\n### 5.7.2 结构\r\n\r\n享元（Flyweight ）模式中存在以下两种状态：\r\n\r\n1. 内部状态，即不会随着环境的改变而改变的可共享部分。\r\n2. 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。\r\n\r\n享元模式的主要有以下角色：\r\n\r\n* 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。\r\n* 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。\r\n* 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。\r\n* 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。\r\n\r\n\r\n\r\n### 5.7.3 案例实现\r\n\r\n【例】俄罗斯方块\r\n\r\n下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。\r\n\r\n<img src=\"img/俄罗斯方块.jpeg\" style=\"zoom:60%;\" />\r\n\r\n\r\n\r\n**先来看类图：**\r\n\r\n<img src=\"img/享元模式.png\" style=\"zoom:80%;\" />\r\n\r\n**代码如下：**\r\n\r\n俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。\r\n\r\n```java\r\npublic abstract class AbstractBox {\r\n    public abstract String getShape();\r\n\r\n    public void display(String color) {\r\n        System.out.println(\"方块形状：\" + this.getShape() + \" 颜色：\" + color);\r\n    }\r\n}\r\n```\r\n\r\n接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。\r\n\r\n```java\r\npublic class IBox extends AbstractBox {\r\n\r\n    @Override\r\n    public String getShape() {\r\n        return \"I\";\r\n    }\r\n}\r\n\r\npublic class LBox extends AbstractBox {\r\n\r\n    @Override\r\n    public String getShape() {\r\n        return \"L\";\r\n    }\r\n}\r\n\r\npublic class OBox extends AbstractBox {\r\n\r\n    @Override\r\n    public String getShape() {\r\n        return \"O\";\r\n    }\r\n}\r\n```\r\n\r\n提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。\r\n\r\n```java\r\npublic class BoxFactory {\r\n\r\n    private static HashMap<String, AbstractBox> map;\r\n\r\n    private BoxFactory() {\r\n        map = new HashMap<String, AbstractBox>();\r\n        AbstractBox iBox = new IBox();\r\n        AbstractBox lBox = new LBox();\r\n        AbstractBox oBox = new OBox();\r\n        map.put(\"I\", iBox);\r\n        map.put(\"L\", lBox);\r\n        map.put(\"O\", oBox);\r\n    }\r\n\r\n    public static final BoxFactory getInstance() {\r\n        return SingletonHolder.INSTANCE;\r\n    }\r\n\r\n    private static class SingletonHolder {\r\n        private static final BoxFactory INSTANCE = new BoxFactory();\r\n    }\r\n\r\n    public AbstractBox getBox(String key) {\r\n        return map.get(key);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 5.7.5 优缺点和使用场景\r\n\r\n**1，优点**\r\n\r\n- 极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能\r\n- 享元模式中的外部状态相对独立，且不影响内部状态\r\n\r\n**2，缺点：**\r\n\r\n为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂\r\n\r\n**3，使用场景：**\r\n\r\n- 一个系统有大量相同或者相似的对象，造成内存的大量耗费。\r\n- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。\r\n- 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。\r\n\r\n\r\n\r\n### 5.7.6 JDK源码解析\r\n\r\nInteger类使用了享元模式。我们先看下面的例子：\r\n\r\n```java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        Integer i1 = 127;\r\n        Integer i2 = 127;\r\n\r\n        System.out.println(\"i1和i2对象是否是同一个对象？\" + (i1 == i2));\r\n\r\n        Integer i3 = 128;\r\n        Integer i4 = 128;\r\n\r\n        System.out.println(\"i3和i4对象是否是同一个对象？\" + (i3 == i4));\r\n    }\r\n}\r\n```\r\n\r\n运行上面代码，结果如下：\r\n\r\n<img src=\"img/image-20200208212930857.png\" style=\"zoom:80%;\" />\r\n\r\n为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：\r\n\r\n```java\r\npublic class Demo {\r\n    public static void main(String[] args) {\r\n        Integer i1 = Integer.valueOf((int)127);\r\n        Integer i2 Integer.valueOf((int)127);\r\n        System.out.println((String)new StringBuilder().append((String)\"i1\\u548ci2\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f\").append((boolean)(i1 == i2)).toString());\r\n        Integer i3 = Integer.valueOf((int)128);\r\n        Integer i4 = Integer.valueOf((int)128);\r\n        System.out.println((String)new StringBuilder().append((String)\"i3\\u548ci4\\u5bf9\\u8c61\\u662f\\u5426\\u662f\\u540c\\u4e00\\u4e2a\\u5bf9\\u8c61\\uff1f\").append((boolean)(i3 == i4)).toString());\r\n    }\r\n}\r\n```\r\n\r\n上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 `valueOf()` ，所以只需要看该方法即可\r\n\r\n```java\r\npublic final class Integer extends Number implements Comparable<Integer> {\r\n    \r\n\tpublic static Integer valueOf(int i) {\r\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\r\n            return IntegerCache.cache[i + (-IntegerCache.low)];\r\n        return new Integer(i);\r\n    }\r\n    \r\n    private static class IntegerCache {\r\n        static final int low = -128;\r\n        static final int high;\r\n        static final Integer cache[];\r\n\r\n        static {\r\n            int h = 127;\r\n            String integerCacheHighPropValue =\r\n                sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\r\n            if (integerCacheHighPropValue != null) {\r\n                try {\r\n                    int i = parseInt(integerCacheHighPropValue);\r\n                    i = Math.max(i, 127);\r\n                    // Maximum array size is Integer.MAX_VALUE\r\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\r\n                } catch( NumberFormatException nfe) {\r\n                }\r\n            }\r\n            high = h;\r\n            cache = new Integer[(high - low) + 1];\r\n            int j = low;\r\n            for(int k = 0; k < cache.length; k++)\r\n                cache[k] = new Integer(j++);\r\n            // range [-128, 127] must be interned (JLS7 5.1.7)\r\n            assert IntegerCache.high >= 127;\r\n        }\r\n\r\n        private IntegerCache() {}\r\n    }\r\n}\r\n```\r\n\r\n可以看到 `Integer` 默认先创建并缓存 `-128 ~ 127` 之间数的 `Integer` 对象，当调用 `valueOf` 时如果参数在 `-128 ~ 127` 之间则计算下标并从缓存中返回，否则创建一个新的 `Integer` 对象。\r\n\r\n\r\n\r\n\r\n\r\n# 6，行为型模式\r\n\r\n行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。\r\n\r\n行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。\r\n\r\n行为型模式分为：\r\n\r\n* 模板方法模式\r\n* 策略模式\r\n* 命令模式\r\n* 职责链模式\r\n* 状态模式\r\n* 观察者模式\r\n* 中介者模式\r\n* 迭代器模式\r\n* 访问者模式\r\n* 备忘录模式\r\n* 解释器模式\r\n\r\n以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。\r\n\r\n\r\n\r\n## 6.1 模板方法模式\r\n\r\n### 6.1.1 概述\r\n\r\n在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。\r\n\r\n例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。\r\n\r\n**定义：**\r\n\r\n定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。\r\n\r\n\r\n\r\n###  6.1.2 结构\r\n\r\n模板方法（Template Method）模式包含以下主要角色：\r\n\r\n* 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。\r\n\r\n  * 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。\r\n\r\n  * 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：\r\n\r\n    * 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。\r\n\r\n    * 具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\r\n\r\n    * 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。\r\n\r\n      一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。\r\n\r\n* 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。\r\n\r\n\r\n\r\n### 6.1.3 案例实现\r\n\r\n【例】炒菜\r\n\r\n炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：\r\n\r\n<img src=\"img/模板方法模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\npublic abstract class AbstractClass {\r\n    \r\n    public final void cookProcess() {\r\n        //第一步：倒油\r\n        this.pourOil();\r\n        //第二步：热油\r\n        this.heatOil();\r\n        //第三步：倒蔬菜\r\n        this.pourVegetable();\r\n        //第四步：倒调味料\r\n        this.pourSauce();\r\n        //第五步：翻炒\r\n        this.fry();\r\n    }\r\n\r\n    public void pourOil() {\r\n        System.out.println(\"倒油\");\r\n    }\r\n\r\n    //第二步：热油是一样的，所以直接实现\r\n    public void heatOil() {\r\n        System.out.println(\"热油\");\r\n    }\r\n\r\n    //第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）\r\n    public abstract void pourVegetable();\r\n\r\n    //第四步：倒调味料是不一样\r\n    public abstract void pourSauce();\r\n\r\n\r\n    //第五步：翻炒是一样的，所以直接实现\r\n    public void fry(){\r\n        System.out.println(\"炒啊炒啊炒到熟啊\");\r\n    }\r\n}\r\n\r\npublic class ConcreteClass_BaoCai extends AbstractClass {\r\n\r\n    @Override\r\n    public void pourVegetable() {\r\n        System.out.println(\"下锅的蔬菜是包菜\");\r\n    }\r\n\r\n    @Override\r\n    public void pourSauce() {\r\n        System.out.println(\"下锅的酱料是辣椒\");\r\n    }\r\n}\r\n\r\npublic class ConcreteClass_CaiXin extends AbstractClass {\r\n    @Override\r\n    public void pourVegetable() {\r\n        System.out.println(\"下锅的蔬菜是菜心\");\r\n    }\r\n\r\n    @Override\r\n    public void pourSauce() {\r\n        System.out.println(\"下锅的酱料是蒜蓉\");\r\n    }\r\n}\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //炒手撕包菜\r\n        ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai();\r\n        baoCai.cookProcess();\r\n\r\n        //炒蒜蓉菜心\r\n        ConcreteClass_CaiXin caiXin = new ConcreteClass_CaiXin();\r\n        caiXin.cookProcess();\r\n    }\r\n}\r\n```\r\n\r\n> 注意：为防止恶意操作，一般模板方法都加上 final 关键词。\r\n\r\n\r\n\r\n### 6.1.3 优缺点\r\n\r\n**优点：**\r\n\r\n* 提高代码复用性\r\n\r\n  将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。\r\n\r\n* 实现了反向控制\r\n\r\n  通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。\r\n\r\n**缺点：**\r\n\r\n* 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。\r\n* 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。\r\n\r\n\r\n\r\n### 6.1.4 适用场景\r\n\r\n* 算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。\r\n* 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。\r\n\r\n\r\n\r\n### 6.1.5 JDK源码解析\r\n\r\nInputStream类就使用了模板方法模式。在InputStream类中定义了多个 `read()` 方法，如下：\r\n\r\n```java\r\npublic abstract class InputStream implements Closeable {\r\n    //抽象方法，要求子类必须重写\r\n    public abstract int read() throws IOException;\r\n\r\n    public int read(byte b[]) throws IOException {\r\n        return read(b, 0, b.length);\r\n    }\r\n\r\n    public int read(byte b[], int off, int len) throws IOException {\r\n        if (b == null) {\r\n            throw new NullPointerException();\r\n        } else if (off < 0 || len < 0 || len > b.length - off) {\r\n            throw new IndexOutOfBoundsException();\r\n        } else if (len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据\r\n        if (c == -1) {\r\n            return -1;\r\n        }\r\n        b[off] = (byte)c;\r\n\r\n        int i = 1;\r\n        try {\r\n            for (; i < len ; i++) {\r\n                c = read();\r\n                if (c == -1) {\r\n                    break;\r\n                }\r\n                b[off + i] = (byte)c;\r\n            }\r\n        } catch (IOException ee) {\r\n        }\r\n        return i;\r\n    }\r\n}\r\n```\r\n\r\n从上面代码可以看到，无参的 `read()` 方法是抽象方法，要求子类必须实现。而 `read(byte b[])` 方法调用了 `read(byte b[], int off, int len)` 方法，所以在此处重点看的方法是带三个参数的方法。 \r\n\r\n在该方法中第18行、27行，可以看到调用了无参的抽象的 `read()` 方法。\r\n\r\n总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。\r\n\r\n\r\n\r\n## 6.2 策略模式\r\n\r\n### 6.2.1 概述\r\n\r\n先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。\r\n\r\n<img src=\"img/image-20200210143039168.png\" style=\"zoom:80%;\" />\r\n\r\n作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。\r\n\r\n<img src=\"img/image-20200210144457478.png\" style=\"zoom:70%;\" />\r\n\r\n**定义：**\r\n\r\n​\t该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。\r\n\r\n\r\n\r\n### 6.2.2 结构\r\n\r\n策略模式的主要角色如下：\r\n\r\n* 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。\r\n* 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。\r\n* 环境（Context）类：持有一个策略类的引用，最终给客户端调用。\r\n\r\n\r\n\r\n### 6.2.3 案例实现\r\n\r\n【例】促销活动\r\n\r\n一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：\r\n\r\n<img src=\"img/策略模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n定义百货公司所有促销活动的共同接口\r\n\r\n```java\r\npublic interface Strategy {\r\n    void show();\r\n}\r\n```\r\n\r\n定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动\r\n\r\n```java\r\n//为春节准备的促销活动A\r\npublic class StrategyA implements Strategy {\r\n\r\n    public void show() {\r\n        System.out.println(\"买一送一\");\r\n    }\r\n}\r\n\r\n//为中秋准备的促销活动B\r\npublic class StrategyB implements Strategy {\r\n\r\n    public void show() {\r\n        System.out.println(\"满200元减50元\");\r\n    }\r\n}\r\n\r\n//为圣诞准备的促销活动C\r\npublic class StrategyC implements Strategy {\r\n\r\n    public void show() {\r\n        System.out.println(\"满1000元加一元换购任意200元以下商品\");\r\n    }\r\n}\r\n```\r\n\r\n定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员\r\n\r\n```java\r\npublic class SalesMan {                        \r\n    //持有抽象策略角色的引用                              \r\n    private Strategy strategy;                 \r\n                                               \r\n    public SalesMan(Strategy strategy) {       \r\n        this.strategy = strategy;              \r\n    }                                          \r\n                                               \r\n    //向客户展示促销活动                                \r\n    public void salesManShow(){                \r\n        strategy.show();                       \r\n    }                                          \r\n}                                              \r\n```\r\n\r\n\r\n\r\n### 6.2.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n* 策略类之间可以自由切换\r\n\r\n  由于策略类都实现同一个接口，所以使它们之间可以自由切换。\r\n\r\n* 易于扩展\r\n\r\n  增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“\r\n\r\n* 避免使用多重条件选择语句（if else），充分体现面向对象设计思想。\r\n\r\n**2，缺点：**\r\n\r\n* 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。\r\n* 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。\r\n\r\n\r\n\r\n### 6.2.5 使用场景\r\n\r\n* 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。\r\n* 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。\r\n* 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。\r\n* 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。\r\n* 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。\r\n\r\n\r\n\r\n### 6.2.6 JDK源码解析\r\n\r\n`Comparator` 中的策略模式。在Arrays类中有一个 `sort()` 方法，如下：\r\n\r\n```java\r\npublic class Arrays{\r\n    public static <T> void sort(T[] a, Comparator<? super T> c) {\r\n        if (c == null) {\r\n            sort(a);\r\n        } else {\r\n            if (LegacyMergeSort.userRequested)\r\n                legacyMergeSort(a, c);\r\n            else\r\n                TimSort.sort(a, 0, a.length, c, null, 0, 0);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nArrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。\r\n\r\n```java\r\npublic class demo {\r\n    public static void main(String[] args) {\r\n\r\n        Integer[] data = {12, 2, 3, 2, 4, 5, 1};\r\n        // 实现降序排序\r\n        Arrays.sort(data, new Comparator<Integer>() {\r\n            public int compare(Integer o1, Integer o2) {\r\n                return o2 - o1;\r\n            }\r\n        });\r\n        System.out.println(Arrays.toString(data)); //[12, 5, 4, 3, 2, 2, 1]\r\n    }\r\n}\r\n```\r\n\r\n这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 `compare()` 方法吗？让我们继续查看TimSort类的 `sort()` 方法，代码如下：\r\n\r\n```java\r\nclass TimSort<T> {\r\n    static <T> void sort(T[] a, int lo, int hi, Comparator<? super T> c,\r\n                         T[] work, int workBase, int workLen) {\r\n        assert c != null && a != null && lo >= 0 && lo <= hi && hi <= a.length;\r\n\r\n        int nRemaining  = hi - lo;\r\n        if (nRemaining < 2)\r\n            return;  // Arrays of size 0 and 1 are always sorted\r\n\r\n        // If array is small, do a \"mini-TimSort\" with no merges\r\n        if (nRemaining < MIN_MERGE) {\r\n            int initRunLen = countRunAndMakeAscending(a, lo, hi, c);\r\n            binarySort(a, lo, hi, lo + initRunLen, c);\r\n            return;\r\n        }\r\n        ...\r\n    }   \r\n        \r\n    private static <T> int countRunAndMakeAscending(T[] a, int lo, int hi,Comparator<? super T> c) {\r\n        assert lo < hi;\r\n        int runHi = lo + 1;\r\n        if (runHi == hi)\r\n            return 1;\r\n\r\n        // Find end of run, and reverse range if descending\r\n        if (c.compare(a[runHi++], a[lo]) < 0) { // Descending\r\n            while (runHi < hi && c.compare(a[runHi], a[runHi - 1]) < 0)\r\n                runHi++;\r\n            reverseRange(a, lo, runHi);\r\n        } else {                              // Ascending\r\n            while (runHi < hi && c.compare(a[runHi], a[runHi - 1]) >= 0)\r\n                runHi++;\r\n        }\r\n\r\n        return runHi - lo;\r\n    }\r\n}\r\n```\r\n\r\n上面的代码中最终会跑到 `countRunAndMakeAscending()` 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。\r\n\r\n\r\n\r\n## 6.3 命令模式\r\n\r\n### 6.3.1 概述\r\n\r\n日常生活中，我们出去吃饭都会遇到下面的场景。\r\n\r\n<img src=\"img/image-20200211130313251.png\" style=\"zoom:60%;\" />\r\n\r\n**定义：**\r\n\r\n将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。\r\n\r\n\r\n\r\n### 6.3.2 结构\r\n\r\n命令模式包含以下主要角色：\r\n\r\n* 抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。\r\n* 具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。\r\n* 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。\r\n* 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。\r\n\r\n\r\n\r\n### 6.3.3 案例实现\r\n\r\n将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。\r\n\r\n服务员： 就是调用者角色，由她来发起命令。\r\n\r\n资深大厨： 就是接收者角色，真正命令执行的对象。\r\n\r\n订单： 命令中包含订单。\r\n\r\n类图如下：\r\n\r\n<img src=\"img/命令模式.png\" style=\"zoom:75%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\npublic interface Command {\r\n    void execute();//只需要定义一个统一的执行方法\r\n}\r\n\r\npublic class OrderCommand implements Command {\r\n\r\n    //持有接受者对象\r\n    private SeniorChef receiver;\r\n    private Order order;\r\n\r\n    public OrderCommand(SeniorChef receiver, Order order){\r\n        this.receiver = receiver;\r\n        this.order = order;\r\n    }\r\n\r\n    public void execute()  {\r\n        System.out.println(order.getDiningTable() + \"桌的订单：\");\r\n        Set<String> keys = order.getFoodDic().keySet();\r\n        for (String key : keys) {\r\n            receiver.makeFood(order.getFoodDic().get(key),key);\r\n        }\r\n\r\n        try {\r\n            Thread.sleep(100);//停顿一下 模拟做饭的过程\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n\r\n        System.out.println(order.getDiningTable() + \"桌的饭弄好了\");\r\n    }\r\n}\r\n\r\npublic class Order {\r\n    // 餐桌号码\r\n    private int diningTable;\r\n\r\n    // 用来存储餐名并记录份数\r\n    private Map<String, Integer> foodDic = new HashMap<String, Integer>();\r\n\r\n    public int getDiningTable() {\r\n        return diningTable;\r\n    }\r\n\r\n    public void setDiningTable(int diningTable) {\r\n        this.diningTable = diningTable;\r\n    }\r\n\r\n    public Map<String, Integer> getFoodDic() {\r\n        return foodDic;\r\n    }\r\n\r\n    public void setFoodDic(String name, int num) {\r\n        foodDic.put(name,num);\r\n    }\r\n}\r\n\r\n// 资深大厨类 是命令的Receiver\r\npublic class SeniorChef {\r\n\r\n    public void makeFood(int num,String foodName) {\r\n        System.out.println(num + \"份\" + foodName);\r\n    }\r\n}\r\n\r\npublic class Waitor {\r\n\r\n    private ArrayList<Command> commands;//可以持有很多的命令对象\r\n\r\n    public Waitor() {\r\n        commands = new ArrayList();\r\n    }\r\n    \r\n    public void setCommand(Command cmd){\r\n        commands.add(cmd);\r\n    }\r\n\r\n    // 发出命令 喊 订单来了，厨师开始执行\r\n    public void orderUp() {\r\n        System.out.println(\"美女服务员：叮咚，大厨，新订单来了.......\");\r\n        for (int i = 0; i < commands.size(); i++) {\r\n            Command cmd = commands.get(i);\r\n            if (cmd != null) {\r\n                cmd.execute();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //创建2个order\r\n        Order order1 = new Order();\r\n        order1.setDiningTable(1);\r\n        order1.getFoodDic().put(\"西红柿鸡蛋面\",1);\r\n        order1.getFoodDic().put(\"小杯可乐\",2);\r\n\r\n        Order order2 = new Order();\r\n        order2.setDiningTable(3);\r\n        order2.getFoodDic().put(\"尖椒肉丝盖饭\",1);\r\n        order2.getFoodDic().put(\"小杯雪碧\",1);\r\n\r\n        //创建接收者\r\n        SeniorChef receiver=new SeniorChef();\r\n        //将订单和接收者封装成命令对象\r\n        OrderCommand cmd1 = new OrderCommand(receiver, order1);\r\n        OrderCommand cmd2 = new OrderCommand(receiver, order2);\r\n        //创建调用者 waitor\r\n        Waitor invoker = new Waitor();\r\n        invoker.setCommand(cmd1);\r\n        invoker.setCommand(cmd2);\r\n\r\n        //将订单带到柜台 并向厨师喊 订单来了\r\n        invoker.orderUp();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 6.3.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n* 降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。\r\n* 增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。\r\n* 可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。\r\n* 方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。\r\n\r\n**2，缺点：**\r\n\r\n* 使用命令模式可能会导致某些系统有过多的具体命令类。\r\n* 系统结构更加复杂。\r\n\r\n\r\n\r\n### 6.3.5 使用场景\r\n\r\n* 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。\r\n* 系统需要在不同的时间指定请求、将请求排队和执行请求。\r\n* 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。\r\n\r\n\r\n\r\n### 6.3.6 JDK源码解析\r\n\r\nRunable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法\r\n\r\n```java\r\n//命令接口(抽象命令角色)\r\npublic interface Runnable {\r\n\tpublic abstract void run();\r\n}\r\n\r\n//调用者\r\npublic class Thread implements Runnable {\r\n    private Runnable target;\r\n    \r\n    public synchronized void start() {\r\n        if (threadStatus != 0)\r\n            throw new IllegalThreadStateException();\r\n\r\n        group.add(this);\r\n\r\n        boolean started = false;\r\n        try {\r\n            start0();\r\n            started = true;\r\n        } finally {\r\n            try {\r\n                if (!started) {\r\n                    group.threadStartFailed(this);\r\n                }\r\n            } catch (Throwable ignore) {\r\n            }\r\n        }\r\n    }\r\n    \r\n    private native void start0();\r\n}\r\n```\r\n\r\n会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。\r\n\r\n```java\r\n/**\r\n * jdk Runnable 命令模式\r\n *\t\tTurnOffThread ： 属于具体\r\n */\r\npublic class TurnOffThread implements Runnable{\r\n     private Receiver receiver;\r\n    \r\n     public TurnOffThread(Receiver receiver) {\r\n     \tthis.receiver = receiver;\r\n     }\r\n     public void run() {\r\n     \treceiver.turnOFF();\r\n     }\r\n}\r\n```\r\n\r\n```java\r\n/**\r\n * 测试类\r\n */\r\npublic class Demo {\r\n     public static void main(String[] args) {\r\n         Receiver receiver = new Receiver();\r\n         TurnOffThread turnOffThread = new TurnOffThread(receiver);\r\n         Thread thread = new Thread(turnOffThread);\r\n         thread.start();\r\n     }\r\n}\r\n```\r\n\r\n\r\n\r\n## 6.4 责任链模式\r\n\r\n### 6.4.1 概述\r\n\r\n在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。\r\n\r\n**定义：**\r\n\r\n又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。\r\n\r\n\r\n\r\n### 6.4.2 结构\r\n\r\n职责链模式主要包含以下角色:\r\n\r\n* 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。\r\n* 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。\r\n* 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。\r\n\r\n\r\n\r\n### 6.4.3 案例实现\r\n\r\n现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。\r\n\r\n类图如下：\r\n\r\n<img src=\"img/责任链模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//请假条\r\npublic class LeaveRequest {\r\n    private String name;//姓名\r\n    private int num;//请假天数\r\n    private String content;//请假内容\r\n\r\n    public LeaveRequest(String name, int num, String content) {\r\n        this.name = name;\r\n        this.num = num;\r\n        this.content = content;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public int getNum() {\r\n        return num;\r\n    }\r\n\r\n    public String getContent() {\r\n        return content;\r\n    }\r\n}\r\n\r\n//处理者抽象类\r\npublic abstract class Handler {\r\n    protected final static int NUM_ONE = 1;\r\n    protected final static int NUM_THREE = 3;\r\n    protected final static int NUM_SEVEN = 7;\r\n\r\n    //该领导处理的请假天数区间\r\n    private int numStart;\r\n    private int numEnd;\r\n\r\n    //领导上面还有领导\r\n    private Handler nextHandler;\r\n\r\n    //设置请假天数范围 上不封顶\r\n    public Handler(int numStart) {\r\n        this.numStart = numStart;\r\n    }\r\n\r\n    //设置请假天数范围\r\n    public Handler(int numStart, int numEnd) {\r\n        this.numStart = numStart;\r\n        this.numEnd = numEnd;\r\n    }\r\n\r\n    //设置上级领导\r\n    public void setNextHandler(Handler nextHandler){\r\n        this.nextHandler = nextHandler;\r\n    }\r\n\r\n    //提交请假条\r\n    public final void submit(LeaveRequest leave){\r\n        if(0 == this.numStart){\r\n            return;\r\n        }\r\n\r\n        //如果请假天数达到该领导者的处理要求\r\n        if(leave.getNum() >= this.numStart){\r\n            this.handleLeave(leave);\r\n\r\n            //如果还有上级 并且请假天数超过了当前领导的处理范围\r\n            if(null != this.nextHandler && leave.getNum() > numEnd){\r\n                this.nextHandler.submit(leave);//继续提交\r\n            } else {\r\n                System.out.println(\"流程结束\");\r\n            }\r\n        }\r\n    }\r\n\r\n    //各级领导处理请假条方法\r\n    protected abstract void handleLeave(LeaveRequest leave);\r\n}\r\n\r\n//小组长\r\npublic class GroupLeader extends Handler {\r\n    public GroupLeader() {\r\n        //小组长处理1-3天的请假\r\n        super(Handler.NUM_ONE, Handler.NUM_THREE);\r\n    }\r\n\r\n    @Override\r\n    protected void handleLeave(LeaveRequest leave) {\r\n        System.out.println(leave.getName() + \"请假\" + leave.getNum() + \"天,\" + leave.getContent() + \"。\");\r\n        System.out.println(\"小组长审批：同意。\");\r\n    }\r\n}\r\n\r\n//部门经理\r\npublic class Manager extends Handler {\r\n    public Manager() {\r\n        //部门经理处理3-7天的请假\r\n        super(Handler.NUM_THREE, Handler.NUM_SEVEN);\r\n    }\r\n\r\n    @Override\r\n    protected void handleLeave(LeaveRequest leave) {\r\n        System.out.println(leave.getName() + \"请假\" + leave.getNum() + \"天,\" + leave.getContent() + \"。\");\r\n        System.out.println(\"部门经理审批：同意。\");\r\n    }\r\n}\r\n\r\n//总经理\r\npublic class GeneralManager extends Handler {\r\n    public GeneralManager() {\r\n        //部门经理处理7天以上的请假\r\n        super(Handler.NUM_SEVEN);\r\n    }\r\n\r\n    @Override\r\n    protected void handleLeave(LeaveRequest leave) {\r\n        System.out.println(leave.getName() + \"请假\" + leave.getNum() + \"天,\" + leave.getContent() + \"。\");\r\n        System.out.println(\"总经理审批：同意。\");\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //请假条来一张\r\n        LeaveRequest leave = new LeaveRequest(\"小花\",5,\"身体不适\");\r\n\r\n        //各位领导\r\n        GroupLeader groupLeader = new GroupLeader();\r\n        Manager manager = new Manager();\r\n        GeneralManager generalManager = new GeneralManager();\r\n\r\n        groupLeader.setNextHandler(manager);//小组长的领导是部门经理\r\n        manager.setNextHandler(generalManager);//部门经理的领导是总经理\r\n        //之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。\r\n\r\n        //提交申请\r\n        groupLeader.submit(leave);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 6.4.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n* 降低了对象之间的耦合度\r\n\r\n  该模式降低了请求发送者和接收者的耦合度。\r\n\r\n* 增强了系统的可扩展性\r\n\r\n  可以根据需要增加新的请求处理类，满足开闭原则。\r\n\r\n* 增强了给对象指派职责的灵活性\r\n\r\n  当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。\r\n\r\n* 责任链简化了对象之间的连接\r\n\r\n  一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。\r\n\r\n* 责任分担\r\n\r\n  每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。\r\n\r\n**2，缺点：**\r\n\r\n* 不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。\r\n* 对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。\r\n* 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。\r\n\r\n\r\n\r\n### 6.4.5 源码解析\r\n\r\n在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析:\r\n\r\n* 模拟web请求Request以及web响应Response\r\n\r\n  ```java\r\n  public interface Request{\r\n   \r\n  }\r\n  \r\n  public interface Response{\r\n   \r\n  }\r\n  ```\r\n\r\n* 模拟web过滤器Filter\r\n\r\n  ```java\r\n   public interface Filter {\r\n   \tpublic void doFilter(Request req,Response res,FilterChain c);\r\n   }\r\n  ```\r\n\r\n* 模拟实现具体过滤器  \r\n\r\n  ```java\r\n  public class FirstFilter implements Filter {\r\n      @Override\r\n      public void doFilter(Request request, Response response, FilterChain chain) {\r\n  \r\n          System.out.println(\"过滤器1 前置处理\");\r\n  \r\n          // 先执行所有request再倒序执行所有response\r\n          chain.doFilter(request, response);\r\n  \r\n          System.out.println(\"过滤器1 后置处理\");\r\n      }\r\n  }\r\n  \r\n  public class SecondFilter  implements Filter {\r\n      @Override\r\n      public void doFilter(Request request, Response response, FilterChain chain) {\r\n  \r\n          System.out.println(\"过滤器2 前置处理\");\r\n  \r\n          // 先执行所有request再倒序执行所有response\r\n          chain.doFilter(request, response);\r\n  \r\n          System.out.println(\"过滤器2 后置处理\");\r\n      }\r\n  }\r\n  ```\r\n\r\n* 模拟实现过滤器链FilterChain  \r\n\r\n  ```java\r\n  public class FilterChain {\r\n  \r\n      private List<Filter> filters = new ArrayList<Filter>();\r\n  \r\n      private int index = 0;\r\n  \r\n      // 链式调用\r\n      public FilterChain addFilter(Filter filter) {\r\n          this.filters.add(filter);\r\n          return this;\r\n      }\r\n  \r\n      public void doFilter(Request request, Response response) {\r\n          if (index == filters.size()) {\r\n              return;\r\n          }\r\n          Filter filter = filters.get(index);\r\n          index++;\r\n          filter.doFilter(request, response, this);\r\n      }\r\n  }\r\n  ```\r\n\r\n* 测试类\r\n\r\n  ```java\r\n  public class Client {\r\n      public static void main(String[] args) {\r\n          Request  req = null;\r\n          Response res = null ;\r\n  \r\n          FilterChain filterChain = new FilterChain();\r\n          filterChain.addFilter(new FirstFilter()).addFilter(new SecondFilter());\r\n          filterChain.doFilter(req,res);\r\n      }\r\n  }\r\n  ```\r\n\r\n  \r\n# 6，行为型模式\r\n\r\n## 6.5 状态模式\r\n\r\n### 6.5.1 概述\r\n\r\n【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。\r\n\r\n类图如下：\r\n\r\n<img src=\"img/状态模式前.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\npublic interface ILift {\r\n    //电梯的4个状态\r\n    //开门状态\r\n    public final static int OPENING_STATE = 1;\r\n    //关门状态\r\n    public final static int CLOSING_STATE = 2;\r\n    //运行状态\r\n    public final static int RUNNING_STATE = 3;\r\n    //停止状态\r\n    public final static int STOPPING_STATE = 4;\r\n\r\n    //设置电梯的状态\r\n    public void setState(int state);\r\n\r\n    //电梯的动作\r\n    public void open();\r\n    public void close();\r\n    public void run();\r\n    public void stop();\r\n}\r\n\r\npublic class Lift implements ILift {\r\n    private int state;\r\n\r\n    @Override\r\n    public void setState(int state) {\r\n        this.state = state;\r\n    }\r\n\r\n    //执行关门动作\r\n    @Override\r\n    public void close() {\r\n        switch (this.state) {\r\n            case OPENING_STATE:\r\n                System.out.println(\"电梯关门了。。。\");//只有开门状态可以关闭电梯门，可以对应电梯状态表来看\r\n                this.setState(CLOSING_STATE);//关门之后电梯就是关闭状态了\r\n                break;\r\n            case CLOSING_STATE:\r\n                //do nothing //已经是关门状态，不能关门\r\n                break;\r\n            case RUNNING_STATE:\r\n                //do nothing //运行时电梯门是关着的，不能关门\r\n                break;\r\n            case STOPPING_STATE:\r\n                //do nothing //停止时电梯也是关着的，不能关门\r\n                break;\r\n        }\r\n    }\r\n\r\n    //执行开门动作\r\n    @Override\r\n    public void open() {\r\n        switch (this.state) {\r\n            case OPENING_STATE://门已经开了，不能再开门了\r\n                //do nothing\r\n                break;\r\n            case CLOSING_STATE://关门状态，门打开:\r\n                System.out.println(\"电梯门打开了。。。\");\r\n                this.setState(OPENING_STATE);\r\n                break;\r\n            case RUNNING_STATE:\r\n                //do nothing 运行时电梯不能开门\r\n                break;\r\n            case STOPPING_STATE:\r\n                System.out.println(\"电梯门开了。。。\");//电梯停了，可以开门了\r\n                this.setState(OPENING_STATE);\r\n                break;\r\n        }\r\n    }\r\n\r\n    //执行运行动作\r\n    @Override\r\n    public void run() {\r\n        switch (this.state) {\r\n            case OPENING_STATE://电梯不能开着门就走\r\n                //do nothing\r\n                break;\r\n            case CLOSING_STATE://门关了，可以运行了\r\n                System.out.println(\"电梯开始运行了。。。\");\r\n                this.setState(RUNNING_STATE);//现在是运行状态\r\n                break;\r\n            case RUNNING_STATE:\r\n                //do nothing 已经是运行状态了\r\n                break;\r\n            case STOPPING_STATE:\r\n                System.out.println(\"电梯开始运行了。。。\");\r\n                this.setState(RUNNING_STATE);\r\n                break;\r\n        }\r\n    }\r\n\r\n    //执行停止动作\r\n    @Override\r\n    public void stop() {\r\n        switch (this.state) {\r\n            case OPENING_STATE: //开门的电梯已经是是停止的了(正常情况下)\r\n                //do nothing\r\n                break;\r\n            case CLOSING_STATE://关门时才可以停止\r\n                System.out.println(\"电梯停止了。。。\");\r\n                this.setState(STOPPING_STATE);\r\n                break;\r\n            case RUNNING_STATE://运行时当然可以停止了\r\n                System.out.println(\"电梯停止了。。。\");\r\n                this.setState(STOPPING_STATE);\r\n                break;\r\n            case STOPPING_STATE:\r\n                //do nothing\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Lift lift = new Lift();\r\n        lift.setState(ILift.STOPPING_STATE);//电梯是停止的\r\n        lift.open();//开门\r\n        lift.close();//关门\r\n        lift.run();//运行\r\n        lift.stop();//停止\r\n    }\r\n}\r\n```\r\n\r\n问题分析：\r\n\r\n* 使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。\r\n* 扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑\r\n\r\n\r\n\r\n**定义：**\r\n\r\n对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。\r\n\r\n\r\n\r\n### 6.5.2 结构\r\n\r\n状态模式包含以下主要角色。\r\n\r\n* 环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。\r\n* 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。\r\n* 具体状态（Concrete  State）角色：实现抽象状态所对应的行为。\r\n\r\n\r\n\r\n### 6.5.3 案例实现\r\n\r\n对上述电梯的案例使用状态模式进行改进。类图如下：\r\n\r\n<img src=\"img/状态模式.png\" style=\"zoom:70%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//抽象状态类\r\npublic abstract class LiftState {\r\n    //定义一个环境角色，也就是封装状态的变化引起的功能变化\r\n    protected Context context;\r\n\r\n    public void setContext(Context context) {\r\n        this.context = context;\r\n    }\r\n\r\n    //电梯开门动作\r\n    public abstract void open();\r\n\r\n    //电梯关门动作\r\n    public abstract void close();\r\n\r\n    //电梯运行动作\r\n    public abstract void run();\r\n\r\n    //电梯停止动作\r\n    public abstract void stop();\r\n}\r\n\r\n//开启状态\r\npublic class OpenningState extends LiftState {\r\n\r\n    //开启当然可以关闭了，我就想测试一下电梯门开关功能\r\n    @Override\r\n    public void open() {\r\n        System.out.println(\"电梯门开启...\");\r\n    }\r\n\r\n    @Override\r\n    public void close() {\r\n        //状态修改\r\n        super.context.setLiftState(Context.closeingState);\r\n        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作\r\n        super.context.getLiftState().close();\r\n    }\r\n\r\n    //电梯门不能开着就跑，这里什么也不做\r\n    @Override\r\n    public void run() {\r\n        //do nothing\r\n    }\r\n\r\n    //开门状态已经是停止的了\r\n    @Override\r\n    public void stop() {\r\n        //do nothing\r\n    }\r\n}\r\n\r\n//运行状态\r\npublic class RunningState extends LiftState {\r\n\r\n    //运行的时候开电梯门？你疯了！电梯不会给你开的\r\n    @Override\r\n    public void open() {\r\n        //do nothing\r\n    }\r\n\r\n    //电梯门关闭？这是肯定了\r\n    @Override\r\n    public void close() {//虽然可以关门，但这个动作不归我执行\r\n        //do nothing\r\n    }\r\n\r\n    //这是在运行状态下要实现的方法\r\n    @Override\r\n    public void run() {\r\n        System.out.println(\"电梯正在运行...\");\r\n    }\r\n\r\n    //这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了\r\n    @Override\r\n    public void stop() {\r\n        super.context.setLiftState(Context.stoppingState);\r\n        super.context.stop();\r\n    }\r\n}\r\n\r\n//停止状态\r\npublic class StoppingState extends LiftState {\r\n\r\n    //停止状态，开门，那是要的！\r\n    @Override\r\n    public void open() {\r\n        //状态修改\r\n        super.context.setLiftState(Context.openningState);\r\n        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作\r\n        super.context.getLiftState().open();\r\n    }\r\n\r\n    @Override\r\n    public void close() {//虽然可以关门，但这个动作不归我执行\r\n        //状态修改\r\n        super.context.setLiftState(Context.closeingState);\r\n        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作\r\n        super.context.getLiftState().close();\r\n    }\r\n\r\n    //停止状态再跑起来，正常的很\r\n    @Override\r\n    public void run() {\r\n        //状态修改\r\n        super.context.setLiftState(Context.runningState);\r\n        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作\r\n        super.context.getLiftState().run();\r\n    }\r\n\r\n    //停止状态是怎么发生的呢？当然是停止方法执行了\r\n    @Override\r\n    public void stop() {\r\n        System.out.println(\"电梯停止了...\");\r\n    }\r\n}\r\n\r\n//关闭状态\r\npublic class ClosingState extends LiftState {\r\n\r\n    @Override\r\n    //电梯门关闭，这是关闭状态要实现的动作\r\n    public void close() {\r\n        System.out.println(\"电梯门关闭...\");\r\n    }\r\n\r\n    //电梯门关了再打开，逗你玩呢，那这个允许呀\r\n    @Override\r\n    public void open() {\r\n        super.context.setLiftState(Context.openningState);\r\n        super.context.open();\r\n    }\r\n\r\n\r\n    //电梯门关了就跑，这是再正常不过了\r\n    @Override\r\n    public void run() {\r\n        super.context.setLiftState(Context.runningState);\r\n        super.context.run();\r\n    }\r\n\r\n    //电梯门关着，我就不按楼层\r\n    @Override\r\n    public void stop() {\r\n        super.context.setLiftState(Context.stoppingState);\r\n        super.context.stop();\r\n    }\r\n}\r\n\r\n//环境角色\r\npublic class Context {\r\n    //定义出所有的电梯状态\r\n    public final static OpenningState openningState = new OpenningState();//开门状态，这时候电梯只能关闭\r\n    public final static ClosingState closeingState = new ClosingState();//关闭状态，这时候电梯可以运行、停止和开门\r\n    public final static RunningState runningState = new RunningState();//运行状态，这时候电梯只能停止\r\n    public final static StoppingState stoppingState = new StoppingState();//停止状态，这时候电梯可以开门、运行\r\n\r\n\r\n    //定义一个当前电梯状态\r\n    private LiftState liftState;\r\n\r\n    public LiftState getLiftState() {\r\n        return this.liftState;\r\n    }\r\n\r\n    public void setLiftState(LiftState liftState) {\r\n        //当前环境改变\r\n        this.liftState = liftState;\r\n        //把当前的环境通知到各个实现类中\r\n        this.liftState.setContext(this);\r\n    }\r\n\r\n    public void open() {\r\n        this.liftState.open();\r\n    }\r\n\r\n    public void close() {\r\n        this.liftState.close();\r\n    }\r\n\r\n    public void run() {\r\n        this.liftState.run();\r\n    }\r\n\r\n    public void stop() {\r\n        this.liftState.stop();\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Context context = new Context();\r\n        context.setLiftState(new ClosingState());\r\n\r\n        context.open();\r\n        context.close();\r\n        context.run();\r\n        context.stop();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 6.5.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n* 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。\r\n* 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。\r\n\r\n**2，缺点：**\r\n\r\n* 状态模式的使用必然会增加系统类和对象的个数。 \r\n* 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。\r\n* 状态模式对\"开闭原则\"的支持并不太好。\r\n\r\n\r\n\r\n### 6.5.5 使用场景\r\n\r\n- 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。\r\n- 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。\r\n\r\n\r\n\r\n## 6.6 观察者模式\r\n\r\n### 6.6.1 概述\r\n\r\n**定义：**\r\n\r\n又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。\r\n\r\n\r\n\r\n### 6.6.2 结构\r\n\r\n在观察者模式中有如下角色：\r\n\r\n* Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。\r\n* ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。\r\n* Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。\r\n* ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。\r\n\r\n\r\n\r\n### 6.6.3 案例实现\r\n\r\n【例】微信公众号\r\n\r\n在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。\r\n\r\n类图如下：\r\n\r\n<img src=\"img/观察者模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n定义抽象观察者类，里面定义一个更新的方法\r\n\r\n```java\r\npublic interface Observer {\r\n    void update(String message);\r\n}\r\n```\r\n\r\n定义具体观察者类，微信用户是观察者，里面实现了更新的方法\r\n\r\n```java\r\npublic class WeixinUser implements Observer {\r\n    // 微信用户名\r\n    private String name;\r\n\r\n    public WeixinUser(String name) {\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public void update(String message) {\r\n        System.out.println(name + \"-\" + message);\r\n    }\r\n}\r\n```\r\n\r\n定义抽象主题类，提供了attach、detach、notify三个方法\r\n\r\n```java\r\npublic interface Subject {\r\n    //增加订阅者\r\n    public void attach(Observer observer);\r\n\r\n    //删除订阅者\r\n    public void detach(Observer observer);\r\n    \r\n    //通知订阅者更新消息\r\n    public void notify(String message);\r\n}\r\n\r\n```\r\n\r\n微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法\r\n\r\n```java\r\npublic class SubscriptionSubject implements Subject {\r\n    //储存订阅公众号的微信用户\r\n    private List<Observer> weixinUserlist = new ArrayList<Observer>();\r\n\r\n    @Override\r\n    public void attach(Observer observer) {\r\n        weixinUserlist.add(observer);\r\n    }\r\n\r\n    @Override\r\n    public void detach(Observer observer) {\r\n        weixinUserlist.remove(observer);\r\n    }\r\n\r\n    @Override\r\n    public void notify(String message) {\r\n        for (Observer observer : weixinUserlist) {\r\n            observer.update(message);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n客户端程序\r\n\r\n```java\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        SubscriptionSubject mSubscriptionSubject=new SubscriptionSubject();\r\n        //创建微信用户\r\n        WeixinUser user1=new WeixinUser(\"孙悟空\");\r\n        WeixinUser user2=new WeixinUser(\"猪悟能\");\r\n        WeixinUser user3=new WeixinUser(\"沙悟净\");\r\n        //订阅公众号\r\n        mSubscriptionSubject.attach(user1);\r\n        mSubscriptionSubject.attach(user2);\r\n        mSubscriptionSubject.attach(user3);\r\n        //公众号更新发出消息给订阅的微信用户\r\n        mSubscriptionSubject.notify(\"传智黑马的专栏更新了\");\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 6.6.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n* 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。\r\n* 被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】\r\n\r\n**2，缺点：**\r\n\r\n* 如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时\r\n* 如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃\r\n\r\n\r\n\r\n### 6.6.5 使用场景\r\n\r\n* 对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。\r\n* 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。\r\n\r\n\r\n\r\n### 6.6.6 JDK中提供的实现\r\n\r\n在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。\r\n\r\n**1，Observable类**\r\n\r\nObservable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。\r\n\r\n* void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。\r\n\r\n* void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。\r\n\r\n* void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。\r\n\r\n**2，Observer 接口**\r\n\r\nObserver 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。\r\n\r\n【例】警察抓小偷\r\n\r\n警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：\r\n\r\n小偷是一个被观察者，所以需要继承Observable类\r\n\r\n```java\r\npublic class Thief extends Observable {\r\n\r\n    private String name;\r\n\r\n    public Thief(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void steal() {\r\n        System.out.println(\"小偷：我偷东西了，有没有人来抓我！！！\");\r\n        super.setChanged(); //changed  = true\r\n        super.notifyObservers();\r\n    }\r\n}\r\n\r\n```\r\n\r\n警察是一个观察者，所以需要让其实现Observer接口\r\n\r\n```java\r\npublic class Policemen implements Observer {\r\n\r\n    private String name;\r\n\r\n    public Policemen(String name) {\r\n        this.name = name;\r\n    }\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public void update(Observable o, Object arg) {\r\n        System.out.println(\"警察：\" + ((Thief) o).getName() + \"，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！\");\r\n    }\r\n}\r\n```\r\n\r\n客户端代码\r\n\r\n```java\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //创建小偷对象\r\n        Thief t = new Thief(\"隔壁老王\");\r\n        //创建警察对象\r\n        Policemen p = new Policemen(\"小李\");\r\n        //让警察盯着小偷\r\n        t.addObserver(p);\r\n        //小偷偷东西\r\n        t.steal();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 6.7 中介者模式\r\n\r\n### 6.7.1 概述\r\n\r\n一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。\r\n\r\n如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。\r\n\r\n<img src=\"img/image-20200214110924010.png\" style=\"zoom:60%;\" />\r\n\r\n**定义：**\r\n\r\n又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。\r\n\r\n\r\n\r\n### 6.7.2 结构\r\n\r\n中介者模式包含以下主要角色：\r\n\r\n* 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。\r\n\r\n* 具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。\r\n* 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。\r\n* 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。\r\n\r\n\r\n\r\n### 6.7.3 案例实现\r\n\r\n【例】租房\r\n\r\n现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。\r\n\r\n类图如下：\r\n\r\n<img src=\"img/中介者模式.png\" style=\"zoom:70%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//抽象中介者\r\npublic abstract class Mediator {\r\n    //申明一个联络方法\r\n    public abstract void constact(String message,Person person);\r\n}\r\n\r\n//抽象同事类\r\npublic abstract class Person {\r\n    protected String name;\r\n    protected Mediator mediator;\r\n\r\n    public Person(String name,Mediator mediator){\r\n        this.name = name;\r\n        this.mediator = mediator;\r\n    }\r\n}\r\n\r\n//具体同事类 房屋拥有者\r\npublic class HouseOwner extends Person {\r\n\r\n    public HouseOwner(String name, Mediator mediator) {\r\n        super(name, mediator);\r\n    }\r\n\r\n    //与中介者联系\r\n    public void constact(String message){\r\n        mediator.constact(message, this);\r\n    }\r\n\r\n    //获取信息\r\n    public void getMessage(String message){\r\n        System.out.println(\"房主\" + name +\"获取到的信息：\" + message);\r\n    }\r\n}\r\n\r\n//具体同事类 承租人\r\npublic class Tenant extends Person {\r\n    public Tenant(String name, Mediator mediator) {\r\n        super(name, mediator);\r\n    }\r\n\r\n    //与中介者联系\r\n    public void constact(String message){\r\n        mediator.constact(message, this);\r\n    }\r\n\r\n    //获取信息\r\n    public void getMessage(String message){\r\n        System.out.println(\"租房者\" + name +\"获取到的信息：\" + message);\r\n    }\r\n}\r\n\r\n//中介机构\r\npublic class MediatorStructure extends Mediator {\r\n    //首先中介结构必须知道所有房主和租房者的信息\r\n    private HouseOwner houseOwner;\r\n    private Tenant tenant;\r\n\r\n    public HouseOwner getHouseOwner() {\r\n        return houseOwner;\r\n    }\r\n\r\n    public void setHouseOwner(HouseOwner houseOwner) {\r\n        this.houseOwner = houseOwner;\r\n    }\r\n\r\n    public Tenant getTenant() {\r\n        return tenant;\r\n    }\r\n\r\n    public void setTenant(Tenant tenant) {\r\n        this.tenant = tenant;\r\n    }\r\n\r\n    public void constact(String message, Person person) {\r\n        if (person == houseOwner) {          //如果是房主，则租房者获得信息\r\n            tenant.getMessage(message);\r\n        } else {       //反正则是房主获得信息\r\n            houseOwner.getMessage(message);\r\n        }\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //一个房主、一个租房者、一个中介机构\r\n        MediatorStructure mediator = new MediatorStructure();\r\n\r\n        //房主和租房者只需要知道中介机构即可\r\n        HouseOwner houseOwner = new HouseOwner(\"张三\", mediator);\r\n        Tenant tenant = new Tenant(\"李四\", mediator);\r\n\r\n        //中介结构要知道房主和租房者\r\n        mediator.setHouseOwner(houseOwner);\r\n        mediator.setTenant(tenant);\r\n\r\n        tenant.constact(\"需要租三室的房子\");\r\n        houseOwner.constact(\"我这有三室的房子，你需要租吗？\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 6.7.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n* 松散耦合\r\n\r\n  中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。\r\n\r\n* 集中控制交互\r\n\r\n  多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。\r\n\r\n* 一对多关联转变为一对一的关联\r\n\r\n  没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。\r\n\r\n**2，缺点：**\r\n\r\n当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。\r\n\r\n\r\n\r\n### 6.7.5 使用场景\r\n\r\n* 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。\r\n* 当想创建一个运行于多个类之间的对象，又不想生成新的子类时。\r\n\r\n\r\n\r\n\r\n\r\n## 6.8 迭代器模式\r\n\r\n### 6.8.1 概述\r\n\r\n**定义：**\r\n\r\n提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 \r\n\r\n\r\n\r\n### 6.8.2 结构\r\n\r\n迭代器模式主要包含以下角色：\r\n\r\n* 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。\r\n\r\n* 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。\r\n* 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。\r\n* 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。\r\n\r\n\r\n\r\n### 6.8.3 案例实现\r\n\r\n【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：\r\n\r\n<img src=\"img/迭代器模式.png\" style=\"zoom:90%;\" />\r\n\r\n\r\n\r\n代码如下：\r\n\r\n定义迭代器接口，声明hasNext、next方法\r\n\r\n```java\r\npublic interface StudentIterator {\r\n    boolean hasNext();\r\n    Student next();\r\n}\r\n```\r\n\r\n定义具体的迭代器类，重写所有的抽象方法\r\n\r\n```java\r\npublic class StudentIteratorImpl implements StudentIterator {\r\n    private List<Student> list;\r\n    private int position = 0;\r\n\r\n    public StudentIteratorImpl(List<Student> list) {\r\n        this.list = list;\r\n    }\r\n\r\n    @Override\r\n    public boolean hasNext() {\r\n        return position < list.size();\r\n    }\r\n\r\n    @Override\r\n    public Student next() {\r\n        Student currentStudent = list.get(position);\r\n        position ++;\r\n        return currentStudent;\r\n    }\r\n}\r\n```\r\n\r\n定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法\r\n\r\n```java\r\npublic interface StudentAggregate {\r\n    void addStudent(Student student);\r\n\r\n    void removeStudent(Student student);\r\n\r\n    StudentIterator getStudentIterator();\r\n}\r\n```\r\n\r\n定义具体的容器类，重写所有的方法\r\n\r\n```java\r\npublic class StudentAggregateImpl implements StudentAggregate {\r\n\r\n    private List<Student> list = new ArrayList<Student>();  // 学生列表\r\n\r\n    @Override\r\n    public void addStudent(Student student) {\r\n        this.list.add(student);\r\n    }\r\n\r\n    @Override\r\n    public void removeStudent(Student student) {\r\n        this.list.remove(student);\r\n    }\r\n\r\n    @Override\r\n    public StudentIterator getStudentIterator() {\r\n        return new StudentIteratorImpl(list);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 6.8.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n* 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。\r\n* 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。\r\n* 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。\r\n\r\n**2，缺点：**\r\n\r\n增加了类的个数，这在一定程度上增加了系统的复杂性。\r\n\r\n\r\n\r\n### 6.8.5 使用场景\r\n\r\n* 当需要为聚合对象提供多种遍历方式时。\r\n* 当需要为遍历不同的聚合结构提供一个统一的接口时。\r\n* 当访问一个聚合对象的内容而无须暴露其内部细节的表示时。\r\n\r\n\r\n\r\n### 6.8.6 JDK源码解析\r\n\r\n迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。\r\n\r\n```java\r\nList<String> list = new ArrayList<>();\r\nIterator<String> iterator = list.iterator(); //list.iterator()方法返回的肯定是Iterator接口的子实现类对象\r\nwhile (iterator.hasNext()) {\r\n    System.out.println(iterator.next());\r\n}\r\n```\r\n\r\n看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明\r\n\r\n- List：抽象聚合类\r\n- ArrayList：具体的聚合类\r\n- Iterator：抽象迭代器\r\n- list.iterator()：返回的是实现了 `Iterator` 接口的具体迭代器对象\r\n\r\n具体的来看看 ArrayList的代码实现\r\n\r\n```java\r\npublic class ArrayList<E> extends AbstractList<E>\r\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\r\n    \r\n    public Iterator<E> iterator() {\r\n        return new Itr();\r\n    }\r\n    \r\n    private class Itr implements Iterator<E> {\r\n        int cursor;       // 下一个要返回元素的索引\r\n        int lastRet = -1; // 上一个返回元素的索引\r\n        int expectedModCount = modCount;\r\n\r\n        Itr() {}\r\n\t\t\r\n        //判断是否还有元素\r\n        public boolean hasNext() {\r\n            return cursor != size;\r\n        }\r\n\r\n        //获取下一个元素\r\n        public E next() {\r\n            checkForComodification();\r\n            int i = cursor;\r\n            if (i >= size)\r\n                throw new NoSuchElementException();\r\n            Object[] elementData = ArrayList.this.elementData;\r\n            if (i >= elementData.length)\r\n                throw new ConcurrentModificationException();\r\n            cursor = i + 1;\r\n            return (E) elementData[lastRet = i];\r\n        }\r\n        ...\r\n}\r\n```\r\n\r\n这部分代码还是比较简单，大致就是在 `iterator` 方法中返回了一个实例化的 `Iterator` 对象。Itr是一个内部类，它实现了 `Iterator` 接口并重写了其中的抽象方法。\r\n\r\n> 注意： \r\n>\r\n> ​\t当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现`java.util.Iterable`并实现其中的iterator()方法使其返回一个 `java.util.Iterator` 的实现类就可以了。\r\n\r\n\r\n\r\n\r\n\r\n## 6.9 访问者模式\r\n\r\n### 6.9.1 概述\r\n\r\n**定义：**\r\n\r\n封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。\r\n\r\n\r\n\r\n### 6.9.2 结构\r\n\r\n访问者模式包含以下主要角色:\r\n\r\n* 抽象访问者（Visitor）角色：定义了对每一个元素`（Element）`访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。\r\n* 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。\r\n* 抽象元素（Element）角色：定义了一个接受访问者的方法（`accept`），其意义是指，每一个元素都要可以被访问者访问。\r\n* 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。\r\n* 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（`Element`），并且可以迭代这些元素，供访问者访问。\r\n\r\n\r\n\r\n### 6.9.3 案例实现\r\n\r\n【例】给宠物喂食\r\n\r\n现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。\r\n\r\n- 访问者角色：给宠物喂食的人\r\n- 具体访问者角色：主人、其他人\r\n- 抽象元素角色：动物抽象类\r\n- 具体元素角色：宠物狗、宠物猫\r\n- 结构对象角色：主人家\r\n\r\n类图如下：\r\n\r\n![](img\\访问者模式.png)\r\n\r\n代码如下：\r\n\r\n创建抽象访问者接口\r\n\r\n```java\r\npublic interface Person {\r\n    void feed(Cat cat);\r\n\r\n    void feed(Dog dog);\r\n}\r\n```\r\n\r\n创建不同的具体访问者角色（主人和其他人），都需要实现 `Person`接口\r\n\r\n```java\r\npublic class Owner implements Person {\r\n\r\n    @Override\r\n    public void feed(Cat cat) {\r\n        System.out.println(\"主人喂食猫\");\r\n    }\r\n\r\n    @Override\r\n    public void feed(Dog dog) {\r\n        System.out.println(\"主人喂食狗\");\r\n    }\r\n}\r\n\r\npublic class Someone implements Person {\r\n    @Override\r\n    public void feed(Cat cat) {\r\n        System.out.println(\"其他人喂食猫\");\r\n    }\r\n\r\n    @Override\r\n    public void feed(Dog dog) {\r\n        System.out.println(\"其他人喂食狗\");\r\n    }\r\n}\r\n```\r\n\r\n定义抽象节点 -- 宠物\r\n\r\n```java\r\npublic interface Animal {\r\n    void accept(Person person);\r\n}\r\n```\r\n\r\n定义实现`Animal`接口的 具体节点（元素）\r\n\r\n```java\r\npublic class Dog implements Animal {\r\n\r\n    @Override\r\n    public void accept(Person person) {\r\n        person.feed(this);\r\n        System.out.println(\"好好吃，汪汪汪！！！\");\r\n    }\r\n}\r\n\r\npublic class Cat implements Animal {\r\n\r\n    @Override\r\n    public void accept(Person person) {\r\n        person.feed(this);\r\n        System.out.println(\"好好吃，喵喵喵！！！\");\r\n    }\r\n}\r\n```\r\n\r\n定义对象结构，此案例中就是主人的家\r\n\r\n```java\r\npublic class Home {\r\n    private List<Animal> nodeList = new ArrayList<Animal>();\r\n\r\n    public void action(Person person) {\r\n        for (Animal node : nodeList) {\r\n            node.accept(person);\r\n        }\r\n    }\r\n\r\n    //添加操作\r\n    public void add(Animal animal) {\r\n        nodeList.add(animal);\r\n    }\r\n}\r\n\r\n```\r\n\r\n测试类\r\n\r\n```java\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Home home = new Home();\r\n        home.add(new Dog());\r\n        home.add(new Cat());\r\n\r\n        Owner owner = new Owner();\r\n        home.action(owner);\r\n\r\n        Someone someone = new Someone();\r\n        home.action(someone);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 6.9.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n* 扩展性好\r\n\r\n  在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。\r\n\r\n* 复用性好\r\n\r\n  通过访问者来定义整个对象结构通用的功能，从而提高复用程度。\r\n\r\n* 分离无关行为\r\n\r\n  通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。\r\n\r\n**2，缺点：**\r\n\r\n* 对象结构变化很困难\r\n\r\n  在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。\r\n\r\n* 违反了依赖倒置原则\r\n\r\n  访问者模式依赖了具体类，而没有依赖抽象类。\r\n\r\n\r\n\r\n### 6.9.5  使用场景\r\n\r\n* 对象结构相对稳定，但其操作算法经常变化的程序。\r\n\r\n* 对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。\r\n\r\n  \r\n\r\n### 6.9.6 扩展\r\n\r\n访问者模式用到了一种双分派的技术。\r\n\r\n**1，分派：**\r\n\r\n变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 `Map map = new HashMap()` ，map变量的静态类型是 `Map` ，实际类型是 `HashMap` 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。\r\n\r\n**静态分派(Static Dispatch)** 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。\r\n\r\n**动态分派(Dynamic Dispatch)** 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。\r\n\r\n**2，动态分派：**\r\n\r\n通过方法的重写支持动态分派。\r\n\r\n```java\r\npublic class Animal {\r\n    public void execute() {\r\n        System.out.println(\"Animal\");\r\n    }\r\n}\r\n\r\npublic class Dog extends Animal {\r\n    @Override\r\n    public void execute() {\r\n        System.out.println(\"dog\");\r\n    }\r\n}\r\n\r\npublic class Cat extends Animal {\r\n     @Override\r\n    public void execute() {\r\n        System.out.println(\"cat\");\r\n    }\r\n}\r\n\r\npublic class Client {\r\n   \tpublic static void main(String[] args) {\r\n        Animal a = new Dog();\r\n        a.execute();\r\n        \r\n        Animal a1 = new Cat();\r\n        a1.execute();\r\n    }\r\n}\r\n```\r\n\r\n上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。\r\n\r\nJava编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。\r\n\r\n**3，静态分派：**\r\n\r\n通过方法重载支持静态分派。\r\n\r\n```java\r\npublic class Animal {\r\n}\r\n\r\npublic class Dog extends Animal {\r\n}\r\n\r\npublic class Cat extends Animal {\r\n}\r\n\r\npublic class Execute {\r\n    public void execute(Animal a) {\r\n        System.out.println(\"Animal\");\r\n    }\r\n\r\n    public void execute(Dog d) {\r\n        System.out.println(\"dog\");\r\n    }\r\n\r\n    public void execute(Cat c) {\r\n        System.out.println(\"cat\");\r\n    }\r\n}\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Animal a = new Animal();\r\n        Animal a1 = new Dog();\r\n        Animal a2 = new Cat();\r\n\r\n        Execute exe = new Execute();\r\n        exe.execute(a);\r\n        exe.execute(a1);\r\n        exe.execute(a2);\r\n    }\r\n}\r\n```\r\n\r\n运行结果：\r\n\r\n<img src=\"img/image-20200214215446638.png\" style=\"zoom:70%;\" />\r\n\r\n这个结果可能出乎一些人的意料了，为什么呢？\r\n\r\n**重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。**\r\n\r\n**4，双分派：**\r\n\r\n所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。\r\n\r\n```java\r\npublic class Animal {\r\n    public void accept(Execute exe) {\r\n        exe.execute(this);\r\n    }\r\n}\r\n\r\npublic class Dog extends Animal {\r\n    public void accept(Execute exe) {\r\n        exe.execute(this);\r\n    }\r\n}\r\n\r\npublic class Cat extends Animal {\r\n    public void accept(Execute exe) {\r\n        exe.execute(this);\r\n    }\r\n}\r\n\r\npublic class Execute {\r\n    public void execute(Animal a) {\r\n        System.out.println(\"animal\");\r\n    }\r\n\r\n    public void execute(Dog d) {\r\n        System.out.println(\"dog\");\r\n    }\r\n\r\n    public void execute(Cat c) {\r\n        System.out.println(\"cat\");\r\n    }\r\n}\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Animal a = new Animal();\r\n        Animal d = new Dog();\r\n        Animal c = new Cat();\r\n\r\n        Execute exe = new Execute();\r\n        a.accept(exe);\r\n        d.accept(exe);\r\n        c.accept(exe);\r\n    }\r\n}\r\n```\r\n\r\n在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也`将自己this作为参数传递进去，这里就完成了第二次分派`，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。\r\n\r\n说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。\r\n\r\n运行结果如下：\r\n\r\n<img src=\"img/image-20200426233931693.png\" style=\"zoom:67%;\" />\r\n\r\n**双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。**\r\n\r\n\r\n\r\n## 6.10 备忘录模式\r\n\r\n### 6.10.1 概述\r\n\r\n备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。\r\n\r\n**定义：**\r\n\r\n又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。\r\n\r\n\r\n\r\n### 6.10.2 结构\r\n\r\n备忘录模式的主要角色如下：\r\n\r\n* 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。\r\n* 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。\r\n* 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。\r\n\r\n> 备忘录有两个等效的接口：\r\n>\r\n> * **窄接口**：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。\r\n> * **宽接口**：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。\r\n\r\n\r\n\r\n### 6.10.3 案例实现\r\n\r\n【例】游戏挑战BOSS\r\n\r\n游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。\r\n\r\n要实现上述案例，有两种方式：\r\n\r\n* “白箱”备忘录模式\r\n* “黑箱”备忘录模式\r\n\r\n\r\n\r\n#### 6.10.3.1 “白箱”备忘录模式\r\n\r\n备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：\r\n\r\n<img src=\"img/白箱备忘录模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//游戏角色类\r\npublic class GameRole {\r\n    private int vit; //生命力\r\n    private int atk; //攻击力\r\n    private int def; //防御力\r\n\r\n    //初始化状态\r\n    public void initState() {\r\n        this.vit = 100;\r\n        this.atk = 100;\r\n        this.def = 100;\r\n    }\r\n\r\n    //战斗\r\n    public void fight() {\r\n        this.vit = 0;\r\n        this.atk = 0;\r\n        this.def = 0;\r\n    }\r\n\r\n    //保存角色状态\r\n    public RoleStateMemento saveState() {\r\n        return new RoleStateMemento(vit, atk, def);\r\n    }\r\n\r\n    //回复角色状态\r\n    public void recoverState(RoleStateMemento roleStateMemento) {\r\n        this.vit = roleStateMemento.getVit();\r\n        this.atk = roleStateMemento.getAtk();\r\n        this.def = roleStateMemento.getDef();\r\n    }\r\n\r\n    public void stateDisplay() {\r\n        System.out.println(\"角色生命力：\" + vit);\r\n        System.out.println(\"角色攻击力：\" + atk);\r\n        System.out.println(\"角色防御力：\" + def);\r\n    }\r\n\r\n    public int getVit() {\r\n        return vit;\r\n    }\r\n\r\n    public void setVit(int vit) {\r\n        this.vit = vit;\r\n    }\r\n\r\n    public int getAtk() {\r\n        return atk;\r\n    }\r\n\r\n    public void setAtk(int atk) {\r\n        this.atk = atk;\r\n    }\r\n\r\n    public int getDef() {\r\n        return def;\r\n    }\r\n\r\n    public void setDef(int def) {\r\n        this.def = def;\r\n    }\r\n}\r\n\r\n//游戏状态存储类(备忘录类)\r\npublic class RoleStateMemento {\r\n    private int vit;\r\n    private int atk;\r\n    private int def;\r\n\r\n    public RoleStateMemento(int vit, int atk, int def) {\r\n        this.vit = vit;\r\n        this.atk = atk;\r\n        this.def = def;\r\n    }\r\n\r\n    public int getVit() {\r\n        return vit;\r\n    }\r\n\r\n    public void setVit(int vit) {\r\n        this.vit = vit;\r\n    }\r\n\r\n    public int getAtk() {\r\n        return atk;\r\n    }\r\n\r\n    public void setAtk(int atk) {\r\n        this.atk = atk;\r\n    }\r\n\r\n    public int getDef() {\r\n        return def;\r\n    }\r\n\r\n    public void setDef(int def) {\r\n        this.def = def;\r\n    }\r\n}\r\n\r\n//角色状态管理者类\r\npublic class RoleStateCaretaker {\r\n    private RoleStateMemento roleStateMemento;\r\n\r\n    public RoleStateMemento getRoleStateMemento() {\r\n        return roleStateMemento;\r\n    }\r\n\r\n    public void setRoleStateMemento(RoleStateMemento roleStateMemento) {\r\n        this.roleStateMemento = roleStateMemento;\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"------------大战Boss前------------\");\r\n        //大战Boss前\r\n        GameRole gameRole = new GameRole();\r\n        gameRole.initState();\r\n        gameRole.stateDisplay();\r\n\r\n        //保存进度\r\n        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();\r\n        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());\r\n\r\n        System.out.println(\"------------大战Boss后------------\");\r\n        //大战Boss时，损耗严重\r\n        gameRole.fight();\r\n        gameRole.stateDisplay();\r\n        System.out.println(\"------------恢复之前状态------------\");\r\n        //恢复之前状态\r\n        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());\r\n        gameRole.stateDisplay();\r\n\r\n    }\r\n}\r\n```\r\n\r\n> 分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。\r\n\r\n\r\n\r\n#### 6.10.3.2 “黑箱”备忘录模式\r\n\r\n备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将**备忘录类**设计成**发起人类**的内部成员类。\r\n\r\n将 `RoleStateMemento` 设为 `GameRole` 的内部类，从而将 `RoleStateMemento` 对象封装在 `GameRole` 里面；在外面提供一个标识接口 `Memento` 给 `RoleStateCaretaker` 及其他对象使用。这样 `GameRole` 类看到的是 `RoleStateMemento` 所有的接口，而`RoleStateCaretaker`  及其他对象看到的仅仅是标识接口 `Memento` 所暴露出来的接口，从而维护了封装型。类图如下：\r\n\r\n<img src=\"img/黑箱备忘录模式.png\" style=\"zoom:70%;\" />\r\n\r\n代码如下：\r\n\r\n窄接口`Memento`，这是一个标识接口，因此没有定义出任何的方法\r\n\r\n```java\r\npublic interface Memento {\r\n}\r\n```\r\n\r\n定义发起人类 `GameRole`，并在内部定义备忘录内部类 `RoleStateMemento`（该内部类设置为私有的）\r\n\r\n```java\r\n/游戏角色类\r\npublic class GameRole {\r\n    private int vit; //生命力\r\n    private int atk; //攻击力\r\n    private int def; //防御力\r\n\r\n    //初始化状态\r\n    public void initState() {\r\n        this.vit = 100;\r\n        this.atk = 100;\r\n        this.def = 100;\r\n    }\r\n\r\n    //战斗\r\n    public void fight() {\r\n        this.vit = 0;\r\n        this.atk = 0;\r\n        this.def = 0;\r\n    }\r\n\r\n    //保存角色状态\r\n    public Memento saveState() {\r\n        return new RoleStateMemento(vit, atk, def);\r\n    }\r\n\r\n    //回复角色状态\r\n    public void recoverState(Memento memento) {\r\n        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;\r\n        this.vit = roleStateMemento.getVit();\r\n        this.atk = roleStateMemento.getAtk();\r\n        this.def = roleStateMemento.getDef();\r\n    }\r\n\r\n    public void stateDisplay() {\r\n        System.out.println(\"角色生命力：\" + vit);\r\n        System.out.println(\"角色攻击力：\" + atk);\r\n        System.out.println(\"角色防御力：\" + def);\r\n\r\n    }\r\n\r\n    public int getVit() {\r\n        return vit;\r\n    }\r\n\r\n    public void setVit(int vit) {\r\n        this.vit = vit;\r\n    }\r\n\r\n    public int getAtk() {\r\n        return atk;\r\n    }\r\n\r\n    public void setAtk(int atk) {\r\n        this.atk = atk;\r\n    }\r\n\r\n    public int getDef() {\r\n        return def;\r\n    }\r\n\r\n    public void setDef(int def) {\r\n        this.def = def;\r\n    }\r\n\r\n    private class RoleStateMemento implements Memento {\r\n        private int vit;\r\n        private int atk;\r\n        private int def;\r\n\r\n        public RoleStateMemento(int vit, int atk, int def) {\r\n            this.vit = vit;\r\n            this.atk = atk;\r\n            this.def = def;\r\n        }\r\n\r\n        public int getVit() {\r\n            return vit;\r\n        }\r\n\r\n        public void setVit(int vit) {\r\n            this.vit = vit;\r\n        }\r\n\r\n        public int getAtk() {\r\n            return atk;\r\n        }\r\n\r\n        public void setAtk(int atk) {\r\n            this.atk = atk;\r\n        }\r\n\r\n        public int getDef() {\r\n            return def;\r\n        }\r\n\r\n        public void setDef(int def) {\r\n            this.def = def;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n负责人角色类 `RoleStateCaretaker` 能够得到的备忘录对象是以 `Memento` 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容\r\n\r\n```java\r\n//角色状态管理者类\r\npublic class RoleStateCaretaker {\r\n    private Memento memento;\r\n\r\n    public Memento getMemento() {\r\n        return memento;\r\n    }\r\n\r\n    public void setMemento(Memento memento) {\r\n        this.memento = memento;\r\n    }\r\n}\r\n```\r\n\r\n客户端测试类\r\n\r\n```java\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        System.out.println(\"------------大战Boss前------------\");\r\n        //大战Boss前\r\n        GameRole gameRole = new GameRole();\r\n        gameRole.initState();\r\n        gameRole.stateDisplay();\r\n\r\n        //保存进度\r\n        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();\r\n        roleStateCaretaker.setMemento(gameRole.saveState());\r\n        \r\n        System.out.println(\"------------大战Boss后------------\");\r\n        //大战Boss时，损耗严重\r\n        gameRole.fight();\r\n        gameRole.stateDisplay();\r\n        System.out.println(\"------------恢复之前状态------------\");\r\n        //恢复之前状态\r\n        gameRole.recoverState(roleStateCaretaker.getMemento());\r\n        gameRole.stateDisplay();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 6.10.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n- 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。\r\n- 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。\r\n- 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。\r\n\r\n**2，缺点：**\r\n\r\n* 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。\r\n\r\n\r\n\r\n### 6.10.5 使用场景\r\n\r\n* 需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。\r\n\r\n* 需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。\r\n\r\n\r\n\r\n# 6，行为型模式\r\n\r\n## 6.11 解释器模式\r\n\r\n### 6.11.1 概述\r\n\r\n<img src=\"img/image-20200215220322641.png\" style=\"zoom:60%;\" />\r\n\r\n如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。\r\n\r\n```java\r\n//用于两个整数相加\r\npublic static int add(int a,int b){\r\n    return a + b;\r\n}\r\n\r\n//用于两个整数相加\r\npublic static int add(int a,int b,int c){\r\n    return a + b + c;\r\n}\r\n\r\n//用于n个整数相加\r\npublic static int add(Integer ... arr) {\r\n    int sum = 0;\r\n    for (Integer i : arr) {\r\n        sum += i;\r\n    }\r\n    return sum;\r\n}\r\n```\r\n\r\n上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。   \r\n\r\n显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。\r\n\r\n**定义：**\r\n\r\n> 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\r\n\r\n在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。\r\n\r\n解释器就是要解析出来语句的含义。但是如何描述规则呢？\r\n\r\n**文法（语法）规则：**\r\n\r\n文法是用于描述语言的语法结构的形式规则。\r\n\r\n```\r\nexpression ::= value | plus | minus\r\nplus ::= expression ‘+’ expression   \r\nminus ::= expression ‘-’ expression  \r\nvalue ::= integer\r\n```\r\n\r\n> 注意： 这里的符号“::=”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。\r\n\r\n上面规则描述为 ：\r\n\r\n表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。\r\n\r\n**抽象语法树：**\r\n\r\n在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。\r\n\r\n用树形来表示符合文法规则的句子。\r\n\r\n<img src=\"img/image-20200215225227616.png\" style=\"zoom:50%;\" />\r\n\r\n### 6.11.2 结构\r\n\r\n解释器模式包含以下主要角色。\r\n\r\n* 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。\r\n\r\n* 终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。\r\n* 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。\r\n* 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。\r\n* 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。\r\n\r\n\r\n\r\n### 6.11.3 案例实现\r\n\r\n【例】设计实现加减法的软件\r\n\r\n<img src=\"img/解释器模式.png\" style=\"zoom:80%;\" />\r\n\r\n代码如下：\r\n\r\n```java\r\n//抽象角色AbstractExpression\r\npublic abstract class AbstractExpression {\r\n    public abstract int interpret(Context context);\r\n}\r\n\r\n//终结符表达式角色\r\npublic class Value extends AbstractExpression {\r\n    private int value;\r\n\r\n    public Value(int value) {\r\n        this.value = value;\r\n    }\r\n\r\n    @Override\r\n    public int interpret(Context context) {\r\n        return value;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return new Integer(value).toString();\r\n    }\r\n}\r\n\r\n//非终结符表达式角色  加法表达式\r\npublic class Plus extends AbstractExpression {\r\n    private AbstractExpression left;\r\n    private AbstractExpression right;\r\n\r\n    public Plus(AbstractExpression left, AbstractExpression right) {\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n\r\n    @Override\r\n    public int interpret(Context context) {\r\n        return left.interpret(context) + right.interpret(context);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"(\" + left.toString() + \" + \" + right.toString() + \")\";\r\n    }\r\n}\r\n\r\n///非终结符表达式角色 减法表达式\r\npublic class Minus extends AbstractExpression {\r\n    private AbstractExpression left;\r\n    private AbstractExpression right;\r\n\r\n    public Minus(AbstractExpression left, AbstractExpression right) {\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n\r\n    @Override\r\n    public int interpret(Context context) {\r\n        return left.interpret(context) - right.interpret(context);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"(\" + left.toString() + \" - \" + right.toString() + \")\";\r\n    }\r\n}\r\n\r\n//终结符表达式角色 变量表达式\r\npublic class Variable extends AbstractExpression {\r\n    private String name;\r\n\r\n    public Variable(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public int interpret(Context ctx) {\r\n        return ctx.getValue(this);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name;\r\n    }\r\n}\r\n\r\n//环境类\r\npublic class Context {\r\n    private Map<Variable, Integer> map = new HashMap<Variable, Integer>();\r\n\r\n    public void assign(Variable var, Integer value) {\r\n        map.put(var, value);\r\n    }\r\n\r\n    public int getValue(Variable var) {\r\n        Integer value = map.get(var);\r\n        return value;\r\n    }\r\n}\r\n\r\n//测试类\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Context context = new Context();\r\n\r\n        Variable a = new Variable(\"a\");\r\n        Variable b = new Variable(\"b\");\r\n        Variable c = new Variable(\"c\");\r\n        Variable d = new Variable(\"d\");\r\n        Variable e = new Variable(\"e\");\r\n        //Value v = new Value(1);\r\n\r\n        context.assign(a, 1);\r\n        context.assign(b, 2);\r\n        context.assign(c, 3);\r\n        context.assign(d, 4);\r\n        context.assign(e, 5);\r\n\r\n        AbstractExpression expression = new Minus(new Plus(new Plus(new Plus(a, b), c), d), e);\r\n\r\n        System.out.println(expression + \"= \" + expression.interpret(context));\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 6.11.4 优缺点\r\n\r\n**1，优点：**\r\n\r\n* 易于改变和扩展文法。\r\n\r\n  由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。\r\n\r\n* 实现文法较为容易。\r\n\r\n  在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。\r\n\r\n* 增加新的解释表达式较为方便。\r\n\r\n  如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 \"开闭原则\"。\r\n\r\n**2，缺点：**\r\n\r\n- 对于复杂文法难以维护。\r\n\r\n  在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。\r\n\r\n* 执行效率较低。\r\n\r\n  由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。\r\n\r\n\r\n\r\n### 6.11.5 使用场景\r\n\r\n* 当语言的文法较为简单，且执行效率不是关键问题时。\r\n\r\n* 当问题重复出现，且可以用一种简单的语言来进行表达时。\r\n\r\n* 当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。\r\n\r\n\r\n\r\n# 7，自定义Spring框架\r\n\r\n## 7.1 spring使用回顾\r\n\r\n自定义spring框架前，先回顾一下spring框架的使用，从而分析spring的核心，并对核心功能进行模拟。\r\n\r\n* 数据访问层。定义UserDao接口及其子实现类\r\n\r\n  ```java\r\n  public interface UserDao {\r\n      public void add();\r\n  }\r\n  \r\n  public class UserDaoImpl implements UserDao {\r\n  \r\n      public void add() {\r\n          System.out.println(\"userDaoImpl ....\");\r\n      }\r\n  }\r\n  ```\r\n\r\n* 业务逻辑层。定义UserService接口及其子实现类\r\n\r\n  ```java\r\n  public interface UserService {\r\n      public void add();\r\n  }\r\n  \r\n  public class UserServiceImpl implements UserService {\r\n  \r\n      private UserDao userDao;\r\n  \r\n      public void setUserDao(UserDao userDao) {\r\n          this.userDao = userDao;\r\n      }\r\n  \r\n      public void add() {\r\n          System.out.println(\"userServiceImpl ...\");\r\n          userDao.add();\r\n      }\r\n  }\r\n  ```\r\n\r\n* 定义UserController类，使用main方法模拟controller层\r\n\r\n  ```java\r\n  public class UserController {\r\n      public static void main(String[] args) {\r\n          //创建spring容器对象\r\n          ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\r\n          //从IOC容器中获取UserService对象\r\n          UserService userService = applicationContext.getBean(\"userService\", UserService.class);\r\n          //调用UserService对象的add方法\r\n          userService.add();\r\n      }\r\n  }\r\n  ```\r\n\r\n* 编写配置文件。在类路径下编写一个名为ApplicationContext.xml的配置文件\r\n\r\n  ```java\r\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n  <beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xmlns=\"http://www.springframework.org/schema/beans\"\r\n         xmlns:context=\"http://www.springframework.org/schema/context\"\r\n         xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n          http://www.springframework.org/schema/beans/spring-beans.xsd\r\n          http://www.springframework.org/schema/context\r\n          http://www.springframework.org/schema/context/spring-context.xsd\">\r\n  \r\n      <bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\">\r\n          <property name=\"userDao\" ref=\"userDao\"></property>\r\n      </bean>\r\n  \r\n      <bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"></bean>\r\n  \r\n  </beans>\r\n  ```\r\n\r\n  代码运行结果如下：\r\n\r\n  <img src=\"img/image-20200429165544151.png\" style=\"zoom:60%;\" />\r\n\r\n通过上面代码及结果可以看出：\r\n\r\n* userService对象是从applicationContext容器对象获取到的，也就是userService对象交由spring进行管理。\r\n* 上面结果可以看到调用了UserDao对象中的add方法，也就是说UserDao子实现类对象也交由spring管理了。\r\n* UserService中的userDao变量我们并没有进行赋值，但是可以正常使用，说明spring已经将UserDao对象赋值给了userDao变量。\r\n\r\n上面三点体现了Spring框架的IOC（Inversion of Control）和DI（Dependency Injection, DI）\r\n\r\n\r\n\r\n## 7.2 spring核心功能结构\r\n\r\nSpring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为:\r\n\r\n核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是 Spring 框架的总体架构图：\r\n\r\n<img src=\"img/image-20200429111324770.png\" style=\"zoom:40%;\" />\r\n\r\n\r\n\r\n核心容器由 beans、core、context 和 expression（Spring Expression Language，SpEL）4个模块组成。\r\n\r\n* spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。BeanFactory属于延时加载，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该 Bean 进行实例化与依赖关系的装配。\r\n* spring-context模块构架于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，它的超类是 BeanFactory。与BeanFactory不同，ApplicationContext实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。\r\n* spring-context-support模块是对Spring IoC容器及IoC子容器的扩展支持。\r\n* spring-context-indexer模块是Spring的类管理组件和Classpath扫描组件。\r\n* spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同Spring IoC进行交互。\r\n\r\n\r\n\r\n### 7.1.1 bean概述\r\n\r\nSpring 就是面向 `Bean` 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring IoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。\r\n\r\nspring中bean用于对一个类进行封装。如下面的配置：\r\n\r\n```xml\r\n<bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\">\r\n    <property name=\"userDao\" ref=\"userDao\"></property>\r\n</bean>\r\n<bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"></bean>\r\n```\r\n\r\n为什么Bean如此重要呢？\r\n\r\n* spring 将bean对象交由一个叫IOC容器进行管理。\r\n* bean对象之间的依赖关系在配置文件中体现，并由spring完成。\r\n\r\n\r\n\r\n## 7.3 Spring IOC相关接口分析\r\n\r\n### 7.3.1 BeanFactory解析\r\n\r\nSpring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。\r\n\r\n<img src=\"img/image-20200429185050396.png\" style=\"zoom:60%;\" />\r\n\r\n其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。\r\n\r\n那么为何要定义这么多层次的接口呢？\r\n\r\n每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如，\r\n\r\n* ListableBeanFactory接口表示这些Bean可列表化。\r\n* HierarchicalBeanFactory表示这些Bean 是有继承关系的，也就是每个 Bean 可能有父 Bean\r\n* AutowireCapableBeanFactory 接口定义Bean的自动装配规则。\r\n\r\n这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是BeanFactory，来看一下它的源码：\r\n\r\n```java\r\npublic interface BeanFactory {\r\n\r\n\tString FACTORY_BEAN_PREFIX = \"&\";\r\n\r\n\t//根据bean的名称获取IOC容器中的的bean对象\r\n\tObject getBean(String name) throws BeansException;\r\n\t//根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了\r\n\t<T> T getBean(String name, Class<T> requiredType) throws BeansException;\r\n\tObject getBean(String name, Object... args) throws BeansException;\r\n\t<T> T getBean(Class<T> requiredType) throws BeansException;\r\n\t<T> T getBean(Class<T> requiredType, Object... args) throws BeansException;\r\n\t\r\n\t<T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);\r\n\t<T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);\r\n\r\n\t//判断容器中是否包含指定名称的bean对象\r\n\tboolean containsBean(String name);\r\n\t//根据bean的名称判断是否是单例\r\n\tboolean isSingleton(String name) throws NoSuchBeanDefinitionException;\r\n\tboolean isPrototype(String name) throws NoSuchBeanDefinitionException;\r\n\tboolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\r\n\tboolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;\r\n\t@Nullable\r\n\tClass<?> getType(String name) throws NoSuchBeanDefinitionException;\r\n\tString[] getAliases(String name);\r\n}\r\n```\r\n\r\n在BeanFactory里只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。\r\n\r\nBeanFactory有一个很重要的子接口，就是ApplicationContext接口，该接口主要来规范容器中的bean对象是非延时加载，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。\r\n\r\n<img src=\"img/image-20200430220155371.png\" style=\"zoom:60%;\" />\r\n\r\n要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如：\r\n\r\n* ClasspathXmlApplicationContext : 根据类路径加载xml配置文件，并创建IOC容器对象。\r\n* FileSystemXmlApplicationContext ：根据系统路径加载xml配置文件，并创建IOC容器对象。\r\n* AnnotationConfigApplicationContext ：加载注解类配置，并创建IOC容器。\r\n\r\n\r\n\r\n### 7.3.2 BeanDefinition解析\r\n\r\nSpring IoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以BeanDefinition来描述的，如下面配置文件\r\n\r\n```xml\r\n<bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"></bean>\r\n\r\nbean标签还有很多属性：\r\n\tscope、init-method、destory-method等。\r\n```\r\n\r\n其继承体系如下图所示。\r\n\r\n<img src=\"img/image-20200429204239868.png\" style=\"zoom:60%;\" />\r\n\r\n\r\n\r\n### 7.3.3 BeanDefinitionReader解析\r\n\r\nBean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。\r\n\r\n<img src=\"img/image-20200429204700956.png\" style=\"zoom:60%;\" />\r\n\r\n看看BeanDefinitionReader接口定义的功能来理解它具体的作用：\r\n\r\n```java\r\npublic interface BeanDefinitionReader {\r\n\r\n\t//获取BeanDefinitionRegistry注册器对象\r\n\tBeanDefinitionRegistry getRegistry();\r\n\r\n\t@Nullable\r\n\tResourceLoader getResourceLoader();\r\n\r\n\t@Nullable\r\n\tClassLoader getBeanClassLoader();\r\n\r\n\tBeanNameGenerator getBeanNameGenerator();\r\n\r\n\t/*\r\n\t\t下面的loadBeanDefinitions都是加载bean定义，从指定的资源中\r\n\t*/\r\n\tint loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException;\r\n\tint loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException;\r\n\tint loadBeanDefinitions(String location) throws BeanDefinitionStoreException;\r\n\tint loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException;\r\n}\r\n```\r\n\r\n\r\n\r\n### 7.3.4 BeanDefinitionRegistry解析\r\n\r\nBeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry。\r\n\r\n```java\r\npublic interface BeanDefinitionRegistry extends AliasRegistry {\r\n\r\n\t//往注册表中注册bean\r\n\tvoid registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\r\n\t\t\tthrows BeanDefinitionStoreException;\r\n\r\n\t//从注册表中删除指定名称的bean\r\n\tvoid removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;\r\n\r\n\t//获取注册表中指定名称的bean\r\n\tBeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;\r\n    \r\n\t//判断注册表中是否已经注册了指定名称的bean\r\n\tboolean containsBeanDefinition(String beanName);\r\n    \r\n\t//获取注册表中所有的bean的名称\r\n\tString[] getBeanDefinitionNames();\r\n    \r\n\tint getBeanDefinitionCount();\r\n\tboolean isBeanNameInUse(String beanName);\r\n}\r\n```\r\n\r\n继承结构图如下：\r\n\r\n<img src=\"img/image-20200429211132185.png\" style=\"zoom:60%;\" />\r\n\r\n从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个：\r\n\r\n* DefaultListableBeanFactory\r\n\r\n  在该类中定义了如下代码，就是用来注册bean\r\n\r\n  ```java\r\n  private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(256);\r\n  ```\r\n\r\n* SimpleBeanDefinitionRegistry\r\n\r\n  在该类中定义了如下代码，就是用来注册bean\r\n\r\n  ```java\r\n  private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<>(64);\r\n  ```\r\n\r\n\r\n\r\n### 7.3.5 创建容器\r\n\r\nClassPathXmlApplicationContext对Bean配置资源的载入是从refresh（）方法开始的。refresh（）方法是一个模板方法，规定了 IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean 配置资源进行载入，ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh（）方法启动整个IoC容器对Bean定义的载入过程。\r\n\r\n\r\n\r\n\r\n\r\n## 7.4 自定义SpringIOC\r\n\r\n现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans>\r\n    <bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\">\r\n        <property name=\"userDao\" ref=\"userDao\"></property>\r\n    </bean>\r\n    <bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"></bean>\r\n</beans>\r\n```\r\n\r\n### 7.4.1 定义bean相关的pojo类\r\n\r\n#### 7.4.1.1 PropertyValue类\r\n\r\n用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。\r\n\r\n```java\r\npublic class PropertyValue {\r\n\r\n  private String name;\r\n  private String ref;\r\n  private String value;\r\n\r\n  public PropertyValue() {\r\n  }\r\n\r\n  public PropertyValue(String name, String ref,String value) {\r\n    this.name = name;\r\n    this.ref = ref;\r\n    this.value = value;\r\n  }\r\n\r\n  public String getName() {\r\n    return name;\r\n  }\r\n\r\n  public void setName(String name) {\r\n    this.name = name;\r\n  }\r\n\r\n  public String getRef() {\r\n    return ref;\r\n  }\r\n\r\n  public void setRef(String ref) {\r\n    this.ref = ref;\r\n  }\r\n\r\n  public String getValue() {\r\n    return value;\r\n  }\r\n\r\n  public void setValue(String value) {\r\n    this.value = value;\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 7.4.1.2 MutablePropertyValues类\r\n\r\n一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来存储并管理多个PropertyValue对象。\r\n\r\n```java\r\npublic class MutablePropertyValues implements Iterable<PropertyValue> {\r\n\r\n    private final List<PropertyValue> propertyValueList;\r\n\r\n    public MutablePropertyValues() {\r\n        this.propertyValueList = new ArrayList<PropertyValue>();\r\n    }\r\n\r\n    public MutablePropertyValues(List<PropertyValue> propertyValueList) {\r\n        this.propertyValueList = (propertyValueList != null ? propertyValueList : new ArrayList<PropertyValue>());\r\n    }\r\n\r\n    public PropertyValue[] getPropertyValues() {\r\n        return this.propertyValueList.toArray(new PropertyValue[0]);\r\n    }\r\n\r\n    public PropertyValue getPropertyValue(String propertyName) {\r\n        for (PropertyValue pv : this.propertyValueList) {\r\n            if (pv.getName().equals(propertyName)) {\r\n                return pv;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public Iterator<PropertyValue> iterator() {\r\n        return propertyValueList.iterator();\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return this.propertyValueList.isEmpty();\r\n    }\r\n\r\n    public MutablePropertyValues addPropertyValue(PropertyValue pv) {\r\n        for (int i = 0; i < this.propertyValueList.size(); i++) {\r\n            PropertyValue currentPv = this.propertyValueList.get(i);\r\n            if (currentPv.getName().equals(pv.getName())) {\r\n                this.propertyValueList.set(i, new PropertyValue(pv.getName(),pv.getRef(), pv.getValue()));\r\n                return this;\r\n            }\r\n        }\r\n        this.propertyValueList.add(pv);\r\n        return this;\r\n    }\r\n\r\n    public boolean contains(String propertyName) {\r\n        return getPropertyValue(propertyName) != null;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 7.4.1.3 BeanDefinition类\r\n\r\nBeanDefinition类用来封装bean信息的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。\r\n\r\n```java\r\npublic class BeanDefinition {\r\n    private String id;\r\n    private String className;\r\n\r\n    private MutablePropertyValues propertyValues;\r\n\r\n    public BeanDefinition() {\r\n        propertyValues = new MutablePropertyValues();\r\n    }\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getClassName() {\r\n        return className;\r\n    }\r\n\r\n    public void setClassName(String className) {\r\n        this.className = className;\r\n    }\r\n\r\n    public void setPropertyValues(MutablePropertyValues propertyValues) {\r\n        this.propertyValues = propertyValues;\r\n    }\r\n\r\n    public MutablePropertyValues getPropertyValues() {\r\n        return propertyValues;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 7.4.2 定义注册表相关类\r\n\r\n#### 7.4.2.1 BeanDefinitionRegistry接口\r\n\r\nBeanDefinitionRegistry接口定义了注册表的相关操作，定义如下功能：\r\n\r\n* 注册BeanDefinition对象到注册表中\r\n* 从注册表中删除指定名称的BeanDefinition对象\r\n* 根据名称从注册表中获取BeanDefinition对象\r\n* 判断注册表中是否包含指定名称的BeanDefinition对象\r\n* 获取注册表中BeanDefinition对象的个数\r\n* 获取注册表中所有的BeanDefinition的名称\r\n\r\n```java\r\npublic interface BeanDefinitionRegistry {\r\n\r\n    //注册BeanDefinition对象到注册表中\r\n    void registerBeanDefinition(String beanName, BeanDefinition beanDefinition);\r\n\r\n    //从注册表中删除指定名称的BeanDefinition对象\r\n    void removeBeanDefinition(String beanName) throws Exception;\r\n\r\n    //根据名称从注册表中获取BeanDefinition对象\r\n    BeanDefinition getBeanDefinition(String beanName) throws Exception;\r\n\r\n    boolean containsBeanDefinition(String beanName);\r\n\r\n    int getBeanDefinitionCount();\r\n\r\n    String[] getBeanDefinitionNames();\r\n}\r\n```\r\n\r\n\r\n\r\n#### 7.4.2.2 SimpleBeanDefinitionRegistry类\r\n\r\n该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。\r\n\r\n```java\r\npublic class SimpleBeanDefinitionRegistry implements BeanDefinitionRegistry {\r\n\r\n    private Map<String, BeanDefinition> beanDefinitionMap = new HashMap<String, BeanDefinition>();\r\n\r\n    @Override\r\n    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) {\r\n        beanDefinitionMap.put(beanName,beanDefinition);\r\n    }\r\n\r\n    @Override\r\n    public void removeBeanDefinition(String beanName) throws Exception {\r\n        beanDefinitionMap.remove(beanName);\r\n    }\r\n\r\n    @Override\r\n    public BeanDefinition getBeanDefinition(String beanName) throws Exception {\r\n        return beanDefinitionMap.get(beanName);\r\n    }\r\n\r\n    @Override\r\n    public boolean containsBeanDefinition(String beanName) {\r\n        return beanDefinitionMap.containsKey(beanName);\r\n    }\r\n\r\n    @Override\r\n    public int getBeanDefinitionCount() {\r\n        return beanDefinitionMap.size();\r\n    }\r\n\r\n    @Override\r\n    public String[] getBeanDefinitionNames() {\r\n        return beanDefinitionMap.keySet().toArray(new String[1]);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 7.4.3 定义解析器相关类\r\n\r\n#### 7.4.3.1 BeanDefinitionReader接口\r\n\r\nBeanDefinitionReader是用来解析配置文件并在注册表中注册bean的信息。定义了两个规范：\r\n\r\n* 获取注册表的功能，让外界可以通过该对象获取注册表对象。\r\n* 加载配置文件，并注册bean数据。\r\n\r\n```java\r\npublic interface BeanDefinitionReader {\r\n\r\n\t//获取注册表对象\r\n    BeanDefinitionRegistry getRegistry();\r\n\t//加载配置文件并在注册表中进行注册\r\n    void loadBeanDefinitions(String configLocation) throws Exception;\r\n}\r\n```\r\n\r\n\r\n\r\n#### 7.4.3.2 XmlBeanDefinitionReader类\r\n\r\nXmlBeanDefinitionReader类是专门用来解析xml配置文件的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。\r\n\r\n```java\r\npublic class XmlBeanDefinitionReader implements BeanDefinitionReader {\r\n\r\n    private BeanDefinitionRegistry registry;\r\n\r\n    public XmlBeanDefinitionReader() {\r\n        this.registry = new SimpleBeanDefinitionRegistry();\r\n    }\r\n\r\n    @Override\r\n    public BeanDefinitionRegistry getRegistry() {\r\n        return registry;\r\n    }\r\n\r\n    @Override\r\n    public void loadBeanDefinitions(String configLocation) throws Exception {\r\n\r\n        InputStream is = this.getClass().getClassLoader().getResourceAsStream(configLocation);\r\n        SAXReader reader = new SAXReader();\r\n        Document document = reader.read(is);\r\n        Element rootElement = document.getRootElement();\r\n        //解析bean标签\r\n        parseBean(rootElement);\r\n    }\r\n\r\n    private void parseBean(Element rootElement) {\r\n\r\n        List<Element> elements = rootElement.elements();\r\n        for (Element element : elements) {\r\n            String id = element.attributeValue(\"id\");\r\n            String className = element.attributeValue(\"class\");\r\n            BeanDefinition beanDefinition = new BeanDefinition();\r\n            beanDefinition.setId(id);\r\n            beanDefinition.setClassName(className);\r\n            List<Element> list = element.elements(\"property\");\r\n            MutablePropertyValues mutablePropertyValues = new MutablePropertyValues();\r\n            for (Element element1 : list) {\r\n                String name = element1.attributeValue(\"name\");\r\n                String ref = element1.attributeValue(\"ref\");\r\n                String value = element1.attributeValue(\"value\");\r\n                PropertyValue propertyValue = new PropertyValue(name,ref,value);\r\n                mutablePropertyValues.addPropertyValue(propertyValue);\r\n            }\r\n            beanDefinition.setPropertyValues(mutablePropertyValues);\r\n\r\n            registry.registerBeanDefinition(id,beanDefinition);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 7.4.4 IOC容器相关类\r\n\r\n#### 7.4.4.1 BeanFactory接口\r\n\r\n在该接口中定义IOC容器的统一规范即获取bean对象。\r\n\r\n```java\r\npublic interface BeanFactory {\r\n\t//根据bean对象的名称获取bean对象\r\n    Object getBean(String name) throws Exception;\r\n\t//根据bean对象的名称获取bean对象，并进行类型转换\r\n    <T> T getBean(String name, Class<? extends T> clazz) throws Exception;\r\n}\r\n```\r\n\r\n\r\n\r\n#### 7.4.4.2 ApplicationContext接口\r\n\r\n该接口的所以的子实现类对bean对象的创建都是非延时的，所以在该接口中定义 `refresh()` 方法，该方法主要完成以下两个功能：\r\n\r\n* 加载配置文件。\r\n* 根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。\r\n\r\n```java\r\npublic interface ApplicationContext extends BeanFactory {\r\n\t//进行配置文件加载并进行对象创建\r\n    void refresh() throws IllegalStateException, Exception;\r\n}\r\n```\r\n\r\n\r\n\r\n#### 7.4.4.3 AbstractApplicationContext类\r\n\r\n* 作为ApplicationContext接口的子类，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。\r\n\r\n* 声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。\r\n\r\n  BeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。\r\n\r\n```java\r\npublic abstract class AbstractApplicationContext implements ApplicationContext {\r\n\r\n    protected BeanDefinitionReader beanDefinitionReader;\r\n    //用来存储bean对象的容器   key存储的是bean的id值，value存储的是bean对象\r\n    protected Map<String, Object> singletonObjects = new HashMap<String, Object>();\r\n\r\n    //存储配置文件的路径\r\n    protected String configLocation;\r\n\r\n    public void refresh() throws IllegalStateException, Exception {\r\n\r\n        //加载BeanDefinition\r\n        beanDefinitionReader.loadBeanDefinitions(configLocation);\r\n\r\n        //初始化bean\r\n        finishBeanInitialization();\r\n    }\r\n\r\n    //bean的初始化\r\n    private void finishBeanInitialization() throws Exception {\r\n        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();\r\n        String[] beanNames = registry.getBeanDefinitionNames();\r\n\r\n        for (String beanName : beanNames) {\r\n            BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);\r\n            getBean(beanName);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n> 注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。\r\n\r\n\r\n\r\n#### 7.4.4.4 ClassPathXmlApplicationContext类\r\n\r\n该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能：\r\n\r\n* 在构造方法中，创建BeanDefinitionReader对象。\r\n* 在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。\r\n* 重写父接口中的getBean()方法，并实现依赖注入操作。\r\n\r\n```java\r\npublic class ClassPathXmlApplicationContext extends AbstractApplicationContext{\r\n\r\n    public ClassPathXmlApplicationContext(String configLocation) {\r\n        this.configLocation = configLocation;\r\n        //构建XmlBeanDefinitionReader对象\r\n        beanDefinitionReader = new XmlBeanDefinitionReader();\r\n        try {\r\n            this.refresh();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n\r\n    //根据bean的id属性值获取bean对象\r\n    @Override\r\n    public Object getBean(String name) throws Exception {\r\n\r\n        //return singletonObjects.get(name);\r\n        Object obj = singletonObjects.get(name);\r\n        if(obj != null) {\r\n            return obj;\r\n        }\r\n\r\n        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();\r\n        BeanDefinition beanDefinition = registry.getBeanDefinition(name);\r\n        if(beanDefinition == null) {\r\n            return null;\r\n        }\r\n        String className = beanDefinition.getClassName();\r\n        Class<?> clazz = Class.forName(className);\r\n        Object beanObj = clazz.newInstance();\r\n        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();\r\n        for (PropertyValue propertyValue : propertyValues) {\r\n            String propertyName = propertyValue.getName();\r\n            String value = propertyValue.getValue();\r\n            String ref = propertyValue.getRef();\r\n            if(ref != null && !\"\".equals(ref)) {\r\n\r\n                Object bean = getBean(ref);\r\n                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);\r\n                Method[] methods = clazz.getMethods();\r\n                for (Method method : methods) {\r\n                    if(method.getName().equals(methodName)) {\r\n                        method.invoke(beanObj,bean);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(value != null && !\"\".equals(value)) {\r\n                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);\r\n                Method method = clazz.getMethod(methodName, String.class);\r\n                method.invoke(beanObj,value);\r\n            }\r\n        }\r\n        singletonObjects.put(name,beanObj);\r\n        return beanObj;\r\n    }\r\n\r\n    @Override\r\n    public <T> T getBean(String name, Class<? extends T> clazz) throws Exception {\r\n\r\n        Object bean = getBean(name);\r\n        if(bean != null) {\r\n            return clazz.cast(bean);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 7.4.5 自定义Spring IOC总结\r\n\r\n#### 7.4.5.1 使用到的设计模式\r\n\r\n* 工厂模式。这个使用工厂模式 + 配置文件的方式。\r\n* 单例模式。Spring IOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。\r\n* 模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。\r\n* 迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。\r\n\r\nspring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。\r\n\r\n#### 7.4.5.2 符合大部分设计原则\r\n\r\n#### 7.4.5.3 整个设计和Spring的设计还是有一定的出入\r\n\r\nspring框架底层是很复杂的，进行了很深入的封装，并对外提供了很好的扩展性。而我们自定义SpringIOC有以下几个目的：\r\n\r\n* 了解Spring底层对对象的大体管理机制。\r\n* 了解设计模式在具体的开发中的使用。\r\n* 以后学习spring源码，通过该案例的实现，可以降低spring学习的入门成本。\r\n\r\n\r\n\r\n\r\n\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>"},{"shortInfo":{"title":"Ajax学习笔记","date":"2022-08-26T15:42:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["Ajax","前端"],"categories":"笔记","hideAtIndex":true,"id":4042505685,"countWords":3807,"readSeconds":380.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# Ajax学习笔记\r\n\r\n## 目录\r\n- [Ajax学习笔记](#ajax学习笔记)\r\n  - [目录](#目录)\r\n  - [尝试封装AJAX](#尝试封装ajax)\r\n  - [HTTP协议](#http协议)\r\n    - [请求报文格式](#请求报文格式)\r\n    - [响应报文格式](#响应报文格式)\r\n  - [AJAX](#ajax)\r\n    - [XMLHttpRequest对象](#xmlhttprequest对象)\r\n    - [核心API](#核心api)\r\n  - [通过express框架启动一个后端服务](#通过express框架启动一个后端服务)\r\n  - [ajax请求基本流程\\_demo1](#ajax请求基本流程_demo1)\r\n  - [GET请求中通过URL传递参数\\_demo2](#get请求中通过url传递参数_demo2)\r\n    - [方法1](#方法1)\r\n    - [方法2](#方法2)\r\n  - [POST请求中通过传递参数\\_demo3](#post请求中通过传递参数_demo3)\r\n    - [解析发送的文本](#解析发送的文本)\r\n    - [解析url格式数据(a=123\\&b=321)](#解析url格式数据a123b321)\r\n  - [ajax设置请求头](#ajax设置请求头)\r\n  - [ajax设置响应体数据类型](#ajax设置响应体数据类型)\r\n  - [nodemon](#nodemon)\r\n  - [ie缓存问题的解决](#ie缓存问题的解决)\r\n  - [处理超时和网络异常](#处理超时和网络异常)\r\n  - [中途手动取消请求](#中途手动取消请求)\r\n  - [防止用户多次点击导致频繁发送相同请求](#防止用户多次点击导致频繁发送相同请求)\r\n  - [jquery中的ajax](#jquery中的ajax)\r\n  - [ajax工具库:axios](#ajax工具库axios)\r\n  - [window.fetch()原生ajax接口](#windowfetch原生ajax接口)\r\n\r\n\r\n## 尝试封装AJAX\r\n```js\r\nfunction Ajax(method,url,headers,data,callBack){\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open(method,url,true);\r\n    for(keyName in headers){\r\n        xhr.response.setRequestHeader(keyName,headers[keyName]);\r\n    }\r\n    xhr.send(data);\r\n    xhr.onreadystatechange = function(){\r\n        if(xhr.readyState==4){\r\n            if(xhr.status>=200 && xhr.status<300){\r\n                callBack(xhr.response);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nAjax(\"GET\",\"http://127.0.0.1:8000/demo1\",null,null,result=>{\r\n    console.log(\"接受到的响应体内容为：\"+result);\r\n})\r\n```\r\n**测试**\r\n\r\n![图 13](./images/Ajax学习笔记/945373296dffc7f9789eeb8c525ad63633da961a5eab5363d36541742d684a7c.png)  \r\n\r\n\r\n## HTTP协议\r\nHTTP(**H**yper **T**ext **T**ransport **P**rotocol),超文本传输协议,请求-响应协议,通常运行在TCP上\r\n\r\n### 请求报文格式\r\n\r\n1. 请求行\r\n   * **请求方法**+**空格**+**URL**+**空格**+**协议版本**+**回车换行(CRLF)**\r\n   * 示例:\r\n      ```\r\n      GET /index.html HTTP/1.1\\r\\n\r\n      ```\r\n2. 请求头\r\n   * **键名**+**冒号**+**空格**+**键值**+**回车换行**\r\n   * 示例:\r\n      ```\r\n      host:baidu.com\\r\\n\r\n      user-Agent:chrome\\r\\n\r\n      ```\r\n   * ![](./images/Ajax学习笔记/2022-11-28-14-32-07.png) \r\n\r\n3. 空行(CRLF)\r\n   * `CR`: `Carriage Return`,回车符号,`0x0d`,`\\r`\r\n   * `LF`: `Line Feed`,换行符,`0x0a`,`\\n`\r\n   * 示例:\r\n        ```\r\n        \\r\\n\r\n        ```\r\n4. 报文主体\r\n   * 数据部分\r\n   * 示例:\r\n        ```\r\n        hello world!\r\n        ```\r\n\r\n**完整示例**\r\n```\r\nGET /index.html HTTP/1.1\r\nhost: baidu.com\r\nuser-Agent: chrome\r\n\r\nhello world!\r\n```\r\n\r\n![图 7](./images/Ajax学习笔记/9e9779c97ad0448a3deae16470deb3e75aa96fdc763ec4e298b1f12ae3e6667f.png)  \r\n\r\n\r\n\r\n### 响应报文格式\r\n1. 响应行\r\n   * **协议版本**+空格+**状态码**+空格+**状态字符串**+回车换行(CRLF)\r\n   * 示例:\r\n        ```\r\n        HTTP/1.1 200 OK\\r\\n\r\n        ```\r\n    * 状态码 ![](./images/Ajax学习笔记/2022-11-28-15-12-28.png)\r\n   * ![](./images/Ajax学习笔记/2022-11-28-15-20-17.png)\r\n2. 响应头\r\n   * **键名**+**冒号**+**空格**+**键值**+回车换行\r\n   * 示例:\r\n        ```\r\n        host:baidu.com\\r\\n\r\n        user-Agent:chrome\\r\\n\r\n        ```\r\n    * ![](./images/Ajax学习笔记/2022-11-28-15-10-05.png)\r\n\r\n3. 空行(CRLF)\r\n   * `CR`: `Carriage Return`,回车符号,`0x0d`,`\\r`\r\n   * `LF`: `Line Feed`,换行符,`0x0a`,`\\n`\r\n   * 示例:\r\n        ```\r\n        \\r\\n\r\n        ```\r\n4. 报文主体\r\n   * 数据部分\r\n   * 示例:\r\n        ```\r\n        hello world!\r\n        ```\r\n\r\n\r\n**完整示例**\r\n```\r\nHTTP/1.1 200 OK\r\nhost: baidu.com\r\nuser-Agent: chrome\r\n\r\n<html>\r\n   <head>\r\n   </head>\r\n   <body>\r\n        hello world!\r\n   </body>\r\n</html>\r\n```\r\n\r\n![图 6](./images/Ajax学习笔记/7e6ba87309410398b0889fc2d15a82345d154c6abc5d202f6c986440b20aafb2.png)  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## AJAX\r\n**Ajax**即`Asynchronous Javascript And XML`（异步JavaScript和XML）\r\n\r\n### XMLHttpRequest对象\r\n\r\n使用 JavaScript 向服务器提出请求并处理响应而不阻塞用户核心对象是**XMLHttpRequest**。\r\n通过这个对象， JavaScript 可在不重载页面的情况与 Web 服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。\r\n\r\n\r\n[完整API: https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)\r\n\r\n### 核心API\r\n* `xhr=new XMLHttpRequest();` 创建 XMLHttpRequest 对象\r\n* `xhr.open(method,url,async)`  规定请求的类型、URL 以及是否异步处理请求。\r\n    * **method** ： 请求的类型；GET 或 POST\r\n    * **url** ： 文件在服务器上的位置\r\n    * **async** ： true（用于**异步**的**AJAX**）或 false（同步）\r\n* `setRequestHeader(header,value)` 向请求添加 HTTP 头。\r\n    * **header** : 规定头的名称\r\n    * **value** : 规定头的值\r\n* `xhr.send(string)` 将请求发送到服务器。\r\n  * **string** ： 仅用于 POST 请求\r\n* `xhr.readyState` 存有 **XMLHttpRequest** 的状态。从 0 到 4 发生变化。\r\n    * **0**: 请求未初始化\r\n    * **1**: 服务器连接已建立\r\n    * **2**: 请求已接收\r\n    * **3**: 请求处理中\r\n    * **4**: 请求已完成，且响应已就绪\r\n* `xhr.status` 响应报文的状态码\r\n  * **2XX**: 成功\r\n  * **4XX**: 失败\r\n* `xhr.onreadystatechange=function(){}`  每当 readyState 属性改变时，就会调用该函数。\r\n  *  onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。\r\n\r\n## 通过express框架启动一个后端服务\r\n\r\n**安装node,npm express**\r\n```\r\n# 安装nodejs npm\r\napt-get install nodejs npm\r\n# 初始化\r\nnpm init --yes\r\n# 安装express\r\nnpm install express\r\n# 编辑testExpress.js\r\n# 执行testExpress.js\r\nnode testExpress.js\r\n```\r\n\r\n\r\n**testExpress.js**\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.get(\"/\",(request,response)=>{\r\n    //设置响应\r\n    response.send(\"Hello Express!!\");\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n## ajax请求基本流程_demo1\r\n**效果**\r\n![图 8](./images/Ajax学习笔记/c80dd76911ec613aedcb083ac3297b459df84dfdfa67fd602aa2a5b614906e01.png)  \r\n\r\n**前端代码**\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        #result1{\r\n            width: 200px;\r\n            height: 100px;\r\n            border: 1px solid black;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <button id=\"btn1\">点击发送请求</button>\r\n    <div id=\"result1\"></div>\r\n    <script>\r\n        var btn1 = document.getElementById(\"btn1\")\r\n        var result1 = document.getElementById(\"result1\")\r\n        btn1.onclick=function(){\r\n            //ajax部分\r\n            //1. 创建xhr对象\r\n            const xhr = new XMLHttpRequest();\r\n            //2. 初始化:设置请求方法和url\r\n            xhr.open(\"GET\",\"http://127.0.0.1:8000/demo1\")\r\n            //3. 发送\r\n            xhr.send();\r\n            //4. 事件绑定:绑定处理返回结果的函数\r\n            xhr.onreadystatechange = function(){\r\n                // 4.1 判断readyState状态\r\n                if(xhr.readyState==4){\r\n                    //onreadystatechange事件会在readyState值改变后触发\r\n                    //xhr.readyState\r\n                        // 0 初始值 \r\n                        // 1 open方法调用完毕 \r\n                        // 2 send方法调用完毕 \r\n                        // 3 接收到服务端返回的部分结果 \r\n                        // 4 接收到服务端返回的所有结果\r\n\r\n                        //4.2 判断响应报文头状态码\r\n                        if(xhr.status>=200 && xhr.status<300){\r\n                            //xhr.status\r\n                                // 2xx 成功\r\n                                // 4xx 失败\r\n                                // 5xx\r\n                            //获取响应头的数据\r\n                            console.log(xhr.status);//状态码 \r\n                            console.log(xhr.statusText);//状态字符串 \r\n                            console.log(xhr.getAllResponseHeaders());//所有响应头\r\n                            console.log(xhr.response);//响应体 \r\n                            //将响应体内容写入页面\r\n                            result1.innerHTML=xhr.response;\r\n                        }\r\n                }\r\n            }\r\n        }\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n**后端代码**\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.get(\"/demo1\",(request,response)=>{\r\n    //设置响应头\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");//允许跨域,若没有,则当以文件方式打开前端页面或访问前端页面的域名或端口与服务端不一致时,响应报文会被浏览器拦截\r\n    //设置响应体\r\n    response.send(\"Hello Express!!\");\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n## GET请求中通过URL传递参数_demo2\r\n\r\n### 方法1\r\n**效果**\r\n![图 10](./images/Ajax学习笔记/5799fdd3638eeafab6bd0e8e64bb485e8591fa5169403576c7667c0355e92552.png)  \r\n\r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"GET\",\"http://127.0.0.1:8000/demo2?a=1&b=2&c=3\")\r\n```\r\n\r\n**后端关键代码**\r\n```js\r\napp.get(\"/demo2\",(request,response)=>{\r\n    response.send(request.query);//request.query 中存放着传递过来的键值对\r\n})\r\n```\r\n\r\n### 方法2\r\n**效果**\r\n![图 9](./images/Ajax学习笔记/a46234cd8cc372a024311518512f464cf9f55890f682bf289fd65fd6ceae0bc7.png)  \r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"GET\",\"http://127.0.0.1:8000/demo2/1/2/3\")\r\n```\r\n\r\n**后端关键代码**\r\n```js\r\napp.get(\"/demo2/:a/:b/:c\",(request,response)=>{\r\n    response.send(request.params);//request.params 中存放着传递过来的键值对\r\n})\r\n```\r\n\r\n\r\n## POST请求中通过传递参数_demo3\r\n\r\n### 解析发送的文本\r\n![图 12](./images/Ajax学习笔记/a8a5ba527782e970517f95f4fdac198f1bf20d571463bf6e923ce8732e8fabd6.png)  \r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"POST\",\"http://127.0.0.1:8000/demo3\")\r\nxhr.send(\"hello server\")\r\n```\r\n\r\n**后端关键代码**\r\n```js\r\n//引入中间件,用于获取request.body内容\r\nconst bodyParser = require('body-parser');\r\n// 解析 text\r\napp.use(bodyParser.text());\r\n\r\n//创建路由\r\napp.post(\"/demo3\",(request,response)=>{\r\n    //设置响应头\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");\r\n    //设置响应体\r\n    response.send(\"你发送的数据是:\" + request.body);\r\n})\r\n```\r\n\r\n### 解析url格式数据(a=123&b=321)\r\n![图 11](./images/Ajax学习笔记/ec47983f998ddd778f3a164385b3509c609b73a02e5a34b4dfd32228a35bd5ad.png)  \r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"POST\",\"http://127.0.0.1:8000/demo3\")\r\n//设置请求头\r\nxhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\")\r\nxhr.send(\"a=123&b=321\")\r\n```\r\n**后端关键代码**\r\n```js\r\n//引入中间件,用于获取request.body内容\r\nconst bodyParser = require('body-parser');\r\n// 解析 application/x-www-form-urlencoded //也就是解析a=1&b=2 这种url格式的数据\r\napp.use(bodyParser.urlencoded({ extended: false })) \r\n        // extended: false 方法内部使用querystring模块处理请求参数的格式\r\n        // extended: true 方法内部使用第三方模块qs模块请求参数的格式\r\n\r\n//创建路由\r\napp.post(\"/demo3\",(request,response)=>{\r\n    //设置响应头\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");//允许跨域\r\n    //设置响应体\r\n    response.send(\"你发送的数据是:\" + JSON.stringify(request.body));\r\n})\r\n```\r\n\r\n\r\n## ajax设置请求头\r\n* `xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\")`// for A=123&B=321\r\n* `xhr.setRequestHeader(\"Name\",\"dyg\")`// **自定义请求头**\r\n    * `response.setHeader(\"Access-Control-Allow-Headers\",\"*\")` 发送带有自定义请求头的请求需要在服务端设置响应头为允许自定义响应头 \r\n    * 发送带有自定义请求头的请求报文时,会先发送一个`OPTIONS`类型的请求验证自定义请求头是否可用,服务器需要\r\n需要处理该`OPTIONS`类型的请求\r\n\r\n\r\n## ajax设置响应体数据类型\r\n\r\n**手动数据类型转换**\r\n* `jsOBJ = JSON.parse(xhr.response) ` 实现手动数据类型转换 `string->obj`\r\n\r\n**自动数据类型转换**\r\n* `xhr.responseType = \"json\"` 实现自动数据类型转换 一般写在`xhr`对象创建之后\r\n\r\n\r\n## nodemon\r\n**用于实现服务端代码改变后自动重启**\r\n\r\n```bash\r\nnpm i nodemon -g\r\n```\r\n\r\n## ie缓存问题的解决\r\nie浏览器会将相同地址的服务端响应报文存入缓存,在第二次客户端发送同样的请求时,ie浏览器会将缓存中的数据作为第二次的响应报文,带来的问题是不能获取服务端相同地址上的最新数据.\r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"POST\",\"http://127.0.0.1:8000/demo3&date=\"+Date.now() )\r\n```\r\n\r\n\r\n## 处理超时和网络异常\r\n```js\r\nconst xhr = new XMLHttpRequest();\r\n//当请求超时后,会将请求的status状态由pending改为canceled\r\nxhr.timeout =  2000;\r\n// 设置超时的回调函数\r\nxhr.ontimeout = function(){\r\n    alert(\"网络超时,请稍后重试\")\r\n}\r\nxhr.onterror = function(){//网络异常时status状态为failed\r\n    alert(\"网络异常,请稍后重试\")\r\n}\r\nxhr.open(\"GET\",\"http://127.0.0.1:8000/demo1\")\r\n\r\n```\r\n\r\n\r\n## 中途手动取消请求\r\n\r\n**取消请求**\r\n```js\r\nxhr.abort   ();\r\n```\r\n\r\n\r\n**客户端**\r\n```html\r\n  <button id=\"btn4_1\">点击发送请求</button>\r\n  <button id=\"btn4_2\">点击取消请求</button>\r\n  <script>\r\n      var btn4_1 = document.getElementById(\"btn4_1\")\r\n      var btn4_2 = document.getElementById(\"btn4_2\")\r\n      let xhr = null;\r\n      btn4_1.onclick=function(){\r\n          xhr = new XMLHttpRequest();\r\n          xhr.open(\"POST\",\"http://127.0.0.1:8000/demo4\")\r\n          xhr.send(\"hello server\");\r\n      }\r\n      btn4_2.onclick = function(){\r\n          xhr.abort();\r\n      }\r\n  </script>\r\n```\r\n\r\n**服务端**\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.post(\"/demo4\",(request,response)=>{\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");\r\n    setTimeout(()=>{\r\n        response.send(\"你发送的数据是:\" + request.body);\r\n    },3000)\r\n\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n## 防止用户多次点击导致频繁发送相同请求\r\n\r\n\r\n![图 1](./images/Ajax学习笔记/faa475ec71e77bd72eb7aa7ee2390631b37b70329f1a081519f6aed8e3f9b3e4.png)  \r\n\r\n**客户端**\r\n```html\r\n  <button id=\"btn5\">点击发送请求</button>\r\n  <script>\r\n      var btn5 = document.getElementById(\"btn5\")\r\n      btn5.onclick=function(){\r\n          var self = this\r\n          if(self.isSending == true)//判断是否正在发送请求\r\n          {\r\n              self.xhr.abort();//取消正在发送的请求\r\n          }\r\n          self.xhr = new XMLHttpRequest();\r\n          self.isSending = true;//创建标志为,记录为正在发送请求\r\n          self.xhr.open(\"POST\",\"http://127.0.0.1:8000/demo5\")\r\n          self.xhr.send(\"hello server\");\r\n          self.xhr.onreadystatechange = function(){\r\n              if(self.xhr.readyState==4){\r\n                  self.isSending = false;//改变标志位\r\n              }\r\n          }\r\n      }\r\n  </script>\r\n```\r\n\r\n**服务端**\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.post(\"/demo5\",(request,response)=>{\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");//允许跨域,若没有,则当以文件方式打开前端页面或访问前端页面的域名或端口与服务端不一致时,响应报文会被浏览器拦截\r\n    setTimeout(()=>{\r\n        response.send(\"你发送的数据是:\" + request.body);\r\n    },3000)\r\n\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n## jquery中的ajax\r\n* `$.get(url,{a:1,b:2},function(data){},\"json\")`\r\n* `$.post(url,{a:1,b:2},function(data){},\"json\")`\r\n\r\n```html\r\n    <!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n    <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n    <button id=\"btn6-1\">点击发送GET请求</button>\r\n    <button id=\"btn6-2\">点击发送POST请求</button>\r\n    <button id=\"btn6-3\">通用方法</button>\r\n    <script>\r\n        $(\"#btn6-1\").click(function(){\r\n            // $.get(url,data,function(data){\r\n            $.get(\"http://127.0.0.1:8000/demo6\",{a:1,b:2},function(data){\r\n                console.log(data)\r\n            })\r\n        })\r\n        $(\"#btn6-2\").click(function(){\r\n            $.post(\"http://127.0.0.1:8000/demo6\",{a:1,b:2},function(data){\r\n                console.log(data)\r\n            })\r\n        })\r\n        $(\"#btn6-3\").click(function(){\r\n            $.ajax({\r\n                type: \"GET\",\r\n                url: \"http://127.0.0.1:8000/demo6\",\r\n                headers: {\r\n                    a:100,\r\n                    b:200,\r\n                },\r\n                data: {a:1,b:2},\r\n                dataType: \"json\",//可将字符串类型的data自动转换为json\r\n                success: function(data){ console.log(data) },\r\n                timeout: 2000,\r\n                error: function(){ console.log(\"出错了\") },//超时或网络异常的错误回调函数\r\n            })\r\n        })\r\n```\r\n\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.all(\"/demo6\",(request,response)=>{\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");\r\n    response.setHeader(\"access-control-allow-headers\",\"*\");\r\n    response.send(\"hello client\");\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n## ajax工具库:axios\r\n**get**\r\n```js\r\naxios.get('http://127.0.0.1:8000/demo7',{\r\n    params: {\r\n        name:\"DingYigui\",\r\n        id:123\r\n    },\r\n    headers:{\r\n        test:321\r\n    }\r\n})\r\n.then(function (response) {\r\n    console.log(response);\r\n})\r\n.catch(function (error) {\r\n    console.log(error);\r\n})\r\n.then(function () {\r\n    // always executed\r\n});\r\n```\r\n\r\n**post**\r\n```html\r\n<!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n<script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n<!-- axios 库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n<script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n<button id=\"btn7-1\">点击使用axios(config)发送请求</button>\r\n<button id=\"btn7-2\">点击使用axios.get(url[, config])发送请求</button>\r\n<button id=\"btn7-3\">点击使用axios.post(url[, data[, config]])发送请求</button>\r\n<script>\r\n    $(\"#btn7-1\").click(function(){\r\n        //axios(config)\r\n        axios({\r\n            method: 'get',\r\n            url:\"http://127.0.0.1:8000/demo7\",\r\n            params: {//url格式数据\r\n                name:\"DingYigui\",\r\n                id:123\r\n            },\r\n            headers:{//报头\r\n                test:321\r\n            },\r\n            data:{\r\n                a:123,\r\n                b:321\r\n            }\r\n        })\r\n        .then(function (response) {\r\n            console.log(response);\r\n        })\r\n        .catch(function (error) {\r\n            console.log(error);\r\n        })\r\n        .then(function () {\r\n            // always executed\r\n        });\r\n    })\r\n    $(\"#btn7-2\").click(function(){\r\n        // axios.get(url[, config])\r\n        axios.get('http://127.0.0.1:8000/demo7',{\r\n            params: {\r\n                name:\"DingYigui\",\r\n                id:123\r\n            },\r\n            headers:{\r\n                test:321\r\n            }\r\n        })\r\n        .then(function (response) {\r\n            console.log(response);\r\n        })\r\n        .catch(function (error) {\r\n            console.log(error);\r\n        })\r\n        .then(function () {\r\n            // always executed\r\n        });\r\n    })\r\n    $(\"#btn7-3\").click(function(){\r\n        // axios.post(url[, data[, config]])\r\n        axios.post('http://127.0.0.1:8000/demo7',{a:123,b:321},{\r\n            params: {//url格式数据\r\n                name:\"DingYigui\",\r\n                id:123\r\n            },\r\n            headers:{//报头\r\n                test:321\r\n            }\r\n        })\r\n        .then(function (response) {\r\n            console.log(response);\r\n        })\r\n        .catch(function (error) {\r\n            console.log(error);\r\n        })\r\n        .then(function () {\r\n            // always executed\r\n        });\r\n    })\r\n</script>\r\n```\r\n\r\n## window.fetch()原生ajax接口\r\n\r\n\r\n```html\r\n  <!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n  <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n  <!-- axios 库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n  <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n  <button id=\"btn8\">点击使用fetch(url,config)发送请求</button>\r\n  <script>\r\n      $(\"#btn8\").click(function(){\r\n          url = \"http://127.0.0.1:8000/demo8\"\r\n          config = {\r\n              method:\"POST\",\r\n              headers: {\r\n                  name: \"DYG\"\r\n              },\r\n              body: \"username=admin&passwd=admin\"\r\n          }\r\n          fetch(url,config)\r\n          .then(response=>{\r\n              console.log(response)\r\n            //   return response.json() //可以解析为json对象\r\n              return response.text()\r\n          })\r\n          .then(body=>{\r\n              console.log(body)\r\n          })\r\n      })\r\n```\r\n\r\n\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.post(\"/demo4\",(request,response)=>{\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");//允许跨域,若没有,则当以文件方式打开前端页面或访问前端页面的域名或端口与服务端不一致时,响应报文会被浏览器拦截\r\n    setTimeout(()=>{\r\n        response.send(\"你发送的数据是:\" + request.body);\r\n    },3000)\r\n\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n"},{"shortInfo":{"title":"Alpine Linux(iSH and UTM)配置过程记录","date":"2022-08-04T09:59:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["iSH","Alpine","Linux"],"categories":"笔记","hideAtIndex":true,"id":798420514,"countWords":2331,"readSeconds":233.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# Alpine Linux(iSH and UTM)配置过程记录\r\n## 目录\r\n- [Alpine Linux(iSH and UTM)配置过程记录](#alpine-linuxish-and-utm配置过程记录)\r\n  - [目录](#目录)\r\n  - [一、换源配置](#一换源配置)\r\n  - [二、安装软件](#二安装软件)\r\n  - [三、配置服务管理openrc](#三配置服务管理openrc)\r\n  - [配置开启ssh服务](#配置开启ssh服务)\r\n  - [实现ish后台运行配置](#实现ish后台运行配置)\r\n  - [尝试安装vsCode网页版](#尝试安装vscode网页版)\r\n    - [尝试1：在iSH中尝试通过npm安装（配置失败）](#尝试1在ish中尝试通过npm安装配置失败)\r\n    - [尝试2：在iSH中尝试通过docker安装（配置失败）](#尝试2在ish中尝试通过docker安装配置失败)\r\n    - [尝试3：在UTM中安装Alpine3.16.1再尝试使用npm安装（配置失败）](#尝试3在utm中安装alpine3161再尝试使用npm安装配置失败)\r\n    - [尝试4：在UTM中安装Alpine3.16.1再尝试使用yarn安装（配置失败）](#尝试4在utm中安装alpine3161再尝试使用yarn安装配置失败)\r\n    - [尝试5：在UTM中安装Alpine3.16.1再尝试使用release版本安装（配置失败）](#尝试5在utm中安装alpine3161再尝试使用release版本安装配置失败)\r\n    - [尝试6：在UTM中安装Alpine3.16.1并开启JIT再尝试使用release版本安装（成功）](#尝试6在utm中安装alpine3161并开启jit再尝试使用release版本安装成功)\r\n\r\n\r\n## 一、换源配置\r\n\r\n**1.编辑文件**\r\n```bash\r\nvi /etc/apk/repositories\r\n```\r\n\r\n**2.添加内容 注意版本号要和原来的一致**\r\n```bash\r\n# 任选一组\r\n# 阿里云源 实测可以使用\r\nhttp://mirrors.aliyun.com/alpine/v3.12/main\r\nhttp://mirrors.aliyun.com/alpine/v3.12/community\r\n# 中科大源 实测可以使用\r\nhttp://mirrors.ustc.edu.cn/alpine/v3.12/main\r\nhttp://mirrors.ustc.edu.cn/alpine/v3.12/community\r\n# 清华源 实测可以使用\r\nhttp://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/main\r\nhttp://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/community\r\n```\r\n**3.更新**\r\n```bash\r\napk update\r\n```\r\n\r\n**4.另一种一步到位的方法**\r\n```bash\r\n# 配置\r\ncat >> .profile << EOF\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.14/main' > /etc/apk/repositories\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.14/community' >> /etc/apk/repositories\r\nEOF\r\n# 执行\r\nsource .profile\r\n# 应用修改\r\napk update\r\n```\r\n\r\n\r\n\r\n## 二、安装软件\r\n\r\n```bash\r\napk add openrc\r\napk add curl\r\napk add npm\r\napk add git\r\napk add nss #for https\r\napk add openssh\r\n```\r\n\r\n\r\n\r\n## 三、配置服务管理openrc\r\n**1.安装openrc**\r\n```bash\r\napk add openrc\r\n# 注意 要先安装openrc 再安装要启动的服务比如docker 否则提示服务不存在\r\n```\r\n\r\n**2.编辑/etc/inittab 将`::sysinit:/sbin/openrc sysinit`中的`sysinit`删除**\r\n```bash\r\nvi /etc/inittab\r\n```\r\n\r\n**3.重启ish**\r\n\r\n**4.添加服务**\r\n```bash\r\nrc-update add sshd\r\n```\r\n\r\n**5.删除服务**\r\n```bash\r\nrc-update del sshd\r\n```\r\n\r\n**6.启动服务**\r\n```bash\r\nrc-service sshd start\r\n```\r\n\r\n**7.暂停服务**\r\n```bash\r\nrc-service sshd stop\r\n```\r\n\r\n**8.查询服务状态**\r\n```bash\r\nrc-status -a\r\n```\r\n\r\n\r\n\r\n\r\n## 配置开启ssh服务\r\n**1. 安装ssh**\r\n```bash\r\napk add openssh\r\n```\r\n\r\n**2.为本机生成SSH主机秘钥**\r\n```bash\r\nssh-keygen -A\r\n```\r\n\r\n**3.临时启动守护进程**\r\n```bash\r\n/usr/sbin/sshd\r\n```\r\n\r\n**4.将守护进程添加到开机启动**\r\n```bash\r\nrc-update add sshd\r\n# 移除开机自启服务：rc-update del sshd\r\n```\r\n**5.启动服务**\r\n```bash\r\nrc-service sshd start\r\n# 暂停服务：rc-service sshd stop\r\n```\r\n\r\n**6.配置sshd**\r\n```bash\r\ncat >> /etc/ssh/sshd_config  << EOF\r\n# 允许root登录 禁止密码登录\r\n# PermitRootLogin prohibit-password\r\n# 允许root登录\r\nPermitRootLogin yes\r\n# 允许公钥登录\r\nPubkeyAuthentication yes\r\n# 允许密码登录\r\nPasswordAuthentication yes                                       \r\n# 不允许空密码\r\nPermitEmptyPasswords no\r\nEOF\r\n```\r\n\r\n\r\n## 实现ish后台运行配置\r\n\r\n**1.关键代码**\r\n```bash\r\n# 说明：ish是ios系统上的应用程序，为使iSH进程能够支持长期后台运行而不被杀死，需要不断获取手机位置信息\r\ncat /dev/location > /dev/null &\r\n```\r\n\r\n**2.配置**\r\n```bash\r\necho 'cat /dev/location > /dev/null &' >> .profile\r\ncat .profile # 检查配置是否成功\r\n```\r\n\r\n## 尝试安装vsCode网页版\r\n\r\n### 尝试1：在iSH中尝试通过npm安装（配置失败）\r\n\r\n**先要安装`npm`和`nodejs`**\r\n但由于npm软件最新版使用了一些ish没有实现的指令 导致运行npm会提示非法指令 所以只能安装低版本\r\n\r\n**1.修改 /etc/apk/repositories 将版本改为3.12版本**\r\n```bash\r\n# 修改\r\ncat >> .profile << EOF\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/main' > /etc/apk/repositories\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/community' >> /etc/apk/repositories\r\nEOF\r\n# 更新\r\napk update\r\n```\r\n\r\n**2.安装**\r\n```bash\r\napk add nodejs=12.22.12-r0 npm=12.22.12-r0\r\n```\r\n\r\n**3.npm换为国内源**\r\n```bash\r\nnpm config set registry https://registry.npmmirror.com\r\n# 或者安装yarn: npm install -g yarn\r\n```\r\n\r\n**4.然后安装code-server**\r\n```bash\r\nnpm install -g code-server --unsafe-perm\r\n# 然后在这一步卡死了\r\n# ish1.2.3（build298） 卡在了yarn\r\n```\r\n\r\n### 尝试2：在iSH中尝试通过docker安装（配置失败）\r\n\r\n**1.安装docker和compose**\r\n```bash\r\napk add docker\r\napk add docker-compose\r\n# compose可以根据yml文件中的配置来启动docker\r\n```\r\n\r\n**2.下载coder**\r\n```bash\r\ngit clone https://github.com/coder/coder.git --depth=1\r\n```\r\n\r\n**3.临时启动守护进程测试**\r\n```bash\r\nrc-service docker start\r\n# 报错并卡死：\r\n# 原因：ish没有实现filesystems文件\r\n# 报错提示：grep: /proc/filesystems: No such file\r\n# 如果直接执行： rc-update add sshd 会导致卡死\r\n```\r\n\r\n**4.启动**\r\n```bash\r\nCODER_ACCESS_URL=http://localhost:7080\r\ndocker-compose up\r\n```\r\n\r\n\r\n\r\n### 尝试3：在UTM中安装Alpine3.16.1再尝试使用npm安装（配置失败）\r\n安装UTM 在UTM中安装Alpine3.16.1\r\n\r\n```bash\r\n# 安装时最好设置好密码\r\n# 并且在提示：# PermitRootLogin prohibit-password ？\r\n# 输入yes\r\n```\r\n\r\n安装nodejs npm\r\n```bash\r\n# 安装过程依赖python\r\napk add python3\r\n# code-server要求node16 ： code-server@4.5.1: wanted: {\"node\":\"16\"} (current: {\"node\":\"12.22.12\",\"npm\":\"6.14.16\"})\r\napk add nodejs=16.16.0-r0 npm\r\nnpm install -g code-server --unsafe-perm\r\n# 依旧报错 ：  gyp: Undefined variable module_name in binding.gyp while trying to load binding.gyp\r\n# 还是argon2的问题\r\n```\r\n尝试1、3出错原因和这个类似：[#5184](https://github.com/coder/code-server/issues/5184)\r\n\r\n\r\n### 尝试4：在UTM中安装Alpine3.16.1再尝试使用yarn安装（配置失败）\r\n\r\n该方法根据自issue：[#5174](https://github.com/coder/code-server/issues/5174)\r\n\r\n```bash\r\nnpm install -g yarn\r\nsudo yarn global add code-server\r\n```\r\n\r\n**绷不住了！！！ 报错超时，好像是虚拟机的问题！！！**\r\n\r\n```txt\r\nipad:~# npm install yarn -g\r\nadded 1 package in 1m\r\nipad:~# sudo yarn global add code-server\r\n-ash: sudo: not found\r\nipad:~# yarn global add code-server\r\nyarn global v1.22.19\r\n[1/4] Resolving packages...\r\n[2/4] Fetching packages...\r\n[3/4] Linking dependencies...\r\nwarning \"code-server > @coder/logger@1.1.16\" has unmet peer dependency \"@google-cloud/logging@^4.5.2\".\r\n[4/4] Building fresh packages...\r\nsuccess Installed \"code-server@4.5.1\" with binaries:\r\n      - code-server\r\nDone in 893.96s.\r\nipad:~# code-server \r\n[2022-08-06T18:56:50.068Z] info  Wrote default config file to ~/.config/code-server/config.yaml\r\n[2022-08-06T18:57:00.929Z] error timed out\r\n```\r\n\r\n### 尝试5：在UTM中安装Alpine3.16.1再尝试使用release版本安装（配置失败）\r\n既然在UTM安装的是64bit版本的系统 为什么不直接使用release版本？？？\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64\r\n\r\ncd ./code-server-4.5.1-linux-amd64\r\n# 执行，报错：./lib/node not fond\r\n./code-server\r\n# 安装node\r\napk add node \r\n# 查看安装目录\r\nwhich node\r\n# 建立软连接\r\nln -s /usr/bin/node ./lib/node\r\n\r\n# 再次执行\r\n./code-server\r\n# 依旧报错\r\n# [2022-08-06T18:57:00.929Z] error timed out\r\n\r\n# 查文档得知要求：glibc >= 2.17 and glibcxx >= v3.4.18\r\n# 而\r\n#alpine linux追求系统小，默认使用了uclibc，但用glibc编译的程序无法直接在上面运行了。\r\n#需要自行安装第三方的alpine glibc，然后就可以无障碍运行其他机器编译的依赖glibc的程序了。\r\n\r\n\r\n# 查了issue #1706 发现code-server 对于glibc glibcxx已经静态编译了 不需要系统自带静态链接库了\r\n\r\n\r\n```\r\n\r\n\r\n### 尝试6：在UTM中安装Alpine3.16.1并开启JIT再尝试使用release版本安装（成功）\r\n方法同上，UTM使用JIT（jitterbug）启动，终于可以了！！！原来是运行速度的问题\r\n\r\n\r\n完整过程：\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64\r\n# 递归创建文件夹\r\nmkdir -p ~/.local/lib ~/.local/bin\r\n# 移动并改名\r\nmv ./code-server-4.5.1-linux-amd64 ~/.local/lib/code-server-4.5.1/\r\n# 建立软连接\r\nln -s ~/.local/lib/code-server-4.5.1/bin/code-server ~/.local/bin/code-server\r\n# 添加到环境变量\r\nPATH=\"/root/.local/bin:$PATH\"\r\n# 运行\r\ncode-server \r\n\r\n\r\n\r\n# 如果提示-ash: node: not found 则为node添加软连接\r\nln -s /usr/bin/node ~/.local/lib/code-server-4.5.1/lib/node\r\n# 原因：\r\n# 使用命令：ldd ~/.local/lib/code-server-4.5.1/lib/node\r\n# 可以发现缺少一些动态链接库，因为alpine是阉割版的linux\r\n# 所以直接apk add nodejs\r\n# 然后删除原文件\r\n# rm ~/.local/lib/code-server-4.5.1/lib/node\r\n# which node 查看刚安装的node的所在目录\r\n# 然后添加软连接\r\nln -s /usr/bin/node ~/.local/lib/code-server-4.5.1/lib/node\r\n```\r\n\r\n**编辑配置文件修改密码**\r\n```bash\r\ncat > ~/.config/code-server/config.yaml <<EOF\r\nbind-addr: 0.0.0.0:80\r\nauth: password\r\npassword: *****数字加英文*****\r\ncert: false\r\nEOF\r\n```\r\n\r\n**配置自动添加环境变量**\r\n```\r\nvi .profile\r\nPATH=\"/root/.local/bin:$PATH\"\r\n```\r\n\r\n**配置开机自启服务（暂时没有解决输出重定向的问题）**\r\n```bash\r\nvim /etc/init.d/vscode\r\n```\r\n\r\n```bash\r\n#!/sbin/openrc-run\r\nname=\"vscode\"\r\ncommand=\"/root/.local/bin/code-server > /dev/null & \"\r\n#command_background=\"yes\"\r\ndepend() {\r\n        need net\r\n        after sshd\r\n}\r\n```\r\n\r\n```bash\r\n# 修改权限 否则提示* rc-service: Permission denied\r\nchmod 755 /etc/init.d/vscode\r\n```\r\n\r\n```bash\r\n管理服务\r\n列出所有可用服务\r\nrc-service --list | grep vscode\r\n\r\n启动/停止/重启 已有服务\r\nrc-service 服务名 start/stop/restart\r\n或\r\n/etc/init.d/服务名 start/stop/restart\r\n\r\n添加到开机自启动\r\nrc-update add vscode\r\n```"},{"shortInfo":{"title":"alpine安装code-server过程记录","date":"2022-08-07T16:12:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["code-server","alpine"],"hideAtIndex":true,"categories":"笔记","id":795180986,"countWords":1413,"readSeconds":141.3,"assetsbaseUrl":"/self_server/assets/"},"content":"## alpine安装code-server过程记录\r\n\r\n## 尝试1：在iSH中尝试通过npm安装（配置失败）\r\n\r\n**先要安装`npm`和`nodejs`**\r\n但由于npm软件最新版使用了一些ish没有实现的指令 导致运行npm会提示非法指令 所以只能安装低版本\r\n\r\n**1.修改 /etc/apk/repositories 将版本改为3.12版本**\r\n```bash\r\n# 修改\r\ncat >> .profile << EOF\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/main' > /etc/apk/repositories\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/community' >> /etc/apk/repositories\r\nEOF\r\n# 更新\r\napk update\r\n```\r\n\r\n**2.安装**\r\n```bash\r\napk add nodejs=12.22.12-r0 npm=12.22.12-r0\r\n```\r\n\r\n**3.npm换为国内源**\r\n```bash\r\nnpm config set registry https://registry.npmmirror.com\r\n# 或者安装yarn: npm install -g yarn\r\n```\r\n\r\n**4.然后安装code-server**\r\n```bash\r\nnpm install -g code-server --unsafe-perm\r\n# 然后在这一步卡死了\r\n# ish1.2.3（build298） 卡在了yarn\r\n```\r\n\r\n## 尝试2：在iSH中尝试通过docker安装（配置失败）\r\n\r\n**1.安装docker和compose**\r\n```bash\r\napk add docker\r\napk add docker-compose\r\n# compose可以根据yml文件中的配置来启动docker\r\n```\r\n\r\n**2.下载coder**\r\n```bash\r\ngit clone https://github.com/coder/coder.git --depth=1\r\n```\r\n\r\n**3.临时启动守护进程测试**\r\n```bash\r\nrc-service docker start\r\n# 报错并卡死：\r\n# 原因：ish没有实现filesystems文件\r\n# 报错提示：grep: /proc/filesystems: No such file\r\n# 如果直接执行： rc-update add sshd 会导致卡死\r\n```\r\n\r\n**4.启动**\r\n```bash\r\nCODER_ACCESS_URL=http://localhost:7080\r\ndocker-compose up\r\n```\r\n\r\n\r\n\r\n## 尝试3：在UTM中安装Alpine3.16.1再尝试使用npm安装（配置失败）\r\n安装UTM 在UTM中安装Alpine3.16.1\r\n\r\n```bash\r\n# 安装时最好设置好密码\r\n# 并且在提示：# PermitRootLogin prohibit-password ？\r\n# 输入yes\r\n```\r\n\r\n安装nodejs npm\r\n```bash\r\n# 安装过程依赖python\r\napk add python3\r\n# code-server要求node16 ： code-server@4.5.1: wanted: {\"node\":\"16\"} (current: {\"node\":\"12.22.12\",\"npm\":\"6.14.16\"})\r\napk add nodejs=16.16.0-r0 npm\r\nnpm install -g code-server --unsafe-perm\r\n# 依旧报错 ：  gyp: Undefined variable module_name in binding.gyp while trying to load binding.gyp\r\n# 还是argon2的问题\r\n```\r\n尝试1、3出错原因和这个类似：[#5184](https://github.com/coder/code-server/issues/5184)\r\n\r\n\r\n## 尝试4：在UTM中安装Alpine3.16.1再尝试使用yarn安装（配置失败）\r\n\r\n该方法根据自issue：[#5174](https://github.com/coder/code-server/issues/5174)\r\n\r\n```bash\r\nnpm install -g yarn\r\nsudo yarn global add code-server\r\n```\r\n\r\n**绷不住了！！！ 报错超时，好像是虚拟机的问题！！！**\r\n\r\n```txt\r\nipad:~# npm install yarn -g\r\nadded 1 package in 1m\r\nipad:~# sudo yarn global add code-server\r\n-ash: sudo: not found\r\nipad:~# yarn global add code-server\r\nyarn global v1.22.19\r\n[1/4] Resolving packages...\r\n[2/4] Fetching packages...\r\n[3/4] Linking dependencies...\r\nwarning \"code-server > @coder/logger@1.1.16\" has unmet peer dependency \"@google-cloud/logging@^4.5.2\".\r\n[4/4] Building fresh packages...\r\nsuccess Installed \"code-server@4.5.1\" with binaries:\r\n      - code-server\r\nDone in 893.96s.\r\nipad:~# code-server \r\n[2022-08-06T18:56:50.068Z] info  Wrote default config file to ~/.config/code-server/config.yaml\r\n[2022-08-06T18:57:00.929Z] error timed out\r\n```\r\n\r\n## 尝试5：在UTM中安装Alpine3.16.1再尝试使用release版本安装（配置失败）\r\n既然在UTM安装的是64bit版本的系统 为什么不直接使用release版本？？？\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64\r\n\r\ncd ./code-server-4.5.1-linux-amd64\r\n# 执行，报错：./lib/node not fond\r\n./code-server\r\n# 安装node\r\napk add node \r\n# 查看安装目录\r\nwhich node\r\n# 建立软连接\r\nln -s /usr/bin/node ./lib/node\r\n\r\n# 再次执行\r\n./code-server\r\n# 依旧报错\r\n# [2022-08-06T18:57:00.929Z] error timed out\r\n\r\n# 查文档得知要求：glibc >= 2.17 and glibcxx >= v3.4.18\r\n# 而\r\n#alpine linux追求系统小，默认使用了uclibc，但用glibc编译的程序无法直接在上面运行了。\r\n#需要自行安装第三方的alpine glibc，然后就可以无障碍运行其他机器编译的依赖glibc的程序了。\r\n\r\n\r\n# 查了issue #1706 发现code-server 对于glibc glibcxx已经静态编译了 不需要系统自带静态链接库了\r\n\r\n\r\n```\r\n\r\n\r\n## 尝试6：在UTM中安装Alpine3.16.1并开启JIT再尝试使用release版本安装（成功）\r\n方法同上，UTM使用JIT（jitterbug）启动，终于可以了！！！原来是运行速度的问题\r\n\r\n\r\n完整过程：\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n## 或者在pc端下载好了之后通过sftp传输\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64.tar.gz\r\n# 递归创建文件夹\r\nmkdir -p ~/.local/lib ~/.local/bin\r\n# 移动并改名\r\nmv ./code-server-4.5.1-linux-amd64 ~/.local/lib/code-server-4.5.1/\r\n# 建立软连接\r\nln -s ~/.local/lib/code-server-4.5.1/bin/code-server ~/.local/bin/code-server\r\n# 添加到环境变量\r\nPATH=\"/root/.local/bin:$PATH\"\r\n# 运行\r\ncode-server \r\n\r\n\r\n\r\n# 如果提示-ash: node: not found 则为node添加软连接\r\n# ln -s /usr/bin/node ~/.local/lib/code-server-4.5.1/lib/node\r\n# 原因：\r\n# 使用命令：ldd ~/.local/lib/code-server-4.5.1/lib/node\r\n# 可以发现缺少一些动态链接库，因为alpine是阉割版的linux\r\n# 所以直接\r\napk add nodejs\r\n# 然后删除原文件\r\nrm ~/.local/lib/code-server-4.5.1/lib/node\r\n# which node 查看刚安装的node的所在目录\r\n# 然后添加软连接\r\nln -s /usr/bin/node ~/.local/lib/code-server-4.5.1/lib/node\r\n```\r\n\r\n**编辑配置文件修改密码**\r\n```bash\r\ncat > ~/.config/code-server/config.yaml <<EOF\r\nbind-addr: 0.0.0.0:80\r\nauth: password\r\npassword: *****数字加英文*****\r\ncert: false\r\nEOF\r\n```\r\n\r\n**配置自动添加环境变量**\r\n```\r\nvi .profile\r\nPATH=\"/root/.local/bin:$PATH\"\r\n```\r\n\r\n**配置开机自启服务（暂时没有解决输出重定向的问题）**\r\n```bash\r\nvim /etc/init.d/vscode\r\n```\r\n\r\n```bash\r\n#!/sbin/openrc-run\r\nname=\"vscode\"\r\ncommand=\"/root/.local/bin/code-server > /dev/null & \"\r\n#command_background=\"yes\"\r\ndepend() {\r\n        need net\r\n        after sshd\r\n}\r\n```\r\n\r\n```bash\r\n# 修改权限 否则提示* rc-service: Permission denied\r\nchmod 755 /etc/init.d/vscode\r\n```\r\n\r\n```bash\r\n管理服务\r\n列出所有可用服务\r\nrc-service --list | grep vscode\r\n\r\n启动/停止/重启 已有服务\r\nrc-service 服务名 start/stop/restart\r\n或\r\n/etc/init.d/服务名 start/stop/restart\r\n\r\n添加到开机自启动\r\nrc-update add vscode\r\n```"},{"shortInfo":{"title":"自动写入文字动态效果函数的实现","date":"2022-10-03T12:26:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["vue"],"hideAtIndex":true,"categories":"前端","id":2050704433,"countWords":1166,"readSeconds":116.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 自动写入文字动态效果函数的实现\r\n\r\n**代码**\r\n```js\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nexport const autoTyping = async function(DomElement, start_TextString ,ended_TextString,interval=150) {\r\n    return new Promise(async(TypingResolve,TypingReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce(){\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n\r\n\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nexport const autoBackSpacing = async function(DomElement, start_TextString ,ended_TextString='',interval=150) {\r\n    return new Promise(async(BackSpaceResolve,BackSpaceReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce(){\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText!=ended_TextString ) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0,DomElement.innerText.length-1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nexport const waitMs = function(timeout){\r\n    return new Promise((resolve)=>{\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n```\r\n\r\n**测试代码**\r\n\r\n<span id=\"span\" data-value=\"在绝望中坚持真理,在荒诞中奋起抵抗.\" ></span><span class=\"_\">_</span>\r\n<br>\r\n<button id=\"btn\">点击测试效果</button>\r\n<script>\r\nlet span = document.querySelector(\"#span\")\r\nlet btn = document.querySelector(\"#btn\")\r\nbtn.addEventListener('click',async ()=>{\r\n    try{\r\n        await autoTyping(span,'',span.dataset['value'],150)\r\n        await waitMs(2000)\r\n        await autoBackSpacing(span,span.dataset['value'],'',50)\r\n    }catch(e){\r\n        console.log(e);\r\n    }\r\n})\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\n    async function autoTyping(DomElement, start_TextString ,ended_TextString,interval=150) {\r\n    return new Promise(async(TypingResolve,TypingReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce(){\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nasync function autoBackSpacing(DomElement, start_TextString ,ended_TextString='',interval=150) {\r\n    return new Promise(async(BackSpaceResolve,BackSpaceReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce(){\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText!=ended_TextString ) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0,DomElement.innerText.length-1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nfunction waitMs(timeout){\r\n    return new Promise((resolve)=>{\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n</script>\r\n\r\n<style>\r\n._{\r\n    display: inline-block;\r\n    margin-left: 5px;\r\n    animation: dash_flash 0.7s ease infinite;\r\n}\r\n@keyframes dash_flash {\r\n    /* 定义动画 */\r\n    from{opacity: 0;}\r\n    to{opacity: 1;}\r\n}\r\n</style>\r\n\r\n\r\n```html\r\n<span id=\"span\" data-value=\"在绝望中坚持真理,在荒诞中奋起抵抗.\" ></span><span class=\"_\">_</span>\r\n<br>\r\n<button id=\"btn\">点击测试</button>\r\n<script>\r\nlet span = document.querySelector(\"#span\")\r\nlet btn = document.querySelector(\"#btn\")\r\nbtn.addEventListener('click',async ()=>{\r\n    try{\r\n        await autoTyping(span,'',span.dataset['value'])\r\n        await waitMs(2000)\r\n        await autoBackSpacing(span,span.dataset['value'],'')\r\n    }catch(e){\r\n        console.log(e);\r\n    }\r\n})\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\n    async function autoTyping(DomElement, start_TextString ,ended_TextString,interval=150) {\r\n    return new Promise(async(TypingResolve,TypingReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce(){\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nasync function autoBackSpacing(DomElement, start_TextString ,ended_TextString='',interval=150) {\r\n    return new Promise(async(BackSpaceResolve,BackSpaceReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce(){\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText!=ended_TextString ) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0,DomElement.innerText.length-1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nfunction waitMs(timeout){\r\n    return new Promise((resolve)=>{\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n</script>\r\n\r\n<style>\r\n._{\r\n    display: inline-block;\r\n    margin-left: 5px;\r\n    animation: dash_flash 0.7s ease infinite;\r\n}\r\n@keyframes dash_flash {\r\n    /* 定义动画 */\r\n    from{opacity: 0;}\r\n    to{opacity: 1;}\r\n}\r\n</style>\r\n```\r\n"},{"shortInfo":{"title":"bootstrap笔记","date":"2022-06-22T23:22:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["bootstrap","前端"],"categories":"笔记","hideAtIndex":true,"id":1320646771,"countWords":741,"readSeconds":74.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# bootstrap笔记\r\n\r\n## 目录\r\n- [bootstrap笔记](#bootstrap笔记)\r\n  - [目录](#目录)\r\n  - [简介](#简介)\r\n  - [dist](#dist)\r\n  - [基本使用步骤](#基本使用步骤)\r\n  - [栅格系统](#栅格系统)\r\n    - [栅格化](#栅格化)\r\n    - [代码书写方式](#代码书写方式)\r\n    - [使用测试](#使用测试)\r\n  - [一些类名](#一些类名)\r\n    - [container](#container)\r\n  - [官方文档](#官方文档)\r\n    - [全局样式](#全局样式)\r\n    - [组件](#组件)\r\n    - [JavaScript插件](#javascript插件)\r\n\r\n\r\n\r\n\r\n\r\n## 简介\r\n用于开发**响应式**布局、**移动设备优先**的 WEB 项目。\r\n\r\n## dist\r\n* `bootstrap-3.4.1` 源码\r\n* `bootstrap-3.4.1-dist` 用于生产环境的\r\n* `-min`格式化到同一行的，一定程度上压缩了体积的代码\r\n\r\n## 基本使用步骤\r\n1. 引用booststrap的css代码\r\n    ```html\r\n    <link rel=\"stylesheet\" href=\"./lib/bootstrap-3.4.1-dist/css/bootstrap.css\">\r\n    <link rel=\"stylesheet\" href=\"./lib/bootstrap-3.4.1-dist/css/bootstrap.min.css\">\r\n    ```\r\n2. 调用类\r\n\r\n\r\n## 栅格系统\r\n### 栅格化\r\n栅格化是指将整个网页的宽度分成诺干份  \r\nbootstrap3中默认将网页分成12等份\r\n![](./images/bootstrap笔记/2022-06-23-04-35-08.png)\r\n如有一个盒子要一行容纳四个子盒子，那么每个子盒子就要占父盒子宽度的三份\r\n\r\n### 代码书写方式\r\nbootstrap3把所有屏幕分成4类\r\n![](./images/bootstrap笔记/2022-06-23-04-41-42.png)\r\n* 语义解释\r\n    * .col-xs- 超小屏幕 手机 (<=768px) (iPhone6、7、8 375px) (iPhone12Pro 390px)\r\n    * .col-sm- 小屏幕 平板 (≥768px)\r\n    * .col-md- 中等屏幕 桌面显示器 (≥992px)\r\n    * .col-lg- 大屏幕 大桌面显示器 (≥1200px)\r\n    * col-列；colum\r\n    * xs-maxsmall，超小；sm-small，小；md-medium，中等；lg-large，大；\r\n    * -*表示占列，即占自动每行row分12列栅格系统比；\r\n\r\n### 使用测试\r\n大屏一行排列4个；中屏一行排列2个\r\n```html\r\n<link rel=\"stylesheet\" href=\"./lib/bootstrap-3.4.1-dist/css/bootstrap.css\">\r\n<style>\r\n    .container div{\r\n        height: 50px;\r\n        background-color: skyblue;\r\n        text-align: center;\r\n    }\r\n</style>\r\n<div class=\"container\">\r\n    <div class=\"col-lg-3 col-md-6\">1</div>\r\n    <div class=\"col-lg-3 col-md-6\">2</div>\r\n    <div class=\"col-lg-3 col-md-6\">3</div>\r\n    <div class=\"col-lg-3 col-md-6\">4</div>\r\n</div>\r\n```\r\n\r\n## 一些类名\r\n### container\r\n* `container` 响应式布局版心,自带15px左右内边距\r\n* `row` 自带-15px的左右外边距，用于抵消container的15px **用法**是:`container>row`\r\n    ```html\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div></div>\r\n            <div></div>\r\n            <div></div>\r\n        </div>\r\n    </div>\r\n    ```\r\n* `container-fluid` 宽度为100%的容器，自带15px左右内边距\r\n\r\n\r\n## 官方文档\r\n一般直接查[官方文档](https://v3.bootcss.com/)\r\n* **全局样式** 可以直接调用的类名\r\n* **组件** 封装好的功能组件，下拉菜单，导航等\r\n* **JavaScript插件** 一些现成的封装好的交互效果\r\n\r\n* **定制** 根据需求修改框架原有的功能\r\n![](./images/bootstrap笔记/2022-06-23-05-50-57.png)\r\n\r\n### 全局样式\r\n一般直接查[官方文档](https://v3.bootcss.com/)\r\n### 组件\r\n一般直接查[官方文档](https://v3.bootcss.com/)\r\n### JavaScript插件\r\n一般直接查[官方文档](https://v3.bootcss.com/)\r\n\r\nJavaScript插件\r\n* 需要先引入jquery\r\n* 再引入bootstrap.js\r\n* 位置一般写在body结束标签之前\r\n\r\nCarousel是轮播图"},{"shortInfo":{"title":"C++实现元胞自动机模拟器","date":"2021-01-12T16:00:00.000Z","cover":"\\self_server\\assets\\images\\C++实现元胞自动机模拟器\\cover.gif","tags":["c++","元胞自动机","demo"],"categories":"笔记","hideAtIndex":true,"imageMin":true,"id":1806477147,"countWords":19,"readSeconds":1.9,"assetsbaseUrl":"/self_server/assets/"},"content":"## [-->下载<--](./uploads/live_game.zip)\r\n\r\n\r\n![](./images/C++实现元胞自动机模拟器/cover.gif)"},{"shortInfo":{"title":"C++实现贪吃蛇小游戏","date":"2021-02-16T16:00:00.000Z","cover":"\\self_server\\assets\\images\\C++实现贪吃蛇小游戏\\cover1.gif","tags":["C++","贪吃蛇","demo"],"categories":"笔记","hideAtIndex":true,"imageMin":true,"id":3162786206,"countWords":32,"readSeconds":3.2,"assetsbaseUrl":"/self_server/assets/"},"content":"## [-->自动吃食版下载<--](./uploads/autoEat.exe)\r\n\r\n## [-->玩家操作版下载<--](./uploads/userPlay.exe)\r\n\r\n![](./images/C++实现贪吃蛇小游戏/cover1.gif)"},{"shortInfo":{"title":"C++实现连连看小游戏及寻路算法演示","date":"2021-04-02T22:03:00.000Z","cover":"\\self_server\\assets\\images\\C++实现连连看小游戏及寻路算法演示\\cover.gif","tags":["连连看","C++","demo"],"categories":"笔记","hideAtIndex":true,"imageMin":true,"id":4150131817,"countWords":236,"readSeconds":23.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# [-->下载<--](./uploads/连连看/Linkup.exe)\r\n\r\n![](./images/C++实现连连看小游戏及寻路算法演示/cover.gif)\r\n\r\n## 映射彩虹色\r\n\r\n**原理**\r\n![](./images/C++实现连连看小游戏及寻路算法演示/2022-10-18-16-56-24.png)\r\n\r\n**代码**\r\n```c++\r\n    int preocess_color(double rate)//[0.0 ~ 1.0]  -> struct rgb[char red,char green,char blue]\r\n    {\r\n        int R=0;\r\n        int G=0;\r\n        int B=0;\r\n        if(rate<=1/6.0)\r\n        {\r\n            R=255;\r\n            G=152/(1/6.0)*rate;\r\n            B=0;\r\n        }\r\n        else\r\n        if(rate<=2/6.0)\r\n        {\r\n            R=255;\r\n            G=255/(2/6.0)*rate;\r\n            B=0;\r\n        }\r\n        else\r\n        if(rate<=3/6.0)\r\n        {\r\n            R=255/(0-(1/6.0))*(rate-2/6.0)+255;\r\n            G=255;\r\n            B=0;\r\n        }\r\n        else\r\n        if(rate<=4/6.0)\r\n        {\r\n            R=0;\r\n            G=255;\r\n            B=255/(1/6.0)*(rate-3/6.0);\r\n        }\r\n        else\r\n        if(rate<=5/6.0)\r\n        {\r\n            R=0;\r\n            G=255/(0-(1/6.0))*(rate-4/6.0)+255;\r\n            B=255;\r\n        }\r\n        else\r\n        //if(rate<=1)\r\n        {\r\n            R=150/(1/6.0)*(rate-5/6.0);\r\n            G=0;\r\n            B=255;\r\n        }\r\n        return EGERGB(R,G,B);\r\n\r\n    }\r\n```\r\n\r\n\r\n## 计算互补色\r\n```c++\r\n    //计算互补色180°\r\n    int process_another_color(int in_color)\r\n    {\r\n\r\n        int B=GetRValue(in_color);\r\n        int G=GetGValue(in_color);\r\n        int R=GetBValue(in_color);\r\n\r\n\r\n        return EGERGB(255-R,255-G,255-B);\r\n    }\r\n```"},{"shortInfo":{"layout":"post","title":"CSS3+HTML5项目实战","date":"2022-06-16T13:51:00.000Z","tags":["网站","demo"],"hideAtIndex":true,"categories":"前端","cover":"\\self_server\\assets\\images\\default_cover2.jpg","id":2151049767,"countWords":42,"readSeconds":4.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# CSS3+HTML5项目实战\r\n\r\n## Demos\r\n### [-->学成在线<--](./demos/CSS3+HTML5项目实战/学成在线/)\r\n### [-->小兔仙<--](./demos/CSS3+HTML5项目实战/小兔仙/xtx-pc-client/)\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"title":"CSS3进阶笔记","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-06-16T17:51:00.000Z","tags":["CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":1157729724,"countWords":5918,"readSeconds":591.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# CSS3进阶笔记\r\n\r\n## 目录\r\n- [CSS3进阶笔记](#css3进阶笔记)\r\n  - [目录](#目录)\r\n  - [字体图标](#字体图标)\r\n  - [阿里巴巴矢量字体库iconfont使用步骤](#阿里巴巴矢量字体库iconfont使用步骤)\r\n  - [平面转换](#平面转换)\r\n    - [平面位移](#平面位移)\r\n    - [平面旋转](#平面旋转)\r\n    - [位移旋转缩放的中心点更改](#位移旋转缩放的中心点更改)\r\n    - [多重转换](#多重转换)\r\n    - [平面缩放](#平面缩放)\r\n    - [使用transform的居中和缩放](#使用transform的居中和缩放)\r\n  - [空间转换](#空间转换)\r\n    - [透视](#透视)\r\n    - [空间位移](#空间位移)\r\n    - [空间旋转](#空间旋转)\r\n      - [几种空间旋转效果测试](#几种空间旋转效果测试)\r\n    - [立体呈现](#立体呈现)\r\n      - [尝试实现立方体-正交](#尝试实现立方体-正交)\r\n      - [3d导航条实现](#3d导航条实现)\r\n    - [空间缩放](#空间缩放)\r\n      - [对3d立方体盒子的空间缩放测试](#对3d立方体盒子的空间缩放测试)\r\n  - [动画](#动画)\r\n    - [animation动画属性](#animation动画属性)\r\n    - [立方体动画测试](#立方体动画测试)\r\n    - [制作精灵动画](#制作精灵动画)\r\n    - [无缝走马灯动画](#无缝走马灯动画)\r\n  - [渐变背景](#渐变背景)\r\n    - [使用示例1](#使用示例1)\r\n    - [使用示例2-综合案例实现](#使用示例2-综合案例实现)\r\n  - [绘制三角形](#绘制三角形)\r\n  - [毛玻璃效果](#毛玻璃效果)\r\n  - [背景图片的实现方式](#背景图片的实现方式)\r\n\r\n## 字体图标\r\n* 字体图标展示的是图标，实际特性却像是字，可以通过color属性改变颜色\r\n* 字体图标用于处理颜色单一的简单小图（复杂图用精灵图）\r\n* ![](./images/CSS3进阶笔记/2022-06-17-01-55-16.png)\r\n* 优点：\r\n    * 灵活，尺寸颜色可用css属性修改\r\n    * 轻量，体积小渲染快降低服务器请求次数\r\n    * 兼容，几乎兼容所有主流浏览器\r\n    * 方便，\r\n        * 下载字体包\r\n        * 使用字体图标\r\n  \r\n## 阿里巴巴矢量字体库iconfont使用步骤\r\n1. `iconfont.cn`下载字体图标\r\n2. 引入的css文件名为iconfont.css ![](./images/CSS3进阶笔记/2022-06-17-02-23-42.png)\r\n    ```html\r\n    <link rel=\"stylesheet\" href=\"./iconfont/iconfont.css\">\r\n    ```\r\n\r\n3. 调用图标对应的类名，**必须**调用两个类名\r\n    1. `iconfont`类,基本样式，包含字体图标的默认大小和颜色\r\n    2. `icon-xxx`类,图标对应的类名![](./images/CSS3进阶笔记/2022-06-17-02-26-00.png)\r\n    ```html\r\n    <span class=\"iconfont icon-XXX\"></span>\r\n    ```\r\n* iconfont具体实现原理\r\n    * `.iconfont`类\r\n    * ![](./images/CSS3进阶笔记/2022-06-17-02-50-20.png)\r\n    * `.icon-XXX`类\r\n    ![](./images/CSS3进阶笔记/2022-06-17-02-57-28.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 平面转换\r\n* 作用：改变盒子在**平面(2D)**的形态(**位移** ， 旋转 ， **缩放** )\r\n* 属性名: **transform**\r\n* 语法格式:\r\n    * `transform: translate(水平向右移动距离,垂直向下移动距离);`\r\n    * `transform: translate(自身宽度的百分比,自身高度的百分比);`\r\n    * `transform: translate(只写一个参数表示X轴移动距离);`\r\n    * `transform: translateX(一个参数);`\r\n    * `transform: translateY(一个参数);`\r\n    * \r\n![](./images/CSS3进阶笔记/2022-06-17-04-31-22.png)\r\n\r\n### 平面位移\r\n* `transform: translate(像素,或自身的百分比);`\r\n* 水平和垂直居中\r\n\r\n<div class=\"father\">\r\n    <div class=\"box\">transform: translate(-50%,-50%);</div>\r\n</div>\r\n<style>\r\n    .father{\r\n        position: relative;\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n    }\r\n    .father .box{\r\n        position:absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        transform: translate(-50%,-50%);\r\n        width: 200px;\r\n        height: 100px;\r\n        background-color: green;\r\n        line-height: 100px;\r\n    }\r\n</style>\r\n\r\n```html\r\n<div class=\"father\">\r\n    <div class=\"box\">transform: translate(-50%,-50%);</div>\r\n</div>\r\n<style>\r\n    .father{\r\n        position: relative;\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n    }\r\n    .father .box{\r\n        position:absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        transform: translate(-50%,-50%);\r\n        width: 200px;\r\n        height: 100px;\r\n        background-color: green;\r\n        line-height: 100px;\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n* 天猫\r\n\r\n<div class=\"tianmao-bgi\"></div>\r\n<style>\r\n    .tianmao-bgi{\r\n        width: 683px;\r\n        height: 300px;\r\n        background-image: url(./images/CSS3进阶笔记/bg.jpg);\r\n        background-size: contain;\r\n        /* 溢出部分隐藏 */\r\n        overflow: hidden;\r\n    }\r\n    .tianmao-bgi::before,\r\n    .tianmao-bgi::after{\r\n        display: inline-block;\r\n        content: \"\";\r\n        width: 341px;\r\n        height: 300px;\r\n        background-image: url(./images/CSS3进阶笔记/fm.jpg);\r\n        background-size:cover;\r\n        transition: all 0.5s;\r\n    }\r\n    .tianmao-bgi::after{\r\n        background-position:right 0;\r\n    }\r\n    .tianmao-bgi:hover::before{\r\n        transform: translate(-100%);\r\n    }\r\n    .tianmao-bgi:hover::after{\r\n        transform: translate(+100%);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div class=\"tianmao-bgi\"></div>\r\n<style>\r\n    .tianmao-bgi{\r\n        width: 683px;\r\n        height: 300px;\r\n        background-image: url(./images/CSS3进阶笔记/bg.jpg);\r\n        background-size: contain;\r\n        /* 溢出部分隐藏 */\r\n        overflow: hidden;\r\n    }\r\n    .tianmao-bgi::before,\r\n    .tianmao-bgi::after{\r\n        display: inline-block;\r\n        content: \"\";\r\n        width: 341px;\r\n        height: 300px;\r\n        background-image: url(./images/CSS3进阶笔记/fm.jpg);\r\n        background-size:cover;\r\n        transition: all 0.5s;\r\n    }\r\n    .tianmao-bgi::after{\r\n        background-position:right 0;\r\n    }\r\n    .tianmao-bgi:hover::before{\r\n        transform: translate(-100%);\r\n    }\r\n    .tianmao-bgi:hover::after{\r\n        transform: translate(+100%);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n### 平面旋转\r\n* 语法 `transform:rotate(角度deg);`\r\n* 角度单位deg\r\n* 旋转一圈为360deg\r\n* 取正为顺时针旋转，取负则相反\r\n* 一定要配合**过渡**属性才能看到动态的效果\r\n\r\n<div class=\"rotate-test\" >旋转测试</div>\r\n<style>\r\n    .rotate-test{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        text-align: center;\r\n        line-height: 100px;\r\n        /* 一定要配合过渡属性才能看到动态的效果 */\r\n        transition: all 1s;\r\n    }\r\n    .rotate-test:hover{\r\n        transform:rotate(360deg);\r\n    }\r\n</style>\r\n\r\n### 位移旋转缩放的中心点更改\r\n* 默认原点是盒子的中心点\r\n* 语法: `transform-origin: 水平位置 垂直位置;`\r\n* 取值：**方位名词**、像素、百分比（相对于盒子自身尺寸计算）\r\n* 示例\r\n<div class=\"origin-test\" >旋转测试</div>\r\n<style>\r\n    .origin-test{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        text-align: center;\r\n        line-height: 100px;\r\n        transition: all 1s;\r\n        transform-origin: right bottom;\r\n    }\r\n    .origin-test:hover{\r\n        transform:rotate(360deg);\r\n    }\r\n</style>\r\n\r\n\r\n### 多重转换\r\n* 语法格式,将其当做复合属性：`transform: translate() rotate();`\r\n* 注意\r\n    * 因为旋转会改变坐标轴方向，所以如果要实现平移+旋转效果，需要注意该属性的两个参数的顺序\r\n    * 不能拆成`transform: translate();transform: rotate();`两个写，否则后一个将会覆盖前一个。\r\n\r\n<div class=\"multip\" >\r\n    <div>多重转换</div>\r\n</div>\r\n<style>\r\n    .multip{\r\n        width: 313px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n    }\r\n    .multip div{\r\n        position: relative;\r\n        left: -50px;\r\n        height: 100px;\r\n        width: 100px;\r\n        background: green;\r\n        transition: all 2s;\r\n        border-radius: 50%;\r\n        text-align: center;\r\n        line-height: 100px;\r\n    }\r\n    .multip:hover div{\r\n        transform: translate(313px,0) rotate(360deg);\r\n    }\r\n</style>\r\n\r\n\r\n```html\r\n<div class=\"multip\" >\r\n    <div>多重转换</div>\r\n</div>\r\n<style>\r\n    .multip{\r\n        width: 313px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n    }\r\n    .multip div{\r\n        position: relative;\r\n        left: -50px;\r\n        height: 100px;\r\n        width: 100px;\r\n        background: green;\r\n        transition: all 2s;\r\n        border-radius: 50%;\r\n        text-align: center;\r\n        line-height: 100px;\r\n    }\r\n    .multip:hover div{\r\n        transform: translate(313px,0) rotate(360deg);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n### 平面缩放\r\n* 语法：\r\n    * transform:scale(X轴缩放倍数,Y轴缩放倍数);\r\n    * transform:scale(XY等比例缩放倍数);\r\n* 倍数没有单位\r\n\r\n<div class=\"father-scale\">\r\n    <div class=\"box\">transform:scale(缩放倍数);</div>\r\n</div>\r\n<style>\r\n    .father-scale{\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n        overflow: hidden;\r\n    }\r\n    .father-scale .box{\r\n        width: 100%;\r\n        height: 100%;\r\n        background-color: green;\r\n        transition: transform 1s;\r\n        line-height: 300px;\r\n        text-align: center;\r\n    }\r\n    .father-scale:hover .box{\r\n        transform: scale(1.5);\r\n    }\r\n</style>\r\n\r\n### 使用transform的居中和缩放\r\n* 需要把居中和缩放写到一个transform中\r\n* `transform:translate(-50%,-50%) scale(0.5);`\r\n\r\n<div class=\"father-scaleAndMiddle\">\r\n    <div class=\"box\">transform:translate(-50%,-50%) scale(0.5);</div>\r\n</div>\r\n<style>\r\n    .father-scaleAndMiddle{\r\n        position: relative;\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n        overflow: hidden;\r\n    }\r\n    .father-scaleAndMiddle .box{\r\n        position: absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        width: 50%;\r\n        height: 50%;\r\n        background-color: green;\r\n        transition: all 1s;\r\n        line-height: 150px;\r\n        font-size: 0.5em;\r\n        text-align: center;\r\n        transform: translate(-50%,-50%) scale(1);\r\n    }\r\n    .father-scaleAndMiddle:hover .box{\r\n        transform: translate(-50%,-50%) scale(1.5);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div class=\"father-scaleAndMiddle\">\r\n    <div class=\"box\">transform:translate(-50%,-50%) scale(0.5);</div>\r\n</div>\r\n<style>\r\n    .father-scaleAndMiddle{\r\n        position: relative;\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n        overflow: hidden;\r\n    }\r\n    .father-scaleAndMiddle .box{\r\n        position: absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        width: 50%;\r\n        height: 50%;\r\n        background-color: green;\r\n        transition: transform 1s;\r\n        line-height: 150px;\r\n        text-align: center;\r\n        transform: translate(-50%,-50%) scale(1);\r\n    }\r\n    .father-scaleAndMiddle:hover .box{\r\n        transform: translate(-50%,-50%) scale(1.5);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 空间转换\r\n* 使用transform属性实现元素在**空间(3D)**内的**位移**，**旋转**，**缩放**等效果\r\n* z轴的正轴方向为从屏幕指向自己\r\n![](./images/CSS3进阶笔记/2022-06-18-03-10-06.png)\r\n\r\n### 透视\r\n浏览器默认应该是正交透视，没有近大远小的透视效果\r\n* 属性名：perspective\r\n* 语法：perspective:透视距离;\r\n* 建议的取值：**800-1200px**\r\n* 使用：添加给盒子的父级，透视中心为父级盒子的中心\r\n* 注意：记得给盒子添加宽高，否则会找到一个错误的中心点\r\n* 透视距离，也称视距，指人眼到屏幕的距离\r\n![](./images/CSS3进阶笔记/2022-06-18-03-43-26.png)\r\n\r\n\r\n### 空间位移\r\n* 语法：\r\n    * `transform:translate3d(x,y,z);`\r\n    * `transform:translateX(x);`\r\n    * `transform:translateY(y);`\r\n    * `transform:translateZ(z);`\r\n* 取值：像素，百分比(以自身长宽高为基准)\r\n* **注意**：默认为正交透视，所以在Z轴的位移将看不出近大远小的透视效果\r\n\r\n\r\n<div class=\"transZtest1\">\r\n    <div></div>\r\n</div>\r\n<style>\r\n    .transZtest1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        /* 透视 盒子中心成为透视中心 */\r\n        perspective: 1200px;\r\n    }\r\n    .transZtest1 div\r\n    {\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n    }\r\n    .transZtest1:hover div{\r\n        transform: translateZ(-1000px);\r\n    }\r\n</style>\r\n\r\n\r\n### 空间旋转\r\n* 语法：\r\n    * `rotateX()` 绕X轴旋转\r\n    * `rotateY()` 绕Y轴旋转\r\n    * `rotateZ()` 绕Z轴旋转\r\n    * `rotate3d(x,y,z,角度度数)`\r\n        * **指定一个旋转轴，旋转指定的角度**\r\n        * **x,y,z取值为0-1的数字**\r\n* **注意**：默认为正交透视，所以在各轴的位移默认将看不出近大远小的透视效果\r\n\r\n\r\n#### 几种空间旋转效果测试\r\n<div class=\"rotateXtestBox1\">\r\n    <div class=\"rotateXtest\">rotateX()</div>\r\n</div>\r\n<style>\r\n    .rotateXtestBox1 {\r\n        margin:10px;\r\n        width: 100px;\r\n        height: 100px;\r\n        perspective: 1200px;\r\n    }\r\n    .rotateXtestBox1 .rotateXtest{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        transition: all 2s;\r\n    }\r\n    .rotateXtestBox1 .rotateXtest:hover{\r\n        transform: rotateX(60deg);\r\n    }\r\n</style>\r\n\r\n<div class=\"rotateXtestBox2\">\r\n    <div class=\"rotateXtest\">rotateY()</div>\r\n</div>\r\n<style>\r\n    .rotateXtestBox2 {\r\n        margin:10px;\r\n        perspective: 1200px;\r\n    }\r\n    .rotateXtestBox2 .rotateXtest{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        transition: all 2s;\r\n    }\r\n    .rotateXtestBox2 .rotateXtest:hover{\r\n        transform: rotateY(60deg);\r\n    }\r\n</style>\r\n\r\n<div class=\"rotateXtestBox3\">\r\n    <div class=\"rotateXtest\">rotateZ()</div>\r\n</div>\r\n<style>\r\n    .rotateXtestBox3 {\r\n        margin:10px;\r\n        perspective: 1200px;\r\n    }\r\n    .rotateXtestBox3 .rotateXtest{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        transition: all 2s;\r\n    }\r\n    .rotateXtestBox3 .rotateXtest:hover{\r\n        transform: rotateZ(60deg);\r\n    }\r\n</style>\r\n\r\n### 立体呈现\r\n* 用法：`transform-style:preserve-3d`\r\n    * 默认值：`flat`，表示处于平面空间\r\n* 作用：使子元素处于3d空间\r\n\r\n\r\n#### 尝试实现立方体-正交\r\n* 结合transform-style、transition、rotate等属性的综合案例\r\n\r\n<div class=\"threedbox\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    .threedbox{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        /* perspective: 1500px; */\r\n        transform-style: preserve-3d;\r\n        transition: all 5s;\r\n    }\r\n    .threedbox .font,\r\n    .threedbox .back,\r\n    .threedbox .left,\r\n    .threedbox .right,\r\n    .threedbox .top,\r\n    .threedbox .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    .threedbox .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    .threedbox .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    .threedbox .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    .threedbox .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    .threedbox .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    .threedbox .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    .threedbox:hover{\r\n        /* transform: rotateY(365deg); */\r\n        transform: rotate3d(1,1,1,360deg);\r\n    }\r\n</style>\r\n\r\n代码：\r\n```html\r\n<div class=\"threedbox\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n\r\n<style>\r\n    .threedbox{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        /* perspective: 1200px; */\r\n        transform-style: preserve-3d;\r\n        transition: all 5s;\r\n    }\r\n    .threedbox .font,\r\n    .threedbox .back,\r\n    .threedbox .left,\r\n    .threedbox .right,\r\n    .threedbox .top,\r\n    .threedbox .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    .threedbox .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    .threedbox .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    .threedbox .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    .threedbox .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    .threedbox .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    .threedbox .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    \r\n    .threedbox:hover{\r\n        /* transform: rotateY(365deg); */\r\n        transform: rotate3d(1,1,1,360deg);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 3d导航条实现\r\n<div class=\"nav-demo clearall\">\r\n    <ul>\r\n        <li><a class=\"clearfix\" href=\"#\"><span>首页</span><span>index</span></a></li>\r\n        <li><a class=\"clearfix\" href=\"#\"><span>中文</span><span>Chinese</span></a></li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    .clearfix::after{\r\n        content:'';\r\n        display:block;\r\n        clear:both;\r\n    }\r\n    .nav-demo ul{\r\n        list-style: none;\r\n        height: 30px;\r\n    }\r\n    .nav-demo ul li{\r\n        float: left;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        /* background-color: #fff; */\r\n    }\r\n    .nav-demo ul li a{\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 30px;\r\n        width: 80px;\r\n        line-height: 30px;\r\n        perspective: 1200px;\r\n        transform-style: preserve-3d;\r\n        text-align: center;\r\n        transition: all 1s;\r\n        color: white;\r\n    }\r\n    .nav-demo ul li a span{\r\n        position:absolute;\r\n        left: 0px;\r\n        top: 0px;\r\n        display: inline-block;\r\n        height: 30px;\r\n        width: 100%;\r\n        background-color: green;\r\n    }\r\n    .nav-demo ul li span:nth-child(1){\r\n        transform: translateZ(15px);\r\n    }\r\n    .nav-demo ul li span:nth-child(2){\r\n        background-color: orange;\r\n        transform: translateY(-15px) rotateX(90deg) ;\r\n    }\r\n    .nav-demo ul li:hover a{\r\n        /* transform: rotate3d(1,1,1,90deg); */\r\n        transform: rotate3d(1,0,0,-90deg);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div class=\"nav-demo\">\r\n    <ul>\r\n        <li><a class=\"clearfix\" href=\"#\"><span>首页</span><span>index</span></a></li>\r\n        <li><a class=\"clearfix\" href=\"#\"><span>中文</span><span>Chinese</span></a></li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    .clearfix::after{\r\n        content:'';\r\n        display:block;\r\n        clear:both;\r\n    }\r\n    .nav-demo ul{\r\n        list-style: none;\r\n        height: 30px;\r\n    }\r\n    .nav-demo ul li{\r\n        float: left;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        /* background-color: #fff; */\r\n    }\r\n    .nav-demo ul li a{\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 30px;\r\n        width: 80px;\r\n        line-height: 30px;\r\n        perspective: 1200px;\r\n        transform-style: preserve-3d;\r\n        text-align: center;\r\n        transition: all 1s;\r\n        color: white;\r\n    }\r\n    .nav-demo ul li a span{\r\n        position:absolute;\r\n        left: 0px;\r\n        top: 0px;\r\n        display: inline-block;\r\n        height: 30px;\r\n        width: 100%;\r\n        background-color: green;\r\n    }\r\n    .nav-demo ul li span:nth-child(1){\r\n        transform: translateZ(15px);\r\n    }\r\n    .nav-demo ul li span:nth-child(2){\r\n        background-color: orange;\r\n        transform: translateY(-15px) rotateX(90deg) ;\r\n    }\r\n    .nav-demo ul li:hover a{\r\n        /* transform: rotate3d(1,1,1,90deg); */\r\n        transform: rotate3d(1,0,0,-90deg);\r\n    }\r\n</style>\r\n```\r\n\r\n### 空间缩放\r\n* 语法：\r\n    * `transform:scaleX(倍数);` 将模型拉宽，效果参考平面缩放\r\n    * `transform:scaleY(倍数);` 将模型拉高，效果参考平面缩放\r\n    * `transform:scaleZ(倍数);` 将模型拉长，效果相当于模型有了厚度\r\n    * `transform:scale3d(倍数,倍数,倍数);`\r\n* 注意书写书写，一般应该先位移，后旋转，再缩放\r\n\r\n#### 对3d立方体盒子的空间缩放测试\r\n\r\n<div id=\"threedbox-2\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    #threedbox-2{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        perspective: 1500px;\r\n        transform-style: preserve-3d;\r\n        transition: all 3s;\r\n        transform:  rotate3d(1,1,1,30deg) ;\r\n    }\r\n    #threedbox-2 .font,\r\n    #threedbox-2 .back,\r\n    #threedbox-2 .left,\r\n    #threedbox-2 .right,\r\n    #threedbox-2 .top,\r\n    #threedbox-2 .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    #threedbox-2 .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    #threedbox-2 .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    #threedbox-2 .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    #threedbox-2 .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    #threedbox-2 .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    #threedbox-2 .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    #threedbox-2:hover{\r\n        /* scale3d测试 */\r\n        transform:  rotate3d(1,1,1,30deg) scale3d(0.5,1.5,2);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div id=\"threedbox-2\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    #threedbox-2{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        perspective: 1500px;\r\n        transform-style: preserve-3d;\r\n        transition: all 3s;\r\n        transform:  rotate3d(1,1,1,30deg) ;\r\n    }\r\n    #threedbox-2 .font,\r\n    #threedbox-2 .back,\r\n    #threedbox-2 .left,\r\n    #threedbox-2 .right,\r\n    #threedbox-2 .top,\r\n    #threedbox-2 .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    #threedbox-2 .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    #threedbox-2 .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    #threedbox-2 .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    #threedbox-2 .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    #threedbox-2 .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    #threedbox-2 .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    #threedbox-2:hover{\r\n        /* scale3d测试 */\r\n        transform:  rotate3d(1,1,1,30deg) scale3d(0.5,1.5,2);\r\n    }\r\n    \r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n## 动画\r\n* 构成动画的最小单位是帧或动画帧\r\n* 动画和过渡的区别：\r\n    * 过渡是两个状态间的变化过程\r\n    * 动画是多个状态间的变化过程\r\n\r\n* 实现步骤\r\n    1. 定义动画\r\n        * 方法1 两个状态间的动画\r\n            ```css\r\n            @keyframes 动画名称{\r\n                from{}\r\n                to{}\r\n            }\r\n            ```\r\n        * 方法2 多个状态间的动画\r\n            ```css\r\n            @keyframes 动画名称{\r\n                <!-- 百分比指的是占用时间的百分比 -->\r\n                0%{}\r\n                10%{}\r\n                20%{}\r\n                50%{}\r\n                100%{}\r\n            }\r\n            ```\r\n    2. 使用动画\r\n        ```css\r\n            animation:动画名称 动画花费时长;\r\n        ```\r\n\r\n* 测试\r\n<div id=\"testframe1\">\r\n    动画将在刷新浏览器后立即播放\r\n</div>\r\n<style>\r\n    #testframe1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        animation: changeWidth 10s;\r\n    }\r\n    @keyframes changeWidth {\r\n        from{\r\n            width: 100px;\r\n        }\r\n        to{\r\n            width: 200px;\r\n        }\r\n    }\r\n</style>\r\n<br>\r\n<div id=\"testframe2\">\r\n    动画将在刷新浏览器后立即播放\r\n</div>\r\n<style>\r\n    #testframe2{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        /* 总共10秒 */\r\n        animation: changeWidth2 10s;\r\n    }\r\n    @keyframes changeWidth2 {\r\n        0%{width: 0px;}\r\n        /* 0-200px用了1秒钟 */\r\n        10%{width: 200px;}\r\n        50%{width: 300px;}\r\n        /* 300-1000px用了最后五秒钟 */\r\n        100%{width: 1000px;}\r\n    }\r\n</style>\r\n\r\n```html\r\n<div id=\"testframe1\">\r\n    动画将在刷新浏览器后立即播放\r\n</div>\r\n<style>\r\n    #testframe1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        animation: changeWidth 10s;\r\n    }\r\n    @keyframes changeWidth {\r\n        from{\r\n            width: 100px;\r\n        }\r\n        to{\r\n            width: 200px;\r\n        }\r\n    }\r\n</style>\r\n<br>\r\n<div id=\"testframe2\">\r\n    动画将在刷新浏览器后立即播放\r\n</div>\r\n<style>\r\n    #testframe2{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        /* 总共10秒 */\r\n        animation: changeWidth2 10s;\r\n    }\r\n    @keyframes changeWidth2 {\r\n        0%{width: 0px;}\r\n        /* 0-200px用了1秒钟 */\r\n        10%{width: 200px;}\r\n        50%{width: 300px;}\r\n        /* 300-1000px用了最后五秒钟 */\r\n        100%{width: 1000px;}\r\n    }\r\n</style>\r\n```\r\n\r\n### animation动画属性\r\n* 完整语法格式: `animation: name1 duration1,name2 duration2;`\r\n* 完整语法格式: `animation: name duration timing-function delay iteration-count direction fill-mode;`\r\n* 完整语法格式: `animation: 动画名称 动画时长 速度曲线 延迟时间 重复次数 动画方向 执行完毕时状态;`\r\n* 注意：\r\n    * **动画名称和时长为必填值**\r\n    * **取值不分先后顺序**\r\n    * 如有两个数值，第一个表示动画时长，第二个表示延迟时间\r\n\r\n* **速度曲线**取值: 默认为补间动画，流畅\r\n    * `liner` 线性\r\n    * `steps(x)` 逐帧动画，分成x等份播放的动画\r\n\r\n* **延迟时间** ：单位s 延迟多少秒播放动画\r\n* \r\n* **重复次数** ： 默认只播放一次，设置后将播放指定次数\r\n    * **取纯数字** 指定播放次数\r\n    * **取关键字** \r\n        * `infinite` 无限次\r\n        * 等...\r\n\r\n* **动画方向**：默认按关键帧的顺序播放\r\n    * `alternative` 按关键帧的顺序播放后再反着倒放动画\r\n    * 等...\r\n\r\n* **执行完毕时状态**:\r\n    * `backwards` 默认值 动画停留在初始状态 \r\n    * `forwards` 动画停留在最终状态\r\n    * 注意:该属性值会和 `infinite` 、`alternative` 冲突\r\n\r\n\r\n* 拆分写法\r\n![](./images/CSS3进阶笔记/2022-06-18-21-29-52.png)\r\n\r\n\r\n### 立方体动画测试\r\n\r\n<div id=\"threedbox-animation1\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    #threedbox-animation1{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        /* perspective: 1200px; */\r\n        transform-style: preserve-3d;\r\n        transform: rotate3d(1,1,1,45deg);\r\n        /* 无限播放的动画 */\r\n        animation: threedboxFrames1 3s infinite;\r\n    }\r\n    #threedbox-animation1 .font,\r\n    #threedbox-animation1 .back,\r\n    #threedbox-animation1 .left,\r\n    #threedbox-animation1 .right,\r\n    #threedbox-animation1 .top,\r\n    #threedbox-animation1 .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    #threedbox-animation1 .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    #threedbox-animation1 .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    #threedbox-animation1 .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    #threedbox-animation1 .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    #threedbox-animation1 .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    #threedbox-animation1 .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    /* 定义动画 */\r\n    @keyframes threedboxFrames1 {\r\n        from{transform: rotate3d(1,1,1,45deg) rotate3d(0,1,0,0deg);}\r\n        to{transform:  rotate3d(1,1,1,45deg) rotate3d(0,1,0,360deg);}\r\n    }\r\n    #threedbox-animation1:hover{\r\n        /* 鼠标控制暂停的效果     */\r\n       animation-play-state: paused;\r\n    }\r\n</style>\r\n\r\n```html\r\n<div id=\"threedbox-animation1\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    #threedbox-animation1{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        /* perspective: 1200px; */\r\n        transform-style: preserve-3d;\r\n        transform: rotate3d(1,1,1,45deg);\r\n        /* 无限播放的动画 */\r\n        animation: threedboxFrames1 3s infinite;\r\n    }\r\n    #threedbox-animation1 .font,\r\n    #threedbox-animation1 .back,\r\n    #threedbox-animation1 .left,\r\n    #threedbox-animation1 .right,\r\n    #threedbox-animation1 .top,\r\n    #threedbox-animation1 .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    #threedbox-animation1 .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    #threedbox-animation1 .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    #threedbox-animation1 .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    #threedbox-animation1 .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    #threedbox-animation1 .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    #threedbox-animation1 .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    /* 定义动画 */\r\n    @keyframes threedboxFrames1 {\r\n        from{transform: rotate3d(1,1,1,45deg) rotate3d(0,1,0,0deg);}\r\n        to{transform:  rotate3d(1,1,1,45deg) rotate3d(0,1,0,360deg);}\r\n    }\r\n    #threedbox-animation1:hover{\r\n        /* 鼠标控制暂停的效果     */\r\n       animation-play-state: paused;\r\n    }\r\n</style>\r\n\r\n```\r\n\r\n### 制作精灵动画\r\n* 步骤\r\n    * 准备显示区域 尺寸为精灵图小图尺寸\r\n    * 定义动画 改变图片位置 \r\n    * 使用动画\r\n        * 添加速度曲线`steps(N)` N为小图数，\r\n        * 添加无限重复效果 `infinite`\r\n* 精灵图：\r\n![](./images/CSS3进阶笔记/bg2.png)\r\n\r\n<div id=\"spbox1\"></div>\r\n<style>\r\n    #spbox1{\r\n        width: 140px;\r\n        height: 140px;\r\n        /* background-color: #fff; */\r\n        border: 1px solid #fff;\r\n        background-image: url(./images/CSS3进阶笔记/bg2.png);\r\n        animation: \r\n            run1 1s infinite steps(12),\r\n            move1 10s infinite forwards;\r\n    }\r\n    @keyframes run1 {\r\n        /* from、0% 的初值是0 则这句可以省略 */\r\n        /* 0%{background-position: 0 0;} */\r\n        /*  */\r\n        /* 从第一张到第12张移动了-11*140px */\r\n        /* 从第一张到第一张移动了-12*140px */\r\n        /* 所以取值-1680px就好 */\r\n        100%{background-position: -1680px 0;}\r\n    }\r\n    @keyframes move1 {\r\n        /* from{transform:translateX(0px)} */\r\n        to{transform:translateX(300px)}\r\n        \r\n    }\r\n</style>\r\n\r\n\r\n### 无缝走马灯动画\r\n* 实现无缝的关键在于，要把最开头几张图复制到最后\r\n![](./images/CSS3进阶笔记/2022-06-18-23-47-35.png)\r\n\r\n\r\n\r\n\r\n\r\n## 渐变背景\r\n* 语法 \r\n    * `  linear-gradient(颜色1,颜色2);`\r\n    * `background-image: linear-gradient(transparent,颜色2);`\r\n    * `background-image: linear-gradient(颜色1,颜色2,颜色3);`\r\n* 图片遮罩：可以一个盒子背景为某张图片，嵌套一个类名为mask的相同大小的渐变背景图，定位在父级上\r\n\r\n### 使用示例1\r\n\r\n<div id=\"linear-1\"></div>\r\n<style>\r\n    #linear-1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-image: linear-gradient(red,green);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div id=\"linear-1\"></div>\r\n<style>\r\n    #linear-1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-image: linear-gradient(red,green);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n### 使用示例2-综合案例实现\r\n\r\n<div id=\"linearTest2Box\">\r\n    <img src=\"/images/CSS3进阶笔记/product.jpeg\" alt=\"\">\r\n    <div class=\"mask\"></div>\r\n    <div class=\"text\">\r\n        <h2>产品说明标题</h2>\r\n        <p>任意字数产品说明文字任意字数产品说明文字任意字数产品说明文字任意字数产品说明文字</p>\r\n    </div>\r\n</div>\r\n<style>\r\n    #linearTest2Box{\r\n        position: relative;\r\n        width: 384px;\r\n        height: 271px;\r\n        overflow: hidden;\r\n    }\r\n    #linearTest2Box img{\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 384px;\r\n        height: 271px;\r\n        transition: all 0.5s;\r\n        z-index: 1;\r\n    }\r\n    #linearTest2Box .mask{\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 384px;\r\n        height: 271px;\r\n        background-image: linear-gradient(transparent,rgba(0,0,0,0.5));\r\n        opacity: 0;\r\n        transition: all 0.5s;\r\n        z-index: 2;\r\n    }\r\n    #linearTest2Box .text {\r\n        position: absolute;\r\n        left: 0px;\r\n        bottom: 0px;\r\n        padding: 0 10px;\r\n        z-index: 3;\r\n        /* h2的行高为50px */\r\n        transform: translate(0,100%) translate(0,-50px);\r\n        transition: all 0.5s;\r\n    }\r\n    #linearTest2Box .text h2{\r\n        height: 50px;\r\n        font-size: 2em;\r\n        color: #fff;\r\n    }\r\n    #linearTest2Box .text p{\r\n        font-size: 1em;\r\n        color: #fff;\r\n        overflow: hidden;\r\n    }\r\n    #linearTest2Box:hover img{\r\n        transform: scale(1.05);\r\n    }\r\n    #linearTest2Box:hover .mask{\r\n        opacity: 1;\r\n    }\r\n    #linearTest2Box:hover .text{\r\n        transform: translate(0,0);\r\n    }\r\n</style>\r\n\r\n\r\n代码：\r\n```html\r\n<div id=\"linearTest2Box\">\r\n    <img src=\"/images/CSS3进阶笔记/product.jpeg\" alt=\"\">\r\n    <div class=\"mask\"></div>\r\n    <div class=\"text\">\r\n        <h2>产品说明标题</h2>\r\n        <p>任意字数产品说明文字任意字数产品说明文字任意字数产品说明文字任意字数产品说明文字</p>\r\n    </div>\r\n</div>\r\n<style>\r\n    #linearTest2Box{\r\n        position: relative;\r\n        width: 384px;\r\n        height: 271px;\r\n        overflow: hidden;\r\n    }\r\n    #linearTest2Box img{\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 384px;\r\n        height: 271px;\r\n        transition: all 0.5s;\r\n        z-index: 1;\r\n    }\r\n    #linearTest2Box .mask{\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 384px;\r\n        height: 271px;\r\n        background-image: linear-gradient(transparent,rgba(0,0,0,0.5));\r\n        opacity: 0;\r\n        transition: all 0.5s;\r\n        z-index: 2;\r\n    }\r\n    #linearTest2Box .text {\r\n        position: absolute;\r\n        left: 0px;\r\n        bottom: 0px;\r\n        padding: 0 10px;\r\n        z-index: 3;\r\n        /* h2的行高为50px */\r\n        transform: translate(0,100%) translate(0,-50px);\r\n        transition: all 0.5s;\r\n    }\r\n    #linearTest2Box .text h2{\r\n        height: 50px;\r\n        font-size: 2em;\r\n        color: #fff;\r\n    }\r\n    #linearTest2Box .text p{\r\n        font-size: 1em;\r\n        color: #fff;\r\n        overflow: hidden;\r\n    }\r\n    #linearTest2Box:hover img{\r\n        transform: scale(1.05);\r\n    }\r\n    #linearTest2Box:hover .mask{\r\n        opacity: 1;\r\n    }\r\n    #linearTest2Box:hover .text{\r\n        transform: translate(0,0);\r\n    }\r\n</style>\r\n```\r\n\r\n## 绘制三角形\r\n\r\n**利用边框拐角处的45度角绘制三角形**\r\n\r\n\r\n<div id=\"demoNOH895\">利用边框拐角处的45度角绘制三角形</div>\r\n<style>\r\n    #demoNOH895{\r\n    box-sizing: border-box;\r\n    width: 200px;\r\n    height: 200px;\r\n    border-top: 50px solid black;\r\n    border-right: 50px solid red;\r\n    border-bottom: 50px solid green;\r\n    border-left: 50px solid blue;\r\n}\r\n</style>\r\n\r\n```html\r\n<div id=\"demoNOH895\">利用边框拐角处的45度角绘制三角形</div>\r\n<style>\r\n    #demoNOH895{\r\n    box-sizing: border-box;\r\n    width: 200px;\r\n    height: 200px;\r\n    border-top: 50px solid black;\r\n    border-right: 50px solid red;\r\n    border-bottom: 50px solid green;\r\n    border-left: 50px solid blue;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n**宽高不定，各边框50px，效果：**\r\n\r\n<div id=\"demojowej09\"></div>\r\n<style>\r\n    #demojowej09{\r\n    box-sizing: border-box;\r\n    width: 0px;\r\n    height: 0px;\r\n    border-top: 50px solid black;\r\n    border-right: 50px solid red;\r\n    border-bottom: 50px solid green;\r\n    border-left: 50px solid blue;\r\n}\r\n</style>\r\n\r\n```html\r\n<div id=\"demojowej09\"></div>\r\n<style>\r\n    #demojowej09{\r\n    box-sizing: border-box;\r\n    width: 0px;\r\n    height: 0px;\r\n    border-top: 50px solid black;\r\n    border-right: 50px solid red;\r\n    border-bottom: 50px solid green;\r\n    border-left: 50px solid blue;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n**宽高不定，上边框50px，其他边框透明，效果：**\r\n\r\n<div id=\"demojowewdeio\"></div>\r\n<style>\r\n    #demojowewdeio{\r\n    box-sizing: border-box;\r\n    width: 0px;\r\n    height: 0px;\r\n    border-top: 50px solid green;\r\n    border-right: 50px solid transparent;\r\n    border-bottom: 50px solid transparent;\r\n    border-left: 50px solid transparent;\r\n}\r\n</style>\r\n\r\n```html\r\n<div id=\"demojowewdeio\"></div>\r\n<style>\r\n    #demojowewdeio{\r\n    box-sizing: border-box;\r\n    width: 0px;\r\n    height: 0px;\r\n    border-top: 50px solid green;\r\n    border-right: 50px solid transparent;\r\n    border-bottom: 50px solid transparent;\r\n    border-left: 50px solid transparent;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n可以实现的其他效果：\r\n![](./images/CSS3进阶笔记/2022-07-03-14-51-07.png)\r\n\r\n\r\n## 毛玻璃效果\r\n\r\n* 语法: `背景幕布-过滤器 : 模糊(像素)`\r\n* 案例: `backdrop-filter: blur(8px);`\r\n* 和filter的区别:\r\n  * filter ：模糊内容 作用于当前元素本身，并且它的后代元素也会继承这个属性\r\n  * backdrop-filter : 作用于当前元素背后的所有元素\r\n\r\n* 饱和度: `saturate(150%) <100%变暗，>100%变亮` 防止透过遮罩层内容过暗\r\n* 对比度: `contrast(50%) 100%为原图，0%为全灰色图像` 防止透过遮罩层内容色彩过杂\r\n\r\n示例\r\n```css\r\ndiv{\r\n\r\n    /* chrome浏览器 */\r\n    backdrop-filter:saturate(150%) contrast(50%) blur(8px);\r\n\r\n    /* ios浏览器 */\r\n    -webkit-backdrop-filter:saturate(150%) contrast(50%) blur(8px);\r\n}\r\n```\r\n\r\n## 背景图片的实现方式\r\n```html\r\n<div class=\"bg_img\" style=\"background-image: url(/src/components/BackGround/images/2.png);\"></div>\r\n\r\n<style>\r\n.bg_img{\r\n  z-index: -1;//保证其在最低层\r\n  position: fixed;//相对于视口布局\r\n  top: 0;\r\n  left: 0;\r\n  width: 100vh;//宽度为100%视口宽度\r\n  height: 100vh;//高度为100%视口宽度\r\n  background-size: cover;//关键属性\r\n  background-color: white; //默认背景白色\r\n  background-position: bottom center;//背景图片 水平 和 垂直 方向的对齐方式\r\n  filter:\r\n}\r\n</style>\r\n```"},{"shortInfo":{"title":"CSS3重学笔记","cover":"\\self_server\\assets\\images\\CSS3重学笔记\\cover.png","coverWidth":1920,"coverHeight":1080,"date":"2022-06-04T22:00:00.000Z","date_end":"2022-06-08T14:47:00.000Z","tags":["CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":1859149050,"countWords":13820,"readSeconds":1382,"assetsbaseUrl":"/self_server/assets/"},"content":"# css3重学笔记\r\n\r\n## 更新日志\r\n* **2022-06-05**: 因为感觉原先学CSS的时候没有学透彻，一直想重新系统性的学一遍，查缺补漏。最近几天有时间就开始学了，顺便记个笔记，加深印象、方便复习和查阅。\r\n* **2022.06.11**：终于把基础部分的知识点归纳总结完了，崩溃了，为什么这么多......\r\n* **2022.06.12**: 【增添】`background-size`、`text-shadow`、`box-shadow` `transition`属性笔记\r\n\r\n## 目录\r\n- [css3重学笔记](#css3重学笔记)\r\n  - [更新日志](#更新日志)\r\n  - [目录](#目录)\r\n  - [css简介](#css简介)\r\n  - [引入方式](#引入方式)\r\n    - [内嵌式](#内嵌式)\r\n    - [外联式](#外联式)\r\n    - [行内式](#行内式)\r\n  - [选择器](#选择器)\r\n    - [标签选择器](#标签选择器)\r\n    - [类选择器](#类选择器)\r\n    - [id选择器](#id选择器)\r\n    - [通配符选择器](#通配符选择器)\r\n    - [后代选择器](#后代选择器)\r\n    - [子代选择器](#子代选择器)\r\n    - [并集选择器](#并集选择器)\r\n    - [交集选择器](#交集选择器)\r\n    - [伪类选择器](#伪类选择器)\r\n    - [结构伪类选择器](#结构伪类选择器)\r\n    - [伪html元素选择器](#伪html元素选择器)\r\n  - [字体样式](#字体样式)\r\n    - [字体的大小属性](#字体的大小属性)\r\n    - [字体的粗细属性](#字体的粗细属性)\r\n    - [字体的倾斜属性](#字体的倾斜属性)\r\n    - [字体的family字体属性](#字体的family字体属性)\r\n    - [字体的复合属性](#字体的复合属性)\r\n  - [文本样式](#文本样式)\r\n    - [文本缩进属性](#文本缩进属性)\r\n    - [文本水平对齐方式属性](#文本水平对齐方式属性)\r\n    - [文本修饰线属性](#文本修饰线属性)\r\n    - [文本行高属性](#文本行高属性)\r\n    - [文字阴影属性](#文字阴影属性)\r\n    - [文字外边框](#文字外边框)\r\n  - [盒子模型](#盒子模型)\r\n    - [简介](#简介)\r\n    - [盒子模型各组成部分的设置](#盒子模型各组成部分的设置)\r\n      - [内容区域content](#内容区域content)\r\n      - [内边距区域padding](#内边距区域padding)\r\n      - [边框区域border](#边框区域border)\r\n      - [外边距区域margin](#外边距区域margin)\r\n    - [盒子模型的外边距margin的合并问题](#盒子模型的外边距margin的合并问题)\r\n    - [盒子模型的外边距margin的塌陷问题](#盒子模型的外边距margin的塌陷问题)\r\n    - [盒子模型行内元素的padding和margin问题](#盒子模型行内元素的padding和margin问题)\r\n    - [盒子模型实现指定尺寸的方法](#盒子模型实现指定尺寸的方法)\r\n    - [清除默认内外边距](#清除默认内外边距)\r\n    - [margin和text-align实现水平居中的区别](#margin和text-align实现水平居中的区别)\r\n    - [案例实现](#案例实现)\r\n      - [新浪首页导航条实例编写](#新浪首页导航条实例编写)\r\n      - [新闻列表案例实现](#新闻列表案例实现)\r\n  - [盒子阴影属性](#盒子阴影属性)\r\n  - [背景](#背景)\r\n    - [颜色的几种表示方式](#颜色的几种表示方式)\r\n    - [背景颜色属性](#背景颜色属性)\r\n    - [背景图片](#背景图片)\r\n    - [背景图片重复方式](#背景图片重复方式)\r\n    - [背景图片位置](#背景图片位置)\r\n    - [背景复合属性](#背景复合属性)\r\n    - [背景图大小](#背景图大小)\r\n    - [img标签和背景图片区别](#img标签和背景图片区别)\r\n  - [元素(html标签)显示模式](#元素html标签显示模式)\r\n    - [块级元素](#块级元素)\r\n    - [行内元素](#行内元素)\r\n    - [行内块元素](#行内块元素)\r\n    - [css元素属性控制显示模式的相互转换](#css元素属性控制显示模式的相互转换)\r\n  - [css三大特性](#css三大特性)\r\n    - [继承性](#继承性)\r\n    - [层叠性](#层叠性)\r\n    - [优先级](#优先级)\r\n      - [多个基本选择器之间的的优先级](#多个基本选择器之间的的优先级)\r\n      - [多个复合选择器之间的优先级的权重的计算](#多个复合选择器之间的优先级的权重的计算)\r\n  - [标准流](#标准流)\r\n    - [标准流的概念](#标准流的概念)\r\n    - [标准流的局限性](#标准流的局限性)\r\n  - [浮动](#浮动)\r\n    - [浮动的作用](#浮动的作用)\r\n    - [浮动的特点](#浮动的特点)\r\n    - [浮动布局案例1实现](#浮动布局案例1实现)\r\n    - [浮动布局案例2实现(小米产品页)](#浮动布局案例2实现小米产品页)\r\n    - [浮动布局案例3实现(网页导航条)](#浮动布局案例3实现网页导航条)\r\n    - [清除浮动](#清除浮动)\r\n      - [设置行高法](#设置行高法)\r\n      - [添加额外标签清除法；](#添加额外标签清除法)\r\n      - [单伪元素清除法](#单伪元素清除法)\r\n      - [双伪元素清除法](#双伪元素清除法)\r\n      - [overflow属性清除](#overflow属性清除)\r\n  - [去除列表默认符号](#去除列表默认符号)\r\n  - [定位](#定位)\r\n    - [网页常见布局方式](#网页常见布局方式)\r\n    - [定位的使用步骤](#定位的使用步骤)\r\n    - [相对定位](#相对定位)\r\n    - [绝对定位](#绝对定位)\r\n      - [绝对定位的居中](#绝对定位的居中)\r\n    - [绝对定位fixed](#绝对定位fixed)\r\n    - [修改定位元素的层级关系](#修改定位元素的层级关系)\r\n      - [元素的层级关系](#元素的层级关系)\r\n      - [z-index](#z-index)\r\n  - [文字的垂直对齐](#文字的垂直对齐)\r\n    - [概念](#概念)\r\n    - [行内块元素的基线、底线、顶线、中线的概念](#行内块元素的基线底线顶线中线的概念)\r\n    - [实测效果](#实测效果)\r\n    - [文本框和按钮的中线对齐](#文本框和按钮的中线对齐)\r\n    - [图片和按钮框的中线对齐](#图片和按钮框的中线对齐)\r\n    - [嵌套关系的div和文本框的顶对齐](#嵌套关系的div和文本框的顶对齐)\r\n    - [嵌套关系的div和img的中线对齐](#嵌套关系的div和img的中线对齐)\r\n      - [情形1](#情形1)\r\n      - [情形2](#情形2)\r\n    - [该属性的其他属性值](#该属性的其他属性值)\r\n  - [鼠标光标类型](#鼠标光标类型)\r\n  - [圆角边框](#圆角边框)\r\n  - [溢出内容显示效果](#溢出内容显示效果)\r\n  - [元素的隐藏](#元素的隐藏)\r\n  - [透明属性](#透明属性)\r\n  - [过渡](#过渡)\r\n  - [去除鼠标选中input-text后显示的默认边框](#去除鼠标选中input-text后显示的默认边框)\r\n  - [css3的书写顺序](#css3的书写顺序)\r\n    - [编写思路](#编写思路)\r\n    - [使浏览器加载更快的书写顺序](#使浏览器加载更快的书写顺序)\r\n    - [正确书写顺序使浏览器加载更快的原因](#正确书写顺序使浏览器加载更快的原因)\r\n  - [html嵌套原则](#html嵌套原则)\r\n  - [vscode的emment插件语法（自带插件）](#vscode的emment插件语法自带插件)\r\n  - [pxcook像素大厨的基本使用](#pxcook像素大厨的基本使用)\r\n\r\n\r\n## css简介\r\n* CSS: **Cascading Style sheets 层叠样式表**\r\n* 注释格式: `/* css的唯一注释格式 */`\r\n* 语法格式: `选择器{属性:属性值;}`\r\n\r\n## 引入方式\r\n- [内嵌式](#内嵌式)\r\n- [外联式](#外联式)\r\n- [行内式](#行内式)\r\n\r\n### 内嵌式\r\n* 写在style标签中\r\n* 虽然style标签可以写在任意位置，但**一般约定style标签写在head标签中的title标签下**\r\n    ```html\r\n    <head>\r\n        <title>Document</title>\r\n        <style>\r\n            p{  \r\n                color: red;\r\n                background-color: green;\r\n                font-size: 30px;\r\n                width: 500px;\r\n                height: 500px;\r\n            }\r\n        </style>\r\n        <link rel=\"stylesheet\" href=\"path/to/file.css\">\r\n    </head>\r\n    ```\r\n* 使用场景：小案例\r\n* 作用范围：**当前页面**\r\n    \r\n### 外联式\r\n* 写在一个单独的.css文件中\r\n* 需要用link标签引入\r\n    ```html\r\n    <!-- rel=>relation关系 stylesheet指定是css-->\r\n    <!-- href=>路径 -->\r\n        <link rel=\"stylesheet\" href=\"path/to/file.css\">\r\n    ```\r\n* 使用场景：大项目\r\n* 作用范围：**多个页面**\r\n    \r\n### 行内式\r\n* 直接写到标签的style属性中\r\n    ```html\r\n        <p style=\"color: white;\">qqq</p>\r\n    ```\r\n* 使用场景：一般配合js使用\r\n* 作用范围：**仅单个标签**\r\n\r\n## 选择器\r\n- [标签选择器](#标签选择器)\r\n- [类选择器](#类选择器)\r\n- [id选择器](#id选择器)\r\n- [通配符选择器](#通配符选择器)\r\n- [后代选择器](#后代选择器)\r\n- [子代选择器](#子代选择器)\r\n- [并集选择器](#并集选择器)\r\n- [交集选择器](#交集选择器)\r\n- [伪类选择器](#伪类选择器)\r\n- [结构伪类选择器](#结构伪类选择器)\r\n- [伪html元素选择器](#伪html元素选择器)\r\n\r\n\r\n### 标签选择器\r\n* 语法：`标签名{css属性名:属性值;}`\r\n* 特点：匹配到所有标签，无论嵌套关系多深\r\n\r\n\r\n### 类选择器\r\n* 语法：`.类名值{css属性名:属性值;}`\r\n* 特点：只作用于标签属性中`class=\"指定类名\"`的所有标签\r\n* 注意：\r\n    * 所有标签都可以有class属性\r\n    * **类名只能以数字字母下划线中划线组成且不能以数字或中划线开头。**\r\n    * 一个标签可有有多个类名`<div class=\"c1 c2\"></div>`\r\n    * 一个类选择器也可以选中多个类`.类名1 .类名2{css属性名:属性值;}`\r\n\r\n\r\n### id选择器\r\n* 语法：`#id属性值{css属性名:属性值;}`\r\n* 特点：只唯一作用于id属性为指定值的标签\r\n* 注意：\r\n    * 所有HTML标签都可以有id属性\r\n    * **id属性值只能以数字字母下划线中划线组成且不能以数字或中划线开头。**\r\n    * 按规定id属性值在单个页面中是唯一的\r\n    * 一个标签只能有一个id属性值\r\n    * 一个id选择器只能选中一个标签\r\n    * id选择器一般配合js使用\r\n\r\n\r\n### 通配符选择器\r\n* 语法：`*{css属性名:属性值;}`\r\n* 特点：作用于所有标签\r\n* 用法：清除标签的默认样式\r\n    * margin外边距 如h1标签就有默认外边距\r\n    * padding内边距\r\n    ```css\r\n    *{\r\n        margin:0;\r\n        padding:0;\r\n    }\r\n    ```\r\n\r\n### 后代选择器\r\n* 语法: `选择器1 选择器2{css属性名:属性值;}`\r\n* 特点：选择器之间用**空格**隔开\r\n* 注意：\r\n    * **后代包括 子代 孙代 重孙代**\r\n    * 单个选择器可以是上面四种基本选择器\r\n    * 可以跨代选择\r\n\r\n### 子代选择器\r\n* 语法：`选择器1>选择器2{css属性名:属性值;}`\r\n* 特点：选择器之间用 **>** 隔开\r\n* 注意：\r\n    * **子代选择器只能选择子代 不能选择孙代**\r\n\r\n### 并集选择器\r\n* 语法：`选择器1,选择器2{css属性名:属性值;}`\r\n* 特点：选择器之间用**逗号**隔开\r\n* 注意：\r\n    * **并集选择器中的单个选择器可以是上面两种复合选择器**\r\n    * **单个选择器可以一行写一个提高代码可读性**\r\n\r\n### 交集选择器\r\n* 语法 `选择器1选择器2{}`\r\n* 特点：交集选择器选择的是满足要求的一类标签 交集可能是空 可能有一个 可能有多个\r\n* 4种基本选择器两两排列组合的示例：\r\n    * 标签和类名的交集：`p.class1{}`\r\n    * 标签和id的交集`p#id1{}`\r\n    * 标签和通配符的交集：`p*{}` `*p{} `\r\n        * 似乎没有什么应用场景 *和p的交集就是p\r\n    * 类名和id的交集： `.class1#id1{}` `#id1.class1{}`\r\n    * 类和通配符的交集：`.class1*{}` `*.class1{}`\r\n        * 似乎没有什么应用场景 *和class1的交集就是class1\r\n    * id和通配符的交集：`#id1*{}` `*#id1{}`\r\n        * 同上；*和#id1的交集就是#id1\r\n* 注意：\r\n    * **交集选择器能且只能交两个基本选择器**\r\n    * 交集选择器的两个选择器一定是对两个不同HTML的标签选择器做交集 所以不要问h1和p的交集怎么写 不要问`h1p{}`这种写法浏览器能不能识别（你说你没问？好吧我问的...），这两个标签不可能有交集 但是类和类可以有交集`.class1.class2{}`这种写法浏览器能识别 `#id1#id2{}`这种写法浏览器也能识别\r\n    * 因为统配符选择器和任何选择器的交集都是这个选择器本身，所以实际中应该用不到\r\n\r\n### 伪类选择器\r\n* hover\r\n    * 语法：`选择器:hover{}`\r\n    * 作用：设置鼠标悬停在标签上时显示的样式\r\n    * 注意：任何标签都有伪类hover\r\n\r\n### 结构伪类选择器\r\n* 作用：根据HTML的元素结构关系查找元素\r\n* 优势：减少对HTML中类的依赖，利于代码整洁\r\n* 场景：常用于查找某父级选择器中的子元素\r\n* 语法：\r\n    * `选择器:first-child{}` 第一个元素\r\n    * `选择器:last-child{}` 最后一个元素\r\n    * `选择器:nth-child(n){}` 第n个的元素\r\n    * `选择器:nth-last-child(n){}` 最后第n个元素\r\n    * n的取值\r\n        * 数字：0、1、2、3.... (0会选不中任何元素)\r\n        * 公式：\r\n            * 偶数 `2n`  `even`\r\n            * 奇数 `2n+1` `2n-1` `odd`\r\n            * 前3个 `3-n`\r\n                * （n取0时得3 取1时得2 取2时得1 取3时的0 取4时得-1 以此类推 感觉可理解为是在一个for循环中n从0开始取值，公式就是元素下标要填写的内容）\r\n            * 后3个 `3+n`\r\n* 注意：\r\n    * 对于左浮动，要用last-child选中最后(右)一个元素\r\n    * 对于右浮动，要用first-child选中最后(左)一个元素\r\n```html\r\n<style>\r\n    li:first-child{\r\n        background-color: gold;\r\n    }\r\n    li:nth-child(2){\r\n        background-color: darkgrey;\r\n    }\r\n    .li-example:nth-child(3){\r\n        background-color: chocolate;\r\n    }\r\n</style>\r\n<ul>\r\n    <li class=\"li-example\">这是第1个li</li>\r\n    <li class=\"li-example\">这是第2个li</li>\r\n    <li class=\"li-example\">这是第3个li</li>\r\n    <li class=\"li-example\">这是第4个li</li>\r\n    <li class=\"li-example\">这是第5个li</li>\r\n</ul>\r\n\r\n```\r\n效果：![](./images/CSS3重学笔记/2022-06-08-10-37-10.png)\r\n\r\n\r\n### 伪html元素选择器\r\n* 伪元素是`CSS3`模拟出的HTML标签效果\r\n* 伪元素的`CSS`样式必须要有`content`属性,属性值可以为空(`content:\"\";`)\r\n* 伪元素默认是**行内元素(inline-block)**\r\n* 语法：\r\n    * `选择器::before{}` 在选中元素的内容的最开头添加的伪元素\r\n    * `选择器::after{}` 在选中元素的内容的最后添加的伪元素\r\n\r\n\r\n\r\n## 字体样式\r\n- [字体样式](#字体样式)\r\n    - [字体的大小属性](#字体的大小属性)\r\n    - [字体的粗细属性](#字体的粗细属性)\r\n    - [字体的倾斜属性](#字体的倾斜属性)\r\n    - [字体的family字体属性](#字体的family字体属性)\r\n    - [字体的复合属性](#字体的复合属性)\r\n    - [文字阴影属性](#文字阴影属性)\r\n\r\n### 字体的大小属性\r\n* 属性名：`font-size`\r\n* 取值：`数字+px`\r\n* 注意：\r\n    * 谷歌浏览器默认文字大小16px\r\n    * 必须加单位否则没有效果\r\n\r\n### 字体的粗细属性\r\n* 属性名：`font-weight`\r\n* 取值：\r\n    * 取关键字：\r\n        * `normal` 正常不加粗（默认）\r\n        * `bold`  加粗\r\n    * 取数字：\r\n        * 取`100~900`的整百数 *共九种取值*\r\n        * `400` 效果对应 `normal`\r\n        * `700` 效果对应 `bold`\r\n    * 注意：\r\n        * 并不是所有`字体`都有九种粗细\r\n        * 实际开发中主要用 `正常` 和 `加粗` 两种取值\r\n\r\n### 字体的倾斜属性\r\n* 属性名：font-style\r\n* 取值：\r\n    * normal 正常不倾斜（默认）\r\n    * italic 倾斜\r\n        * italic作形容词时译为“斜体的；仿意大利古书写体的”，作名词时译为“斜体字”\r\n* 所以可以用该属性把斜体标签变不倾斜`<em style=\"font-style:normal\">ggg</em>`\r\n\r\n### 字体的family字体属性\r\n* 属性名：`font-family`\r\n* 取值格式：`font-family:字体名1,字体名2,字体名3,字体系列名;`\r\n* 取值：\r\n    * `微软雅黑` windows默认\r\n    * `苹方` macOS默认\r\n    * 等...\r\n* 扩展：网页中一般采用**无衬线字体(sans-serif)**\r\n    * ![](./images/CSS3重学笔记/2022-06-05-08-41-07.png)\r\n* 示例：\r\n    ```css\r\n    div{\r\n        /* 按优先级选择可用的字体，如果没有两种字体都没有则使用任意一种无衬线字体(sans-serif) */ \r\n        font-family:微软雅黑,黑体,sans-serif;\r\n    }\r\n    ```\r\n\r\n### 字体的复合属性\r\n* 属性名：`font`\r\n* 取值格式：font:style weight size family;\r\n    * 示例：`font: italic bold 16px 微软雅黑;`\r\n* 这个属性只能省略前两个值，省略表示设置为默认值\r\n* 这种一个属性后有多个值的称为复合属性\r\n\r\n## 文本样式\r\n- [文本样式](#文本样式)\r\n    - [文本缩进属性](#文本缩进属性)\r\n    - [文本水平对齐方式属性](#文本水平对齐方式属性)\r\n    - [文本修饰线属性](#文本修饰线属性)\r\n    - [文本行高属性](#文本行高属性)\r\n    - [文字阴影属性](#文字阴影属性)\r\n\r\n### 文本缩进属性\r\n* 属性名`text-indent`\r\n* 取值：\r\n    * `数字+px`\r\n    * `数字+em` (推荐)\r\n        * `1em`=当前标签的`font-size`大小\r\n\r\n### 文本水平对齐方式属性\r\n* 属性名`text-align`\r\n* 取值\r\n    * `left`\r\n    * `center`\r\n    * `right`\r\n* 注意\r\n    * 可以作用于该标签的内容 不光是作用于文字\r\n    * 要让`img`这种单标签居中 需要设置其父元素的`text-indent`属性\r\n\r\n### 文本修饰线属性\r\n* 属性名：`text-decoration`\r\n* 取值：\r\n    * `underline` 下划线\r\n    * `line-through` 删除线\r\n    * `overline` 上划线\r\n    * `none` 无装饰线\r\n* 注意：\r\n    * 开发中会用`text-decoration:none`清除超链接的下划线\r\n\r\n\r\n### 文本行高属性\r\n* 属性名：`line-height`\r\n* 取值：\r\n    * 数字+px\r\n    * 倍数可以是小数 （当前标签的font-size的倍数）\r\n* 可以写到font中\r\n    * 格式：`font: [style weight] size[/line-height] family;`\r\n    * 示例：`font: italic 700 66px/2 微软雅黑;`\r\n* 行高![](./images/CSS3重学笔记/2022-06-05-12-38-53.png)\r\n\r\n### 文字阴影属性\r\n* 属性名：`text-shadow`\r\n* 语法 `text-shadow: 水平偏移px 垂直偏移px 模糊程度px 颜色;`\r\n* 取值：\r\n    * 水平偏移h-shadow 必须\r\n    * 垂直偏移x-shadow 必须\r\n    * 模糊程度blur 模糊的程度 可选\r\n    * 颜色color 阴影颜色 可选\r\n* 示例效果：\r\n    * ![](./images/CSS3重学笔记/2022-06-12-15-25-18.png)\r\n    * ![](./images/CSS3重学笔记/2022-06-12-15-38-06.png)\r\n    * ![](./images/CSS3重学笔记/2022-06-12-15-38-14.png)\r\n* js语法:`object.style.textShadow=\"2px 2px #ff0000\"`\r\n\r\n\r\n### 文字外边框\r\n语法: `text-stroke：[ text-stroke-width ] || [ text-stroke-color ]`\r\n\r\n## 盒子模型\r\n- [简介](#简介)\r\n- [盒子模型各组成部分的设置](#盒子模型各组成部分的设置)\r\n    - [内容区域content](#内容区域content)\r\n    - [内边距区域padding](#内边距区域padding)\r\n    - [边框区域border](#边框区域border)\r\n    - [外边距区域margin](#外边距区域margin)\r\n- [盒子模型的外边距margin的合并问题](#盒子模型的外边距margin的合并问题)\r\n- [盒子模型的外边距margin的塌陷问题](#盒子模型的外边距margin的塌陷问题)\r\n- [盒子模型行内元素的padding和margin问题](#盒子模型行内元素的padding和margin问题)\r\n- [盒子模型实现指定尺寸的方法](#盒子模型实现指定尺寸的方法)\r\n- [清除默认内外边距](#清除默认内外边距)\r\n- [margin和text-align实现水平居中的区别](#margin和text-align实现水平居中的区别)\r\n- [案例实现](#案例实现)\r\n    - [新浪首页导航条实例编写](#新浪首页导航条实例编写)\r\n    - [新闻列表案例实现](#新闻列表案例实现)\r\n\r\n### 简介\r\n* css中规定每个盒子分别由\r\n    * **内容区域content**，\r\n    * **内边距区域padding**，\r\n    * **边框区域border**，\r\n    * **外边距区域margin**构成 这就是**盒子模型**\r\n* 页面中每一个标签都可看作是一个盒子，方便布局\r\n* 浏览器渲染时将网页中元素看成矩形区域，我们形象的称为盒子\r\n![](./images/CSS3重学笔记/2022-06-07-12-11-21.png)\r\n![](./images/CSS3重学笔记/2022-06-07-13-30-00.png)\r\n![](./images/CSS3重学笔记/2022-06-07-13-39-11.png)\r\n\r\n### 盒子模型各组成部分的设置\r\n#### 内容区域content\r\n* 通过width height属性控制，单位px\r\n\r\n#### 内边距区域padding\r\n* 通过padding属性控制\r\n* 语法格式：\r\n    * `padding: 上 右 下 左;`\r\n    * `padding: 上 左右 下;`\r\n    * `padding: 上下 左右;`\r\n    * `padding: 上下左右边距;`\r\n    * 上述四种写法的规律就是，从上开始顺时针依次赋值，没有赋到值的就看其对面的值\r\n\r\n#### 边框区域border\r\n* 通过border属性控制\r\n    * 这是一个复合属性\r\n    * 属性值**不分先后顺序**，**任意一个都不能省略**\r\n    * 语法1：`border:宽度 线条种类 颜色;`\r\n        * 宽度：数字+px\r\n        * 线条种类 solid实线 dashed虚线 dotted点线\r\n    * 语法2：`border-方位名词:宽度 线条种类 颜色;`\r\n        * 方位名词： \r\n            * `top`\r\n            * `bottom` \r\n            * `left` \r\n            * `right`\r\n    * 语法3(不常用)：\r\n        * `border-width:宽度;` \r\n        * `border-style:线条种类;` \r\n        * `border-color:颜色;`\r\n    * 语法4(不常用)：\r\n        * `border-width:上宽度 右宽度 下宽度 左宽度;` \r\n        * `border-style:上线条种类 右线条种类 下线条种类 左线条种类;`\r\n        *  `border-color:上颜色 右颜色 下颜色 左颜色;`\r\n\r\n#### 外边距区域margin\r\n* 通过`margin`属性控制\r\n* 语法格式同padding\r\n*版心居中：`margin:0 auto; `\r\n    版心：网页中的有效内容\r\n\r\n### 盒子模型的外边距margin的合并问题\r\n* **垂直布局**和**块级元素**，上盒子的下外边距会和下盒子的上外边距外边距同时设置，浏览器会自动取最大值。\r\n![](./images/CSS3重学笔记/2022-06-08-09-28-53.png)\r\n* 解决方法：只设置其中一个\r\n\r\n### 盒子模型的外边距margin的塌陷问题\r\n* **嵌套**的**块级元素**，子元素的margin-top会作用在父元素上\r\n![](./images/CSS3重学笔记/2022-06-08-09-56-12.png)\r\n* 解决方法\r\n    * 给父元素设置`border-top` 或 `padding-top` 可以达到预期效果\r\n    * 给父元素设置`overflow:hidden;` (应该是最优解)\r\n    * 转换成行内块元素`inline-block`\r\n    * 设置浮动\r\n    * 等...\r\n\r\n### 盒子模型行内元素的padding和margin问题\r\n* 对行内元素应用margin属性时，只有设置的左右外边距会起作用\r\n* 对行内元素应用padding属性时，只有设置的左右内边距会起作用\r\n* 解决方法：使用`line-height`属性设置\r\n* 总结：行内元素无法设置上下外边距和内边距，可以通过`line-height`设置\r\n\r\n\r\n### 盒子模型实现指定尺寸的方法\r\n* 一般情况下盒子整体尺寸会因border、padding的设置而被撑大，如设置width500px;border10px;padding10px;则整个盒子的宽度会从500px变成540px。\r\n* 解决方法1手动计算content的宽高\r\n    * 如果想要设置整体宽度width500px，border10px，padding10px，则应该设置width为500-10\\*2-10\\*2=460px\r\n* 解决方法2自动计算content的宽高\r\n    * 给盒子设置`box-sizing:border-box;`(**内减模式**)\r\n    * 浏览器会自动计算多出的大小，自动从content的width，height属性中减去\r\n\r\n\r\n### 清除默认内外边距\r\n* body标签默认有margin8px\r\n* p标签默认有上下margin\r\n* ul标签默认有margin和padding-left\r\n```css\r\n*{\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\n```\r\n\r\n### margin和text-align实现水平居中的区别\r\n* `text-align` 指当前元素中内容的对其方式。\r\n    * 写法：`text-align:center;`\r\n    * 应用于**块级元素**\r\n* `margin` 是指当前元素的外边距 而当指定其上下外边距为0 左右外边距为自动时 表现为相对于父标签居中，**不会影响自身的内容**\r\n    * 写法：`margin:0px auto;`\r\n    * 应用于**块级元素**\r\n    * * 当元素设置为浮动时，左右`margin`设置为`auto`来居中元素的方式会失效\r\n\r\n### 案例实现\r\n#### 新浪首页导航条实例编写\r\n```html\r\n<style>\r\n    .nav{\r\n        width: 100%;\r\n        height: 40px;\r\n        border-top: 3px solid #ff8500;\r\n        border-bottom: 1px solid #edeef0;\r\n        background-color: white;\r\n    }\r\n    .nav-item{\r\n        width:auto;\r\n        height: 40px;\r\n        background-color: white;\r\n        display: inline-block;\r\n        text-decoration: none;\r\n        text-align: center;\r\n        color: #4c4c4c;\r\n        font-size: 12px;\r\n        line-height: 40px;\r\n        padding: 0 5px 0 5px;\r\n    }\r\n    .nav-item:hover{\r\n        background-color: #edeef0;\r\n        color: #ff8400;\r\n    }\r\n</style>\r\n<div class=\"nav\">\r\n    <a href=\"#\" class=\"nav-item\">首页</a>\r\n    <a href=\"#\" class=\"nav-item\">文字个数不应影响效果</a>\r\n    <a href=\"#\" class=\"nav-item\">新浪导航</a>\r\n    <a href=\"#\" class=\"nav-item\">新浪导航</a>\r\n</div>\r\n```\r\n**效果：**\r\n![](./images/CSS3重学笔记/2022-06-08-18-46-27.png)\r\n\r\n\r\n#### 新闻列表案例实现\r\n```html\r\n<style>\r\n    .news-Box *{\r\n        margin: 0;\r\n        padding: 0;\r\n        /* 所有标签自动内减内边距和border */\r\n        box-sizing: border-box;\r\n    }\r\n    .news-Box{\r\n        width: 500px;\r\n        height: 400px;\r\n        background-color: white;\r\n        border:1px solid #ccc;\r\n        padding: 20px 30px 0px;\r\n        margin: 50px auto;\r\n    }\r\n    .news-title{\r\n        border-bottom: 1px solid #ccc;\r\n        font-size: 30px;\r\n        line-height: 1;/*1倍字的大小，这样可以去除字的上下边距*/\r\n        padding: 10px 0;\r\n        color: black;\r\n    }\r\n    .news-items{\r\n        list-style: none;\r\n    }\r\n    .news-item{\r\n        height: 50px;\r\n        border-bottom: 1px dashed #ccc;\r\n        font-size: 20px;\r\n        line-height: 50px;\r\n        padding: 0 25px;\r\n    }\r\n    .news-item-link{\r\n        text-decoration: none;\r\n        color: #666;\r\n    }\r\n</style>\r\n<body>\r\n    <div class=\"news-Box\">\r\n        <h2 class=\"news-title\">最新文章/News</h2>\r\n        <ul class=\"news-items\">\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n        </ul>\r\n    </div>\r\n</body>\r\n\r\n```\r\n效果：\r\n![](./images/CSS3重学笔记/2022-06-08-18-46-54.png)\r\n\r\n## 盒子阴影属性\r\n* 语法格式：`box-shadow:水平偏移px 垂直偏移px 模糊度px 阴影尺寸px inset(内阴影); `\r\n![](./images/CSS3重学笔记/2022-06-12-16-03-13.png)\r\n\r\n## 背景\r\n- [背景](#背景)\r\n    - [颜色的几种表示方式](#颜色的几种表示方式)\r\n    - [背景颜色属性](#背景颜色属性)\r\n    - [背景图片](#背景图片)\r\n    - [背景图片重复方式](#背景图片重复方式)\r\n    - [背景图片位置](#背景图片位置)\r\n    - [背景复合属性](#背景复合属性)\r\n    - [背景图大小](#背景图大小)\r\n    - [img标签和背景图片区别](#img标签和背景图片区别)\r\n\r\n\r\n### 颜色的几种表示方式\r\n* **关键字** `red` `green` `blue` `yellow` ...\r\n* **rgb表示法**\r\n    * 示例`rgb(255,255,255)`\r\n* **rgba表示法**\r\n    * `rgb`的取值范围0~255 \r\n    * a表示透明度;取值范围0~1 小数表示法 可以省略整数部分0.5写.5\r\n    * 示例`rgba(255,255,255,0.5)`\r\n* **十六进制表示法**\r\n    * `#ffffff`\r\n    * `#fff` 简写\r\n        * 注意是两位一组 其中一组中数字相同的才能简写 于是`#ff0066`可以写成`#f06`\r\n\r\n\r\n\r\n### 背景颜色属性\r\n* 属性名：`background-color`\r\n* 取值：`颜色名关键字` 、 `rgb` `rgba` `#十六进制`\r\n* 注意\r\n    * 背景色默认为透明\r\n        * `transparent`\r\n        * `rgba(XX,XX,XX,0)`\r\n    * 开发时可以设置背景色 辅助观察和理解元素间的尺寸和层叠关系\r\n\r\n### 背景图片\r\n* 属性名：`background-image`\r\n* 取值：`url(\"\")`\r\n* 示例：`background-image:url(\"./path/to/your/file.img\")`\r\n* 注意：\r\n    * `url`中可以用单引号 双引号 也可以都不用\r\n    * 图片为默认重复方式为水平和垂直方向重复（由如下属性控制）\r\n\r\n### 背景图片重复方式\r\n* 属性名：`background-repeat`\r\n* 取值：\r\n    * `repeat`  水平和垂直方向重复 （默认）\r\n    * `no-repeat` 不重复\r\n    * `repeat-x` 仅沿x轴重复\r\n    * `repeat-y` 仅沿y轴重复\r\n\r\n### 背景图片位置\r\n* 属性名：`background-position`\r\n* 使用格式：`background-position:水平方向 垂直方向;`\r\n* 取值：\r\n    * 取方位名词关键字 \r\n        * 水平： `right` `center` `left`\r\n        * 垂直： `top` `center` `bottom`\r\n    * 取坐标：\r\n        * 左上角为原点\r\n        * 水平方向坐标轴的增长方向为朝右\r\n        * 垂直方向坐标轴的增长方向为朝下\r\n        * 取具体数值+px 可以取负数表示反方向\r\n* 注意：\r\n    * 两种取值方式 可以混合使用\r\n    * `background-position:center center;`可以简写成`background-position:center;`\r\n\r\n### 背景复合属性\r\n* 属性名： `background`\r\n* 标准书写格式：`background:color image repeat position`\r\n* 注意：\r\n    * 四个取值不分先后顺序、随意省略\r\n    * 最后一个取值`position`其实由两个值组成，分为水平方向和垂直方向，当取关键字时可以颠倒顺序，当取数值时不能颠倒顺序\r\n    * 所以当盒子大小和背景图片一致时可直接简写为`background: url();`\r\n\r\n### 背景图大小\r\n* 语法: `background-size:宽度 高度;`\r\n* 取值：\r\n    * 像素，数字+px\r\n    * 百分比，相对于当前盒子的宽高\r\n    * 包含 `contain` ，将背景图**等比例缩放**，直到某条边或框和盒子一致\r\n    * 覆盖 `cover` 将图片**等比例缩放**，直到刚好填满整个盒子\r\n* 可以连写到`background`属性中，语法为`background:color image repeat position/size;`\r\n* 效果示例\r\n    * ![](./images/CSS3重学笔记/2022-06-12-14-45-00.png)\r\n    * ![](./images/CSS3重学笔记/2022-06-12-14-45-55.png)\r\n\r\n\r\n### img标签和背景图片区别\r\n* `img`是一个HTML标签。不设置宽高以原尺寸显示；设置单个宽高图片以等比例缩放显示；同时设置宽高图片以不等比例缩放显示。\r\n* `background-img`是CSS样式。可以设置给div标签，但div必须设置宽高，如果不设置什么都不显示\r\n* 选用原则：**重要的用img 不重要的装饰性的用背景图**\r\n\r\n\r\n\r\n## 元素(html标签)显示模式\r\n- [块级元素](#块级元素)\r\n- [行内元素](#行内元素)\r\n- [行内块元素](#行内块元素)\r\n- [css元素属性控制显示模式的相互转换](#css元素属性控制显示模式的相互转换)\r\n\r\n### 块级元素\r\n* 特点\r\n    * **独占一行**\r\n    * **可以**设置宽高\r\n    * 宽度默认继承自父级元素\r\n* 代表元素： **div** **h系列** **p**  ul li dl dt dd form header nav footer\r\n\r\n### 行内元素\r\n* 特点\r\n    * **一行显示多个**\r\n    * **不可以**设置宽高(不生效)\r\n    * 宽度和高度默认由内容撑开\r\n* 代表元素\r\n    * **span** **a** b u i s strong ins em del\r\n\r\n### 行内块元素\r\n* 特点\r\n    * **一行可以显示多个**\r\n    * **可以**设置宽高\r\n* 代表标签\r\n    * **img** **input** textarea button select ...\r\n* 注意 img标签有行内块特点 但在Chrome调试工具中显示是inline\r\n\r\n### css元素属性控制显示模式的相互转换\r\n* 属性名：display\r\n* 可选值：\r\n    * **block** 块级元素 块元素**可以设置宽高** 使用频率**多**\r\n    * **inline** 行内元素 行内元素不可以设置宽高 使用频率少\r\n    * **inline-block** 行内块元素 行内块**可以设置宽高** 使用频率**多**\r\n\r\n## css三大特性\r\n- [继承性](#继承性)\r\n- [层叠性](#层叠性)\r\n- [优先级](#优先级)\r\n    - [多个基本选择器之间的的优先级](#多个基本选择器之间的的优先级)\r\n    - [多个复合选择器之间的优先级的权重的计算](#多个复合选择器之间的优先级的权重的计算)\r\n\r\n### 继承性\r\n* 子元素默认继承父元素\r\n* 自己有相关属性的不再从父元素继承\r\n    * a标签的文字颜色和下划线是浏览器给的默认颜色，不再从父元素继承。\r\n    * h标签的大小是默认属性，不再从父元素继承。\r\n* **只有文字控制属性才存在继承**\r\n* 如：\r\n    * color文字颜色 \r\n    * font系列（font-style font-weight font-size font-family）\r\n    * text系列（text-indent text-align）\r\n    * line-height行高\r\n    * 等\r\n\r\n### 层叠性\r\n* 给标签设置不同的属性，样式会**叠加**\r\n    * 样式叠加：`div{color:red;font-size:10px;}`\r\n* 给标签设置相同的属性，样式会**覆盖**，覆盖的原则为先写的被后写的覆盖\r\n    * 最终为绿色：`div{color:red;color:green;}`\r\n* 样式冲突时，只有当选择器**优先级相同**时才能通过层叠性判断结果\r\n    * 大概解释成，单个选择器内的样式冲突时，可以根据层叠性判断，多个选择器之间样式冲突时，必须要优先级相同才能根据层叠性判断。\r\n\r\n### 优先级\r\n#### 多个基本选择器之间的的优先级\r\n* 不同的选择器有不同的优先级\r\n* 优先级高的选择器样式**覆盖**优先级低的选择器样式\r\n* 优先级关系\r\n    * `继承<标签选择器<通配符选择器<类选择器<id选择器<行内样式<!important`\r\n    * 作用范围广的选择器优先级低\r\n    * 作用范围精确的选择器优先级高\r\n* 注意：\r\n    * `!important`写在属性值之后分号之前\r\n    * `!important`无法被继承\r\n    * 实际开发中不建议使用`!important`\r\n* 示例：最终颜色为pink![](./images/CSS3重学笔记/2022-06-07-10-52-21.png)\r\n\r\n#### 多个复合选择器之间的优先级的权重的计算\r\n* 如果使用复合选择器，需通过叠加计算方法，判断最终哪个选择器的优先级最高,优先级高的覆盖优先级低的。\r\n* 叠加公式：![](./images/CSS3重学笔记/2022-06-07-08-17-55.png)\r\n* 先比较各复合选择器优先级的第一级，值最大的选择器的优先级最高，如果无法得出最大值\r\n* 再比较各复合选择器优先级的第二级，值最大的选择器的优先级最高，如果无法得出最大值，以此类推\r\n* **如果都比较不出来，再根据层叠性确定**\r\n* **!inportant**优先级依然是最高\r\n+ 计算权重优先复合选择器的优先级的权重计算**示例**：\r\n    + 最终字的颜色为red![](./images/CSS3重学笔记/2022-06-07-10-25-40.png)\r\n    + 最终显示为天蓝色skyblue![](./images/CSS3重学笔记/2022-06-07-10-26-52.png)\r\n    + 最终为blue蓝色 ![](./images/CSS3重学笔记/2022-06-07-11-15-01.png)![](./images/CSS3重学笔记/2022-06-07-11-13-20.png)\r\n    + 最终为天蓝色![](./images/CSS3重学笔记/2022-06-07-11-11-50.png)\r\n    + 最终为pink![](./images/CSS3重学笔记/2022-06-07-11-17-43.png)![](./images/CSS3重学笔记/2022-06-07-11-18-07.png)\r\n    + 最终为黄色![](./images/CSS3重学笔记/2022-06-07-11-28-54.png)\r\n    + 最终为红色![](./images/CSS3重学笔记/2022-06-07-11-30-41.png)\r\n\r\n\r\n\r\n## 标准流\r\n- [标准流的概念](#标准流的概念)\r\n- [标准流的局限性](#标准流的局限性)\r\n\r\n### 标准流的概念\r\n* **标准流**也称**文档流**，是浏览器**渲染排版**网页的**默认规则**，规定了元素的**排列方式**\r\n* 常见**标准**排版规则\r\n    * `块级block` \r\n        * 独占一行，从上往下，**垂直布局**\r\n    * `行内inline`或`行内块inline-block` \r\n        * 空间不够换行，从左往右，**水平布局**\r\n\r\n### 标准流的局限性\r\n* 无法让多个块级元素显示在一行，\r\n* 无法让行内块元素完美显示在一行（会因为代码的换行而导致显示效果中产生间距）\r\n```html\r\n<style>\r\n    div{\r\n        display: inline-block;\r\n        width: 100px;\r\n        height: 100px;\r\n    }\r\n    .one{\r\n        background-color: pink;\r\n    }\r\n    .two{\r\n        background-color: green;\r\n    }\r\n</style>\r\n<body>\r\n    <div class=\"one\">div1</div>\r\n    <div class=\"two\">div2</div>\r\n</body>\r\n```\r\n* 显示效果：\r\n* ![](./images/CSS3重学笔记/2022-06-08-14-04-59.png)\r\n\r\n## 浮动\r\n- [浮动的作用](#浮动的作用)\r\n- [浮动的特点](#浮动的特点)\r\n- [浮动布局案例1实现](#浮动布局案例1实现)\r\n- [浮动布局案例2实现(小米产品页)](#浮动布局案例2实现小米产品页)\r\n- [浮动布局案例3实现(网页导航条)](#浮动布局案例3实现网页导航条)\r\n- [清除浮动](#清除浮动)\r\n    - [设置行高法](#设置行高法)\r\n    - [添加额外标签清除法；](#添加额外标签清除法)\r\n    - [单伪元素清除法](#单伪元素清除法)\r\n    - [双伪元素清除法](#双伪元素清除法)\r\n    - [overflow属性清除](#overflow属性清除)\r\n\r\n### 浮动的作用\r\n* **早期**用来做图文环绕\r\n    * 在文字中插入图片，然后给图片设置浮动属性\r\n* **现在**用来做网页布局\r\n    * 让多个标准流的块级元素渲染在一行\r\n        ```html\r\n        <style>\r\n            div{\r\n                display: inline-block;\r\n                width: 100px;\r\n                height: 100px;\r\n                float: left;\r\n            }\r\n            .one{\r\n                background-color: pink;\r\n            }\r\n            .two{\r\n                background-color: green;\r\n            }\r\n        </style>\r\n        <body>\r\n            <div class=\"one\">div1</div>\r\n            <div class=\"two\">div2</div>\r\n        </body>\r\n        ```\r\n    * 效果：![](./images/CSS3重学笔记/2022-06-08-14-22-31.png) \r\n\r\n### 浮动的特点\r\n* 浮动元素会**脱离标准流的控制**，简称脱标，在标准流中**不占位置**，其他非浮动元素会占领空出的位置\r\n* 浮动元素比标准流高半个等级，会覆盖标签不会覆盖内容\r\n    ![](./images/CSS3重学笔记/2022-06-08-14-55-38.png)\r\n* 浮动会顶对齐\r\n* 浮动找浮动，下一个浮动元素会在上一个浮动元素左右排列\r\n    ![](./images/CSS3重学笔记/2022-06-08-14-58-44.png)\r\n* 可以用margin控制布局\r\n  ![](./images/CSS3重学笔记/2022-06-08-15-09-04.png)\r\n\r\n\r\n* 浮动后的元素可以设置宽高，能在一行显示，具备行内块特点\r\n\r\n* 浮动后的元素不能通过margin:0 auto;方式居中，\r\n    * 可能是因为这种方式居中的原理是设置上下外边距为0，然后让浏览器根据当前标签的父标签的宽来自动auto计算当前标签的左右外边距实现居中，而当设置为浮动后，元素脱离了标准流，相当于没有父标签了，就没办法自动计算左右外边距了\r\n\r\n\r\n### 浮动布局案例1实现\r\n* 要求使用浮动\r\n    ![](./images/CSS3重学笔记/2022-06-08-15-41-03.png)\r\n* 写bug记录......\r\n    * 设置一个div版心居中时，记住要先给他加宽度，否则默认占父元素宽度的100%\r\n```html\r\n<style>\r\n    .nav{\r\n        height: 40px;\r\n        background-color: #333;\r\n    }\r\n    .head,\r\n    .content{\r\n        margin: 0 auto;\r\n    }\r\n    .head{\r\n        height: 100px;\r\n        width: 1226px;\r\n        background-color: #ffc0cd;\r\n    }\r\n    .content{\r\n        width: 1226px;\r\n        height: 460px;\r\n        background-color: red;\r\n    }\r\n    .left{\r\n        width: 234px;\r\n        height: 460px;\r\n        background-color: #ffa500;\r\n        float: left;\r\n    }\r\n    .right{\r\n        width: 992px;\r\n        height: 460px;\r\n        background-color: #87ceeb;\r\n        float: left;\r\n    }\r\n</style>\r\n<body>\r\n    <div class=\"nav\"></div>\r\n    <div class=\"head\"></div>\r\n    <div class=\"content\">\r\n        <div class=\"left\"></div>\r\n        <div class=\"right\"></div>\r\n    </div>\r\n</body>\r\n```\r\n效果：\r\n![](./images/CSS3重学笔记/2022-06-08-15-40-06.png)\r\n\r\n### 浮动布局案例2实现(小米产品页)\r\n![](./images/CSS3重学笔记/2022-06-08-16-51-05.png)\r\n```html\r\n<style>\r\n    *{\r\n        margin: 0;\r\n        padding: 0;\r\n    }\r\n    .box{\r\n        margin: 0 auto;\r\n        width: 1226px;\r\n        height: 614px;\r\n        background-color: red;\r\n    }\r\n    .left{\r\n        float: left;\r\n        width: 234px;\r\n        height: 614px;\r\n        background-color: #800080;\r\n    }\r\n    .right{\r\n        float: left;\r\n        width: 992px;\r\n        height: 614px;\r\n        background-color: white;\r\n    }\r\n    .item{\r\n        float: left;\r\n        margin: 0 0 14px 14px;\r\n        width: 234px;\r\n        height: 300px;\r\n        background-color: #87ceeb;\r\n    }\r\n    ul{\r\n        list-style: none;\r\n    }\r\n</style>\r\n<div class=\"box\">\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\">\r\n        <ul>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n        </ul>\r\n    </div>\r\n</div>\r\n```\r\n效果：\r\n![](./images/CSS3重学笔记/2022-06-08-16-51-39.png)\r\n\r\n\r\n### 浮动布局案例3实现(网页导航条)\r\n![](./images/CSS3重学笔记/2022-06-08-19-37-18.png)\r\n```html\r\n<style>\r\n    *{\r\n        margin: 0;\r\n        padding: 0;\r\n    }\r\n    .nav{\r\n        width: 640px;\r\n        height: 50px;\r\n        background-color: #ffc0cb;\r\n    }\r\n    .nav li{\r\n        /* 网站的导航条应该用li */\r\n        /* 根据li独占一行的特性判断其为block元素 */\r\n        float: left;\r\n    }\r\n    .nav .item{\r\n        display: block;\r\n        width: 80px;\r\n        height: 50px;\r\n        text-align: center;\r\n        font-size: 16px;\r\n        line-height: 50px;\r\n        color: white;\r\n        text-decoration: none;\r\n    }\r\n    .nav li:hover{\r\n        background-color: #008000;\r\n    }\r\n    ul{\r\n        list-style: none;\r\n    }\r\n</style>\r\n<div class=\"nav\">\r\n    <ul>\r\n        <li><a href=\"#\" class=\"item\">新闻1</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻2</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻3</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻4</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻5</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻6</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻7</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻8</a></li>\r\n    </ul>\r\n</div>\r\n```\r\n效果:\r\n![](./images/CSS3重学笔记/2022-06-08-20-14-11.png)\r\n\r\n### 清除浮动\r\n* 含义：清除浮动属性给其他标签带来的影响；\r\n* 当子元素浮动，子元素就不在标准流中，于是就不能撑开标准流的块级父元素，**如果父元素没有设置高度，子元素浮动后父元素的高度为0**，因为子元素浮动后不占位置；\r\n\r\n#### 设置行高法\r\n* 如果内容允许给父元素设置固定的高 就设置固定的高\r\n\r\n####  添加额外标签清除法；\r\n* 在父元素内容**最后**添加**块级元素**(一般类名为`clearfix`的div)，给添加的元素设置`clear:both;`\r\n* `clear属性`：专为解决此问题打造，取值为`left`时清除左浮动影响，取值为`right`时清除右浮动影响，取值为`both`时清除全部的影响。\r\n* 缺点：额外添加了标签，复杂化了HTML结构\r\n    ```html\r\n    <style>\r\n        .clearfix{\r\n            clear:both;\r\n        }\r\n    </style>\r\n    <div>\r\n        <div>浮动1</div>\r\n        <div>浮动2</div>\r\n        <div class=\"clearfix\"></div>\r\n    </div>\r\n    ```\r\n\r\n#### 单伪元素清除法\r\n* 先给父标签附加类名(clearfix),然后利用after伪元素\r\n* 优点；\r\n* 基本写法\r\n    ```css\r\n        .clearfix::after{\r\n            content:'';\r\n            display:block;\r\n            clear:both;\r\n        }\r\n    ```\r\n* 补充写法\r\n    ```css\r\n        .clearfix::after{\r\n            content:'';\r\n            display:block;\r\n            clear:both;\r\n            /* 多出的两行是为了解决低版本浏览器兼容性问题，某些浏览器(ie6、7、8)会认为伪元素有高度 */\r\n            height:0;\r\n            visibility:hidden;\r\n        }\r\n    ```\r\n\r\n#### 双伪元素清除法\r\n```css\r\n/* .clearfix::before,出现的目的在于解决外边距塌陷问题 */\r\n/* 塌陷问题的产生的情形是，嵌套的块级元素，这里把两个伪元素转换成table元素，就避免了这个问题 */\r\n.clearfix::before,\r\n.clearfix::after{\r\n    content:\"\";\r\n    display:table;\r\n}\r\n.clearfix::after{\r\n    clear:both;\r\n}\r\n```\r\n\r\n#### overflow属性清除\r\n* 直接给父元素设置属性`overflow:hidden;`\r\n* 优点：方便\r\n\r\n## 去除列表默认符号\r\n```css\r\nul{\r\n    list-style: none;\r\n}\r\n```\r\n效果对比：![](./images/CSS3重学笔记/2022-06-08-08-51-33.png)\r\n\r\n\r\n## 定位\r\n- [定位](#定位)\r\n    - [网页常见布局方式](#网页常见布局方式)\r\n    - [定位的使用步骤](#定位的使用步骤)\r\n    - [相对定位](#相对定位)\r\n    - [绝对定位](#绝对定位)\r\n        - [绝对定位的居中](#绝对定位的居中)\r\n    - [绝对定位fixed](#绝对定位fixed)\r\n    - [修改定位元素的层级关系](#修改定位元素的层级关系)\r\n        - [元素的层级关系](#元素的层级关系)\r\n        - [z-index](#z-index)\r\n    \r\n\r\n### 网页常见布局方式\r\n* 标准流： 块级元素垂直布局；行内/行内块元素水平布局\r\n* 浮动： 让块级元素水平布局\r\n* 定位\r\n    * 可以自由的让元素摆放在网页中任意位置\r\n    * 应用于盒子的层叠情况\r\n\r\n### 定位的使用步骤\r\n1. 设置定位方式\r\n    * 属性名 `position`\r\n    * 属性值 \r\n        * `static` 静态定位(默认，不定位)\r\n        * `relative` 相对定位\r\n        * `absolute` 绝对定位\r\n        * `fixed` 固定定位\r\n2. 设置偏移量\r\n    * 属性名 `top` `bottom` `left` `right` 水平和垂直方向各选其一\r\n    * 属性值 **像素** **百分比**\r\n\r\n### 相对定位\r\n* 相对于 **自己** 原先的位置移动\r\n* 不会改变元素显示模式\r\n* 仍然占有原先的位置(没有脱标)，空出的位置不会被其他元素占用\r\n* 不写偏移属性不改变位置\r\n* 同时写 left right 只有 left 会生效，无论顺序\r\n* 同时写 top bottom 只有 top 会生效，无论顺序\r\n```css\r\n.box{\r\n    /* 相对于自己原先位置移动10px */\r\n    position: relative;\r\n    top:10px;\r\n    left:10px;\r\n}\r\n```\r\n\r\n### 绝对定位\r\n* 相对于 **非静态定位** 的第一个 **父(祖宗)元素** 进行定位\r\n    * 如果其父元素有定位就相对于**父元素**定位\r\n    * 如果其父元素没有定位则相对浏览器窗口定位\r\n    * 父级可以是相对定位也可以是绝对定位，一般用相对定位;(**子绝父相**)\r\n* 会改变元素的显示模式，块元素会变行内元素\r\n* 不再占有原先位置(脱标),其他元素会填充该元素原先所在的位置![](./images/CSS3重学笔记/2022-06-10-17-19-54.png)\r\n* 当设置 `position: absolute;` 却不指定偏移时，元素保持原先位置(无论其父元素是不是静态定位)\r\n\r\n#### 绝对定位的居中\r\n* 设置绝对定位后不能使用`margin 0 auto;`方式居中\r\n* 解决办法1(手动计算)\r\n```css\r\n.box{\r\n    /* 绝对定位到父元素50%的位置，然后反方向移动宽高的一半 */\r\n    position: absolute;\r\n    left:50%;\r\n    top:50%;\r\n    margin-left: -250px;\r\n    margin-top: -150px;\r\n    width: 500px;\r\n    height: 300px;\r\n}\r\n```\r\n* 解决办法2(自动计算)\r\n```css\r\n.box{\r\n    /* 使用transform属性移动自身宽高的一半 */\r\n    position: absolute;\r\n    left:50%;\r\n    top:50%;\r\n    transform: translate(-50%,-50%);\r\n    width: 500px;\r\n    height: 300px;\r\n}\r\n```\r\n\r\n### 绝对定位fixed\r\n* 相对于**浏览器窗口**定位，不随滚动而位移\r\n* 会改变元素的显示模式，块元素变为行内块元素\r\n* 不再占有原先位置(脱标),其他元素会填充该元素原先所在的位置\r\n\r\n\r\n### 修改定位元素的层级关系\r\n\r\n#### 元素的层级关系\r\n* 不同**布局方式**元素的层级关系\r\n    + `标准流 < 浮动 < 定位`\r\n+ 不同**定位**之间的层级关系\r\n    + 相对、绝对、固定默认层级**相同**，会根据html标签代码的书写顺序（而不是css代码的书写顺序）来渲染，先渲染的会被后渲染的覆盖\r\n\r\n#### z-index\r\n+ 对于有定位属性的元素，想要要修改其渲染后的覆盖顺序，只需要调整html标签的顺序\r\n+ 如果不想修改html标签的顺序，可以使用`z-index:整数;`属性来控制，相当于指定其在第几图层。\r\n+ z-index只对有定位属性的元素生效\r\n+ 定位的默认层级是0\r\n\r\n\r\n\r\n## 文字的垂直对齐\r\n- [文字的垂直对齐](#文字的垂直对齐)\r\n    - [概念](#概念)\r\n    - [行内块元素的基线、底线、顶线、中线的概念](#行内块元素的基线底线顶线中线的概念)\r\n    - [实测效果](#实测效果)\r\n    - [文本框和按钮的中线对齐](#文本框和按钮的中线对齐)\r\n    - [图片和按钮框的中线对齐](#图片和按钮框的中线对齐)\r\n    - [嵌套关系的div和文本框的顶对齐](#嵌套关系的div和文本框的顶对齐)\r\n    - [嵌套关系的div和img的中线对齐](#嵌套关系的div和img的中线对齐)\r\n        - [情形1](#情形1)\r\n        - [情形2](#情形2)\r\n    - [该属性的其他属性值](#该属性的其他属性值)\r\n\r\n### 概念\r\n* 浏览器会将`行内元素`和`行内块元素`当成文字处理，默认的对齐方式是`基线对齐`\r\n* `块元素不会被当成文字处理。`\r\n\r\n### 行内块元素的基线、底线、顶线、中线的概念\r\n1. 顶线：**中文汉字**的的上端沿\r\n2. 中线：顶线和底线的中间线\r\n3. 基线:（base line）英文字母“x”的下端沿；\r\n4. 底线：**中文汉字**的下端沿\r\n![](./images/CSS3重学笔记/2022-06-11-17-24-43.png)\r\n\r\n### 实测效果\r\n* 没有文字时，按钮默认基线为下边缘，文本框的基线为文字输入区域下边缘\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-18-05.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-19-08.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-19-39.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-20-27.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-21-43.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-26-25.png)\r\n* 基线对齐不能实现完美对齐\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-28-18.png)\r\n\r\n### 文本框和按钮的中线对齐\r\n* `vertical-align: middle;`\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-51-09.png)\r\n\r\n\r\n### 图片和按钮框的中线对齐\r\n* 默认基线对齐\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-39-33.png)\r\n\r\n* 修改后\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-40-16.png)\r\n\r\n### 嵌套关系的div和文本框的顶对齐\r\n* 修改前\r\n![](./images/CSS3重学笔记/2022-06-11-17-41-16.png)\r\n* 修改为顶对齐后\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-43-01.png)\r\n\r\n### 嵌套关系的div和img的中线对齐\r\n\r\n#### 情形1\r\n* 修改前:div高度为默认，img高度设置为400px,但由于浏览器默认是基线对齐，底部会被撑开一条线\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-56-38.png)\r\n* 解决办法\r\n    * 修改为中线对齐 \r\n    * **另一种解决方法是把img转换成块元素**\r\n* 效果：\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-57-10.png)\r\n\r\n#### 情形2\r\n* 修改前：div拥有固定行高\r\n    ![](./images/CSS3重学笔记/2022-06-11-18-17-48.png)\r\n\r\n* 修改图片为中线对齐，同时在div中设置文字行高`line-height`为自身的高度，便可实现居中\r\n    ![](./images/CSS3重学笔记/2022-06-11-18-23-53.png)\r\n    ![](./images/CSS3重学笔记/2022-06-12-23-02-58.png)\r\n\r\n* 更进一步的，因为图片是行内块，所以要使图片水平方向居中，只需给父级元素添加text-aline:center\r\n    ![](./images/CSS3重学笔记/2022-06-11-18-25-34.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-18-25-45.png)\r\n\r\n### 该属性的其他属性值\r\n1. 基线对齐（vertical-align : baseline）使元素的基线同基准元素（取行高最高的作为基准）的基线对齐\r\n2. 顶端对齐（vertical-align : top）是将元素的行内框的顶端与行框的顶端对齐\r\n3. 底端对齐（vertical-align : bottom）与顶端对齐（vertical-align : top）相反\r\n4. 中间对齐（vertical-align : middle）通常使用在图片上，将图片的垂直方向的中线与文本行的中线（文字元素的行内框中线）对齐。\r\n5. 文本顶端对齐（vertical-align : text-top）是将元素行内框的顶端同行框的顶线对齐\r\n6. 文本底端对齐（vertical-align : text-bottom）是将元素行内框的底端同行框的底线对齐\r\n7. 上标（vertical-align:super）使元素的基线相对于基准元素的基线升高；\r\n8. 下标（vertical-align:sub）使元素的基线降低，移动的幅度CSS规范中没有规定，由浏览器来决定。\r\n\r\n\r\n## 鼠标光标类型\r\n* 属性名cursor\r\n* 属性值\r\n    * default 默认鼠标箭头\r\n    * pointer 小手\r\n    * text 工字形光标\r\n    * move 十字光标\r\n\r\n## 圆角边框\r\n* 属性名 border-radius\r\n* 属性值\r\n    * 数字+px\r\n    * 百分比\r\n* 书写格式 \r\n    * `border-radius: 左上 右上 右下 左下;` ;\r\n    * 可以像padding一样的格式省略为只写一个值、两个值、三个值或写全四个值；\r\n* 取值含义\r\n    * ![](./images/CSS3重学笔记/2022-06-11-20-25-46.png)\r\n* 画正圆\r\n    * 对正方形设置该属性\r\n    * `border-radius:50%;` \r\n    * 该属性的值最大取50%\r\n    * 应用：头像![](./images/CSS3重学笔记/2022-06-11-20-43-03.png)\r\n* 画胶囊\r\n    * 对长方形设置该属性\r\n    * `border-radius:高度的一半;`\r\n    * 应用 ![](./images/CSS3重学笔记/2022-06-11-20-42-30.png)\r\n\r\n## 溢出内容显示效果\r\n* 属性名：overflow\r\n* 属性值：\r\n    * visible 溢出部分可见（默认）\r\n    * hidden 溢出部分隐藏\r\n    * scroll 无论是否溢出，显示滚动条\r\n    * auto 自动根据内容是否溢出而显示滚动条\r\n* 测试效果\r\n    * visible ![](./images/CSS3重学笔记/2022-06-11-20-55-39.png)\r\n    * hidden ![](./images/CSS3重学笔记/2022-06-11-20-56-48.png)\r\n    * scroll ![](./images/CSS3重学笔记/2022-06-11-20-57-48.png)\r\n    * auto ![](./images/CSS3重学笔记/2022-06-11-20-58-44.png)\r\n\r\n## 元素的隐藏\r\n* `visibility:hidden;`\r\n    * 不常用，\r\n    * 只是单纯隐藏，仍然**占用标准流**\r\n* `display:none;`\r\n    * 常用\r\n    * 隐藏后**不占**用标准流\r\n* 应用：子菜单：![](./images/CSS3重学笔记/2022-06-11-21-05-06.png)\r\n* 案例：\r\n    * 先设置其默认情况隐藏![](./images/CSS3重学笔记/2022-06-11-21-21-57.png)\r\n    * 再设置其鼠标悬停时的显示模式为块![](./images/CSS3重学笔记/2022-06-11-21-21-15.png)\r\n    * 效果![](./images/CSS3重学笔记/2022-06-11-21-22-18.png)\r\n\r\n## 透明属性\r\n属性名：opacity\r\n取值：0~1之间的数字；0表示完全透明，1表示完全不透明\r\n作用：控制元素的整体透明度（包括其文字、图片的内容）\r\n\r\n## 过渡\r\n* 让元素的样式慢慢变化，常配合hover使用\r\n* 语法:\r\n    * `transition: 属性名 时间s;`\r\n    * `transition: 属性名 时间s,属性名 时间s,属性名 时间s,属性名 时间s;`\r\n    * `transition: all 时间s;`\r\n* 注意点\r\n    *  默认状态 和 `hover` 状态**样式不同**，才能有过渡效果 \r\n    * `transition`属性给需要过渡的**元素本身**加 \r\n    * `transition`属性设置在不同状态中，效果不同的\r\n        1. 给默认状态设置，鼠标**移入移出都有过渡效果**\r\n        2.  给hover状态设置，鼠标**移入有过渡效果，移出没有过渡效果**\r\n* 示例\r\n```html\r\n    <style>\r\n    .test{\r\n            width: 100px;\r\n            height: 100px;\r\n            background-color: green;\r\n            /* transition: width 1s; */\r\n            /* transition: width 1s,background-color 1s; */\r\n            transition: all 1s;\r\n        }\r\n        .test:hover{\r\n            width: 200px;\r\n            background-color: red;\r\n        }\r\n    </style>\r\n    <div class=\"test\"></div>\r\n```\r\n效果：\r\n<style>\r\n.test{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        /* transition: width 1s; */\r\n        /* transition: width 1s,background-color 1s; */\r\n        font-size:10px;\r\n        transition: all 1s;\r\n    }\r\n    .test:hover{\r\n        width: 200px;\r\n        background-color: red;\r\n        font-size:50px;\r\n    }\r\n</style>\r\n<div class=\"test\">文字</div>\r\n\r\n## 去除鼠标选中input-text后显示的默认边框\r\n* 设置属性：`outline:none;`\r\n* 去除前\r\n![](./images/CSS3重学笔记/2022-06-13-02-06-27.png)\r\n* 取出后\r\n![](./images/CSS3重学笔记/2022-06-13-02-05-32.png)\r\n\r\n## css3的书写顺序\r\n可以先按编写思略写，再按能使浏览器加载更快的书写顺序修改\r\n\r\n### 编写思路\r\n* 从外到内\r\n* 先宽高背景色\r\n* 再调节内容位置\r\n* 最后控制文字细节\r\n\r\n### 使浏览器加载更快的书写顺序\r\n1. （定位）\r\n2. 浮动 或 display\r\n3. 盒子模型相关属性\r\n    * width height \r\n    * background-color\r\n    * margin border padding \r\n4. 文字样式 font系列\r\n\r\n### 正确书写顺序使浏览器加载更快的原因\r\n* 该部分复制自CSDN\r\n* 正确的书写顺序\r\n    1. 定位属性：position display float left top right bottom overflow clear z-index\r\n    2. 自身属性：width height padding border margin background\r\n    3. 文字样式：font-family font-size font-style font-weight font-varient color\r\n    4. 文本属性：text-align vertical-align text-wrap text-transform text-indent text-decoration letter-spacing word-spacing white-space text-overflow\r\n    5. css3中新增属性：content box-shadow border-radius transform……\r\n\r\n* 目的：减少浏览器reflow（回流），提升浏览器渲染dom的性能\r\n\r\n* 原理：浏览器的渲染流程为——\r\n    1. 解析html构建dom树，解析css构建css树：将html解析成树形的数据结构，将css解析成树形的数据结构\r\n    2. 构建render树：DOM树和CSS树合并之后形成的render树。\r\n    3. 布局render树：有了render树，浏览器已经知道那些网页中有哪些节点，各个节点的css定义和以及它们的从属关系，从而计算出每个节点在屏幕中的位置。\r\n    4. 绘制render树：按照计算出来的规则，通过显卡把内容画在屏幕上。\r\n    * css样式解析到显示至浏览器屏幕上就发生在②③④步骤，可见浏览器并不是一获取到css样式就立马开始解析而是根据css样式的书写顺序将之按照dom树的结构分布render样式，完成第②步，然后开始遍历每个树结点的css样式进行解析，此时的css样式的遍历顺序完全是按照之前的书写顺序。在解析过程中，**一旦浏览器发现某个元素的定位变化影响布局，则需要倒回去重新渲染**，正如按照这样的书写书序：\r\n        ```css\r\n            width: 100px;\r\n            height: 100px;\r\n            background-color: red;\r\n            position: absolute;\r\n        ```\r\n    * 当浏览器解析到position的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染，解除该元素在文档中所占位置，然而由于该元素的占位发生变化，其他元素也可能会受到它回流的影响而重新排位。最终导致③步骤花费的时间太久而影响到④步骤的显示，影响了用户体验。\r\n    * 所以规范的的css书写顺序对于文档渲染来说一定是事半功倍的！ \r\n\r\n\r\n\r\n## html嵌套原则\r\n* ![](./images/CSS3重学笔记/2022-06-06-09-32-35.png)\r\n* 块级元素一般作为大容器，\r\n    * 可以嵌套：\r\n        * 块级元素\r\n        * 行内元素 行内块元素 （这两个只能嵌套行内和行内块元素）\r\n    * **但p标签禁止嵌套div p h等标签**\r\n    * **h和p禁止互相嵌套**\r\n* a标签可以嵌套任意标签\r\n    * 但不要a标签嵌套a标签\r\n\r\n\r\n\r\n## vscode的emment插件语法（自带插件）\r\n![](./images/CSS3重学笔记/2022-06-05-17-40-04.png)\r\n* div+类名 div.class1\r\n* p+id p#id\r\n* a+id+类名 a.id1#class1\r\n* 同级标签 a+p\r\n* 嵌套标签 ul>li\r\n* 多个 ul*3>li*3\r\n* 内容 ul*3>li{$}*3\r\n* css\r\n    * css提示规律\r\n        * 按首字母提示\r\n    w300+h200+bgc\r\n\r\n## pxcook像素大厨的基本使用\r\n* 写网页的测量工具\r\n"},{"shortInfo":{"title":"C语言实现简易辅助复习单词小程序","date":"2022-04-22T16:14:32.000Z","cover":"\\self_server\\assets\\images\\C语言实现简易辅助复习单词小程序\\default_cover2.jpg","tags":["C","背单词","demo"],"categories":"笔记","hideAtIndex":true,"imageMin":true,"id":1836521732,"countWords":46,"readSeconds":4.6,"assetsbaseUrl":"/self_server/assets/"},"content":"## 使用演示\r\n![使用演示](./images/C语言实现简易辅助复习单词小程序/2022_04_23_00_14_32_683.gif)\r\n\r\n## [-->主程序下载<--](./uploads/c语言简易单词复习程序/main.exe)\r\n"},{"shortInfo":{"title":"Electron19","date":"2022-11-19T12:12:00.000Z","cover":"\\self_server\\assets\\images\\Electron%2019\\2022-12-04-01-18-30.png","tags":["笔记"],"categories":"笔记","id":3818145765,"countWords":5314,"readSeconds":531.4,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/Electron%2019/2022-12-04-01-18-30.png) -->\r\n\r\n# Electron 19\r\n \r\n## 目录\r\n- [Electron 19](#electron-19)\r\n  - [目录](#目录)\r\n  - [1、什么是 Electron](#1什么是-electron)\r\n  - [2、Electron 初探](#2electron-初探)\r\n    - [2.1 常见的桌面GUI工具介绍](#21-常见的桌面gui工具介绍)\r\n    - [2.2 桌面端设计与开发要点](#22-桌面端设计与开发要点)\r\n    - [2.3 初始化项目 + 项目依赖介绍](#23-初始化项目--项目依赖介绍)\r\n  - [3、Electron 核心概念](#3electron-核心概念)\r\n    - [3.1 Electron 主进程与渲染进程](#31-electron-主进程与渲染进程)\r\n    - [3.2 主进程事件生命周期](#32-主进程事件生命周期)\r\n    - [3.3 渲染进程如何使用 Node 模块](#33-渲染进程如何使用-node-模块)\r\n    - [3.5 主进程与渲染进程通信](#35-主进程与渲染进程通信)\r\n      - [3.5.1 index.html](#351-indexhtml)\r\n      - [3.5.2 renderer.js](#352-rendererjs)\r\n      - [3.5.3 main.js](#353-mainjs)\r\n  - [4、主进程](#4主进程)\r\n    - [4.1 App](#41-app)\r\n      - [4.1.1 事件](#411-事件)\r\n        - [4.1.1.1 before-quit](#4111-before-quit)\r\n        - [4.1.1.2 browser-window-blur](#4112-browser-window-blur)\r\n        - [4.1.1.3 browser-window-focus](#4113-browser-window-focus)\r\n      - [4.1.2 方法](#412-方法)\r\n        - [4.1.2.1 app.quit()](#4121-appquit)\r\n        - [4.1.2.2 app.getPath(name)](#4122-appgetpathname)\r\n    - [4.2 BrowserWindow](#42-browserwindow)\r\n      - [4.2.1 实例方法](#421-实例方法)\r\n      - [4.2.2 优雅的显示窗口](#422-优雅的显示窗口)\r\n      - [4.2.3 父子窗口](#423-父子窗口)\r\n      - [4.2.4 无边框窗口](#424-无边框窗口)\r\n      - [4.2.5 属性与方法](#425-属性与方法)\r\n        - [4.2.5.1 minWidth \\&\\& minHeight](#4251-minwidth--minheight)\r\n        - [4.2.5.2 窗口焦点事件](#4252-窗口焦点事件)\r\n        - [4.2.5.3 静态方法](#4253-静态方法)\r\n        - [4.2.5.4 实例方法](#4254-实例方法)\r\n      - [4.2.6 state](#426-state)\r\n      - [4.2.7 webContents](#427-webcontents)\r\n        - [4.2.7.1 方法 getAllWebContents(）\\*](#4271-方法-getallwebcontents)\r\n        - [4.2.7.2 实例事件](#4272-实例事件)\r\n        - [4.2.7.3 实例方法](#4273-实例方法)\r\n    - [4.3 dialog - 对话框](#43-dialog---对话框)\r\n    - [4.4 快捷键+系统快捷键](#44-快捷键系统快捷键)\r\n    - [4.5 Menu](#45-menu)\r\n      - [4.5.1 index.html](#451-indexhtml)\r\n      - [4.5.2 main.js](#452-mainjs)\r\n      - [4.5.3 mainMenu.js](#453-mainmenujs)\r\n    - [4.6 Context Menus](#46-context-menus)\r\n      - [4.6.1 index.html](#461-indexhtml)\r\n      - [4.6.2 main.js](#462-mainjs)\r\n    - [4.7 Tray (托盘)](#47-tray-托盘)\r\n      - [4.7.1 main.js](#471-mainjs)\r\n  - [5、渲染进程](#5渲染进程)\r\n    - [5.1 clipboard](#51-clipboard)\r\n      - [5.1.1 `readText()`](#511-readtext)\r\n      - [5.1.2 `writeText(text)`](#512-writetexttext)\r\n    - [5.2 contextBridge](#52-contextbridge)\r\n    - [5.3 desktopCapturer](#53-desktopcapturer)\r\n    - [5.4 ipcRenderer](#54-ipcrenderer)\r\n    - [5.5 nativeImage](#55-nativeimage)\r\n      - [5.5.1 支持的格式](#551-支持的格式)\r\n      - [5.5.2 高分辨率图像](#552-高分辨率图像)\r\n      - [5.5.3 方法](#553-方法)\r\n      - [5.5.4 Class: NativeImage](#554-class-nativeimage)\r\n\r\n\r\n\r\n## 1、什么是 Electron\r\n\r\n参见 PPT。\r\n\r\n## 2、Electron 初探\r\n\r\n### 2.1 常见的桌面GUI工具介绍\r\n\r\n| 名称     | 语音   | 优点                     | 缺点                     |\r\n| -------- | ------ | ------------------------ | ------------------------ |\r\n| `QT`       | C++    | `跨平台、性能好、生态好`   | `依赖多，程序包大`         |\r\n| PyQT     | Python | 底层集成度高、易上手     | 授权问题                 |\r\n| WPF      | C#     | 类库丰富、扩展灵活       | 只支持Windows，程序包大  |\r\n| WinForm  | C#     | 性能好，组件丰富，易上手 | 只支持Windows，UI差      |\r\n| Swing    | Java   | 基于AWT，组件丰富        | 性能差，UI一般           |\r\n| `NW.js`    | JS     | 跨平台性好，界面美观     | 底层交互差、性能差，包大 |\r\n| `Electron` | JS     | 相比NW发展更好           | `底层交互差、性能差，包大` |\r\n| CEF      | C++    | 性能好，灵活集成，UI美观 | 占用资源多，包大         |\r\n\r\n- 底层依赖 + 调用:CEF、QT、Swing\r\n- UI美观:Electron（NW.js）、PyQT\r\n- 跨平台:Swing（JAVA）、PyQT（Python、C++）、Electron（前端）\r\n\r\n技术是为业务服务的，选择合适的最重要！\r\n\r\n### 2.2 桌面端设计与开发要点\r\n\r\n1、UX/UI设计概念\r\n\r\n**UX设计:** UX（User Experience）即用户体验，其核心是用户，体验指用户在使用产品以及与产品发生交互时出现的主观感受和需求满足。\r\n\r\n**UI设计:** UI（User Interface）使用者界面，可以说是 UX 设计的一部分，其中重要的**图形化或者可视化**部分，都是由 UI 设计来完成的。\r\n\r\n2、核心原则\r\n\r\n简单易用。\r\n\r\n3、通用原则\r\n\r\n交互简单:上手就会，一看就懂\r\n\r\n风格统一:菜单、导航、按钮反馈、颜色、预知提示\r\n\r\n认知一致:名词、友好提示、划分信息、突出展示\r\n\r\n4、桌面端设计\r\n\r\n保持与PC端统一的风格设计与交互设计。\r\n\r\n加入定制的菜单与专业操控设计。\r\n\r\n减少资源加载。\r\n\r\n### 2.3 初始化项目 + 项目依赖介绍\r\n\r\n1、Electron 官网\r\n\r\nhttps://www.electronjs.org/\r\n\r\n2、初始化一个项目\r\n\r\n```\r\nfelixlu electron $ npm init -y\r\n```\r\n\r\n```\r\nnpm i electron -D\r\n```\r\n\r\n3、配置启动脚本\r\n\r\n在 package.json 里配置 npm 脚本:\r\n\r\n```json\r\n{\r\n  \"scripts\": {\r\n    \"start\": \"electron .\"\r\n  },\r\n}\r\n```\r\n\r\n4、创建入口文件\r\n\r\n- 在项目根目录下创建文件 index.html:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>Electron Demo</title>\r\n</head>\r\n<body>\r\n  hello Electron\r\n</body>\r\n</html>\r\n```\r\n\r\n- 在项目根目录下创建 index.js 文件，这是程序的入口文件:\r\n\r\n```js\r\nconst { app } = require('electron')\r\n\r\n// 主进程\r\nconst createWindow = () => {\r\n  const win = new BrowserWindow({\r\n    width: 800,\r\n    height: 600\r\n  })\r\n\r\n  win.loadFile('index.html')\r\n}\r\n\r\napp.whenReady().then(createWindow)\r\n```\r\n\r\n\r\n\r\n## 3、Electron 核心概念\r\n\r\n### 3.1 Electron 主进程与渲染进程\r\n\r\n**主进程:** 启动项目时运行的 main.js 脚本就是我们说的主进程。在主进程运行的脚本可以以创建 Web 页面的形式展示 GUI。**主进程只有一个**。\r\n\r\n**渲染进程:** 每个 Electron 的页面都在运行着自己的进程，这样的进程称之为渲染进程（基于Chromium的多进程结构）。\r\n\r\n![image-20220622220437989](./images/image-20220622220437989.png)\r\n\r\n主进程使用 BrowserWindow 创建实例，主进程销毁后，对应的渲染进程回被终止。主进程与渲染进程通过 IPC 方式（事件驱动）进行通信。\r\n\r\n### 3.2 主进程事件生命周期\r\n\r\n> main process modules/app/event:https://www.electronjs.org/zh/docs/latest/api/app\r\n\r\n```js\r\napp.on('window-all-closed', () => {\r\n  console.log('window-all-closed')\r\n  // 对于 MacOS 系统 -> 关闭窗口时，不会直接推出应用\r\n  if (process.platform !== 'darwin') {\r\n    app.quit()\r\n  }\r\n})\r\n\r\napp.on('quit', () => {\r\n  console.log('quit')\r\n})\r\n\r\napp.whenReady().then(() => {\r\n  createWindow()\r\n  // 在MacOS下，当全部窗口关闭，点击 dock 图标，窗口再次打开。\r\n  app.on('activate', () => {\r\n    if (BrowserWindow.getAllWindows().length === 0) {\r\n      createWindow()\r\n    }\r\n  })\r\n})\r\n```\r\n\r\n### 3.3 渲染进程如何使用 Node 模块\r\n\r\n**1、通过 webPreferences/nodeIntegration**\r\n\r\n```js\r\nconst win = new BrowserWindow({\r\n  width: 800,\r\n  height: 400,\r\n  webPreferences: {\r\n  \tnodeIntegration: true,\r\n  \tcontextIsolation: false\r\n  }\r\n})\r\n```\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>Electron Demo</title>\r\n  <script src=\"https://unpkg.com/vue@next\"></script>\r\n</head>\r\n<body>\r\n  <h1>\r\n    hello Electron\r\n  </h1>\r\n  <div id=\"root\">\r\n    <p>electronVersion: {{electronVersion}}</p>\r\n    <p>nodeVersion: {{nodeVersion}}</p>\r\n    <p>chromeVersion: {{chromeVersion}}</p>\r\n  </div>\r\n  <script>\r\n    // const path = require('path')\r\n    // console.log(path)\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return {\r\n          electronVersion: process.versions.electron,\r\n          nodeVersion: process.versions.node,\r\n          chromeVersion: process.versions.chrome\r\n        }\r\n      }\r\n    })\r\n    app.mount('#root')\r\n  </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n**2、通过 webPreferences/preload 实现**\r\n\r\n```js\r\nconst win = new BrowserWindow({\r\n    width: 800,\r\n    height: 400,\r\n    webPreferences: {\r\n      // 在启动应用时在渲染进程里预加载 js\r\n      preload: path.join(__dirname, './preload-js/index.js')\r\n    }\r\n  })\r\n```\r\n\r\n```js\r\n// preload-js/index.js\r\n\r\n// const { contextBridge } = require('electron')\r\n// contextBridge.exposeInMainWorld('myAPI', {\r\n//  desktop: true\r\n// })\r\n\r\nconst { createApp } = require('vue')\r\nwindow.addEventListener('load', () => {\r\n  const app = createApp({\r\n    data() {\r\n      return {\r\n        electronVersion: process.versions.electron,\r\n        nodeVersion: process.versions.node,\r\n        chromeVersion: process.versions.chrome\r\n      }\r\n    }\r\n  })\r\n  app.mount('#root')\r\n})\r\n```\r\n\r\n**3、代码改造**\r\n\r\n```js\r\n// index.js\r\n win.loadFile('./renderer/index.html')\r\n```\r\n\r\n```html\r\n<!-- renderer/index.html -->\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <!-- <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self';\"> -->\r\n  <title>Electron Demo</title>\r\n  <script src=\"./vue.global.js\"></script>\r\n</head>\r\n<body>\r\n  <h1>hello Electron</h1>\r\n  <div id=\"root\"></div>\r\n  <script src=\"./main.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n\r\n```js\r\n// renderer/main.js\r\nconst app = Vue.createApp({\r\n  template: `\r\n    <p>electronVersion: {{electronVersion}}</p>\r\n    <p>nodeVersion: {{nodeVersion}}</p>\r\n    <p>chromeVersion: {{chromeVersion}}</p>\r\n  `,\r\n  data() {\r\n    return {\r\n      electronVersion: process.versions.electron,\r\n      nodeVersion: process.versions.node,\r\n      chromeVersion: process.versions.chrome\r\n    }\r\n  }\r\n})\r\napp.mount('#root')\r\n```\r\n\r\n```html\r\n<!-- 配置CSP -->\r\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; img-src 'self' data:; script-src 'self'; style-src 'self' 'unsafe-inline'\">\r\n```\r\n\r\n```js\r\n// 暂时关闭安全警告\r\nprocess.env['ELECTRON_DISABLE_SECURITY_WARNINGS'] = 'true'\r\n```\r\n\r\n### 3.5 主进程与渲染进程通信\r\n\r\n#### 3.5.1 index.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self' 'unsafe-inline'\">\r\n    <title>Hello World!</title>\r\n  </head>\r\n  <body>\r\n    <h1>Hello World!</h1>\r\n\r\n    <button type=\"button\" id=\"talk\">Talk to main process</button><br>\r\n\r\n    <!-- All of the Node.js APIs are available in this renderer process. -->\r\n    We are using Node.js <strong><script>document.write( process.versions.node)</script></strong>,\r\n    and Electron <strong><script>document.write( process.versions.electron )</script></strong>.\r\n\r\n    <script>\r\n      // You can also require other files to run in this process\r\n      require('./renderer.js')\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n#### 3.5.2 renderer.js\r\n\r\n```js\r\n// This file is required by the index.html file and will\r\n// be executed in the renderer process for that window.\r\n// All of the Node.js APIs are available in this process.\r\n\r\nconst { ipcRenderer } = require('electron')\r\n\r\nlet i = 1\r\nsetInterval( () => {\r\n  console.log(i)\r\n  i++\r\n}, 1000)\r\n\r\ndocument.getElementById('talk').addEventListener('click', e => {\r\n\r\n  // ipcRenderer.send( 'channel1', 'Hello from main window')\r\n\r\n  let response = ipcRenderer.sendSync( 'sync-message', 'Waiting for response')\r\n  console.log(response)\r\n\r\n})\r\n\r\nipcRenderer.on( 'channel1-response', (e, args) => {\r\n  console.log(args)\r\n})\r\n\r\nipcRenderer.on( 'mailbox', (e, args) => {\r\n  console.log(args)\r\n})\r\n```\r\n\r\n#### 3.5.3 main.js\r\n\r\n```js\r\n// Modules\r\nconst {app, BrowserWindow, ipcMain} = require('electron')\r\n\r\n// Keep a global reference of the window object, if you don't, the window will\r\n// be closed automatically when the JavaScript object is garbage collected.\r\nlet mainWindow\r\n\r\n// Create a new BrowserWindow when `app` is ready\r\nfunction createWindow () {\r\n\r\n  mainWindow = new BrowserWindow({\r\n    width: 1000, height: 800, x: 100, y:140,\r\n    webPreferences: { nodeIntegration: true }\r\n  })\r\n\r\n  // Load index.html into the new BrowserWindow\r\n  mainWindow.loadFile('index.html')\r\n\r\n  // Open DevTools - Remove for PRODUCTION!\r\n  mainWindow.webContents.openDevTools();\r\n\r\n  mainWindow.webContents.on( 'did-finish-load', e => {\r\n\r\n    // mainWindow.webContents.send( 'mailbox', {\r\n    //   from: 'Ray',\r\n    //   email: 'ray@stackacademy.tv',\r\n    //   priority: 1\r\n    // })\r\n  })\r\n\r\n  // Listen for window being closed\r\n  mainWindow.on('closed',  () => {\r\n    mainWindow = null\r\n  })\r\n}\r\n\r\nipcMain.on( 'sync-message', (e, args) => {\r\n  console.log(args)\r\n\r\n  setTimeout( () => {\r\n    e.returnValue = 'A sync response from the main process'\r\n  }, 4000)\r\n\r\n})\r\n\r\nipcMain.on( 'channel1', (e, args) => {\r\n  console.log(args)\r\n  e.sender.send( 'channel1-response', 'Message received on \"channel1\". Thank you!')\r\n})\r\n\r\n// Electron `app` is ready\r\napp.on('ready', createWindow)\r\n\r\n// Quit when all windows are closed - (Not macOS - Darwin)\r\napp.on('window-all-closed', () => {\r\n  if (process.platform !== 'darwin') app.quit()\r\n})\r\n\r\n// When app icon is clicked and app is running, (macOS) recreate the BrowserWindow\r\napp.on('activate', () => {\r\n  if (mainWindow === null) createWindow()\r\n})\r\n```\r\n\r\n## 4、主进程\r\n\r\n> Electron API （Electron API 有两种）\r\n\r\n- Main Process （主进进程）\r\n- Renderer Process（渲染进程）\r\n\r\n### 4.1 App\r\n\r\n#### 4.1.1 事件\r\n\r\n##### 4.1.1.1 before-quit\r\n\r\n> 在应用程序开始关闭窗口之前触发。\r\n\r\n```js\r\napp.on('before-quit', (e) => {\r\n  console.log('App is quiting')\r\n  e.preventDefault()\r\n})\r\n```\r\n\r\n##### 4.1.1.2 browser-window-blur\r\n\r\n> 在 browserWindow 失去焦点时发出\r\n\r\n```js\r\napp.on('browser-window-blur', (e) => {\r\n  console.log('App unfocused')\r\n})\r\n```\r\n\r\n##### 4.1.1.3 browser-window-focus\r\n\r\n> 在 browserWindow 获得焦点时发出\r\n\r\n```js\r\napp.on('browser-window-focus', (e) => {\r\n  console.log('App focused')\r\n})\r\n```\r\n\r\n#### 4.1.2 方法\r\n\r\n##### 4.1.2.1 app.quit()\r\n\r\n```js\r\napp.on('browser-window-blur', (e) => {\r\n  setTimeout(() => {\r\n    app.quit()\r\n  }, 3000)\r\n})\r\n\r\napp.on('browser-window-blur', (e) => {\r\n  setTimeout(app.quit, 3000)\r\n})\r\n```\r\n\r\n##### 4.1.2.2 app.getPath(name)\r\n\r\n```js\r\napp.whenReady().then(() => {\r\n  console.log(app.getPath('desktop'))\r\n  console.log(app.getPath('music'))\r\n  console.log(app.getPath('temp'))\r\n  console.log(app.getPath('userData'))\r\n\r\n  createWindow()\r\n})\r\n```\r\n\r\n### 4.2 BrowserWindow\r\n\r\n> electron.BrowserWindow: 创建和控制浏览器窗口\r\n\r\n#### 4.2.1 实例方法\r\n\r\nwin.loadURL(url[, options]): 和 loadFile 互斥\r\n\r\n```js\r\nmainWindow.loadURL('https://www.baidu.com')\r\n```\r\n\r\n#### 4.2.2 优雅的显示窗口\r\n\r\n- 使用ready-to-show事件\r\n\r\n```js\r\nlet mainWindow = new BrowserWindow({ show: false })\r\nmainWindow.once('ready-to-show', () => {\r\n  mainWindow.show()\r\n})\r\n```\r\n\r\n- 设置 backgroundColor\r\n\r\n```js\r\nlet win = new BrowserWindow({ backgroundColor: '#2e2c29' })\r\n```\r\n\r\n#### 4.2.3 父子窗口\r\n\r\n- 窗口定义\r\n\r\n```js\r\nsecondaryWindow = new BrowserWindow({\r\n  width: 600,\r\n  height: 600,\r\n  webPreferences: { nodeIntegration: true }\r\n})\r\n\r\nsecondaryWindow.loadFile('index.html')\r\n\r\nsecondaryWindow.on('closed',  () => {\r\n   mainWindow = null\r\n})\r\n```\r\n\r\n- 窗口关系\r\n\r\n```js\r\nsecondaryWindow = new BrowserWindow({\r\n  parent: mainWindon, // 定义父窗口\r\n  modal: true // 锁定在主窗口\r\n})\r\n```\r\n\r\n- 子窗口显示和隐藏\r\n\r\n```js\r\nsecondaryWindow = new BrowserWindow({\r\n  show: false\r\n})\r\n\r\nsetTimeout(() => {\r\n  secondaryWindow.show()\r\n  setTimeout(() => {\r\n    secondaryWindow.hide()\r\n  }, 3000)\r\n}, 2000)\r\n```\r\n\r\n#### 4.2.4 无边框窗口\r\n\r\n> Frameless Window\r\n\r\n```js\r\nmainWindow = new BrowserWindow({\r\n  frame: false\r\n})\r\n```\r\n\r\n让页面可拖拽\r\n\r\n```html\r\n<body style=\"user-select: none; -webkit-app-region:drag;\">\r\n```\r\n\r\nno-drag 修复下面控件的bug\r\n\r\n```html\r\n<input style=\"-webkit-app-region: no-drag;\" type=\"range\" name=\"range\" min=\"0\" max=\"10\">\r\n```\r\n\r\n显示红绿灯\r\n\r\n```js\r\nmainWindow = new BrowserWindow({\r\n  titleBarStyle: 'hidden' // or hiddenInset 距离红绿灯更近\r\n})\r\n```\r\n\r\n#### 4.2.5 属性与方法\r\n\r\n##### 4.2.5.1 minWidth && minHeight\r\n\r\n```js\r\nmainWindow = new BrowserWindow({\r\n  minWidth: 300,\r\n  minHeight: 300\r\n})\r\n```\r\n\r\n更多详见:https://electronjs.org/docs/api/browser-window#new-browserwindowoptions\r\n\r\n##### 4.2.5.2 窗口焦点事件\r\n\r\n```js\r\nsecWindow = new BrowserWindow({\r\n  width: 400, height: 300,\r\n  webPreferences: { nodeIntegration: true },\r\n})\r\n\r\nmainWindow.on('focus', () => {\r\n  console.log('mainWindow focused')\r\n})\r\n\r\nsecWindow.on('focus', () => {\r\n  console.log('secWindow focused')\r\n})\r\n\r\napp.on('browser-window-focus', () => {\r\n  console.log('App focused')\r\n})\r\n```\r\n\r\n##### 4.2.5.3 静态方法\r\n\r\n- getAllWindows()\r\n\r\n```js\r\nlet allWindows = BrowserWindow.getAllWindows()\r\nconsole.log(allWindows)\r\n```\r\n\r\n更多详见: https://electronjs.org/docs/api/browser-window#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\r\n\r\n##### 4.2.5.4 实例方法\r\n\r\n- maximize()\r\n\r\n```\r\nsecWindow.on('closed', () => {\r\n  mainWindow.maximize()\r\n})\r\n```\r\n\r\n更多详见:https://electronjs.org/docs/api/browser-window#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95\r\n\r\n#### 4.2.6 state\r\n\r\n> electron-win-state 保存窗口的状态\r\n> `npm install electron-win-state`\r\n\r\n#### 4.2.7 webContents\r\n\r\n> webContents 是 EventEmitter 的实例， 负责渲染和控制网页, 是 BrowserWindow 对象的一个属性。\r\n\r\n```\r\nlet wc = mainWindow.webContents\r\nconsole.log(wc)\r\n```\r\n\r\n##### 4.2.7.1 方法 getAllWebContents(）*\r\n\r\n- 返回 WebContents[] - 所有 WebContents 实例的数组。 包含所有Windows，webviews，opened devtools 和 devtools 扩展背景页的 web 内容\r\n\r\n```\r\nconst {app, BrowserWindow, webContents} = require('electron')\r\nconsole.log(webContents.getAllWebContents())\r\n```\r\n\r\n##### 4.2.7.2 实例事件\r\n\r\n- did-finish-load\r\n- dom-ready\r\n\r\n```html\r\n<div>\r\n   <img src=\"https://placekitten.com/500/500\" alt=\"\">\r\n</div>\r\n<script>\r\nlet wc = mainWindow.webContents\r\nwc.on('did-finish-load', () => {\r\n  console.log('Conent fully loaded')\r\n})\r\nwc.on('dom-ready', () => {\r\n  console.log('DOM Ready')\r\n})\r\n</script>\r\n```\r\n\r\n- new-window\r\n\r\n```html\r\n<div>\r\n  <a target=\"_blank\" href=\"https://placekitten.com/500/500\"><h3>Kitten</h3></a>\r\n</div>\r\n\r\n<script>\r\nwc.on('new-window', (e, url) => {\r\n  e.preventDefault()\r\n  console.log('DOM Ready')\r\n})\r\n</script>\r\n```\r\n\r\n- context-menu : 右键上下文信息\r\n\r\n```js\r\nwc.on('context-menu', (e, params) => {\r\n  console.log(`Context menu opened on: ${params.mediaType} at x:${params.x}, y:${params.y}`)\r\n})\r\n\r\nwc.on('context-menu', (e, params) => {\r\n  console.log(`User seleted text: ${params.selectionText}`)\r\n  console.log(`Selection can be copied: ${params.editFlags.canCopy}`)\r\n})\r\n```\r\n\r\n##### 4.2.7.3 实例方法\r\n\r\n- executeJavaScript()\r\n\r\n```js\r\nwc.on('context-menu', (e, params) => {\r\n  wc.executeJavaScript(`alert('${params.selectionText}')`)\r\n})\r\n```\r\n\r\n### 4.3 dialog - 对话框\r\n\r\n> 显示用于打开和保存文件、警报等的本机系统对话框\r\n\r\n```js\r\nconst {app, BrowserWindow, dialog} = require('electron')\r\n\r\nmainWindow.webContents.on('did-finish-load', () => {\r\n  dialog.showOpenDialog({\r\n    buttonLabel: '选择',\r\n    defaultPath: app.getPath('desktop'),\r\n    properties: ['multiSelections', 'createDirectory', 'openFile', 'openDirectory']\r\n  }).then((result)=> {\r\n    console.log(result.filepaths)\r\n  })\r\n})\r\n```\r\n\r\n```js\r\ndialog.showSaveDialog({}).then(result => {\r\n  console.log(result.filePath)\r\n})\r\n```\r\n\r\n```js\r\nconst answers = ['Yes', 'No', 'Maybe']\r\ndialog.showMessageBox({\r\n  title: 'Message Box',\r\n  message: 'Please select an option',\r\n  detail: 'Message details.',\r\n  buttons: answers\r\n}).then(({response}) => {\r\n  console.log(`User selected: ${answers[response]}`)\r\n})\r\n```\r\n\r\n### 4.4 快捷键+系统快捷键\r\n\r\n> **快捷键**:定义键盘快捷键。\r\n> **系统快捷键**:在应用程序没有键盘焦点时，监听键盘事件。\r\n\r\n快捷键可以包含多个功能键和一个键码的字符串，由符号+结合，用来定义你应用中的键盘快捷键\r\n\r\n示例:\r\n\r\n+ CommandOrControl+A\r\n+ CommandOrControl+Shift+Z\r\n\r\n快捷方式使用 register 方法在 globalShortcut 模块中注册。\r\n\r\nglobalShortcut 模块可以在操作系统中注册/注销全局快捷键, 以便可以为操作定制各种快捷键。\r\n\r\n注意: 快捷方式是全局的; 即使应用程序没有键盘焦点, 它也仍然在持续监听键盘事件。 在应用程序模块发出 ready 事件之前, 不应使用此模块。\r\n\r\n```js\r\nconst {app, BrowserWindow, globalShortcut} = require('electron')\r\n\r\nglobalShortcut.register('G', () => {\r\n  console.log('User pressed G')\r\n})\r\n```\r\n\r\n```js\r\nglobalShortcut.register('CommandOrControl+Y', () => {\r\n  console.log('User pressed G with a combination key')\r\n  globalShortcut.unregister('CommandOrControl+Y')\r\n})\r\n```\r\n\r\n### 4.5 Menu\r\n\r\n#### 4.5.1 index.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self' 'unsafe-inline'\">\r\n    <title>Hello World!</title>\r\n  </head>\r\n  <body>\r\n    <h1>Hello World!</h1>\r\n\r\n    <textarea name=\"name\" rows=\"8\" cols=\"80\"></textarea>\r\n\r\n    <!-- All of the Node.js APIs are available in this renderer process. -->\r\n    We are using Node.js <strong><script>document.write( process.versions.node)</script></strong>,\r\n    and Electron <strong><script>document.write( process.versions.electron )</script></strong>.\r\n\r\n    <script>\r\n      // You can also require other files to run in this process\r\n      require('./renderer.js')\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n#### 4.5.2 main.js\r\n\r\n```js\r\n// Modules\r\nconst {app, BrowserWindow, Menu, MenuItem} = require('electron')\r\n\r\n// Keep a global reference of the window object, if you don't, the window will\r\n// be closed automatically when the JavaScript object is garbage collected.\r\nlet mainWindow\r\n\r\nlet mainMenu = Menu.buildFromTemplate( require('./mainMenu') )\r\n\r\n\r\n// Create a new BrowserWindow when `app` is ready\r\nfunction createWindow () {\r\n\r\n  mainWindow = new BrowserWindow({\r\n    width: 1000, height: 800,\r\n    webPreferences: { nodeIntegration: true }\r\n  })\r\n\r\n  // Load index.html into the new BrowserWindow\r\n  mainWindow.loadFile('index.html')\r\n\r\n  // Open DevTools - Remove for PRODUCTION!\r\n  mainWindow.webContents.openDevTools();\r\n\r\n  Menu.setApplicationMenu(mainMenu)\r\n\r\n  // Listen for window being closed\r\n  mainWindow.on('closed',  () => {\r\n    mainWindow = null\r\n  })\r\n}\r\n\r\n// Electron `app` is ready\r\napp.on('ready', createWindow)\r\n\r\n// Quit when all windows are closed - (Not macOS - Darwin)\r\napp.on('window-all-closed', () => {\r\n  if (process.platform !== 'darwin') app.quit()\r\n})\r\n\r\n// When app icon is clicked and app is running, (macOS) recreate the BrowserWindow\r\napp.on('activate', () => {\r\n  if (mainWindow === null) createWindow()\r\n})\r\n\r\n```\r\n\r\n#### 4.5.3 mainMenu.js\r\n\r\n```js\r\nmodule.exports = [\r\n  {\r\n    label: 'Electron',\r\n    submenu: [\r\n      { label: 'Item 1'},\r\n      { label: 'Item 2', submenu: [ { label: 'Sub Item 1'} ]},\r\n      { label: 'Item 3'},\r\n    ]\r\n  },\r\n  {\r\n    label: 'Edit',\r\n    submenu: [\r\n      { role: 'undo'},\r\n      { role: 'redo'},\r\n      { role: 'copy'},\r\n      { role: 'paste'},\r\n    ]\r\n  },\r\n  {\r\n    label: 'Actions',\r\n    submenu: [\r\n      {\r\n        label: 'DevTools',\r\n        role: 'toggleDevTools'\r\n      },\r\n      {\r\n        role: 'toggleFullScreen'\r\n      },\r\n      {\r\n        label: 'Greet',\r\n        click: () => { console.log('Hello from Main Menu') },\r\n        accelerator: 'Shift+Alt+G'\r\n      }\r\n    ]\r\n  }\r\n]\r\n```\r\n\r\n### 4.6 Context Menus\r\n\r\n#### 4.6.1 index.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self' 'unsafe-inline'\">\r\n    <title>Hello World!</title>\r\n  </head>\r\n  <body>\r\n    <h1>Hello World!</h1>\r\n\r\n    <textarea name=\"name\" rows=\"8\" cols=\"80\"></textarea>\r\n\r\n    <!-- All of the Node.js APIs are available in this renderer process. -->\r\n    We are using Node.js <strong><script>document.write( process.versions.node)</script></strong>,\r\n    and Electron <strong><script>document.write( process.versions.electron )</script></strong>.\r\n\r\n    <script>\r\n      // You can also require other files to run in this process\r\n      require('./renderer.js')\r\n    </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n#### 4.6.2 main.js\r\n\r\n```js\r\n// Modules\r\nconst {app, BrowserWindow, Menu} = require('electron')\r\n\r\n// Keep a global reference of the window object, if you don't, the window will\r\n// be closed automatically when the JavaScript object is garbage collected.\r\nlet mainWindow\r\n\r\nlet contextMenu = Menu.buildFromTemplate([\r\n  { label: 'Item 1' },\r\n  { role: 'editMenu' }\r\n])\r\n\r\n// Create a new BrowserWindow when `app` is ready\r\nfunction createWindow () {\r\n\r\n  mainWindow = new BrowserWindow({\r\n    width: 1000, height: 800,\r\n    webPreferences: { nodeIntegration: true }\r\n  })\r\n\r\n  // Load index.html into the new BrowserWindow\r\n  mainWindow.loadFile('index.html')\r\n\r\n  // Open DevTools - Remove for PRODUCTION!\r\n  mainWindow.webContents.openDevTools();\r\n\r\n  mainWindow.webContents.on('context-menu', e => {\r\n    contextMenu.popup()\r\n  })\r\n\r\n  // Listen for window being closed\r\n  mainWindow.on('closed',  () => {\r\n    mainWindow = null\r\n  })\r\n}\r\n\r\n// Electron `app` is ready\r\napp.on('ready', createWindow)\r\n\r\n// Quit when all windows are closed - (Not macOS - Darwin)\r\napp.on('window-all-closed', () => {\r\n  if (process.platform !== 'darwin') app.quit()\r\n})\r\n\r\n// When app icon is clicked and app is running, (macOS) recreate the BrowserWindow\r\napp.on('activate', () => {\r\n  if (mainWindow === null) createWindow()\r\n})\r\n```\r\n\r\n### 4.7 Tray (托盘)\r\n\r\n#### 4.7.1 main.js\r\n\r\n```js\r\n// Modules\r\nconst {app, BrowserWindow, Tray, Menu} = require('electron')\r\n\r\n// Keep a global reference of the window object, if you don't, the window will\r\n// be closed automatically when the JavaScript object is garbage collected.\r\nlet mainWindow, tray\r\n\r\nlet trayMenu = Menu.buildFromTemplate([\r\n  { label: 'Item 1' },\r\n  { role: 'quit' }\r\n])\r\n\r\nfunction createTray() {\r\n\r\n  tray = new Tray('trayTemplate@2x.png')\r\n  tray.setToolTip('Tray details')\r\n\r\n  tray.on('click', e => {\r\n\r\n    if (e.shiftKey) {\r\n      app.quit()\r\n    } else {\r\n      mainWindow.isVisible() ? mainWindow.hide() : mainWindow.show()\r\n    }\r\n  })\r\n\r\n  tray.setContextMenu(trayMenu)\r\n}\r\n\r\n// Create a new BrowserWindow when `app` is ready\r\nfunction createWindow () {\r\n\r\n  createTray()\r\n\r\n  mainWindow = new BrowserWindow({\r\n    width: 1000, height: 800,\r\n    webPreferences: { nodeIntegration: true }\r\n  })\r\n\r\n  // Load index.html into the new BrowserWindow\r\n  mainWindow.loadFile('index.html')\r\n\r\n  // Open DevTools - Remove for PRODUCTION!\r\n  mainWindow.webContents.openDevTools();\r\n\r\n  // Listen for window being closed\r\n  mainWindow.on('closed',  () => {\r\n    mainWindow = null\r\n  })\r\n}\r\n\r\n// Electron `app` is ready\r\napp.on('ready', createWindow)\r\n\r\n// Quit when all windows are closed - (Not macOS - Darwin)\r\napp.on('window-all-closed', () => {\r\n  if (process.platform !== 'darwin') app.quit()\r\n})\r\n\r\n// When app icon is clicked and app is running, (macOS) recreate the BrowserWindow\r\napp.on('activate', () => {\r\n  if (mainWindow === null) createWindow()\r\n})\r\n```\r\n\r\n## 5、渲染进程\r\n\r\n### 5.1 clipboard\r\n\r\n> 在系统剪贴板上进行复制和粘贴操作。\r\n>\r\n> 在主进程（main process）和渲染进程（renderer process）上均可用。\r\n\r\n#### 5.1.1 `readText()`\r\n\r\n返回字符串 - 剪贴板中的内容为纯文本。\r\n\r\n```js\r\nconst { clipboard } = require('electron')\r\n\r\nclipboard.writeText('千锋教育HTML5大前端!')\r\n\r\nconst text = clipboard.readText()\r\nconsole.log(text)\r\n// hello i am a bit of text!'\r\n```\r\n\r\n#### 5.1.2 `writeText(text)`\r\n\r\n将文本作为纯文本写进剪贴板。\r\n\r\n### 5.2 contextBridge\r\n\r\n> 创建一个安全的、双向的、跨越隔离情境的同步桥梁。\r\n>\r\n> 只在渲染进程（renderer pocess）中可用。\r\n\r\n### 5.3 desktopCapturer\r\n\r\n>使用 navigator.mediaDevices.getUserMedia API 访问可用于从桌面捕获音频和视频的媒体源信息。\r\n>\r\n>只在主进程（main process）可用。\r\n\r\n下面的例子显示了如何从一个标题为Electron的桌面窗口捕捉图像:\r\n\r\n- 在主进程里\r\n\r\n```js\r\n// ./controller/getSource.js\r\nconst { desktopCapturer, ipcMain } = require('electron')\r\n\r\nconst getSource = (mainWindow) => {\r\n  ipcMain.handle('desktop-capturer', async (event) => {\r\n    desktopCapturer.getSources({ \r\n      types: ['window', 'screen'],\r\n      thumbnailSize: {\r\n        width: 1728,\r\n        height: 1117\r\n      }\r\n    }).then(async sources => {\r\n      for (const source of sources) {\r\n        if (source.name === 'Entire Screen') {\r\n          mainWindow.webContents.send('SET_SOURCE', source)\r\n          return\r\n        }\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nmodule.exports = getSource\r\n\r\n// ./main.js\r\ngetSource(win)\r\n```\r\n\r\n- 在预处理JS里\r\n\r\n```js\r\n// ./preload-js/setSource.js\r\nconst { ipcRenderer } = require('electron')\r\n\r\nconst setSource = () => {\r\n  return new Promise((resolve) => {\r\n    ipcRenderer.on('SET_SOURCE', async (event, source) => {\r\n      let str = source.thumbnail.crop({ x: 0, y: 30, width: 1200, height: 1170 })\r\n      resolve(str.toDataURL())\r\n    })\r\n  })\r\n}\r\n\r\nconst invokeCaptureEvent = async () => {\r\n  const result = await ipcRenderer.invoke('desktop-capturer')\r\n  return result\r\n}\r\n\r\nmodule.exports = {\r\n  setSource,\r\n  invokeCaptureEvent\r\n}\r\n\r\n// ./preload-js/index.js\r\nconst { setSource, invokeCaptureEvent } = require('./setSource')\r\ncontextBridge.exposeInMainWorld('myAPI', {\r\n  setSource,\r\n  invokeCaptureEvent\r\n})\r\n```\r\n\r\n- 在渲染进程页面里\r\n\r\n```js\r\nconst app = Vue.createApp({\r\n  template: `\r\n    <div>\r\n      <button @click=\"captureDesk\">抓取桌面</button>\r\n    </div>\r\n    <div>\r\n      <img :src=\"imgSrc\" alt=\"\" />\r\n    </div>\r\n  `,\r\n\r\n  data() {\r\n    return {\r\n      imgSrc: ''\r\n    }\r\n  },\r\n\r\n  methods: {\r\n    async captureDesk() {\r\n      const result = await myAPI.invokeCaptureEvent()\r\n    }\r\n  },\r\n\r\n  async beforeCreate() {\r\n    let imgDataUrl = await myAPI.setSource()\r\n    this.imgSrc = imgDataUrl\r\n  },\r\n})\r\n\r\napp.mount('#root')\r\n```\r\n\r\n### 5.4 ipcRenderer\r\n\r\n>从一个渲染器进程到主进程的异步通信。\r\n>\r\n>只在渲染进程（renderer pocess）中可用。\r\n\r\n### 5.5 nativeImage\r\n\r\n>使用PNG或JPG文件创建托盘、停靠区和应用程序图标。\r\n>\r\n>在主进程（main process）和渲染进程（renderer process）上均可用。\r\n\r\n在Electron中，对于接受图像的API，你可以传递文件路径或NativeImage实例。当传递null时，将使用一个空的图像。\r\n\r\n例如，在创建一个托盘或设置一个窗口的图标时，你可以把图像文件路径作为一个字符串传递。\r\n\r\n```js\r\nconst { BrowserWindow, Tray } = require('electron')\r\n\r\nconst appIcon = new Tray('/Users/somebody/images/icon.png')\r\nconst win = new BrowserWindow({ icon: '/Users/somebody/images/window.png' })\r\nconsole.log(appIcon, win)\r\n```\r\n\r\n或者从剪贴板上读取图像，返回一个NativeImage。\r\n\r\n```js\r\nconst { clipboard, Tray } = require('electron')\r\nconst image = clipboard.readImage()\r\nconst appIcon = new Tray(image)\r\nconsole.log(appIcon)\r\n```\r\n\r\n#### 5.5.1 支持的格式\r\n\r\n目前支持PNG和JPEG图像格式。建议使用PNG，因为它支持透明度和无损压缩。\r\n\r\n在Windows上，你也可以从文件路径加载ICO图标。为了获得最佳的视觉质量，建议至少包括以下尺寸的文件。\r\n\r\n- Small icon\r\n  - 16x16 (100% DPI scale)\r\n  - 20x20 (125% DPI scale)\r\n  - 24x24 (150% DPI scale)\r\n  - 32x32 (200% DPI scale)\r\n- Large icon\r\n  - 32x32 (100% DPI scale)\r\n  - 40x40 (125% DPI scale)\r\n  - 48x48 (150% DPI scale)\r\n  - 64x64 (200% DPI scale)\r\n  - 256x256\r\n\r\n#### 5.5.2 高分辨率图像\r\n\r\n在支持高DPI的平台上，如苹果Retina显示器，你可以在图像的基本文件名后附加@2x来标记它为高分辨率的图像。\r\n\r\n例如，如果icon.png是一个具有标准分辨率的普通图像，那么icon@2x.png，将被视为具有双倍DPI密度的高分辨率图像。\r\n\r\n如果你想同时支持不同DPI密度的显示器，你可以把不同尺寸的图像放在同一个文件夹里，使用不带DPI后缀的文件名。例如:\r\n\r\n```js\r\nimages/\r\n├── icon.png\r\n├── icon@2x.png\r\n└── icon@3x.png\r\n```\r\n\r\n```js\r\nconst { Tray } = require('electron')\r\nconst appIcon = new Tray('/Users/somebody/images/icon.png')\r\nconsole.log(appIcon)\r\n```\r\n\r\n还支持以下DPI的后缀:\r\n\r\n```js\r\n@1x\r\n@1.25x\r\n@1.33x\r\n@1.4x\r\n@1.5x\r\n@1.8x\r\n@2x\r\n@2.5x\r\n@3x\r\n@4x\r\n@5x\r\n```\r\n\r\n#### 5.5.3 方法\r\n\r\n- ### `nativeImage.createEmpty()`\r\n\r\n- ### `nativeImage.createFromPath(path)`\r\n\r\n返回 `NativeImage`\r\n\r\n从位于路径的文件中创建一个新的NativeImage实例。如果路径不存在，不能被读取，或者不是一个有效的图像，该方法将返回一个空图像。\r\n\r\n```js\r\nconst nativeImage = require('electron').nativeImage\r\n\r\nconst image = nativeImage.createFromPath('/Users/somebody/images/icon.png')\r\nconsole.log(image)\r\n```\r\n\r\n- ### `nativeImage.createFromDataURL(dataURL)`\r\n\r\n#### 5.5.4 Class: NativeImage\r\n\r\n自然地包裹图像，如托盘、停靠区和应用程序图标。\r\n\r\n\r\n在主进程（main process）和渲染进程（renderer process）上均可用。\r\n\r\n实例方法:\r\n\r\n- #### `image.toPNG([options])`\r\n\r\n- #### `image.toJPEG(quality)`\r\n\r\n- #### `image.toDataURL([options])`\r\n\r\n- #### `image.getSize([scaleFactor])`\r\n\r\n- #### `image.crop(rect)`\r\n\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>\r\n"},{"shortInfo":{"title":"ES6-ES11新特性学习笔记","date":"2022-09-04T04:00:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["ES6","javaScript"],"hideAtIndex":true,"categories":"笔记","id":3683242962,"countWords":7032,"readSeconds":703.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# ES6-ES11新特性学习笔记\r\n## 目录\r\n- [ES6-ES11新特性学习笔记](#es6-es11新特性学习笔记)\r\n  - [目录](#目录)\r\n  - [概念](#概念)\r\n  - [ES6-let](#es6-let)\r\n  - [ES6-const](#es6-const)\r\n  - [ES6-解构赋值](#es6-解构赋值)\r\n  - [ES6-模板字符串](#es6-模板字符串)\r\n  - [ES6-简化对象写法](#es6-简化对象写法)\r\n  - [ES6-箭头函数](#es6-箭头函数)\r\n  - [ES6-函数形式参数初值](#es6-函数形式参数初值)\r\n  - [ES6-函数的rest剩余参数(...)](#es6-函数的rest剩余参数)\r\n  - [ES6-spread扩展运算符(...)](#es6-spread扩展运算符)\r\n  - [ES6-Symbol](#es6-symbol)\r\n  - [ES6-迭代器(Iterator)](#es6-迭代器iterator)\r\n  - [ES6-生成器](#es6-生成器)\r\n  - [ES6-Promise](#es6-promise)\r\n  - [ES6-Set集合](#es6-set集合)\r\n  - [ES6-Map](#es6-map)\r\n  - [ES6-Class](#es6-class)\r\n  - [ES6-新的数值方法](#es6-新的数值方法)\r\n  - [ES6-新的对象方法](#es6-新的对象方法)\r\n  - [ES6-模块化](#es6-模块化)\r\n  - [ES7-新运算符`**`](#es7-新运算符)\r\n  - [ES7-数组对象新方法`listA.includes()`](#es7-数组对象新方法listaincludes)\r\n  - [ES8-`async`/`await`](#es8-asyncawait)\r\n  - [ES8-`Obj.eys()`/`values()`/`entries()`](#es8-objeysvaluesentries)\r\n  - [ES9-针对于对象的`...`扩展运算符](#es9-针对于对象的扩展运算符)\r\n  - [ES9-正则-提取内容新方法](#es9-正则-提取内容新方法)\r\n  - [ES9-正则-反向断言](#es9-正则-反向断言)\r\n  - [ES9-正则-dotAll模式](#es9-正则-dotall模式)\r\n  - [ES10-二维数组或Map转对象](#es10-二维数组或map转对象)\r\n  - [ES10-trimStart,trimEnd](#es10-trimstarttrimend)\r\n  - [ES10-flat,flatMap](#es10-flatflatmap)\r\n  - [ES10-`Symbol.prototype.description`](#es10-symbolprototypedescription)\r\n  - [ES11-类的私有属性](#es11-类的私有属性)\r\n  - [ES11-Promise.allSettled()](#es11-promiseallsettled)\r\n  - [ES11-`String.prototype.matchAll()`](#es11-stringprototypematchall)\r\n  - [ES11-`?.`可选链操作符](#es11-可选链操作符)\r\n  - [ES11-动态`import()`](#es11-动态import)\r\n  - [ES11-BigInt大整型](#es11-bigint大整型)\r\n  - [ES11-globalThis](#es11-globalthis)\r\n\r\n\r\n## 概念\r\n**用处**\r\n* 语法简洁 功能丰富\r\n* `vue` `react` 框架开发中大量使用ES6语法\r\n* 岗位要求\r\n\r\n\r\n## ES6-let\r\n**声明格式**\r\n```js\r\nlet a;\r\nlet a,b,c;\r\nlet a=1,b=2,c=3;\r\n```\r\n**特性:**\r\n**1.块级作用域**\r\n```js\r\nvar a=1\r\n{//for if\r\n    let a=2;\r\n}\r\nconsole.log(a);// 输出1\r\n```\r\n\r\n**2. 不存在变量提升**\r\n```js\r\n//var\r\nconsole.log(a) //a为undefine\r\nvar a=123\r\n\r\n//let\r\nconsole.log(a) //报错:声明错误\r\nlet a=123\r\n```\r\n\r\n**3. 不影响作用域链**\r\n```js\r\n{\r\n    let a=1;\r\n    function(){\r\n        console.log(a) //能正常访问a\r\n    }\r\n}\r\n```\r\n\r\n**4. 不能重复声明**\r\n```js\r\nlet a=1;\r\nlet b=2;\r\n```\r\n\r\n**案例**\r\n```js\r\nfor(var i=0;i<10;i++)\r\n{\r\n    items[i].onclick = function(){\r\n        console.log(i)//i的值始终为10\r\n    }\r\n}\r\n\r\nfor(let i=0;i<10;i++)\r\n{\r\n    items[i].onclick = function(){\r\n        console.log(i)//i的值为其所在循环的值\r\n    }\r\n}\r\n```\r\n\r\n\r\n## ES6-const\r\n**声明格式**\r\n```js\r\nconst TEST = \"123\"\r\n```\r\n\r\n**注意事项**\r\n1. 必须赋初值\r\n2. 一般常量名大写\r\n3. 常量值不能修改,但能对数组的元素或对象的属性值修改,因为常量指向的地址没有发生改变\r\n4. 是块级作用于 \r\n\r\n\r\n## ES6-解构赋值\r\n**数组的解构赋值**\r\n```js\r\nvar test = [1,2,3,4]\r\nvar [a,b,c,d] = test\r\nconsole.log(a)\r\nconsole.log(b)\r\nconsole.log(c)\r\nconsole.log(d)\r\n```\r\n\r\n**对象的解构赋值**\r\n```js\r\nvar test = {a:1,b:2,c:3}\r\nvar {a,b,c} = test\r\n\r\nconsole.log(a)\r\nconsole.log(b)\r\nconsole.log(c)\r\n```\r\n\r\n\r\n## ES6-模板字符串\r\n**语法**\r\n```js\r\nvar test =`这是一个用反引号包裹的字符串`\r\n```\r\n\r\n**特性**\r\n1. 内容中可直接换行\r\n2. 内容中可直接拼接变量\r\n    ```js\r\n    var str = \"hhhhhhhhhhhhh\"\r\n    var test =`\r\n    <ul>\r\n        <li>12313123</li>\r\n        <li>12313123</li>\r\n        <li>12313123</li>\r\n        <li>${str}</li>\r\n    </ul>\r\n    `\r\n    ```\r\n\r\n## ES6-简化对象写法\r\n**语法**\r\n```js\r\nvar test1=1,test2=2,test3=3;\r\n\r\nvar obj1={\r\n    test1:test1,\r\n    test2:test2,\r\n    test3:test3,\r\n    test4:function(){\r\n        console.log(\"hhh\")\r\n    }\r\n}\r\n\r\nvar obj2 ={//obj1 和 obj2 写法等效\r\n    test1,\r\n    test2,\r\n    test3,\r\n    test4(){\r\n        console.log(\"hhh\")\r\n    }\r\n}\r\n```\r\n\r\n## ES6-箭头函数\r\n**语法**\r\n```js\r\nvar test1 = function(){\r\n    console.log(\"123\")\r\n}\r\n\r\nvar test2 = ()=>{ //test1 和 test2 等效\r\n    console.log(\"123\")\r\n}\r\n\r\n```\r\n\r\n\r\n**特性**\r\n1. this是静态的，始终指向函数声明时所在作用域的this的值\r\n2. 不能作为构造函数来示例化对象\r\n3. 箭头函数内不能使用arguments变量\r\n4. 当形式参数只有一个时可以省略小括号\r\n5. 当代码体只有一条语句时可省略大括号，函数的返回值为语句v的返回值，且return也必须省略。\r\n   ```js\r\n   let pow = x => x*x\r\n   console.log(pow(2)) //4\r\n   ```\r\n\r\n**案例1**\r\n```js\r\nad.addEventListener(\"click\",function(){\r\n    //由于this指向window，将报错\r\n    // setTimeout(function(){\r\n    //     this.style.background = \"pink\" \r\n    // },1000)\r\n\r\n    setTimeout(()=>{\r\n        this.style.background = \"pink\" //this指向ad 不报错\r\n    },1000)\r\n})\r\n```\r\n\r\n**案例2:筛选偶数**\r\n```js\r\n//不使用箭头函数\r\nconst arr =[1,2,3,4,5,6,7]\r\nconst result = arr.filter(function(item){\r\n    if(item%2==0) return true\r\n    else return false;\r\n})\r\nconsole.log(result)\r\n\r\n\r\n\r\n//使用箭头函数\r\nconst arr =[1,2,3,4,5,6,7]\r\nconst result = arr.filter(item => item%2==0 )\r\nconsole.log(result)\r\n```\r\n\r\n**总结**\r\n箭头函数适合与this无关的回调：定时器，数组的方法回调\r\n箭头函数不适合与this有关的回调：事件回调，对象方法\r\n\r\n\r\n## ES6-函数形式参数初值\r\n**语法**\r\n```js\r\nfunction add(a=0,b=0,c=0){\r\n    return a+b+c\r\n}\r\n```\r\n\r\n**特性**\r\n1. 有默认值的形式参数位置靠后\r\n2. 可以和结构赋值结合使用\r\n\r\n```js\r\nfunction connect({host=\"1270.0.0.1\",username=\"root\",password=\"root\",port=3394}){\r\n    console.log(host)\r\n    console.log(username)\r\n    console.log(password)\r\n    console.log(port)\r\n}\r\n\r\nconnect({\r\n    host: \"localhost\",\r\n    username: \"root\",\r\n    password: \"root\",\r\n    port: \"3394\",\r\n})\r\n```\r\n\r\n\r\n## ES6-函数的rest剩余参数(...)\r\n\r\n```js\r\nfunction f1(a,b,c){\r\n    console.log(arguments) //arguments是伪数组,存有所有参数\r\n}\r\nf1(1,2,3,4,5,6)\r\n\r\n\r\nvar f2 = (a,b,c,...rest)=>{//(rest可以是其他变量名)\r\n    console.log(rest) //rest 是真的数组，存有剩余的参数\r\n}\r\nf2(1,2,3,4,5,6)\r\n```\r\n\r\n\r\n## ES6-spread扩展运算符(...)\r\n扩展运算符(...)会调用默认的 `Iterator` 接口\r\n\r\n**基本使用**\r\n```js\r\nvar list = [\"123\",\"321\",\"456\"]\r\n\r\nfun1(list) //等效于 fun1([\"123\",\"321\",\"456\"])\r\n\r\nfun2(...list) //等效于 fun2(\"123\",\"321\",\"456\")\r\n```\r\n\r\n**应用**\r\n1. 数组合并\r\n   ```js\r\n   const a=[1,2,3]\r\n   const b=[4,5,6]\r\n   const c=[...a,...b] //c:[1,2,3,4,5,6]\r\n   ```\r\n2. 数组拷贝\r\n   ```js\r\n   const a=[\"A\",\"B\",\"C\"]\r\n   const b=[...a]           //浅拷贝\r\n   ```\r\n\r\n3. 伪数组转换真数组\r\n   ```js\r\n   const divs = document.querrySelectorAll(\"div\")\r\n   const divArr = [...divs]\r\n   ```\r\n\r\n\r\n## ES6-Symbol\r\n**概念**\r\n* Symbol是ES6引入的新的数据类型,不能用 new 命令，因为其不是对象。\r\n* 表示独一无二的值,最大的用法是用来定义对象的唯一属性名\r\n* ES6 数据类型\r\n  * Number  \r\n  * String  \r\n  * Boolean  \r\n  * Object \r\n  * null \r\n  * undefined \r\n  * **Symbol**\r\n\r\n**特点**\r\n* 值唯一,用于解决命名冲突的问题\r\n* 不能与其他数据类型运算\r\n* 不能使用for in 遍历,但可以使用Reflect.ownkeys获取对象的所有键名\r\n\r\n**一些内置属性(共11个)**\r\n* Symbol.match\r\n* Symbol.isConcatSpreadable\r\n\r\n```js\r\nlet s1 = Symbol();\r\nlet s2 = Symbol(\"标志名称\");\r\nlet s3 = Symbol(\"标志名称\");        // s2 !=  s3\r\n\r\nlet s4 = Symbol.for(\"标志名称2\")    // 由.for()这种函数创建的symbol称为函数对象\r\nlet s5 = Symbol.for(\"标志名称2\")    // s4 == s5\r\n```\r\n\r\n\r\n**案例1**\r\n```js\r\nconst game = {\r\n    up : function(){ console.log(\"up\") },\r\n    down : function(){ console.log(\"down\") }\r\n}\r\nconst myMethods = {\r\n    up:Symbol(\"myUp\"),\r\n    down:Symbol(\"myDown\")\r\n}\r\n\r\n\r\ngame[myMethods.up] = function(){ console.log(\"myUp\") }\r\ngame[myMethods.down] = function(){ console.log(\"myDown\") }\r\n\r\nconsole.log(game)\r\n// 输出:\r\n// {\r\n//   up: [Function: up],\r\n//   down: [Function: down],\r\n//   [Symbol(myUp)]: [Function],\r\n//   [Symbol(myDown)]: [Function]\r\n// }\r\n```\r\n\r\n**案例2**\r\n```js\r\nconst game = {\r\n    up : function(){ console.log(\"up\") },\r\n    down : function(){ console.log(\"down\") },\r\n    [Symbol(\"myUp\")]:function(){ console.log(\"myUp\") }, //这样定义后似乎无法调用\r\n    [Symbol(\"myDown\")]:function(){ console.log(\"myDown\") },\r\n}\r\nconsole.log(game)\r\n\r\n// > console.log(game)\r\n// 输出:\r\n// {\r\n//   up: [Function: up],\r\n//   down: [Function: down],\r\n//   [Symbol(myUp)]: [Function: [myUp]],\r\n//   [Symbol(myDown)]: [Function: [myDown]]\r\n// }\r\n```\r\n\r\n## ES6-迭代器(Iterator)\r\n**主要用于遍历元素,实现原理和python中的yield类似**\r\n* 可自定义遍历数据\r\n* 迭代器提供的接口可供 `for [item] of [obj]` 使用\r\n* 原生具备迭代器接口的数据类型\r\n  * Arrary\r\n  * Arguments\r\n  * Set\r\n  * Map\r\n  * String\r\n  * TypedArray\r\n  * NodeList\r\n\r\n```js\r\nvar listA = [\"111\",\"222\",\"333\"]\r\n\r\n\r\n// let iterator = listA[Symbol.iterator]();\r\n// console.log(iterator.next())// next第一次指向第一个元素,第二次调用指向第二个元素...\r\n\r\n\r\nfor(let item of listA){\r\n    console.log(item) \r\n    //输出结果为\r\n    // \"111\"\r\n    // \"222\"\r\n    // \"333\"\r\n}\r\n\r\nfor(let key of listA){\r\n    console.log(key) \r\n    //输出结果为\r\n    // 0\r\n    // 1\r\n    // 2\r\n}\r\n```\r\n\r\n**自定义遍历数据**\r\n```js\r\nvar classA = {\r\n    name: \"1234班\",\r\n    students: [\r\n        \"小明\",\r\n        \"小红\",\r\n        \"小黄\",\r\n        \"小蓝\",\r\n        \"小绿\",\r\n        \"小白\",\r\n    ],\r\n    [Symbol.iterator]: function () {//不能使用剪头函数,否则this指向window\r\n        let index = 0;\r\n        return {\r\n            next: () => {\r\n                if (index < this.students.length) {\r\n                    return { value: this.students[index++], done: false }\r\n                } else {\r\n                    return { value: undefined, done: true }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfor (item of classA) {\r\n    console.log(item)\r\n}\r\n```\r\n\r\n\r\n## ES6-生成器\r\n**主要用于异步编程**\r\n\r\n**特性演示**\r\n```js\r\nfunction * test1(){\r\n    for (let index = 0; index < 100; index++) {\r\n        if(index%2==1)\r\n            yield index;\r\n    }\r\n}\r\n// const iterator = test1()\r\n    //test1()返回值是一个生成器对象\r\n\r\n// console.log(iterator.next());\r\n    // 输出:\r\n    // {value:1,done:false}\r\n\r\n// console.log(iterator.next().value);\r\n    // 输出:\r\n    // 1\r\n\r\nfor (item of test1()) {\r\n    console.log(item) \r\n    //输出:\r\n    // 1\r\n    // 3\r\n    // 5\r\n    // ... ...\r\n}\r\n```\r\n\r\n\r\n**参数传递**\r\n```js\r\nfunction * test2(arg1){\r\n    console.log(arg1)\r\n\r\n    var result = yield \"1111\"; \r\n    console.log(result)\r\n    \r\n    var result = yield \"2222\";\r\n    console.log(result)\r\n\r\n    var result = yield \"3333\";\r\n    console.log(result)\r\n}\r\n\r\nconst iterator = test2(\"AAA\")\r\n\r\nconsole.log(iterator.next(\"BBB\").value); // \"BBB\"将不会输出\r\nconsole.log(iterator.next(\"CCC\").value); //next的形式参数会作为前一个yield语句的返回值\r\nconsole.log(iterator.next(\"DDD\").value); //\"DDD\"将会作为 yield \"1111\" 的返回值\r\n```\r\n\r\n\r\n**异步编程案例**\r\n```js\r\nfunction A(){\r\n    setTimeout(() => {\r\n        console.log(\"111\");\r\n        iterator.next()\r\n    }, 1000);\r\n}\r\nfunction B(){\r\n    setTimeout(() => {\r\n        console.log(\"222\");\r\n        iterator.next()\r\n    }, 1000);\r\n}\r\nfunction C(){\r\n    setTimeout(() => {\r\n        console.log(\"333\");\r\n        iterator.next()\r\n    }, 1000);\r\n}\r\nfunction * test3(){\r\n    yield A()\r\n    yield B()\r\n    yield C()\r\n}\r\n\r\nconst iterator = test3()\r\n\r\niterator.next()\r\n//输出:\r\n// 111\r\n// 222\r\n// 333\r\n```\r\n\r\n\r\n**实际案例模拟**\r\n```js\r\nfunction getUserInfo(){\r\n    setTimeout(() => {\r\n        let UserInfo = \"用户信息\"\r\n        console.log(\"成功获取: \"+UserInfo);\r\n        iterator.next(UserInfo)\r\n    }, 1000);\r\n}\r\nfunction getOrders(){\r\n    setTimeout(() => {\r\n        let ordersInfo = \"用户订单\"\r\n        console.log(\"成功获取: \"+ordersInfo);\r\n        iterator.next(ordersInfo)\r\n    }, 1000);\r\n}\r\nfunction getGoods(){\r\n    setTimeout(() => {\r\n        let goodsInfo = \"订单商品\"\r\n        console.log(\"成功获取: \"+goodsInfo);\r\n        iterator.next(goodsInfo)\r\n    }, 1000);\r\n}\r\nfunction * test4(){\r\n    let UserInfo = yield getUserInfo() //获取用户信息\r\n    let ordersInfo = yield getOrders(UserInfo) //根据用户信息获取订单信息\r\n    let goodsInfo = yield getGoods(ordersInfo) //根据订单信息获取商品信息\r\n}\r\n\r\nconst iterator = test4()\r\niterator.next()\r\n    // 输出结果:\r\n    // 成功获取: 用户信息\r\n    // 成功获取: 用户订单\r\n    // 成功获取: 订单商品\r\n```\r\n\r\n\r\n## ES6-Promise\r\n**详细笔记见《Promise学习笔记》**\r\n\r\n**基本使用**\r\n```js\r\nconst a = new Promise((resolve,reject)=>{\r\n    setTimeout(()=>{\r\n        var data = \"从服务器获取数据\" \r\n        resolve(data)\r\n    },1000)\r\n}) \r\n\r\na.then(value=>{\r\n    console.log(value)\r\n},reason=>{\r\n    console.log(reason)\r\n})\r\n```\r\n\r\n## ES6-Set集合\r\nSet类型类似于数组,但其成员的值是唯一的,不会有重复的属性值  \r\nSet类型支持扩展运算符`...`  \r\nSet类型实现了 `iterator` 接口,可以通过 `for(A of B){}` 遍历\r\n**内置方法和属性**\r\n* size\r\n* add()\r\n* delete()\r\n* has()\r\n* clear()\r\n\r\n```js\r\nlet setA = new Set()\r\nconsole.log(setA) //Set(0){}\r\n\r\n\r\n// let setB = new Set(可迭代的数据)\r\nlet setB = new Set([1,2,3,4,5,6,7,7,7,7,7,\"8\"])\r\nconsole.log(setB) //Set(8){1,2,3,4,5,6,7,\"8\"}\r\n\r\n\r\nconsole.log(setB.size) //集合元素个数\r\nsetB.add(\"9\") //新增元素\r\nsetB.delete(\"9\") //删除元素\r\nsetB.has(1) //检测元素\r\n// setB.clear() //清空集合元素\r\n\r\nfor(item of setB){\r\n    console.log(item)\r\n}\r\n```\r\n\r\n\r\n**实用案例**\r\n```js\r\n// 数组去重\r\nvar listA = [1,2,3,4,5,6,7,8,1,1,1,2,2,2,3,3,3,4,4,4,5]\r\nvar result1 = [...new Set(listA)]\r\nconsole.log(result1);\r\n\r\n\r\n//交集运算\r\nvar ListB = [1,2,3,4,5,6,6,6,6,6]\r\nvar ListC = [4,5,6,7,8,9,9,9,9,9]\r\nvar result2 = [...new Set(ListB)].filter(item => ( new Set(ListC) ).has(item))\r\nconsole.log(result2)\r\n\r\n\r\n//并集运算\r\nvar ListD = [1,2,3,4,5,6,6,6,6,6]\r\nvar ListE = [4,5,6,7,8,9,9,9,9,9]\r\nvar result3 = [...new Set([...ListD,...ListE])]\r\nconsole.log(result3)\r\n\r\n\r\n//差集 \r\nvar ListF = [1,2,3,4,5,6,6,6,6,6]\r\nvar ListE = [4,5,6,7,8,9,9,9,9,9]\r\nvar result4 = [...new Set(ListF)].filter(item => !( new Set(ListE) ).has(item)) //F和E的差集\r\nvar result5 = [...new Set(ListE)].filter(item => !( new Set(ListF) ).has(item)) //E和F的差集\r\nconsole.log(result4)\r\nconsole.log(result5)\r\n```\r\n\r\n\r\n## ES6-Map\r\nMap类型类似于对象,是键值对的集合,但其\"键\"不只是字符串,各种数据类型甚至是对象都能作为\"键\"  \r\nMap类型支持扩展运算符`...`   \r\nMap类型实现了 `iterator` 接口,可以通过 `for(A of B){}` 遍历\r\n**内置方法和属性**\r\n* size\r\n* set(key,value)\r\n* get(key)\r\n* delete(key)\r\n* has(key)\r\n* clear()\r\n* ......\r\n\r\n\r\n```js\r\n// let MapA = new Map([[A,B],[C,D],[E,F]])\r\nlet MapA = new Map()\r\nconsole.log(MapA.set(\"123\",321))\r\nconsole.log(MapA.get(\"123\"))\r\nconsole.log(MapA.has(\"123\"))\r\nconsole.log(MapA.delete(\"123\"))\r\nconsole.log(MapA.clear())\r\n```\r\n\r\n\r\n## ES6-Class\r\n\r\n通过ES6的class关键字可以定义对象,但其绝大部分功能都可通过ES5的语法实现(构造函数,this关键字),新写法只是让其看起来更像面向对象编程\r\n\r\n**基本用法**\r\n```js\r\nclass Cat {\r\n    constructor(name, sex) {\r\n        this.name = name\r\n        this.sex = sex\r\n    }\r\n    bark() {\r\n        console.log(\"喵喵喵\")\r\n    }\r\n}\r\n\r\nnew Cat(\"小黄猫\", \"公猫\").bark() //输出: 喵喵喵\r\nconsole.log(new Cat(\"小黄猫\", \"公猫\").sex) //输出5\r\n```\r\n\r\n\r\n**static静态属性和成员**\r\n```js\r\n// **ES5原版写法**\r\n\r\n//构造函数\r\nfunction Dog(name, sex) {\r\n    this.name = name\r\n    this.sex = sex\r\n}\r\n//为构造函数对象添加方法/属性(静态属性)\r\nDog.age = 1\r\nDog.bark = function () {\r\n    console.log(\"汪汪汪~~~\")\r\n}\r\n//为实例对象添加方法/属性\r\nDog.prototype.age = 5\r\nDog.prototype.bark = function () {\r\n    console.log(\"汪汪汪\")\r\n}\r\n\r\nnew Dog(\"小白狗\", \"公狗\").bark() //输出: 汪汪汪\r\nDog.bark() //输出: 汪汪汪~~~\r\nconsole.log(new Dog(\"小白狗\", \"公狗\").age) //输出5\r\nconsole.log(Dog.age)// 输出1\r\n```\r\n\r\n\r\n```js\r\n// **ES6新版写法写法**\r\nclass Cat {\r\n    static age = 1;\r\n    static bark = function () {\r\n        console.log(\"喵喵喵~~~\")\r\n    }\r\n    constructor(name, sex) {\r\n        this.name = name\r\n        this.sex = sex\r\n        this.age = 5;\r\n    }\r\n    bark() {\r\n        console.log(\"喵喵喵\")\r\n    }\r\n}\r\n\r\nnew Cat(\"小黄猫\", \"公猫\").bark() //输出: 喵喵喵\r\nconsole.log(new Cat(\"小黄猫\", \"公猫\").age) //输出5\r\nCat.bark() //输出: 喵喵喵~~~\r\nconsole.log(Cat.age) //输出1\r\n```\r\n\r\n\r\n**继承**\r\n\r\n```js\r\n// ES5特性的继承\r\nfunction Phone(brand, prise) {\r\n    this.brand = brand\r\n    this.prise = prise\r\n}\r\nPhone.prototype.tele = function () {//为实例化后的对象添加方法\r\n    console.log(\"call......\");\r\n}\r\n\r\n\r\nfunction SmartPhone(brand, prise, size, color) {\r\n    Phone.call(this, brand, prise) // 初始化父级对象\r\n    this.size = size\r\n    this.color = color\r\n}\r\n\r\n// 设置子级构造函数原型\r\nSmartPhone.prototype = new Phone //使得SmartPhone的实例对象拥有Phone实例对象上的属性和方法\r\nSmartPhone.prototype.constructor = SmartPhone //使得SmartPhone的实例对象的构造函数是SmartPhone() 而不是Phone()\r\n\r\nSmartPhone.prototype.playGame = function () {//为实例化后的对象添加方法\r\n    console.log(\"playGame......\")\r\n}\r\n\r\nvar huawei = new SmartPhone(\"华为\", 4799, \"12-inch\", \"黑色\")\r\nhuawei.tele()\r\nhuawei.playGame()\r\n```\r\n\r\n```js\r\n// ES6特性的继承\r\nclass Phone {\r\n    constructor(brand, prise) {\r\n        this.brand = brand\r\n        this.prise = prise\r\n    }\r\n    call() {\r\n        console.log(\"call......\");\r\n    }\r\n}\r\nclass SmartPhone extends Phone {\r\n    constructor(brand, prise, size, color) {\r\n        super(brand, prise)\r\n        this.size = size\r\n        this.color = color\r\n    }\r\n    playGame() {\r\n        console.log(\"playGame......\")\r\n    }\r\n}\r\n\r\n\r\nvar huawei = new SmartPhone(\"花为\", 4799, \"12-inch\", \"黑色\")\r\nhuawei.call()\r\nhuawei.playGame()\r\n```\r\n\r\n**重写父类方法**\r\n```js\r\n// ES6特性的继承\r\nclass Phone {\r\n    constructor(brand, prise) {\r\n        this.brand = brand\r\n        this.prise = prise\r\n    }\r\n    call() {\r\n        console.log(\"call......\");\r\n    }\r\n}\r\nclass SmartPhone extends Phone {\r\n    constructor(brand, prise, size, color) {\r\n        super(brand, prise)\r\n        this.size = size\r\n        this.color = color\r\n    }\r\n    playGame() {\r\n        console.log(\"playGame......\")\r\n    }\r\n    call() {\r\n        console.log(\"call2......\");//重写父类的方法\r\n    }\r\n}\r\n\r\nvar huawei = new SmartPhone(\"花为\", 4799, \"12-inch\", \"黑色\")\r\nhuawei.call()\r\nhuawei.playGame()\r\n```\r\n\r\n**get与set**\r\n```js\r\nclass Phone {\r\n    constructor(brand, prise) {\r\n        this.brand = brand\r\n        this.prise = prise\r\n    }\r\n    get value(){\r\n        console.log(\"获取了价格\")\r\n        return this.prise\r\n    }\r\n    set value(value){\r\n        console.log(\"设置了价格\")\r\n        this.prise = value\r\n    }\r\n}\r\n\r\nvar xiaomi = new Phone(\"xiaomi\",999)\r\nconsole.log(xiaomi.value);\r\nconsole.log(xiaomi.value=0.01);\r\n```\r\n\r\n\r\n## ES6-新的数值方法\r\n\r\n**`Number.EPSILON`浮点数最小精度**\r\n```js\r\nconsole.log(Number.EPSILON); //2.220446049250313e-16   2.22*10^(-16) 是js浮点数的最小精度单位 ,用于比较浮点数是否相等\r\n\r\nfunction equal(a,b){\r\n    return Math.abs(a-b) < Number.EPSILON\r\n}\r\n\r\nconsole.log(0.1+0.2); // 输出 0.30000000000000004\r\nconsole.log(0.1+0.2 == 0.3); // 输出 false\r\nconsole.log(equal(0.1+0.2 , 0.3)); // 输出 true\r\n```\r\n\r\n**二进制,八进制,十六进制**\r\n```js\r\nvar b = 0b1111\r\nvar o = 0o7777\r\nvar d = 999999\r\nvar x = 0xffff\r\n\r\nconsole.log(b); //输出: 15\r\nconsole.log(o); //输出: 4095\r\nconsole.log(d); //输出: 999999\r\nconsole.log(x); //输出: 65535\r\n```\r\n\r\n**判断有限数**\r\n```js\r\nconsole.log(Number.isFinite(1));        //输出: true\r\nconsole.log(Number.isFinite(1/0));      //输出: false\r\nconsole.log(Number.isFinite(Infinity)); //输出: false\r\n```\r\n\r\n**判断非数**\r\n```js\r\n//在es5中isNaN()是一个单独的函数,在ES6中将其作为了Number对象的方法\r\nconsole.log(Number.isNaN(123)); //输出: false\r\nconsole.log(Number.isNaN(NaN)); //输出: true\r\n```\r\n\r\n**判断整数**\r\n```js\r\nconsole.log(Number.isInteger(123)); //输出: true\r\nconsole.log(Number.isInteger(123.123)); //输出: false\r\n```\r\n\r\n**字符串转数字**\r\n```js\r\n//在ES6中将其作为了Number对象的方法,之前是一个单独的函数\r\nconsole.log(Number.parseFloat(\"3.1415元\")); //输出: 3.1415\r\nconsole.log(Number.parseInt(\"3.1415元\")); //输出: 3\r\n```\r\n\r\n**抹掉小数部分**\r\n```js\r\nconsole.log(Math.trunc(3.1415)); //输出: 3\r\n```\r\n\r\n\r\n**sign()函数**\r\n```js\r\nconsole.log(Math.sign(100));    //输出: 1\r\nconsole.log(Math.sign(0));      //输出: 0\r\nconsole.log(Math.sign(-100));   //输出: -1\r\n```\r\n\r\n## ES6-新的对象方法\r\n\r\n**`Object.is()`判断两个值是否完全相等**\r\n```js\r\n        console.log(Object.is(123,123));        //输出: true\r\n        console.log(Object.is(\"123\",\"123\"));    //输出: true\r\n        console.log(Object.is(NaN,NaN));        //输出: true\r\n        console.log(123 === 123);               //输出: true\r\n        console.log(\"123\" === \"123\");           //输出: true\r\n        console.log(NaN === NaN);               //输出: false\r\n```\r\n\r\n**`Object.assign(a,b)`合并对象**\r\n```js\r\nconst defaultConfg = {\r\n    host:\"localhost\",\r\n    port:80,\r\n    username:\"admin\",\r\n    password:\"admin\"\r\n}\r\nconst customConfg = {\r\n    port:8080,\r\n    username:\"dyg\",\r\n    password:\"123456\"\r\n}\r\n\r\nconst resultConfg = Object.assign(defaultConfg,customConfg)\r\nconsole.log(resultConfg);\r\n//输出:\r\n//{\r\n//     host:\"localhost\",\r\n//     port:8080,\r\n//     username:\"dyg\",\r\n//     password:\"123456\"\r\n// }\r\n```\r\n\r\n\r\n**获取/设置原型对象**\r\n```js\r\nconst objA = [\"123\",\"321\"]\r\nconst objB = [123,321]\r\nObject.setPrototypeOf(objA,objB) //也就是使得objA.__prpto___ 指向objB\r\nconsole.log(objA);\r\nconsole.log(Object.getPrototypeOf(objA));\r\n```\r\n\r\n\r\n\r\n## ES6-模块化\r\n**原先的社区版模块化规范**\r\n* commonJs规范标准 服务端标准 现实实现: nodejs Browserify \r\n* AMD规范标准 浏览器端标准 现实实现: requirejs \r\n* CMD规范标准 浏览器端标准 现实实现: seaJS \r\n\r\n**ES6模块化规范语法**\r\n* `export{XXX,XXX,XXX}` 导出模块接口\r\n* `import{XXX,XXX,XXX} from \"url\"` 导入模块接口,顺序无妨,名称需一致\r\n* `import{XXX as XXX} from \"url\"`   \r\n* `export default{XXX,XXX,XXX}` 向外暴露的成员，可以使用任意变量来接收,不需要`{}`。\r\n* `import AAA from \"url with default export\"` 导入\r\n\r\n**特点**\r\n* ES6 的模块**自动开启严格模式**，不管你有没有在模块头部加上 use strict;。\r\n* 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。\r\n\r\n**注意**\r\n要在nodejs中使用ES6模块化规范,要求在package.json中添加type:module\r\n\r\n**基本使用:导出**\r\n```js\r\n//第一种 按需导出\r\nexport var a = 123;\r\nexport function funA(){\r\n    console.log(\"111111111111111111111111\")\r\n}\r\n\r\n//第二种\r\nvar a = 123;\r\nfunction funA(){\r\n    console.log(\"111111111111111111111111\")\r\n}\r\nexport{a,funA}\r\n//或\r\nexport{abc:a,cde:funA}\r\n\r\n\r\n\r\n//第三种\r\nvar a = 123;\r\nfunction funA(){\r\n    console.log(\"111111111111111111111111\")\r\n}\r\nexport default{a,funA}\r\n```\r\n\r\n**基本使用:导入**\r\n```js\r\n//第一种 : 通用方式\r\nimport * as test1 from \"./_demo.js\" \r\n\r\n\r\n//第二种\r\nimport {a,funA} from \"./_demo.js\"  //名称需一致顺序无妨\r\nimport {a as a2,funA} from \"./_demo.js\"  //防止变量名冲突,使用as\r\n\r\n//第三种 : 导入默认赋值\r\nimport {default as temp1} from \"./_demo.js\"\r\n\r\n//第四种 : 导入默认赋值\r\nimport temp2 from \"./_demo.js\"\r\n\r\n//第五种 : 多种相结合\r\nimport temp2,{a as a2,funA} from \"./_demo.js\"\r\n```\r\n\r\n**注意**\r\n在script标签中写js代码，或者使用src引入js文件时，默认不能使用module形式，即不能使用import导入文件，\r\n需要再script标签上加上 `type=\"module\"`\r\n```html\r\n<script type=\"module\" src=\"./??\">\r\n</script>\r\n```\r\n\r\n\r\n## ES7-新运算符`**`\r\n```js\r\nconsole.log(2**10) //1024\r\n```\r\n\r\n## ES7-数组对象新方法`listA.includes()`\r\n```js\r\nvar listA = [\"AAA\",\"BBB\",\"CCC\"]\r\nconsole.log(listA.includes(\"CCC\"))  // true\r\n\r\n//旧版的判断元素是否存在\r\nvar listA = [\"AAA\",\"BBB\",\"CCC\"]\r\nconsole.log(listA.indexOf(\"CCC\"))  // 返回下标,若不存在则返回 -1 \r\n```\r\n\r\n## ES8-`async`/`await`\r\n* `async`修饰的函数的返回值为**promise对象**,promise对象的结果为函数`return`的值\r\n* `await`修饰一个promsie对象,\r\n\r\n\r\n\r\n\r\n**`async`修饰的函数**\r\n* 返回的是一个promise的对象\r\n* promise对象的值和状态\r\n  * 若函数直接return XXX; 则函数返回的promise对象的值为XXX,状态为成功 \r\n  * 若函数直接抛出错误; 则函数返回的promise对象的值为抛出的错误对象,状态为失败 \r\n  * 若函数return new Promise(???); 则函数返回的的promise对象的值和状态与return的promise状态一致\r\n```js\r\nasync function test() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            console.log(\"hhhhhhh\");\r\n            resolve(\"hhhhhhh\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nconsole.log(test());\r\n```\r\n\r\n**`await`修饰的语句**\r\n* `await` 必须写在 `async` 修饰的函数中,但 `async` 中不一定要包含 `await`\r\n* `await` 一般用于修饰一个promise对象 即 `await new Promise(略) `\r\n* `await`修饰的promise对象的状态为成功, 则表达式的值为promise对象的value值\r\n* `await`修饰的promise对象的状态为失败, 则表达式抛出错误,需 `try{}catch(err){}` 捕获\r\n\r\n\r\n```js\r\nasync function test1() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(\"111111\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function test2() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(\"222222\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function test3() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(\"333333\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function main() {\r\n    let a = await test1()\r\n    let b = await test2()\r\n    let c = await test3()\r\n    console.log(a+b+c); \r\n}\r\nmain()\r\n```\r\n\r\n**结合 `axios` `async` `awite`**\r\n```html\r\n<script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n<script>\r\n    async function main() {\r\n        let sentences = await axios.get(\"https://api.apiopen.top/api/sentences\")\r\n        console.log(sentences.data.result);\r\n    }\r\n    main()\r\n</script>\r\n```\r\n\r\n\r\n**执行顺序的问题**\r\n在async修饰的函数中,语句是在主线程中执行的,当遇到第一个await语句并执行完后,函数中的剩余语句将交给异步执行栈,而后函数将直接返回一个promsie对象,\r\n\r\n```js\r\nasync function test4() {\r\n    return new Promise((resolve, reject) => {\r\n        console.log(\"2222222222222222222222\");\r\n        setTimeout(() => {                          //该行代码将交由异步执行栈执行\r\n            console.log(\"4444444444444444444444\");\r\n            resolve(\"5555555555555555555555\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function main() {\r\n    console.log(\"1111111111111111111111\");\r\n    let d = await test4()                   //执行该行之后,后续代码交给异步执行栈执行,函数main直接return\r\n    console.log(d);\r\n}\r\n\r\nconsole.log(\"0000000000000000000000\");\r\nmain()\r\nconsole.log(\"3333333333333333333333\"); \r\n\r\n//输出结果\r\n//  0000000000000000000000\r\n//  1111111111111111111111\r\n//  2222222222222222222222\r\n//  3333333333333333333333\r\n//  4444444444444444444444\r\n//  5555555555555555555555\r\n```\r\n\r\n\r\n\r\n## ES8-`Obj.eys()`/`values()`/`entries()`\r\n* `Object.keys(testObj)` 获取所有键\r\n* `Object.values(testObj)` 获取所以值\r\n* `Object.entries(testObj)` 获取所有键值组成的列表\r\n* `Object.getOwnPropertyDescriptors(testObj)` 获取对象属性的描述对象\r\n```js\r\nlet testObj = {\r\n    key1: \"value1\",\r\n    key2: \"value2\",\r\n    key3: \"value3\",\r\n    key4: [1, 2, 3, 4, 5],\r\n}\r\n\r\nconsole.log(Object.keys(testObj));\r\n//输出: [key1,key2,key3,key4]\r\nconsole.log(Object.values(testObj));\r\n//输出: [value1,value2,value3,value4]\r\nconsole.log(Object.entries(testObj));\r\n/*\r\n    输出: \r\n    [\r\n        [\"key1\",\"value1\"],\r\n        [\"key2\",\"value2\"],\r\n        [\"key3\",\"value3\"],\r\n        [\"key4\",[1,2,3,4,5]]\r\n    ]\r\n*/\r\nconsole.log(Object.getOwnPropertyDescriptors(testObj));\r\n// 输出:\r\n// {\r\n//     \"key1\": {\r\n//         \"value\": \"value1\",\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     },\r\n//     \"key2\": {\r\n//         \"value\": \"value2\",\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     },\r\n//     \"key3\": {\r\n//         \"value\": \"value3\",\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     },\r\n//     \"key4\": {\r\n//         \"value\": [\r\n//             1,\r\n//             2,\r\n//             3,\r\n//             4,\r\n//             5\r\n//         ],\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     }\r\n// }\r\n```\r\n\r\n**结合map的应用**\r\n```js\r\nlet map = new Map(Object.entries(testObj))\r\nconsole.log(map);\r\n//  输出: Map(4) {'key1' => 'value1', 'key2' => 'value2', 'key3' => 'value3', 'key4' => Array(5)}\r\n```\r\n\r\n## ES9-针对于对象的`...`扩展运算符\r\nES6中的的扩展运算符是针对于数组的,ES9的新扩展运算是针对于对象的\r\n\r\n**用法**\r\n```js\r\n//用法1\r\nlet obj1 = {\r\n    key1: \"value1\",\r\n    key2: \"value2\",\r\n    key3: \"value3\",\r\n    key4: [1, 2, 3, 4, 5],\r\n}\r\nlet obj2 ={...obj1}\r\nconsole.log(obj2);\r\n\r\n\r\n```\r\n\r\n```js\r\n//用法2\r\nfunction test({host,port,...user}){\r\n    console.log(host);\r\n    console.log(port);\r\n    console.log(user);//剩余的属性都会成为user对象的属性\r\n    console.log(user.username);\r\n    console.log(user.password);\r\n}\r\ntest({\r\n    host:\"localhost\",\r\n    port:3306,\r\n    username:\"dyg\",\r\n    password:\"123456\",\r\n})\r\n```\r\n\r\n## ES9-正则-提取内容新方法\r\n**利用旧版标准提取字符串**\r\n```js\r\nlet str = `<a href=\"http://baidu.com\">百度</a>\"`\r\nconst reg = /<a href=\"(.*)\">(.*)<\\/a>/\r\nlet result = reg.exec(str)\r\nconsole.log(result);\r\n    //输出 :  ['<a href=\"http://baidu.com\">百度</a>', 'http://baidu.com', '百度']\r\nconsole.log(result[1]);\r\n    //输出 :  'http://baidu.com'\r\nconsole.log(result[2]);\r\n    //输出 :  '百度'\r\n```\r\n\r\n**利用新版标准提取字符串**\r\n```js\r\nlet str2 = `<a href=\"http://baidu.com\">百度</a>\"`\r\nconst reg2 = /<a href=\"(?<url>.*)\">(?<text>.*)<\\/a>/\r\nlet result2 = reg2.exec(str2)\r\nconsole.log(result2);\r\n    //输出 :  ['<a href=\"http://baidu.com\">百度</a>', 'http://baidu.com', '百度']\r\nconsole.log(result2.groups.url);\r\n    //输出 :  'http://baidu.com'\r\nconsole.log(result2.groups.text);\r\n    //输出 :  '百度'\r\n```\r\n\r\n## ES9-正则-反向断言\r\n```js\r\nlet str = `目标年新: 20W ¥`\r\n// 正向断言\r\nconst reg = /(?<salary>\\d+[a-zA-Z])(?= ¥)/   //提取出:[多个数字+单个字母+' ¥']中的[多个数字+单个字母]\r\nconst result = reg.exec(str)\r\nconsole.log(result.groups.salary); //输出20W\r\n\r\n\r\n//反向断言\r\nconst reg2 = /(?<=: )(?<salary>\\d+[a-zA-Z])/   //提取出:[': '+多个数字+单个字母]中的[多个数字+单个字母]\r\nconst result2 = reg2.exec(str)\r\nconsole.log(result2.groups  .salary); //输出20W\r\n```\r\n\r\n## ES9-正则-dotAll模式\r\n```js\r\n//dot . 元字符 除换行符以外的任意单个字符\r\n//在dotAll 模式 . 将能匹配任意字符包括换行符\r\n\r\n//目标提取出a和p标签的内容\r\nlet str = `\r\n    <ul>\r\n        <li>\r\n            <a>肖申克的救赎</a>\r\n            <p>上映时间:1994-09-10</p>\r\n        </li>\r\n        <li>\r\n            <a>阿甘正传</a>\r\n            <p>上映时间:1994-07-06</p>\r\n        </li>\r\n    </ul>\r\n`\r\n\r\nvar reg_old = /<a>([\\S\\s]*?)<\\/a>[\\S\\s]*?<p>([\\S\\s]*?)<\\/p>/g      // 旧版: `.`仅能匹配任意字符,不包括换行符号\r\nvar data_old = ''\r\nvar result_old = []\r\nwhile (data_old = reg_old.exec(str)) {\r\n    result_old.push([data_old[1], data_old[2],])\r\n}\r\nconsole.log(result_old);\r\n\r\nvar reg_new = /<a>(.*?)<\\/a>.*?<p>(.*?)<\\/p>/gs                    // 新版: `/s`表示是模式修正使得`.`能匹配任意字符,包括换行符号\r\nvar data_new = ''\r\nvar result_new = []\r\nwhile (data_new = reg_new.exec(str)) {\r\n    result_new.push([data_new[1], data_new[2],])\r\n}\r\nconsole.log(result_new);\r\n```\r\n**输出结果**\r\n![图 1](./images/ES6-ES11新特性学习笔记/48142215ed63936854349dcedf19d963bdd31d5ae2e161afac79037e51b07bd8.png)  \r\n\r\n## ES10-二维数组或Map转对象\r\n`Object.fromEntries()`二维数组或Map转对象,实际上是ES8中`Object.entries(testObj)`的**逆运算**\r\n```js\r\nvar result1 = Object.fromEntries([\r\n    [\"Name\", \"DYG\"],\r\n    [\"Age\", \"21\"],\r\n])\r\nconsole.log(result1);\r\n// 输出:\r\n// {Name: 'DYG', Age: '21'}\r\n\r\n\r\n\r\nvar result2 = Object.fromEntries(new Map([\r\n    [\"Name\", \"DYG\"],\r\n    [\"Age\", \"21\"],\r\n]))\r\nconsole.log(result2);\r\n    // 输出:\r\n    // {Name: 'DYG', Age: '21'}\r\n```\r\n\r\n\r\n## ES10-trimStart,trimEnd\r\n* `str.trimStart()` 清除字符串开头处空白\r\n* `str.trimEnd()` 清除字符串结束处空白\r\n```js\r\n        var str = \"   测试文字   \"\r\n        console.log(str.trim())         //ES5 中的方法,输出结果为 : \"测试文字\"\r\n        console.log(str.trimStart())    //ES10中的方法,输出结果为 : \"   测试文字\"\r\n        console.log(str.trimEnd())      //ES10中的方法,输出结果为 : \"测试文字   \"\r\n```\r\n\r\n## ES10-flat,flatMap\r\n\r\n**`flat()`**\r\n```js\r\nvar test1 = [1, 2, 3, 4, 5, [6, 7]]\r\nconsole.log(test1.flat());          //二维数组转一维\r\n//输出 [1,2,3,4,5,6,7]\r\n\r\nvar test2 = [1, 2, 3, 4, 5, [6, 7, [8, 9]]]\r\nconsole.log(test2.flat());          //三维数组转二维\r\n//输出 [1,2,3,4,5,6,7,[8,9]]\r\nconsole.log(test2.flat(2));         //三维数组转一维(指定深度为2)\r\n//输出 [1,2,3,4,5,6,7,8,9]\r\n```\r\n\r\n**`flatMap()`**\r\n```js\r\nvar test3 = [\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n]\r\nconsole.log(test3.map(item => item[5]))\r\n/* 输出: \r\n[\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n]\r\n*/\r\nconsole.log(test3.flatMap(item => item[5]))\r\n// 输出 [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\r\n```\r\n\r\n\r\n## ES10-`Symbol.prototype.description`\r\n```js\r\nvar temp = Symbol(\"这是描述字符串\")\r\nconsole.log(temp.description); //输出: 这是描述字符串\r\n```\r\n\r\n\r\n## ES11-类的私有属性\r\n```js\r\nclass Person{\r\n    name;\r\n    #age;\r\n    constructor(name,age){\r\n        this.name=name\r\n        this.#age=age\r\n    }\r\n}\r\n\r\nvar girl = new Person(\"小红\",18)\r\nconsole.log(girl.name);\r\n// console.log(girl.#age); //无法访问\r\n```\r\n\r\n## ES11-Promise.allSettled()\r\n* `Promise.allSettled([p1,p2])` 始终返回成功的promise对象, 类似于`||`\r\n  * 原先版本中有`Promise.all([p1,p2])`,其返回值成功失败由传入的参数决定,类似于`&&`\r\n```js\r\nvar p1 = new Promise((resolve,reject)=>{\r\n    setTimeout(()=>{\r\n        resolve(\"哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\")\r\n    },1000)\r\n})\r\nvar p2 = new Promise((resolve,reject)=>{\r\n    setTimeout(()=>{\r\n        reject(\"嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻\")\r\n    },1000)\r\n})\r\n\r\nconsole.log(Promise.allSettled([p1,p2]));\r\n```\r\n\r\n![图 3](./images/ES6-ES11新特性学习笔记/073d3d06eb89d441a759837d652fdeb6b5906e913fe25087ecb18b0b96184c74.png)  \r\n\r\n\r\n## ES11-`String.prototype.matchAll()`\r\n\r\n```js\r\nlet str = `\r\n<ul>\r\n    <li>\r\n        <a>肖申克的救赎</a>\r\n        <p>上映时间:1994-09-10</p>\r\n    </li>\r\n    <li>\r\n        <a>阿甘正传</a>\r\n        <p>上映时间:1994-07-06</p>\r\n    </li>\r\n</ul>\r\n`\r\n\r\nvar reg = /<a>(.*?)<\\/a>.*?<p>(.*?)<\\/p>/gs\r\n\r\nvar result1 = str.matchAll(reg)     //返回的是一个可迭代对象\r\nconsole.log([...result1]);          //所以可以使用扩展运算符 获取所有结果\r\n\r\nvar result2 = str.matchAll(reg)     //返回的是一个可迭代对象\r\nfor (let item of result2) {           //所以可以使用of 遍历对象 获取所有结果\r\n    console.log(item);\r\n    console.log({ \"name\": item[1], \"time\": item[2] });\r\n}\r\n```\r\n\r\n\r\n## ES11-`?.`可选链操作符\r\n```js\r\nfunction test(config) {\r\n    // 1\r\n    var dbHost = config.db.host\r\n    // var cacheHost = config.cache.host // 将报错,因为没有 config.cache\r\n    console.log(dbHost);\r\n    console.log(cacheHost);\r\n\r\n    // \r\n    var dbHost = config && config.db && config.db.host              //手动层层判断该对象是否有该属性,不会报错\r\n    var cacheHost = config && config.cache && config.cache.host     //手动层层判断该对象是否有该属性,不会报错\r\n    console.log(dbHost);\r\n    console.log(cacheHost);\r\n\r\n    var dbHost = config?.db?.host           //自动判断问号前的属性是否存在,不会报错\r\n    var cacheHost = config?.cache?.host     //自动判断问号前的属性是否存在,不会报错\r\n    console.log(dbHost);\r\n    console.log(cacheHost);\r\n}\r\n\r\ntest({\r\n    db: {\r\n        host: \"localhost\",\r\n        port: 1234,\r\n        username: \"root\",\r\n        password: \"root\",\r\n    },\r\n    // cache: {                     //不写cache\r\n    //     // host:\"localhost\",\r\n    //     port:4321,\r\n    //     username:\"root\",\r\n    //     password:\"root\",\r\n    // },\r\n})\r\n```\r\n\r\n\r\n## ES11-动态`import()`\r\n* 原先的import是静态的,需要在文件开头把所需模块一次性import导入\r\n* 动态import就是**按需导入**,**懒加载**\r\n\r\n**基本用法**\r\n```html\r\n<button id=\"btn\">点击测试</button>\r\n<script type=\"module\">\r\n    var btn = document.querySelector(\"#btn\")\r\n    btn.addEventListener(\"click\",async function(){\r\n        let hello = await import(\"./_hello.js\")     //import返回promise对象,使用await接受value\r\n        hello.myFun()\r\n    })\r\n</script>\r\n```\r\n\r\n```js\r\n//./_hello.js\r\nexport function myFun(){\r\n    alert(\"hello\")\r\n}\r\n```\r\n\r\n\r\n## ES11-BigInt大整型\r\n**BigInt**\r\n* BigInt常量: `123n`\r\n* BigInt()只能传入整数,不能传入浮点数\r\n* BigInt类型的数只能和BigInt类型数做运算\r\n\r\n**基本使用**\r\n```js\r\n        let test1 = 12345n;\r\n        console.log(test1);          //输出: 12345n\r\n        console.log(typeof test1); //输出: bigint\r\n\r\n        let test2 = BigInt(12345);\r\n        console.log(test2);          //输出: 12345n\r\n        console.log(typeof test2); //输出: bigint\r\n```\r\n\r\n**用处**\r\n```js\r\nlet maxInteger = Number.MAX_SAFE_INTEGER\r\nconsole.log(maxInteger+0);  //输出:     9007199254740991\r\nconsole.log(maxInteger+1);  //输出:     9007199254740992\r\nconsole.log(maxInteger+2);  //输出:     9007199254740992        //无法再加\r\n\r\nconsole.log(BigInt(maxInteger)+BigInt(0))//输出:     9007199254740991n\r\nconsole.log(BigInt(maxInteger)+BigInt(1))//输出:     9007199254740992n\r\nconsole.log(BigInt(maxInteger)+BigInt(2))//输出:     9007199254740993n        //可以再加\r\n```\r\n\r\n\r\n## ES11-globalThis\r\n\r\n```js\r\nconsole.log(globalThis) //在浏览器中指向 window\r\n// Window {window: Window, self: Window, document: document, name: '', location: Location, …}\r\n\r\nconsole.log(globalThis) //在nodejs中指向 global\r\n/*\r\nObject [global] {\r\n    global: [Circular],\r\n    clearInterval: [Function: clearInterval],\r\n    clearTimeout: [Function: clearTimeout],\r\n    setInterval: [Function: setInterval],\r\n    setTimeout: [Function: setTimeout] {\r\n        [Symbol(nodejs.util.promisify.custom)]: [Function]\r\n    },\r\n    queueMicrotask: [Function: queueMicrotask],\r\n    clearImmediate: [Function: clearImmediate],\r\n    setImmediate: [Function: setImmediate] {\r\n        [Symbol(nodejs.util.promisify.custom)]: [Function]\r\n    }\r\n}\r\n*/\r\n```"},{"shortInfo":{"title":"express学习笔记","date":"2022-08-30T00:05:00.000Z","cover":"\\self_server\\assets\\images\\express学习笔记\\2022-12-04-01-20-05.png","tags":["express"],"categories":"后端","id":2555377629,"countWords":6340,"readSeconds":634,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/express学习笔记/2022-12-04-01-20-05.png) -->\r\n\r\n# express学习笔记\r\n\r\n## 目录\r\n- [express学习笔记](#express学习笔记)\r\n  - [目录](#目录)\r\n  - [概念](#概念)\r\n  - [实现API接口服务器](#实现api接口服务器)\r\n    - [基本示例:post get all listen](#基本示例post-get-all-listen)\r\n    - [获取URL中的**查询参数**](#获取url中的查询参数)\r\n    - [获取URL中的**动态参数**](#获取url中的动态参数)\r\n  - [静态web服务器](#静态web服务器)\r\n    - [**基本使用示例**](#基本使用示例)\r\n    - [**托管多个静态网页**](#托管多个静态网页)\r\n    - [**挂载路径前缀**](#挂载路径前缀)\r\n  - [路由](#路由)\r\n    - [概念](#概念-1)\r\n    - [**最简用法:直接挂载到app上**](#最简用法直接挂载到app上)\r\n    - [**高级用法:将路由抽离为单独模块**](#高级用法将路由抽离为单独模块)\r\n    - [为路由添加访问前缀](#为路由添加访问前缀)\r\n  - [中间件](#中间件)\r\n    - [概念](#概念-2)\r\n    - [示例](#示例)\r\n    - [**中间件的分类**](#中间件的分类)\r\n    - [**应用级别中间件**](#应用级别中间件)\r\n    - [**路由级别中间件**](#路由级别中间件)\r\n    - [**错误级别中间件**](#错误级别中间件)\r\n    - [**内置中间件**](#内置中间件)\r\n    - [**第三方中间件**](#第三方中间件)\r\n    - [**自定义中间件:尝试实现urlencoded模块**](#自定义中间件尝试实现urlencoded模块)\r\n  - [常用中间件的使用](#常用中间件的使用)\r\n    - [CORS跨源访问限制](#cors跨源访问限制)\r\n    - [express-session身份认证](#express-session身份认证)\r\n    - [JWT认证机制机制](#jwt认证机制机制)\r\n  - [session认证完整案例](#session认证完整案例)\r\n  - [jwt认证完整案例](#jwt认证完整案例)\r\n  - [综合案例：结合jwt认证机制、express、mysql时间api服务器](#综合案例结合jwt认证机制expressmysql时间api服务器)\r\n\r\n\r\n------------------------------------------------------------------\r\n\r\n## 概念\r\nexpress作用和nodejs的http模块类似,用于创建web服务器<br>\r\nexpress是基于http模块封装的,使用起来比http模块简单,效率更高\r\n\r\n**express用处**\r\n* web服务器\r\n* API接口服务器\r\n\r\n------------------------------------------------------------------\r\n\r\n## 实现API接口服务器\r\n### 基本示例:post get all listen\r\n```js\r\nconst express = require(\"express\")\r\n\r\nconst app = express();\r\n\r\napp.get(\"/test_01\",(request,response)=>{\r\n    response.send(\"hello world!!\")\r\n})\r\n\r\napp.post(\"/test_02\",(request,response)=>{\r\n    response.send({hello:\"world\"})\r\n})\r\n\r\napp.all(\"/test_03\",(request,response)=>{\r\n    response.send({hello:\"world\"})\r\n})\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"express server is running at http://127.0.0.1:8000\")\r\n})\r\n```\r\n------------------------------------------------------------------\r\n\r\n\r\n### 获取URL中的**查询参数**\r\n```js\r\napp.get(\"/test_04\",(request,response)=>{\r\n    // request.query默认是空对象\r\n    // 客户端使用 ?name=DingYigui&age=20 这种查询字符串形式的URL时\r\n    // request.query=={\"name\"=\"DingYigui\",\"age\"=20}\r\n\r\n    console.log(request.query)\r\n    \r\n    response.send(request.query)\r\n})\r\n```\r\n------------------------------------------------------------------\r\n\r\n### 获取URL中的**动态参数**\r\n```js\r\napp.get(\"/test_05/:name/:age\",(request,response)=>{\r\n    // request.params 默认是空对象 是动态匹配到的URL参数\r\n    // 客户端使用 /test_05/DingYigui/20 形式的URL时\r\n    \r\n    // request.params=={\"name\"=\"DingYigui\",\"age\"=20}\r\n    console.log(request.params)\r\n    response.send(request.params)\r\n})\r\n```\r\n------------------------------------------------------------------\r\n\r\n## 静态web服务器\r\n\r\n### **基本使用示例**\r\n```js\r\nconst express = require(\"express\")\r\n\r\nconst app = express();\r\n\r\napp.use(express.static(\"./site0\"))\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"express server is running at http://127.0.0.1:8000\")\r\n})\r\n```\r\n\r\n> 要访问 `/site0/index` 只需访问 `/index`\r\n\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n### **托管多个静态网页**\r\n```js\r\napp.use(express.static(\"./site1\"))\r\napp.use(express.static(\"./site2\"))\r\n```\r\n> 注意: 若访问的index.html在两个文件目录中均存在,则优先访问第一个文件夹\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n### **挂载路径前缀**\r\n```js\r\napp.use(\"/subSite\",express.static(\"./site1\"))\r\n```\r\n> 要访问 `/site1/index` 则需访问 `/subSite/index`\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n## 路由\r\n### 概念\r\n路由就是**映射关系**,在express中就是指**客户端请求**和**服务端处理函数**的**映射关系**\r\n\r\nexpress路由的**组成**: `app.METHOD(PATH,HANDLER)`\r\n* `METHOD` 请求的方法\r\n* `PATH` 请求的URL地址\r\n* `HANDLER` 处理函数\r\n\r\nexpress路由的**匹配规则**\r\n* 将按照定义的**先后顺序**进行匹配\r\n* **请求类型**和**请求URL**需**同时匹配**才会调用对应的**处理函数**\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n### **<sky>最简用法</sky>:直接挂载到app上**  \r\n<red>express不建议将路由直接挂载到app上,这样会导致代码量越来越多,不便管理</red>\r\n\r\n```js\r\napp.get(\"/test_01\",(request,response)=>{\r\n    response.send(\"hello world!!\")\r\n})\r\n\r\napp.post(\"/test_02\",(request,response)=>{\r\n    response.send({hello:\"world\"})\r\n})\r\n\r\napp.all(\"/test_03\",(request,response)=>{\r\n    response.send({hello:\"world\"})\r\n})\r\n```\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n### **<sky>高级用法</sky>:将路由抽离为单独模块**  \r\n\r\n<gre>express官方推荐用法</gre>  \r\n\r\n```js\r\n// ./src/user.js\r\nconst express = require(\"express\")\r\nconst routerApp = express.Router()     //创建路由对象\r\n\r\nrouterApp.get(\"/user/list\",(req,res)=>{ //挂载路由\r\n    res.send(\"getted user list\")\r\n})\r\nrouterApp.post(\"/user/add\",(req,res)=>{ //挂载路由\r\n    res.send(\"added user\")\r\n})\r\n\r\nmodule.exports = routerApp //导出路由对象\r\n```\r\n\r\n```js\r\n// ./index.js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\nconst userRouter = require(\"./src/user.js\") //导入user路由模块\r\napp.use(\"/api\",userRouter) //注册路由\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n>`app.use()`用于注册全局**中间件**\r\n\r\n\r\n------------------------------------------------------------------\r\n\r\n### 为路由添加访问前缀\r\n```js\r\napp.use(\"/api\",userRouter) //添加访问前缀\r\n```\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n## 中间件\r\n\r\n### 概念\r\n中间件(Middleware),特指业务流程的中间处理环节\r\n\r\n但一个请求到达express服务器后,可连续调用多个中间件对请求进行**预处理**\r\n![图 1](./images/express学习笔记/94e6281102dfa399e3de1d15a143647e4bdec8256d7ce39ebff2d5eb91fcee3f.png)  \r\n\r\n\r\n**中间件本质为函数**\r\n```js\r\nconst mw = function (request,response,next){\r\n    console.log(\"这是一个中间件函数\")\r\n    next()\r\n}\r\n```\r\n**next()函数**  \r\nnext()函数实现多个中间件之间的**连续调用**,表示把**流转关系**转交给**下一个中间件**或**路由**\r\n\r\n![图 2](./images/express学习笔记/05ed400ef4edde4dad65a33e9bf0c8354e53ddb3f963aabae9c53f4a1c7dd4aa.png)  \r\n\r\n\r\n\r\n### 示例\r\n**案例1:全局生效的中间件**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\n//定义中间件1\r\nconst mw1 = function(req,res,next){\r\n    req.startTime = Date.now()\r\n    console.log(\"执行了第1个中间件\")\r\n    next()\r\n}\r\n//定义中间件2\r\nconst mw2 = function(req,res,next){\r\n    console.log(\"执行了第2个中间件\")\r\n    next()\r\n}\r\n\r\n//注册中间件1:先注册的先执行,后注册的后执行\r\napp.use(mw1)\r\n//注册中间件2\r\napp.use(mw2)\r\n\r\n\r\napp.get(\"/testRW\",(req,res)=>{ //挂载路由\r\n    var now = Date.now()\r\n    var gap = now-req.startTime\r\n    res.send(\"处理该请求耗时:\"+ gap + \"ms\")\r\n})\r\n\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n> **注意**:对于全局生效的中间件,一定要在路由之前注册中间件\r\n\r\n\r\n\r\n**案例2:局部生效的中间件**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\n//定义中间件1\r\nconst mw1 = function(req,res,next){\r\n    req.startTime = Date.now()\r\n    console.log(\"执行了第1个中间件\")\r\n    next()\r\n}\r\n//定义中间件2\r\nconst mw2 = function(req,res,next){\r\n    console.log(\"执行了第2个中间件\")\r\n    next()\r\n}\r\n\r\n\r\n//以下三种方式均可\r\napp.get(\"/testRW_2_1\",mw1,(req,res)=>{ //挂载路由\r\n    var now = Date.now()\r\n    var gap = now-req.startTime\r\n    res.send(\"处理该请求耗时:\"+ gap + \"ms\")\r\n})\r\n\r\n// 以下两种方式等效\r\napp.get(\"/testRW_2_2\",mw1,mw2,(req,res)=>{ //挂载路由\r\n    var now = Date.now()\r\n    var gap = now-req.startTime\r\n    res.send(\"处理该请求耗时:\"+ gap + \"ms\")\r\n})\r\n\r\napp.get(\"/testRW_2_3\",[mw1,mw2],(req,res)=>{ //挂载路由\r\n    var now = Date.now()\r\n    var gap = now-req.startTime\r\n    res.send(\"处理该请求耗时:\"+ gap + \"ms\")\r\n})\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n\r\n\r\n### **中间件的分类**\r\n* **应用**级别中间件\r\n* **路由**级别中间件\r\n* **错误**级别中间件\r\n* Express**内置**中间件\r\n* **第三方**中间件\r\n\r\n\r\n### **应用级别中间件**\r\n通过`app.use()` `app.post()` `app.get()`绑定到**app实例**上的中间件都称为**应用级别中间件**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\napp.use((req,res,next)=>{\r\n    console.log(\"这是一个应用级别中间件,同时也是全局中间件\")\r\n    next();\r\n})\r\n\r\napp.get(\"/api/test\",\r\n    (req,res,next)=>{\r\n        console.log(\"这是一个应用级别中间件,同时也是局部中间件\")\r\n        next();\r\n    },\r\n    (req,res)=>{\r\n        res.send(\"hello world\")\r\n    }\r\n)\r\n```\r\n\r\n### **路由级别中间件**\r\n绑定到`express.Router()`的**实例**上的中间件都称为**路由级别中间件**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\nconst router = app.Router()\r\n\r\nrouter.use((req,res,next)=>{\r\n    console.log(\"这是一个路由级别中间件\")\r\n    next();\r\n})\r\n\r\nrouter.get(\"/test\",\r\n    (req,res,next)=>{\r\n        console.log(\"这是一个路由级别中间件\")\r\n        next();\r\n    },\r\n    (req,res)=>{\r\n        res.send(\"hello world\")\r\n    }\r\n)\r\n\r\napp.use(\"/api\",router)\r\n```\r\n\r\n\r\n### **错误级别中间件**  \r\n用于捕获整个项目中发生异常错误的中间件,**防止项目异常崩溃的问题**  \r\n**格式:**`function(err,req,res,next){}`  \r\n**注意:** <red>错误级别中间件需放在路由之后<red>\r\n```js\r\n//创建路由\r\napp.get(\"/test\",(req,res)=>{\r\n    throw new Error(\"服务器发生了内部错误!!!\") //手动抛出一个错误\r\n    res.send(\"hello world\")                 //此处便不会执行\r\n})\r\n\r\n//注册错误级别中间件\r\napp.use((err,req,res,next)=>{\r\n    console.log(err.message)                //输出错误信息\r\n    res.send(err.message)                   //向客户端响应\r\n})\r\n```\r\n\r\n### **内置中间件**\r\n自`express@4.16.0`起内置了三个常用中间件\r\n* `express.static` \r\n  * 用于托管指定目录下的静态网页\r\n  * (该中间件可兼任旧版本)\r\n* `express.json()`\r\n  * 用于解析<red>**请求体中**</red>的**JSON格式**的数据,解析完毕后将被挂载到`req.body`上  \r\n  * (该中间件不可兼任旧版本的express)\r\n* `express.urlencoded()`\r\n  * 用于解析<red>**请求体中**</red>中的**URL-encoded格式**的数据,解析完毕后将被挂载到`req.body`上\r\n  * (该中间件不可兼任旧版本的express)\r\n\r\n```js\r\n// 解析 application/json 格式的数据\r\napp.use(express.json())\r\n// 解析 application/x-www-form-urlencoded 格式的数据\r\napp.use(express.urlencoded({extented:false}))\r\n\r\napp.post(\"/\",(req,res)=>{ //此时便能够解析并获取到请求体中的json格式和urlencoded格式的数据了\r\n    console.log(req.body)\r\n    res.send(req.body)\r\n})\r\n```\r\n\r\n\r\n### **第三方中间件**\r\n在`express@4.16.0`内置`express.urlencoded`模块之前,常使用的一个叫<red>body-parser</red>的模块  \r\n实际上该模块就是`express.urlencoded`的前身\r\n```js\r\nconst parser = require(\"body-parser\")\r\napp.use(parser.urlencoded({extented:false}))\r\n```\r\n\r\n### **自定义中间件:尝试实现urlencoded模块**\r\n实现将请求体中的`a=123&b=321`格式的数据解析为`{a:123,b:321}`格式的json对象\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\nconst qs = require(\"querystring\")\r\nfunction BodyUrlDataDecoded(req,res,next){//定义中间件\r\n    req.bodyUrlData = []\r\n    req.on(\"data\",(chunk)=>{ //监听req的data\r\n        req.bodyUrlData.push(chunk) //收集数据片段\r\n    })\r\n    req.on(\"end\",()=>{//监听req的end事件\r\n        var temp = req.bodyUrlData.toString() //将收集的数据片段转换为字符串\r\n        req.body = qs.parse(temp) // 将字符串通过nodejs内置的querystring模块解析为json对象\r\n        next()\r\n    })\r\n}\r\napp.use(BodyUrlDataDecoded) //注册中间件\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\napp.all(\"/\",(req,res)=>{\r\n    res.setHeader(\"Access-Control-Allow-Origin\",\"*\")\r\n    res.setHeader(\"Access-Control-Allow-Headers\",\"*\")\r\n    console.log(req.body);\r\n    res.send(req.body)\r\n})\r\napp.listen(8000,()=>{\r\n    console.log(\"express server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n**测试自定义中间件**\r\n```html\r\n<!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n<script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n<!-- axios 库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n<script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n<button id=\"btn\">点击使用axios(config)发送请求</button>\r\n<script>\r\n    $(\"#btn\").click(function(){\r\n        //axios(config)\r\n        axios({\r\n            method: 'post',\r\n            url:\"http://127.0.0.1:8000/\",\r\n            params: {//url格式数据\r\n            },\r\n            headers:{//报头\r\n            },\r\n            data: \"a=123&b=321\"\r\n            // data:{\r\n            //     a:123,\r\n            //     b:321\r\n            // }\r\n        })\r\n        .then(function (response) {\r\n            console.log(response);\r\n        })\r\n        .catch(function (error) {\r\n            console.log(error);\r\n        })\r\n        .then(function () {\r\n            // always executed\r\n        });\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n\r\n## 常用中间件的使用\r\n\r\n### CORS跨源访问限制\r\n**方法1:添加请求头**\r\n```js\r\nres.setHeader(\"Access-Control-Allow-Origin\",\"*\")\r\nres.setHeader(\"Access-Control-Allow-Headers\",\"*\")\r\n```\r\n\r\n方法2: 通过第三方中间件cors\r\n```js\r\nconst cors = require(\"cors\")\r\napp.use(cors)\r\n```\r\n\r\n\r\n### express-session身份认证\r\n\r\n**基本使用**\r\n```js\r\nconst session = require(\"express-session\")\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\napp.use(session({\r\n    secret: \"keyboard cat\",     //任意字符串,用于加密cookie\r\n    resave: false,              //固定写法\r\n    saveUninitialized: true,    //固定写法\r\n}))\r\n\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\napp.post(\"/api/login\", (req, res) => {\r\n\r\n    console.log(req.session);\r\n\r\n    //判断用户名和密码是否正确\r\n    if (req.body.username != \"admin\" && req.body.password != \"admin\") {\r\n        res.send({ status: 1, msg: \"登陆失败\" })\r\n        return;\r\n    }\r\n\r\n    //保存此次会话的用户信息\r\n    req.session.userinfo = req.body\r\n    req.session.islogin = true\r\n    res.send({ status: 0, msg: \"登陆成功\" })\r\n    return;\r\n})\r\n```\r\n\r\n**`console.log(req.session);`输出的数据格式**\r\n```js\r\n// 登陆前\r\nSession {\r\n  cookie: { path: '/', _expires: null, originalMaxAge: null, httpOnly: true }\r\n}\r\n\r\n//登陆后\r\nSession {\r\n  cookie: { path: '/', _expires: null, originalMaxAge: null, httpOnly: true },\r\n  userinfo: { username: 'admin', password: 'admin' },\r\n  islogin: true\r\n}\r\n```\r\n\r\n\r\n**实现 `登陆` `登出` 的案例**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\nconst session = require(\"express-session\")\r\n\r\napp.use(express.static(\"./webRoot\"))\r\n\r\napp.use(session({\r\n    secret: \"keyboard cat\",     //任意字符串,用于加密cookie\r\n    resave: false,              //固定写法\r\n    saveUninitialized: true,    //固定写法\r\n}))\r\n\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\napp.post(\"/api/login\", (req, res) => {\r\n\r\n    console.log(req.session);\r\n\r\n    //判断用户名和密码是否正确\r\n    if (req.body.username != \"admin\" && req.body.password != \"admin\") {\r\n        res.send({ \r\n            status: 1, \r\n            msg: \"登陆失败\" \r\n        })\r\n        return;\r\n    }\r\n\r\n    //保存此次会话的用户信息\r\n    req.session.userinfo = req.body\r\n    req.session.islogin = true\r\n    res.send({ \r\n        status: 0, \r\n        msg: \"登陆成功\" \r\n    })\r\n    return;\r\n})\r\n\r\napp.get(\"/api/logout\", (req, res) => {\r\n\r\n    //判断该请求的是否已经登陆\r\n    if (!req.session.islogin) {\r\n        res.send({ \r\n            status: 1, \r\n            msg: \"logout失败\" \r\n        })\r\n        return;\r\n    }\r\n\r\n    //销毁该会话\r\n    req.session.destroy()\r\n    res.send({ status: 0, msg: \"logout成功\" })\r\n    return;\r\n})\r\n\r\napp.get(\"/api/get-username\", (req, res) => {\r\n    //判断该请求的是否已经登陆\r\n    if (!req.session.islogin) {\r\n        res.send({ \r\n            status: 1, \r\n            msg: \"get-username失败\" \r\n        })\r\n        return;\r\n    }\r\n    res.send({ \r\n        status: 0, \r\n        msg: \"get-username成功\", \r\n        username: req.session.userinfo.username \r\n    })\r\n    return;\r\n})\r\n\r\n\r\napp.listen(8000, () => {\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n\r\n\r\n```html\r\n    <h1>登陆</h1>\r\n    <form action=\"/api/login\" method=\"post\">\r\n        <input type=\"text\" name=\"username\"><br>\r\n        <input type=\"password\" name=\"password\"><br>\r\n        <input type=\"submit\" value=\"登陆\"><br>\r\n    </form>\r\n\r\n    <h1>登出</h1>\r\n    <form action=\"/api/logout\" method=\"get\">\r\n        <input type=\"submit\" value=\"登出\"><br>\r\n    </form>\r\n\r\n    <h1>获取当前用户的用户名</h1>\r\n    <form action=\"/api/get-username\" method=\"get\">\r\n        <input type=\"submit\" value=\"获取当前用户的用户名\"><br>\r\n    </form>\r\n```\r\n\r\n\r\n\r\n### JWT认证机制机制\r\n**安装相关包**\r\n* `jsonwebtoken` 用于将用户信息**加密**为JWT字符串\r\n* `express-jwt` 用于将从客户端收到的JWT字符串**解密**为用户信息\r\n\r\n```bash\r\nnpm install jsonwebtoken express-jwt\r\n```\r\n\r\n**实现JWT认证登陆的完整示例**\r\n\r\n![图 6](./images/express学习笔记/a6285567a812d97f3fe90506e6993ed9f7e77ca9e06f3b5bcedbca35616fe252.png)  \r\n\r\n\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\n//jwt身份认证\r\nconst jwtEncode = require(\"jsonwebtoken\") //加密\r\n// const jwtDecode = require(\"express-jwt\")  //解密\r\nvar { expressjwt: jwtDecode } = require(\"express-jwt\");\r\nconst secretKey = \"dfwofwiefjw0wfej02fj023j0r2\" //随便写一段密钥用于加密token\r\n\r\n//用于支持跨源\r\nconst cors = require(\"cors\")\r\napp.use(cors())\r\n\r\n// 静态资源\r\napp.use(express.static(\"./webRoot\"))\r\n\r\n//解密请求头中的 jwtToken 解析还原为json对象 并把解析出来的信息挂载到 req.auth 上\r\n//同时配置了访问权限 没有Token则不能访问任何接口 \r\n//unless指定某些页面不需要Token 这里指定 /api/login 不需要身份认证便能访问\r\napp.use(\r\n    jwtDecode({\r\n        secret: secretKey,\r\n        algorithms: [\"HS256\"] //防止潜在的降级攻击所必需的\r\n    })\r\n        .unless({ path: [/^\\/api\\/login/] }) //指定 /api/login 不需要身份认证便能访问\r\n)\r\n\r\n//用于req.body\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\n//登陆api\r\napp.post(\"/api/login\", (req, res) => {\r\n\r\n    //判断用户名和密码是否正确\r\n    if (req.body.username != \"admin\" && req.body.password != \"admin\") {\r\n        res.send({\r\n            status: 1,\r\n            msg: \"登陆失败\"\r\n        })\r\n        return;\r\n    }\r\n\r\n    //生成token\r\n    //sign方法:sign(参数1,参数2,参数3)\r\n    // 参数1 待加密的数据\r\n    // 参数2 加密密钥\r\n    // 参数3 配置项,可配置有效期\r\n    var token = jwtEncode.sign({ username: req.body.username }, secretKey, { expiresIn: \"30s\" })\r\n    //发送token\r\n    res.send({\r\n        status: 0,\r\n        msg: \"登陆成功\",\r\n        token: token\r\n    })\r\n})\r\n\r\n// app.get(\"/api/logout\", (req, res) => {\r\n// logout不需要服务端执行任何操作了 只需要客户端删除token就好了\r\n//     res.send({ \r\n//         status: 0, \r\n//         msg: \"logout成功\" \r\n//     })\r\n//     return;\r\n// })\r\n\r\napp.get(\"/api/get-userinfo\", (req, res) => {\r\n    res.send({\r\n        status: 0,\r\n        msg: \"获取用户的信息成功\",\r\n        userinfo: req.auth\r\n    })\r\n    return;\r\n})\r\n\r\napp.use((err, res, req, next) => { //处理错误\r\n    if (err.name == \"UnauthorizedError\") {\r\n        req.send({\r\n            status: 401,\r\n            msg: \"未登陆或登陆状态已过期,请重新登陆\",\r\n            err: err\r\n        })\r\n    } else {\r\n        req.send({\r\n            status: 500,\r\n            msg: \"服务器未知错误\",\r\n            err: err\r\n        })\r\n    }\r\n}\r\n)\r\n\r\n\r\n\r\n\r\napp.listen(8000, () => {\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n\r\n**前端代码**\r\n```html\r\n    <!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n    <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n    <!-- axios 库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n    <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n\r\n\r\n    <h1>登陆</h1>\r\n    用户:<input type=\"text\" id=\"username\"><br>\r\n    密码:<input type=\"password\" id=\"password\"><br>\r\n    <button id=\"btn-login\">登陆</button>\r\n    <div id=\"login-result\"></div>\r\n    <script>\r\n        $(\"#btn-login\").click(function () {\r\n            console.log(\"123\");\r\n            //axios(config)\r\n            axios({\r\n                method: 'post',\r\n                url: \"/api/login\",\r\n                data: {\r\n                    username: $(\"#username\").val(),\r\n                    password: $(\"#password\").val(),\r\n                }\r\n            })\r\n                .then((response) => {\r\n                    console.log(response);\r\n                    $(\"#login-result\").text(JSON.stringify(response.data))\r\n                    sessionStorage.setItem(\"token\", response.data.token) //保存token\r\n                })\r\n        })\r\n    </script>\r\n\r\n\r\n\r\n\r\n\r\n    <h1>获取用户的信息</h1>\r\n    <button id=\"btn-get-userinfo\">获取</button>\r\n    <div id=\"get-userinfo-result\"></div>\r\n    <script>\r\n        $(\"#btn-get-userinfo\").click(function () {\r\n            //axios(config)\r\n            axios({\r\n                method: 'get',\r\n                url: \"/api/get-userinfo\",\r\n                headers: {//报头\r\n                    Authorization: \"Bearer \" + sessionStorage.getItem(\"token\") //获取token\r\n                }\r\n            })\r\n                .then((response) => {\r\n                    console.log(response);\r\n                    $(\"#get-userinfo-result\").text(JSON.stringify(response.data))\r\n                })\r\n        })\r\n    </script>\r\n\r\n\r\n    <h1>登出</h1>\r\n    <button id=\"btn-logout\">登出</button>\r\n    <div id=\"logout-result\"></div>\r\n    <script>\r\n        $(\"#btn-logout\").click(function () {\r\n            sessionStorage.setItem(\"token\", \"\") //清除token\r\n            $(\"#logout-result\").text(\"登出完毕\")\r\n\r\n        })\r\n    </script>\r\n```\r\n\r\n\r\n## session认证完整案例\r\n\r\n```html\r\n    <h1>登陆</h1>\r\n    <form action=\"/api/login\" method=\"post\">\r\n        <input type=\"text\" name=\"username\"><br>\r\n        <input type=\"password\" name=\"password\"><br>\r\n        <input type=\"submit\" value=\"登陆\"><br>\r\n    </form>\r\n\r\n    <h1>登出</h1>\r\n    <form action=\"/api/logout\" method=\"get\">\r\n        <input type=\"submit\" value=\"登出\"><br>\r\n    </form>\r\n    \r\n    <h1>获取当前用户的用户名</h1>\r\n    <form action=\"/api/get-username\" method=\"get\">\r\n        <input type=\"submit\" value=\"获取当前用户的用户名\"><br>\r\n    </form>\r\n```\r\n\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\nconst session = require(\"express-session\")\r\n\r\napp.use(express.static(\"./webRoot\"))\r\n\r\napp.use(session({\r\n    secret: \"keyboard cat\",     //任意字符串,用于加密cookie\r\n    resave: false,              //固定写法\r\n    saveUninitialized: true,    //固定写法\r\n}))\r\n\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\napp.post(\"/api/login\", (req, res) => {\r\n\r\n    console.log(req.session);\r\n\r\n    //判断用户名和密码是否正确\r\n    if (req.body.username != \"admin\" && req.body.password != \"admin\") {\r\n        res.send({ \r\n            status: 1, \r\n            msg: \"登陆失败\" \r\n        })\r\n        return;\r\n    }\r\n\r\n    //保存此次会话的用户信息\r\n    req.session.userinfo = req.body\r\n    req.session.islogin = true\r\n    res.send({ \r\n        status: 0, \r\n        msg: \"登陆成功\" \r\n    })\r\n    return;\r\n})\r\n\r\napp.get(\"/api/logout\", (req, res) => {\r\n\r\n    //判断该请求的是否已经登陆\r\n    if (!req.session.islogin) {\r\n        res.send({ \r\n            status: 1, \r\n            msg: \"logout失败\" \r\n        })\r\n        return;\r\n    }\r\n\r\n    //销毁该会话\r\n    req.session.destroy()\r\n    res.send({ status: 0, msg: \"logout成功\" })\r\n    return;\r\n})\r\n\r\napp.get(\"/api/get-username\", (req, res) => {\r\n    //判断该请求的是否已经登陆\r\n    if (!req.session.islogin) {\r\n        res.send({ \r\n            status: 1, \r\n            msg: \"get-username失败\" \r\n        })\r\n        return;\r\n    }\r\n    res.send({ \r\n        status: 0, \r\n        msg: \"get-username成功\", \r\n        username: req.session.userinfo.username \r\n    })\r\n    return;\r\n})\r\n\r\n\r\napp.listen(8000, () => {\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n\r\n\r\n## jwt认证完整案例\r\n\r\n```html\r\n    <!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n    <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n    <!-- axios 库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n    <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n\r\n\r\n    <h1>登陆</h1>\r\n    用户:<input type=\"text\" id=\"username\"><br>\r\n    密码:<input type=\"password\" id=\"password\"><br>\r\n    <button id=\"btn-login\">登陆</button>\r\n    <div id=\"login-result\"></div>\r\n    <script>\r\n        $(\"#btn-login\").click(function () {\r\n            // console.log(\"123\");\r\n            //axios(config)\r\n            axios({\r\n                method: 'post',\r\n                url: \"/api/login\",\r\n                data: {\r\n                    username: $(\"#username\").val(),\r\n                    password: $(\"#password\").val(),\r\n                }\r\n            })\r\n                .then((response) => {\r\n                    console.log(response);\r\n                    $(\"#login-result\").text(JSON.stringify(response.data))\r\n                    sessionStorage.setItem(\"token\", response.data.token) //保存token\r\n                })\r\n        })\r\n    </script>\r\n```\r\n\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\n//jwt身份认证\r\nconst jwtEncode = require(\"jsonwebtoken\") //加密\r\n// const jwtDecode = require(\"express-jwt\")  //解密\r\nvar { expressjwt: jwtDecode } = require(\"express-jwt\");\r\nconst secretKey = \"dfwofwiefjw0wfej02fj023j0r2\" //随便写一段密钥用于加密token\r\n\r\n//用于支持跨源\r\nconst cors = require(\"cors\")\r\napp.use(cors())\r\n\r\n// 静态资源\r\napp.use(express.static(\"./webRoot\"))\r\n\r\n//解密请求头中的 jwtToken 解析还原为json对象 并把解析出来的信息挂载到 req.auth 上\r\n//同时配置了访问权限 没有Token则不能访问任何接口 \r\n//unless指定某些页面不需要Token 这里指定 /api/login 不需要身份认证便能访问\r\napp.use(\r\n    jwtDecode({\r\n        secret: secretKey,\r\n        algorithms: [\"HS256\"] //防止潜在的降级攻击所必需的\r\n    })\r\n        .unless({ path: [/^\\/api\\/login/] }) //指定 /api/login 不需要身份认证便能访问\r\n)\r\n\r\n//用于req.body\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\n//登陆api\r\napp.post(\"/api/login\", (req, res) => {\r\n\r\n    //判断用户名和密码是否正确\r\n    if (req.body.username != \"admin\" && req.body.password != \"admin\") {\r\n        res.send({\r\n            status: 1,\r\n            msg: \"登陆失败\"\r\n        })\r\n        return;\r\n    }\r\n\r\n    //生成token\r\n    //sign方法:sign(参数1,参数2,参数3)\r\n    // 参数1 待加密的数据\r\n    // 参数2 加密密钥\r\n    // 参数3 配置项,可配置有效期\r\n    var token = jwtEncode.sign({ username: req.body.username }, secretKey, { expiresIn: \"30s\" })\r\n    //发送token\r\n    res.send({\r\n        status: 0,\r\n        msg: \"登陆成功\",\r\n        token: token\r\n    })\r\n})\r\n\r\n// app.get(\"/api/logout\", (req, res) => {\r\n// logout不需要服务端执行任何操作了 只需要客户端删除token就好了\r\n//     res.send({ \r\n//         status: 0, \r\n//         msg: \"logout成功\" \r\n//     })\r\n//     return;\r\n// })\r\n\r\napp.get(\"/api/get-userinfo\", (req, res) => {\r\n    res.send({\r\n        status: 0,\r\n        msg: \"获取用户的信息成功\",\r\n        userinfo: req.auth\r\n    })\r\n    return;\r\n})\r\n\r\napp.use((err, res, req, next) => { //处理错误\r\n    if (err.name == \"UnauthorizedError\") {\r\n        req.send({\r\n            status: 401,\r\n            msg: \"未登陆或登陆状态已过期,请重新登陆\",\r\n            err: err\r\n        })\r\n    } else {\r\n        req.send({\r\n            status: 500,\r\n            msg: \"服务器未知错误\",\r\n            err: err\r\n        })\r\n    }\r\n}\r\n)\r\n\r\n\r\n\r\n\r\napp.listen(8000, () => {\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n\r\n```\r\n\r\n\r\n## 综合案例：结合jwt认证机制、express、mysql时间api服务器\r\n\r\n![](./images/express学习笔记/2022-11-24-09-21-34.png)\r\n\r\n`package.json`\r\n```json\r\n{\r\n  \"name\": \"api_server\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"keywords\": [],\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"bcryptjs\": \"^2.4.3\",\r\n    \"express-jwt\": \"^7.7.5\",\r\n    \"joi\": \"^17.6.0\"\r\n  }\r\n}\r\n```\r\n\r\n`index.js`\r\n```js\r\nconst express = require(\"express\")\r\nconst cors = require(\"cors\")\r\nconst confg = require(\"./confg\")\r\nvar { expressjwt: jwtDecode } = require(\"express-jwt\");\r\n\r\n\r\nconst app = express()\r\n\r\n\r\napp.use((req,res,next)=>{\r\n    res.msgSend=(msg,errMsg=null,status=1,data=null)=>{\r\n        res.send(\r\n            {\r\n                status,\r\n                msg,\r\n                errMsg,\r\n                data\r\n            }\r\n        )\r\n    }\r\n    next()\r\n})\r\napp.use(\r\n    jwtDecode({\r\n        secret:confg.jwtSecretKey,\r\n        algorithms: [\"HS256\"]\r\n    })\r\n        .unless({path:[/\\/api/]})\r\n)\r\napp.use(cors())//跨域访问访问中间件\r\napp.use(express.json())//解析请求体中json格式字符串中间件\r\napp.use(express.urlencoded({extended:false}))//解析请求体中url格式字符串中间件\r\n\r\n\r\n\r\nconst user = require(\"./router/user\")\r\napp.use(\"/api\",user)//注册user模块\r\n\r\nconst userinfo = require(\"./router/userinfo\")\r\napp.use(\"/my\",userinfo)//注册userinfo模块\r\n\r\n\r\napp.use((err,req,res,next)=>{\r\n    if(err.name === \"UnauthorizedError\")\r\n        res.msgSend(\"身份认证失败,未登陆或登陆超时,请重新登陆\",err.message)\r\n    else\r\n        res.msgSend(\"未知错误\",err.message)\r\n    next()\r\n})\r\n\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"api server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n\r\n\r\n`confg.js`\r\n```js\r\nconst jwtSecretKey = \"2374bnp0r0fj3u3t7gh452ris95247\" // 随便写的用于加密的字符串\r\nconst jwtExpiresIn = \"6h\" // jwt过期时间\r\n\r\n\r\nmodule.exports ={\r\n    jwtSecretKey,\r\n    jwtExpiresIn\r\n} \r\n```\r\n\r\n`db/mysql.js`\r\n```js\r\nconst mysql = require(\"mysql\")\r\n\r\nconst db = mysql.createPool(\r\n    {\r\n        host:\"127.0.0.1\",\r\n        user:\"root\",\r\n        password: \"root\",\r\n        database: \"my_db_01\"\r\n    }\r\n)\r\nmodule.exports = db\r\n\r\n/*\r\n\r\nmy_db_01\r\n    tb_users\r\n        id INT auto_increment NOT NULL UNIQUE PRIMARY KEY,\r\n        username VARCHAR(255) NOT NULL UNIQUE,\r\n        password VARCHAR(255) NOT NULL,\r\n        nickname VARCHAR(255) ,\r\n        email VARCHAR(255) ,\r\n        user_pic TEXT ,\r\n\r\nvar sql = `\r\nCREATE DATABASE IF NOT EXISTS my_db_01;\r\nuse my_db_01;\r\nCREATE TABLE IF NOT EXISTS `my_db_01`.`tb_users` (\r\n  `id` INT NOT NULL AUTO_INCREMENT,\r\n  `username` VARCHAR(255) NOT NULL,\r\n  `password` VARCHAR(255) NOT NULL,\r\n  `email` VARCHAR(255) NULL,\r\n  `user_pic` TEXT NULL,\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE INDEX `id_UNIQUE` (`id` ASC) VISIBLE,\r\n  UNIQUE INDEX `username_UNIQUE` (`username` ASC) VISIBLE);\r\n`\r\ndb.query(sql,(err,result)=>{\r\n    console.log(err || result);\r\n})\r\n\r\n*/\r\n```\r\n\r\n`router/user.js`\r\n```js\r\nconst express = require(\"express\")\r\nconst user_handler = require(\"../router_handler/user\")\r\nconst router = express.Router()\r\n\r\nrouter.post(\"/signup\",user_handler.signup)\r\nrouter.post(\"/signin\",user_handler.signin)\r\n\r\nmodule.exports=router\r\n```\r\n\r\n`router_handler/user.js`\r\n```js\r\nconst db = require(\"../db/mysql\")\r\nconst bcrypt = require(\"bcryptjs\")\r\nconst Joi = require(\"joi\")\r\nconst { sign_schema } = require(\"../schema\")\r\nconst jwt = require(\"jsonwebtoken\")\r\nconst confg = require(\"../confg\")\r\n\r\n\r\n\r\nexports.signup = (req, res) => {//注册接口\r\n    const userinfo = req.body\r\n    const value = sign_schema.validate({ username: userinfo.username, password: userinfo.password });//验证帐号密码合法性\r\n    if (value.error) {\r\n        return res.msgSend(\"用户名或密码格式不合法\", value.error.details)\r\n    } else {\r\n        const sql = \"select * from tb_users where username=?\"\r\n        db.query(sql, userinfo.username, (err, result) => {\r\n            if (err)\r\n                return res.msgSend(\"SQL查询用户是否存在失败\", err.message)\r\n            else if (result.length != 0) {\r\n                return res.msgSend(\"用户名被占用,请更换其他用户名\")\r\n            } else {\r\n                const passwordHash = bcrypt.hashSync(userinfo.password)//对密码进行加密\r\n                const sql = \"insert into tb_users set ?\"\r\n                db.query(sql, { username: userinfo.username, password: passwordHash }, (err, result) => {\r\n                    if (err)\r\n                        return res.msgSend(\"注册用户失败\", err.message)\r\n                    else if (result.affectedRows == 0) {\r\n                        return res.msgSend(\"注册用户失败\")\r\n                    } else\r\n                        return res.msgSend(\"注册用户成功\", null, 1)\r\n                })\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nexports.signin = (req, res) => {//登陆接口\r\n    //应当先验证帐号密码是否合法;否则直接用该数据来拼接SQL查询语句将有可能导致数据库遭到注入攻击\r\n    const userinfo = req.body\r\n    const value = sign_schema.validate({ username: userinfo.username, password: userinfo.password });//验证帐号密码合法性\r\n    if (value.error) {\r\n        return res.msgSend(\"用户名或密码格式不合法\", value.error.details)\r\n    } else {\r\n        const sql = \"select * from tb_users where username=?\"\r\n        db.query(sql, userinfo.username, (err, result) => {//查询用户名是否存在\r\n            if (err)\r\n                return res.msgSend(\"SQL查询用户是否存在失败\", err.message)\r\n            else if (result.length != 1) {//查询结果应当有且只有一个\r\n                return res.msgSend(\"用户名不存在\")\r\n            } else if (bcrypt.compareSync(userinfo.password, result[0].password) == false) {//验证密码是否正确\r\n                return res.msgSend(\"密码错误,登陆失败\")\r\n            } else {\r\n                const token = jwt.sign({ username: result[0].username, id: result[0].id }, confg.jwtSecretKey, { expiresIn: confg.jwtExpiresIn }) //生成token\r\n                return res.send({\r\n                    status: 0,\r\n                    msg: \"登陆成功\",\r\n                    token: \"Bearer \" + token //返回拼接好的token\r\n                })\r\n            }\r\n        })\r\n    }\r\n}\r\n```\r\n\r\n`router/userinfo.js`\r\n```js\r\nconst express = require(\"express\")\r\nconst userinfo_handler = require(\"../router_handler/userinfo\")\r\nconst router = express.Router()\r\n\r\nrouter.get(\"/getuserinfo\",userinfo_handler.getUserInfo)\r\nrouter.post(\"/setuserinfo\",userinfo_handler.setUserInfo)\r\nrouter.post(\"/update/avatar\",userinfo_handler.updateAvatar)\r\n\r\nmodule.exports=router\r\n```\r\n\r\n`router_handler/userinfo.js`\r\n```js\r\nconst db = require(\"../db/mysql\")\r\nconst bcrypt = require(\"bcryptjs\")\r\n\r\nconst { setUserInfo_schema } = require(\"../schema\")\r\nconst { updateAvatar_schema } = require(\"../schema\")\r\n\r\nmodule.exports.getUserInfo = (req, res) => {\r\n    const userId = req.auth.id\r\n    const sql = \"select * from tb_users where id=?\"\r\n    db.query(sql, userId, (err, result) => {\r\n        if (err) {\r\n            return res.msgSend(\"SQL查询用户失败\", err.message)\r\n        } else if (result.length != 1)\r\n            return res.msgSend(\"SQL查询用户信息不唯一\")\r\n        else {\r\n            res.msgSend(\"获取用户信息成功\", null, 0, { ...result[0], password: \"\" })\r\n        }\r\n    })\r\n}\r\n\r\n\r\n\r\nmodule.exports.setUserInfo = (req, res) => {\r\n    const userId = req.auth.id\r\n    const userInfo = req.body\r\n    const value = setUserInfo_schema.validate({ nickname: userInfo.nickname, password: userInfo.password, email: userInfo.email });//验证表单合法性\r\n    if (value.error) {\r\n        return res.msgSend(\"用户名或密码或email格式不合法\", value.error.details)\r\n    } else {\r\n        var setUserInfo = {}//构建用于用于更新数据库的对象\r\n        if (userInfo.password) {\r\n            setUserInfo.password = bcrypt.hashSync(userInfo.password)//对密码进行加密\r\n        }\r\n        if (userInfo.nickname) {\r\n            setUserInfo.nickname = userInfo.nickname\r\n        }\r\n        if (userInfo.email) {\r\n            setUserInfo.email = userInfo.email\r\n        }\r\n        const sql = \"update tb_users set ? where id=?\"\r\n        db.query(sql, [setUserInfo, userId], (err, result) => {\r\n            if (err)\r\n                return res.msgSend(\"设置用户信息失败\", err.message)\r\n            else if (result.affectedRows != 1) {\r\n                return res.msgSend(\"设置用户信息失败\")\r\n            } else\r\n                return res.msgSend(\"设置用户信息成功\", null, 0)\r\n        })\r\n    }\r\n}\r\n\r\n\r\nmodule.exports.updateAvatar = (req, res) => {\r\n    const userId = req.auth.id\r\n    const userInfo = req.body\r\n    const value = updateAvatar_schema.validate({ avatar: userInfo.avatar });//验证表单合法性\r\n    if (value.error) {\r\n        return res.msgSend(\"avatar格式不合法\", value.error.details)\r\n    } else {\r\n        const sql = \"update tb_users set ? where id=?\"\r\n        db.query(sql, [{user_pic:userInfo.avatar}, userId], (err, result) => {\r\n            if (err)\r\n                return res.msgSend(\"更新用户头像失败\", err.message)\r\n            else if (result.affectedRows != 1) {\r\n                return res.msgSend(\"更新用户头像失败\")\r\n            } else\r\n                return res.msgSend(\"更新用户头像成功\", null, 0)\r\n        })\r\n    }\r\n}\r\n```\r\n\r\n`schema/index.js`\r\n```js\r\nconst Joi = require(\"joi\")\r\n\r\nconst id = Joi.number().integer().min(1)\r\nconst username = Joi.string().alphanum().min(3).max(30)\r\nconst password = Joi.string().alphanum().min(3).max(30)//.pattern(new RegExp('^[a-zA-Z0-9]{3,30}$'))\r\nconst nickname = Joi.string().alphanum().min(3).max(30)\r\nconst email= Joi.string().email({ minDomainSegments: 2, tlds: { allow: ['com', 'net'] } })\r\nconst avatar = Joi.string().dataUri()//'data:image/png;base64,VE9PTUFOWVNFQ1JFVFM='\r\n\r\nconst sign_schema = Joi.object({\r\n    username:username.required(),\r\n    password:password.required(),\r\n})\r\n\r\nconst setUserInfo_schema = Joi.object({\r\n    // id,//id不允许修改\r\n    // username,//username不允许修改\r\n    nickname,\r\n    password,\r\n    email\r\n    }).or(\"nickname\",\"password\",\"email\") //至少包含一个信息\r\n\r\nconst updateAvatar_schema = Joi.object({\r\n    avatar:avatar.required() \r\n\r\n})\r\n\r\nmodule.exports.sign_schema = sign_schema\r\nmodule.exports.setUserInfo_schema = setUserInfo_schema\r\nmodule.exports.updateAvatar_schema = updateAvatar_schema\r\n```\r\n\r\n<style>\r\n    red{\r\n        color:red;\r\n    }\r\n    gre{\r\n        color:green;\r\n    }\r\n    sky{\r\n        color:skyblue;\r\n    }\r\n</style>"},{"shortInfo":{"title":"flexible.js源码分析","date":"2022-07-05T02:52:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["js","源码分析","前端"],"hideAtIndex":true,"categories":"笔记","id":1001296160,"countWords":854,"readSeconds":85.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# flexible.js源码分析\r\n\r\nflexible.js是手淘开发出的一个用来适配移动端的js框架。手淘框架的核心原理就是根据不同的视口宽度给html根标签设置不同的font-size，然后所有的px都用rem来代替，这样就实现了不同大小的屏幕都适应相同的样式了。\r\n\r\n\r\n## 最外层\r\n* 最外层是一个立即执行函数，\r\n* 接收的实参为window和document对象\r\n* 其中所有变量都是局部变量，不会造成变量名冲突\r\n\r\n```js\r\n(function flexible (window, document) {\r\n    //立即执行函数\r\n}(window, document))\r\n```\r\n\r\n\r\n## 变量\r\n```js\r\n//documentElement是html根标签\r\n  var docEl = document.documentElement\r\n//devicePixelRatio是物理像素比，一般pc端是1 手机端是2\r\n  var dpr = window.devicePixelRatio || 1\r\n```\r\n\r\n\r\n## 设置body字体大小\r\n```js\r\n  // adjust body font size\r\n  function setBodyFontSize () {\r\n    if (document.body) {//判断是否有body元素\r\n      document.body.style.fontSize = (12 * dpr) + 'px' //设置body的Font-size:(12*dpr)px\r\n    }\r\n    else {\r\n        //如果页面没有body，则添加DOMContentLoaded事件监听器，待DOM加载完毕后再来执行该函数\r\n      document.addEventListener('DOMContentLoaded', setBodyFontSize)\r\n    }\r\n  }\r\n  setBodyFontSize();\r\n```\r\n\r\n\r\n## 设置html文字大小\r\n* pageshow是页面显示时触发的事件，无论页面是否来自缓存；\r\n* 该事件会在load事件触发之后触发；\r\n* 该事件对象中persisted属性可以用来判断是否是缓存中的页面触发的pageshow事件\r\n* 该事件添加给window\r\n* 此处不能用load事件来代替的原因是：\r\n    * load事件虽可以在点击超链接、f5刷新、强制刷新、前进后退后触发\r\n    * 但在火狐浏览器中，存在“往返缓存”机制，后退页面时，整个DOM和js的状态都被存储在了内存中，此时再点击前进按钮回到页面，整个页面不会重新加载，不会触发load事件\r\n\r\n```js\r\n  \r\n  function setRemUnit () {\r\n    var rem = docEl.clientWidth / 10 // 设置 1rem = 视口宽度 / 10\r\n    docEl.style.fontSize = rem + 'px' // 为HTML根标签设置字体大小\r\n  }\r\n\r\n  setRemUnit() // 调用\r\n\r\n  // 添加监听事件，当窗口改变大小后重新根据视口宽度计算1rem大小\r\n  window.addEventListener('resize', setRemUnit)\r\n  //页面显示时触发的事件\r\n  window.addEventListener('pageshow', function (e) {\r\n    if (e.persisted) {//如果页面是从缓存中取出的\r\n      setRemUnit()\r\n    }\r\n  })\r\n```\r\n\r\n\r\n## 使移动端支持0.5px\r\n```js\r\n//移动端检测是否支持0.5px，若支持则添加类名使其向下兼容\r\n  if (dpr >= 2) {//检测是否是移动端\r\n   //创建一个假body元素\r\n    var fakeBody = document.createElement('body')\r\n     //创建一个测试元素\r\n    var testElement = document.createElement('div')\r\n     //给测试元素添加0.5px的边框\r\n    testElement.style.border = '.5px solid transparent'\r\n    //将测试元素附加给假body元素\r\n    fakeBody.appendChild(testElement)\r\n    //将假body元素附加给html根标签\r\n    docEl.appendChild(fakeBody)\r\n    // 检测测试元素的高度是否为1，若是则说明支持0.5px的写法\r\n    if (testElement.offsetHeight === 1) {\r\n        //为根标签添加样式类名 通过添加类名hairlines来向下兼容\r\n      docEl.classList.add('hairlines')\r\n    }\r\n    //移除假body元素\r\n    docEl.removeChild(fakeBody)\r\n  }\r\n```\r\n\r\n\r\n## 完整源码\r\n```js\r\n(function flexible (window, document) {\r\n  var docEl = document.documentElement\r\n  var dpr = window.devicePixelRatio || 1\r\n\r\n  // adjust body font size\r\n  function setBodyFontSize () {\r\n    if (document.body) {\r\n      document.body.style.fontSize = (12 * dpr) + 'px'\r\n    }\r\n    else {\r\n      document.addEventListener('DOMContentLoaded', setBodyFontSize)\r\n    }\r\n  }\r\n  setBodyFontSize();\r\n\r\n  // set 1rem = viewWidth / 10\r\n  function setRemUnit () {\r\n    var rem = docEl.clientWidth / 10\r\n    docEl.style.fontSize = rem + 'px'\r\n  }\r\n\r\n  setRemUnit()\r\n\r\n  // reset rem unit on page resize\r\n  window.addEventListener('resize', setRemUnit)\r\n  window.addEventListener('pageshow', function (e) {\r\n    if (e.persisted) {\r\n      setRemUnit()\r\n    }\r\n  })\r\n\r\n  // detect 0.5px supports\r\n  if (dpr >= 2) {\r\n    var fakeBody = document.createElement('body')\r\n    var testElement = document.createElement('div')\r\n    testElement.style.border = '.5px solid transparent'\r\n    fakeBody.appendChild(testElement)\r\n    docEl.appendChild(fakeBody)\r\n    if (testElement.offsetHeight === 1) {\r\n      docEl.classList.add('hairlines')\r\n    }\r\n    docEl.removeChild(fakeBody)\r\n  }\r\n}(window, document))\r\n```\r\n\r\n"},{"shortInfo":{"layout":"post","title":"Flex布局模型项目实战","date":"2022-06-19T22:39:00.000Z","tags":["网站","demo"],"hideAtIndex":true,"categories":"前端","cover":"\\self_server\\assets\\images\\default_cover2.jpg","id":2645433642,"countWords":59,"readSeconds":5.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# Flex布局模型项目实战\r\n\r\n## Demos\r\n* [-->移动端小兔仙儿下单页<--](./demos/Flex布局模型项目实战/xiaotuxianOrders/order)\r\n* [-->PC端小兔仙儿个人中心页<--](./demos/Flex布局模型项目实战/xiaotuxianCenter/center)\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"layout":"post","title":"font-class图标使用","date":"2022-02-23T02:31:00.000Z","cover":"\\self_server\\assets\\images\\font_class图标使用.png","tags":["font-class","笔记","前端"],"hideAtIndex":true,"categories":"前端","reprint":true,"id":3641748571,"countWords":123,"readSeconds":12.3,"assetsbaseUrl":"/self_server/assets/"},"content":"## 阿里巴巴矢量图标库\r\nhttps://www.iconfont.cn/\r\n\r\n## font-class 引用\r\nfont-class使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。\r\n\r\n使用步骤如下：\r\n\r\n第一步：引入项目下面生成的 fontclass 代码：\r\n```\r\n<link rel=\"stylesheet\" href=\"./iconfont.css\">\r\n```\r\n\r\n第二步：挑选相应图标并获取类名，应用于页面：\r\n```\r\n<span class=\"iconfont icon-xxx\"></span>\r\n```\r\n\" iconfont\" 是你项目下的 font-family。可以通过编辑项目查看，默认是 \"iconfont\"。\r\n\r\n"},{"shortInfo":{"title":"frp配置过程记录(ipad远程登录电脑)","date":"2022-08-04T12:26:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["frp","linux","ipad"],"hideAtIndex":true,"categories":"笔记","id":3720745835,"countWords":608,"readSeconds":60.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# frp配置过程记录(ipad远程登录电脑)\r\n\r\n\r\n## 服务端配置过程\r\n\r\n**准备工作**\r\n```bash\r\n# 从github下载frp的releases版本\r\nwget -O https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz\r\n# 解压\r\ntar -xvf ./frp_0.44.0_linux_amd64.tar.gz\r\n# 进入目录\r\ncd ./frp_0.44.0_linux_amd64\r\n# 创建文件夹\r\nmkdir ~/frps/\r\n# 移动\r\nmv ./frps ~/frps/\r\n# 添加执行权限\r\nchmod +x ~/frps/frps\r\n```\r\n\r\n\r\n**编写配置文件**\r\n```bash\r\ncat > ~/frps/frps.ini  << EOF\r\n# frps.ini\r\n[common]\r\n# 这里是基本配置部分\r\nbind_port = 7000\r\nbind_udp_port = 7000\r\n\r\n# 这里设置鉴权方式为:token\r\nauthentication_method = token\r\n# 随便写一段英文+数字 服务端和客户端需一致\r\ntoken = swhm3elmbxnbnuqvoh5i5wlitjyymv22\r\nEOF\r\n```\r\n\r\n**临时启动服务测试是否配置成功**\r\n```bash\r\n~/frps/frps -c ~/frps/frps.ini\r\n```\r\n\r\n\r\n**配置开机自启:创建并编辑 frps.service 文件**\r\n\r\n```bash\r\n# su用于提权 否则无法使用cat\r\nsu\r\ncat > /etc/systemd/system/frps.service  << EOF\r\n# for redhat8\r\n[Unit]\r\n# 服务名称，可自定义\r\nDescription = frp server\r\nAfter = network.target syslog.target\r\nWants = network.target\r\n\r\n[Service]\r\nType = simple\r\n# 启动frps的命令，需修改为您的frps的安装路径\r\n# /home/userName/ 为路径\r\nExecStart = /home/dyg/frps/frps -c /home/dyg/frps/frps.ini\r\n\r\n[Install]\r\nWantedBy = multi-user.target\r\nEOF\r\n```\r\n\r\n**配置开机自启:使用 systemd 命令，管理 frps**\r\n```bash\r\n# 启动frp\r\nsystemctl start frps\r\n# 停止frp\r\nsystemctl stop frps\r\n# 重启frp\r\nsystemctl restart frps\r\n# 查看frp状态\r\nsystemctl status frps\r\n# 配置 frps 开机自启\r\nsystemctl enable frps\r\n# 取消配置 frps 开机自启\r\nsystemctl disable frps\r\n```\r\n\r\n\r\n\r\n## 客户端配置（win10电脑）\r\n**frpc.ini文件**\r\n```txt\r\n[common]\r\nprotocol = tcp\r\n# xx.xx.xx.xx 为服务端ip地址或域名\r\nserver_addr = xx.xx.xx.xx\r\nserver_port = 7000\r\nauthentication_method = token\r\n# 随便写一段英文+数字 服务端和客户端需一致\r\ntoken = swhm3elmbxnbnuqvoh5i5wlitjyymv22\r\n\r\n# win10远程桌面TCP配置\r\n[mstsc_TCP]\r\ntype = tcp\r\nlocal_ip = 127.0.0.1\r\nlocal_port = 3389\r\nremote_port = 11111\r\n\r\n# win10远程桌面UDP配置\r\n[mstsc_UDP]\r\ntype = udp\r\nlocal_ip = 127.0.0.1\r\nlocal_port = 3389\r\nremote_port = 11111\r\n```\r\n\r\n**启动服务**\r\n将frpc.exe和frpc.ini放置到相同目录,然后执行\r\n```bash\r\n./frpc.exe\r\n```\r\n\r\n\r\n\r\n## 客户端配置2（ubuntu20.04）\r\n适用于ubuntu centos\r\n```bash\r\n# 切换目录\r\ncd frp_0.44.0_linux_amd64/\r\n# frpc拷贝到/usr/local/bin/\r\nsudo cp frpc /usr/local/bin/frpc\r\n# frpc.ini拷贝到/etc/frp/\r\nsudo mkdir /etc/frp/\r\nsudo cp frpc.ini /etc/frp/\r\n# 编辑配置为系统服务\r\nvim /usr/lib/systemd/system/frpc.service\r\n#########################################\r\n[Unit]\r\nDescription=frpc\r\nAfter=network.target\r\n[Service]\r\nTimeoutStartSec=1\r\nExecStart=/usr/local/bin/frpc -c /etc/frp/frpc.ini\r\nExecStop=/bin/kill $MAINPID\r\n[Install]\r\nWantedBy=multi-user.target\r\n###########################################\r\n\r\n# 启动 frp 并设置开机启动\r\nsystemctl enable frpc\r\nsystemctl start frpc\r\nsystemctl status frpc\r\n \r\n# 部分服务器上,可以需要加 .service 后缀来操作,即:\r\nsystemctl enable frpc.service\r\nsystemctl start frpc.service\r\nsystemctl status frpc.service\r\n```"},{"shortInfo":{"title":"gitalk使用问题和解决方案及相关知识点简记","date":"2022-06-02T18:40:47.000Z","tags":["gitalk"],"hideAtIndex":true,"catalagues":"笔记","cover":"\\self_server\\assets\\images\\default_cover2.jpg","id":2074766430,"countWords":2001,"readSeconds":200.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# gitalk使用问题和解决方案及相关知识点简记\r\n* 遇到的问题是管理员突然无法初始化文章底部的评论区\r\n* 了解其工作原理和造成该问题的原因后发现没有简单的解决方法\r\n* 在此简要记录一下造成的原因和其中一些原先不懂的知识点\r\n\r\n## 问题及原因\r\n1. 管理者初始化某篇文章下的评论区实际上就是登陆`github`并用其账号创建一个`issue`的过程，完成这个操作前需要：用户授权code + `clientID`+`clientSecret` 向`https://github.com/login/oauth/access_token`发送`POST`请求以获取`access_token`\r\n1. 但由于当前的站点页面是`username.github.io`,需要另外请求资源的地址是`github.com`,这属于`跨域访问`，需要发送`跨域访问请求`，而此时 `https://github.com/login/oauth/access_token` ，**不支持跨域访问请求**，所以无法获取 `access_token`\r\n1. 于是就要通过允许跨域访问的公用代理服务器`https://cors-anywhere.herokuapp.com/`，告诉他你要访问什么地址，需要发送什么数据，让它来做代理，替你获取`access_token`\r\n1. `gitalk`原先`默认`使用的是`https://cors-anywhere.azm.workers.dev`，其服务器在国外，现已经被墙\r\n1. 而`https://cors-anywhere.herokuapp.com/`是`cors-anywhere`项目的示例服务器，由于使用的人太多，现在已经被限制使用\r\n1. 并且使用上述两个公用的代理服务器是不安全的，因为获取`access_token`需要把`秘钥clientSecret`发送给他们\r\n\r\n## 注意\r\n* 这里的clientID是OAuth应用程序的ID\r\n* 这里的clientSecret是OAuth应用程序用于授权登录的秘钥\r\n* GitHub授权登录过程\r\n    1. 首先授权账号的 OAuth 服务。\r\n    1. **Get**   `https://github.com/login/oauth/authorize?client_id=?&redirect_uri=?`\r\n        + 携带的必须参数的是`client_id`和`redirect_uri`(和设置OAuth时的地址相同)\r\n        + 用户登录github账号并且点击授权登录之后\r\n        + Github会返回一个`code`\r\n        + 并重定向到`redirect_uri`\r\n    1. **Post**  `https://github.com/login/oauth/access_token`\r\n        + 携带的必须参数为 `client_id`    `client_secret`      `code`      `redirect_uri`\r\n        + 然后Github会返回一个`access_token`\r\n        + 并重定向到我们的`redirect_uri`\r\n    1. **Get**  `https://api.github.com/user`\r\n        + 携带的参数格式为 Header:   \"Authorization\" : \"token access_token \"\r\n    1. Github返回我们的user信息，授权登录完成。\r\n\r\n\r\n## 解决方案\r\n* 可以用`cors-anywhere`项目的解决方案\r\n* 也可以只在本地架设代理服务器\r\n    * 好处是不会暴露秘钥\r\n    * 坏处是只能在本地初始化评论区\r\n* 本地用python架设代理服务器：\r\n    * flask不适用于生产环境\r\n    * 有空打算写一个nodejs版的\r\n```python\r\nimport requests\r\nimport flask\r\nfrom flask_cors import CORS\r\n\r\nserver = flask.Flask(__name__)\r\n\r\n# 跨域访问问题\r\nCORS(server, resources=r'/*')\r\n\r\n# github auth\r\nclient_id = \"你自己的\"\r\nclient_secret = \"你自己的\"\r\n\r\n\r\n# 接口返回格式 {\"access_token\":\"gho_COSr3lUITUX9b2J7krsKjNlnlNSOBw2g0oZ1\",\"token_type\":\"bearer\",\"scope\":\"public_repo\"}\r\n@server.post('/get_access_token')\r\ndef get_access_token():\r\n    url = 'https://github.com/login/oauth/access_token'\r\n    params = {\r\n        'client_id': client_id,\r\n        'client_secret': client_secret,\r\n        'code': flask.request.json['code']\r\n    }\r\n    headers = {\r\n        'accept': 'application/json'\r\n    }\r\n    result = requests.post(url=url, params=params, headers=headers, verify=False)\r\n    # 存储access_token\r\n    # ..暂时不需要\r\n    return result.json()\r\n\r\n\r\nif __name__ == '__main__':\r\n    server.run(host='0.0.0.0', port=8011, debug=False)\r\n\r\n\r\n## copy from \"https://apidocs.cn/blog/front/js/修改Gitalk代理地址，解决无法登录问题.html\"\r\n```\r\n* 然后Gitalk的代码也需要更改：\r\n```js\r\nnew Gitalk({\r\n    // '''\r\n    proxy: 'https://IP:PORT/get_access_token'\r\n    //clientSecret: '', 此行配置可以去除了\r\n    // '''\r\n})\r\n```\r\n\r\n## 关于跨域请求\r\n* 跨域资源共享(CORS)是一种机制\r\n* 它允许浏览器向跨源服务器，发出XMLHttpRequest或Fetch请求。并且整个CORS通信过程都是浏览器自动完成的，不需要用户参与。\r\n* 过程\r\n    - 浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。\r\n    - 服务器收到浏览器跨域请求后，根据自身配置返回对应文件头。若未配置过任何允许跨域，则文件头里不包含 Access-Control-Allow-origin 字段，若配置过域名，则返回 Access-Control-Allow-origin + 对应配置规则里的域名的方式。\r\n    - 浏览器根据接受到的 响应头里的 Access-Control-Allow-origin 字段做匹配，若无该字段，说明不允许跨域，从而抛出一个错误；若有该字段，则对字段内容和当前域名做比对，如果同源，则说明可以跨域，浏览器接受该响应；若不同源，则说明该域名不可跨域，浏览器不接受该响应，并抛出一个错误。\r\n* 举例来说\r\n    * 浏览器访问a.com时 页面中有一个资源来自b.com\r\n    * 浏览器获取来自a.com的资源时,发送普通请求；浏览器获取来自b.com的资源时，发送的是跨域请求.\r\n    * b.com的服务器如果不允许跨域，收到跨域请求后,发送响应，响应头中不包含Access-Control-Allow-origin 字段\r\n    * b.com的服务器如果允许跨域，收到跨域请求后,发送响应，响应头中包含Access-Control-Allow-origin + 允许的跨域规则（比如说www.*.com）\r\n    * 浏览器收到之后会看Access-Control-Allow-origin字段，没有这个字段就抛出错误\r\n    * 有这个字段还得看内容是不是包含a.com，不包含就抛出错误，包含就接受这个响应\r\n\r\n\r\n\r\n## CSDN上看到的相关知识点的总结\r\n```text\r\nCORS的哪些是简单请求？\r\n简单请求不会触发CORS的预检请求，若请求满足所有下述条件，则该请求可视为“简单请求”：\r\n\r\n简洁版：\r\n只能使用GET、HEAD、POST方法。使用POST方法向服务器发送数据时，Content-Type只能使用application/x-www-form-urlencoded、multipart/form-data\r\n或 text/plain 编码格式。\r\n请求时不能使用自定义的HTTP Headers\r\n\r\n完整版：\r\n\r\n(一) 使用下列方法之一\r\n\r\nGET HEAD POST\r\n\r\n(二) 只能设置以下集合中的请求头\r\n\r\nAccept Accept-Language Content-Language Content-Type(但是有限制) DPR\r\nDownlink Save-Data Viewport-Width Width\r\n\r\n(三) Content-Type的值仅限于下面的三者之一\r\n\r\ntext/plain multipart/form-data application/x-www-form-urlencoded\r\n\r\n请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。\r\n\r\n请求中没有使用 ReadableStream 对象。\r\n\r\n除了上面这些请求外，都是非简单请求。\r\n\r\nCORS的预检请求具体是怎样的？\r\n若是跨域的非简单请求的话，浏览器会首先向服务器发送一个预检请求，以获知服务器是否允许该实际请求。\r\n\r\n整个过程大概是：\r\n\r\n浏览器给服务器发送一个OPTIONS方法的请求，该请求会携带下面两个首部字段：\r\nAccess-Control-Request-Method: 实际请求要用到的方法\r\nAccess-Control-Request-Headers: 实际请求会携带哪些首部字段\r\n若是服务器接受后续请求，则这次预请求的响应体中会携带下面的一些字段：\r\nAccess-Control-Allow-Methods: 服务器允许使用的方法\r\nAccess-Control-Allow-Origin: 服务器允许访问的域名\r\nAccess-Control-Allow-Headers: 服务器允许的首部字段\r\nAccess-Control-Max-Age: 该响应的有效时间(s),在有效时间内浏览器无需再为同一个请求发送预检请求\r\n预检请求完毕之后，再发送实际请求\r\n这里有两点要注意（注意，注意，注意）：\r\n关于Access-Control-Max-Age，浏览器自身也有维护一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效，而是以最大有效时间为主。\r\n当你勾选了浏览器的 Disable cache选项时，会导致浏览器每次非简单请求都会发送预检请求\r\n————————————————\r\n版权声明：本文为CSDN博主「Henry_楠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/haonan_z/article/details/122105620\r\n\r\n```"},{"shortInfo":{"layout":"post","title":"gittalk的使用示例","date":"2022-02-23T12:38:00.000Z","cover":"\\self_server\\assets\\images\\gittalk.png","coverWidth":1430,"coverHeight":577,"tags":["笔记","gitalk"],"hideAtIndex":true,"categories":"前端","id":1450903631,"countWords":187,"readSeconds":18.7,"assetsbaseUrl":"/self_server/assets/"},"content":"## GitTalk 提示错误Error: Validation Failed. \r\n* 原因：提交的id过长（超出50）\r\n* 解决办法：使用id: decodeURI(location.href)\r\n\r\n## GitHub issue内容出现UTF-8编码的中文的解决\r\n* body: decodeURI(window.location.pathname)\r\n\r\n## 获取页面内容的简短描述（不好用）\r\n* document.getElementsByTagName(\"meta\")[\"description\"].content\r\n\r\n## 示例代码\r\n```\r\n//存放gitalk的div\r\n<div id=\"gitalk\"></div>\r\n\r\n//实例化\r\n<script type=\"text/javascript\">\r\n    var gitalk = new Gitalk({\r\n        clientID: \"必填\",\r\n        clientSecret: \"必填\",\r\n        repo: \"必填\",\r\n        owner: \"必填\",\r\n        admin: \"必填\",\r\n        \r\n        id: decodeURI(location.href),//页面的唯一标识。长度必须小于50。location.href是不包含域名的URL\r\n        title: document.title,//GitHub issue标题。\r\n        body: decodeURI(window.location.pathname),//GitHub issue内容 = 文章完整URL地址\r\n\r\n        pagerDirection: ,//评论排序方式\r\n        createIssueManually: ,//admin用户手动创建issue\r\n    })\r\n    gitalk.render('gitalk') //渲染到指定的id中\r\n</script>\r\n```"},{"shortInfo":{"layout":"post","title":"git命令备忘笔记","date":"2022-01-09T12:28:00.000Z","cover":"\\self_server\\assets\\images\\git.jpg","coverWidth":1915,"coverHeight":895,"tags":["笔记","git"],"categories":"笔记","id":1494261917,"countWords":2715,"readSeconds":271.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# git命令备忘笔记\r\n\r\n## 目录\r\n- [git命令备忘笔记](#git命令备忘笔记)\r\n  - [目录](#目录)\r\n  - [git用户配置](#git用户配置)\r\n  - [编辑git配置文件:](#编辑git配置文件)\r\n  - [查看配置信息](#查看配置信息)\r\n  - [git默认编辑器配置](#git默认编辑器配置)\r\n  - [git默认差异分析工具配置](#git默认差异分析工具配置)\r\n  - [基本操作](#基本操作)\r\n  - [有关创建与提交你的项目的快照的命令：](#有关创建与提交你的项目的快照的命令)\r\n  - [git-查看提交历史](#git-查看提交历史)\r\n  - [远程操作](#远程操作)\r\n  - [git分支管理](#git分支管理)\r\n  - [git 标签](#git-标签)\r\n  - [ssh加密通信配置](#ssh加密通信配置)\r\n  - [windows-git工具打开后自动测试](#windows-git工具打开后自动测试)\r\n  - [将已经提交到远程仓库的版本撤销](#将已经提交到远程仓库的版本撤销)\r\n  - [子仓库](#子仓库)\r\n    - [包含子仓库](#包含子仓库)\r\n    - [从远端克隆父仓库后子仓库为默认为空，需执行以下操作来下载子仓库](#从远端克隆父仓库后子仓库为默认为空需执行以下操作来下载子仓库)\r\n    - [删除误添加到暂存区的子仓库](#删除误添加到暂存区的子仓库)\r\n  - [提交信息为当前日期](#提交信息为当前日期)\r\n\r\n## git用户配置\r\n* `git config --global user.name \"YiguiDing\"`\r\n* `git config --global user.email 2449695354@qq.com`\r\n* `--global` 意味着配置文件写入进当前用户的家目录的全局配置文件\r\n* 去掉该选项意味着配置文件写入当前项目的`.git/config`文件文件\r\n\r\n## 编辑git配置文件:\r\n* `git config -e         `    # 针对当前仓库 \r\n* `git config -e --global ` # 针对系统上所有仓库\r\n\r\n## 查看配置信息\r\n* `git config --list`\r\n* 输出信息中重复的变量名代表来自不同的文件如\r\n  * 系统配置文件 `/etc/gitconfig `\r\n  * 全局配置文件 `~/.config `\r\n  * 项目配置文件 `./.git/config`\r\n* 查询单个配置变量 `git config user.name`\r\n\r\n## git默认编辑器配置\r\n* `git config --global core.editor vim`\r\n* 一般为vi vim 或特殊配置为Emacs\r\n\r\n## git默认差异分析工具配置\r\n* `git config --global merge.tool vimdiff`\r\n* Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。\r\n\r\n\r\n  \r\n## 基本操作\r\n* 将当前所在目录初始化为git仓库: `git init `\r\n* 将XXX目录初始化为git仓库: `git init XXX `\r\n* 告诉Git开始对这些文件进行跟踪: `git add 文件名`\r\n* 提交：`git commit -m \"提交消息\"`\r\n  * linux系统中提交用单引号，win用双引号\r\n* 推送到远程仓库：`git push origin master`\r\n* 克隆远程仓库 `git clone 仓库地址 [指定目录]`\r\n\r\n## 有关创建与提交你的项目的快照的命令：\r\n* `git add\t`    添加文件到暂存区\r\n  * `git add 文件名1 文件名2 文件名3`\r\n  * `git add 文件夹名`\r\n  * `git add . `当前所在文件夹\r\n* `git status`\t查看仓库当前的状态，显示有变更的文件。\r\n  * `-s`参数来获得简短的输出结果\r\n  * `红色??` 表示该文夹没有被追踪（添加到缓存区）\r\n  * `绿色A`  表示该文件已被追踪（添加到缓存区）\r\n  * `绿A红M `    表示该文件添加到缓存之后又有改动。\r\n* `git diff`\t    比较文件的不同，即暂存区和工作区的差异。\r\n  * 尚未缓存的改动：`git diff`\r\n  * 查看已缓存的改动： `git diff --cached`\r\n  * 查看已缓存的与未缓存的所有改动：`git diff HEAD`\r\n  * 显示摘要而非整个diff：`git diff --stat`\r\n  * 显示暂存区和工作区的差异: `git diff [file]`\r\n  * 显示暂存区和上一次提交(commit)的差异:\r\n    * `git diff --cached [file]`\r\n    * `git diff --staged [file]`\r\n  * 显示两次提交之间的差异:\r\n    * `git diff [first-branch]...[second-branch]`\r\n* `git commit`\t提交暂存区到本地仓库。\r\n  * 提交暂存区所有内容：`git commit -m [message]`\r\n  * 提交暂存区指定内容：`git commit [file1] [file2] ... -m [message]`\r\n  * `git -am \"修改了123.txt文件\"`\r\n    * `-a`意味着可以跳过`git add 123.txt`步骤，直接提交\r\n*` git reset`\t    回退版本。\r\n  * `git reset [--soft | --mixed | --hard] [HEAD]`\r\n  * `--soft` 工作区和暂存区内容保持不变，本地仓库回退一个版本\r\n  * `--mixed `为默认，工作区保持不变,暂存区内容回退到上一次提交版本\r\n  * `--hard` 工作区和暂存区内容都回退到上一次提交版本\r\n* `git rm`\t    删除工作区文件。\r\n  * 将文件从暂存区和工作区中删除(该文件提交到暂存区后未被修改)：`git rm fileName.txt`\r\n  * 强行从暂存区和工作区中删除一个文件(该文件提交到暂存区后又被修改)：`git rm -f fileName.txt `\r\n  * 将文件从暂存区删除，但在工作区中保留：`git rm --cached fileName.txt`\r\n  * 进入某个目录中，递归删除该目录下的所有文件和子目录： `git rm –r * `\r\n* `git mv`\t    移动或重命名工作区文件。\r\n  * 移动或重命名：`git mv [file] [newfile]`\r\n  * 强制移动并覆盖：`git mv -f [file] [newfile]`\r\n\r\n## git-查看提交历史\r\n* `git log` - 查看历史提交记录。\r\n  * `-6` 指定列出条数\r\n  *  `--oneline` 选项来查看历史记录的简洁的版本\r\n  *  `--all` 查看所有分支的提交历史\r\n  *  `--graph` 选项，查看历史中什么时候出现了分支、合并。\r\n  *  ` --no-merges` 选项以隐藏合并提交记录\r\n  *  `--reverse` 参数来逆向显示所有日志\r\n  *  `--author=YiguiDing` 查找指定用户的提交日志\r\n  *   `--after` `--since`指定日期之后，使用格式：`--after={2010-04-18}`\r\n  *   `--before` `--until`指定日期之前，使用格式：`--before={3.weeks.ago}` \r\n* `git blame file` - 以列表形式查看指定文件的历史修改记录。\r\n\r\n\r\n## 远程操作\r\n* `git remote`\t远程仓库操作\r\n  * `git remote show [remote]` 显示某个远程仓库详细信息\r\n  * `git remote add [shortName] [url]` 为一个远程库取一个**简短名**\r\n  * `git remote rm shortName`  # 删除远程仓库**简短名**\r\n  * `git remote reName old_shortName new_shortName`  # 修改仓库**简短名**\r\n  * `-v` 列举当前仓库remote远程仓库**简短名**和**实际地址**之间的对应关系\r\n* `git fetch`   从远程获取代码库\r\n  * `git fetch origin` 从远程获取代码库但不合并到当前分支\r\n  * `git merge origin/master` 将远程代码的主分支合并到当前分支\r\n* `git pull`    下载远程代码并合并\r\n  * 其实就是 `git fetch` 和 `git merge local_master` 的简写\r\n  * `git pull <远程主机名> <远程分支名>:<本地分支名>`\r\n  * `git pull origin master:brantest`将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。\r\n  * `git pull origin master`与当前分支合并,冒号后面的部分可以省略。\r\n* `git push`    上传远程代码并合并\r\n    * `git push <远程主机名> <本地分支名>:<远程分支名>` \r\n    * `git push <远程主机名> <本地分支名>` 如果远程分支名与本地分支名相同，则可以省略冒号`:`及其之后内容\r\n\r\n## git分支管理\r\n* `git branch`列出分支\r\n* `git branch newBranchName`创建一个分支\r\n  * `-b` 创建分支后立马切换\r\n  * `-d` 删除分支\r\n* `git checkout newBranchName`切换到新创建的分支\r\n* 分支切换时，如果工作区内容的全部提交，工作区的全部内容会变成新分支的内容，否则未提交的内容会带新分支去\r\n* `git merge branchA` 将分支branchA合并到当前分支中去\r\n  * 合并完成后可以删除branchA分支\r\n  * 当两个分支内容存在冲突时，合并的操作步骤：\r\n    1. 执行合并操作\r\n    1. 提示有文件存在冲突\r\n    1. 手动编辑那些已经合并但存在冲突的文件，删除冲突代码\r\n    1. 执行`git add 文件名` 用用于告诉Git 文件冲突已经解决\r\n    1. 不带参数的执行`git commit`\r\n    1. 成功合并后git将会做出提示\r\n\r\n## git 标签\r\n* `git tag` 默认为给最新一次提交（HEAD）打上标签\r\n* `git tag 3e92c19 ` 给3e92c19(commit id)打上标签\r\n* `-m` 指定标签信息注解内容,示例`git tag -a <tagname> -m \"runoob.com标签\"`\r\n* `-a` (annotated)选项意为\"创建一个带注解的标签\" 会记录这标签是啥时候打的，谁打的，\r\n* `-s` (signed)如果有私钥,可用GPG签署标签,示例：`git tag -s 标签名 -m '标签说明'`\r\n* `-d` 删除标签 `git tag -d 标签名`\r\n* `git show 标签名` 查看标签信息\r\n* `git tag` 查看所有标签\r\n* `git log --decorate` ，也可以看到打的标签\r\n\r\n## ssh加密通信配置\r\n* 配置成功后可以免密码向远程仓库推送\r\n  * 使用格式大致为`git push git@github.com:username/pathToProgectName.git localBranchName:remoteBranchName`\r\n1. 生成 SSH密钥 `ssh-keygen -t rsa -C \"youremail@example.com\"`\r\n    * 将生成两个文件 公钥 `~/.ssh/id_rsa.pub` 和 私钥`~/.ssh/id_rsa`\r\n        * 其中.ssh目录的权限最高允许为755，最低允许为700，也就是说属主用户的权限为rwx,其他用户不能拥有w权限\r\n        * 私钥的权限必须为600 \r\n        * 公钥的权限一般为644,最低应该是600\r\n        * `authoried_keys`权限一般为644，最低应该是600\r\n1. 将生成的SSH公钥附加到服务端的authoried_keys记录文件中\r\n    * 先在客户端将文件拷贝到服务端`scp ~/.ssh/id_rsa.pub root@域名或IP:~/.ssh/authorized_keys`\r\n    * scp使用SSH方式登录，会要求输入密码\r\n1. 再在服务端执行附加命令`cat id_rsa.pub >> authorized_keys`\r\n1. 确保服务端的SSH配置`/etc/ssh/sshd_config`文件中有：\r\n    * `RSAAuthentication yes`\r\n    * `PubkeyAuthentication yes`\r\n    * 其他无关紧要的配置\r\n      * `PermitRootLogin yes`\r\n      * `PasswordAuthentication no`\r\n    * 如有不同需要修改,然后重启服务`service sshd restart`\r\n1. 客户端SSH配置示例`/etc/ssh/ssh_config`\r\n```\r\nHost *\r\n  IdentityFile ~/.ssh/id_rsa\r\nHost github.com\r\n  IdentityFile ~/.ssh/id_rsa\r\nHost gitee.com\r\n  IdentityFile ~/.ssh/id_rsa\r\n```\r\n\r\n## windows-git工具打开后自动测试\r\n附加两行内容到`/etc/profile`或`~/.profile`文件中\r\n  * `ssh git@github.com`\r\n  * `ssh git@gitee.com\r\n`\r\n\r\n## 将已经提交到远程仓库的版本撤销\r\n* `git log --oneline` 找出上一次提交版本的commitID\r\n* `git reset --mixed xxxx` 将缓存区恢复成该commitID\r\n* `git add .` 重新将工作区文件添加到缓存区\r\n* `git commit -m \"xxxxxxx\"` 提交到本地仓库\r\n* `git push origin master --force` 强制推送到远程仓库\r\n\r\n\r\n## 子仓库\r\n### 包含子仓库\r\n* 格式：`git submodule add \"url\" \"add_To_path\"`\r\n    * `git submodule add git@github.com:YiguiDing/js_russuaGame.git`\r\n    * `git submodule add git@github.com:YiguiDing/js_russuaGame.git ./js_russuaGame`\r\n\r\n### 从远端克隆父仓库后子仓库为默认为空，需执行以下操作来下载子仓库\r\n* `git submodule init`\r\n* `git submodule update`\r\n\r\n### 删除误添加到暂存区的子仓库\r\n* `git rm --cached html-js_russiaGame`\r\n\r\n## 提交信息为当前日期\r\n* `git commit -m \"$(date)\"`\r\n* **$(command)** 与 **\\`command\\`**\r\n  * linux中**echo $(date)** 和 **echo \\`date\\`** 的作用是将date命令的结果用echo输出\r\n  * 在Windows的git工具中两种都能使用（类似Linux环境）\r\n  * 但是在powerShell中只有第一种能使用\r\n"},{"shortInfo":{"layout":"post","title":"Hexo备忘笔记","date":"2022-02-23T01:50:00.000Z","cover":"\\self_server\\assets\\images\\Hexo.jpg","tags":["笔记","Hexo"],"hideAtIndex":true,"categories":"笔记","id":2598071876,"countWords":360,"readSeconds":36,"assetsbaseUrl":"/self_server/assets/"},"content":"# Hexo安装使用\r\nHexo 是一个快速、简洁且高效的博客框架。\r\nNexmoe是该博客框架的一个主题\r\n\r\n1. 创建conda环境（可有可无\r\n    * conda creat --name Hexo\r\n    * conda activate Hexo\r\n\r\n\r\n1. 安装 Hexo \r\n\t* 环境安装\r\n\t\tNode.js（包含npm，npx\r\n\t\tGit\r\n\t* 安装 Hexo\r\n\t\t安装给当前目录的项目：\r\n\t\t\tnpm install hexo\r\n\t\t安装到全局：（如果不想把所有文件防在当前目录）\r\n\t\t\tnpm install -g hexo-cli\r\n\t\ttips：hexo-cli是hexo命令行模式\r\n\r\n1. 使用Hexo：\r\n    * npx hexo + 参数\r\n    * hexo + 参数\r\n\t    + 需将 Hexo 所在的目录下的 node_modules 添加到环境变量：\r\n\t    + echo 'PATH=\"$PATH:./node_modules/.bin\"' >> ~/.profile\r\n\r\n## Hexo常用命令\r\n1. hexo init [folder] 默认在目前的文件夹建立网站\r\n\t本命令相当于执行了以下几步：\r\n\t\tGit clone hexo-starter 和 hexo-theme-landscape 主题到当前目录或指定目录。\r\n\t\t使用npm 包管理器下载依赖\r\n\r\n1. hexo generate\r\n\t使用 Hexo 生成静态文件\r\n1. hexo generate --watch\r\n\t监视文件变动并立即重新生成静态文件\r\n1. hexo generate --deploy\r\n1. hexo deploy --generate\r\n\t生成完毕后自动部署网站\r\n\r\n1. **hexo clean && hexo generate && hexo deploy**\r\n\t清除,生成,部署\r\n\r\n## 为Hexo安装配置修改Nexmoe主题\r\n* 安装\r\n\tnpm i hexo-theme-nexmoe\r\n* 安装依赖 WordCount\r\n\tnpm i --save hexo-wordcount\r\n* 配置 Nexmoe​\r\n\t在 Hexo 根目录下修改 _config.nexmoe.yml\r\n* 在本地启动一个 Hexo Server\r\n\thexo s --debug\r\n\r\n## 官方文档\r\n- hexo博客框架: https://hexo.io/zh-cn/docs/index.html\r\n- Nexmoe主题: https://docs.nexmoe.com/"},{"shortInfo":{"title":"Hexo文章中图片的点击放大fancyBox效果添加过程记录","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-06-02T06:51:44.000Z","tags":["Hexo","fancybox"],"hideAtIndex":true,"categories":"前端","id":3804516115,"countWords":298,"readSeconds":29.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# Hexo文章中图片的点击放大fancyBox效果添加过程记录\r\n* 根据文档应该在post模板head中添加:\r\n```html\r\n<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\r\n\r\n<link  href=\"/path/to/jquery.fancybox.min.css\" rel=\"stylesheet\">\r\n<script src=\"/path/to/jquery.fancybox.min.js\"></script>\r\n\r\n```\r\n\r\n* 根据文档需要有以下代码才能使图片有点击放大查看的效果\r\n```html\r\n<a data-fancybox=\"gallery\" href=\"big_1.jpg\">\r\n    <img src=\"small_1.jpg\">\r\n</a>\r\n```\r\n\r\n* 于是找到`node_modules/hexo-renderer-marked/renderer.js`文件，修改代码\r\n    * 该文件负责将Markdown转换为html标签\r\n    * 如负责将`![text](/path/to/image.jpg)` 转换为 `<img src=\"/blog/path/to/image.jpg\" alt=\"text\">`\r\n\r\n```js\r\n// Prepend root to image path\r\n  image(href, title, text) {\r\n    const { hexo, options } = this;\r\n    const { relative_link } = hexo.config;\r\n    const { lazyload, prependRoot, postPath } = options;\r\n\r\n    if (!/^(#|\\/\\/|http(s)?:)/.test(href) && !relative_link && prependRoot) {\r\n      if (!href.startsWith('/') && !href.startsWith('\\\\') && postPath) {\r\n        const PostAsset = hexo.model('PostAsset');\r\n        // findById requires forward slash\r\n        const asset = PostAsset.findById(join(postPath, href.replace(/\\\\/g, '/')));\r\n        // asset.path is backward slash in Windows\r\n        if (asset) href = asset.path.replace(/\\\\/g, '/');\r\n      }\r\n      href = url_for.call(hexo, href);\r\n    }\r\n\r\n    //原版代码\r\n    // let out = `<img src=\"${encodeURL(href)}\"`;\r\n    // if (text) out += ` alt=\"${text}\"`;\r\n    // if (title) out += ` title=\"${title}\"`;\r\n    // if (lazyload) out += ' loading=\"lazy\"';\r\n    // out += '>';\r\n    // return out;\r\n\r\n    //为gallery效果而改的代码\r\n    let out = `<a data-fancybox=\"gallery\" href=\"${encodeURL(href)}\"><img src=\"${encodeURL(href)}\"`;\r\n    if (text) out += ` alt=\"${text}\"`;\r\n    if (title) out += ` title=\"${title}\"`;\r\n    if (lazyload) out += ' loading=\"lazy\"';\r\n    out += '></a>';\r\n    \r\n    return out;\r\n\r\n  }\r\n\r\n```\r\n"},{"shortInfo":{"layout":"post","title":"Hexo设置文章展示优先级","date":"2022-02-23T19:15:00.000Z","cover":"\\self_server\\assets\\images\\book1.jpg","tags":["笔记","Hexo"],"hideAtIndex":true,"categories":"笔记","id":1466672112,"countWords":54,"readSeconds":5.4,"assetsbaseUrl":"/self_server/assets/"},"content":"1.安装插件\r\n\r\n```bash\r\nnpm install hexo-generator-index --save\r\n```\r\n2.设置文章优先级\r\n```md\r\n---\r\n**top: 1**\r\nlayout: post\r\ntitle: \"Hexo设置文章展示优先级\"\r\ndate: 2022-02-24 03:15:00 +0800\r\n---\r\n```\r\n1. 数值越大优先级越高"},{"shortInfo":{"title":"HTML5重学笔记","cover":"\\self_server\\assets\\images\\HTML5重学笔记\\cover.png","coverWidth":1920,"coverHeight":1080,"date":"2022-06-04T10:25:06.000Z","tags":["HTML","前端"],"hideAtIndex":true,"categories":"笔记","id":1234334178,"countWords":4219,"readSeconds":421.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# HTML5重学笔记\r\n\r\n## 说明\r\n* 重学HTML5时顺便做的笔记，查缺补漏。\r\n* 受本网页内css样式的影响，展示的效果会与默认样式有所不同\r\n* `2022.06.12`：增添标签结构说明、SEO、ICO相关笔记\r\n## 目录\r\n- [HTML5重学笔记](#html5重学笔记)\r\n  - [说明](#说明)\r\n  - [目录](#目录)\r\n  - [基本结构](#基本结构)\r\n  - [标题h](#标题h)\r\n  - [段落p](#段落p)\r\n  - [换行和分割线](#换行和分割线)\r\n  - [文本格式化标签](#文本格式化标签)\r\n  - [链接标签a](#链接标签a)\r\n  - [图片](#图片)\r\n    - [媒体标签-图片](#媒体标签-图片)\r\n    - [媒体标签-音频](#媒体标签-音频)\r\n    - [媒体标签-视频](#媒体标签-视频)\r\n  - [列表标签](#列表标签)\r\n    - [列表标签-无序表](#列表标签-无序表)\r\n    - [列表标签-有序表](#列表标签-有序表)\r\n    - [列表标签-自定义列表](#列表标签-自定义列表)\r\n  - [表单](#表单)\r\n    - [表单-input输入标签](#表单-input输入标签)\r\n    - [表单-button标签](#表单-button标签)\r\n    - [表单-select标签下拉菜单](#表单-select标签下拉菜单)\r\n    - [表单-textaera文本域](#表单-textaera文本域)\r\n    - [实现点击文字也能选中单选按钮](#实现点击文字也能选中单选按钮)\r\n  - [table 表格](#table-表格)\r\n  - [语义化标签](#语义化标签)\r\n  - [字符实体标签](#字符实体标签)\r\n  - [seo搜索引擎优化](#seo搜索引擎优化)\r\n  - [ico浏览器标题栏图标](#ico浏览器标题栏图标)\r\n\r\n\r\n## 基本结构\r\n* `<!DOCTYPE html>` 说明是html5版本\r\n* `<html lang=\"en\">`\r\n    * **标识网页使用的语言**\r\n    * 作用： **搜索引擎归类** + **浏览器翻译**\r\n    * 常见语言：`zh-CN`简体中文 `en`英文\r\n* `<meta charset=\"UTF-8\">` 标识网页使用的字符编码\r\n    * `UTF-8` 万国码\r\n    * `GB3212` 6000+汉子\r\n    * `GBK` 20000+汉子\r\n* `<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">`\r\n    * 用于解决IE浏览器兼容性问题\r\n* `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">`\r\n    * `宽度=设备宽度`使得宽度等于设备宽度，用于移动端开发\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    \r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n## 标题h\r\n* h标签会自动换行\r\n* 共6级\r\n\r\n\r\n```html\r\n<h1>h1标题</h1> \r\n<h2>h2标题</h2> \r\n<h3>h3标题</h3> \r\n<h4>h4标题</h4> \r\n<h5>h5标题</h5> \r\n<h6>h6标题</h6>\r\n```\r\n\r\n效果：\r\n\r\n![](./images/HTML5重学笔记/2022-06-08-18-49-07.png)\r\n\r\n<hr>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 段落p\r\n* 段落之间有缝隙\r\n* 会自动换行\r\n* 但是连续的纯英文被认为是一个单词 不换行\r\n\r\n\r\n```html\r\n<p>ppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp</p>\r\n<p>自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行</p>\r\n<p>自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行</p>\r\n```\r\n\r\n效果：\r\n![](./images/HTML5重学笔记/2022-06-08-18-50-03.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 换行和分割线\r\n\r\n```html\r\n123<br>456<hr>\r\n```\r\n\r\n效果：\r\n![](./images/HTML5重学笔记/2022-06-08-18-49-46.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 文本格式化标签\r\n\r\n```html\r\n<b>加粗b</b>    <strong>表示重要性的加粗strong</strong> <br>\r\n<u>下划线u</u>  <ins>表示重要性的下划线ins</ins> <br>\r\n<i>倾斜i</i>  <em>表示重要性的倾斜em</em> <br>\r\n<s>删除s</s>  <del>表示重要性的删除del</del> <br>\r\n\r\n```\r\n\r\n效果：\r\n\r\n![](./images/HTML5重学笔记/2022-06-08-18-51-14.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 链接标签a\r\n* href 跳转地址\r\n* #空链接\r\n* target 目标网页的打开形式 \r\n    * _self（默认）在当前窗口打开\r\n    * _blank打开一个新窗口跳转\r\n\r\n```html\r\n\r\n<a href=\"baidu.com\">会出错 必须加协议</a>\r\n<br>\r\n<a href=\"http://baidu.com\">正常http://baidu.com</a>\r\n<br>\r\n<a href=\"./pathTofileName.html\">pathTofileName.html</a>\r\n<br>\r\n<a href=\"#\">空链接</a> \r\n<br>\r\n<a href=\"http://baidu.com\" target=\"_blank\">在新窗口打开百度</a>\r\n\r\n```\r\n\r\n效果：<br>\r\n<a href=\"baidu.com\">会出错 必须加协议</a>\r\n<br>\r\n<a href=\"http://baidu.com\">正常http://baidu.com</a>\r\n<br>\r\n<a href=\"./pathTofileName.html\">pathTofileName.html</a>\r\n<br>\r\n<a href=\"#\">空链接</a> \r\n<br>\r\n<a href=\"http://baidu.com\" target=\"_blank\">在新窗口打开百度</a>\r\n\r\n\r\n\r\n## 图片\r\n- [媒体标签-图片](#媒体标签-图片)\r\n- [媒体标签-音频](#媒体标签-音频)\r\n- [媒体标签-视频](#媒体标签-视频)\r\n\r\n### 媒体标签-图片\r\n* 概念\r\n    * img 是标签 \r\n    * src=\"\" 是标签的属性 \r\n    * src是属性名 \r\n    * \"\"是属性值\r\n* 标签和属性之间必须以空格隔开\r\n* 属性之间没有顺序\r\n* src 资源路径\r\n* alt 图片加载失败时的替换文本\r\n* title 鼠标悬停时的显示文本\r\n* width height 写一个就好 另一个会自动确定 写两个容易造成图片畸变，除非你非要这么做\r\n\r\n```html\r\n<img src=\"./images/web_img/user_icon.png\" alt=\"图片加载失败了\" title=\"鼠标悬停显示\" width=\"100px\">\r\n```\r\n\r\n效果：<br>\r\n<img src=\"./images/web_img/user_icon.png\" alt=\"图片加载失败了\" title=\"鼠标悬停显示\" width=\"100px\">\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 媒体标签-音频\r\n* controls 显示控制面板 默认不显示\r\n* autoplay 自动播放（好像基本上浏览器都不支持音频自动播放）\r\n* loop 循环\r\n\r\n```html\r\n<audio src=\"piano.mp3\" controls autoplay loop></audio>\r\n```\r\n\r\n### 媒体标签-视频\r\n* controls 添加播放控制面板\r\n* autoplay 自动播放 谷歌不支持(静音才能自动播放)\r\n* muted 静音\r\n* loop\r\n\r\n```html\r\n<video src=\"./00.mp4\" controls muted autoplay></video>\r\n```\r\n\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 列表标签\r\n- [列表标签-无序表](#列表标签-无序表)\r\n- [列表标签-有序表](#列表标签-有序表)\r\n- [列表标签-自定义列表](#列表标签-自定义列表)\r\n  \r\n### 列表标签-无序表\r\n* 无序列表\r\n* ul只能包含li标签\r\n* li标签可以包含任意标签\r\n\r\n```html\r\n<ul>\r\n    <li>西瓜</li>\r\n    <li>南瓜</li>\r\n    <li>冬瓜</li>\r\n</ul>\r\n```\r\n\r\n效果：\r\n\r\n![](./images/HTML5重学笔记/2022-06-08-18-52-43.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 列表标签-有序表\r\n* 有序列表\r\n* 默认有数字序号\r\n* ol中只能包含li\r\n* li中可以包含任意标签\r\n\r\n```html\r\n<ol>\r\n    <li>kkk</li>\r\n    <li>jjj</li>\r\n    <li>bbb</li>\r\n</ol>\r\n```\r\n\r\n效果：<br>\r\n![](./images/HTML5重学笔记/2022-06-08-18-53-11.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 列表标签-自定义列表\r\n* 自定义列表\r\n* dl只能包含dt和dd\r\n* dt和dt可以包含任意标签\r\n\r\n```html\r\n<dl>\r\n    <dt>列标题</dt>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n</dl>\r\n```\r\n\r\n效果：<br>\r\n<dl>\r\n    <dt>列标题</dt>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n</dl>\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 表单\r\n- [input输入标签](#表单-input输入标签)\r\n- [button标签](#表单-button标签)\r\n- [select标签下拉菜单](#表单-select标签下拉菜单)\r\n- [textaera文本域](#表单-textaera文本域)\r\n- [实现点击文字也能选中单选按钮](#实现点击文字也能选中单选按钮)\r\n\r\n### 表单-input输入标签\r\n\r\n```html\r\ntext:<input type=\"text\" placeholder=\"请输入用户名\"> <!--占位符placeholder-->\r\n<br><br>\r\npassword:<input type=\"password\" placeholder=\"请输入密码\"> <!--占位符placeholder-->\r\n<br><br>\r\nradio:<input type=\"radio\" name=\"性别\">男 <input type=\"radio\" name=\"性别\" checked>女  <!-- 单选框需要有同样的name --> <!--checked表示默认选中 -->\r\n<br><br>\r\ncheckbox:<input type=\"checkbox\" checked> <!--checked表示默认选中 -->\r\n<br><br>\r\nfile:<input type=\"file\" multiple>  <!-- multiple表示可以选中多个文件 -->\r\n<br><br>\r\nsubmit:<input type=\"submit\"> <!-- 提交按钮点击提交数据          要让其能够使用 需要一个表单域标签  value=\"显示的内容\" value默认为submit -->\r\n<br><br>\r\nreset:<input type=\"reset\"> <!-- 重置按钮 点击恢复表单默认值      要让其能够使用 需要一个表单域标签  value=\"显示的内容\" value默认为reset  -->\r\n<br><br>\r\nbutton:<input type=\"button\" value=\"这是一个按钮\"><!-- 普通按钮默认无功能要配合js  value=\"显示的内容\" value默认为空  -->\r\n\r\n<br><br>\r\n<hr>\r\n<form action=\"#提交地址\">\r\n    用户名：<input type=\"text\" name=\"\" id=\"\"><br>\r\n    密码：<input type=\"password\" name=\"\" id=\"\"><br>\r\n    <input type=\"submit\" name=\"\" id=\"\"><!--submit需要一个表单域标签-->\r\n    <input type=\"reset\"><!--reset需要一个表单域标签-->\r\n</form>\r\n\r\n```\r\n\r\n效果：<br>\r\ntext:<input type=\"text\" placeholder=\"请输入用户名\"> <!--占位符placeholder-->\r\n<br><br>\r\npassword:<input type=\"password\" placeholder=\"请输入密码\"> <!--占位符placeholder-->\r\n<br><br>\r\nradio:<input type=\"radio\" name=\"性别\">男 <input type=\"radio\" name=\"性别\" checked>女  <!-- 单选框需要有同样的name --> <!--checked表示默认选中 -->\r\n<br><br>\r\ncheckbox:<input type=\"checkbox\" checked> <!--checked表示默认选中 -->\r\n<br><br>\r\nfile:<input type=\"file\" multiple>  <!-- multiple表示可以选中多个文件 -->\r\n<br><br>\r\nsubmit:<input type=\"submit\"> <!-- 提交按钮点击提交数据          要让其能够使用 需要一个表单域标签  value=\"显示的内容\" value默认为submit -->\r\n<br><br>\r\nreset:<input type=\"reset\"> <!-- 重置按钮 点击恢复表单默认值      要让其能够使用 需要一个表单域标签  value=\"显示的内容\" value默认为reset  -->\r\n<br><br>\r\nbutton:<input type=\"button\" value=\"这是一个按钮\"><!-- 普通按钮默认无功能要配合js  value=\"显示的内容\" value默认为空  -->\r\n\r\n<br><br>\r\n<hr>\r\n<form action=\"#提交地址\">\r\n    用户名：<input type=\"text\" name=\"\" id=\"\"><br>\r\n    密码：<input type=\"password\" name=\"\" id=\"\"><br>\r\n    <input type=\"submit\" name=\"\" id=\"\"><!--submit需要一个表单域标签-->\r\n    <input type=\"reset\"><!--reset需要一个表单域标签-->\r\n</form>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 表单-button标签\r\n* button 谷歌中默认type是submit  \r\n* button type可选值为submit reset button\r\n* value属性似乎没什么用\r\n\r\n```html\r\n<button>提交</button>\r\n<button type=\"submit\" value=\"submit\">提交</button>\r\n<button type=\"reset\">重置</button>\r\n<button type=\"button\">普通按钮</button>\r\n```\r\n\r\n效果：<br>\r\n<button>提交</button>\r\n<button type=\"submit\" value=\"submit\">提交</button>\r\n<button type=\"reset\">重置</button>\r\n<button type=\"button\">普通按钮</button>\r\n\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 表单-select标签下拉菜单\r\n* select\r\n    * option\r\n        * selected\r\n\r\n```html\r\n<select name=\"\" id=\"\">\r\n    <option value=\"\">北京</option>\r\n    <option value=\"\">上海</option>\r\n    <option value=\"\">深证</option>\r\n    <option value=\"\" selected>广东</option>     <!--selected 属性表示默认被选中-->\r\n</select>\r\n```\r\n\r\n效果：<br>\r\n<select name=\"\" id=\"\">\r\n    <option value=\"\">北京</option>\r\n    <option value=\"\">上海</option>\r\n    <option value=\"\">深证</option>\r\n    <option value=\"\" selected>广东</option>     <!--selected 属性表示默认被选中-->\r\n</select>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 表单-textaera文本域\r\n* cols是控制列数\r\n* rows是控制行数\r\n* 但真正控制这个一般用css\r\n\r\n```html\r\n<textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"></textarea>\r\n```\r\n\r\n效果：<br>\r\n<textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"></textarea>\r\n\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 实现点击文字也能选中单选按钮\r\n* 方法1\r\n    *  将选项内容用lable扩起来\r\n    * 将lable的for属性设为radio的id\r\n* 方法2\r\n    * 直接用lable把input包裹起来\r\n需要删除lable的for属性\r\n\r\n```html\r\n<!-- 方法1 -->\r\n<input id=\"id_1\" type=\"radio\" name=\"sex\"> <label for=\"id_1\">男</label>\r\n<input id=\"id_2\" type=\"radio\" name=\"sex\"> <label for=\"id_2\">女</label>\r\n<!-- 方法2 -->\r\n<label  > <input  type=\"radio\" name=\"sex\"> 男    </label>\r\n<label > <input  type=\"radio\" name=\"sex\"> 女    </label>\r\n```\r\n\r\n效果：<br>\r\n<!-- 方法1 -->\r\n<input id=\"id_1\" type=\"radio\" name=\"sex\"> <label for=\"id_1\">男</label>\r\n<input id=\"id_2\" type=\"radio\" name=\"sex\"> <label for=\"id_2\">女</label>\r\n<!-- 方法2 -->\r\n<label  > <input  type=\"radio\" name=\"sex\"> 男    </label>\r\n<label > <input  type=\"radio\" name=\"sex\"> 女    </label>\r\n\r\n\r\n## table 表格\r\n* table 表格\r\n    * caption是表的标题\r\n    * tr是行\r\n        * th是表头单元格\r\n        * td是普通单元格\r\n* 表格也有结构(可省略)\r\n    * thead\r\n    * tbody\r\n    * tfoot\r\n* 表格跨行合并 表格跨列合并\r\n    * 原则 保留左上的并删除其他的，然后为保留的单元格设置属性\r\n    * 跨列rowspan=\"合并了几列?\"\r\n    * 跨行colspan\r\n    * 不能跨结构合并\r\n* 表格默认没有边框线,要border=\"1\"\r\n* 实际的样式应该在写在css中\r\n\r\n```html\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>标题</caption>\r\n    <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    <tr> <td>总结</td>   <td>男</td>     <td>18</td> </tr>\r\n</table>\r\n\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>标题</caption>\r\n    <tr> <th>姓名</th>   <td>DYG</td>    <td>HHH</td>   <td>KKK</td> </tr>\r\n    <tr> <th>性别</th>   <td>男</td>     <td>男</td>    <td>男</td>  </tr>\r\n    <tr> <th>年龄</th>   <td>18</td>     <td>18</td>    <td>18</td> </tr>\r\n</table>\r\n\r\n<!-- 表格也有结构(可省略) -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格也有结构(可省略)</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>   <td>XXX</td>     <td>XXX</td> </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨列合并 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨列合并</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>   <td colspan=\"2\">XXX</td>      </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨行合并 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨行合并</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>       <td rowspan=\"2\">男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>                                   <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>     <td>XXX</td>               <td>XXX</td>       </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨行又跨列 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨行又跨列</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>       <td rowspan=\"2\" colspan=\"2\">男</td>                      </tr>\r\n        <tr> <td>DYG</td>                                                               </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>     <td>XXX</td>               <td>XXX</td>                 </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n```\r\n\r\n效果：<br>\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>标题</caption>\r\n    <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    <tr> <td>总结</td>   <td>男</td>     <td>18</td> </tr>\r\n</table>\r\n\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>标题</caption>\r\n    <tr> <th>姓名</th>   <td>DYG</td>    <td>HHH</td>   <td>KKK</td> </tr>\r\n    <tr> <th>性别</th>   <td>男</td>     <td>男</td>    <td>男</td>  </tr>\r\n    <tr> <th>年龄</th>   <td>18</td>     <td>18</td>    <td>18</td> </tr>\r\n</table>\r\n\r\n<!-- 表格也有结构(可省略) -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格也有结构(可省略)</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>   <td>XXX</td>     <td>XXX</td> </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨列合并 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨列合并</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>   <td colspan=\"2\">XXX</td>      </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨行合并 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨行合并</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>       <td rowspan=\"2\">男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>                                   <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>     <td>XXX</td>               <td>XXX</td>       </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n\r\n<!-- 表格跨行又跨列 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨行又跨列</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>       <td rowspan=\"2\" colspan=\"2\">男</td>                      </tr>\r\n        <tr> <td>DYG</td>                                                               </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>     <td>XXX</td>               <td>XXX</td>                 </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 语义化标签\r\n* 没有语义的标签div span\r\n    * div span是布局标签\r\n    * div独占一行\r\n    * span一行可以显示多个\r\n* 有语义的标签\r\n    * 这些标签是HTML5中的 主要用于移动端\r\n    * 这些标签特点和div一致，只是多了语义\r\n\r\n```html\r\n<!-- 没有语义的标签div span -->\r\n<div>div独占一行</div>\r\n<div>div独占一行</div>\r\n<span>span一行显示多个</span>\r\n<span>span一行显示多个</span>\r\n<br><hr>\r\n<!-- 有语义的标签 -->\r\n<header>网页头部</header>\r\n<nav>网页导航条</nav>\r\n<footer>网页底部</footer>\r\n<aside>网页侧边栏</aside>\r\n<section>网页区块</section>\r\n<article>网页文章article</article>\r\n```\r\n\r\n效果：<br>\r\n<!-- 没有语义的标签div span -->\r\n<div>div独占一行</div>\r\n<div>div独占一行</div>\r\n<span>span一行显示多个</span>\r\n<span>span一行显示多个</span>\r\n<br><hr>\r\n<!-- 有语义的标签 -->\r\n<header>网页头部</header>\r\n<nav>网页导航条</nav>\r\n<footer>网页底部</footer>\r\n<aside>网页侧边栏</aside>\r\n<section>网页区块</section>\r\n<article>网页文章article</article>\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 字符实体标签\r\n* 只要记住一个，空格\\&nbsp;\r\n\r\n```html\r\n<p>这里有很多空格（                         ）但却只显示一个</p>\r\n<p>这里有很多空格（&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ）能显示多个</p>\r\n```\r\n\r\n效果：<br>\r\n<p>这里有很多空格（                         ）但却只显示一个</p>\r\n<p>这里有很多空格（&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ）能显示多个</p>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## seo搜索引擎优化\r\n* SEO(Search Engine Optimization)搜索引擎优化\r\n* 作用，让网站在搜索引擎中排名靠前\r\n* 提升排名的方法\r\n    * 竞价排名\r\n    * 将网页制作成.html后缀\r\n    * 标签语义化（在合适的地方使用合适的标签，如H1 p strong）\r\n    * 等...\r\n* 搜索引擎优化三大标签，\r\n    ```html\r\n    <title>文章标题</title>\r\n    <meta name=\"description\" content=\"描述\">\r\n    <meta name=\"keywords\" content=\"关键词1,关键词2\">\r\n    ```\r\n![](./images/HTML5重学笔记/2022-06-12-20-57-03.png)\r\n\r\n## ico浏览器标题栏图标\r\n* 文件名一般为`favicon.ico`\r\n* 一般放在根目录\r\n```html\r\n<!-- 图片一般放根目录 -->\r\n<link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\">\r\n```\r\n![](./images/HTML5重学笔记/2022-06-12-21-03-27.png)"},{"shortInfo":{"layout":"post","title":"I am Tiny Rick","date":"2021-12-28T12:21:00.000Z","cover":"\\self_server\\assets\\images\\rick.jpg","tags":["Tiny Rick","日志"],"categories":"日志","id":1900215257,"countWords":52,"readSeconds":5.2,"assetsbaseUrl":"/self_server/assets/"},"content":"#### Is anybody listening，can anyone understand？\r\n\r\n<div style=\"position: relative; padding: 30% 45%;\">\r\n<iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" src=\"https://player.bilibili.com/player.html?aid=889771805&bvid=BV1hP4y1W7cb&cid=387720584&page=1&as_wide=1&high_quality=1&danmaku=0\" frameborder=\"no\" scrolling=\"no\"></iframe>\r\n</div>"},{"shortInfo":{"title":"indexedDB学习笔记","date":"2022-07-17T06:49:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["indexedDB"],"hideAtIndex":true,"categories":"笔记","id":699480446,"countWords":2693,"readSeconds":269.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# indexedDB学习笔记\r\n\r\n**特点**\r\n* **存储容量大**\r\n  * IndexedDB主要用来客户端存储大量数据而生的，\r\n  * cookie、localstorage等存储方式都有存储大小限制。\r\n* **非关系型数据库(NoSql)**，以键值对的形式存储数据\r\n* **只能通过主键、索引、游标方式查询数据**\r\n* **持久化存储**，清除浏览器缓存不会清除其数据\r\n  * cookie、localStorage、sessionStorage会清除数据\r\n* **异步操作**，IndexedDB操作时不会锁死浏览器，而localstorage是同步的\r\n* **支持事务transaction**，一系列的操作步骤中，若有一步失败，整个操作都会取消\r\n* **同源策略**，网页只能访问自身域名下的数据库\r\n\r\n**重要概念**\r\n* **事务 transaction**\r\n    * 对数据库进行一系列操作时，若有一步失败，则会回滚到最初始的状态，确保数据的一致性\r\n* **仓库 objectStore** ，可以把仓库理解为表\r\n* **索引 index**\r\n    * 可在创建store时创建索引\r\n    * 查询时可通过索引来筛选\r\n    * 插入数据时，索引字段不能为空\r\n* **游标 cursor**\r\n    * 游标是IndexedDB数据库新的概念\r\n    * 概念类似c的指针，\r\n    * 作用类似Python的生成器\r\n\r\n\r\n\r\n## 打开数据库\r\n```js\r\n/**\r\n * 打开数据库\r\n * @param {object} dbName 数据库的名字\r\n * @param {string} storeName 仓库名称\r\n * @param {string} version 所创建的数据库的版本号\r\n * @return {object} 该函数会返回一个数据库实例\r\n */\r\n\r\nfunction openDB(dbName, version = 1) {\r\n  return new Promise((resolve, reject) => { //返回promise对象使得可以链式调用\r\n    //  兼容浏览器\r\n    var indexedDB =\r\n      window.indexedDB ||\r\n      window.mozIndexedDB ||\r\n      window.webkitIndexedDB ||\r\n      window.msIndexedDB;\r\n    let db;//用于存储数据库实例\r\n    // 打开数据库，若没有则会创建\r\n    const request = indexedDB.open(dbName, version);\r\n    // 数据库打开成功的回调（连接成功或创建成功）\r\n    request.onsuccess = function (event) {\r\n      db = event.target.result; // db数据库对象实例,包含了很多增删查改的操作\r\n      console.log(\"数据库打开成功\");\r\n      resolve(db);//返回给外部调用者\r\n    };\r\n    // 数据库打开失败的回调（连接或创建失败）\r\n    request.onerror = function (event) {\r\n      console.log(\"数据库打开报错\");\r\n    };\r\n    // 数据库创建或版本号有更新时候的回调，数据内容的更新不会触发该回调\r\n    request.onupgradeneeded = function (event) {\r\n      // 数据库创建或升级的时候会触发\r\n      console.log(\"onupgradeneeded\");\r\n      db = event.target.result; // 获取数据库对象\r\n      // 创建存储库\r\n      var objectStore;\r\n      objectStore = db.createObjectStore(\"users\", {//概念对应于sql数据库的表的名称\r\n        keyPath: \"userID\", // 指定userID为主键\r\n        // autoIncrement: true // 实现自增\r\n      });\r\n      // 通过主键仅能查询一条数据，通过索引能查询多条满足指定条件的数据，如查询userSex:男\r\n      // 创建索引，在后面查询数据的时候可以根据索引查，若不创建，则只能根据主键来查询\r\n      objectStore.createIndex(\"userID\", \"userID\", { unique: true }); // 主键应当唯一，unique\r\n      objectStore.createIndex(\"userName\", \"userName\", { unique: false }); \r\n      objectStore.createIndex(\"userSex\", \"userSex\", { unique: false });\r\n      objectStore.createIndex(\"userAge\", \"userAge\", { unique: false });\r\n    };\r\n  });\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\n\r\n/* \r\n    由于openDB返回的是promise对象,是异步的，所以这么写是错误的：\r\n        let db = openDB(\"test\",1);\r\n        console.log(db)\r\n*/\r\n// 正确写法应该使用链式方法调用\r\nlet db;\r\nopenDB(\"test\",1).then((db)=>{ //链式方法调用，并接收值\r\n    db=db\r\n    console.log(db)\r\n    // 后续代码必须写在这个里面，但是也可以使用wait方法将该异步操作变同步操作\r\n\r\n    // 后续代码.....\r\n\r\n\r\n\r\n})\r\n    console.log(db); //报错，因为上述的函数返回的是promise对象，是异步的，\r\n\r\n```\r\n\r\n\r\n## 新增数据\r\n```js\r\n/**\r\n * 新增数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} data 数据 必须是一个对象，必须包含主键、索引\r\n */\r\nfunction addData(db, storeName, data) {\r\n  var request = db\r\n    //这里写成了链式调用的形式，也可以不这样写\r\n    //插入数据需要通过事务transaction来操作，\r\n    //事务的第一个参数是一个列表\r\n    .transaction([storeName], \"readwrite\") // 参数分别是：事务对象（指定表格名称） 和  操作模式（\"只读\"或\"读写\"）\r\n    .objectStore(storeName) // 仓库对象\r\n    .add(data);\r\n\r\n  request.onsuccess = function (event) {\r\n    console.log(\"数据写入成功\");\r\n  };\r\n\r\n  request.onerror = function (event) {\r\n    console.log(\"数据写入失败\");\r\n  };\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\nlet data={\r\n    \"主键名\":\"主键值\"， //可以使用UUID作为主键值，主键必须存在\r\n    \"索引名1\":\"索引1值\",\r\n    \"索引名2\":\"索引2值\",\r\n    \"索引名3\":\"索引3值\",\r\n    \"其他键名\":\"其他键值\" // 可以第一次插入的data有3个键值对，第二次插入的数据有4个键值对，可以不一致\r\n}\r\naddData(db, \"storeName\", data)\r\n\r\n```\r\n\r\n\r\n## 通过主键读取数据\r\n```js\r\n/**\r\n * 通过主键读取数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} key 主键值\r\n */\r\nfunction getDataByKey(db, storeName, key) {\r\n  return new Promise((resolve, reject) => {\r\n    var transaction = db.transaction([storeName]); // 创建事务\r\n    var objectStore = transaction.objectStore(storeName); // 仓库对象\r\n    var request = objectStore.get(key); // 通过主键获取数据\r\n\r\n    request.onerror = function (event) {\r\n      console.log(\"事务失败\");\r\n    };\r\n\r\n    request.onsuccess = function (event) {\r\n      console.log(\"主键查询结果: \", request.result);\r\n      resolve(request.result);\r\n    };\r\n  });\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\n\r\ngetDataByKey(db, \"storeName\", \"主键值\").then((result)=>{\r\n    console.log(result)\r\n})\r\n\r\n```\r\n\r\n\r\n## 通过游标读取数据\r\n```js\r\n/**\r\n * 通过游标读取数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n */\r\nfunction cursorGetData(db, storeName) {\r\n  let list = [];\r\n  var store = db\r\n    .transaction(storeName, \"readwrite\") // 事务\r\n    .objectStore(storeName); // 仓库对象\r\n  var request = store.openCursor(); // 指针对象，初始化一个游标\r\n\r\n  // 游标开启成功，逐行读数据\r\n  request.onsuccess = function (e) {\r\n    var cursor = e.target.result;\r\n    if (cursor) {// 必须要检查 因为需要判断是否为游标已经走到了末尾\r\n        // 放入列表；\r\n            // 可以在此通过条件判断来筛选出想要的数据,但这里效率会非常低，因为会遍历所有表项，要想筛选，应该先通过索引来筛选\r\n            //这里没有进行判断，所以获取到的是整张表，但若要想获取整张表 可以用db.transaction().objectStore().getAll()\r\n        list.push(cursor.value); \r\n        cursor.continue(); // 遍历了存储对象中的所有内容\r\n    } else {\r\n      console.log(\"游标读取的数据：\", list); //获取到值，\r\n      // 这里没有用promise，但是indexedDB本身就是异步的，且这是一个事件处理函数，推测仍然不能使用return，具体如何获取返回值应该可以参考之前的代码\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\n\r\n// 因为内部没有写判断条件，所以获取的是整张表的数据\r\ncursorGetData(db, \"storeName\", \"主键值\");// 异步函数\r\n\r\n```\r\n\r\n\r\n## 通过索引读取数据\r\n```js\r\n/**\r\n * 通过索引读取数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} indexName 索引名称\r\n * @param {string} indexValue 索引值\r\n */\r\nfunction getDataByIndex(db, storeName, indexName, indexValue) {\r\n  var store = db.transaction(storeName, \"readwrite\").objectStore(storeName);\r\n  var request = store.index(indexName).get(indexValue);\r\n  request.onerror = function () {\r\n    console.log(\"事务失败\");\r\n  };\r\n  request.onsuccess = function (e) {\r\n    var result = e.target.result;\r\n    console.log(\"索引查询结果：\", result);\r\n  };\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\n\r\n// 获取的是第一条满足条件的数据\r\ngetDataByIndex(db, \"storeName\", \"索引键名\", \"索引键值\");// 异步函数\r\n\r\n```\r\n\r\n\r\n\r\n## 通过索引和游标查询记录\r\n```js\r\n/**\r\n * 通过索引和游标查询记录\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} indexName 索引名称\r\n * @param {string} indexValue 索引值\r\n */\r\nfunction cursorGetDataByIndex(db, storeName, indexName, indexValue) {\r\n  let list = [];\r\n  var store = db.transaction(storeName, \"readwrite\").objectStore(storeName); // 仓库对象\r\n  var request = store\r\n    .index(indexName) // 索引对象\r\n    .openCursor( \r\n        IDBKeyRange.only(indexValue) //表示查询所有值等于(only) indexValue的游标\r\n        ); //此时拿到的游标就是索引为指定值的表项了\r\n  request.onsuccess = function (e) {\r\n    var cursor = e.target.result;\r\n    if (cursor) { // 必须要检查\r\n      list.push(cursor.value);\r\n      cursor.continue(); // 遍历了存储对象中的所有内容\r\n    } else {\r\n      console.log(\"游标索引查询结果：\", list);\r\n    }\r\n  };\r\n  request.onerror = function (e) {};\r\n}\r\n```\r\n\r\n\r\n**使用**\r\n```js\r\n\r\n// 获取的是所有满足条件的数据\r\ngetDataByIndex(db, \"storeName\", \"索引键名\", \"索引键值\");// 异步函数\r\n\r\n// 获取所有age=5的表项\r\ngetDataByIndex(db, \"storeName\", \"age\", \"5\");// 异步函数\r\n\r\n```\r\n\r\n## 通过索引和游标分页查询记录\r\n如果一个数据库有十万条数据，浏览器的页面不可能全部渲染出来，需要做成分页的形式，点击第几页再渲染第几页的内容\r\n\r\n* advance 该函数可以让我们的游标跳过多少条开始查询。\r\n\r\n```js\r\n/**\r\n * 通过索引和游标分页查询记录\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} indexName 索引名称\r\n * @param {string} indexValue 索引值\r\n * @param {number} page 页码\r\n * @param {number} pageSize 查询条数\r\n */\r\nfunction cursorGetDataByIndexAndPage(\r\n  db,\r\n  storeName,\r\n  indexName,\r\n  indexValue,\r\n  page,//查询的是第几页的内容，从1开始\r\n  pageSize\r\n) {\r\n  let list = [];\r\n  let counter = 0; // 计数器\r\n  let advanced = true; // 是否跳过多少条查询\r\n  var store = db.transaction(storeName, \"readwrite\").objectStore(storeName); // 仓库对象\r\n  var request = store\r\n    .index(indexName) // 索引对象\r\n    .openCursor(IDBKeyRange.only(indexValue)); // 指针对象\r\n  request.onsuccess = function (e) {\r\n    var cursor = e.target.result;\r\n    if (page > 1 && advanced) { //判断是否需要跳过多少条开始查询，其实判断page>=1也可以\r\n      advanced = false;\r\n      cursor.advance((page - 1) * pageSize); // 跳过多少条\r\n      return;\r\n    }\r\n    if (cursor) {\r\n      // 必须要检查\r\n      list.push(cursor.value);\r\n      counter++;\r\n      if (counter < pageSize) {\r\n        cursor.continue(); // 遍历了存储对象中的所有内容\r\n      } else {\r\n        cursor = null;\r\n        console.log(\"分页查询结果\", list);\r\n      }\r\n    } else {\r\n      console.log(\"分页查询结果\", list);\r\n    }\r\n  };\r\n  request.onerror = function (e) {};\r\n}\r\n```\r\n\r\n\r\n**使用**\r\n```js\r\n\r\n// 获取的是所有满足条件的数据的指定页码的指定条数\r\ncursorGetDataByIndexAndPage(db, \"storeName\", \"索引键名\", \"索引键值\",页码，条数);\r\n\r\n// 获取的是age=5的第二页中的数据，每页有10条数据\r\ngetDataByIndex(db, \"storeName\", \"age\", \"5\",2,10);\r\n\r\n```\r\n\r\n## 更新数据\r\n```js\r\n/**\r\n * 更新数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {object} data 数据\r\n */\r\nfunction updateDB(db, storeName, data) {\r\n  var request = db\r\n    .transaction([storeName], \"readwrite\") // 事务对象\r\n    .objectStore(storeName) // 仓库对象\r\n    .put(data);//若有该数据则更新该数据，若没有则添加该数据\r\n\r\n  request.onsuccess = function () {\r\n    console.log(\"数据更新成功\");\r\n  };\r\n\r\n  request.onerror = function () {\r\n    console.log(\"数据更新失败\");\r\n  };\r\n}\r\n```\r\n\r\n## 通过主键删除数据\r\n```js\r\n/**\r\n * 通过主键删除数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {object} id 主键值\r\n */\r\nfunction deleteDB(db, storeName, id) {\r\n  var request = db\r\n    .transaction([storeName], \"readwrite\")\r\n    .objectStore(storeName)\r\n    .delete(id);\r\n\r\n  request.onsuccess = function () {\r\n    console.log(\"数据删除成功\");\r\n  };\r\n\r\n  request.onerror = function () {\r\n    console.log(\"数据删除失败\");\r\n  };\r\n}\r\n```\r\n\r\n## 通过索引和游标删除指定的数据\r\n```js\r\n/**\r\n * 通过索引和游标删除指定的数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} indexName 索引名\r\n * @param {object} indexValue 索引值\r\n */\r\nfunction cursorDelete(db, storeName, indexName, indexValue) {\r\n  var store = db.transaction(storeName, \"readwrite\").objectStore(storeName);\r\n  var request = store\r\n    .index(indexName) // 索引对象\r\n    .openCursor(IDBKeyRange.only(indexValue)); // 指针对象\r\n  request.onsuccess = function (e) {\r\n    var cursor = e.target.result;\r\n    var deleteRequest;\r\n    if (cursor) {\r\n      deleteRequest = cursor.delete(); // 请求删除当前项\r\n      deleteRequest.onerror = function () {\r\n        console.log(\"游标删除该记录失败\");\r\n      };\r\n      deleteRequest.onsuccess = function () {\r\n        console.log(\"游标删除该记录成功\");\r\n      };\r\n      cursor.continue(); //游标移动到下一个，以便删除所有匹配数据\r\n    }\r\n  };\r\n  request.onerror = function (e) {};\r\n}\r\n```\r\n\r\n## 关闭数据库\r\n```js\r\n/**\r\n * 关闭数据库\r\n * @param {object} db 数据库实例\r\n */\r\nfunction closeDB(db) {\r\n  db.close();\r\n  console.log(\"数据库已关闭\");\r\n}\r\n```\r\n\r\n\r\n## 删除数据库\r\n\r\n```js\r\n/**\r\n * 删除数据库\r\n * @param {object} dbName 数据库名称\r\n */\r\nfunction deleteDBAll(dbName) {\r\n  console.log(dbName);\r\n  let deleteRequest = window.indexedDB.deleteDatabase(dbName);\r\n  deleteRequest.onerror = function (event) {\r\n    console.log(\"删除失败\");\r\n  };\r\n  deleteRequest.onsuccess = function (event) {\r\n    console.log(\"删除成功\");\r\n  };\r\n}\r\n```"},{"shortInfo":{"title":"JavaScript基础知识复习笔记","date":"2022-06-23T21:27:00.000Z","cover":"\\self_server\\assets\\images\\JavaScript基础知识复习笔记\\2022-12-04-01-22-12.png","tags":["JavaScript","前端"],"categories":"笔记","id":1139222918,"countWords":6641,"readSeconds":664.1,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/JavaScript基础知识复习笔记/2022-12-04-01-22-12.png) -->\r\n\r\n# JavaScript基础知识复习笔记\r\n\r\n## 目录\r\n- [JavaScript基础知识复习笔记](#javascript基础知识复习笔记)\r\n  - [目录](#目录)\r\n  - [简介](#简介)\r\n    - [用处](#用处)\r\n    - [浏览器组成](#浏览器组成)\r\n    - [js组成](#js组成)\r\n      - [ECMAScript](#ecmascript)\r\n      - [DOM](#dom)\r\n      - [BOM](#bom)\r\n  - [书写位置](#书写位置)\r\n    - [行内式](#行内式)\r\n    - [内嵌式](#内嵌式)\r\n    - [外链式](#外链式)\r\n  - [注释](#注释)\r\n  - [输入输出](#输入输出)\r\n  - [变量](#变量)\r\n    - [特殊情况](#特殊情况)\r\n    - [命名规范](#命名规范)\r\n  - [数据类型](#数据类型)\r\n    - [数据类型分类](#数据类型分类)\r\n      - [数字型Number](#数字型number)\r\n      - [字符串型String](#字符串型string)\r\n        - [转义字符](#转义字符)\r\n        - [长度](#长度)\r\n        - [拼接](#拼接)\r\n      - [布尔型Boolean](#布尔型boolean)\r\n      - [未定义Undefined](#未定义undefined)\r\n      - [空值Null](#空值null)\r\n    - [数据类型检测](#数据类型检测)\r\n    - [通过控制台颜色判断类型](#通过控制台颜色判断类型)\r\n    - [字面量](#字面量)\r\n    - [数据类型转换](#数据类型转换)\r\n      - [转为字符串](#转为字符串)\r\n      - [转为数值型](#转为数值型)\r\n      - [转为布尔型](#转为布尔型)\r\n  - [标识符、关键字、保留字](#标识符关键字保留字)\r\n  - [运算符](#运算符)\r\n    - [逻辑与的逻辑中断](#逻辑与的逻辑中断)\r\n    - [逻辑或的逻辑中断](#逻辑或的逻辑中断)\r\n  - [运算符优先级](#运算符优先级)\r\n  - [流程控制](#流程控制)\r\n    - [分支](#分支)\r\n    - [循环](#循环)\r\n    - [相关关键字](#相关关键字)\r\n  - [数组Arrary](#数组arrary)\r\n    - [创建](#创建)\r\n    - [遍历](#遍历)\r\n    - [新增元素](#新增元素)\r\n  - [函数](#函数)\r\n    - [先声明后使用](#先声明后使用)\r\n    - [形参和实参个数问题](#形参和实参个数问题)\r\n    - [arguments](#arguments)\r\n  - [立即执行函数](#立即执行函数)\r\n    - [写法](#写法)\r\n  - [作用域](#作用域)\r\n    - [作用域链](#作用域链)\r\n  - [预解析](#预解析)\r\n    - [案例1](#案例1)\r\n    - [案例2](#案例2)\r\n    - [案例3](#案例3)\r\n    - [案例4（经典面试题）](#案例4经典面试题)\r\n  - [自定义对象](#自定义对象)\r\n    - [创建对象](#创建对象)\r\n    - [new关键字](#new关键字)\r\n    - [遍历对象](#遍历对象)\r\n  - [内置对象](#内置对象)\r\n    - [Math对象](#math对象)\r\n    - [Date对象](#date对象)\r\n      - [网页倒计时效果例程](#网页倒计时效果例程)\r\n    - [Array对象](#array对象)\r\n    - [String对象](#string对象)\r\n      - [基本包装类型](#基本包装类型)\r\n      - [字符串不可变性](#字符串不可变性)\r\n    - [String对象的常用方法](#string对象的常用方法)\r\n    - [试写相关算法](#试写相关算法)\r\n  - [数据类型总结](#数据类型总结)\r\n    - [分类](#分类)\r\n    - [堆和栈](#堆和栈)\r\n    - [函数的值传递：类似c语言](#函数的值传递类似c语言)\r\n\r\n## 简介\r\n* 布兰登艾奇（Brendan Eich 1961~）在1995年10天时间设计出了JavaScript  \r\n* 网景公司最初命名为LiveScript 后与sun公司（Java由Sun公司发明）合作改名为JavaScript   \r\n* JavaScript是运行在客户端的脚本（script）语言  \r\n* 脚本语言 ：不需要编译，运行过程有js解释器逐行解释并执行  \r\n* 现在也可以基于nodejs进行服务端编程  \r\n\r\n### 用处\r\n* 表单动态校验 ：密码强度检测（js产生的最初目的）\r\n* 网页特效\r\n* 服务端开发（nodejs）\r\n* 桌面程序（Electron）\r\n* App（Cordova）\r\n* 硬件控制-物联网（Ruff）\r\n* 游戏开发（cocos2d-js）\r\n\r\n### 浏览器组成\r\n* 渲染引擎 ：解析html css 俗称内核，Chrome的blink 老版本的webkit\r\n* js引擎 ：**解释执行**网页的JavaScript代码，Chrome的v8\r\n    * 浏览器本身并不会执行js代码，而是通过内置引擎来执行\r\n    * **其它的JavaScript的引擎**转换成**字节码**或JavaScript，**V8使用c++开发**，**V8将JavaScript编译成原生机器码**，使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，**JavaScript程序在V8引擎下的运行速度媲美二进制程序。**\r\n\r\n\r\n### js组成\r\n* ECMAScript ：JavaScript语法\r\n* DOM ：页面文档对象模型\r\n* BOM ：浏览器对象模型\r\n\r\n#### ECMAScript\r\n* ECMAScript 国际标准 由ECMA国际组织进行标准化 规定了JS的编程语法和基础核心知识\r\n* JavaScript 工业标准 网景公司\r\n* JScript 工业标准 微软公司\r\n\r\n#### DOM\r\n* （Document Object Model）页面文档对象模型\r\n* 是W3C组织推荐的处理可扩展标记语言的标准编程接口\r\n* 通过DOM提供的接口可对页面元素进行操作（大小、位置、颜色...）\r\n\r\n#### BOM\r\n* （Browser Object Model）浏览器对象模型\r\n* 通过BOM可操作浏览器窗口，如弹出框，控制跳转，获取分辨率\r\n\r\n\r\n## 书写位置\r\n\r\n### 行内式\r\n直接写在html元素标签内部   \r\n因为html标签属性值使用双引号，js字符串应当使用单引号\r\n```html\r\n<input type=\"button\" value=\"这是一个按钮\" onclick=\"alert('提示框内容')\">\r\n```\r\n\r\n### 内嵌式\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <script>\r\n        alert('提示框内容');\r\n    </script>\r\n</head>\r\n<body>\r\n    \r\n</body>\r\n</html>\r\n```\r\n\r\n### 外链式\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <script src=\"./js/index.js\"></script>\r\n</head>\r\n<body>\r\n    \r\n</body>\r\n</html>\r\n```\r\n\r\n## 注释\r\n* 单行注释\r\n* 多行注释\r\n```js\r\n\r\n//单行注释\r\n\r\n/*\r\n多行注释\r\n多行注释\r\n*/\r\n\r\n```\r\n\r\n\r\n## 输入输出\r\n* 弹出输入框 `prompt(\"字符串\")` 返回值类型：`string`\r\n* 弹出提示框 `alert(\"字符串\")`\r\n* 控制台打印信息 `console.log(\"字符串\")`\r\n\r\n## 变量\r\n* 使用var关键字声明变量：`var num;`\r\n* 赋值 `num=1;`\r\n* 声明并赋值 `var myname=\"DingYigui\";`\r\n\r\n### 特殊情况\r\n* 只声明不赋值，直接使用，变量为`undefined`\r\n* 不声明不赋值，直接使用，程序会报错：变量未定义；**报错之后，后续代码不再执行**\r\n* 不声明直接赋值，可以直接使用，成为全局变量\r\n\r\n### 命名规范\r\n* 有字母数字下划线及$组成  \r\n* 区分大小写  \r\n* 不能以数字开头  \r\n* 不能是关键字、保留字  \r\n\r\n* 其他\r\n    * **建议**变量名、函数名有意义  \r\n    * **建议**遵循驼峰命名法thisIsAVar  \r\n    * 变量名一般用名词\r\n    * 函数名一般用动词\r\n    * name不是关键字也不是保留字，但在一些浏览器中有其他含义，最好不要用作变量名\r\n    * \r\n\r\n\r\n\r\n## 数据类型\r\nJavaScript是**弱类型语言**，或者说**动态语言**。   \r\n不用提前声明变量的类型，**在程序运行过程中类型会自动被确定**  \r\n数字型变量在被赋值为字符串后自动变为字符串型\r\n\r\n### 数据类型分类\r\n* 简单数据类型 ： **Number** **String** **Boolean** **Undefined** **Null**\r\n* 复杂数据类型：object\r\n![](./images/JavaScript基础知识复习笔记/2022-06-24-15-01-21.png)\r\n\r\n#### 数字型Number\r\n* 整数：`var a=0;`\r\n* 小数：`var a=1.5;`\r\n* 八进制：`var a=07;//八进制`\r\n* 十六进制：`var a=0xff;//十六进制`\r\n\r\n范围\r\n```js\r\nalert(Number.MAX_VALUE);//最大值 \r\nalert(Number.MIN_VALUE);//最小值 \r\n```\r\n\r\n特殊值\r\n```js\r\nalert(Infinity);//无穷大\r\nalert(-Infinity);//无穷小 \r\nalert(NaN);//Not a Number 不是一个数\r\n\r\nalert(Number.MAX_VALUE*2);//将会输出Infinity\r\nalert(\"字符串\"-100);//将会输出NaN\r\n```\r\n\r\n函数\r\n```js\r\nisNaN() //判断是否是NaN\r\n```\r\n\r\n#### 字符串型String\r\n加了引号或双引号就是字符串  \r\n字符串中需要包含单引号时外部用双引号  \r\n字符串中需要包含双引号时外部用单引号  \r\n\r\n##### 转义字符\r\n* \\t\r\n* \\n newline换行\r\n* \\\\\\\r\n* \\'\r\n* \\\" \r\n* \\b blank空格\r\n\r\n##### 长度  \r\n```js\r\nvar str=\"123\"  \r\nalert(str.length)\r\n```\r\n\r\n##### 拼接  \r\n```js\r\n\"123\"+\"456\"  \r\nstr1 + str2\r\n```\r\n\r\n字符串和其他类型拼接，先会把其他类型自动转为字符串，结果为字符串\r\n```js\r\n\"123\"+ 456\r\n\"123\"+ true\r\n```\r\n#### 布尔型Boolean\r\n* 取值为 **true** 或 **false**  \r\n* 在餐饮数值运算时被当做1或0  \r\n\r\n#### 未定义Undefined\r\n* 变量声明不赋值时，变量的默认值\r\n    ```js\r\n    var i;\r\n    ```\r\n* 也可以直接赋值为undefined\r\n    ```js\r\n    var i=undefined;\r\n    ```\r\n* 和字符串相连会被转换成字符串\"undefined\"  \r\n* 和数值运算结果为NaN\r\n\r\n#### 空值Null\r\n```js\r\nvar i=null\r\n```\r\n* 空值和字符串相连被当做字符串\"undefined\"  \r\n* 空值和数字相加被当做0\r\n\r\n### 数据类型检测\r\n* 语法：`typeof 变量名` \r\n* 结果为\"number\" 、 \"string\" 、 \"boolean\" 、 \"undefined\" 、 \"object\"(var a=null;a是对象)\r\n\r\n```js\r\nvar x= prompt(\"请输入数字\")\r\nconsole.log(typeof x);//输出string\r\n```\r\n\r\n### 通过控制台颜色判断类型\r\n* 蓝色为数值\r\n* 深蓝色为布尔值\r\n* 灰色为字符串\r\n\r\n![](./images/JavaScript基础知识复习笔记/2022-06-25-04-32-58.png)\r\n![](./images/JavaScript基础知识复习笔记/2022-06-25-04-32-43.png)\r\n\r\n### 字面量\r\n数字字面量1，2，3 1.5\r\n字符串字面量 \"123\" '123'\r\n布尔字面量 true false\r\n\r\n### 数据类型转换\r\n* 表单、prompt()获取到的数据默认是字符串类型，不能进行加减运算\r\n* 三种转换\r\n    * 转换成字符串\r\n    * 转换成数字\r\n    * 转换成布尔型\r\n\r\n#### 转为字符串\r\n* `XXX.toString()`\r\n* `String(XXX)`强制转换\r\n* `XXX+\"\"`拼接字符串 利用+运算转换为字符串\r\n```js\r\n// toString()\r\nvar num=1;\r\nvar str=num.toString();\r\nconsole.log(typeof str)\r\n\r\n// String()强制转换\r\nconsole.log(typeof String(123))\r\n\r\n\r\n// 加号拼接字符串\r\n123+\"\"\r\nconsole.log(typeof (123+\"\"))\r\n```\r\n#### 转为数值型\r\n* `parseInt(string)` 获取整数部分\r\n* `parseFloat(string)` 获取整数及小数部分\r\n* `Number()` 强制转换为数值型 获取整数及小数部分\r\n* js隐式转换（`- * /`）利用算术运算转换为数值型\r\n\r\n```js\r\nparseInt(\"1.5px\")//结果：1\r\nparseInt(\"width:1.5px\")//结果：NaN\r\n\r\nparseFloat(\"1.5px\")//结果：1.5\r\nparseFloat(\"width:1.5px\")//结果：NaN\r\n\r\nNumber(\"1.\")//结果：1\r\nNumber(\"1.5\")//结果：1.5\r\n\r\n\"1.5\"+1.5 //结果为字符串拼接效果：\"1.51.5\"\r\n\"1.5\"-1.5 //结果为数值相相减效果：0\r\n\"1.5\"*1.5 //结果为数值相乘效果：2.25\r\n\"1.5\"/1.5 //结果为数值相除效果：1\r\n\r\n```\r\n\r\n#### 转为布尔型\r\n* Boolean()\r\n* 代表空的否定的值都会转换成`false`：0 、 \"\" 、null 、NaN 、undefined \r\n* 其余都会被转换成`true`\r\n\r\n```js\r\nBoolean(null)//false\r\nBoolean(0)//false\r\nBoolean(NaN)//false\r\nBoolean(\"\")//false\r\nBoolean(undefined)//false\r\n\r\n```\r\n\r\n## 标识符、关键字、保留字\r\n* **标识(zhi)符**:变量名、函数名、参数名...\r\n    * 不能是关键字或保留字\r\n* **关键字**：编程语言中已经使用的字，for break case...\r\n* **保留字**：预留的关键字byte char const double\r\n\r\n## 运算符\r\n* 算数：+ - * %\r\n    * 由于表示精度问题，浮点数0.1+0.2不一定等于0.3\r\n* 自增自减：++i --i i++ i--\r\n* 比较运算符（关系运算符）\r\n    * <\r\n    * \\>\r\n    * \\<=\r\n    * \\>=\r\n    * == 会自动类型转换：1==\"1\"为真\r\n    * != 不等\r\n    * === 全等，要求值相同，类型也相同，才为真\r\n    * !== 不等\r\n\r\n* 逻辑运算符:\r\n    * 与&&\r\n    * 或||\r\n    * 非!\r\n\r\n* 赋值运算符\r\n    * =\r\n    * += -=\r\n    * *= /= %=\r\n\r\n### 逻辑与的逻辑中断\r\n表达式1&&表达式2  \r\n* 当表达式1的值为真，整个表达式的返回值为表达式2\r\n* 当表达式1的值为假，整个表达式的返回值为表达式1\r\n\r\n```js\r\n123 && 321 //返回321\r\n\r\n0 && 321 //返回0\r\n'' && 321 //返回''\r\nfalse && 321 //返回false\r\nundefined && 321 //返回undefined\r\n```\r\n\r\n### 逻辑或的逻辑中断\r\n表达式1||表达式2  \r\n* 如果表达式1的值为真，则整个表达式的值为表达式1\r\n* 如果表达式1的值为假，则整个表达式的值为表达式2\r\n\r\n```js\r\n123 || 321 //返回123\r\n\r\n0 || 321 //返回321\r\n'' || 321 //返回321\r\nfalse || 321 //返回321\r\nundefined || 321 //返回321\r\n```\r\n\r\n\r\n## 运算符优先级\r\n![](./images/JavaScript基础知识复习笔记/2022-06-26-04-17-35.png)\r\n\r\n## 流程控制\r\n\r\n### 分支\r\nif分支:和c语言语法一致\r\n```js\r\nif(表达式){\r\n    语句;\r\n}\r\n\r\nif(表达式){\r\n    语句;\r\n}else{\r\n    语句2;\r\n}\r\n\r\nif(表达式){\r\n    语句;\r\n}\r\nelse if(表达式2){\r\n    语句2;\r\n}else{\r\n    语句3;\r\n}\r\n```\r\n\r\n三元表达式\r\n```js\r\nresult=表达式1? 表达式2:表达式3;\r\n```\r\n\r\n多分支语句：也是和c语言类似\r\n```js\r\nswitch(变量 或 表达式){\r\n    case 变量值1:  //要求 switch中的值 和 case 的值 是全等的关系\r\n        语句1;\r\n        break;\r\n    case 变量值2:\r\n        语句2;\r\n        break;\r\n    case 变量值3:\r\n        语句3;\r\n        break;\r\n    default:\r\n        语句4;\r\n        break; //default如果没有写在所有case的最后，则break不能省略，\r\n}\r\n```\r\n\r\n### 循环\r\nfor\r\n```js\r\nfor(var i=1;i<=100;i++){\r\n    语句1;\r\n}\r\n```\r\n\r\nwhile\r\n```js\r\nwhile(表达式){\r\n    语句1;\r\n}\r\n```\r\n\r\ndo\r\n```js\r\ndo{\r\n    语句1;\r\n}while(表达式);\r\n```\r\n\r\n```js\r\n//语法\r\nfor(变量名 in 对象或数组){\r\n    //\r\n}\r\n```\r\n\r\n### 相关关键字\r\n* continue 立即结束本次循环，进入下一次循环\r\n* break 立即跳出整个循环\r\n\r\n\r\n## 数组Arrary\r\n* 数组中可以存放**任意类型**的数据\r\n### 创建\r\n* 利用字面量创建数组\r\n```js\r\nvar arr=[];//创建空数组\r\nvar arr=[1,2.5,\"3\",ture];\r\narr[2]//\"3\"\r\n```\r\n* new创建数组\r\n```js\r\n    var arr=new Array();//创建空数组\r\n```\r\n### 遍历\r\n```js\r\nvar arr=[1,2,3,4,5];\r\nfor(var i=0;i<arr.length;i++){\r\n    console.log(arr[i]);\r\n}\r\n```\r\n\r\n### 新增元素\r\n方法1\r\n* XXX.length是可修改的\r\n* XXX.length+=2后，会新增两个undefined的元素\r\n* 在这个位置赋值就好了\r\n\r\n方法2\r\n* 直接索引到元素然后赋值\r\n```js\r\nvar arr=[];\r\nfor(var i=0;i<100;i++)\r\n{\r\n    arr[i]=i;\r\n}\r\nconsole.log(arr);\r\n```\r\n\r\n## 函数\r\n### 先声明后使用\r\n* 声明方法1：\r\n    ```js\r\n    // 声明方法1：\r\n    function 函数名(形式参数1,形式参数2,....){\r\n        语句;\r\n        //利用return返回值：\r\n        return 需要返回的结果 ;\r\n        //利用return返回多个结果\r\n        return [result1,result2];\r\n        //利用return终止函数：\r\n        return;//没有返回值的函数 或返回值为return; 其返回值的值为undefined\r\n    }\r\n    //调用：\r\n    var y = 函数名(实际参数1,实际参数2,....);\r\n    ```\r\n\r\n* 声明方法2（匿名函数）：\r\n    ```js\r\n    // 声明方法2（匿名函数）：\r\n    var 变量名 = function(形式参数1,形式参数2,....){\r\n        // 语句;\r\n    }\r\n    // 调用：\r\n    变量名(实际参数1,实际参数2,....);\r\n    ```\r\n\r\n### 形参和实参个数问题\r\n```js\r\nfunction A(x1,x2){\r\n    console.log(x1+x2);\r\n}\r\n\r\nA(1);// 形参x1被赋值为1 x2没有被赋值 结果为undefined 于是x1+x2结果为NaN\r\nA(1,2);//结果为3\r\nA(1,2,3);//形参x1被赋值为1 x2被赋值为2 实参3被忽略\r\n\r\n```\r\n\r\n### arguments\r\n* arguments是所有函数都具有的**内置对象**\r\n* 可以通过该对象获取函数传入的所有实参、和实参的具体个数\r\n* arguments是一个**伪数组**\r\n    * 具有length属性\r\n    * 按索引获取元素\r\n    * 没有pop push 等方法\r\n\r\n```js\r\nfunction A(){\r\n    console.log(arguments)\r\n}\r\n\r\nA();\r\nA(1,2,3,4,5);\r\n```\r\n\r\n## 立即执行函数\r\n* 不需要先声明后调用，声明后立马就能执行的函数\r\n* 立即函数的最大作用就是创建了一个独立的作用域，其中创建的所有变量都是局部变量\r\n* 两个不同的立即函数直接需用分号隔开\r\n\r\n### 写法\r\n```js\r\n//写法1：相当于 var fun = function(形参列表){}; (fun)(实参列表);\r\n(function(形参列表){})(实参列表);\r\n\r\n//写法2: 相当于 var fun = function(形参列表){}; fun(实参列表);\r\n(function(形参列表){}(实参列表));\r\n```\r\n\r\n\r\n\r\n\r\n## 作用域\r\n* 全局变量：\r\n    * 作用域：作用于整个js文件或整个script标签\r\n    * 全局变量在作用域中的任何位置都可以使用\r\n    * 若在局部使用的一个未声明的变量，则该变量自动变为全局变量\r\n* 局部变量\r\n    * 形参、函数内部变量\r\n    * \r\n* 块级作用域（ es6新增）\r\n    * {}\r\n    * if(){}\r\n    * for(){} while(){} do{}while()\r\n    * 大括号里面声明的变量不能在之外声明\r\n\r\n### 作用域链\r\n内部函数访问外部变量时，按嵌套的深度查找，深度优先\r\n\r\n```js\r\nvar num=1;\r\nfunction a(){\r\n    var num=2;\r\n    function b(){\r\n        console.log(num);//2\r\n    }\r\n}\r\n```\r\n\r\n## 预解析\r\njs引擎在执行js脚本时分为两步\r\n* 预解析：将所有 var声明的全局变量 和 函数 提升到**当前**作用域之前\r\n    * 变量预解析（变量提升）：仅仅是将var变量的声明提前，**赋初值的操作不会提前。**\r\n    * 函数预解析（函数提升）：把函数声明提升到最前\r\n* 执行代码：按书写顺序执行\r\n\r\n\r\n变量预解析导致undefined的示例：\r\n```js\r\nconsole.log(y);//undefined\r\nvar y=123;\r\n//相当于：\r\nvar y;\r\nconsole.log(y);//undefined\r\ny=123;\r\n```\r\n\r\n```js\r\na();// 返回：1\r\nfunction a(){\r\n    return 1;\r\n}\r\n// 相当于：\r\nfunction a(){\r\n    return 1;\r\n}\r\na();// 返回：1\r\n\r\n//所以非匿名函数的声明写在使用语句之前不会有什么问题\r\n```\r\n\r\n```js\r\nf();//undefined\r\nvar f=function(){return 123;}\r\n\r\n// 相当于：\r\nvar f;\r\nf();//undefined\r\nf=function(){return 123;}\r\n```\r\n\r\n\r\n### 案例1  \r\n输出结果是undefined而不是10\r\n```js\r\nvar num=10;\r\nfun();\r\nfunction fun(){\r\n    console.log(num);\r\n    var num = 20;\r\n}\r\n```\r\n相当于：\r\n```js\r\nvar num=10;\r\nfunction fun(){\r\n    var num;\r\n    console.log(num);\r\n    num = 20;\r\n}\r\nfun();\r\n```\r\n\r\n### 案例2  \r\n结果：  \r\nundefined  \r\n20  \r\n![](./images/JavaScript基础知识复习笔记/2022-06-26-10-21-28.png)\r\n\r\n### 案例3  \r\n结果：  \r\nundefined  \r\n9\r\n\r\n![](./images/JavaScript基础知识复习笔记/2022-06-26-10-23-27.png)\r\n\r\n### 案例4（经典面试题）  \r\n结果：  \r\n9  \r\n9  \r\n9  \r\n9  \r\n9  \r\n报错：undefined  \r\n![](./images/JavaScript基础知识复习笔记/2022-06-26-10-26-27.png)\r\n\r\n## 自定义对象\r\n* js中对象有三种\r\n    * 自定义对象\r\n    * 内置对象\r\n    * 浏览器对象\r\n* 对象由**属性**和**方法**组成\r\n* 对象是**复杂数据类型**object\r\n* 对象是无序的相关属性和方法的集合\r\n* 构造函数抽象出了对象的公共部分，封装到了函数中，泛指了某一大类\r\n* 利用构造函数创建对象的过程也称为**对象实例化**\r\n### 创建对象\r\n* **字面量**创建对象,大括号{} \r\n    ```js\r\n    //创建\r\n    var obj={\r\n        //键值对\r\n        name:\"dyg\",\r\n        age:18,\r\n        sayHi:function(){\r\n                ;\r\n            }\r\n        }\r\n    //使用\r\n    obj.name\r\n    obj[\"name\"]\r\n    obj.age\r\n    obj.sayHi();\r\n    ```\r\n* **new**创建对象\r\n    ```js\r\n    var obj=new Object();//创建空对象\r\n    obj.name=\"DingYigui\" //追加属性\r\n    obj.age=18;\r\n    obj.sayHi=function(){};//追加方法\r\n    ```\r\n* **构造函数**创建对象  \r\n    构造函数是特殊的函数，用来初始化对象，为对象初始化值，与new一起使用  \r\n    * **构造函数首字母必须大写**    \r\n    * **构造函数不需要返回值就能返回对象**  \r\n    * **调用构造函数必须使用new**  \r\n    ```js\r\n    function 构造函数名(形式参数1,形式参数2,...){\r\n        this.属性名=形式参数1;\r\n        this.方法名=function (){};\r\n    }\r\n\r\n    var obj=new 构造函数名(实际参数1,形式参数2,...);\r\n    ```\r\n\r\n### new关键字\r\nnew关键字创建对象的过程  \r\n1. new 构造函数(); 会在内存中创建一个空对象。\r\n2. this会指向创建的空对象。\r\n3. 执行构造函数内的语句，给空对象添加属性和方法\r\n4. 返回这个对象\r\n\r\n### 遍历对象\r\n```js\r\n//语法\r\nfor(变量 in 对象){\r\n    //\r\n}\r\n\r\n//示例\r\nvar obj = {name:\"dingYigui\",age:\"18\"}\r\nfor(key in obj){\r\n    console.log(key);//属性名\r\n    console.log(obj[key]);//属性值\r\n}\r\n```\r\n\r\n## 内置对象\r\n* **一般查文档**[**MDN**](https://developer.mozilla.org/)\r\n### Math对象\r\n* Math不是一个构造函数名，而是一个静态的对象（就是字面量创建的对象{}）\r\n* 常用属性\r\n    * `Math.PI` \r\n    * `Math.E` \r\n* 常用方法\r\n    * `Math.sqrt()`\r\n    * `Math.max()` \r\n        * 正常返回实参数组的最大值\r\n        * 有非数返回NaN\r\n        * 没有实参返回负无穷\r\n    * `Math.min()`\r\n    * `Math.floor()` 向下取整\r\n    * `Math.ceil()` 向上取整\r\n    * `Math.round()` 四舍五入 \r\n        * **3.5结果为4** \r\n        * 但：**-3.5结果为-3** \r\n    * `Math.abs()` 绝对值 \"-1\"能隐式转换\r\n    * `Math.random()`  `[0,1)`\r\n\r\n### Date对象\r\n* Date不是静态对象，而是一个构造函数名 只能通过new实例化日期对象\r\n* 常用声明写法\r\n    * `new Date();` 默认传入值为当前时间\r\n    * `new Date(value);` value是毫秒数\r\n    * `new Date(dateString);`\r\n        * `new Date(\"1995-12-17 03:24:00\");`\r\n    * `new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);`\r\n        * `new Date(2022,6,27)`\r\n* 常用方法\r\n    * `obj.getFullYear()` 年\r\n    * `obj.getMonth()` 月，0-11\r\n    * `obj.getDate()` 日\r\n    * `obj.getDay()` 星期日->六 0->6 \r\n    * `obj.getHours()` 时\r\n    * `obj.getMinutes()` 分\r\n    * `obj.getSeconds()` 秒\r\n    * `obj.valueOf()` 获取毫秒数（自1970.1.1）\r\n    * `obj.getTime()` 获取毫秒数（自1970.1.1）\r\n    * `var date = + new Date();` 获取毫秒数（自1970.1.1）\r\n    * `Date.now()` 获取毫秒数（自1970.1.1） **H5新增的方法，不用new**\r\n* 由于不同时刻获取到的毫秒数不会重复，所以毫秒数也叫**时间戳**\r\n\r\n#### 网页倒计时效果例程\r\n```js\r\nfunction getLast(targetTime){\r\n    var target=+new Date(targetTime);\r\n    var now=+new Date();\r\n\r\n    var last=(target-now)/1000;//剩余总毫秒数\r\n    last=last<=0? 0:last;\r\n\r\n    var d=parseInt(last/60/60/24);\r\n    var h=parseInt(last/60/60%24);\r\n    var m=parseInt(last/60%60);\r\n    var s=parseInt(last%60);\r\n\r\n    d=d<10? \"0\"+d:d;\r\n    h=h<10? \"0\"+h:h;\r\n    m=m<10? \"0\"+m:m;\r\n    s=s<10? \"0\"+s:s;\r\n\r\n    return d+\" \"+h+\":\"+m+\":\"+s;\r\n}\r\n\r\nconsole.log(getLast(\"2022-6-28 12:24:00\"));\r\nconsole.log(getLast(0));\r\n```\r\n\r\n### Array对象\r\n* 常用字面量`[]`声明，或用`new Array()`声明空数组\r\n* 检测是否为数组： \r\n    * `instanceof` **运算符** 返回布尔值 `obj instanceof Array` 判断x是否为Array\r\n    * `Array.isArray(obj)` 检测是否为数组 Array内置方法\r\n* 常用方法\r\n    * `new Array(2)` 表示声明一个长度为2的空数组\r\n    * `new Array(2,3)` 表示声明一个数组`[2,3]`\r\n    * `Array.isArray(obj)` 检测是否为数组 Array内置方法\r\n    * `obj.push(x[,y,z])` 数组**末尾**添加一个或多个元素 **返回新数组长度**\r\n    * `obj.unshift(x[,y,z])` 数组**开头**添加一个或多个元素 **返回新数组长度**\r\n    * `obj.pop()` **弹出（删除）**数组中**最后一个**元素，**返回值为弹出的这个元素**\r\n    * `obj.shift()` **弹出（删除）**数组中**第一个**元素，**返回值为弹出的这个元素**\r\n    * `obj.reverse()` 翻转原数组 返回该数组\r\n    * `obj.sort()` 字典序排序 只能对0-9的数字完美排序\r\n    * `obj.sort(function(a,b){return a-b;})` 能对数字大小排序 a-b升序 b-a降序\r\n    * `obj.indexOf(x)` 返回数组中**第一个**元素x的索引  查找不到返回-1\r\n    * `obj.indexOf(x)` 返回数组中**最后一个**元素x的索引  查找不到返回-1\r\n    * `obj.indexOf(x,startIndex)` 同上，从某个位置开始查找\r\n    * `obj.toString()` 数组转字符串,逗号分隔 返回值字符串，不修改原数组\r\n    * `obj.join(\"分隔符 无实参默认逗号\")` 数组转字符串,自定义分隔符分隔 返回值字符串，不修改原数组\r\n    * `obj.concat()` 连接两个或多个数组，应该不影响原数组\r\n    * `obj.slice(beginIndex,endIndex)` 数组截取，返回被截取出的新数组 不会影响原数组\r\n    * `obj.splice(beginIndex,要删除个数)` 数组删除，返回被删除的数组，会影响原数组\r\n    * `obj.splice(obj.findIndex( (item)=> item.id == targetId),1)` 删除符合条件的指定元素\r\n    * `obj.filter( (item,index,arr) => return item > 10 )` filter过滤器,不会对空数组进行检测；不会改变原始数组\r\n    * `obj.includes(item)` 判断数组中是否包含某元素\r\n\r\n去重\r\n```js\r\n//遍历旧数组\r\n//如果旧数字的元素在新数组中查找不到，则插入新数组\r\n//否则进入下一次循环\r\n\r\nvar oldArray=[123,123,123,456,456,789,789]\r\nvar newArray=[];\r\nfor(index in oldArray){\r\n    if(newArray.indexOf(oldArray[index])==-1)\r\n        newArray.push(oldArray[index])\r\n}\r\nconsole.log(newArray);\r\n```\r\n\r\n### String对象\r\n\r\n#### 基本包装类型\r\n基本包装类型：js会把基本数据类型包装成复杂数据类型，这样基本数据类型就有了属性和方法\r\n\r\njs提供了三个特殊的引用类型：\r\n* String\r\n* Number\r\n* Boolean  \r\n\r\n```js\r\n//基本数据类型是没有属性和方法的，但是一下代码能正常执行\r\nvar str=\"DingYigui\"\r\nconsole.log(str.length);\r\n\r\n//上述代码的执行过程为\r\n// 1、生成临时变量，把简单类型保证成复杂数据类型\r\nvar temp = new String(\"DingYigui\")\r\n//2.赋值\r\nstr=temp;\r\n// 3. 销毁\r\ntemp=null;\r\n\r\n```\r\n\r\n#### 字符串不可变性\r\n字符串内的值不可变，虽看上去内容可以改变，实际是在内存中开辟了新的空间，地址变了  \r\n不要频繁拼接字符串：\r\n```js\r\n// 不要频繁拼接字符串，因为该过程会不断申请新内存\r\nvar str=\"123\"\r\nstr=\"456\"//重新给字符串赋值会在内存中重新开辟空间，这个特点就是字符串不可变\r\n\r\n//由于字符串不可变，频繁拼接字符串就会有效率问题，因为开辟空间需要时间\r\n\r\nfor(var i=0;i<10000000;i++)\r\n{\r\n    str+=i;\r\n}\r\nconsole.log(str)//非常耗时\r\n\r\n```\r\n\r\n### String对象的常用方法\r\n由于字符串的不可变性，字符串的所有方法不会修改字符串本身，只会返回一个新的字符串\r\n\r\n* `str.indexOf(\"查找字符\")`\r\n* `str.indexOf(\"查找字符\",startIndex)`\r\n* `str.charAt(index)` 返回指定位置字符\r\n* `str[index]` 返回指定位置字符 (html5 IE8+)\r\n* `str.charCodeAt(index)` 返回指定位置字符的ASCII码\r\n* `str.concat(str1,str2,str3)` 拼接两个多多个字符串 等效+运算符\r\n* `str.substr(starIndex,length)` 返回从某位置开始指定长度的字符串\r\n* `str.slice(start,end)` 截取下标(start,end] 的字符串，可以理解为切片\r\n* `str.substring(start,end)` 截取下标(start,end] 的字符串，同上，但是不接受负数\r\n* `str.replace(\"被替换的字符\",\"替换为字符\")`  只替换第一个字符  \r\n* `str.split(\"根据字符串中的什么字符作为分隔符\")` 字符转数组 \r\n    * `arr.join(\"分隔符\")` 是数组转字符串\r\n* `str.toUpperCase()` 转大写\r\n* `str.toLowerCase()` 转小写\r\n* \r\n\r\n### 试写相关算法\r\n查找字符串中所有z出现的位置及次数\r\n\r\n```js\r\nvar str=\"abcdzqwezxqwezgeflz\"\r\nvar list=[];\r\n\r\nlist.push(str.indexOf(\"z\"));//查找第一个z的位置\r\nwhile(true)\r\n{\r\n    var temp=str.indexOf(\"z\",list[list.length-1]+1)//从上一个位置之后开始查找\r\n    if(temp==-1)\r\n        break;\r\n    list.push(temp);\r\n}\r\nconsole.log(list)\r\nconsole.log(\"z出现了\" + list.length + \"次\")\r\n```\r\n\r\n统计每个字符出现的次数\r\n```js\r\nvar str=\"abcdzqwezxqwezgeflz\"\r\nvar obj={};\r\n\r\nfor(i in str)//统计每个字符出现的次数\r\n{\r\n    if(obj[str[i]])\r\n    {\r\n        obj[str[i]]++\r\n    }else{\r\n        obj[str[i]]=1;\r\n    }\r\n}\r\nconsole.log(obj)\r\n```\r\n\r\n统计每个字符出现的次数和具体位置\r\n```js\r\nvar str=\"abcdzqwezxqwezgeflz\"\r\nvar obj={};\r\n\r\nfor(i in str)//统计每个字符出现的次数\r\n{\r\n    if(obj[str[i]])\r\n    {\r\n        obj[str[i]].count++;\r\n        obj[str[i]].position.push(i);\r\n    }else{\r\n        obj[str[i]]={count:1,position:[i]}\r\n    }\r\n}\r\nconsole.log(obj)\r\n```\r\n![](./images/JavaScript基础知识复习笔记/2022-06-27-21-26-13.png)\r\n\r\n\r\n## 数据类型总结\r\n### 分类\r\n* **简单数据类型** 也叫基本数据类型、值类型\r\n    * 存储时，存储的是值本身，因此也叫值类型\r\n    * number string boolean undefined null(空对象，设计遗留问题)\r\n* **复杂数据类型** 也叫 引用类型\r\n    * Object Array Date等\r\n\r\n### 堆和栈\r\n* JavaScript中没有堆和栈的概念，下面的概念只是为了理解。\r\n* 一般是局部变量、函数形参、返回值\r\n    * 简单数据类型放入栈\r\n* 有程序员分配和释放，若程序员不释放，由垃圾回收机制回收\r\n    * 复杂数据类型放入堆\r\n\r\n* 简单数据类型存放在栈，直接在栈中存储值\r\n* 复杂数据类型存放在堆，在栈中存放地址\r\n![](./images/JavaScript基础知识复习笔记/2022-06-27-22-19-50.png)\r\n\r\n### 函数的值传递：类似c语言\r\n* 简单数据类型，实参传给形参的是值，对形参的操作不会影响原值\r\n* 复杂数据类型，实参传给形参的是地址，对形参的操作会印象原值"},{"shortInfo":{"title":"JavaWeb学习笔记","date":"2022-11-06T05:13:00.000Z","endDate":"2022-12-04 0:28:00 +0800","cover":"\\self_server\\assets\\images\\JavaWeb学习笔记\\2022-12-04-01-53-57.png","tags":["笔记"],"categories":"笔记","id":3970547339,"countWords":33862,"readSeconds":3386.2,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/JavaWeb学习笔记/2022-12-04-01-53-57.png) -->\r\n\r\n<details>\r\n<summary>\r\n显示/隐藏\r\n\r\n## 目录\r\n</summary>\r\n\r\n- [目录](#目录)\r\n- [概念](#概念)\r\n- [数据库:mySql](#数据库mysql)\r\n  - [mySql安装配置](#mysql安装配置)\r\n  - [SQL基础语法](#sql基础语法)\r\n  - [MySql数据类型](#mysql数据类型)\r\n  - [SQL语句的分类](#sql语句的分类)\r\n  - [DDL(Data Definition Language)数据定义语言](#ddldata-definition-language数据定义语言)\r\n    - [DDL——\\>`操作数据库`](#ddl操作数据库)\r\n      - [查询数据库](#查询数据库)\r\n      - [创建数据库](#创建数据库)\r\n      - [删除数据库](#删除数据库)\r\n      - [使用（切换）数据库](#使用切换数据库)\r\n      - [查看当前使用的数据库](#查看当前使用的数据库)\r\n    - [DDL——\\>`操作表`](#ddl操作表)\r\n      - [创建表](#创建表)\r\n      - [查询所有表](#查询所有表)\r\n      - [查询表结构](#查询表结构)\r\n      - [删除表](#删除表)\r\n      - [修改表](#修改表)\r\n        - [修改表名](#修改表名)\r\n        - [添加列](#添加列)\r\n        - [修改列的数据类型](#修改列的数据类型)\r\n        - [修改列名和数据类型](#修改列名和数据类型)\r\n        - [删除列](#删除列)\r\n      - [案例](#案例)\r\n  - [DML(Data Manipulation Language)数据操作语言](#dmldata-manipulation-language数据操作语言)\r\n    - [DML——\\>`添加数据`](#dml添加数据)\r\n      - [添加数据到指定列](#添加数据到指定列)\r\n      - [给所有列添加数据](#给所有列添加数据)\r\n      - [批量添加数据](#批量添加数据)\r\n    - [DML——\\>`修改数据`](#dml修改数据)\r\n    - [DML——\\>`删除表数据`](#dml删除表数据)\r\n  - [DQL(Data Query Language)数据查询语言](#dqldata-query-language数据查询语言)\r\n    - [DQL——\\>`基础查询`](#dql基础查询)\r\n    - [DQL——\\>`条件查询`](#dql条件查询)\r\n    - [DQL——\\>`排序查询`](#dql排序查询)\r\n    - [DQL——\\>`聚合查询`](#dql聚合查询)\r\n    - [DQL——\\>`分组查询`](#dql分组查询)\r\n    - [DQL——\\>`分页查询`](#dql分页查询)\r\n  - [DCL(Data Control Language)数据控制语言](#dcldata-control-language数据控制语言)\r\n    - [??](#)\r\n  - [约束](#约束)\r\n    - [非空约束](#非空约束)\r\n    - [唯一约束](#唯一约束)\r\n    - [主键约束](#主键约束)\r\n    - [检查约束](#检查约束)\r\n    - [默认约束](#默认约束)\r\n    - [外键约束](#外键约束)\r\n    - [额......](#额)\r\n  - [数据库设计](#数据库设计)\r\n    - [一对一](#一对一)\r\n    - [一对多](#一对多)\r\n    - [多对多](#多对多)\r\n  - [多表查询](#多表查询)\r\n    - [笛卡尔积](#笛卡尔积)\r\n    - [内连接](#内连接)\r\n    - [外连接](#外连接)\r\n    - [子查询](#子查询)\r\n    - [案例：子查询](#案例子查询)\r\n  - [事务](#事务)\r\n- [JDBC](#jdbc)\r\n  - [DriverManager工具类](#drivermanager工具类)\r\n  - [Connection数据库连接对象](#connection数据库连接对象)\r\n  - [`Statement` sql执行器对象](#statement-sql执行器对象)\r\n  - [`PreparedStatement` 预编译sql执行器对象:防止sql注入](#preparedstatement-预编译sql执行器对象防止sql注入)\r\n  - [ResultSet 结果集合对象](#resultset-结果集合对象)\r\n  - [数据库连接池](#数据库连接池)\r\n    - [Druid德鲁伊数据库连接池](#druid德鲁伊数据库连接池)\r\n  - [JDBC练习](#jdbc练习)\r\n    - [查询数据](#查询数据)\r\n    - [插入数据](#插入数据)\r\n    - [更新数据](#更新数据)\r\n    - [删除数据](#删除数据)\r\n- [Maven](#maven)\r\n- [myBatis](#mybatis)\r\n  - [myBatis简单示例](#mybatis简单示例)\r\n    - [使用示例1:myBatis简单示例](#使用示例1mybatis简单示例)\r\n    - [使用示例2:使用Mapper代理方式](#使用示例2使用mapper代理方式)\r\n  - [核心配置文件](#核心配置文件)\r\n  - [查询数据](#查询数据-1)\r\n    - [多查询selectAll](#多查询selectall)\r\n    - [单查询selectById](#单查询selectbyid)\r\n    - [多条件查询：散装参数](#多条件查询散装参数)\r\n    - [多条件查询：对象参数](#多条件查询对象参数)\r\n    - [多条件查询：集合参数](#多条件查询集合参数)\r\n    - [多条件-动态条件查询`where标签或1=1恒等式`](#多条件-动态条件查询where标签或11恒等式)\r\n    - [单条件-动态条件查询`:when:choose:otherwise`](#单条件-动态条件查询whenchooseotherwise)\r\n  - [增添数据](#增添数据)\r\n    - [插入单条数据](#插入单条数据)\r\n    - [插入单条数据：返回主键](#插入单条数据返回主键)\r\n  - [修改数据](#修改数据)\r\n    - [修改全部字段](#修改全部字段)\r\n    - [修改任意字段`set:if`](#修改任意字段setif)\r\n  - [删除数据](#删除数据-1)\r\n    - [删除单个deleteById](#删除单个deletebyid)\r\n    - [删除多个`deleteById`:`不使用注解版`](#删除多个deletebyid不使用注解版)\r\n    - [删除多个`deleteById`:`使用注解版`](#删除多个deletebyid使用注解版)\r\n  - [myBatis对参数的封装](#mybatis对参数的封装)\r\n  - [使用注解完成简单sql操作](#使用注解完成简单sql操作)\r\n- [Tomcat](#tomcat)\r\n- [Servlet](#servlet)\r\n  - [什么是Servlet](#什么是servlet)\r\n  - [实现最简Servlet程序](#实现最简servlet程序)\r\n  - [servlet生命周期](#servlet生命周期)\r\n  - [HTTPServlet](#httpservlet)\r\n  - [urlPattern配置](#urlpattern配置)\r\n  - [xml方式配置Servlet](#xml方式配置servlet)\r\n  - [Request对象](#request对象)\r\n    - [Request继承体系](#request继承体系)\r\n    - [Request常用方法](#request常用方法)\r\n    - [通用的获取参数的方法](#通用的获取参数的方法)\r\n    - [解决Request输入流中文乱码的问题](#解决request输入流中文乱码的问题)\r\n  - [Request内部请求转发转发流转给jsp页面Forward](#request内部请求转发转发流转给jsp页面forward)\r\n  - [Response对象](#response对象)\r\n    - [Response设置响应数据功能介绍](#response设置响应数据功能介绍)\r\n    - [Response完成重定向](#response完成重定向)\r\n    - [Response响应字符数据](#response响应字符数据)\r\n    - [Response响应字节数据](#response响应字节数据)\r\n  - [案例：实现登录注册案例](#案例实现登录注册案例)\r\n  - [优化：把SqlSessionFactory优化为工具类](#优化把sqlsessionfactory优化为工具类)\r\n- [JSP(Java Server Pages)Java服务端页面](#jspjava-server-pagesjava服务端页面)\r\n  - [servlet+jsp](#servletjsp)\r\n  - [JSTF标签](#jstf标签)\r\n- [MVC模式与三层架构](#mvc模式与三层架构)\r\n  - [MVC模式](#mvc模式)\r\n  - [三层架构](#三层架构)\r\n  - [SSM三大框架](#ssm三大框架)\r\n  - [MVC三层模式与三层架构的区别](#mvc三层模式与三层架构的区别)\r\n  - [案例业务逻辑](#案例业务逻辑)\r\n- [使用`三层架构`重写登录注册案例](#使用三层架构重写登录注册案例)\r\n  - [项目目录结构](#项目目录结构)\r\n  - [database数据访问层](#database数据访问层)\r\n  - [service业务逻辑层](#service业务逻辑层)\r\n  - [web表现层（控制器+视图）](#web表现层控制器视图)\r\n  - [maven配置](#maven配置)\r\n  - [结合反射对web表现层的进一步优化并实现验证码和JSON响应](#结合反射对web表现层的进一步优化并实现验证码和json响应)\r\n- [Fastjson：JSON 数据和 Java 对象转换](#fastjsonjson-数据和-java-对象转换)\r\n- [Cookie、Session会话跟踪技术](#cookiesession会话跟踪技术)\r\n  - [Cookie](#cookie)\r\n    - [Cookie基本使用和原理](#cookie基本使用和原理)\r\n    - [Cookie存活时间](#cookie存活时间)\r\n    - [Cookie发送中文](#cookie发送中文)\r\n  - [Session](#session)\r\n    - [Session的钝化与活化](#session的钝化与活化)\r\n    - [Session在浏览器的生命周期](#session在浏览器的生命周期)\r\n    - [Session在服务端的生命周期](#session在服务端的生命周期)\r\n  - [实现登录记住我功能:通过Cookie实现](#实现登录记住我功能通过cookie实现)\r\n  - [实现登录记住我功能:通过Session实现](#实现登录记住我功能通过session实现)\r\n  - [实现注册用户验证码的案例](#实现注册用户验证码的案例)\r\n- [Filter](#filter)\r\n- [Listener](#listener)\r\n\r\n</summary>\r\n</details>\r\n\r\n## 概念\r\nJavaWeb：用java技术解决Web互联网领域问题的技术栈\r\n\r\n**内容**\r\n![](./images/JavaWeb学习笔记/2022-11-06-13-28-58.png)\r\n\r\n\r\n## 数据库:mySql\r\n\r\n**DBMS**\r\n* `Oracle`: 收费的大型数据库，Oracle 公司的产品\r\n* `MySQL`: 开源免费的中小型数据库。后来Sun公司收购了MySQL，而Sun公司又被Oracle 收购. \r\n* `MariaDB` :开源免费中小型的数据库,<green>**在MySQL被收购后,由MySql的原开发人员开发的开源版**</green>\r\n* `SQL Server`: MicroSoft公司收费的中型的数据库。C#、.net等语言常使用\r\n* `SQLite` :嵌入式的微型数据库。如:作为Android内置数据库 \r\n\r\n\r\n### mySql安装配置\r\n1. 下载解压版`mysql-5.7`\r\n3. 配置环境变量\r\n   ```text\r\n   JAVA_HOME = D:\\Program Files\\mysql-5.7.38-winx64\r\n   PATH += %MYSQL_HOME%\\bin\r\n   ```\r\n1. 编写配置文件`my.ini`,放到根目录\r\n   ```ini\r\n    [mysql]\r\n    default-character-set=utf8\r\n    \r\n    [mysqld]\r\n    skip-grant-tables # 跳过权限表认证，用于解决登录sql的报错：ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)\r\n    port=3306\r\n    character-set-server=utf8\r\n    default-storage-engine=INNODB\r\n    sql-mode=\"STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\"\r\n   ```\r\n4. 初始化数据库\r\n   ```bash\r\n   #以管理员方式执行，效果为在mysql根目录生成data文件夹\r\n   mysqld --initialize-insecure\r\n   ```\r\n5. 注册mysql为系统服务\r\n   ```bash\r\n   mysqld -install #注册服务\r\n   mysqld -remove #删除服务\r\n   ```\r\n   **问题**\r\n   若注册服务提示找不到文件，则修改注册表，将路径改为正确路径\r\n   ![](./images/JavaWeb学习笔记/2022-11-06-14-56-38.png)\r\n6. 启动mysql服务\r\n   ```bash\r\n   # 方法1\r\n   net start mysql #启动服务 \r\n   net stop mysql # 停止服务\r\n   # 方法2\r\n   services.msc # 通过windows的services图形界面启动\r\n   ```\r\n7. 修改密码\r\n   ```bash\r\n   mysqld --skip-grant-tables # --skip-grant-tables 的意思是跳过权限表认证。\r\n   mysqld -u root -p root  # 修改密码\r\n   ```\r\n8. 登录\r\n   ```bash\r\n   mysql -u root -p # 默认密码为空\r\n   mysql -u 用户名 -p 密码 -h 主机 -P 端口\r\n   ```\r\n\r\n### SQL基础语法\r\n\r\n**规范**\r\n* 关键字不区分大小写，建议大写\r\n\r\n**注释**\r\n```sql\r\n-- 这是单行注释，必须要有空格\r\n/* \r\n   这是多行注释\r\n*/\r\n```\r\n\r\n### MySql数据类型\r\n\r\n**分类**\r\n* 数值类型\r\n* 日期时间类型\r\n* 字符串类型\r\n\r\n**数值类型**\r\n| 数据类型     | 大小    | 描述           | 说明                                                                             |\r\n| ------------ | ------- | -------------- | -------------------------------------------------------------------------------- |\r\n| TINYINT      | 1 byte  | 小整数值       |\r\n| SMALLINT     | 2 bytes | 大整数值       |\r\n| MEDIUMINT    | 3 bytes | 大整数值       |\r\n| INT或INTEGER | 4 bytes | 大整数值       |\r\n| BIGINT       | 8 bytes | 极大整数值     |\r\n| FLOAT        | 4 bytes | 单精度浮点数值 |\r\n| DOUBLE       | 8 bytes | 双精度浮点数值 | `字段名1 double(总长度,保留小数位数)` <br> 如分数[0.00-100.00]：分数 double(5,2) |\r\n| DECIMAL      |         | 小数值         |\r\n\r\n**日期时间类型**\r\n| 数据类型  | 大小 | 描述                        | 说明                                          |\r\n| --------- | ---- | --------------------------- | --------------------------------------------- |\r\n| DATE      | 3    | 日期值                      |\r\n| TIME      | 3    | 时间值或持续时间            |\r\n| YEAR      | 1    | 年份值                      |\r\n| DATETIME  | 8    | 混合日期和时间值            |\r\n| TIMESTAMP | 4    | 混合日期和时间值,**时间戳** | 若该字段不给数值，则mysql会默认给一个当前时间 |\r\n\r\n**字符串类型**\r\n| 数据类型   | 大小                  | 描述                          | 说明                                                                    |\r\n| ---------- | --------------------- | ----------------------------- | ----------------------------------------------------------------------- |\r\n| CHAR       | 0-255 bytes           | 定长字符串                    | \"abc\" 在 `name char(10)` 中占10个字符 浪费空间节约时间 **空间换时间**   |\r\n| VARCHAR    | 0-65535 bytes         | 变长字符串                    | \"abc\" 在 `name varchar(10)` 中占3个字符 浪费时间节约空间 **时间换空间** |\r\n| TINYBLOB   | 0-255 bytes           | 不超过255个字符的二进制字符串 |\r\n| TINYTEXT   | 0-255 bytes           | 短文本字符串                  |\r\n| BLOB       | 0-65535 bytes         | 二进制形式的长文本数据        |\r\n| TEXT       | 0-65535 bytes         | 长文本数据                    |\r\n| MEDIUMBLOB | 0-16 777215 bytes     | 二进制形式的中等长度文本数据  |\r\n| MEDIUMTEXT | 0-16777 215 bytes     | 中等长度文本数据              |\r\n| LONGBLOB   | 0-4 294 967 295 bytes | 进制形式的极大文本数据        |\r\n| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                  |\r\n\r\n\r\n\r\n### SQL语句的分类\r\n* `DDL(Data Definition Language)`数据`定义`语言，用来定义数据库对象:`数据库，表，列`等\r\n* `DML(Data Manipulation Language)`数据`操作`语言，用来对数据库中表的数据进行`增删改`\r\n* `DQL(Data Query Language)`数据`查询`语言，用来`查`询数据库中表的记录(数据)\r\n* `DCL(Data Control Language)`数据`控制`语言，用来`定义数据库的访问权限和安全级别`，及`创建用户`\r\n\r\n### DDL(Data Definition Language)数据定义语言\r\n\r\n#### DDL——>`操作数据库`\r\n\r\n##### 查询数据库\r\n**查询数据库**\r\n```sql\r\nshow databases;\r\n```\r\n\r\n**查询数据库测试**\r\n```bash\r\nmysql> show databases;\r\n+--------------------+\r\n| Database           | # mysql自带的四个数据库：\r\n+--------------------+\r\n| information_schema | # 不在硬盘中，是一个视图，记录了mysql中的库、表\r\n| mysql              | # 存储了权限等的信息\r\n| performance_schema | # 存储了性能相关的信息\r\n| sys                | # 存储了系统相关的信息\r\n+--------------------+\r\n4 rows in set (0.00 sec)\r\n\r\n```\r\n\r\n-------------------------------------------------------------------\r\n##### 创建数据库\r\n\r\n**创建数据库**\r\n```sql\r\ncreate database 数据库名;\r\n```\r\n\r\n**创建数据库测试**\r\n```bash\r\nmysql> create database db1;\r\nQuery OK, 1 row affected (0.09 sec)\r\n```\r\n\r\n**创建数据库（若不存在）**\r\n```sql\r\ncreate database if not exists 数据库名;\r\n```\r\n\r\n-------------------------------------------------------------------\r\n##### 删除数据库\r\n\r\n**删除数据库**\r\n```sql\r\ndrop database 数据库名;\r\n```\r\n\r\n**删除数据库测试**\r\n```bash\r\nmysql> drop database db1;\r\nQuery OK, 0 rows affected (0.00 sec)\r\n```\r\n\r\n\r\n**删除数据库（若存在）**\r\n```sql\r\ndrop database if not exists 数据库名;\r\n```\r\n\r\n-------------------------------------------------------------------\r\n##### 使用（切换）数据库\r\n\r\n**使用数据库**\r\n```sql\r\nuse 数据库名;\r\n```\r\n\r\n**使用数据库测试**\r\n```bash\r\nmysql> use db1;\r\nDatabase changed\r\n```\r\n\r\n-------------------------------------------------------------------\r\n##### 查看当前使用的数据库\r\n**查看当前使用的数据库**\r\n```sql\r\nselect Database();\r\n```\r\n\r\n**查看当前使用的数据库测试**\r\n```bash\r\nmysql> select Database();\r\n+------------+\r\n| Database() |\r\n+------------+\r\n| db1        |\r\n+------------+\r\n1 row in set (0.00 sec)\r\n```\r\n\r\n-------------------------------------------------------------------\r\n\r\n\r\n#### DDL——>`操作表`\r\n**CRUB**\r\n* 创建(Create)\r\n* 查询(Retrieve)\r\n* 修改(Update)\r\n* 删除(Delete)\r\n\r\n-------------------------------------------------------------------\r\n\r\n##### 创建表\r\n**创建表**\r\n```sql\r\ncreate table 表名(\r\n   字段名1 数据类型1,\r\n   字段名2 数据类型2 -- 最后一行无逗号\r\n);\r\n```\r\n\r\n**创建表测试**\r\n```bash\r\nmysql> \r\ncreate table user(\r\n   id int,\r\n   username varchar(20),\r\n   password varchar(32)\r\n);\r\nQuery OK, 0 rows affected (0.65 sec)\r\nmysql> desc user;\r\n+----------+-------------+------+-----+---------+-------+\r\n| Field    | Type        | Null | Key | Default | Extra |\r\n+----------+-------------+------+-----+---------+-------+\r\n| id       | int(11)     | YES  |     | NULL    |       |\r\n| username | varchar(20) | YES  |     | NULL    |       |\r\n| password | varchar(32) | YES  |     | NULL    |       |\r\n+----------+-------------+------+-----+---------+-------+\r\n3 rows in set (0.00 sec)\r\n```\r\n\r\n\r\n-------------------------------------------------------------------\r\n\r\n##### 查询所有表\r\n\r\n**查询所有表**\r\n```sql\r\nshow tables;\r\n```\r\n\r\n**查询所有表测试**\r\n```bash\r\nmysql> show tables;\r\n+---------------+\r\n| Tables_in_db1 |\r\n+---------------+\r\n| user          |\r\n+---------------+\r\n1 row in set (0.00 sec)\r\n```\r\n\r\n-------------------------------------------------------------------\r\n\r\n##### 查询表结构\r\n\r\n**查询表结构**\r\n```sql\r\ndesc 表名;\r\n```\r\n\r\n**查询表结构测试**\r\n```bash\r\nmysql> desc user;\r\n+----------+-------------+------+-----+---------+-------+\r\n| Field    | Type        | Null | Key | Default | Extra |\r\n+----------+-------------+------+-----+---------+-------+\r\n| id       | int(11)     | YES  |     | NULL    |       |\r\n| username | varchar(20) | YES  |     | NULL    |       |\r\n| password | varchar(32) | YES  |     | NULL    |       |\r\n+----------+-------------+------+-----+---------+-------+\r\n3 rows in set (0.01 sec)\r\n```\r\n\r\n-------------------------------------------------------------------\r\n\r\n##### 删除表\r\n\r\n**删除表**\r\n```sql\r\ndrop table 表名;\r\n```\r\n\r\n**删除表(判断是否存在)**\r\n```sql\r\ndrop table if exists 表名;\r\n```\r\n\r\n**删除表(判断是否存在)测试**\r\n```bash\r\nmysql>  show tables;\r\n+---------------+\r\n| Tables_in_db1 |\r\n+---------------+\r\n| student       |\r\n| user          |\r\n+---------------+\r\n2 rows in set (0.00 sec)\r\n\r\nmysql> drop table if exists user;\r\nQuery OK, 0 rows affected (0.24 sec)\r\nmysql> show tables;\r\n+---------------+\r\n| Tables_in_db1 |\r\n+---------------+\r\n| student       |\r\n+---------------+\r\n1 row in set (0.00 sec)\r\n```\r\n\r\n-------------------------------------------------------------------\r\n\r\n##### 修改表\r\n\r\n###### 修改表名\r\n**修改表名**\r\n```sql\r\nalter table 旧表名 rename to 新表名; \r\n```\r\n\r\n**修改表名测试**\r\n```bash\r\nmysql> show tables;\r\n+---------------+\r\n| Tables_in_db1 |\r\n+---------------+\r\n| student       |\r\n+---------------+\r\n1 row in set (0.00 sec)\r\n\r\nmysql> alter table student rename to student_new;\r\nQuery OK, 0 rows affected (0.43 sec)\r\n\r\nmysql> show tables;\r\n+---------------+\r\n| Tables_in_db1 |\r\n+---------------+\r\n| student_new   |\r\n+---------------+\r\n1 row in set (0.00 sec)\r\n```\r\n\r\n\r\n###### 添加列\r\n**添加列**\r\n```sql\r\nalter table 表名 add 列名 数据类型; \r\n```\r\n\r\n**添加列测试**\r\n```bash\r\nmysql> desc student_new;\r\n+----------+-------------+------+-----+---------+-------+\r\n| Field    | Type        | Null | Key | Default | Extra |\r\n+----------+-------------+------+-----+---------+-------+\r\n| id       | int(11)     | YES  |     | NULL    |       |\r\n| name     | char(10)    | YES  |     | NULL    |       |\r\n| sex      | char(1)     | YES  |     | NULL    |       |\r\n| birthday | date        | YES  |     | NULL    |       |\r\n| score    | double(5,2) | YES  |     | NULL    |       |\r\n| email    | varchar(64) | YES  |     | NULL    |       |\r\n| telnum   | char(20)    | YES  |     | NULL    |       |\r\n| status   | tinyint(4)  | YES  |     | NULL    |       |\r\n+----------+-------------+------+-----+---------+-------+\r\n8 rows in set (0.00 sec)\r\n\r\nmysql> alter table student_new add new_attribute int; # 新增字段\r\nQuery OK, 0 rows affected (0.56 sec)\r\nRecords: 0  Duplicates: 0  Warnings: 0\r\n\r\nmysql> desc student_new;\r\n+---------------+-------------+------+-----+---------+-------+\r\n| Field         | Type        | Null | Key | Default | Extra |\r\n+---------------+-------------+------+-----+---------+-------+\r\n| id            | int(11)     | YES  |     | NULL    |       |\r\n| name          | char(10)    | YES  |     | NULL    |       |\r\n| sex           | char(1)     | YES  |     | NULL    |       |\r\n| birthday      | date        | YES  |     | NULL    |       |\r\n| score         | double(5,2) | YES  |     | NULL    |       |\r\n| email         | varchar(64) | YES  |     | NULL    |       |\r\n| telnum        | char(20)    | YES  |     | NULL    |       |\r\n| status        | tinyint(4)  | YES  |     | NULL    |       |\r\n| new_attribute | int(11)     | YES  |     | NULL    |       | # 新增的字段\r\n+---------------+-------------+------+-----+---------+-------+\r\n9 rows in set (0.00 sec)\r\n```\r\n\r\n###### 修改列的数据类型\r\n\r\n**修改列的数据类型**\r\n```sql\r\nalter table 表名 modify 列名 新数据类型; \r\n```\r\n**修改数据类型测试**\r\n```bash\r\nmysql> desc student_new;\r\n+---------------+-------------+------+-----+---------+-------+\r\n| Field         | Type        | Null | Key | Default | Extra |\r\n+---------------+-------------+------+-----+---------+-------+\r\n| id            | int(11)     | YES  |     | NULL    |       |\r\n| name          | char(10)    | YES  |     | NULL    |       |\r\n| sex           | char(1)     | YES  |     | NULL    |       |\r\n| birthday      | date        | YES  |     | NULL    |       |\r\n| score         | double(5,2) | YES  |     | NULL    |       |\r\n| email         | varchar(64) | YES  |     | NULL    |       |\r\n| telnum        | char(20)    | YES  |     | NULL    |       |\r\n| status        | tinyint(4)  | YES  |     | NULL    |       |\r\n| new_attribute | int(11)     | YES  |     | NULL    |       | # new_attribute int(11)\r\n+---------------+-------------+------+-----+---------+-------+\r\n9 rows in set (0.00 sec)\r\n\r\nmysql> alter table student_new modify new_attribute char(1);   # 修改字段的数据类型\r\nQuery OK, 0 rows affected (0.63 sec)\r\nRecords: 0  Duplicates: 0  Warnings: 0\r\n\r\nmysql> desc student_new;\r\n+---------------+-------------+------+-----+---------+-------+\r\n| Field         | Type        | Null | Key | Default | Extra |\r\n+---------------+-------------+------+-----+---------+-------+\r\n| id            | int(11)     | YES  |     | NULL    |       |\r\n| name          | char(10)    | YES  |     | NULL    |       |\r\n| sex           | char(1)     | YES  |     | NULL    |       |\r\n| birthday      | date        | YES  |     | NULL    |       |\r\n| score         | double(5,2) | YES  |     | NULL    |       |\r\n| email         | varchar(64) | YES  |     | NULL    |       |\r\n| telnum        | char(20)    | YES  |     | NULL    |       |\r\n| status        | tinyint(4)  | YES  |     | NULL    |       |\r\n| new_attribute | char(1)     | YES  |     | NULL    |       | # new_attribute char(1)\r\n+---------------+-------------+------+-----+---------+-------+\r\n9 rows in set (0.00 sec)\r\n```\r\n\r\n###### 修改列名和数据类型\r\n\r\n**修改列名和数据类型**\r\n```sql\r\nalter table 表名 change 列名 新列名 新数据类型; \r\n```\r\n\r\n**修改列名和数据类型测试**\r\n```bash\r\nmysql> desc student_new;\r\n+---------------+-------------+------+-----+---------+-------+\r\n| Field         | Type        | Null | Key | Default | Extra |\r\n+---------------+-------------+------+-----+---------+-------+\r\n| id            | int(11)     | YES  |     | NULL    |       |\r\n| name          | char(10)    | YES  |     | NULL    |       |\r\n| sex           | char(1)     | YES  |     | NULL    |       |\r\n| birthday      | date        | YES  |     | NULL    |       |\r\n| score         | double(5,2) | YES  |     | NULL    |       |\r\n| email         | varchar(64) | YES  |     | NULL    |       |\r\n| telnum        | char(20)    | YES  |     | NULL    |       |\r\n| status        | tinyint(4)  | YES  |     | NULL    |       |\r\n| new_attribute | char(1)     | YES  |     | NULL    |       | # 待修改列名和类型\r\n+---------------+-------------+------+-----+---------+-------+\r\n9 rows in set (0.00 sec)\r\nmysql> alter table student_new change new_attribute new_attr  int; # 修改字段的名字和数据类型\r\nQuery OK, 0 rows affected (0.72 sec)\r\nRecords: 0  Duplicates: 0  Warnings: 0\r\n\r\nmysql> desc student_new;\r\n+----------+-------------+------+-----+---------+-------+\r\n| Field    | Type        | Null | Key | Default | Extra |\r\n+----------+-------------+------+-----+---------+-------+\r\n| id       | int(11)     | YES  |     | NULL    |       |\r\n| name     | char(10)    | YES  |     | NULL    |       |\r\n| sex      | char(1)     | YES  |     | NULL    |       |\r\n| birthday | date        | YES  |     | NULL    |       |\r\n| score    | double(5,2) | YES  |     | NULL    |       |\r\n| email    | varchar(64) | YES  |     | NULL    |       |\r\n| telnum   | char(20)    | YES  |     | NULL    |       |\r\n| status   | tinyint(4)  | YES  |     | NULL    |       |\r\n| new_attr | int(11)     | YES  |     | NULL    |       | # 修改列名和类型\r\n+----------+-------------+------+-----+---------+-------+\r\n9 rows in set (0.00 sec)\r\n```\r\n\r\n###### 删除列\r\n\r\n**删除列**\r\n```sql\r\nalter table 表名 drop 列名; \r\n```\r\n\r\n**删除列测试**\r\n```bash\r\nmysql> desc student_new;\r\n+----------+-------------+------+-----+---------+-------+\r\n| Field    | Type        | Null | Key | Default | Extra |\r\n+----------+-------------+------+-----+---------+-------+\r\n| id       | int(11)     | YES  |     | NULL    |       |\r\n| name     | char(10)    | YES  |     | NULL    |       |\r\n| sex      | char(1)     | YES  |     | NULL    |       |\r\n| birthday | date        | YES  |     | NULL    |       |\r\n| score    | double(5,2) | YES  |     | NULL    |       |\r\n| email    | varchar(64) | YES  |     | NULL    |       |\r\n| telnum   | char(20)    | YES  |     | NULL    |       |\r\n| status   | tinyint(4)  | YES  |     | NULL    |       |\r\n| new_attr | int(11)     | YES  |     | NULL    |       | # 待删除列\r\n+----------+-------------+------+-----+---------+-------+\r\n9 rows in set (0.00 sec)\r\n\r\nmysql> alter table student_new drop new_attr;             # 删除字段\r\nQuery OK, 0 rows affected (0.74 sec)\r\nRecords: 0  Duplicates: 0  Warnings: 0\r\n\r\nmysql> desc student_new;\r\n+----------+-------------+------+-----+---------+-------+\r\n| Field    | Type        | Null | Key | Default | Extra |\r\n+----------+-------------+------+-----+---------+-------+\r\n| id       | int(11)     | YES  |     | NULL    |       |\r\n| name     | char(10)    | YES  |     | NULL    |       |\r\n| sex      | char(1)     | YES  |     | NULL    |       |\r\n| birthday | date        | YES  |     | NULL    |       |\r\n| score    | double(5,2) | YES  |     | NULL    |       |\r\n| email    | varchar(64) | YES  |     | NULL    |       |\r\n| telnum   | char(20)    | YES  |     | NULL    |       |\r\n| status   | tinyint(4)  | YES  |     | NULL    |       | # 删除了一个字段\r\n+----------+-------------+------+-----+---------+-------+\r\n8 rows in set (0.00 sec)\r\n```\r\n\r\n\r\n##### 案例\r\n\r\n**案例1**\r\n\r\n![](./images/JavaWeb学习笔记/2022-11-06-17-09-37.png)\r\n```sql\r\ncreate table student(\r\n   id int,\r\n   name char(10),\r\n   sex char(1),\r\n   birthday date,\r\n   score double(5,2),\r\n   email varchar(64),\r\n   telnum char(20),\r\n   status tinyint\r\n);\r\n```\r\n**案例1执行结果**\r\n```bash\r\nmysql> create table student(\r\n   id int,\r\n   name char(10),\r\n   sex char(1),\r\n   birthday date,\r\n   score double(5,2),\r\n   email varchar(64),\r\n   telnum char(20),\r\n   status tinyint\r\n);\r\nQuery OK, 0 rows affected (0.34 sec)\r\n\r\nmysql> desc student;\r\n+----------+-------------+------+-----+---------+-------+\r\n| Field    | Type        | Null | Key | Default | Extra |\r\n+----------+-------------+------+-----+---------+-------+\r\n| id       | int(11)     | YES  |     | NULL    |       |\r\n| name     | char(10)    | YES  |     | NULL    |       |\r\n| sex      | char(1)     | YES  |     | NULL    |       |\r\n| birthday | date        | YES  |     | NULL    |       |\r\n| score    | double(5,2) | YES  |     | NULL    |       |\r\n| email    | varchar(64) | YES  |     | NULL    |       |\r\n| telnum   | char(20)    | YES  |     | NULL    |       |\r\n| status   | tinyint(4)  | YES  |     | NULL    |       |\r\n+----------+-------------+------+-----+---------+-------+\r\n8 rows in set (0.00 sec)\r\n```\r\n\r\n### DML(Data Manipulation Language)数据操作语言\r\n\r\n#### DML——>`添加数据`\r\n##### 添加数据到指定列\r\n**添加数据到指定列**\r\n```sql\r\ninsert into 表名(列名1,列名2,列名3,...) values(值1,值2,值3,...);\r\n```\r\n**添加数据到指定列测试**\r\n```sql\r\nuse db1;\r\ndesc student;\r\ninsert into \r\nstudent(id,name,sex,birthday,score,email,telnum,status)\r\nvalues(0,\"test1\",'男',\"2022-1-1\",99.99,\"244@qq.com\",\"0519-110\",1);\r\nselect * from student;\r\n```\r\n\r\n```bash\r\nmysql> select * from student;\r\n+------+-------+------+------------+-------+------------+----------+--------+------+\r\n| id   | name  | sex  | birthday   | score | email      | telnum   | status | age  |\r\n+------+-------+------+------------+-------+------------+----------+--------+------+\r\n|    0 | test1 | 男   | 2022-01-01 | 99.99 | 244@qq.com | 0519-110 |      1 | NULL |\r\n+------+-------+------+------------+-------+------------+----------+--------+------+\r\n3 rows in set (0.00 sec)\r\n```\r\n\r\n##### 给所有列添加数据\r\n```sql\r\ninsert into 表名 values(值1,值2,值3,...); -- 不建议使用，值的顺序错误将导致赋值错误\r\n```\r\n\r\n##### 批量添加数据\r\n```sql\r\ninsert into 表名(列名1,列名2,列名3,...) values(值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...),...;\r\ninsert into 表名 values(值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...),...;\r\n```\r\n\r\n#### DML——>`修改数据`\r\n\r\n\r\n**修改表数据**\r\n```sql\r\nupdate 表名 set 列名1=值1,列名2=值2,列名3=值3,... [where 条件];\r\n```\r\n<warn>不写条件会导致所有行被修改</warn>\r\n\r\n#### DML——>`删除表数据`\r\n\r\n**删除表数据**\r\n```sql\r\ndelete from 表名 [where 条件];\r\ndelete from 表名 [where 属性名=属性值];\r\n```\r\n<warn>不写条件会导致所有行被删除</warn>\r\n\r\n\r\n### DQL(Data Query Language)数据查询语言\r\n\r\n**数据查询语法**\r\n```sql\r\nselect\r\n   字段列表\r\nfrom\r\n   表名列表\r\nwhere\r\n   条件列表\r\ngroup by\r\n   分组列表\r\nhaving\r\n   分组后条件\r\norder by\r\n   排序字段\r\nlimit\r\n   分页限定\r\n;\r\n```\r\n\r\n#### DQL——>`基础查询`\r\n\r\n**查询多个字段**\r\n```sql\r\nselect 字段列表 from 表名列表;\r\nselect * from 表名列表; -- 一般公司里要求不用这种形式，因为不能一眼看出查询了哪些列\r\n```\r\n**查询多个字段测试**\r\n```bash\r\nmysql> select name,birthday,sex from student;\r\n+-------+------------+------+\r\n| name  | birthday   | sex  |\r\n+-------+------------+------+\r\n| test1 | 2022-01-01 | 男   |\r\n| test1 | 2022-01-01 | 男   |\r\n| test1 | 2022-01-01 | 男   |\r\n+-------+------------+------+\r\n3 rows in set (0.00 sec)\r\n```\r\n-------------------------------------------------------------------\r\n\r\n**去除重复记录**\r\n```sql\r\nselect distinct 字段列表 from 表名; --根据字段列表的值去除重复记录\r\n```\r\n**去除重复记录测试**\r\n```sql\r\nselect addr distinct addr from student;\r\n```\r\n-------------------------------------------------------------------\r\n**起别名**\r\n```sql\r\nselect 字段1 as 新列名1,字段2 as 新列名2, from student;\r\nselect 字段1  新列名1,字段2  新列名2, from student; -- as 可以省略\r\n```\r\n**起别名测试**\r\n```sql\r\nselect name as 姓名,age as 年龄,sex as 性别 from student;\r\nselect name 姓名,age 年龄,sex 性别 from student;\r\n```\r\n```bash\r\nmysql> select name 姓名,age 年龄,sex 性别 from student;\r\n+--------+--------+--------+\r\n| 姓名   |  年龄   | 性别   |\r\n+--------+--------+--------+\r\n| test1  |   10   |   男   |\r\n| test2  |   20   |   男   |\r\n+--------+--------+--------+\r\n2 rows in set (0.00 sec)\r\n```\r\n\r\n#### DQL——>`条件查询`\r\n**条件查询语法**\r\n```sql\r\nselect 字段列表 from 表名 where 条件列表;\r\n```\r\n| 符号                  | 说明                                                 |\r\n| --------------------- | ---------------------------------------------------- |\r\n| `>`                   |                                                      |\r\n| `<`                   |                                                      |\r\n| `>=`                  |                                                      |\r\n| `<=`                  |                                                      |\r\n| `=`                   | 注意，只写一个等于                                   |\r\n| `<>` or `!=`          |                                                      |\r\n| `between ... and ...` | `[a,b]`                                              |\r\n| `in()`                | 多选一                                               |\r\n| `like 占位符`         | **模糊查询** `_`单字符任意匹配 `%`零或多字符任意匹配 |\r\n| `is null`             |                                                      |\r\n| `is not null`         |                                                      |\r\n| `and` or `&&`         |                                                      |\r\n| `or` or `\\|\\|`        |                                                      |\r\n| `not` or `!`          |                                                      |\r\n\r\n**条件查询语法测试**\r\n```sql\r\n-- 年龄等于20\r\nselect name,sex from student where age=20;\r\n\r\n-- 年龄不等于20\r\nselect name,sex from student where age!=20;\r\n\r\n-- 年龄大于20\r\nselect name,sex from student where age>20;\r\n\r\n-- 年龄大于等于20\r\nselect name,sex from student where age>=20;\r\n\r\n-- 年龄 等于20 或 等于30 或 等于40 \r\nselect name,sex from student where age=20 or age=30 or age=40;\r\nselect name,sex from student where age in(20,30,40);    -- `in()` 的使用\r\n\r\n-- 年龄 大于等于20 且 小于等于30\r\nselect name,sex from student where age>=20 && age<=30;\r\nselect name,sex from student where age>=20 and age<=30;\r\nselect name,sex from student where age between 20 and 30; -- `between... and...` 的使用\r\n\r\n-- 出生日期在 1998-09-01 到 1999-09-01 \r\nselect name,sex from student where birthday between `1998-09-01` and `1999-09-01`;\r\n\r\n-- 英语成绩为null\r\nselect name,sex from student where english = null; -- 错误写法\r\nselect name,sex from student where english is null; -- 正确写法\r\nselect name,sex from student where english is not null;\r\n\r\n-- 姓马的\r\nselect name,sex from student where name like \"马%\";\r\n\r\n-- 第二个字是花\r\nselect name,sex from student where name like \"_花%\";\r\n\r\n-- 名字中含有德字\r\nselect name,sex from student where name like \"%德%\";\r\n```\r\n\r\n\r\n#### DQL——>`排序查询`\r\n\r\n```sql\r\nselect 字段列表 from 表名 order by 排序字段名称1 [排序方式1],排序字段名2 [排序方式2];\r\n\r\n-- 排序方式\r\n   -- ASC 升序（默认）\r\n   -- DESC 降序\r\n```\r\n<warn>根据多个字段排序时，只有当根据第一个字段排序无法区分区分顺序时，才会根据第二个字段排序。</warn>\r\n\r\n**排序查询书写示例**\r\n```sql\r\n-- 查询学生信息，按年龄升序排序\r\nselect * from student order by age asc;\r\nselect * from student order by age;\r\n\r\n-- 查询学生信息 按数学成绩降序排序\r\nselect * from student order by math_score desc;\r\n\r\n-- 查询学生信息 按数学成绩降序排序,如果数学成绩一致，则按英语成绩升序排序。\r\nselect * from student order by math_score desc,english_score asc;\r\n```\r\n\r\n#### DQL——>`聚合查询`\r\n**概念**：将一列数据作为整体，进行运算。\r\n\r\n**聚合函数**\r\n| 函数名      | 功能     | 取值              |\r\n| ----------- | -------- | ----------------- |\r\n| count(列名) | 统计数量 | `非空列名` 或 `*` |\r\n| max(列名)   | 最大值   |\r\n| min(列名)   | 最小值   |\r\n| sum(列名)   | 求和     |\r\n| avg(列名)   | 平均值   |\r\n\r\n<warn>注意：null值不参与聚合运算,如计算某列平均值，为null的行不参与运算。</warn>\r\n\r\n**sql语法格式**\r\n```sql\r\nselect 聚合函数名(列名)[,可以继续写其他字段名] from 表;\r\n```\r\n\r\n**排序查询书写示例**\r\n```sql\r\n-- 统计班级人数\r\nselect count(id) from student;\r\nselect count(*) from student;\r\n\r\n-- 查询数学最高分者的分数，名字，年龄\r\nselect name,age,max(math_score) from student;\r\n```\r\n\r\n#### DQL——>`分组查询`\r\n\r\n**分组查询**\r\n```sql\r\nselect 字段列表 from 表名 where 查询条件 group by 分组字段名 having 分组后过滤条件;\r\n```\r\n<warn>**注意:** </warn>\r\n* 分组后,只能查询分组字段和聚合函数，查询其他字段能出结果但无意义\r\n* 执行顺序: `where` -> `聚合函数` -> `having`\r\n* `where` 和 `having` 区别：\r\n  * `where` 是对分组前的数据进行限定,无法对聚合函数判断\r\n  * `having` 是对分组后的数据进行过滤,能对聚合函数判断\r\n\r\n**分组查询书写示例**\r\n```sql\r\n-- 查询全班男生女生各自的数学平均分\r\nselect sex,avg(math_score) from student group by sex;\r\n\r\n-- 分组后,只能查询分组字段和聚合函数，查询其他字段能出结果但无意义\r\nselect name,sex,avg(math_score) from student group by sex;\r\n\r\n-- 查询全班男生女生各自的数学平均分及各自人数\r\nselect sex,avg(math_score) as math_avg,count(id) as pcount from student group by sex;\r\n\r\n-- 查询全班男生女生各自的数学平均分及各自人数,分数低于70分不参与分组\r\nselect sex,avg(math_score) as math_avg,count(id) as pcount from student where math_score > 70 group by sex;\r\n\r\n-- 查询全班男生女生各自的数学平均分及各自人数,分数低于70分不参与分组,分组后,各分组的总人数>2\r\nselect \r\n   sex,avg(math_score) as math_avg,\r\n   count(id) as pcount from student\r\nwhere\r\n   math_score > 70\r\ngroup by \r\n   sex \r\nhaving \r\n   count(id) > 2;\r\n```\r\n\r\n#### DQL——>`分页查询`\r\n**分页查询语法**\r\n```sql\r\nselect 字段列表 from 表名 limit 起始索引 , 查询条目数;\r\n```\r\n\r\n**注意点**\r\n* 起始索引：从0开始\r\n* 计算公式：`起始索引 = (查询页-1) * 每页显示条目数`\r\n* <green>分页查询语法格式是mysql特有的</green>\r\n  * `sql Server` 分页查询用 `top`\r\n  * `oracle` 分页查询用 `rownnumber`\r\n\r\n**分页查询语法示例**\r\n```sql\r\n-- 从0开始查询三条数据\r\nselect * from student limit 0 ,3 ;\r\n\r\n-- 每页展示10条数据，查询第1页数据\r\nselect * from student limit 0 ,10 ;    `起始索引 = (查询页-1) * 每页显示条目数`\r\n-- 每页展示10条数据，查询第2页数据\r\nselect * from student limit 10 ,10 ;\r\n-- 每页展示10条数据，查询第3页数据\r\nselect * from student limit 20 ,10 ;\r\n```\r\n\r\n\r\n### DCL(Data Control Language)数据控制语言\r\n#### ??\r\n\r\n### 约束\r\n\r\n概念\r\n* 约束是作用于表中列的规则，用于限制加入数据的\r\n* 约束可以保证数据的 **正确性** **完整性** **有效性**\r\n\r\n**主要的几种约束**\r\n| 约束名称 | 描述                                                              | 关键字                         |\r\n| -------- | ----------------------------------------------------------------- | ------------------------------ |\r\n| 非空约束 | 保证列中所有数据不能有null值                                      | `NOT NULL`                     |\r\n| 唯一约束 | 保证列中所有数据各不相同,如果修饰的列是数值类型可以添加自增约束   | `UNIQUE [AUTO_INCREMENT]`      |\r\n| 主键约束 | 主键是一行数据的唯一标识，要求`非空`且`唯一`                      | `PRIMARY KEY [AUTO_INCREMENT]` |\r\n| 检查约束 | 保证列中的值满足某一条件  <warn> mysql不支持 **检查约束** </warn> | `CHECK`                        |\r\n| 默认约束 | 保存数据时，未指定值则采用默认值                                  | `DEFAULT`                      |\r\n| 外键约束 | 外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性      | `FOREIGN KEY`                  |\r\n\r\n**扩展约束**\r\n| 约束名称 | 描述                                                                           | 关键字          |\r\n| -------- | ------------------------------------------------------------------------------ | --------------- |\r\n| 自增约束 | 当列为`数值类型`且有`唯一约束`，保存数据时，`未指定值`或`给null`时将`自动自增` | AUTO_INCREMENT` |\r\n\r\n\r\n\r\n\r\n\r\n#### 非空约束\r\n\r\n```sql\r\nuse db1;\r\ndrop table if exists student;\r\n\r\n-- 在表创建时在列创建 not null 约束：\r\ncreate table student(\r\n   name char(10) not null -- 经测试,MySQL支持\r\n);\r\n\r\n\r\n-- 撤销 not null 约束\r\nalter table student modify name char(10); -- 经测试,MySQL支持\r\n-- 添加 not null 约束\r\nalter table student modify name char(10) not null; -- 经测试,MySQL支持\r\n```\r\n\r\n#### 唯一约束\r\n\r\n```sql\r\nuse db1;\r\ndrop table if exists student;\r\n\r\n-- 在表创建时在列创建 unique 约束：\r\ncreate table student(\r\n   stuid int unique -- 经测试,MySQL支持\r\n);\r\n-- 如果需要为多个列定义 PRIMARY KEY 约束\r\ncreate table student(\r\n   stuid int,\r\n   UNIQUE (stuid) -- 经测试,MySQL支持\r\n);\r\n\r\n-- 撤销 unique 约束\r\nALTER TABLE student DROP INDEX stuid;   -- 经测试,MySQL支持\r\n-- 添加 unique 约束\r\nALTER TABLE student ADD UNIQUE (stuid); -- 经测试,MySQL支持\r\n```\r\n\r\n\r\n```sql\r\nuse db1;\r\ndrop table if exists student;\r\n-- 如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束\r\ncreate table student(\r\n   stuid int,\r\n   CONSTRAINT c1 UNIQUE (stuid) -- 经测试,MySQL支持\r\n);\r\n-- 删除\r\nALTER TABLE student DROP CONSTRAINT c1; -- 经测试,MySQL不支持\r\nALTER TABLE student DROP INDEX c1; -- 经测试,MySQL支持\r\n-- 添加\r\nALTER TABLE student ADD CONSTRAINT c1 UNIQUE (stuid); -- 经测试,MySQL支持 \r\n```\r\n\r\n\r\n#### 主键约束\r\n**语法**\r\n```sql\r\n -- 主键 `非空not null` 且 `唯一unique`\r\nuse db1;\r\ndrop table if exists student;\r\n\r\n\r\n-- 在表创建时在列创建 PRIMARY KEY 约束：\r\ncreate table student(\r\n   id int primary key -- 经测试,MySQL支持\r\n);\r\n-- 如果需要为多个列定义 PRIMARY KEY 约束\r\ncreate table student(\r\n   id int,\r\n   PRIMARY KEY (id) -- 经测试,MySQL支持 -- 可以用于定义复合主键  PRIMARY KEY (id,name)\r\n);\r\n\r\n-- 撤销 PRIMARY KEY 约束\r\nALTER TABLE student DROP PRIMARY KEY;-- 经测试,MySQL支持\r\n-- 添加 PRIMARY KEY 约束\r\nALTER TABLE student ADD PRIMARY KEY (id);-- 经测试,MySQL支持\r\n```\r\n\r\n```sql\r\n-- 如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束\r\ncreate table student(\r\n   id int,\r\n   CONSTRAINT c1 PRIMARY KEY (id) -- 经测试,MySQL支持\r\n);\r\n-- 通过 CONSTRAINT 对约束命名 添加 PRIMARY KEY 约束\r\nALTER TABLE student ADD CONSTRAINT pk_studentID PRIMARY KEY (id);  -- 经测试,MySQL支持\r\n-- 通过 CONSTRAINT 对约束命名 撤销 PRIMARY KEY 约束\r\nALTER TABLE student DROP CONSTRAINT pk_studentID; --  经测试,MySQL不支持这种写法\r\n```\r\n\r\n#### 检查约束\r\n\r\n```sql\r\nuse db1;\r\ndrop table if exists student;\r\n\r\n-- 在表创建时在列创建 check 约束：\r\ncreate table student(\r\n   stuid int check(stuid>0) -- 经测试,MySQL支持\r\n);\r\n-- 如果需要为多个列定义 check 约束\r\ncreate table student(\r\n   stuid int,\r\n   check(stuid>0) -- 经测试,MySQL支持\r\n);\r\n\r\n-- 撤销 check 约束\r\n   ???\r\n-- 添加 CHECK 约束\r\nALTER TABLE student ADD CHECK (stuid>0); -- 经测试,MySQL支持\r\n```\r\n\r\n```sql\r\nuse db1;\r\ndrop table if exists student;\r\n-- 如果需要命名 PRIMARY KEY 约束，以及为多个列定义 PRIMARY KEY 约束\r\ncreate table student(\r\n   stuid int,\r\n   CONSTRAINT c1 CHECK (stuid>0) -- 经测试,MySQL支持\r\n);\r\n-- 删除\r\nALTER TABLE student DROP CONSTRAINT c1; -- 经测试, MySQL 不支持\r\nALTER TABLE student DROP CHECK c1;-- 经测试, MySQL5.7 不支持\r\n-- 添加\r\nALTER TABLE student ADD CONSTRAINT c1 CHECK ( stuid>0 ); -- 经测试,MySQL支持\r\n```\r\n\r\n#### 默认约束\r\n\r\n```sql\r\nuse db1;\r\ndrop table if exists student;\r\n\r\n-- 在表创建时在列创建 default 约束：\r\ncreate table student(\r\n   stuid int default 0 -- 经测试,MySQL支持\r\n);\r\n\r\n-- 撤销 default 约束\r\nALTER TABLE student ALTER stuid DROP DEFAULT ; -- 经测试,MySQL支持\r\n-- 添加 CHECK 约束\r\nALTER TABLE student ALTER stuid SET DEFAULT 0; -- 经测试,MySQL支持\r\n```\r\n\r\n\r\n#### 外键约束\r\n\r\n```sql\r\ndrop database if exists db1;\r\ncreate database if not exists db1;\r\nuse db1;\r\ndrop table if exists student;\r\ndrop table if exists department;\r\n\r\ncreate table department(\r\n   id int primary key,\r\n   name char(20) not null\r\n);\r\n\r\ncreate table student(\r\n   id int primary key,\r\n   depart_id int,\r\n   constraint stu_dep foreign key(depart_id)  references department(id) \r\n);\r\n\r\n-- 添加 FOREIGN KEY 约束\r\nALTER TABLE student ADD FOREIGN KEY (depart_id) REFERENCES department(id); -- 经测试,MySQL支持\r\nALTER TABLE student ADD CONSTRAINT stu_dep FOREIGN KEY (depart_id) REFERENCES department(id); -- 经测试,MySQL支持\r\n-- 撤销 FOREIGN KEY 约束\r\nALTER TABLE student DROP FOREIGN KEY stu_dep ; -- 经测试,MySQL支持\r\n```\r\n\r\n\r\n\r\n#### 额...... \r\n\r\n**属性级(列名)的约束语法**\r\n```sql\r\n-- 在定义表示添加约束\r\ncreate table 表名(\r\n   列名 数据类型 NOT NULL,\r\n   列名 数据类型 UNIQUE AUTO_INCREMENT,\r\n   列名 数据类型 PRIMARY KEY AUTO_INCREMENT,\r\n   列名 数据类型 DEFAULT 0,\r\n   列名 数据类型 FOREIGN KEY,\r\n);\r\n\r\n-- 添加非空约束\r\nalter table 表名 modify 列名 数据类型 NOT NULL;\r\n-- 删除非空约束\r\nalter table 表名 modify 列名 数据类型;\r\n\r\n-- 添加唯一约束\r\nalter table 表名 modify 列名 数据类型 unique;\r\n-- 删除唯一约束\r\nalter table 表名 drop index 列名;\r\n\r\n-- 添加主键约束\r\nalter table 表名 add PRIMARY KEY(列名);\r\n-- 删除主键约束\r\nalter table 表名 drop PRIMARY KEY;\r\n\r\n-- 添加默认约束\r\nalter table 表名 alter 列名 set default 0;\r\n-- 删除默认约束\r\nalter table 表名 alter 列名 drop default;\r\n\r\n\r\n\r\n```\r\n\r\n**属性级(列名)的约束语法测试**\r\n```sql\r\nuse db1;\r\ndrop table if exists employee;\r\ncreate table employee(\r\n    id int primary key auto_increment,     -- 主键\r\n    name char(10) not null,                -- 非空\r\n    joindate date not null,                -- 非空\r\n    salary double(8,2) not null,           -- 非空\r\n    bonus double(8,2) default 0            -- 默认约束\r\n);\r\ninsert into employee(id,name,joindate,salary,bonus) values(1,\"张三1\",'2001-01-01',1000.00,0.00);\r\ninsert into employee(id,name,joindate,salary,bonus) values(null,\"张三2\",'2001-01-01',1000.00,0.00);\r\ninsert into employee(name,joindate,salary,bonus) values(\"张三3\",'2001-01-01',1000.00,0.00);\r\n\r\nselect * from employee;\r\n```\r\n```bash\r\nmysql> select * from employee;\r\n+----+---------+------------+---------+-------+\r\n| id | name    | joindate   | salary  | bonus |\r\n+----+---------+------------+---------+-------+\r\n|  1 | 张三1   | 2001-01-01 | 1000.00 |  0.00 |\r\n|  2 | 张三2   | 2001-01-01 | 1000.00 |  0.00 |\r\n|  3 | 张三3   | 2001-01-01 | 1000.00 |  0.00 |\r\n+----+---------+------------+---------+-------+\r\n3 rows in set (0.00 sec)\r\n```\r\n\r\n\r\n\r\n\r\n<!-- \r\n**属性级约束`子句`的语法**\r\n```sql\r\n-- 在定义表示添加约束（完整性约束名）\r\ncreate table 表名(\r\n   列名 数据类型 \r\n      constraint 完整性约束名别名 NOT NULL,\r\n   列名 数据类型 \r\n      constraint 完整性约束名别名  UNIQUE AUTO_INCREMENT,\r\n   列名 数据类型 \r\n      constraint 完整性约束名别名 PRIMARY KEY AUTO_INCREMENT,\r\n   列名 数据类型 \r\n      constraint 完整性约束名别名 DEFAULT 0,\r\n   列名 数据类型 \r\n      constraint 完整性约束名别名 FOREIGN KEY,\r\n);\r\n-- 添加约束\r\nalter table 表名 add  constraint 约束名称 ;\r\n-- 删除约束\r\nalter table 表名 drop 完整性约束名别名;\r\n```\r\n\r\n**测试**\r\n```sql\r\ndrop database if exists db1;\r\ncreate database db1;\r\nuse db1;\r\ndrop table if exists employee;\r\ncreate table employee(\r\n   -- 仅在sql server 中测试有效\r\n   -- 且constraint子句仅支持 CHECK,DEFAULT,FOREIGN,PRIMARY,REFERENCES,UNIQUE\r\n   id int \r\n   constraint constraint1 primary key ,     -- 主键\r\n   name char(10) not null,                -- 非空\r\n   joindate date not null,                -- 非空\r\n   salary double(8,2) not null,           -- 非空\r\n   bonus double(8,2)\r\n   constraint constraint2 default 0            -- 默认约束\r\n);\r\n```\r\n\r\n-->\r\n\r\n**元祖级的约束语法**  \r\n复合主键必须以这种方式定义\r\n```sql\r\n-- 在创建表时定义约束\r\ncreate table 表名(\r\n   列名1 数据类型1,\r\n   列名2 数据类型2,\r\n   列名3 数据类型3,\r\n   列名4 数据类型4,\r\n   列名5 数据类型5,\r\n   \r\n   primary key(列名1,列名2),\r\n   \r\n   constraint 完整性约束名别名 foreign key(外键列名) references 主表(主表列名), \r\n\r\n   constraint 完整性约束名别名 约束名称\r\n   -- 👆\r\n   -- 在 sqlserver 中 constraint 仅支持 CHECK,DEFAULT,FOREIGN,PRIMARY,REFERENCES,UNIQUE\r\n   -- 在 mysql 中 经测试，constraint 支持 unique ，primary key  foreign key，其他暂未测试\r\n);\r\n\r\n-- 添加约束\r\nalter table 表名 add  constraint 完整性约束名别名 约束名称;\r\n-- 删除约束\r\nalter table 表名 drop 完整性约束名别名;\r\n\r\n-- 添加外键约束\r\nalter table 表名 add constraint 完整性约束名别名 foreign key(外键列名) references 主表(主表列名);\r\n-- 删除外键约束\r\nalter table 表名 drop foreign key 完整性约束名别名;\r\n```\r\n\r\n**元祖级的约束语法测试**\r\n```sql\r\nuse db1;\r\n\r\ndrop table if exists department;\r\ncreate table department(\r\n    id int primary key auto_increment,     -- 主键\r\n    name char(20)\r\n);\r\n\r\ndrop table if exists employee;\r\ncreate table employee(\r\n    id int auto_increment,                 -- 主键\r\n    name char(10) not null,                -- 非空\r\n    joindate date not null,                -- 非空\r\n    salary double(8,2) not null,           -- 非空\r\n    bonus double(8,2) default 0,           -- 默认约束\r\n    department int,                        -- 外键\r\n   constraint c1 unique(name), -- 唯一\r\n   constraint c2 primary key(id), -- 主键\r\n   constraint c3 foreign key(department) references department(id) --引用完整性约束\r\n);\r\n```\r\n```bash\r\nmysql> desc employee;\r\n--------------\r\ndesc employee\r\n--------------\r\n\r\n+------------+-------------+------+-----+---------+----------------+\r\n| Field      | Type        | Null | Key | Default | Extra          |\r\n+------------+-------------+------+-----+---------+----------------+\r\n| id         | int(11)     | NO   | PRI | NULL    | auto_increment |\r\n| name       | char(10)    | NO   | UNI | NULL    |                |\r\n| joindate   | date        | NO   |     | NULL    |                |\r\n| salary     | double(8,2) | NO   |     | NULL    |                |\r\n| bonus      | double(8,2) | YES  |     | 0.00    |                |\r\n| department | int(11)     | YES  | MUL | NULL    |                |\r\n+------------+-------------+------+-----+---------+----------------+\r\n6 rows in set (0.00 sec)\r\n```\r\n\r\n### 数据库设计\r\n**表关系分类**\r\n* 一对一：\r\n  * 将一个实体中常用字段和不常用字段拆分为两个表，用于提升查询性能\r\n  * 用户和用户详情信息表\r\n  * 一个用户有一个详情信息\r\n* 一对多（多对一）：\r\n  * 部门和员工\r\n  * 一个部门有多个员工，多个员工同属一个部门\r\n* 多对多\r\n  * 商品和订单\r\n  * 一个商品对应多个订单，一个订单有多个商品\r\n\r\n#### 一对一\r\n**实现方式** 在任意一方建立外键，指向另一方的主键，并且设置外键为`唯一UNIQUE`\r\n\r\n![](./images/JavaWeb学习笔记/2022-11-08-01-53-42.png)\r\n\r\n#### 一对多\r\n**实现方式** 在`多`的一方建立外键，指向`一`的一方的主键\r\n\r\n![](./images/JavaWeb学习笔记/2022-11-08-01-46-47.png)\r\n\r\n#### 多对多\r\n**实现方式** 建立第三张`中间表`，中间表至少包含`两个外键`，分别关联两方的`主键`。\r\n\r\n![](./images/JavaWeb学习笔记/2022-11-08-01-49-47.png)\r\n\r\n\r\n### 多表查询\r\n**多表查询**\r\n* 笛卡尔积：取A、B集合的组合\r\n* 多表查询：从多张查询数据\r\n   * 连接查询\r\n      * 内连接：查询A、B交集数据\r\n      * 外连接：\r\n         * 左外连接：查询A表所有数据和交集部分数据\r\n         * 右外连接：查询B表所有数据和交集部分数据\r\n      * 子查询：查询中嵌套查询\r\n* ![](./images/JavaWeb学习笔记/2022-11-08-02-14-14.png)\r\n\r\n#### 笛卡尔积\r\n* 笛卡尔积：有A、B两集合，取A、B两集合所有的组合\r\n* 若A表有4条数据，B表有8条数据，笛卡尔积就有32条数据。\r\n```sql\r\nselect * from tableA,tableB;\r\n```\r\n\r\n#### 内连接\r\n```sql\r\n-- 写法1：隐式内连接\r\nselect * from tableA,tableB where tableA.id = tableB.id;\r\nselect tableA.id,tableA.name,tableA.id,tableA.name from tableA,tableB where tableA.id = tableB.id; -- 防止字段名冲突\r\nselect A.id,A.name,B.id,B.name from tableA as A,tableB as B where A.id = B.id; -- 给表起别名\r\n\r\n-- 写法2：显式内连接\r\nselect * from tableA inner join tableB on tableA.id = tableB.id;\r\nselect * from tableA join tableB on tableA.id = tableB.id; -- inner可省略\r\n```\r\n\r\n#### 外连接\r\n```sql\r\n--- 左外连接:  tableA的所有数据 + tableA和tableB的交集数据\r\nselect * from tableA left outer join tableB on tableA.id = tableB.id;\r\nselect * from tableA left join tableB on tableA.id = tableB.id; -- outer 可省略\r\n\r\n--- 右外连接： tableB的所有数据 + tableA和tableB的交集数据\r\nselect * from tableA right join tableB on tableA.id = tableB.id;\r\nselect * from tableA right join tableB on tableA.id = tableB.id; -- outer 可省略\r\n```\r\n\r\n\r\n#### 子查询\r\n**概念**： 查询中嵌套查询，称嵌套查询为子查询\r\n\r\n**分类**：**根据子查询的结果不同，作用不同** \r\n* 子查询结果为**单行单列**：（使用`=` `!=` `>` `<`等进行条件判断）\r\n  ```sql\r\n  select 字段列表 from 表 where 字段名 = (子查询);\r\n  select 字段列表,(子查询) as 字段别名  from 表;\r\n  ```\r\n* 子查询结果为**单行多列**：（使用 `in` 等关键字进行条件判断）\r\n  ```sql\r\n  select 字段列表 from 表 where 字段名 in (子查询);\r\n  ```\r\n* 子查询结果为**多行多列**,：（作为**虚拟表**）\r\n   ```sql\r\n   select 字段列表 from (子查询) where 条件;\r\n   ```\r\n\r\n#### 案例：子查询\r\n\r\n**数据准备**\r\n```sql\r\ndrop database if exists db2;\r\ncreate database db2;\r\nuse db2;\r\nDROP TABLE IF EXISTS emp;\r\nDROP TABLE IF EXISTS dept;\r\nDROP TABLE IF EXISTS job;\r\nDROP TABLE IF EXISTS salarygrade;\r\n\r\n\r\n-- 部门表\r\nCREATE TABLE dept (\r\n  id INT PRIMARY KEY PRIMARY KEY, -- 部门id\r\n  dname VARCHAR(50), -- 部门名称\r\n  loc VARCHAR(50) -- 部门所在地\r\n);\r\n\r\n\r\n\r\n-- 职务表，职务名称，职务描述\r\nCREATE TABLE job (\r\n  id INT PRIMARY KEY,\r\n  jname VARCHAR(20),\r\n  description VARCHAR(50)\r\n);\r\n\r\n-- 员工表\r\nCREATE TABLE emp (\r\n  id INT PRIMARY KEY, -- 员工id\r\n  ename VARCHAR(50), -- 员工姓名\r\n  job_id INT, -- 职务id\r\n  mgr INT , -- 上级领导\r\n  joindate DATE, -- 入职日期\r\n  salary DECIMAL(7,2), -- 工资\r\n  bonus DECIMAL(7,2), -- 奖金\r\n  dept_id INT, -- 所在部门编号\r\n  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),\r\n  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)\r\n);\r\n-- 工资等级表\r\nCREATE TABLE salarygrade (\r\n  grade INT PRIMARY KEY,   -- 级别\r\n  losalary INT,  -- 最低工资\r\n  hisalary INT -- 最高工资\r\n);\r\n\t\t\t\t\r\n-- 添加4个部门\r\nINSERT INTO dept(id,dname,loc) VALUES \r\n(10,'教研部','北京'),\r\n(20,'学工部','上海'),\r\n(30,'销售部','广州'),\r\n(40,'财务部','深圳');\r\n\r\n-- 添加4个职务\r\nINSERT INTO job (id, jname, description) VALUES\r\n(1, '董事长', '管理整个公司，接单'),\r\n(2, '经理', '管理部门员工'),\r\n(3, '销售员', '向客人推销产品'),\r\n(4, '文员', '使用办公软件');\r\n\r\n\r\n-- 添加员工\r\nINSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES \r\n(1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20),\r\n(1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30),\r\n(1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30),\r\n(1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20),\r\n(1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30),\r\n(1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30),\r\n(1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10),\r\n(1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20),\r\n(1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10),\r\n(1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30),\r\n(1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20),\r\n(1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30),\r\n(1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20),\r\n(1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10);\r\n\r\n\r\n-- 添加5个工资等级\r\nINSERT INTO salarygrade(grade,losalary,hisalary) VALUES \r\n(1,7000,12000),\r\n(2,12010,14000),\r\n(3,14010,20000),\r\n(4,20010,30000),\r\n(5,30010,99990);\r\n\r\n```\r\n\r\n**题目 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述**\r\n```sql\r\n-- ----写法一：隐式内连接\r\nuse db2;\r\nselect \r\n   emp.id,\r\n   emp.ename,\r\n   emp.salary,\r\n   job.jname,\r\n   job.description\r\nfrom \r\n   emp,job\r\nwhere\r\n   emp.job_id = job.id;\r\n\r\n-- ----写法二：显式内连接\r\nuse db2;\r\nselect \r\n   emp.id,\r\n   emp.ename,\r\n   emp.salary,\r\n   job.jname,\r\n   job.description\r\nfrom \r\n   emp\r\ninner join\r\n   job\r\non\r\n   emp.job_id = job.id;\r\n```\r\n**结果**\r\n| id   | ename  | salary | jname  | description        |\r\n| ---- | ------ | ------ | ------ | ------------------ |\r\n| 1009 | 罗贯？ | 50000  | 董事？ | 管理整个公司，接？ |\r\n| 1004 | 唐僧   | 29750  | 经理   | 管理部门员工       |\r\n| 1006 | 宋江   | 28500  | 经理   | 管理部门员工       |\r\n| 1007 | 刘备   | 24500  | 经理   | 管理部门员工       |\r\n| 1002 | 卢俊？ | 16000  | 销售员 | 向客人推销产品     |\r\n| 1003 | 林冲   | 12500  | 销售员 | 向客人推销产品     |\r\n| 1010 | 吴用   | 15000  | 销售员 | 向客人推销产品     |\r\n| 1001 | 孙悟？ | 8000   | 文员   | 使用办公软件       |\r\n| 1005 | 李？   | 12500  | 文员   | 使用办公软件       |\r\n| 1008 | 猪八？ | 30000  | 文员   | 使用办公软件       |\r\n| 1011 | 沙僧   | 11000  | 文员   | 使用办公软件       |\r\n| 1012 | 李？   | 9500   | 文员   | 使用办公软件       |\r\n| 1013 | 小白？ | 30000  | 文员   | 使用办公软件       |\r\n| 1014 | 关羽   | 13000  | 文员   | 使用办公软件       |\r\n\r\n**题目 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置**\r\n```sql\r\n-- ----写法一：隐式内连接\r\nuse db2;\r\nselect \r\n   emp.id,\r\n   emp.ename,\r\n   emp.salary,\r\n   job.jname,\r\n   job.description,\r\n   dept.dname,\r\n   dept.loc\r\nfrom \r\n   emp,job,dept\r\nwhere\r\n   emp.job_id = job.id and emp.dept_id = dept.id;\r\n\r\n-- ----写法二：显式内连接\r\nuse db2;\r\nselect \r\n   emp.id,\r\n   emp.ename,\r\n   emp.salary,\r\n   job.jname,\r\n   job.description,\r\n   dept.dname,\r\n   dept.loc\r\nfrom \r\n   emp\r\ninner join job on emp.job_id = job.id\r\ninner join dept on emp.dept_id = dept.id;\r\n```\r\n**结果**\r\n| id   | ename  | salary | jname  | description        | dname  | loc  |\r\n| ---- | ------ | ------ | ------ | ------------------ | ------ | ---- |\r\n| 1009 | 罗贯？ | 50000  | 董事？ | 管理整个公司，接？ | 教研？ | 北京 |\r\n| 1007 | 刘备   | 24500  | 经理   | 管理部门员工       | 教研？ | 北京 |\r\n| 1014 | 关羽   | 13000  | 文员   | 使用办公软件       | 教研？ | 北京 |\r\n| 1004 | 唐僧   | 29750  | 经理   | 管理部门员工       | 学工？ | 上海 |\r\n| 1001 | 孙悟？ | 8000   | 文员   | 使用办公软件       | 学工？ | 上海 |\r\n| 1008 | 猪八？ | 30000  | 文员   | 使用办公软件       | 学工？ | 上海 |\r\n| 1011 | 沙僧   | 11000  | 文员   | 使用办公软件       | 学工？ | 上海 |\r\n| 1013 | 小白？ | 30000  | 文员   | 使用办公软件       | 学工？ | 上海 |\r\n| 1006 | 宋江   | 28500  | 经理   | 管理部门员工       | 销售部 | 广州 |\r\n| 1002 | 卢俊？ | 16000  | 销售员 | 向客人推销产品     | 销售部 | 广州 |\r\n| 1003 | 林冲   | 12500  | 销售员 | 向客人推销产品     | 销售部 | 广州 |\r\n| 1010 | 吴用   | 15000  | 销售员 | 向客人推销产品     | 销售部 | 广州 |\r\n| 1005 | 李？   | 12500  | 文员   | 使用办公软件       | 销售部 | 广州 |\r\n| 1012 | 李？   | 9500   | 文员   | 使用办公软件       | 销售部 | 广州 |\r\n\r\n\r\n**题目 3.查询员工姓名，工资，工资等级**\r\n```sql\r\n-- 写法1：子查询\r\nuse db2;\r\nselect \r\n   emp.ename,\r\n   emp.salary,\r\n   (select grade from salarygrade where emp.salary between salarygrade.losalary and salarygrade.hisalary ) as salarygrade\r\nfrom\r\n   emp;\r\n\r\n-- 写法2：隐式内连接\r\nuse db2;\r\nselect \r\n   emp.ename,\r\n   emp.salary,\r\n   salarygrade.grade\r\nfrom \r\n   emp,\r\n   salarygrade\r\nwhere\r\n   emp.salary between  salarygrade.losalary and salarygrade.hisalary \r\n;\r\n-- 写法3：显式内连接\r\nuse db2;\r\nselect \r\n   emp.ename,\r\n   emp.salary,\r\n   salarygrade.grade\r\nfrom \r\n   emp\r\ninner join\r\n   salarygrade\r\non\r\n   emp.salary between  salarygrade.losalary and salarygrade.hisalary \r\n;\r\n```\r\n\r\n| ename  | salary | grade |\r\n| ------ | ------ | ----- |\r\n| 孙悟？ | 8000   | 1     |\r\n| 卢俊？ | 16000  | 3     |\r\n| 林冲   | 12500  | 2     |\r\n| 唐僧   | 29750  | 4     |\r\n| 李？   | 12500  | 2     |\r\n| 宋江   | 28500  | 4     |\r\n| 刘备   | 24500  | 4     |\r\n| 猪八？ | 30000  | 4     |\r\n| 罗贯？ | 50000  | 5     |\r\n| 吴用   | 15000  | 3     |\r\n| 沙僧   | 11000  | 1     |\r\n| 李？   | 9500   | 1     |\r\n| 小白？ | 30000  | 4     |\r\n| 关羽   | 13000  | 2     |\r\n\r\n**题目 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级**\r\n```sql\r\n-- 写法1：显式内连接\r\nuse db2;\r\nselect \r\n   emp.ename,\r\n   emp.salary,\r\n   job.jname,\r\n   job.description,\r\n   dept.dname,\r\n   dept.loc,\r\n   salarygrade.grade\r\nfrom \r\n   emp\r\ninner join job on emp.job_id = job.id\r\ninner join dept on emp.dept_id = dept.id\r\ninner join salarygrade on emp.salary between salarygrade.losalary and salarygrade.hisalary\r\n;\r\n\r\n-- 写法2：子查询\r\nuse db2;\r\nselect \r\n   emp.ename,\r\n   emp.salary,\r\n   emp.dept_id,\r\n   (select grade from salarygrade where emp.salary between salarygrade.losalary and salarygrade.hisalary ) as salarygrade ,\r\n   (select job.jname from job where emp.job_id = job.id) as jname,\r\n   (select job.description from job where emp.job_id = job.id) as jdescription,\r\n   (select dept.dname from dept where emp.dept_id = dept.id) as dname,\r\n   (select dept.loc from dept where emp.dept_id = dept.id) as dloc\r\nfrom \r\n   emp\r\n;\r\n```\r\n**查询结果**\r\n| ename | salary | jname  | description       | dname  | loc  | grade |\r\n| ----- | ------ | ------ | ----------------- | ------ | ---- | ----- |\r\n| 孙悟? | 8000   | 文员   | 使用办公软件      | 学工?  | 上海 | 1     |\r\n| 卢俊? | 16000  | 销售员 | 向客人推销产品    | 销售部 | 广州 | 3     |\r\n| 林冲  | 12500  | 销售员 | 向客人推销产品    | 销售部 | 广州 | 2     |\r\n| 唐僧  | 29750  | 经理   | 管理部门员工      | 学工?  | 上海 | 4     |\r\n| 李?   | 12500  | 文员   | 使用办公软件      | 销售部 | 广州 | 2     |\r\n| 宋江  | 28500  | 经理   | 管理部门员工      | 销售部 | 广州 | 4     |\r\n| 刘备  | 24500  | 经理   | 管理部门员工      | 教研?  | 北京 | 4     |\r\n| 猪八? | 30000  | 文员   | 使用办公软件      | 学工?  | 上海 | 4     |\r\n| 罗贯? | 50000  | 董事?  | 管理整个公司，接? | 教研?  | 北京 | 5     |\r\n| 吴用  | 15000  | 销售员 | 向客人推销产品    | 销售部 | 广州 | 3     |\r\n| 沙僧  | 11000  | 文员   | 使用办公软件      | 学工?  | 上海 | 1     |\r\n| 李?   | 9500   | 文员   | 使用办公软件      | 销售部 | 广州 | 1     |\r\n| 小白? | 30000  | 文员   | 使用办公软件      | 学工?  | 上海 | 4     |\r\n| 关羽  | 13000  | 文员   | 使用办公软件      | 教研?  | 北京 | 2     |\r\n\r\n\r\n**题目 5.查询出部门编号、部门名称、部门位置、部门人数**\r\n```sql\r\n-- 方法1： 子查询\r\nuse db2;\r\nselect\r\n   dept.id as 部门编号 ,\r\n   dept.dname as 部门名称 ,\r\n   dept.loc as 部门位置 ,\r\n   (select count(emp.id) from emp where dept.id = emp.dept_id) as 部门人数\r\nfrom\r\n   dept\r\n;\r\n```\r\n\r\n| 部门编号 | 部门名称 | 部门位置 | 部门人数 |\r\n| -------- | -------- | -------- | -------- |\r\n| 10       | 教研?    | 北京     | 3        |\r\n| 20       | 学工?    | 上海     | 5        |\r\n| 30       | 销售部   | 广州     | 6        |\r\n| 40       | 财务?    | 深圳     | 0        |\r\n\r\n\r\n### 事务\r\n**概念**\r\n* 简单理解，事务是一组操作命令，当一组中的一条操作执行出错，则这一组的操作将全部被撤销（回滚）。\r\n* 事务（Transaction）是一种机制一个操作序列，包含了一组数据库操作命令\r\n* 事务把所有命令作为整体一起提交操作请求，这一组数据库命令要么同时成功，要么同时失败。\r\n* 事务是一个不可分割的工作逻辑单元。\r\n\r\n**特性ACID**\r\n* **原子性**(Atomicity):事务是不可分割的最小操作单位，要么同时成功，要么同时失败\r\n* **一致性**(Consistency):事务完成时，必须使所有的数据都保持一致状态\r\n* **隔离性**(lsolation) :多个事务之间，操作的可见性\r\n* **持久性**(Durability):事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\r\n\r\n\r\n**语法**\r\n ```sql\r\n -- 开启事务\r\n start transaction;\r\n -- 开启事务\r\n begin;\r\n 普通sql语句1\r\n 普通sql语句2\r\n 普通sql语句3\r\n 普通sql语句......\r\n\r\n -- 提交事务\r\n commit;\r\n --回滚事务\r\n rollback;\r\n ```\r\n\r\nmysql默认提交事务规则\r\n```sql\r\nselect @@autocommit; -- 输出1表示事务默认自动提交\r\nsql语句; -- 该语句将自动提交\r\n\r\nset @@autocommit = 0; -- 修改事务默认提交方式\r\nselect @@autocommit; -- 输出0表示需要手动提交\r\n\r\nsql语句; -- 该语句将不会自动提交\r\ncommit; -- 手动提交\r\n```\r\n\r\n\r\n## JDBC\r\n**概念**\r\n* 全称：JDBC(Java DataBase Connectivity)Java数据库连接\r\n* 操作关系型数据库的一套API，也就是一个接口类\r\n* 各个数据库厂商会去实现这套接口，提供数据库驱动jar包\r\n* 通过JDBC接口可以不改变sql语句，操作不同的数据库：mysql oracle DB2\r\n* ![](./images/JavaWeb学习笔记/2022-11-08-13-47-24.png)\r\n\r\n\r\n\r\n**测试JDBC：基本写法**\r\n\r\n```sql\r\nshow databases;\r\ndrop database if exists db1;\r\ncreate database db1;\r\nuse db1;\r\ncreate table student(\r\n   id int primary key,\r\n   age int\r\n);\r\ninsert into student(id,age) values(0,10);\r\nupdate student set age=15 where id = 0;\r\n```\r\n\r\n```java\r\npackage test_jdbc;\r\n\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\nimport java.sql.Statement;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 0. 引入mysql-connector-j-8.0.31.jar包\r\n        // 1. 注册驱动\r\n        Class.forName(\"com.mysql.cj.jdbc.Driver\");// 新版本将自动注册，其实不用写\r\n        // 2. 获取连接\r\n        String url = \"jdbc:mysql://localhost:3306/db1\";\r\n        String username = \"root\";\r\n        String password = \"123456\";\r\n        Connection connection = DriverManager.getConnection(url, username, password);\r\n        // 3.定义sql语句\r\n        String sql = \"update student set age=15 where id = 0;\";\r\n        // 4.获取sql执行器对象Statement\r\n        Statement statement = connection.createStatement();\r\n        // 5.执行sql语句\r\n        int updataCount = statement.executeUpdate(sql);\r\n        // 6.处理结果\r\n        System.out.println(updataCount);\r\n        // 7.释放资源\r\n        statement.close();\r\n        connection.close();\r\n    }\r\n}\r\n```\r\n![](./images/JavaWeb学习笔记/2022-11-08-15-00-45.png)\r\n\r\n### DriverManager工具类\r\nDriverManager(驱动管理类)**作用**:\r\n1. **注册驱动** (mysql5之后的驱动包将自动注册)\r\n   1. 注册驱动的过程:\r\n      1. `Class.forName(\"com.mysql.cj.jdbc.Driver\");`将`Driver类`的字节码加载到内存中，\r\n      2. `Driver()`类中的**静态代码块**被执行：\r\n      3. ![](./images/JavaWeb学习笔记/2022-11-14-22-14-18.png)\r\n      4. DriverManager对象通过其自身的静态方法`DriverManager.registerDriver()`接收到`new Driver()`的实例对象\r\n2. **获取数据库连接**\r\n   * `DriverManager.getConnection(url,user,password);`\r\n   * `url`格式：`jdbc:mysql://ip或域名:端口/数据库名称？参数名1=参数值1&参数名2=参数值2`\r\n     * 简写：\r\n       * `localhost:3306` 可简写为\r\n       * `jdbc:mysql:///数据库名称？参数名1=参数值1&参数名2=参数值2`\r\n       * **在xml中的转义字符：**`&`  --> `&amp;`\r\n     * 参数配置：\r\n       * `useSSL=false` 关闭不使用SSL安全连接时的提示\r\n       * `useServerPrepStemts=true` 开启sql语句预编译功能，防止sql注入\r\n\r\n```java\r\nString url = \"jdbc:mysql://localhost:3306/db1\";//完整写法\r\nString url = \"jdbc:mysql:///db1\";//简写\r\nString url = \"jdbc:mysql:///db1?useSSL=false\";//关闭不使用SSL安全连接时的提示\r\nString username = \"root\";\r\nString password = \"123456\";\r\nConnection connection = DriverManager.getConnection(url, username, password);\r\n```\r\n\r\n\r\n### Connection数据库连接对象\r\n\r\n**作用**\r\n1. **获取sql执行器`Statement`、`PreparedStatement`、`CallableStatement`对象**\r\n   ```java\r\n   //获取普通sql执行器对象\r\n   Statement statement = connection.createStatement();\r\n   ```\r\n   ```java\r\n   //获取预编译sql执行器对象:防止sql注入\r\n   PreparedStatement pstatement = connection.prepareStatement(sql);\r\n   ```\r\n   ```java\r\n   //执行存储过程的对象\r\n   CallableStatement cstatement = connection.prepareCall(sql);\r\n   ```\r\n2. **事务处理**\r\n   ```java\r\n   //开启事务：mysql为自动提交事务，设置为自动提交为false便是开启事务管理\r\n   connection.setAutoCommit(boolean autoCommit);\r\n   ```\r\n   ```java\r\n   //提交事务\r\n   connection.commit();\r\n   ```\r\n   ```java\r\n   //回滚事务\r\n   connection.rollback();\r\n   ```\r\n   **事务处理示例**\r\n   ```java\r\n   try{\r\n      connection.setAutoCommit(false);//开启事务\r\n\r\n      Statement statement = connection.createStatement();\r\n\r\n      statement.executeUpdate(sql语句1);\r\n      statement.executeUpdate(sql语句2);\r\n      statement.executeUpdate(sql语句3);\r\n\r\n      connection.commit();//提交事务\r\n   }catch(Exception e){\r\n      connection.rollback();//捕获到任何异常便回滚数据\r\n      connection.setAutoCommit(false);//关闭事务（如果需要）\r\n   }\r\n   ```\r\n\r\n### `Statement` sql执行器对象\r\n\r\n**作用**\r\n1. 执行sql语句\r\n   ```java\r\n   // 执行 DML DDL语句\r\n   //    * 返回值：\r\n   //       * DML语句执行成功后影响的行数\r\n   //       * DDL语句执行成功也可能返回0\r\n   int executeUpdate(sql);\r\n   ```\r\n   ```java\r\n   // 执行DQL语句\r\n   //    * 返回值：ResultSet 类型的结果集合对象，表示查询结果\r\n   ResultSet executeQuery(sql);\r\n   ```\r\n\r\n\r\n### `PreparedStatement` 预编译sql执行器对象:防止sql注入\r\n\r\n**概念**\r\n* `PreparedStatement` 继承自 `Statement` 对象\r\n\r\n\r\n**作用**\r\n* 预编译SQL语句并执行:预防sql注入\r\n\r\n**优点**\r\n* 防sql注入\r\n* 高性能\r\n\r\n**防sql注入原理**： \r\n* 对敏感字符和关键字进行了转义\r\n\r\n**高性能执行原理**\r\n* sql语句提交给mysql服务器要完成一系列操作：\r\n  * **sql语句的语法检查**\r\n  * **将sql语句编译成可执行函数**\r\n  * ![](./images/JavaWeb学习笔记/2022-11-15-01-41-47.png)\r\n* `PreparedStatement(sql模板字符串)` 调用时，会把sql模板语句发送给sql服务器进行预编译，且多次调用只会预编译一次。\r\n* 程序在后续传入参数值时，不需要在进行预编译操作。直接执行sql的**可执行函数**\r\n\r\n**sql注入** \r\n* 通过一定的手段，向程序输入预先编辑好的sql语句，以达到执行sql代码，完成一定的操作，对服务器进行攻击的目的。\r\n* 如： \r\n  * 若后端判断验证用户合法的sql是 `select * from users where username = '输入的用户名' and password = '输入的密码' `;\r\n  * 则在密码框输入`'or '1'='1`\r\n  * sql的语句就变为了 `select * from users where username = '输入的用户名' and password = '' or '1'='1' `;\r\n  * ![](./images/JavaWeb学习笔记/2022-11-15-00-43-02.png)\r\n\r\n\r\n\r\n**使用**\r\n* 使用？作为占位符，预编译sql语句\r\n```java\r\nString url = \"jdbc:mysql://localhost:3306/db1?useServerPrepStemts=true\"; // 启用预编译功能，不启用也行，但使用prepareStatement() 不会导致执行效率变高\r\nString username = \"root\";\r\nString password = \"123456\";\r\n\r\nConnection connection = DriverManager.getConnection(url, username, password);\r\n\r\nString username = \"admin\";\r\nString password = \"admin\";\r\n// 使用？作为占位符，传入prepareStatement() 函数\r\nString sql = \"select * from user where username = ? and password = ? \";\r\nPreparedStatement pstatement = connection.prepareStatement(sql);// 预编译sql语句，多次执行不会导致mysql服务器多次预编译，只会编译一次\r\npstatement.setString(1,username);//给第1个？设置值\r\npstatement.setString(2,password);//给第2个？设置值\r\nResultSet result =  pstatement.executeQuery();//执行sql语句（不要传递参数）\r\n\r\nwhile(result.next()){\r\n   String id = result.getString(\"id\");\r\n   String name = result.getString(\"name\");\r\n   System.out.println(id);\r\n   System.out.println(name);\r\n}\r\n\r\n\r\nresult.close(); // 释放资源\r\nstatement.close(); // 释放资源\r\nconnection.close(); // 释放资源\r\n```\r\n\r\n\r\n### ResultSet 结果集合对象\r\n\r\n**作用**\r\n0. 该实例对象的内容是sql的查询结果\r\n1. 获取查询结果\r\n   ```java\r\n   // 遍历行\r\n   //    * 游标指针：查询结果是一个二维表，游标指针初始指向表头所在行（数据行的上一行）\r\n   //    * next()函数:该函数会使得游标指针指向下一行\r\n   //    * 返回值: 布尔值，当前行是否是有效行（是否有数据）\r\n   boolean next();\r\n   ```\r\n   ```java\r\n   // 获取某列的数据\r\n   //    * 参数\r\n   //       * int 列编号 从1开始编号\r\n   //       * String 列名\r\n   //    * 返回值\r\n   //       * xxx数据类型的数据\r\n   xxx getXxx(参数);\r\n\r\n   String getString(\"UserName\");\r\n   String getString(1);\r\n   ```\r\n\r\n**使用案例**\r\n```java\r\nConnection connection = DriverManager.getConnection(url, username, password);\r\nStatement statement = connection.createStatement();\r\nResultSet result =  statement.executeQuery(sql);\r\n\r\nwhile(result.next()){\r\n   String id = result.getString(\"id\");\r\n   String name = result.getString(\"name\");\r\n   System.out.println(id);\r\n   System.out.println(name);\r\n}\r\nresult.close(); // 释放资源\r\nstatement.close(); // 释放资源\r\nconnection.close(); // 释放资源\r\n```\r\n\r\n\r\n\r\n### 数据库连接池\r\n\r\n**数据库连接池简介**\r\n* 概念类似于线程池，数据连接的建立要耗费时间和计算资源，预先建立一定数量的数据库连接，按需分配，\r\n* 数据库连接池是个容器，负责分配、管理数据库连接(Connection)\r\n\r\n数据库连接池的标准接口及常用实现类\r\n* **接口**： `DataSource`\r\n  ```java\r\n  //接口方法：\r\n  Connection getConnection();//获取池内的连接\r\n  ```\r\n* **实现类**： `DBCP` `C3P0` `Druid` \r\n\r\n\r\n#### Druid德鲁伊数据库连接池\r\nDruid德鲁伊\r\n* 阿里巴巴开源数据库连接池\r\n* 功能强大、性能优秀\r\n\r\n**Druid基本使用**\r\n```java\r\npackage test_for_druid;\r\nimport java.io.FileInputStream;\r\nimport java.sql.Connection;\r\nimport java.util.Properties;\r\n\r\nimport javax.sql.DataSource;\r\n\r\n//1.导入jar包\r\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\r\n//2.编写配置文件\r\n\r\n\r\npublic class Main {\r\n    public static void main(String[] args)throws Exception {\r\n        //3.加载配置文件\r\n        Properties config = new Properties();\r\n        //\r\n        // System.out.println(System.getProperty(\"user.dir\"));//查看当前所在目录\r\n        config.load(new FileInputStream(\"./src/test_for_druid/druid.properties\"));\r\n        System.out.println(config.toString());\r\n\r\n        //4.获取连接池对象\r\n        DataSource dataSource =  DruidDataSourceFactory.createDataSource(config);\r\n        \r\n        //5.从连接池中获取连接对象\r\n        Connection connection = dataSource.getConnection();\r\n\r\n        System.out.println(connection);\r\n    }\r\n}\r\n```\r\n**Druid配置文件**\r\n```properties\r\n# jdbc驱动类名\r\ndriverClassName=com.mysql.jdbc.Driver\r\nurl=jdbc:mysql:///db5?useSSL=false&useServerPrepStmts=true\r\nusername=root\r\npassword=root\r\n# 初始连接数\r\ninitialSize=5\r\n# 最大连接数\r\nmaxActive=10\r\n# 最大等待时间\r\nmaxWait=3000\r\n```\r\n\r\n### JDBC练习\r\n\r\n#### 查询数据\r\n**数据准备**\r\n```sql\r\ndrop database if exists db5;\r\ncreate database db5;\r\nuse db5;\r\ncreate table tb_brand(\r\n   -- id\r\n   id int primary key auto_increment,\r\n   -- 品牌名\r\n   brand_name varchar(20),\r\n   -- 公司名\r\n   company_name varchar(20),\r\n   -- 排序优先级\r\n   ordered int,\r\n   -- 描述\r\n   description varchar(100),\r\n   -- 状态：1 启用 0 禁用\r\n   status int\r\n);\r\ninsert into \r\n    tb_brand(brand_name,company_name,ordered,description,status) \r\n    values\r\n        (\"三只松鼠\",\"三只松鼠股份有限公司\",5,'好吃不上火',0),\r\n        (\"华为\",\"华为技术有限公司\",1,'华为致力于把数字技术带入每个人、每个家庭、每个组织，构建万物互联的智能世界',1),\r\n        (\"小米\",\"小米科技有限公司\",4,'Are you ok?',1);\r\n\r\nSELECT * from tb_brand;\r\n```\r\n**查询表中所有数据案例**\r\n```java\r\npackage test_for_druid;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.sql.Connection;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Properties;\r\n\r\nimport javax.sql.DataSource;\r\n\r\n//1.导入jar包\r\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\r\n//2.编写配置文件\r\n\r\npublic class Main {\r\n    public static void main(String[] args)throws Exception {\r\n        //3.加载配置文件\r\n        Properties config = new Properties();\r\n        //\r\n        // System.out.println(System.getProperty(\"user.dir\"));//查看当前所在目录\r\n        config.load(new FileInputStream(\"./src/test_for_druid/druid.properties\"));\r\n        System.out.println(config.toString());\r\n\r\n        //4.获取连接池对象\r\n        DataSource dataSource =  DruidDataSourceFactory.createDataSource(config);\r\n        \r\n        //5.从连接池中获取连接对象\r\n        Connection connection = dataSource.getConnection();\r\n\r\n        // 定义sql语句\r\n        String sql = \"select * from tb_brand\";\r\n        // 获取sql预编译对象\r\n        PreparedStatement preparedStatement =  connection.prepareStatement(sql);\r\n        //执行查询\r\n        ResultSet resultSet = preparedStatement.executeQuery();\r\n        List<Banner> banners = new LinkedList<>();\r\n        //遍历结果并存入数组\r\n        while(resultSet.next()){\r\n            banners.add(new Banner(\r\n                resultSet.getInt(\"id\"),\r\n                resultSet.getString(\"brand_name\"),\r\n                resultSet.getString(\"company_name\"),\r\n                resultSet.getInt(\"ordered\"),\r\n                resultSet.getString(\"description\"),\r\n                resultSet.getInt(\"status\")\r\n                ));\r\n        }\r\n        System.out.println(banners);\r\n        //释放资源\r\n        preparedStatement.close();\r\n        connection.close();\r\n    }\r\n}\r\nclass Banner{\r\n    // id\r\n    private Integer id;\r\n    // 品牌名\r\n    private String brand_name;\r\n    // 公司名\r\n    private String company_name;\r\n    // 排序优先级\r\n    private Integer ordered;\r\n    // 描述\r\n    private String description;\r\n    // 状态：1 启用 0 禁用\r\n    private Integer status;\r\n    public Banner(Integer id, String brand_name, String company_name, Integer ordered, String description,\r\n            Integer status) {\r\n        this.id = id;\r\n        this.brand_name = brand_name;\r\n        this.company_name = company_name;\r\n        this.ordered = ordered;\r\n        this.description = description;\r\n        this.status = status;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nBanner [id=\" + id + \", brand_name=\" + brand_name + \", company_name=\" + company_name + \", ordered=\"\r\n                + ordered + \", description=\" + description + \", status=\" + status + \"]\";\r\n    }\r\n}\r\n```\r\n\r\n#### 插入数据\r\n```java\r\npackage test_for_druid;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.sql.Connection;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Properties;\r\n\r\nimport javax.sql.DataSource;\r\n\r\n//1.导入jar包\r\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\r\n//2.编写配置文件\r\n\r\npublic class Main {\r\n    public static void main(String[] args)throws Exception {\r\n        //3.加载配置文件\r\n        Properties config = new Properties();\r\n        //\r\n        // System.out.println(System.getProperty(\"user.dir\"));//查看当前所在目录\r\n        config.load(new FileInputStream(\"./src/test_for_druid/druid.properties\"));\r\n        System.out.println(config.toString());\r\n\r\n        //4.获取连接池对象\r\n        DataSource dataSource =  DruidDataSourceFactory.createDataSource(config);\r\n        \r\n        //5.从连接池中获取连接对象\r\n        Connection connection = dataSource.getConnection();\r\n\r\n        // Banner 获取数据\r\n        Banner banner = new Banner(\"生命有限\", \"生命有限公司\", 2, \"当了程序员，寿命减十年\", 0);\r\n        // 定义sql语句\r\n        String sql = \"insert tb_brand(brand_name,company_name,ordered,description,status) values(?,?,?,?,?)\";\r\n        // 获取sql预编译对象\r\n        PreparedStatement preparedStatement =  connection.prepareStatement(sql);\r\n        // 设置值\r\n        preparedStatement.setString(1, banner.getBrand_name());\r\n        preparedStatement.setString(2, banner.getCompany_name());\r\n        preparedStatement.setInt(3, banner.getOrdered());\r\n        preparedStatement.setString(4, banner.getDescription());\r\n        preparedStatement.setInt(5, banner.getStatus());\r\n        //执行查询\r\n        int result = preparedStatement.executeUpdate();\r\n        if(result>0)\r\n            System.out.println(\"更新成功\");\r\n        else\r\n            System.out.println(\"更新失败\");\r\n        //释放资源\r\n        preparedStatement.close();\r\n        connection.close();\r\n    }\r\n}\r\nclass Banner{\r\n    // id\r\n    private Integer id;\r\n    // 品牌名\r\n    private String brand_name;\r\n    // 公司名\r\n    private String company_name;\r\n    // 排序优先级\r\n    private Integer ordered;\r\n    // 描述\r\n    private String description;\r\n    // 状态：1 启用 0 禁用\r\n    private Integer status;\r\n    public Banner(Integer id, String brand_name, String company_name, Integer ordered, String description,\r\n            Integer status) {\r\n        this.id = id;\r\n        this.brand_name = brand_name;\r\n        this.company_name = company_name;\r\n        this.ordered = ordered;\r\n        this.description = description;\r\n        this.status = status;\r\n    }\r\n    public Banner(String brand_name, String company_name, Integer ordered, String description,\r\n            Integer status) {\r\n        this.brand_name = brand_name;\r\n        this.company_name = company_name;\r\n        this.ordered = ordered;\r\n        this.description = description;\r\n        this.status = status;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nBanner [id=\" + id + \", brand_name=\" + brand_name + \", company_name=\" + company_name + \", ordered=\"\r\n                + ordered + \", description=\" + description + \", status=\" + status + \"]\";\r\n    }\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n    public String getBrand_name() {\r\n        return brand_name;\r\n    }\r\n    public String getCompany_name() {\r\n        return company_name;\r\n    }\r\n    public Integer getOrdered() {\r\n        return ordered;\r\n    }\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n    public Integer getStatus() {\r\n        return status;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n#### 更新数据\r\n```java\r\npackage test_for_druid;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.sql.Connection;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Properties;\r\n\r\nimport javax.sql.DataSource;\r\n\r\n//1.导入jar包\r\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\r\n//2.编写配置文件\r\n\r\npublic class Main {\r\n    public static void main(String[] args)throws Exception {\r\n        //3.加载配置文件\r\n        Properties config = new Properties();\r\n        //\r\n        // System.out.println(System.getProperty(\"user.dir\"));//查看当前所在目录\r\n        config.load(new FileInputStream(\"./src/test_for_druid/druid.properties\"));\r\n        System.out.println(config.toString());\r\n\r\n        //4.获取连接池对象\r\n        DataSource dataSource =  DruidDataSourceFactory.createDataSource(config);\r\n        \r\n        //5.从连接池中获取连接对象\r\n        Connection connection = dataSource.getConnection();\r\n\r\n        // Banner 获取数据\r\n        Banner banner = new Banner(4,\"生命有限\", \"生命有限公司\", 9999, \"当了程序员，寿命减十年......\", 0);\r\n        // 定义sql语句\r\n        String sql = \"update tb_brand set brand_name=?, company_name=?, ordered=?, description=?, status=? where id =?\";\r\n        // 获取sql预编译对象\r\n        PreparedStatement preparedStatement =  connection.prepareStatement(sql);\r\n        // 设置值\r\n        preparedStatement.setString(1, banner.getBrand_name());\r\n        preparedStatement.setString(2, banner.getCompany_name());\r\n        preparedStatement.setInt(3, banner.getOrdered());\r\n        preparedStatement.setString(4, banner.getDescription());\r\n        preparedStatement.setInt(5, banner.getStatus());\r\n        preparedStatement.setInt(6, banner.getId());\r\n\r\n        //执行查询\r\n        int result = preparedStatement.executeUpdate();\r\n        if(result>0)\r\n            System.out.println(\"更新成功\");\r\n        else\r\n            System.out.println(\"更新失败\");\r\n\r\n        //释放资源\r\n        preparedStatement.close();\r\n        connection.close();\r\n    }\r\n}\r\nclass Banner{\r\n    // id\r\n    private Integer id;\r\n    // 品牌名\r\n    private String brand_name;\r\n    // 公司名\r\n    private String company_name;\r\n    // 排序优先级\r\n    private Integer ordered;\r\n    // 描述\r\n    private String description;\r\n    // 状态：1 启用 0 禁用\r\n    private Integer status;\r\n    public Banner(Integer id, String brand_name, String company_name, Integer ordered, String description,\r\n            Integer status) {\r\n        this.id = id;\r\n        this.brand_name = brand_name;\r\n        this.company_name = company_name;\r\n        this.ordered = ordered;\r\n        this.description = description;\r\n        this.status = status;\r\n    }\r\n    public Banner(String brand_name, String company_name, Integer ordered, String description,\r\n            Integer status) {\r\n        this.brand_name = brand_name;\r\n        this.company_name = company_name;\r\n        this.ordered = ordered;\r\n        this.description = description;\r\n        this.status = status;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nBanner [id=\" + id + \", brand_name=\" + brand_name + \", company_name=\" + company_name + \", ordered=\"\r\n                + ordered + \", description=\" + description + \", status=\" + status + \"]\";\r\n    }\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n    public String getBrand_name() {\r\n        return brand_name;\r\n    }\r\n    public String getCompany_name() {\r\n        return company_name;\r\n    }\r\n    public Integer getOrdered() {\r\n        return ordered;\r\n    }\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n    public Integer getStatus() {\r\n        return status;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n#### 删除数据\r\n```java\r\npackage test_for_druid;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.sql.Connection;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\nimport java.util.Properties;\r\n\r\nimport javax.sql.DataSource;\r\n\r\n//1.导入jar包\r\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\r\n//2.编写配置文件\r\n\r\npublic class Main {\r\n    public static void main(String[] args)throws Exception {\r\n        //3.加载配置文件\r\n        Properties config = new Properties();\r\n        //\r\n        // System.out.println(System.getProperty(\"user.dir\"));//查看当前所在目录\r\n        config.load(new FileInputStream(\"./src/test_for_druid/druid.properties\"));\r\n        System.out.println(config.toString());\r\n\r\n        //4.获取连接池对象\r\n        DataSource dataSource =  DruidDataSourceFactory.createDataSource(config);\r\n        \r\n        //5.从连接池中获取连接对象\r\n        Connection connection = dataSource.getConnection();\r\n\r\n        // Banner 获取数据\r\n        int id = 4;\r\n        // 定义sql语句\r\n        String sql = \"delete from tb_brand where id = ?\";\r\n        // 获取sql预编译对象\r\n        PreparedStatement preparedStatement =  connection.prepareStatement(sql);\r\n        // 设置值\r\n        preparedStatement.setInt(1,id);\r\n\r\n        //执行查询\r\n        int result = preparedStatement.executeUpdate();\r\n        if(result>0)\r\n            System.out.println(\"更新成功\");\r\n        else\r\n            System.out.println(\"更新失败\");\r\n        //释放资源\r\n        preparedStatement.close();\r\n        connection.close();\r\n    }\r\n}\r\nclass Banner{\r\n    // id\r\n    private Integer id;\r\n    // 品牌名\r\n    private String brand_name;\r\n    // 公司名\r\n    private String company_name;\r\n    // 排序优先级\r\n    private Integer ordered;\r\n    // 描述\r\n    private String description;\r\n    // 状态：1 启用 0 禁用\r\n    private Integer status;\r\n    public Banner(Integer id, String brand_name, String company_name, Integer ordered, String description,\r\n            Integer status) {\r\n        this.id = id;\r\n        this.brand_name = brand_name;\r\n        this.company_name = company_name;\r\n        this.ordered = ordered;\r\n        this.description = description;\r\n        this.status = status;\r\n    }\r\n    public Banner(String brand_name, String company_name, Integer ordered, String description,\r\n            Integer status) {\r\n        this.brand_name = brand_name;\r\n        this.company_name = company_name;\r\n        this.ordered = ordered;\r\n        this.description = description;\r\n        this.status = status;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nBanner [id=\" + id + \", brand_name=\" + brand_name + \", company_name=\" + company_name + \", ordered=\"\r\n                + ordered + \", description=\" + description + \", status=\" + status + \"]\";\r\n    }\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n    public String getBrand_name() {\r\n        return brand_name;\r\n    }\r\n    public String getCompany_name() {\r\n        return company_name;\r\n    }\r\n    public Integer getOrdered() {\r\n        return ordered;\r\n    }\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n    public Integer getStatus() {\r\n        return status;\r\n    }\r\n}\r\n```\r\n\r\n## Maven\r\n\r\nMaven是专门用于管理和构建Java项目的工具，基于项目对象模型（POM）的概念，它的主要功能有:\r\n* 提供了一套标准化的项目结构，通过Maven使得不同IDE创建的项目结构一致\r\n* 提供了一套标准化的构建流程(编译，测试，打包，发布......)\r\n* 提供了一套依赖管理机制\r\n\r\n**标准化的项目结构**\r\n![](./images/JavaWeb学习笔记/2022-11-16-00-15-30.png)\r\n\r\n**标准化的构建流程**\r\n![](./images/JavaWeb学习笔记/2022-11-16-00-21-33.png)\r\n\r\n**依赖管理机制**\r\n![](./images/JavaWeb学习笔记/2022-11-16-00-20-55.png)\r\n\r\n**maven模型**\r\n* POM\r\n* dependency\r\n* Plugin\r\n![](./images/JavaWeb学习笔记/2022-11-16-00-30-15.png)\r\n\r\n**Maven仓库**\r\n * 本地仓库:自己计算机上的一个目录\r\n * 中央仓库:由Maven团队维护的全球唯─的仓库\r\n   * 地址: https://repo1.maven.org/maven2/\r\n * 远程仓库(私服):由公司团队搭建的私有仓库\r\n * jar包的查找顺序\r\n    * 一般引入顺序\r\n      * 项目中使用坐标引入对应依赖jar包，\r\n      * 首先会查找本地仓库中是否有对应的jar包:\r\n      * 如果有，则在项目直接引用;\r\n      * 如果没有，则去中央仓库中下载对应的jar包到本地仓库然后引用。 \r\n    * 搭建远程仓库(私服)后，jar包的查找顺序\r\n      * 本地仓库→远程仓库→中央仓库\r\n\r\n\r\n![](./images/JavaWeb学习笔记/2022-11-16-00-32-01.png)\r\n\r\n**安装配置**\r\n![](./images/JavaWeb学习笔记/2022-11-16-02-06-18.png)\r\n\r\n\r\n**配置本地仓库所在路径**`apache-maven-3.6.3\\conf\\settings.xml`\r\n```xml\r\n<localRepository>D:\\Program Files\\maven\\repository</localRepository>\r\n```\r\n\r\n**配置镜像**`apache-maven-3.6.3\\conf\\settings.xml`\r\n```xml\r\n  <mirrors>\r\n     <mirror>\r\n      <id>aliyunmaven</id>\r\n      <mirrorOf>*</mirrorOf>\r\n      <name>阿里云公共仓库</name>\r\n      <url>https://maven.aliyun.com/repository/public</url>\r\n    </mirror>\r\n  </mirrors>\r\n```\r\n\r\n**坐标**\r\n* Maven 中的坐标是资源的唯一标识\r\n* 使用坐标来定义项目或引入项目中需要的依赖\r\n* Maven 坐标主要组成\r\n  * `groupld`: 定义当前Maven项目隶属组织名称（通常是域名反写，例如: com.itheima)\r\n  * `artifactld`: 定义当前Maven项目名称(通常是模块名称，例如order-service、goods-service)\r\n  * `version`: 定义当前项目版本号\r\n\r\n**定义项目**\r\n![](./images/JavaWeb学习笔记/2022-11-16-22-32-44.png)\r\n\r\n**定义引入项目中需要的依赖项目**\r\n![](./images/JavaWeb学习笔记/2022-11-16-22-33-02.png)\r\n\r\n**常用命令**\r\n```bash\r\n# Maven常用命令\r\ncd project_root\r\nmvn compile # 编译\r\nmvn clean # 清理\r\nmvn test # 测试\r\nmvn package # 打包\r\nmvn install # 安装\r\n```\r\n\r\n**生命周期**\r\n![](./images/JavaWeb学习笔记/2022-11-16-21-57-43.png)\r\n![](./images/JavaWeb学习笔记/2022-11-16-21-58-56.png)\r\n\r\n**依赖管理**\r\n* `scope`可以设置对应jar包的作用范围\r\n* 作用范围\r\n  * 编译环境\r\n  * 测试环境\r\n  * 运行环境\r\n\r\n```xml\r\n  <dependencies>\r\n    <dependency>\r\n      <groupId>junit</groupId>\r\n      <artifactId>junit</artifactId>\r\n      <version>4.11</version>\r\n      <scope>test</scope> <!-- scope指定依赖的作用范围 -->\r\n    </dependency>\r\n  </dependencies>\r\n```\r\n\r\n![](./images/JavaWeb学习笔记/2022-11-17-08-31-04.png)\r\n\r\n## myBatis\r\n* MyBatis是一款优秀的`持久层`**框架**，用于简化`JDBC`开发\r\n* MyBatis 本是 Apache的一个开源项目`iBatis`, 2010年这个项目由apache software foundation迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github\r\n* 官网: https://mybatis.org/mybatis-3/zh/index.html\r\n\r\n**持久层**\r\n* 负责将数据到保存到数据库的那一层代码\r\n* JavaEE三层架构:\r\n  * 表现层 页面展示\r\n  * 业务层 逻辑处理\r\n  * 持久层\r\n\r\n**JDBC缺点**\r\n![](./images/JavaWeb学习笔记/2022-11-17-09-25-52.png)\r\n\r\n**maBatis对JDBC的简化**\r\n![](./images/JavaWeb学习笔记/2022-11-17-09-32-01.png)\r\n\r\n**简单示例：基本步骤**\r\n![](./images/JavaWeb学习笔记/2022-11-26-20-50-57.png)\r\n\r\n### myBatis简单示例\r\n#### 使用示例1:myBatis简单示例\r\n\r\n**准备数据**\r\n```sql\r\nuse db5;\r\ncreate table tb_user(\r\n    id int primary key auto_increment,\r\n    name varchar(20),\r\n    password varchar(20),\r\n    gender char(1),\r\n    addr varchar(30)\r\n);\r\ninsert into \r\ntb_user(id,name,password,gender,addr) \r\nvalues\r\n    (1,\"张三\",\"123\",\"男\",\"北京\"),\r\n    (2,\"李四\",\"123\",\"男\",\"北京\"),\r\n    (3,\"王五\",\"123\",\"男\",\"北京\")\r\n;\r\n```\r\n\r\n**编辑maven项目配置文件`pom.xml`,配置相关依赖**\r\n```xml\r\n    <dependency>\r\n      <!-- mybatis -->\r\n      <groupId>org.mybatis</groupId>\r\n      <artifactId>mybatis</artifactId>\r\n      <version>3.5.5</version>\r\n    </dependency>\r\n    <dependency>\r\n      <!-- mysql的JDBC驱动 -->\r\n      <groupId>mysql</groupId>\r\n      <artifactId>mysql-connector-java</artifactId>\r\n      <version>5.1.46</version>\r\n    </dependency>\r\n```\r\n**编辑mybatis配置文件 `src/main/resources/mybatis-config.xml`**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n  <environments default=\"development\">\r\n    <environment id=\"development\">\r\n      <transactionManager type=\"JDBC\"/>\r\n      <dataSource type=\"POOLED\">\r\n        <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/> <!-- 填mysql的驱动的路径 -->\r\n        <property name=\"url\" value=\"jdbc:mysql:///db5?useSSL=false\"/>  <!-- 填mysql数据库的路径 -->\r\n        <property name=\"username\" value=\"root\"/>  <!-- 填数据库的username -->\r\n        <property name=\"password\" value=\"root\"/>   <!-- 填数据库的password -->\r\n      </dataSource>\r\n    </environment>\r\n  </environments>\r\n  <mappers>\r\n    <mapper resource=\"./UserMapper.xml\"/>  <!-- 填sql语句的映射文件路径 -->\r\n  </mappers>\r\n</configuration>\r\n```\r\n\r\n**编辑sql语句映射文件`src/main/resources/UserMapper.xml`**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"namespaceTest1\"> <!-- 在程序中需要通过 `命名空间.sql语句id` 执行该命令  -->\r\n   <select id=\"selectAllUsers\" resultType=\"com.example.pojo.User\"> <!-- resultType是User类的类型  -->\r\n      select * from tb_user\r\n   </select>\r\n</mapper>\r\n```\r\n\r\n**定义User类`src/main/java/com/example/pojo/User.java`**\r\n```java\r\npackage com.example.pojo;\r\n\r\npublic class User {\r\n    private Integer id;\r\n    private String name;\r\n    private String password;\r\n    private String gender;\r\n    private String addr;\r\n    \r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n    public String getName() {\r\n        return name;\r\n    }\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    public String getPassword() {\r\n        return password;\r\n    }\r\n    public void setPassword(String password) {\r\n        this.password = password;\r\n    }\r\n    public String getGender() {\r\n        return gender;\r\n    }\r\n    public void setGender(String gender) {\r\n        this.gender = gender;\r\n    }\r\n    public String getAddr() {\r\n        return addr;\r\n    }\r\n    public void setAddr(String addr) {\r\n        this.addr = addr;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"User [id=\" + id + \", name=\" + name + \", password=\" + password + \", gender=\" + gender + \", addr=\" + addr\r\n                + \"]\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n**执行sql语句**\r\n`src/main/java/com/example/testSelectAll.java`\r\n```java\r\npackage com.example;\r\n\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\n\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n\r\nimport com.example.pojo.User;\r\n\r\npublic class testSelectAll {\r\n    public static void main(String[] args) throws Exception{\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession();\r\n         \r\n        //通过 `命名空间.sql语句ID` 执行sql语句，结果会自动封装到`List<User>`中\r\n        List<User> users = session.selectList(\"namespaceTest1.selectAllUsers\"); // 这里依然存在把字符串写到程序中的硬编码问题，需要后续进一步解决\r\n\r\n        System.out.println(users);\r\n\r\n        // 释放资源\r\n        session.close();\r\n    }\r\n}\r\n```\r\n输出：\r\n![](./images/JavaWeb学习笔记/2022-11-17-19-33-28.png)\r\n\r\n#### 使用示例2:使用Mapper代理方式\r\n**目的**：解决前一种方法中存在的硬编码问题\r\n![](./images/JavaWeb学习笔记/2022-11-26-21-45-33.png)\r\n\r\n配置过程\r\n![](./images/JavaWeb学习笔记/2022-11-17-19-24-17.png)\r\n\r\n\r\n\r\n0.修改配置\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n  <environments default=\"development\">\r\n    <environment id=\"development\">\r\n      <transactionManager type=\"JDBC\"/>\r\n      <dataSource type=\"POOLED\">\r\n        <!-- \r\n            use db5;\r\n            create table tb_user(\r\n                id int primary key auto_increment,\r\n                name varchar(20),\r\n                password varchar(20),\r\n                gender char(1),\r\n                addr varchar(30)\r\n            );\r\n            insert into \r\n            tb_user(id,name,password,gender,addr) \r\n            values\r\n                (1,\"张三\",\"123\",\"男\",\"北京\"),\r\n                (2,\"李四\",\"123\",\"男\",\"北京\"),\r\n                (3,\"王五\",\"123\",\"男\",\"北京\")\r\n            ;\r\n         -->\r\n        <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/> <!-- 填mysql的驱动的路径 -->\r\n        <property name=\"url\" value=\"jdbc:mysql:///db5?useSSL=false\"/>  <!-- 填mysql数据库的路径 -->\r\n        <property name=\"username\" value=\"root\"/>  <!-- 填数据库的username -->\r\n        <property name=\"password\" value=\"root\"/>   <!-- 填数据库的password -->\r\n      </dataSource>\r\n    </environment>\r\n  </environments>\r\n  <mappers>\r\n    <!-- <mapper resource=\"com/example/mapper/UserMapper.xml\"/>   --> <!-- 填sql语句的映射文件路径 -->\r\n    <package name=\"com.example.mapper\" /> <!-- 使用这种Mapper代理的方式便可以用这种包扫描的写法 -->\r\n  </mappers>\r\n</configuration>\r\n```\r\n\r\n1.定义接口：`src/main/java/com/example/mapper/UserMapper.java`\r\n* 注意存放路径\r\n* 注意接口的函数名、形参列表、返回值都和`UserMapper.xml`中的sql语句有关\r\n\r\n```java\r\npackage com.example.mapper;\r\n\r\nimport java.util.List;\r\n\r\nimport com.example.pojo.User;\r\n\r\npublic interface UserMapper {\r\n    List<User> selectAll(); // 函数名要和UserMapper.xml中的id名一致\r\n}\r\n```\r\n\r\n2.修改：`src/resources/com/example/mapper/UserMapper.xml`\r\n* 注意存放路径，`UserMapper.xml`原本应当存放在和`UserMapper.java`相同的位置，但xml文件应当统一放在resources目录下，且resources目录下的文件打包后将会放到项目根目录，所以存放在`/resources/com/example/mapper/`目录下，打包后也会存放在`UserMapper.java`所在目录\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.example.mapper.UserMapper\">  <!-- namespace改为接口类 -->\r\n  <select id=\"selectAll\" resultType=\"com.example.pojo.User\">   <!-- id为接口的函数名 -->\r\n    select * from tb_user\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n\r\n3.获取UserMapper接口的代理对象\r\n* `session.getMapper(UserMapper.class)`的作用就是实现一个接口代理然后提供代理。\r\n  \r\n```java\r\npackage com.example;\r\n\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\n\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n\r\nimport com.example.mapper.UserMapper;\r\nimport com.example.pojo.User;\r\n\r\npublic class testSelectAll {\r\n    public static void main(String[] args) throws Exception{\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession();\r\n        // 方法一：通过 `命名空间.sql语句ID` 执行sql\r\n        // List<User> users = session.selectList(\"namespaceTest1.selectAllUsers\");\r\n\r\n        // 方法二：通过mapper\r\n        // 获取UserMapper接口的代理对象\r\n        UserMapper userMapper = session.getMapper(UserMapper.class);\r\n        List<User> users = userMapper.selectAll();\r\n\r\n        System.out.println(users);\r\n    }\r\n}\r\n```\r\n输出：\r\n\r\n![](./images/JavaWeb学习笔记/2022-11-17-19-33-14.png)\r\n\r\n\r\n\r\n\r\n### 核心配置文件\r\n\r\n[文档:https://mybatis.net.cn/](https://mybatis.net.cn/)\r\n![](./images/JavaWeb学习笔记/2022-11-27-20-50-29.png)\r\n\r\n\r\n**包别名**\r\n* 当这样配置时， `Blog` 可以用在任何使用 全限名 `domain.blog.Blog` 的地方。\r\n```xml\r\n<typeAliases>\r\n  <typeAlias alias=\"Author\" type=\"domain.blog.Author\"/>  <!-- 单独配置 -->\r\n  <package name=\"domain.blog\"/> <!-- 包扫描方式配置 -->\r\n</typeAliases>\r\n```\r\n\r\n\r\n### 查询数据\r\n\r\n#### 多查询selectAll\r\n\r\n**数据准备**\r\n```sql\r\ndrop database if exists db5;\r\ncreate database db5;\r\nuse db5;\r\ncreate table tb_brand(\r\n   -- id\r\n   id int primary key auto_increment,\r\n   -- 品牌名\r\n   brand_name varchar(20),\r\n   -- 公司名\r\n   company_name varchar(20),\r\n   -- 排序优先级\r\n   ordered int,\r\n   -- 描述\r\n   description varchar(100),\r\n   -- 状态：1 启用 0 禁用\r\n   status int\r\n);\r\ninsert into \r\n    tb_brand(brand_name,company_name,ordered,description,status) \r\n    values\r\n        (\"三只松鼠\",\"三只松鼠股份有限公司\",5,'好吃不上火',0),\r\n        (\"华为\",\"华为技术有限公司\",1,'华为致力于把数字技术带入每个人、每个家庭、每个组织，构建万物互联的智能世界',1),\r\n        (\"小米\",\"小米科技有限公司\",4,'Are you ok?',1);\r\n\r\nSELECT * from tb_brand;\r\n```\r\n\r\n**mybatis配置文件修改**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n  <environments default=\"development\">\r\n    <environment id=\"development\">\r\n      <transactionManager type=\"JDBC\"/>\r\n      <dataSource type=\"POOLED\">\r\n        <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/> <!-- 填mysql的驱动的路径 -->\r\n        <property name=\"url\" value=\"jdbc:mysql:///db5?useSSL=false\"/>  <!-- 填mysql数据库的路径 -->\r\n        <property name=\"username\" value=\"root\"/>  <!-- 填数据库的username -->\r\n        <property name=\"password\" value=\"root\"/>   <!-- 填数据库的password -->\r\n      </dataSource>\r\n    </environment>\r\n  </environments>\r\n  <mappers>\r\n    <package name=\"com.example.mapper\" /> <!-- 包扫描方式 -->\r\n  </mappers>\r\n</configuration>\r\n```\r\n\r\n**编写`pojo.Brand`类**\r\n```java\r\npackage com.example.pojo;\r\n\r\npublic class Brand {\r\n    Integer id;             // -- id\r\n    String brandName;      // -- 品牌名\r\n    String companyName;    // -- 公司名\r\n    Integer ordered;        // -- 排序优先级\r\n    String description;     // -- 描述\r\n    Integer status;         // -- 状态：1 启用 0 禁用\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n    public String getBrandName() {\r\n        return brandName;\r\n    }\r\n    public void setBrandName(String brandName) {\r\n        this.brandName = brandName;\r\n    }\r\n    public String getCompanyName() {\r\n        return companyName;\r\n    }\r\n    public void setCompanyName(String companyName) {\r\n        this.companyName = companyName;\r\n    }\r\n    public Integer getOrdered() {\r\n        return ordered;\r\n    }\r\n    public void setOrdered(Integer ordered) {\r\n        this.ordered = ordered;\r\n    }\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n    public void setDescription(String description) {\r\n        this.description = description;\r\n    }\r\n    public Integer getStatus() {\r\n        return status;\r\n    }\r\n    public void setStatus(Integer status) {\r\n        this.status = status;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Brand [id=\" + id + \", brandName=\" + brandName + \", companyName=\" + companyName + \", ordered=\" + ordered\r\n                + \", description=\" + description + \", status=\" + status + \"]\";\r\n    }\r\n}\r\n```\r\n\r\n**编写`BrandMapper.java`接口类**\r\n```java\r\npackage com.example.mapper;\r\n\r\nimport java.util.List;\r\n\r\nimport com.example.pojo.Brand;\r\n\r\npublic interface BrandMapper {\r\n    List<Brand> selectAll();\r\n}\r\n```\r\n\r\n**编写`BrandMapper.xml`**\r\n* 方法一：原始写法，由于数据库中字段名称为 `brand_name` 类中相应字段名称为 `brandName` 两者不一致，在封装数据阶段会出现问题。\r\n  ```xml\r\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n  <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n  <mapper namespace=\"com.example.mapper.BrandMapper\">\r\n    <!-- selectAll --> \r\n    <select id=\"selectAll\" resultType=\"com.example.pojo.Brand\">\r\n      select * from tb_brand;\r\n    </select>\r\n  </mapper>\r\n  ```\r\n* 方法二：修改sql语句，修改字段别名使其与类中字段名称一致\r\n  ```xml\r\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n  <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n  <mapper namespace=\"com.example.mapper.BrandMapper\">\r\n    <!-- selectAll --> \r\n    <select id=\"selectAll\" resultType=\"com.example.pojo.Brand\">\r\n      select \r\n         id,\r\n         brand_name as brandName,\r\n         company_name as companyName,\r\n         ordered,\r\n         description,\r\n         status,\r\n      from tb_brand;\r\n    </select>\r\n  </mapper>\r\n  ```\r\n* 方法三：定义sql片段\r\n  ```xml\r\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n  <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n  <mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <sql id=\"brand_colums\">  <!-- 定义sql片段 --> \r\n         id,\r\n         brand_name as brandName,\r\n         company_name as companyName,\r\n         ordered,\r\n         description,\r\n         status,\r\n  </sql>\r\n    <select id=\"selectAll\" resultType=\"com.example.pojo.Brand\">\r\n      select \r\n         <include refid=\"brand_colums\" /> <!-- 引用sql片段 --> \r\n      from tb_brand;\r\n    </select>\r\n  </mapper>\r\n  ```\r\n* 方法四：使用resultMap\r\n  ```xml\r\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n  <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n  <mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <resultMap id=\"brand_resultMap\" type=\"com.example.pojo.Brand\">  <!-- 定义resultMap --> \r\n         <result column=\"brand_name\" property=\"brandName\" />\r\n         <result column=\"company_name\" property=\"companyName\" />\r\n  </sql>\r\n    <select id=\"selectAll\" resultMap=\"brand_resultMap\"> <!-- resultMap = brand_resultMap --> \r\n      select * from tb_brand;\r\n    </select>\r\n  </mapper>\r\n  ```\r\n\r\n\r\n**编写`testBrand.java`测试类**\r\n```java\r\npackage com.example;\r\n\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\n\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport org.junit.Test;\r\n\r\nimport com.example.mapper.BrandMapper;\r\nimport com.example.pojo.Brand;\r\n\r\npublic class testBrand {\r\n    @Test\r\n    public void testSelectAllBrand() throws Exception{\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession();\r\n        // 方法一：通过 `命名空间.sql语句ID` 执行sql\r\n        // List<User> users = session.selectList(\"namespaceTest1.selectAllUsers\");\r\n\r\n        // 方法二：通过mapper\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n        List<Brand> brands = brandMapper.selectAll();\r\n\r\n        System.out.println(brands);\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### 单查询selectById\r\n\r\n修改`BrandMapper.xml`\r\n\r\n**注意点**\r\n* sql语句`参数占位符`\r\n  * `#{}`占位符 等效于 `?` 也是就是`jdbc`里的`PreparedStatement`,有防sql注入的作用\r\n  * `${}`占位符 1以字符串方式拼接字符串，`存在sql注入问题`\r\n    * 可用于动态确定列名或表名\r\n      * `select ${columName1}`\r\n      * `from ${tableName}`\r\n* 返回值\r\n  * `parameterType=\"int\"` 可省略\r\n* **特殊字符的处理**：在xml中编写sql语句的`<`等的特殊字符\r\n  * `转义字符` `<` => `&lt;`\r\n  * `CDATA区` `<![CDATA[ 这里可以填特殊字符 ]]>`\r\n\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <resultMap id=\"BrandColumMapper\" type=\"com.example.pojo.Brand\">\r\n    <result column=\"brand_name\" property=\"brandName\" />\r\n    <result column=\"company_name\" property=\"companyName\" />\r\n  </resultMap>\r\n  <!-- selectAll --> \r\n  <select id=\"selectAll\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand;\r\n  </select>\r\n\r\n  <!-- selectById --> \r\n  <select id=\"selectById\" parameterType=\"int\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand where id=#{id};\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n修改`BrandMapper.java`\r\n```java\r\npackage com.example.mapper;\r\n\r\nimport java.util.List;\r\n\r\nimport com.example.pojo.Brand;\r\n\r\npublic interface BrandMapper {\r\n    List<Brand> selectAll();\r\n    Brand selectById(int id);\r\n}\r\n```\r\n\r\n**编写测试类**\r\n```java\r\npackage com.example;\r\n\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\n\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport org.junit.Test;\r\n\r\nimport com.example.mapper.BrandMapper;\r\nimport com.example.pojo.Brand;\r\n\r\npublic class testBrand {\r\n\r\n    @Test\r\n    public void testSelectBrandById() throws Exception{\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession();\r\n        // 方法一：通过 `命名空间.sql语句ID` 执行sql\r\n        // List<User> users = session.selectList(\"namespaceTest1.selectAllUsers\");\r\n\r\n        // 方法二：通过mapper\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n        Brand brands = brandMapper.selectById(1);\r\n\r\n        System.out.println(brands);\r\n    }\r\n}\r\n```\r\n输出结果\r\n```\r\nBrand [id=1, brandName=三只松鼠, companyName=三只松鼠股份有限公司, ordered=5, description=好吃不上火, status=0]\r\n```\r\n\r\n#### 多条件查询：散装参数\r\n**多条件查询参数的接收**\r\n1. `散装参数` 要使用注解`@Param(\"字段名\")`和sql的`${字段名}`要一致\r\n2. `对象参数` 要保证`对象属性名`和sql的`${}`要一致\r\n3. `map集合参数` 要保证`map键`和sql的`${}`要一致\r\n\r\n`BrandMapper.xml`核心代码\r\n```xml\r\n<mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <resultMap id=\"BrandColumMapper\" type=\"com.example.pojo.Brand\">\r\n    <result column=\"brand_name\" property=\"brandName\" />\r\n    <result column=\"company_name\" property=\"companyName\" />\r\n  </resultMap>\r\n  <select id=\"selectByCondition\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand\r\n    where status = #{status}\r\n      and company_name like #{companyName} <!-- 此处的companyName的命名规则最好是和对象的属性名保持一致，以避免后续产生的问题 --> \r\n      and brand_name like #{brandName}\r\n      ;\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n`BrandMapper.java`核心代码\r\n```java\r\npackage com.example.mapper;\r\n\r\nimport java.util.List;\r\n\r\nimport org.apache.ibatis.annotations.Param;\r\n\r\nimport com.example.pojo.Brand;\r\n\r\npublic interface BrandMapper {\r\n    List<Brand> selectAll();\r\n    Brand selectById(int id);\r\n    \r\n    List<Brand> selectByCondition(\r\n        @Param(\"status\")        int     status,\r\n        @Param(\"companyName\")   String  companyName,\r\n        @Param(\"brandName\")     String  brandName\r\n    );\r\n}\r\n```\r\n\r\n`testBrand.java`测试代码\r\n```java\r\n@Test\r\npublic void testSelectByCondition() throws Exception{\r\n    // 模拟获取到查询数据\r\n    int status = 1;\r\n    String companyName = \"华为\";\r\n    String brandName = \"华为\";\r\n\r\n    // 对数据处理\r\n    companyName = \"%\"+companyName+\"%\";\r\n    brandName = \"%\"+brandName+\"%\";\r\n\r\n\r\n    // 加载mybatis核心配置文件\r\n    String resource = \"mybatis-config.xml\";\r\n    InputStream inputStream = Resources.getResourceAsStream(resource);\r\n    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n    // 获取SqlSession，用其来执行sql语句\r\n    SqlSession session = sqlSessionFactory.openSession();\r\n\r\n    // 获取UserMapper接口的代理对象\r\n    BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n    List<Brand> brands = brandMapper.selectByCondition(status,companyName,brandName);\r\n\r\n    System.out.println(brands);\r\n}\r\n```\r\n\r\n#### 多条件查询：对象参数\r\n`BrandMapper.xml`核心代码\r\n```xml\r\n<mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <resultMap id=\"BrandColumMapper\" type=\"com.example.pojo.Brand\">\r\n    <result column=\"brand_name\" property=\"brandName\" />\r\n    <result column=\"company_name\" property=\"companyName\" />\r\n  </resultMap>\r\n  <select id=\"selectByCondition\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand\r\n    where status = #{status}\r\n      and company_name like #{companyName} <!-- 此处的companyName的命名规则最好是和对象的属性名保持一致，以避免后续产生的问题 --> \r\n      and brand_name like #{brandName}\r\n      ;\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n`BrandMapper.java`核心代码\r\n```java\r\npackage com.example.mapper;\r\n\r\nimport java.util.List;\r\n\r\nimport org.apache.ibatis.annotations.Param;\r\n\r\nimport com.example.pojo.Brand;\r\n\r\npublic interface BrandMapper {\r\n    List<Brand> selectAll();\r\n    Brand selectById(int id);\r\n    \r\n    List<Brand> selectByCondition(\r\n        @Param(\"status\")        int     status,\r\n        @Param(\"companyName\")   String  companyName,\r\n        @Param(\"brandName\")     String  brandName\r\n    );\r\n\r\n//-----------------------------------------------------------------------------\r\n    List<Brand> selectByCondition(Brand brand);\r\n//-----------------------------------------------------------------------------\r\n\r\n}\r\n```\r\n\r\n`testBrand.java`测试代码\r\n```java\r\n    @Test\r\n    public void testSelectByCondition() throws Exception{\r\n        // 模拟获取到查询数据\r\n        int status = 1;\r\n        String companyName = \"华为\";\r\n        String brandName = \"华为\";\r\n\r\n        // 对数据处理\r\n        companyName = \"%\"+companyName+\"%\";\r\n        brandName = \"%\"+brandName+\"%\";\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n        Brand searchBrand = new Brand();\r\n        searchBrand.setStatus(status);\r\n        searchBrand.setCompanyName(companyName);\r\n        searchBrand.setBrandName(brandName);\r\n//-----------------------------------------------------------------------------\r\n\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession();\r\n\r\n//-----------------------------------------------------------------------------\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n        List<Brand> brands = brandMapper.selectByCondition(searchBrand);\r\n//-----------------------------------------------------------------------------\r\n\r\n        System.out.println(brands);\r\n    }\r\n```\r\n#### 多条件查询：集合参数\r\n\r\n\r\n\r\n\r\n`testBrand.java`测试代码\r\n```java\r\n    @Test\r\n    public void testSelectByCondition() throws Exception{\r\n        // 模拟获取到查询数据\r\n        int status = 1;\r\n        String companyName = \"华为\";\r\n        String brandName = \"华为\";\r\n\r\n        // 对数据处理\r\n        companyName = \"%\"+companyName+\"%\";\r\n        brandName = \"%\"+brandName+\"%\";\r\n\r\n        Map<String,Object> searchBrand = new HashMap<>();\r\n        searchBrand.put(\"status\",status);\r\n        searchBrand.put(\"companyName\",companyName);\r\n        searchBrand.put(\"brandName\",brandName);\r\n\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession();\r\n\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n        List<Brand> brands = brandMapper.selectByCondition(searchBrand);\r\n\r\n        System.out.println(brands);\r\n    }\r\n```\r\n\r\n\r\n#### 多条件-动态条件查询`where标签或1=1恒等式`\r\n* if 条件判断：用于判断传入的参数是否有值\r\n  * test 逻辑表达式\r\n* 存在问题：`status==null`时，第二个`if`中的`and`将导致`sql语法错误`\r\n  * **`1=1`恒等式**解决\r\n  * `where`标签解决\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <resultMap id=\"BrandColumMapper\" type=\"com.example.pojo.Brand\">\r\n    <result column=\"brand_name\" property=\"brandName\" />\r\n    <result column=\"company_name\" property=\"companyName\" />\r\n  </resultMap>\r\n  <!-- selectAll --> \r\n  <select id=\"selectAll\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand;\r\n  </select>\r\n\r\n  <!-- selectById --> \r\n  <select id=\"selectById\" parameterType=\"int\" resultMap=\"BrandColumMapper\">\r\n    <![CDATA[ \r\n      select * from tb_brand where id=#{id};\r\n    ]]>\r\n  </select>\r\n  <!-- selectByCondition -->\r\n  <select id=\"selectByCondition\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand\r\n    where\r\n    <if test=\"status!=null\">\r\n      status = #{status}\r\n    </if> \r\n    <if test=\" company_name!=null and company_name!='' \">\r\n    and company_name like #{companyName} <!-- 此处的companyName的命名规则最好是和对象的属性名保持一致，以避免后续产生的问题 --> \r\n    </if> \r\n    <if test=\" brand_name!=null and brand_name!='' \">\r\n      and brand_name like #{brandName}\r\n    </if> \r\n      ;\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n**`1=1`恒等式解决问题**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <resultMap id=\"BrandColumMapper\" type=\"com.example.pojo.Brand\">\r\n    <result column=\"brand_name\" property=\"brandName\" />\r\n    <result column=\"company_name\" property=\"companyName\" />\r\n  </resultMap>\r\n  <!-- selectAll --> \r\n  <select id=\"selectAll\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand;\r\n  </select>\r\n\r\n  <!-- selectById --> \r\n  <select id=\"selectById\" parameterType=\"int\" resultMap=\"BrandColumMapper\">\r\n    <![CDATA[ \r\n      select * from tb_brand where id=#{id};\r\n    ]]>\r\n  </select>\r\n  <!-- selectByCondition -->\r\n  <select id=\"selectByCondition\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand\r\n    where\r\n    1=1\r\n    <if test=\"status!=null\">\r\n      and status = #{status}\r\n    </if> \r\n    <if test=\" company_name!=null and company_name!='' \">\r\n    and company_name like #{companyName} <!-- 此处的companyName的命名规则最好是和对象的属性名保持一致，以避免后续产生的问题 --> \r\n    </if> \r\n    <if test=\" brand_name!=null and brand_name!='' \">\r\n      and brand_name like #{brandName}\r\n    </if> \r\n      ;\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n**`1=1`恒等式解决问题**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <resultMap id=\"BrandColumMapper\" type=\"com.example.pojo.Brand\">\r\n    <result column=\"brand_name\" property=\"brandName\" />\r\n    <result column=\"company_name\" property=\"companyName\" />\r\n  </resultMap>\r\n  <!-- selectAll --> \r\n  <select id=\"selectAll\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand;\r\n  </select>\r\n\r\n  <!-- selectById --> \r\n  <select id=\"selectById\" parameterType=\"int\" resultMap=\"BrandColumMapper\">\r\n    <![CDATA[ \r\n      select * from tb_brand where id=#{id};\r\n    ]]>\r\n  </select>\r\n  <!-- selectByCondition -->\r\n  <select id=\"selectByCondition\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand\r\n    where\r\n    1=1\r\n    <if test=\"status!=null\">\r\n      and status = #{status}\r\n    </if> \r\n    <if test=\" company_name!=null and company_name!='' \">\r\n    and company_name like #{companyName} <!-- 此处的companyName的命名规则最好是和对象的属性名保持一致，以避免后续产生的问题 --> \r\n    </if> \r\n    <if test=\" brand_name!=null and brand_name!='' \">\r\n      and brand_name like #{brandName}\r\n    </if> \r\n      ;\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n\r\n**`where`标签解决**\r\nwhere标签能自动去掉多余的and or \r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <resultMap id=\"BrandColumMapper\" type=\"com.example.pojo.Brand\">\r\n    <result column=\"brand_name\" property=\"brandName\" />\r\n    <result column=\"company_name\" property=\"companyName\" />\r\n  </resultMap>\r\n  <!-- selectAll -->\r\n  <select id=\"selectAll\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand;\r\n  </select>\r\n\r\n  <!-- selectById -->\r\n  <select id=\"selectById\" parameterType=\"int\" resultMap=\"BrandColumMapper\">\r\n    <![CDATA[ \r\n      select * from tb_brand where id=#{id};\r\n    ]]>\r\n  </select>\r\n  <select id=\"selectByCondition\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand\r\n    <where> <!-- where标签会帮你自动去掉多余的and or 如果没有任何条件会去掉自身 -->\r\n      <if test=\"status!=null\">\r\n        and status = #{status}\r\n      </if>\r\n      <if test=\" company_name!=null and company_name!='' \">\r\n        and company_name like #{companyName} <!-- 此处的companyName的命名规则最好是和对象的属性名保持一致，以避免后续产生的问题 -->\r\n      </if>\r\n      <if test=\" brand_name!=null and brand_name!='' \">\r\n        and brand_name like #{brandName}\r\n      </if>\r\n    </where>\r\n      ;\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n#### 单条件-动态条件查询`:when:choose:otherwise`\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.example.mapper.BrandMapper\">\r\n  <resultMap id=\"BrandColumMapper\" type=\"com.example.pojo.Brand\">\r\n    <result column=\"brand_name\" property=\"brandName\" />\r\n    <result column=\"company_name\" property=\"companyName\" />\r\n  </resultMap>\r\n\r\n  <select id=\"selectBySingleCondition\" resultMap=\"BrandColumMapper\">\r\n    select * from tb_brand\r\n      <where> <!-- where标签会帮你自动去掉多余的and or 如果没有任何条件会去掉自身 -->\r\n      <choose>\r\n        <when test=\"status!=null\">\r\n        status = #{status}\r\n      </when>\r\n        <when test=\"companyName!=null and companyName!=''\">\r\n          company_name like #{companyName}\r\n          <!-- 此处的companyName的命名规则最好是和对象的属性名保持一致，以避免后续产生的问题 -->\r\n        </when>\r\n        <when test=\" brandName!=null and brandName!='' \">\r\n          brand_name like #{brandName}\r\n        </when>\r\n        <otherwise>\r\n          1=1\r\n        </otherwise>\r\n      </choose>\r\n    </where>\r\n    ;\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n`BrandMapper.java`\r\n```java\r\npackage com.example.mapper;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport org.apache.ibatis.annotations.Param;\r\n\r\nimport com.example.pojo.Brand;\r\n\r\npublic interface BrandMapper {\r\n    List<Brand> selectAll();\r\n\r\n    Brand selectById(int id);\r\n    \r\n    List<Brand> selectByCondition(\r\n        @Param(\"status\")        int     status,\r\n        @Param(\"companyName\")   String  companyName,\r\n        @Param(\"brandName\")     String  brandName\r\n    );\r\n\r\n    List<Brand> selectByCondition(Brand brand);\r\n\r\n    List<Brand> selectByCondition(Map<String,Object> brand);\r\n//-------------------------------------------------------------\r\n    List<Brand> selectBySingleCondition(Map<String,Object> brand);\r\n//-------------------------------------------------------------\r\n}\r\n```\r\n\r\n**测试**\r\n```java\r\npackage com.example;\r\n\r\nimport java.io.InputStream;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport org.junit.Test;\r\n\r\nimport com.example.mapper.BrandMapper;\r\nimport com.example.pojo.Brand;\r\n\r\npublic class testBrand {\r\n    @Test\r\n    public void testSelectByCondition() throws Exception{\r\n        // 模拟获取到查询数据\r\n        int status = 1;\r\n        String companyName = \"华为\";\r\n        String brandName = \"华为\";\r\n\r\n        // 对数据处理\r\n        companyName = \"%\"+companyName+\"%\";\r\n        brandName = \"%\"+brandName+\"%\";\r\n\r\n        Map<String,Object> searchBrand = new HashMap<>();\r\n        // searchBrand.put(\"status\",status);\r\n        searchBrand.put(\"companyName\",companyName);\r\n        // searchBrand.put(\"brandName\",brandName);\r\n\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession();\r\n\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n        List<Brand> brands = brandMapper.selectBySingleCondition(searchBrand);\r\n\r\n        System.out.println(brands);\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 增添数据\r\n\r\n#### 插入单条数据\r\n`BrandMapper.xml`\r\n```xml\r\n  <insert id=\"add\">\r\n    insert into tb_brand(brand_name,company_name,ordered,description,status) \r\n    values(#{brandName},#{companyName},#{ordered},#{description},#{status});\r\n  </insert>\r\n```\r\n\r\n`BrandMapper.java`\r\n```java\r\nvoid add(Brand brand);\r\n```\r\n\r\n**测试类**\r\n```java\r\n    @Test\r\n    public void testAdd() throws Exception {\r\n        // 模拟获取到查询数据\r\n\r\n        // 封装数据\r\n        Brand brand = new Brand();\r\n        brand.setBrandName(\"三星\");\r\n        brand.setCompanyName(\"三星公司\");\r\n        brand.setDescription(\"我们有全世界最好用的电池\");\r\n        brand.setOrdered(5);\r\n        brand.setStatus(1);\r\n\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession(false);// 第一个参数为autoCommit 默认为false 也就是默认开启事务\r\n\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n\r\n        try {\r\n            // jdbc默认为手动提交事务\r\n            brandMapper.add(brand);\r\n            session.commit();//手动提交\r\n            System.out.println(\"添加成功\");\r\n\r\n        } catch (Exception e) {\r\n            session.rollback();//回滚\r\n        }\r\n    }\r\n```\r\n\r\n#### 插入单条数据：返回主键\r\n```xml\r\n  <!-- \r\n      useGeneratedKeys=\"true\"  keyProperty=\"id\" \r\n      useGeneratedKeys 表示返回生成的主键，\r\n      keyProperty 指定要封装到对象的什么字段中\r\n   -->\r\n  <insert id=\"add\" useGeneratedKeys=\"true\"  keyProperty=\"id\">\r\n    insert into tb_brand(brand_name,company_name,ordered,description,status) \r\n    values(#{brandName},#{companyName},#{ordered},#{description},#{status});\r\n  </insert>\r\n```\r\n\r\n```java\r\n@Test\r\n    public void testAdd() throws Exception {\r\n        // 模拟获取到查询数据\r\n\r\n        // 封装数据\r\n        Brand brand = new Brand();\r\n        brand.setBrandName(\"三星\");\r\n        brand.setCompanyName(\"三星公司\");\r\n        brand.setDescription(\"我们有全世界最好用的电池\");\r\n        brand.setOrdered(5);\r\n        brand.setStatus(1);\r\n\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession(false);// 第一个参数为autoCommit 默认为false 也就是默认开启事务\r\n\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n\r\n        try {\r\n            // jdbc默认为手动提交事务\r\n            brandMapper.add(brand);\r\n            session.commit();//手动提交\r\n            System.out.println(brand.getId()); // 输出id\r\n            System.out.println(\"添加成功\");\r\n\r\n        } catch (Exception e) {\r\n            session.rollback();//回滚\r\n        }\r\n    }\r\n```\r\n\r\n### 修改数据\r\n\r\n#### 修改全部字段\r\n\r\n`BrandMapper.xml`\r\n```xml\r\n  <update id=\"update\">\r\n    update \r\n      tb_brand\r\n    set\r\n      brand_name=#{brandName},\r\n      company_name=#{companyName},\r\n      ordered=#{ordered},\r\n      description=#{description},\r\n      status=#{status}\r\n    where\r\n      id = #{id}\r\n    ;\r\n  </update>\r\n```\r\n\r\n`BrandMapper.java`\r\n```java\r\n    int update(Brand brand);// 返回值可为void 也可为int，为int时，返回影响的行数\r\n```\r\n\r\n`测试类`\r\n```java\r\n    @Test\r\n    public void testUpdate() throws Exception {\r\n        // 模拟获取到查询数据\r\n\r\n        // 封装数据\r\n        Brand brand = new Brand();\r\n        brand.setBrandName(\"三星\");\r\n        brand.setCompanyName(\"三星公司\");\r\n        brand.setDescription(\"我们不生产电池，我们只是炸弹的搬运工\");\r\n        brand.setOrdered(5);\r\n        brand.setStatus(1);\r\n        brand.setId(9);\r\n\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession(false);// 第一个参数为autoCommit 默认为false 也就是默认开启事务\r\n\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n\r\n        try {// jdbc默认为手动提交事务\r\n            int affectedRows = brandMapper.update(brand);\r\n            session.commit();//手动提交\r\n            System.out.println(\"更新成功,影响的行数：\"+affectedRows);\r\n\r\n        } catch (Exception e) {\r\n            session.rollback();//回滚\r\n        }\r\n    }\r\n```\r\n\r\n#### 修改任意字段`set:if`\r\n\r\n```xml\r\n  <update id=\"update\">\r\n    update \r\n      tb_brand\r\n    <set>  <!-- 用set标签来避免由if产生的逗号问题 --> \r\n      <if test=\" brandName!=null and brandName!='' \">\r\n        brand_name=#{brandName},\r\n      </if>\r\n      <if test=\" companyName!=null and companyName!='' \">\r\n        company_name=#{companyName},\r\n      </if>\r\n      <if test=\" ordered!=null \">\r\n        ordered=#{ordered},\r\n      </if>\r\n      <if test=\" description!=null and description!='' \">\r\n        description=#{description},\r\n      </if>\r\n      <if test=\" status!=null \">\r\n        status=#{status}\r\n      </if>\r\n    </set>\r\n    where\r\n      id = #{id}\r\n    ;\r\n  </update>\r\n```\r\n\r\n### 删除数据\r\n\r\n#### 删除单个deleteById\r\n```xml\r\n  <!-- deleteById --> \r\n  <delete id=\"deleteById\">\r\n    delete \r\n      from \r\n        tb_brand\r\n      where \r\n        id = #{id}\r\n    ;\r\n  </delete>\r\n```\r\n\r\n```java\r\n    int deleteById(int id);\r\n```\r\n\r\n```java\r\n    @Test\r\n    public void testdeleteById() throws Exception {\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession();\r\n\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n\r\n        int affectedRows = brandMapper.deleteById(9);\r\n        System.out.println(\"删除成功,影响的行数：\"+affectedRows);\r\n\r\n    }\r\n```\r\n\r\n\r\n#### 删除多个`deleteById`:`不使用注解版`\r\n```java\r\n    int deleteByIds(int[] ids);// 删除多个\r\n```\r\n\r\n```xml\r\n  <!-- deleteByIds --> \r\n  <delete id=\"deleteByIds\">\r\n  delete \r\n    from \r\n      tb_brand\r\n    where \r\n      id in \r\n        <foreach collection=\"array\" item=\"id\" separator=\",\" open=\"(\" close=\")\"><!-- mybaties会将数组的参数封装为map集合，其key为array，value为数组 --> \r\n          ${id}\r\n        </foreach>\r\n  ;    \r\n  </delete>\r\n```\r\n\r\n```java\r\n    @Test\r\n    public void testdeleteByIds() throws Exception {\r\n        int[] ids = {1,3,5};\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession(false);// 第一个参数为autoCommit 默认为false 也就是默认开启事务\r\n\r\n        // 获取UserMapper接口的代理对象\r\n        BrandMapper brandMapper = session.getMapper(BrandMapper.class);\r\n\r\n        int affectedRows = brandMapper.deleteByIds(ids);\r\n        System.out.println(\"删除成功,影响的行数：\"+affectedRows);\r\n    }\r\n```\r\n\r\n#### 删除多个`deleteById`:`使用注解版`\r\n\r\n```java\r\n/* \r\n   mybaties会将数组的参数封装为map集合，\r\n      默认其key为array，value为数组\r\n      使用@Param(\"ids\")，可将key改为ids\r\n*/\r\n```\r\n\r\n```java\r\n    int deleteByIds(@Param(\"ids\")  int[] ids);// 删除多个\r\n```\r\n\r\n```xml\r\n  <!-- deleteByIds --> \r\n  <delete id=\"deleteByIds\">\r\n  delete \r\n    from \r\n      tb_brand\r\n    where \r\n      id in \r\n        <foreach collection=\"ids\" item=\"id\" separator=\",\" open=\"(\" close=\")\"><!-- collection指定键名 --> \r\n          ${id}\r\n        </foreach>\r\n  ;    \r\n  </delete>\r\n```\r\n\r\n### myBatis对参数的封装\r\nMyBatis 接口方法中可以接收各种各样的参数，MyBatis底层对于这些参数进行不同的封装处理方式\r\n\r\n**对于单个参数**\r\n* 基本类型：\r\n  * 直接使用，`形参名` 和 `sql参数占位符` 可任意，\r\n* POJO类型：直接使用，`对象的属性名`需和`sql参数占位符`名称 一致\r\n* Map集合：直接使用，`键名`需和`sql参数占位符`名称 一致\r\n* Collection： 内部自动封装为map集合\r\n  * `map.put(\"arg0\",connection)`  使用注解`@Param(\"修改默认的arg键名\")`\r\n  * `map.put(\"connection\",connection)`\r\n* list: 内部自动封装为map集合\r\n  * `map.put(\"arg0\",原lsit集合)` 使用注解`@Param(\"修改默认的arg键名\")`\r\n  * `map.put(\"connection\",原lsit集合)`\r\n  * `map.put(\"list\",原lsit集合)`\r\n* array：内部自动封装为map集合\r\n  * `map.put(\"arg0\",原array数组)` 使用注解`@Param(\"修改默认的arg键名\")`\r\n  * `map.put(\"array\",原array数组)`\r\n**对于多个参数**\r\n* 多个参数会封装为map集合\r\n  * `map.put(\"arg0\",形式参数0)` 使用注解`@Param(\"修改默认的arg键名\")`\r\n  * `map.put(\"param0\",形式参数0)`\r\n  * `map.put(\"arg1\",形式参数1)`\r\n  * `map.put(\"param1\",形式参数1)`\r\n\r\n\r\n**题目**\r\n![](./images/JavaWeb学习笔记/2022-11-28-12-48-27.png)\r\n\r\n```\r\n应该为：\r\nuser.userName\r\nuser.password\r\n```\r\n\r\n### 使用注解完成简单sql操作\r\n```java\r\npackage com.example.mapper;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport org.apache.ibatis.annotations.Param;\r\nimport org.apache.ibatis.annotations.Select;\r\n\r\nimport com.example.pojo.Brand;\r\n\r\npublic interface BrandMapper {\r\n    @Select(\"select *,brand_name as brandName,company_name as companyName from tb_brand;\")\r\n    List<Brand> selectAll();\r\n\r\n    @Select(\"select *,brand_name as brandName,company_name as companyName from tb_brand where id = #{id};\")\r\n    Brand selectById(int id);\r\n}\r\n```\r\n\r\n## Tomcat \r\n* Tomcat 是一个轻量级的Web服务器，\r\n* 支持Servlet/JSP少量JavaEE规范，\r\n* 也称为Web容器，Servlet容器\r\n\r\n**解压后目录结构**\r\n\r\n![](./images/JavaWeb学习笔记/2022-11-28-15-56-00.png)\r\n\r\n**启动与关闭**\r\n![](./images/JavaWeb学习笔记/2022-11-28-15-59-22.png)\r\n\r\n**配置**\r\n![](./images/JavaWeb学习笔记/2022-11-28-18-10-33.png)\r\n\r\n**部署**\r\n![](./images/JavaWeb学习笔记/2022-11-28-18-17-24.png)\r\n\r\n`xml`\r\n```xml\r\n\r\n```\r\n\r\n**javaWeb项目目录结构**\r\n![](./images/JavaWeb学习笔记/2022-11-28-18-22-06.png)\r\n\r\n**在idea中通过本地tomCat启动javaWeb项目**\r\n![](./images/JavaWeb学习笔记/2022-11-28-18-47-30.png)\r\n\r\n**在javaWeb项目中集成tomCat**\r\n![](./images/JavaWeb学习笔记/2022-11-28-18-48-08.png)\r\n```xml\r\n\r\n  <build>\r\n    <finalName>web</finalName>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat7-maven-plugin</artifactId>\r\n        <version>2.2</version>\r\n        <configuration>\r\n          <port>8088</port>\r\n          <path>/</path>\r\n        </configuration>\r\n      </plugin>\r\n      <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat6-maven-plugin</artifactId>\r\n        <version>2.3-SNAPSHOT</version>\r\n      </plugin>\r\n    </plugins>\r\n  </build>\r\n\r\n```\r\n\r\n![](./images/JavaWeb学习笔记/2022-11-28-18-49-56.png)\r\n\r\n## Servlet\r\n* Servlet已经是一个非常非常古老的技术了，\r\n* 而且在实际开发中几乎不会用到，\r\n* 在面试中也几乎不会问到Servlet相关的知识。\r\n* `但Struts2和SpringMVC框架，底层都是跟Servlet有关`\r\n\r\n### 什么是Servlet\r\n> servlet程序是由servlet容器（即tomcat服务器）进行管理的  \r\n> 即：由servlet容器（tomcat）完成servlet的实例化、初始化、服务、销毁\r\n\r\nServlet（Server Applet）是Java Servlet的简称，  \r\n是用Java编写的服务器端程序，  \r\n主要功能在于交互式地浏览和修改数据，生成**动态Web内容**。  \r\n简单来说 `Servlet本质就是处理请求做出响应的实现类`\r\n* 客户端发送请求至Web服务器端。\r\n* 服务器将请求信息发送至Servlet\r\n* Servlet 根据请求内容生成响应内容并将其传给服务器。\r\n* 服务器将响应返回给客户端。\r\n* ![](./images/JavaWeb学习笔记/2022-11-29-22-30-28.png)\r\n\r\n> **服务器的三大组件：**\r\n> * servlet：用于处理请求和响应\r\n> * filter：用于过滤请求和响应\r\n> * listener：用于监听服务器的状态\r\n\r\n### 实现最简Servlet程序\r\n**流程**\r\n* 用`maven`创建`javaWeb`项目，在`pom.xml`配置文件中导入`Servlet`依赖\r\n  ```xml\r\n    <dependencies>\r\n    <dependency>\r\n      <groupId>javax.servlet</groupId>\r\n      <artifactId>javax.servlet-api</artifactId>\r\n      <version>3.1.0</version>\r\n      <scope>provided</scope> <!-- provided表示该依赖仅在编译和测试环境有效，因为该包在其运行环境（tomcat）中有,如果不这么写会导致冲突 -->\r\n    </dependency>\r\n  </dependencies>\r\n  ```\r\n* 编写一个类，实现`HttpServlet`类 或 继承`GenericServlet`类 或 实现`Servlet`接口类\r\n* `重写` 或 `实现` 相应的方法\r\n* 在类上使用注解`@WebServlet(\"/demo1\")`,配置其访问路径\r\n* 访问`http://localhost:8080/demo1`\r\n\r\n**实现Servlet接口版**\r\n```java\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.Servlet;\r\nimport javax.servlet.ServletConfig;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\n@WebServlet(\"/demo1\")\r\npublic class MyServlet implements Servlet {\r\n    @Override\r\n    public void init(ServletConfig arg0) throws ServletException {\r\n        // TODO Auto-generated method stub\r\n    }\r\n    @Override\r\n    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {\r\n        System.out.println(\"收到一个请求\");\r\n    }\r\n    @Override\r\n    public void destroy() {\r\n        // TODO Auto-generated method stub\r\n    }\r\n    // 获取ServletConfig对象\r\n    @Override\r\n    public ServletConfig getServletConfig() {\r\n        // TODO Auto-generated method stub\r\n        return null;\r\n    }\r\n    // 获取Servlet信息\r\n    @Override\r\n    public String getServletInfo() {\r\n        // TODO Auto-generated method stub\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n**继承HttpServlet版**\r\n```java\r\npublic class MyServlet extends HttpServlet {\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"收到一个get请求\");\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"收到一个post请求\");\r\n    }\r\n}\r\n```\r\n\r\n**继承GenericServlet版**\r\n```java\r\npublic class MyServlet extends GenericServlet {\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n### servlet生命周期\r\n![](./images/JavaWeb学习笔记/2022-11-30-17-04-42.png)\r\n```java\r\n@WebServlet(urlPatterens=\"/demo1\",loadOnStartUp=1)\r\npublic class MyServlet implements Servlet {\r\n    /**\r\n     * 调用时机：默认情况下在该servlet被第一次访问时,由容器来调用init()方法，只会被调用一次\r\n     *  * 修改调用时机： loadOnStartUp \r\n     *      * 默认值为-1 表示在该url被访问后再初始化\r\n     *      * 可修改为1 表示在服务器启动后便初始化\r\n     * 调用次数：1次\r\n     */\r\n    @Override \r\n    public void init(ServletConfig arg0) throws ServletException {\r\n        System.out.println(\"url被第一次访问...\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n@WebServlet(urlPatterens=\"/demo1\",loadOnStartUp=1)\r\npublic class MyServlet implements Servlet {\r\n    /**\r\n     * 调用时机：url每次被访问时调用一次\r\n     * 调用次数：每当被访问就调用\r\n     */\r\n    @Override\r\n    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {\r\n        System.out.println(\"收到一个请求\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\n@WebServlet(urlPatterens=\"/demo1\",loadOnStartUp=1)\r\npublic class MyServlet implements Servlet {\r\n    /**\r\n     * 调用时机：Servlet被销毁时（内存释放时，服务进程被正常关闭时），由容器来销毁\r\n     * 调用次数：1次\r\n     */\r\n    @Override\r\n    public void destroy() {\r\n        // TODO Auto-generated method stub\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### HTTPServlet\r\n\r\n**一般直接继承HTTPServlet**\r\n* HttpServlet是指能够处理HTTP协议请求的Servlet，\r\n* 它在原有Servlet接口上添加了一些与HTTP协议处理方法，\r\n* 它比Servlet接口的功能更为强大。\r\n* HttpServlet在实现Servlet接口时，覆写了service方法，\r\n  * 该方法体内的代码会自动判断用户的请求方式，\r\n  * 如为GET请求，则调用HttpServlet的doGet方法，\r\n  * 如为Post请求，则调用doPost方法。\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-01-13-46-59.png)\r\n![](./images/JavaWeb学习笔记/2022-12-01-13-48-03.png)\r\n![](./images/JavaWeb学习笔记/2022-12-01-14-22-54.png)\r\n\r\n\r\n**继承HttpServlet版**\r\n```java\r\n@WebServlet(urlPatterns=\"/api/1\")\r\npublic class MyHttpServlet extends HttpServlet {\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"收到一个get请求\");\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"收到一个post请求\");\r\n    }\r\n}\r\n```\r\n\r\n### urlPattern配置\r\n\r\n**一个urlPattern可以配置多个访问路径配置**\r\n```java\r\n@WebServlet(urlPatterns={\"/api/1\",\"/api/2\"})\r\npublic class MyHttpServlet extends HttpServlet {\r\n}\r\n```\r\n\r\n**urlPattern配置规则**\r\n* 精确匹配\r\n  ```java\r\n  @WebServlet(urlPatterns={\"/api/1\",\"/api/2\"}) // 若一个url同时满足精确匹配和目录匹配，则精确匹配优先级更高\r\n  ```\r\n* 目录匹配\r\n  ```java\r\n  @WebServlet(urlPatterns={\"/api/1/*\",\"/api/2/*\"})\r\n  ```\r\n* 扩展名匹配\r\n  ```java\r\n  @WebServlet(urlPatterns={\"*.do1\",\"*.do2\"}) // 不能写 \"/*.do1\"\r\n  ```\r\n* 任意匹配\r\n  ```java\r\n  @WebServlet(urlPatterns={\"/\",\"/*\"})\r\n  ```\r\n**`/`和`/*`区别:**\r\n* 当项目中的Servlet配置了`/`则会覆盖掉tomcat中DefaultServlet（他会处理项目中静态页面的访问，如index.html），当其他的url-pattern都匹配不上时都会走这个Servlet\r\n* 当项目中配置了`/*`，意味着匹配任意访问路径\r\n\r\n**优先级**\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-01-15-03-09.png)\r\n\r\n\r\n\r\n### xml方式配置Servlet\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-01-15-05-38.png)\r\n\r\n\r\n### Request对象\r\n\r\n#### Request继承体系\r\n![](./images/JavaWeb学习笔记/2022-12-01-15-37-24.png)\r\n\r\n#### Request常用方法\r\n![](./images/JavaWeb学习笔记/2022-12-01-16-03-32.png)\r\n![](./images/JavaWeb学习笔记/2022-12-01-15-56-36.png)\r\n![](./images/JavaWeb学习笔记/2022-12-01-15-58-24.png)\r\n\r\n\r\n#### 通用的获取参数的方法\r\n**由于不同的请求方式（get,post）需要使用不同的方法来获取参数，这造成了一定的不方便**\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-01-16-09-00.png)\r\n\r\n\r\n**`通用的`  获取请求数据的 方式**\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-01-16-25-19.png)\r\n\r\n\r\n**测试代码**\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-01-16-52-38.png)\r\n\r\n```bash\r\n收到一个get请求\r\nuserName:[2449695354@qq.com]\r\npassword:[123123]\r\nreadMe:[true]\r\nautoLogin:[true]\r\nhobby:[1, 2, 3]\r\n```\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n<h2>Hello World!</h2>\r\n<form action=\"/api\" method=\"get\">\r\n    userName:<input type=\"text\" name=\"userName\"><br>\r\n    password:<input type=\"password\" name=\"password\"><br>\r\n    <input type=\"checkbox\" name=\"readMe\" value=\"true\">readMe <br>\r\n    <input type=\"checkbox\" name=\"autoLogin\" value=\"true\">autoLogin <br>\r\n    <input type=\"checkbox\" name=\"hobby\" value=\"1\">熬夜 <br>\r\n    <input type=\"checkbox\" name=\"hobby\" value=\"2\">敲代码 <br>\r\n    <input type=\"checkbox\" name=\"hobby\" value=\"3\">掉头发 <br>\r\n    <input type=\"submit\">\r\n</form>\r\n</body>\r\n</html>\r\n```\r\n```java\r\nimport java.io.IOException;\r\nimport java.util.Arrays;\r\nimport java.util.Map;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(\"/api\")\r\npublic class MyServlet extends HttpServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"收到一个get请求\");\r\n        Map<String,String[]> paramMap = req.getParameterMap();\r\n        for(String key : paramMap.keySet()){\r\n            System.out.println(key+\":\"+Arrays.toString(paramMap.get(key)));\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        // （如果要实现一个接口支持两种请求方式）\r\n        // 由于统一了获取请求参数的格式，故可将post请求转交给doget函数\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### 解决Request输入流中文乱码的问题\r\n\r\n> 注：新版tomcat8.0之后已将get请求乱码问题解决，解码方式为UTF-8\r\n\r\n**POST方式乱码的解决**\r\n\r\n由于POST方式的数据是以原始格式放在请求体中的，到达服务端后，底层是通过getReader()方式获取到的,默认会以`ISO-8859-1`解码，所以可以通过设置获取流的编码方式来解决该问题\r\n```java\r\nreq.setCharacterEncoding(\"UTF-8\");// 设置输入流编码\r\nMap<String,String[]> paramMap = req.getParameterMap(); // 然后就能获得正常的数据了\r\n```\r\n\r\n**GET方式乱码的解决：原理解释起来比较困难**  \r\n> 这种方式也能解决post的乱码\r\n\r\n* GET方式的请求数据是放在URL中的，但URL是不支持中文的，  \r\n* 浏览器会将中文以`UTF-8`格式进行`URL编码`   \r\n  * ![](./images/JavaWeb学习笔记/2022-12-01-17-26-05.png)\r\n* TomCat收到后会以`ISO-8859-1`格式进行`URL解码`  \r\n  * ![](./images/JavaWeb学习笔记/2022-12-01-17-22-07.png)\r\n* 问题在于无法修改这个`ISO-8859-1`格式为`UTF-8`  \r\n* 所以需要将得到的数据重新以`ISO-8859-1`格式`解码`获取字节码\r\n* 然后再将得到的字节码以以`UTF-8`格式解析为字符串\r\n\r\n\r\n**URL编码**\r\n1. 将字符串按照编码方式转为二进制\r\n2. 每个字节转为2个16进制数并在前边加上%\r\n\r\n```java\r\nimport java.net.URLDecoder;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\npublic class Test {\r\n    public static void main(String[] args) {\r\n        String userName = \"张三\";\r\n\r\n        // 浏览器做的事\r\n        // 以 ISO_8859_1 编码 URL\r\n        String userName_Browser = URLEncoder.encode(userName,StandardCharsets.UTF_8);\r\n        System.out.println(userName_Browser); // 输出： %E5%BC%A0%E4%B8%89\r\n\r\n        // TomCat做的事，\r\n        // 以 ISO_8859_1 解码 URL\r\n        String userName_TomCat = URLDecoder.decode(userName_Browser, StandardCharsets.ISO_8859_1);\r\n        System.out.println(userName_TomCat); // 输出： ??????\r\n\r\n        // 作为Servlet开发人员要做的事，\r\n        // 以 ISO_8859_1 解码 `乱码字符串` 获取 `字节数组` ， 然后以UTF_8字符集编码解析 `字节数组` 获取 `字符串` \r\n        String userName_Servlet = new String(userName_TomCat.getBytes(StandardCharsets.ISO_8859_1),StandardCharsets.UTF_8);\r\n        System.out.println(userName_Servlet); // 输出： 张三\r\n    }\r\n}\r\n```\r\n\r\n### Request内部请求转发转发流转给jsp页面Forward\r\n![](./images/JavaWeb学习笔记/2022-12-01-19-57-28.png) \r\n> \r\n\r\n**方法**\r\n```java\r\nreq.getRequestDispatcher(\"/api/2\").forward(req, resp);\r\n```\r\n\r\n**传递数据的一些方法**\r\n![](./images/JavaWeb学习笔记/2022-12-01-20-46-36.png)\r\n\r\n\r\n**终端输出**\r\n```bash\r\n/api1 被访问\r\n/api/2 被访问\r\ntest的数据为: test的数据\r\n```\r\n\r\n```java\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(\"/api/1\")\r\npublic class MyServlet1 extends HttpServlet { // 该类需为public\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"/api/1 被访问\");\r\n\r\n        req.setAttribute(\"test\", \"test的数据\");\r\n        \r\n        // 转发给 \"/api/2\" 的处理函数\r\n        req.getRequestDispatcher(\"/api/2\").forward(req, resp);\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(\"/api/2\")\r\npublic class MyServlet2 extends HttpServlet { // 注意 该类需为public\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"/api/2 被访问\");\r\n        System.out.println( \"test的数据为: \"+req.getAttribute(\"test\") );\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n### Response对象\r\n\r\n**实现关系**\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-01-21-33-06.png)\r\n\r\n#### Response设置响应数据功能介绍\r\n![](./images/JavaWeb学习笔记/2022-12-01-21-39-13.png)\r\n\r\n#### Response完成重定向\r\n![](./images/JavaWeb学习笔记/2022-12-01-21-41-02.png)\r\n\r\n```java\r\n@WebServlet(\"/api/1\")\r\npublic class MyServlet1 extends HttpServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        System.out.println(\"/api/1 被访问\");\r\n\r\n        // 设置响应行\r\n        resp.setStatus(302);\r\n        // 设置相应头\r\n        resp.setHeader(\"location\", \"/api/2\");\r\n\r\n        // 等效的简化写法\r\n        // resp.sendRedirect(\"api/2\");\r\n    }\r\n\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n#### Response响应字符数据\r\n```java\r\nresponse.setContentType(\"text/html;charset=utf-8\");\r\nPrintWriter wr = response.getWriter();\r\nwr.write(\"<h1>测试</h1>\");\r\n```\r\n\r\n```java\r\n@WebServlet(\"/a\")\r\npublic class MyServlet0 extends HttpServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException {\r\n        response.setContentType(\"text/html;charset=utf-8\"); // 使其支持中文 ，因为，response获取到的输出流默认为IOS-8859-1\r\n        PrintWriter wr = response.getWriter(); // 注意PrintWriter会随着resp的关闭而自动销毁\r\n        wr.write(\"<h1>测试</h1>\");\r\n    }\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n#### Response响应字节数据\r\n\r\n```java\r\nOutputStream os = response.getOutputStream();\r\n```\r\n\r\n```java\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.apache.commons.io.IOUtils; //commons-io IOUtils是流的工具库\r\n\r\n@WebServlet(\"/a\")\r\npublic class MyServlet0 extends HttpServlet {\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException {\r\n        InputStream is = this.getClass().getResourceAsStream(\"./123.txt\");\r\n        OutputStream os = response.getOutputStream();\r\n        IOUtils.copy(is, os);// 拷贝\r\n        System.out.println(\"拷贝完毕\");\r\n    }\r\n    @Override\r\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n### 案例：实现登录注册案例\r\n\r\n**注册**  \r\n![](./images/JavaWeb学习笔记/2022-12-02-21-44-16.png)\r\n![](./images/JavaWeb学习笔记/2022-12-02-21-44-28.png)\r\n\r\n**注册**  \r\n![](./images/JavaWeb学习笔记/2022-12-02-21-43-58.png)\r\n![](./images/JavaWeb学习笔记/2022-12-02-21-43-42.png)\r\n\r\n**数据准备**\r\n```sql\r\nCREATE DATABASE IF NOT EXISTS db6;\r\n\r\nCREATE TABLE IF NOT EXISTS tb_user(\r\n    id INT AUTO_INCREMENT PRIMARY KEY,\r\n    username VARCHAR(20) UNIQUE NOT NULL,\r\n    password VARCHAR(20) NOT NULL\r\n);\r\n\r\nINSERT INTO \r\n    tb_user(username,password)\r\nVALUES\r\n    (\"张三\",\"123456\"),\r\n    (\"王五\",\"123456\")\r\n;\r\n```\r\n\r\n**项目目录结构**\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-02-21-37-23.png)\r\n\r\n**pom.xml**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <groupId>com.webapptest</groupId>\r\n  <artifactId>webapptest</artifactId>\r\n  <version>1.1-SNAPSHOT</version>\r\n  <packaging>war</packaging>\r\n  \r\n\r\n  <name>web Maven Webapp</name>\r\n  <!-- FIXME change it to the project's website -->\r\n  <url>http://www.example.com</url>\r\n\r\n  <properties>\r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n    <maven.compiler.source>1.7</maven.compiler.source>\r\n    <maven.compiler.target>1.7</maven.compiler.target>\r\n  </properties>\r\n\r\n  <dependencies>\r\n\r\n    <dependency>\r\n    <groupId>javax.servlet</groupId>\r\n    <artifactId>javax.servlet-api</artifactId>\r\n    <version>3.1.0</version>\r\n    <scope>provided</scope>\r\n  </dependency>\r\n\r\n\r\n    <dependency>\r\n      <groupId>org.mybatis</groupId>\r\n      <artifactId>mybatis</artifactId>\r\n      <version>3.5.11</version>\r\n    </dependency>\r\n\r\n\r\n    <dependency>\r\n      <groupId>mysql</groupId>\r\n      <artifactId>mysql-connector-java</artifactId>\r\n      <version>8.0.31</version>\r\n    </dependency>\r\n\r\n\r\n    <dependency>\r\n      <groupId>org.apache.tomcat</groupId>\r\n      <artifactId>tomcat</artifactId>\r\n      <version>10.1.2</version>\r\n      <type>pom</type>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>junit</groupId>\r\n      <artifactId>junit</artifactId>\r\n      <version>4.11</version>\r\n      <scope>test</scope>\r\n    </dependency>\r\n    \r\n  </dependencies>\r\n\r\n  <build>\r\n    <finalName>web</finalName>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat7-maven-plugin</artifactId>\r\n        <version>2.2</version>\r\n        <configuration>\r\n          <port>8080</port>\r\n          <path>/</path>\r\n        </configuration>\r\n      </plugin>\r\n    </plugins>\r\n    \r\n    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\r\n      <plugins>\r\n        <plugin>\r\n          <artifactId>maven-clean-plugin</artifactId>\r\n          <version>3.1.0</version>\r\n        </plugin>\r\n        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->\r\n        <plugin>\r\n          <artifactId>maven-resources-plugin</artifactId>\r\n          <version>3.0.2</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-compiler-plugin</artifactId>\r\n          <version>3.8.0</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-surefire-plugin</artifactId>\r\n          <version>2.22.1</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-war-plugin</artifactId>\r\n          <version>3.2.2</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-install-plugin</artifactId>\r\n          <version>2.5.2</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-deploy-plugin</artifactId>\r\n          <version>2.8.2</version>\r\n        </plugin>\r\n      </plugins>\r\n    </pluginManagement>\r\n  </build>\r\n</project>\r\n```\r\n\r\n**mybatis-config.xml**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n  <environments default=\"development\">\r\n    <environment id=\"development\">\r\n      <transactionManager type=\"JDBC\"/>\r\n      <dataSource type=\"POOLED\">\r\n        <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/> <!-- 填mysql的驱动的路径 -->\r\n        <property name=\"url\" value=\"jdbc:mysql:///db6?useSSL=false&amp;useServerPrepStemts=true\"/>  <!-- 填mysql数据库的路径 -->\r\n        <property name=\"username\" value=\"root\"/>  <!-- 填数据库的username -->\r\n        <property name=\"password\" value=\"root\"/>   <!-- 填数据库的password -->\r\n      </dataSource>\r\n    </environment>\r\n  </environments>\r\n  <mappers>\r\n    <package name=\"com.webapptest.mapper\" /> <!-- 使用这种Mapper代理的方式便可以用这种包扫描的写法 -->\r\n  </mappers>\r\n</configuration>\r\n```\r\n\r\n`UserMapper.java`\r\n```java\r\npackage com.webapptest.mapper;\r\nimport java.util.List;\r\n\r\nimport org.apache.ibatis.annotations.Insert;\r\nimport org.apache.ibatis.annotations.Param;\r\n// import org.apache.ibatis.annotations.Select;\r\nimport org.apache.ibatis.annotations.Select;\r\n\r\nimport com.webapptest.pojo.User;\r\n\r\npublic interface UserMapper {\r\n\r\n    List<User> selectAll();\r\n    \r\n    User selectUserById(int id);\r\n\r\n    @Select(\"select * from tb_user where username = #{username} and password = #{password};\")\r\n    User selectUserByUsernameAndPassword(\r\n        @Param(\"username\") String username,\r\n        @Param(\"password\") String password\r\n    );\r\n\r\n    @Insert(\"INSERT INTO tb_user(id,username,password) values(null,#{username},#{password});\")\r\n    int addUser(User user);\r\n}\r\n```\r\n\r\n`UserMapper.xml`\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.webapptest.mapper.UserMapper\">  <!-- namespace改为接口类 -->\r\n  <select id=\"selectAll\" resultType=\"com.webapptest.pojo.User\">   <!-- id为接口的函数名 -->\r\n    select * from tb_user;\r\n  </select>\r\n  <!-- selectUserById --> \r\n  <select id=\"selectUserById\" resultType=\"com.webapptest.pojo.User\">\r\n    select * from tb_user where id = #{id};\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n`pojo/User.java`\r\n```java\r\npackage com.webapptest.pojo;\r\n\r\npublic class User {\r\n    Integer id; \r\n    String username; \r\n    String password;\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n    public String getUsername() {\r\n        return username;\r\n    }\r\n    public void setUsername(String username) {\r\n        this.username = username;\r\n    }\r\n    public String getPassword() {\r\n        return password;\r\n    }\r\n    public void setPassword(String password) {\r\n        this.password = password;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"User [id=\" + id + \", username=\" + username + \", password=\" + password + \"]\";\r\n    }\r\n}\r\n```\r\n\r\n\r\n`Login.java`\r\n* 踩坑记录，WebServlet的实现类需放到`/src/main/java/`目录下\r\n```java\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.apache.ibatis.io.Resources;\r\n\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n\r\nimport com.webapptest.mapper.UserMapper;\r\nimport com.webapptest.pojo.User;\r\n\r\n@WebServlet(urlPatterns = \"/api/login\")\r\npublic class Login extends HttpServlet {\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        \r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n        \r\n        System.out.println(username);\r\n        System.out.println(password);\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession(true);\r\n\r\n        // 获取UserMapper接口的代理对象\r\n        UserMapper userMapper = session.getMapper(UserMapper.class);\r\n        User user = userMapper.selectUserByUsernameAndPassword(username,password);\r\n        if(user!=null)\r\n            response.getWriter().println(\"登录成功!\");\r\n        else\r\n            response.getWriter().println(\"登录失败!\");\r\n        \r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n\r\n        session.close();\r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n`Register.java`\r\n```java\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.apache.ibatis.io.Resources;\r\n\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n\r\nimport com.webapptest.mapper.UserMapper;\r\nimport com.webapptest.pojo.User;\r\n\r\n@WebServlet(urlPatterns = \"/api/register\")\r\npublic class Register extends HttpServlet {\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        \r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n\r\n        User user = new User();\r\n        user.setUsername(username);\r\n        user.setPassword(password);\r\n        \r\n        System.out.println(username);\r\n        System.out.println(password);\r\n\r\n        // 加载mybatis核心配置文件\r\n        String resource = \"mybatis-config.xml\";\r\n        InputStream inputStream = Resources.getResourceAsStream(resource);\r\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n\r\n        // 获取SqlSession，用其来执行sql语句\r\n        SqlSession session = sqlSessionFactory.openSession(true);\r\n        \r\n        // 获取UserMapper接口的代理对象\r\n        UserMapper userMapper = session.getMapper(UserMapper.class);\r\n\r\n        int affectedRows=0;\r\n\r\n        try {\r\n            // 因为用户名是unique 插入出错则直接提示注册失败\r\n            affectedRows = userMapper.addUser(user);\r\n            response.getWriter().println(\"注册成功!\"+ affectedRows);\r\n\r\n        } catch (Exception e) {\r\n            System.out.println(e);\r\n            response.getWriter().println(\"注册失败!\" + affectedRows);\r\n        }\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n        session.close();\r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n`login.html`\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    <h2>登录</h2>\r\n    <form action=\"/api/login\" method=\"post\">\r\n        userName:<input type=\"text\" name=\"username\"> <br>\r\n        password:<input type=\"password\" name=\"password\"> <br>\r\n        <input type=\"submit\" value=\"登录\">\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n`register.html`\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    <h2>注册</h2>\r\n    <form action=\"/api/register\" method=\"post\">\r\n        userName: <input type=\"text\" name=\"username\"> <br>\r\n        password: <input type=\"password\" name=\"password\"> <br>\r\n        <input type=\"submit\" value=\"注册\">\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n### 优化：把SqlSessionFactory优化为工具类\r\n```java\r\npackage com.webapptest.datebase;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n\r\npublic class DBSessionPool {// 数据库连接池\r\n    public static SqlSessionFactory sqlSessionFactory=null;\r\n    public static SqlSession getSession(Boolean isAutoCommit) throws IOException {\r\n        if(DBSessionPool.sqlSessionFactory==null){\r\n            // 加载mybatis核心配置文件\r\n            String resource = \"mybatis-config.xml\";\r\n            InputStream inputStream = Resources.getResourceAsStream(resource);\r\n            DBSessionPool.sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n        }\r\n        // 获取SqlSession，用其来执行sql语句\r\n        return DBSessionPool.sqlSessionFactory.openSession(isAutoCommit);\r\n    }\r\n}\r\n```\r\n\r\n**从数据库连接池 获取 sqlSession**\r\n```java\r\nimport java.io.IOException;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport org.apache.ibatis.session.SqlSession;\r\n\r\nimport com.webapptest.datebase.DBSessionPool;\r\nimport com.webapptest.mapper.UserMapper;\r\nimport com.webapptest.pojo.User;\r\n\r\n@WebServlet(urlPatterns = \"/api/login\")\r\npublic class Login extends HttpServlet {\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        \r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n        \r\n        System.out.println(username);\r\n        System.out.println(password);\r\n\r\n\r\n         //从数据库连接池 获取 sqlSession\r\n        SqlSession session = DBSessionPool.getSession(true);\r\n\r\n        // 获取UserMapper接口的代理对象\r\n        UserMapper userMapper = session.getMapper(UserMapper.class);\r\n        User user = userMapper.selectUserByUsernameAndPassword(username,password);\r\n        if(user!=null)\r\n            response.getWriter().println(\"登录成功!\");\r\n        else\r\n            response.getWriter().println(\"登录失败!\");\r\n        \r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n\r\n        session.close();\r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n## JSP(Java Server Pages)Java服务端页面\r\n> 简单了解即可，JSP已经逐渐退出历史舞台了。\r\n> JSP本质和PHP类似    \r\n> JSP已经逐渐被AJAX技术取代了  \r\n\r\n\r\n> JSP=HTML+JAVA\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-02-23-23-39.png)\r\n\r\n\r\n`{{ProjectRoot}}/src/main/webapp/index.jsp`\r\n```jsp\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n  <body>\r\n  <h2>Hello World!</h2>\r\n  <%\r\n    <!-- System.out.println(\"Hello JSP...\"); -->\r\n      out.println(\"Hello JSP...\");\r\n  %>\r\n  </body>\r\n</html>\r\n```\r\n**编译后大概的样子**\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-02-23-43-04.png)\r\n\r\n`pom.xml`\r\n```xml\r\n    <dependency>\r\n      <groupId>javax.servlet.jsp</groupId>\r\n      <artifactId>jsp-api</artifactId>\r\n      <version>2.2.1-b03</version>\r\n      <scope>provided</scope>\r\n    </dependency>\r\n```\r\n\r\n\r\n> JSP本质就是一个Servlet\r\n>\r\n> JSP在被访问时，由JSP容器(Tomcat)将其转换为Java文件(Servlet)，在由JSP容器(Tomcat)将其编译，最终对外提供服务的其实就是这个字节码文件\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-02-23-38-51.png)\r\n\r\n\r\nJSP脚本标记分类\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-02-23-43-37.png)\r\n\r\n\r\n**缺点**\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-04-24.png)\r\n\r\n### servlet+jsp\r\n\r\n> 这种方式的主要解决java代码和html代码混在一起难以阅读的问题，  \r\n> 核心原理是，\r\n> * 将需要的数据在servlet中封装好，   \r\n>   * `req.setAttribute(\"test\", \"test的数据\");`   \r\n> * 然后通过通过内部转发流转给jsp页面\r\n>   * `req.getRequestDispatcher(\"/api/2\").forward(req, resp);` \r\n> * jsp页面通过 `EL表达式语言` 读取封装好的数据\r\n\r\n\r\n**EL表达式**\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-24-06.png)\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-26-07.png)\r\n\r\n**基本的书写格式**\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-19-35.png)\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-23-15.png)\r\n\r\n\r\n### JSTF标签\r\n> 该技术主要是解决了过去java的if和for循环不得不写在jsp代码中的问题  \r\n> 其实就是以html标签的方式写java的某些语句\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-37-11.png)\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-39-22.png)\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-41-02.png)\r\n\r\n\r\n**使用JSTF标签的预备步骤**\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-36-54.png)\r\n\r\n\r\n\r\n## MVC模式与三层架构\r\n\r\n### MVC模式\r\nMVC是一种分层开发的模式，其中:\r\n* M: Model，业务模型，处理业务\r\n* V: View，视图，界面展示\r\n* C: Controller，控制器，处理请求，调用模型和视图\r\n\r\n**MVC好处**\r\n* 职责单一\r\n* 互不影响有利于分工协作\r\n* 有利于组件重用\r\n\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-44-23.png)\r\n\r\n\r\n### 三层架构\r\n\r\n* 数据访问层:对数据库的CRUD基本操作\r\n* 业务逻辑层:对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能\r\n* 表现层:接收请求，封装数据，调用业务逻辑层，响应数据\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-51-27.png)\r\n\r\n**三层架构项目结构**\r\n\r\n依次分别为：\r\n* 数据访问层\r\n* 业务逻辑层\r\n* 表现层（控制器+视图）\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-58-28.png)\r\n\r\n\r\n### SSM三大框架\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-50-12.png)\r\n\r\n### MVC三层模式与三层架构的区别\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-03-00-54-22.png)\r\n\r\n### 案例业务逻辑\r\n![](./images/JavaWeb学习笔记/2022-12-03-01-04-10.png)\r\n\r\n## 使用`三层架构`重写登录注册案例\r\n### 项目目录结构\r\n* database 数据访问层\r\n  * `mybatis-config.xml`\r\n  * `mapper` \r\n  * `pojo`\r\n  * `DBSessionPool.java` 单例模式的数据库池\r\n* `service` 业务逻辑层\r\n* `web` 表现层（控制器+视图）\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-03-01-47-23.png)\r\n\r\n### database数据访问层\r\n`database/DBSessionPool.java`\r\n```java\r\npackage com.webapptest.database;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\n\r\npublic class DBSessionPool {// 数据库连接池\r\n    public static SqlSessionFactory sqlSessionFactory=null;\r\n    public static SqlSessionFactory getSqlSessionFactory() {\r\n        if(DBSessionPool.sqlSessionFactory==null){\r\n            // 加载mybatis核心配置文件\r\n            try {\r\n                String resource = \"mybatis-config.xml\";\r\n                InputStream inputStream;\r\n                inputStream = Resources.getResourceAsStream(resource);\r\n                DBSessionPool.sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        return DBSessionPool.sqlSessionFactory;\r\n    }\r\n}\r\n\r\n```\r\n\r\n`database/mapper/UserMapper.java`\r\n```java\r\npackage com.webapptest.database.mapper;\r\nimport java.util.List;\r\n\r\nimport org.apache.ibatis.annotations.Insert;\r\nimport org.apache.ibatis.annotations.Param;\r\nimport org.apache.ibatis.annotations.Select;\r\n\r\nimport com.webapptest.database.pojo.User;\r\n\r\npublic interface UserMapper {\r\n\r\n    List<User> selectAll();\r\n    \r\n    User selectUserById(int id);\r\n\r\n    @Select(\"select * from tb_user where username = #{username} and password = #{password};\")\r\n    User selectUserByUsernameAndPassword(\r\n        @Param(\"username\") String username,\r\n        @Param(\"password\") String password\r\n    );\r\n\r\n    @Insert(\"INSERT INTO tb_user(id,username,password) values(null,#{username},#{password});\")\r\n    int addUser(User user);\r\n}\r\n```\r\n\r\n`database/mapper/UserMapper.xml`\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.webapptest.database.mapper.UserMapper\">  <!-- namespace改为接口类 -->\r\n  <select id=\"selectAll\" resultType=\"com.webapptest.database.pojo.User\">   <!-- id为接口的函数名 -->\r\n    select * from tb_user;\r\n  </select>\r\n  <!-- selectUserById --> \r\n  <select id=\"selectUserById\" resultType=\"com.webapptest.database.pojo.User\">\r\n    select * from tb_user where id = #{id};\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n`../resources/mybatis-config.xml`\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n  <environments default=\"development\">\r\n    <environment id=\"development\">\r\n      <transactionManager type=\"JDBC\"/>\r\n      <dataSource type=\"POOLED\">\r\n        <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/> <!-- 填mysql的驱动的路径 -->\r\n        <property name=\"url\" value=\"jdbc:mysql:///db6?useSSL=false&amp;useServerPrepStemts=true\"/>  <!-- 填mysql数据库的路径 -->\r\n        <property name=\"username\" value=\"root\"/>  <!-- 填数据库的username -->\r\n        <property name=\"password\" value=\"root\"/>   <!-- 填数据库的password -->\r\n      </dataSource>\r\n    </environment>\r\n  </environments>\r\n  <mappers>\r\n    <package name=\"com.webapptest.database.mapper\" /> <!-- 使用这种Mapper代理的方式便可以用这种包扫描的写法 -->\r\n  </mappers>\r\n</configuration>\r\n```\r\n\r\n### service业务逻辑层\r\n\r\n`service/UserService.java`\r\n```java\r\npackage com.webapptest.service;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport com.webapptest.database.DBSessionPool;\r\nimport com.webapptest.database.mapper.UserMapper;\r\nimport com.webapptest.database.pojo.User;\r\n\r\npublic class UserService {\r\n    SqlSession session = DBSessionPool.getSqlSessionFactory().openSession(false); // 获取sqlSession\r\n\r\n    // 添加用户\r\n    public boolean addUser(User user){\r\n        UserMapper userMapper = session.getMapper(UserMapper.class);\r\n        int affectedRows=0;\r\n        try {\r\n            affectedRows = userMapper.addUser(user);\r\n            if(affectedRows == 1) {\r\n                session.commit(); // 提交事务\r\n                return true;\r\n            }else{\r\n                session.rollback();// 回滚事务\r\n                return false;\r\n            }\r\n        } catch (Exception e) {\r\n            session.rollback();// 回滚事务\r\n            return false;\r\n        } finally {\r\n            session.close();\r\n        }\r\n    }\r\n    public User checkUserExist(String username,String password){// 检查用户是否存在\r\n        UserMapper userMapper = session.getMapper(UserMapper.class);\r\n        return userMapper.selectUserByUsernameAndPassword(username,password);\r\n    }\r\n}\r\n```\r\n\r\n### web表现层（控制器+视图）\r\n\r\n`web/Login.java`\r\n```java\r\npackage com.webapptest.web;\r\n\r\n\r\nimport java.io.IOException;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport com.webapptest.database.pojo.User;\r\nimport com.webapptest.service.UserService;\r\n\r\n\r\n@WebServlet(urlPatterns = \"/api/login\")\r\npublic class Login extends HttpServlet {\r\n\r\n    UserService userService = new UserService(); // 服务层\r\n\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        \r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n     \r\n        // 调用服务层，检查用户存在\r\n        User user = userService.checkUserExist(username, password);\r\n\r\n        if(user!=null)\r\n            response.getWriter().println(\"登录成功!\");\r\n        else\r\n            response.getWriter().println(\"登录失败!\");\r\n        \r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n\r\n```\r\n\r\n`web/Register.java`\r\n```java\r\npackage com.webapptest.web;\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport com.webapptest.database.pojo.User;\r\nimport com.webapptest.service.UserService;\r\n\r\n@WebServlet(urlPatterns = \"/api/register\")\r\npublic class Register extends HttpServlet {\r\n    UserService userService = new UserService();\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n\r\n        \r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n\r\n        User user = new User();\r\n        user.setUsername(username);\r\n        user.setPassword(password);\r\n\r\n        Boolean result = userService.addUser(user);\r\n\r\n        if(result)\r\n            response.getWriter().println(\"注册成功!\");\r\n        else\r\n            response.getWriter().println(\"注册失败!\");\r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n### maven配置\r\n\r\n`pom.xml`\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n\r\n  <groupId>com.webapptest</groupId>\r\n  <artifactId>webapptest</artifactId>\r\n  <version>1.1-SNAPSHOT</version>\r\n  <packaging>war</packaging>\r\n  \r\n\r\n  <name>web Maven Webapp</name>\r\n  <!-- FIXME change it to the project's website -->\r\n  <url>http://www.example.com</url>\r\n\r\n  <properties>\r\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n    <maven.compiler.source>1.7</maven.compiler.source>\r\n    <maven.compiler.target>1.7</maven.compiler.target>\r\n  </properties>\r\n\r\n  <dependencies>\r\n\r\n    <dependency>\r\n      <groupId>javax.servlet.jsp</groupId>\r\n      <artifactId>jsp-api</artifactId>\r\n      <version>2.2.1-b03</version>\r\n      <scope>provided</scope>\r\n    </dependency>\r\n\r\n\r\n    <dependency>\r\n    <groupId>javax.servlet</groupId>\r\n    <artifactId>javax.servlet-api</artifactId>\r\n    <version>3.1.0</version>\r\n    <scope>provided</scope>\r\n  </dependency>\r\n\r\n\r\n    <dependency>\r\n      <groupId>org.mybatis</groupId>\r\n      <artifactId>mybatis</artifactId>\r\n      <version>3.5.11</version>\r\n    </dependency>\r\n\r\n\r\n    <dependency>\r\n      <groupId>mysql</groupId>\r\n      <artifactId>mysql-connector-java</artifactId>\r\n      <version>8.0.31</version>\r\n    </dependency>\r\n\r\n\r\n    <dependency>\r\n      <groupId>org.apache.tomcat</groupId>\r\n      <artifactId>tomcat</artifactId>\r\n      <version>10.1.2</version>\r\n      <type>pom</type>\r\n    </dependency>\r\n\r\n    <dependency>\r\n      <groupId>junit</groupId>\r\n      <artifactId>junit</artifactId>\r\n      <version>4.11</version>\r\n      <scope>test</scope>\r\n    </dependency>\r\n    \r\n  </dependencies>\r\n\r\n  <build>\r\n    <finalName>web</finalName>\r\n    <plugins>\r\n      <plugin>\r\n        <groupId>org.apache.tomcat.maven</groupId>\r\n        <artifactId>tomcat7-maven-plugin</artifactId>\r\n        <version>2.2</version>\r\n        <configuration>\r\n          <port>8080</port>\r\n          <path>/</path>\r\n        </configuration>\r\n      </plugin>\r\n    </plugins>\r\n    \r\n    <pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->\r\n      <plugins>\r\n        <plugin>\r\n          <artifactId>maven-clean-plugin</artifactId>\r\n          <version>3.1.0</version>\r\n        </plugin>\r\n        <!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging -->\r\n        <plugin>\r\n          <artifactId>maven-resources-plugin</artifactId>\r\n          <version>3.0.2</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-compiler-plugin</artifactId>\r\n          <version>3.8.0</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-surefire-plugin</artifactId>\r\n          <version>2.22.1</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-war-plugin</artifactId>\r\n          <version>3.2.2</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-install-plugin</artifactId>\r\n          <version>2.5.2</version>\r\n        </plugin>\r\n        <plugin>\r\n          <artifactId>maven-deploy-plugin</artifactId>\r\n          <version>2.8.2</version>\r\n        </plugin>\r\n      </plugins>\r\n    </pluginManagement>\r\n  </build>\r\n</project>\r\n```\r\n\r\n\r\n### <green>结合反射对web表现层的进一步优化并实现验证码和JSON响应</green>\r\n\r\n**完整源代码：**\r\n[webapp_三层架构模板并实现登录注册验证码](./resource/webapp_%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A8%A1%E6%9D%BF%E5%B9%B6%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81%E7%A0%81.zip)\r\n\r\n\r\n> 如果任何一个方法都写一个Servelet实现类，代码会变的很臃肿  \r\n> \r\n> 在Web表现层根据请求的URL直接调用service业务逻辑层的方法  \r\n> 自定义BaseServlet，根据浏览器请求的URL路径完成处理函数的调用\r\n\r\n**优化后目录结构**  \r\n![](./images/JavaWeb学习笔记/2022-12-03-23-54-42.png)\r\n\r\n**优化后登录界面及响应结果JSON结果**  \r\n![](./images/JavaWeb学习笔记/2022-12-04-00-12-03.png)\r\n![](./images/JavaWeb学习笔记/2022-12-04-00-11-14.png)\r\n\r\n**优化后注册界面及响应结果JSON结果**  \r\n![](./images/JavaWeb学习笔记/2022-12-04-00-13-49.png)\r\n![](./images/JavaWeb学习笔记/2022-12-04-00-14-03.png)\r\n\r\n`login.html`\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    <h2>登录</h2>\r\n    <form action=\"/api/user/login\" method=\"post\">\r\n        userName:<input type=\"text\" name=\"username\"> <br>\r\n        password:<input type=\"password\" name=\"password\"> <br>\r\n        remember:<input type=\"checkbox\" name=\"remember\" value=\"true\"> <br>\r\n        <input type=\"submit\" value=\"登录\">\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n`register.html`\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    <h2>注册</h2>\r\n    <form action=\"/api/user/register\" method=\"post\">\r\n        userName: <input type=\"text\" name=\"username\"> <br>\r\n        password: <input type=\"password\" name=\"password\"> <br>\r\n        VarifyCode: <input type=\"text\" name=\"VarifyCode\" > <br>\r\n        <img src=\"/api/user/getVerifytImage\" alt=\"\" style=\"width: 200px;height: 50px;\"> <br>\r\n        <input type=\"submit\" value=\"注册\">\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n`BaseServlet.java`\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\nimport java.lang.reflect.Method;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\npublic class BaseServlet extends HttpServlet {\r\n    @Override\r\n    protected void service(HttpServletRequest req, HttpServletResponse resp) {\r\n        String uriString = req.getRequestURI(); // 获取URI: /user/login\r\n        int supliceIndex = uriString.lastIndexOf(\"/\"); // 找到最后一个/符号的位置\r\n        String methodName = uriString.substring(supliceIndex+1); //获取方法名: login\r\n\r\n        try {// 通过反射获取这个方法,并执行这个方法\r\n            Method method = this.getClass().getDeclaredMethod(methodName,HttpServletRequest.class,HttpServletResponse.class);\r\n            method.invoke(this, req,resp);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        System.out.println(\"BaseServlet的service被调用了\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n`UserServlet.java`\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport com.alibaba.fastjson.JSON;\r\nimport com.webapptest.database.pojo.User;\r\nimport com.webapptest.service.UserService;\r\nimport com.webapptest.utils.CheckCodeUtil;\r\n\r\n// 当浏览器访问 /api/user/login 时，\r\n// 会由 BaseServlet 的 service 函数 找到子类的 login 这个函数,然后执行他\r\n@WebServlet(\"/api/user/*\")\r\npublic class UserServlet extends BaseServlet{\r\n    UserService userService = new UserService(); // 服务层\r\n    public void login(HttpServletRequest request,HttpServletResponse response ) throws IOException{\r\n\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n        \r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n     \r\n        // 调用服务层，检查用户存在\r\n        User user = userService.checkUserExist(username, password);\r\n\r\n        ResponseData responseData = new ResponseData();\r\n        if(user!=null){\r\n            responseData.setStatus(1);\r\n            responseData.setMsg(\"登录成功!\");\r\n            user.setPassword(null);// 清除密码信息\r\n            responseData.setData(user);// 把user对象传递过去\r\n        }\r\n        else{\r\n            responseData.setStatus(0);\r\n            responseData.setMsg(\"登录失败!\");\r\n        }\r\n        response.getWriter().write(JSON.toJSONString(responseData));// 响应数据\r\n\r\n        System.out.println(\"UserServlet的login被调用了\");\r\n    }\r\n    // 获取注册用户时需要的验证码图片\r\n    public void getVerifytImage(HttpServletRequest request,HttpServletResponse response) throws IOException{\r\n        // 生成5位的随机验证码，并保存到session中\r\n        String VarifyCode = CheckCodeUtil.generateVerifyCode(5);\r\n        request.getSession().setAttribute(\"VarifyCode\", VarifyCode);\r\n        // 生成图片返回给浏览器\r\n        CheckCodeUtil.outputImage(200, 50, response.getOutputStream(), VarifyCode);\r\n        System.out.println(\"UserServlet的getVerifytImage被调用了\");\r\n    }\r\n    // 注册用户\r\n    public void register(HttpServletRequest request,HttpServletResponse response) throws IOException{\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n        \r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n        String VarifyCode = request.getParameter(\"VarifyCode\"); // 从浏览器得到的VarifyCode\r\n        String VarifyCode_inSession = (String) request.getSession().getAttribute(\"VarifyCode\");// 从session中获得的VarifyCode\r\n\r\n        User user = new User();\r\n        user.setUsername(username);\r\n        user.setPassword(password);\r\n\r\n        ResponseData responseData = new ResponseData();\r\n\r\n        if( VarifyCode.equalsIgnoreCase(VarifyCode_inSession) == false) // 忽略大小写的比对\r\n        {\r\n            responseData.setStatus(1);\r\n            responseData.setMsg(\"注册失败!,验证码错误。\");\r\n            response.getWriter().write(JSON.toJSONString(responseData));\r\n            return;\r\n        }\r\n\r\n        Boolean result = userService.addUser(user);\r\n\r\n        if(result){\r\n            responseData.setStatus(1);\r\n            responseData.setMsg(\"注册成功!\");\r\n        }\r\n        else{\r\n            responseData.setStatus(0);\r\n            responseData.setMsg(\"注册失败!\");\r\n        }\r\n        response.getWriter().write(JSON.toJSONString(responseData));\r\n    \r\n        System.out.println(\"UserServlet的register被调用了\");\r\n    }\r\n    private class ResponseData{\r\n        int status;\r\n        String msg;\r\n        Object data;\r\n        public int getStatus() {\r\n            return status;\r\n        }\r\n        public void setStatus(int status) {\r\n            this.status = status;\r\n        }\r\n        public String getMsg() {\r\n            return msg;\r\n        }\r\n        public void setMsg(String msg) {\r\n            this.msg = msg;\r\n        }\r\n        public Object getData() {\r\n            return data;\r\n        }\r\n        public void setData(Object data) {\r\n            this.data = data;\r\n        }\r\n        \r\n    } \r\n}\r\n```\r\n\r\n\r\n\r\n## Fastjson：JSON 数据和 Java 对象转换\r\nFastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库，是目前Java语言中最快的JSON库，可以实现Java对象和JSON字符串的相互转换。\r\n\r\n```xml\r\n<dependency>\r\n  <groupld>com.alibaba</groupld>\r\n  <artifactld>fastjson</artifactld>\r\n  <version>1.2.62</version>\r\n</dependency>\r\n```\r\n```java\r\nUser user = new User();\r\nuser.setUsername(\"admin\");\r\nuser.setPassword(\"123456\");\r\n\r\n// 将java对象 转 json字符串\r\nString jsonStr = JSON.toJSONString(obj);\r\n\r\n// 将json字符串 转 java对象\r\nUser user = JSON.parseObject(jsonStr,User.class);\r\n```\r\n\r\n\r\n## Cookie、Session会话跟踪技术\r\n\r\n> 简单来说，就是用来解决http协议无状态性的，  \r\n> 用来让服务端与客户端能在多次请求间共享数据  \r\n> 可以让服务端能够识别两次不同的请求是否为同一身份的用户  \r\n> 可用来做身份验证  \r\n\r\n**实现方式**:\r\n1. 客户端会话跟踪技术:Cookie\r\n2. 服务端会话跟踪技术:Session\r\n\r\n\r\n### Cookie\r\n#### Cookie基本使用和原理\r\n\r\n**在服务端`发送`cookie**\r\n\r\n> 服务端发送 cookie 给浏览器 基于http协议，  \r\n> 保存在响应头的setCookie字段中   \r\n> 浏览器会自动保存cookie\r\n> ![](./images/JavaWeb学习笔记/2022-12-03-02-48-28.png)\r\n> ![](./images/JavaWeb学习笔记/2022-12-03-02-56-37.png)\r\n\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(\"/api/getCookie\")\r\npublic class GetCookie extends HttpServlet{\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        // 发送cookie \r\n        resp.addCookie(new Cookie(\"key\", \"value\"));\r\n    }\r\n}\r\n```\r\n\r\n**在服务端`接收`cookie**\r\n\r\n> 浏览器发送 cookie 给服务器 基于http协议，  \r\n> 保存在请求头的Cookie字段中   \r\n> 浏览器会自动发送cookie\r\n> ![](./images/JavaWeb学习笔记/2022-12-03-02-55-20.png)\r\n> ![](./images/JavaWeb学习笔记/2022-12-03-02-52-19.png)\r\n\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(\"/api/sendCookie\")\r\npublic class SendCookie extends HttpServlet{\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        Cookie[] cookies = req.getCookies();\r\n        for (Cookie cookie : cookies) {\r\n            System.out.println(cookie.getName()+\":\"+cookie.getValue());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### Cookie存活时间\r\n\r\n\r\n**`cookie`存活时间**\r\n* 默认情况下，服务端发来的cookie，浏览器会保存在内存中，浏览器关闭后cookie销毁\r\n* 服务端可以通过`setMaxAge(int seconds)`设置发送的cookie的存活时间\r\n  * 正数：将cookie存入浏览器所在电脑`硬盘`，持久化存储，`过期自动销毁`\r\n  * 0：`即刻删除`浏览器所在电脑中对应字段的值\r\n  * 负数：默认值，存入浏览器所在电脑的`内存`，`关闭浏览器后自动销毁`\r\n\r\n**Cookie默认不支持存储中文**\r\n* 但可在发送是使用URL来编码，收到后再编码会中文\r\n\r\n#### Cookie发送中文\r\n\r\n**发送中文**\r\n![](./images/JavaWeb学习笔记/2022-12-03-03-17-31.png)\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(\"/api/getCookie\")\r\npublic class GetCookie extends HttpServlet{\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        // 发送cookie \r\n        Cookie cookie = new Cookie(\"key\", URLEncoder.encode(\"中文\", StandardCharsets.UTF_8));\r\n        cookie.setMaxAge(3600);// 设置过期时间\r\n        resp.addCookie(cookie);\r\n    }\r\n}\r\n```\r\n\r\n\r\n**接收中文**\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-03-03-21-56.png)\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\nimport java.net.URLDecoder;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(\"/api/sendCookie\")\r\npublic class SendCookie extends HttpServlet{\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        Cookie[] cookies = req.getCookies();\r\n        for (Cookie cookie : cookies) {\r\n            System.out.println(cookie.getName()+\":\"+URLDecoder.decode(cookie.getValue(), StandardCharsets.UTF_8));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### Session\r\n> Session 是基于 Cookie 实现的\r\n>\r\n> 原理理解：浏览器第一次访问服务器后，服务器会为这个会话创建一个Session对象，存放在内存中，在这个Session对象中能够存储键值对信息，而后，服务器响应浏览器，并在响应头的Cookie中附带这个SessionID,浏览器第二次访问服务器时，会在响应头的Cookie字段中自动携带这个SessionID，服务器通过这个SessionID去内存中寻找这个Session，就能获取到上一次在Session中存储的信息\r\n> ![](./images/JavaWeb学习笔记/2022-12-03-03-38-49.png)\r\n\r\n> 浏览器第一次访问服务器时，服务器自动创建Session对象并在响应头中携带该Session的ID\r\n![](./images/JavaWeb学习笔记/2022-12-03-03-56-22.png)\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.HttpSession;\r\n\r\n@WebServlet(\"/api/GetSession\")\r\npublic class GetSession extends HttpServlet{\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        HttpSession session = req.getSession();\r\n        System.out.println(session.getAttribute(\"测试\"));\r\n    }\r\n}\r\n```\r\n\r\n> 浏览器第二次访问服务器时，浏览器自动通过Cookie携带Session的ID，服务器根据该SessionID从内存中找出该Session\r\n![](./images/JavaWeb学习笔记/2022-12-03-03-57-03.png)\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.HttpSession;\r\n\r\n\r\n@WebServlet(\"/api/SendSession\")\r\npublic class SendSession extends HttpServlet{\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        HttpSession session = req.getSession();\r\n        session.setAttribute(\"测试\", \"Session测试\");\r\n    }\r\n}\r\n```\r\n\r\n#### Session的钝化与活化\r\n服务器重启后，Session中的数据是否还在?\r\n* 钝化:在服务器`正常关闭`后，Tomcat会自动将Session数据写入硬盘的文件中(对象序列化)\r\n* 活化:再次启动服务器后，从文件中加载数据到Session中,然后文件会被删除\r\n\r\n#### Session在浏览器的生命周期\r\n> * 默认为关闭浏览器窗口便自动销毁。  \r\n> * 若生命周期有延长，需在服务端指定\r\n\r\n#### Session在服务端的生命周期\r\n> 默认为30分钟，可在web.xml 或tomcat的默认配置文件中修改\r\n```java\r\n<!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \r\n\"http://java.sun.com/dtd/web-app_2_3.dtd\">\r\n\r\n<web-app>\r\n  <display-name>Archetype Created Web Application</display-name>\r\n  <session-config>\r\n    <session-timeout>30</session-timeout>\r\n  </session-config>\r\n</web-app>\r\n```\r\n\r\n> **手动销毁**\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.HttpSession;\r\n\r\n@WebServlet(\"/api/GetSession\")\r\npublic class GetSession extends HttpServlet{\r\n\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        HttpSession session = req.getSession();\r\n        session.invalidate();// 销毁该session\r\n        System.out.println(session.getAttribute(\"测试\"));\r\n    }\r\n}\r\n```\r\n\r\n### 实现登录记住我功能:通过Cookie实现\r\n\r\n> 在页面中提供记住我remember选项\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    <h2>登录</h2>\r\n    <form action=\"/api/login\" method=\"post\">\r\n        userName:<input type=\"text\" name=\"username\"> <br>\r\n        password:<input type=\"password\" name=\"password\"> <br>\r\n        remember:<input type=\"checkbox\" name=\"remember\" value=\"true\"> <br>\r\n        <input type=\"submit\" value=\"登录\">\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n> 处理登录业务，同时处理remember业务逻辑，打钩则生成cookie，发送给客户端\r\n```java\r\npackage com.webapptest.web;\r\n\r\n\r\nimport java.io.IOException;\r\nimport java.net.URLEncoder;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport com.webapptest.database.pojo.User;\r\nimport com.webapptest.service.UserService;\r\n\r\n\r\n@WebServlet(urlPatterns = \"/api/login\")\r\npublic class Login extends HttpServlet {\r\n\r\n    UserService userService = new UserService(); // 服务层\r\n\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n        \r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n        String remember = request.getParameter(\"remember\");\r\n     \r\n        // 调用服务层，检查用户存在\r\n        User user = userService.checkUserExist(username, password);\r\n\r\n//---------------------------------------------------------------------------------\r\n        if(user!=null){\r\n            response.getWriter().println(\"登录成功!\");\r\n            if(\"true\".equals(remember)){ // 如果需要记住客户端，\r\n                Cookie cusername = new Cookie(\"username\",URLEncoder.encode(username,StandardCharsets.UTF_8));  // 用户名密码，统一URL编码\r\n                Cookie cpassword = new Cookie(\"password\",URLEncoder.encode(password,StandardCharsets.UTF_8));  // 用户名密码，统一URL编码\r\n                cusername.setMaxAge(60*60*24);\r\n                cpassword.setMaxAge(60*60*24);\r\n                cusername.setPath(\"/\"); // 作用域\r\n                cpassword.setPath(\"/\"); // 作用域\r\n                response.addCookie(cusername);\r\n                response.addCookie(cpassword);\r\n            }\r\n        }\r\n//---------------------------------------------------------------------------------\r\n        else\r\n            response.getWriter().println(\"登录失败!\");\r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n\r\n> 后续的登录逻辑，用户访问`/login`如果能从用户的cookie中找到用户名密码，直接登录，否则内部跳转到`/login.html`页面\r\n```java\r\npackage com.webapptest.web;\r\n\r\n\r\nimport java.io.IOException;\r\nimport java.net.URLDecoder;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport com.webapptest.database.pojo.User;\r\nimport com.webapptest.service.UserService;\r\n\r\n\r\n@WebServlet(urlPatterns = \"/login\")\r\npublic class Login_Rdirector extends HttpServlet {\r\n\r\n    UserService userService = new UserService(); // 服务层\r\n\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n\r\n        String username=null;\r\n        String password=null;\r\n\r\n//---------------------------------------------------------------------------------\r\n        Cookie[] cookies = request.getCookies(); // 从客户端cookie中提取用户名和密码信息\r\n        for (Cookie cookie : cookies) {\r\n            if(cookie.getName().equals(\"username\"))\r\n                username = URLDecoder.decode(cookie.getValue(), StandardCharsets.UTF_8); // 解码URL用户名\r\n            if(cookie.getName().equals(\"password\"))\r\n                password = URLDecoder.decode(cookie.getValue(), StandardCharsets.UTF_8); // 解码URL密码\r\n        }\r\n//---------------------------------------------------------------------------------\r\n\r\n        System.out.println(username);\r\n        System.out.println(password);\r\n\r\n        // 调用服务层，检查用户存在\r\n        User user = userService.checkUserExist(username, password);\r\n\r\n        if(user!=null)\r\n            response.getWriter().println(\"登录成功!\"); // 如果存在，直接回复登陆成功\r\n        else\r\n            request.getRequestDispatcher(\"/login.html\").forward(request, response);  // 如果不存在，内部流转到登录页面   \r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n### 实现登录记住我功能:通过Session实现\r\n\r\n```java\r\npackage com.webapptest.web;\r\n\r\n\r\nimport java.io.IOException;\r\nimport java.net.URLDecoder;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.HttpSession;\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport com.webapptest.database.pojo.User;\r\nimport com.webapptest.service.UserService;\r\n\r\n\r\n@WebServlet(urlPatterns = \"/login\")\r\npublic class Login_Rdirector extends HttpServlet {\r\n\r\n    UserService userService = new UserService(); // 服务层\r\n\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n\r\n//---------------------------------------------------------------------------------\r\n        HttpSession httpSession = request.getSession();\r\n        String username=( String ) httpSession.getAttribute(\"username\");\r\n        String password=( String ) httpSession.getAttribute(\"password\");\r\n//---------------------------------------------------------------------------------\r\n\r\n        System.out.println(username);\r\n        System.out.println(password);\r\n\r\n        // 调用服务层，检查用户存在\r\n        User user = userService.checkUserExist(username, password);\r\n\r\n        if(user!=null)\r\n            response.getWriter().println(\"登录成功!\"); // 如果存在，直接回复登陆成功\r\n        else\r\n            request.getRequestDispatcher(\"/login.html\").forward(request, response);  // 如果不存在，内部流转到登录页面   \r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npackage com.webapptest.web;\r\n\r\n\r\nimport java.io.IOException;\r\nimport java.net.URLDecoder;\r\nimport java.nio.charset.StandardCharsets;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.Cookie;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.HttpSession;\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport com.webapptest.database.pojo.User;\r\nimport com.webapptest.service.UserService;\r\n\r\n\r\n@WebServlet(urlPatterns = \"/login\")\r\npublic class Login_Rdirector extends HttpServlet {\r\n\r\n    UserService userService = new UserService(); // 服务层\r\n\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n\r\n//---------------------------------------------------------------------------------\r\n        HttpSession httpSession = request.getSession();\r\n        String username=( String ) httpSession.getAttribute(\"username\");\r\n        String password=( String ) httpSession.getAttribute(\"password\");\r\n//---------------------------------------------------------------------------------\r\n\r\n        System.out.println(username);\r\n        System.out.println(password);\r\n\r\n        // 调用服务层，检查用户存在\r\n        User user = userService.checkUserExist(username, password);\r\n\r\n        if(user!=null)\r\n            response.getWriter().println(\"登录成功!\"); // 如果存在，直接回复登陆成功\r\n        else\r\n            request.getRequestDispatcher(\"/login.html\").forward(request, response);  // 如果不存在，内部流转到登录页面   \r\n    }\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n### 实现注册用户验证码的案例\r\n\r\n![](./images/JavaWeb学习笔记/2022-12-03-14-46-47.png)\r\n![](./images/JavaWeb学习笔记/2022-12-03-14-47-34.png)\r\n![](./images/JavaWeb学习笔记/2022-12-03-14-47-45.png)\r\n\r\n**登录界面**\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    <h2>注册</h2>\r\n    <form action=\"/api/register\" method=\"post\">\r\n        userName: <input type=\"text\" name=\"username\"> <br>\r\n        password: <input type=\"password\" name=\"password\"> <br>\r\n        <!-- --------------------------------------------------------------------- -->\r\n        VarifyCode: <input type=\"text\" name=\"VarifyCode\" > \r\n        <img src=\"/api/GetVarifyCodeImg\" alt=\"\" style=\"width: 200px;height: 50px;\">\r\n        <!-- --------------------------------------------------------------------- -->\r\n        <input type=\"submit\" value=\"注册\">\r\n    </form>\r\n</body>\r\n</html>\r\n```\r\n\r\n**获取验证码图片**\r\n\r\n> 核心操作生成验证码图片返回给服务端  \r\n> 并且要把验证码存取在服务端的session中\r\n```java\r\npackage com.webapptest.web;\r\n\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport com.webapptest.utils.CheckCodeUtil;\r\n\r\n@WebServlet(\"/api/GetVarifyCodeImg\")\r\npublic class GetVarifyCodeImg extends HttpServlet{\r\n    @Override\r\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        // 生成5位的随机验证码，并保存到session中\r\n        String VarifyCode = CheckCodeUtil.generateVerifyCode(5);\r\n        req.getSession().setAttribute(\"VarifyCode\", VarifyCode);\r\n        // 生成200x50的图片，通过输出流返回给浏览器\r\n        CheckCodeUtil.outputImage(200, 50, resp.getOutputStream(), VarifyCode);\r\n    }\r\n}\r\n```\r\n\r\n重写`/api/register.java`\r\n\r\n> 要将session中的验证码和客户端收到的验证码进行比对\r\n\r\n```java\r\npackage com.webapptest.web;\r\nimport java.io.IOException;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport javax.servlet.annotation.WebServlet;\r\n\r\nimport com.webapptest.database.pojo.User;\r\nimport com.webapptest.service.UserService;\r\n\r\n@WebServlet(urlPatterns = \"/api/register\")\r\npublic class Register extends HttpServlet {\r\n    UserService userService = new UserService();\r\n    @Override\r\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        request.setCharacterEncoding(\"UTF-8\");\r\n        response.setCharacterEncoding(\"UTF-8\");\r\n        response.setContentType(\"text/html;charset=utf-8\");\r\n\r\n        \r\n        String username = request.getParameter(\"username\");\r\n        String password = request.getParameter(\"password\");\r\n        String VarifyCode = request.getParameter(\"VarifyCode\"); // 从浏览器得到的VarifyCode\r\n\r\n        // 从session中获得的VarifyCode\r\n        String VarifyCode_inSession = (String) request.getSession().getAttribute(\"VarifyCode\");\r\n\r\n         // 忽略大小写的比对\r\n        if( VarifyCode.equalsIgnoreCase(VarifyCode_inSession) == false)\r\n        {\r\n            response.getWriter().println(\"注册失败!,验证码错误。\");\r\n            return;\r\n        }\r\n\r\n        User user = new User();\r\n        user.setUsername(username);\r\n        user.setPassword(password);\r\n\r\n        Boolean result = userService.addUser(user);\r\n\r\n        if(result)\r\n            response.getWriter().println(\"注册成功!\");\r\n        else\r\n            response.getWriter().println(\"注册失败!\");\r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n        this.doGet(req, resp);\r\n    }\r\n}\r\n```\r\n\r\n**生成验证码图片的工具类**\r\n\r\n> [CheckCodeUtil.java](./Utils/CheckCodeUtil.java)\r\n\r\n## Filter\r\n\r\n**概念**  \r\nFilter表示过滤器，是JavaWeb三大组件(Servlet、Filter、Listener)之一。\r\n\r\n**拦截资源路径**  \r\n* `Filter`拦截资源路径`@WebFilter(\"/*\")`\r\n* 具体资源: `/index.jsp`:只有访问`index.jsp`时才会被拦截。\r\n* 目录拦截:`/user/*`:访问`/user`下的所有资源，都会被拦截\r\n* 后缀名: `*jsp`:访问`后缀名为jsp`的资源，都会被拦截\r\n* 拦截所有:`/*`:访问`所有`资源，都会被拦截\r\n\r\n**注解的优先级**  \r\n注解配置的Filter，优先级按照过滤器类名(字符串)的排序\r\n\r\n\r\n> 过滤器链执行流程\r\n> ![](./images/JavaWeb学习笔记/2022-12-03-17-16-31.png)\r\n> ![](./images/JavaWeb学习笔记/2022-12-03-19-48-49.png)\r\n\r\n```java\r\npackage com.webapptest.web.filter;\r\n\r\nimport java.io.IOException;\r\nimport javax.servlet.Filter;\r\nimport javax.servlet.FilterChain;\r\nimport javax.servlet.FilterConfig;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport javax.servlet.annotation.WebFilter;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebFilter(\"/login\")\r\npublic class GolbleFilter implements Filter {\r\n    @Override\r\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\r\n    throws IOException, ServletException\r\n    {\r\n        HttpServletRequest httpServletRequest = (HttpServletRequest)request;\r\n\r\n        // 1.放行前，对request中的数据进行预处理\r\n        // 此处可对 httpServletRequest 处理\r\n\r\n        // 2. 放行，转交给下一个过滤器，如果已经是最后一个过滤器，则交给实际的Servlet的处理函数\r\n        chain.doFilter(request, response);\r\n\r\n        HttpServletResponse httpServletResponse = (HttpServletResponse)response;\r\n        // 3. 此时拿到的 response 是经过 过滤器和实际Servlet处理函数处理过的response\r\n        // 此处可对 httpServletResponse 处理\r\n    }\r\n    @Override\r\n    public void destroy() {\r\n    }\r\n    @Override\r\n    public void init(FilterConfig filterConfig) throws ServletException {\r\n    }\r\n}\r\n```\r\n\r\n## Listener\r\n\r\n**概念**  \r\nListener表示监听器，是JavaWeb三大组件(Servlet、Filter、Listener)之一\r\n\r\n> 监听器可以监听就是在`application`,`session`,`request`三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件\r\n\r\n**Listener分类**  \r\nJavaWeb中提供了8个监听器   \r\n![](./images/JavaWeb学习笔记/2022-12-03-20-13-53.png)\r\n\r\n**基本使用**\r\n```java\r\npackage com.webapptest.web.filter.listener;\r\n\r\nimport javax.servlet.ServletContextEvent;\r\nimport javax.servlet.ServletContextListener;\r\nimport javax.servlet.annotation.WebListener;\r\n\r\n@WebListener // 记得加注解\r\npublic class ServeletAppListener implements ServletContextListener { // 类名任意，关键是要实现接口，添加注解\r\n    @Override\r\n    public void contextInitialized(ServletContextEvent sce) {\r\n        System.out.println(\"ServeletApp启动了......\");\r\n    }\r\n    @Override\r\n    public void contextDestroyed(ServletContextEvent sce) {\r\n        System.out.println(\"ServeletApp关闭了......\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>"},{"shortInfo":{"title":"java学习笔记","date":"2022-10-22T08:22:00.000Z","cover":"\\self_server\\assets\\images\\java学习笔记\\2022-12-04-01-56-07.png","tags":["笔记","java"],"categories":"笔记","id":4041691323,"countWords":59389,"readSeconds":5938.9,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/java学习笔记/2022-12-04-01-56-07.png) -->\r\n\r\n<details>\r\n<summary>显示/隐藏\r\n\r\n## 目录\r\n</summary>\r\n\r\n- [目录](#目录)\r\n- [学习及笔记更新日志](#学习及笔记更新日志)\r\n- [概述](#概述)\r\n- [基础语法](#基础语法)\r\n  - [注释](#注释)\r\n  - [字面量](#字面量)\r\n  - [基本数据类型](#基本数据类型)\r\n  - [标识符命名要求](#标识符命名要求)\r\n- [类型转换](#类型转换)\r\n  - [自动类型转换](#自动类型转换)\r\n  - [强制类型转换](#强制类型转换)\r\n- [运算符](#运算符)\r\n  - [算数运算符](#算数运算符)\r\n  - [字符串连接运算符](#字符串连接运算符)\r\n  - [自增自减运算符](#自增自减运算符)\r\n  - [赋值运算符](#赋值运算符)\r\n  - [关系运算符(条件运算符)](#关系运算符条件运算符)\r\n  - [逻辑运算符](#逻辑运算符)\r\n  - [三元运算符](#三元运算符)\r\n  - [运算符优先级](#运算符优先级)\r\n- [键盘录入API](#键盘录入api)\r\n- [流程控制](#流程控制)\r\n  - [分支](#分支)\r\n  - [循环](#循环)\r\n- [随机数](#随机数)\r\n- [引用数据类型](#引用数据类型)\r\n  - [数组](#数组)\r\n  - [在内存中的占用情况](#在内存中的占用情况)\r\n- [方法](#方法)\r\n  - [定义、调用](#定义调用)\r\n  - [方法在内存中的调用流程](#方法在内存中的调用流程)\r\n  - [方法参数传递机制](#方法参数传递机制)\r\n  - [方法重载](#方法重载)\r\n- [基础知识巩固练习案例](#基础知识巩固练习案例)\r\n  - [买飞机票算票价](#买飞机票算票价)\r\n  - [找素数](#找素数)\r\n  - [生成验证码](#生成验证码)\r\n  - [数字加密](#数字加密)\r\n  - [双色球系统案例](#双色球系统案例)\r\n- [面向对象](#面向对象)\r\n  - [类](#类)\r\n  - [构造器](#构造器)\r\n  - [this关键字](#this关键字)\r\n  - [封装](#封装)\r\n  - [标准javaBean实体类](#标准javabean实体类)\r\n  - [成员变量和局部变量的区别](#成员变量和局部变量的区别)\r\n  - [对象数组在内存中的占用情况](#对象数组在内存中的占用情况)\r\n- [String字符串类及其常用API](#string字符串类及其常用api)\r\n  - [相关概念](#相关概念)\r\n  - [APis](#apis)\r\n    - [构造器](#构造器-1)\r\n    - [常用成员方法](#常用成员方法)\r\n  - [案例](#案例)\r\n- [ArraryList集合容器类及其常用API](#arrarylist集合容器类及其常用api)\r\n  - [相关概念](#相关概念-1)\r\n  - [APIs](#apis-1)\r\n    - [构造器](#构造器-2)\r\n    - [常用成员方法](#常用成员方法-1)\r\n  - [一些案例](#一些案例)\r\n- [面向对象高级](#面向对象高级)\r\n  - [static关键字](#static关键字)\r\n  - [代码块](#代码块)\r\n  - [继承extends](#继承extends)\r\n  - [继承后的方法重写](#继承后的方法重写)\r\n  - [继承后子类构造器的特点](#继承后子类构造器的特点)\r\n  - [this和super的使用](#this和super的使用)\r\n- [单例设计模式](#单例设计模式)\r\n  - [设计模式](#设计模式)\r\n  - [饿汉单例](#饿汉单例)\r\n  - [懒汉单例模式](#懒汉单例模式)\r\n- [包Package](#包package)\r\n- [权限修饰符](#权限修饰符)\r\n- [final修饰符](#final修饰符)\r\n- [常量](#常量)\r\n- [枚举](#枚举)\r\n- [抽象类、抽象方法](#抽象类抽象方法)\r\n  - [final和abstract关系](#final和abstract关系)\r\n- [接口](#接口)\r\n- [多态](#多态)\r\n  - [抽象类的多态实现测试](#抽象类的多态实现测试)\r\n- [内部类](#内部类)\r\n  - [静态内部类](#静态内部类)\r\n  - [成员内部类](#成员内部类)\r\n  - [局部内部类](#局部内部类)\r\n  - [匿名内部类【重点】](#匿名内部类重点)\r\n- [Object类及其常用APIs](#object类及其常用apis)\r\n  - [toString()](#tostring)\r\n  - [equals(Object)](#equalsobject)\r\n- [Objects类及其常用APIs](#objects类及其常用apis)\r\n  - [Objects.equals](#objectsequals)\r\n  - [Objects.inNull](#objectsinnull)\r\n- [StringBuilder类及其常用APIs](#stringbuilder类及其常用apis)\r\n  - [StringBuilder()构造器](#stringbuilder构造器)\r\n  - [append(任意类型)](#append任意类型)\r\n  - [reverse()](#reverse)\r\n  - [length()](#length)\r\n  - [toString()](#tostring-1)\r\n  - [测试](#测试)\r\n- [Math类及其常用APIs](#math类及其常用apis)\r\n  - [常用APIs](#常用apis)\r\n- [System类及其常用APIs](#system类及其常用apis)\r\n  - [常用APIs](#常用apis-1)\r\n- [BigDecimal类及其常用APIs](#bigdecimal类及其常用apis)\r\n  - [BigDecimal构造函数](#bigdecimal构造函数)\r\n  - [常用APIs](#常用apis-2)\r\n  - [精度问题](#精度问题)\r\n  - [二次封装](#二次封装)\r\n- [Date日期对象及常用APIs](#date日期对象及常用apis)\r\n  - [构造器](#构造器-3)\r\n  - [常用方法](#常用方法)\r\n- [SimpleDateFormat 日期对象及常用APIs](#simpledateformat-日期对象及常用apis)\r\n  - [构造器](#构造器-4)\r\n  - [常用方法](#常用方法-1)\r\n- [Calendar 日历对象及常用APIs](#calendar-日历对象及常用apis)\r\n  - [APIs](#apis-2)\r\n- [JDK8新增时间类](#jdk8新增时间类)\r\n  - [`LocalDate`、`LocalTime`、`LocalDateTime`类及其APIs](#localdatelocaltimelocaldatetime类及其apis)\r\n    - [构造函数](#构造函数)\r\n    - [常用成员函数APIs](#常用成员函数apis)\r\n  - [`Instant`类及APIs](#instant类及apis)\r\n    - [Instant创建实例对象](#instant创建实例对象)\r\n    - [一些方法](#一些方法)\r\n  - [`Instant`类及APIs](#instant类及apis-1)\r\n    - [实例化](#实例化)\r\n    - [方法](#方法-1)\r\n  - [Period类](#period类)\r\n  - [Duration类](#duration类)\r\n  - [ChronoUnit类](#chronounit类)\r\n- [包装类](#包装类)\r\n- [正则表达式](#正则表达式)\r\n  - [API](#api)\r\n  - [正则语法](#正则语法)\r\n  - [案例测试](#案例测试)\r\n- [Arrays数组的工具类](#arrays数组的工具类)\r\n  - [tostring](#tostring-2)\r\n  - [sort](#sort)\r\n  - [自定义sort排序](#自定义sort排序)\r\n  - [binarySearch二分查找](#binarysearch二分查找)\r\n- [Lambda表达式](#lambda表达式)\r\n- [Collection集合](#collection集合)\r\n  - [Collection集合概念](#collection集合概念)\r\n  - [Collection集合常用API](#collection集合常用api)\r\n  - [Collection集合遍历](#collection集合遍历)\r\n    - [迭代器](#迭代器)\r\n    - [加强版for循环](#加强版for循环)\r\n    - [结合forEach方法和lambda表达式](#结合foreach方法和lambda表达式)\r\n  - [List系列的集合](#list系列的集合)\r\n    - [ArrayList](#arraylist)\r\n    - [LinkedList](#linkedlist)\r\n    - [迭代时删除元素的问题](#迭代时删除元素的问题)\r\n  - [Set系列集合](#set系列集合)\r\n    - [HashSet](#hashset)\r\n    - [LinkedHashSet](#linkedhashset)\r\n    - [TreeSet](#treeset)\r\n- [可变参数](#可变参数)\r\n- [集合的工具类：Collections类](#集合的工具类collections类)\r\n- [扑克牌洗牌分牌](#扑克牌洗牌分牌)\r\n- [泛型](#泛型)\r\n  - [自定义泛型类](#自定义泛型类)\r\n  - [自定义泛型方法](#自定义泛型方法)\r\n  - [自定义泛型接口](#自定义泛型接口)\r\n  - [泛型通配符](#泛型通配符)\r\n- [Map集合](#map集合)\r\n  - [概念](#概念)\r\n  - [API](#api-1)\r\n  - [特点](#特点)\r\n  - [遍历](#遍历)\r\n  - [案例](#案例-1)\r\n  - [集合和Map的嵌套](#集合和map的嵌套)\r\n- [不可变集合](#不可变集合)\r\n- [Stream流](#stream流)\r\n  - [概念](#概念-1)\r\n  - [获取Stream流](#获取stream流)\r\n  - [Stream的常用中间方法](#stream的常用中间方法)\r\n  - [Stream的常用终极方法](#stream的常用终极方法)\r\n  - [Stream流的收集](#stream流的收集)\r\n  - [案例](#案例-2)\r\n- [异常处理](#异常处理)\r\n  - [概念](#概念-2)\r\n  - [常见异常](#常见异常)\r\n  - [默认异常处理机制](#默认异常处理机制)\r\n  - [处理异常](#处理异常)\r\n  - [自定义异常](#自定义异常)\r\n  - [案例](#案例-3)\r\n- [日志框架](#日志框架)\r\n  - [概念](#概念-3)\r\n  - [日志框架体系结构](#日志框架体系结构)\r\n- [Logback日志框架](#logback日志框架)\r\n  - [概念](#概念-4)\r\n  - [使用与配置](#使用与配置)\r\n- [电影商城实现](#电影商城实现)\r\n- [字符集编码解码](#字符集编码解码)\r\n- [File文件](#file文件)\r\n  - [构造器](#构造器-5)\r\n  - [常用方法](#常用方法-2)\r\n- [流](#流)\r\n  - [基础IO流](#基础io流)\r\n    - [FileInputStream](#fileinputstream)\r\n    - [FileOutputStream](#fileoutputstream)\r\n    - [FileReader](#filereader)\r\n    - [FileWriter](#filewriter)\r\n  - [缓冲IO流](#缓冲io流)\r\n    - [缓冲文件流 BufferedOutputStream BufferedInputStream](#缓冲文件流-bufferedoutputstream-bufferedinputstream)\r\n    - [缓冲字符流 BufferedReader BufferedWriter](#缓冲字符流-bufferedreader-bufferedwriter)\r\n    - [字符输入/输出转换流](#字符输入输出转换流)\r\n  - [对象序列化(对象字节输出流)](#对象序列化对象字节输出流)\r\n  - [打印流](#打印流)\r\n  - [Properties属性集对象](#properties属性集对象)\r\n  - [IO框架：commons-io](#io框架commons-io)\r\n- [中文进制转十进制](#中文进制转十进制)\r\n- [多线程](#多线程)\r\n  - [方法1: **继承**`Thread类`](#方法1-继承thread类)\r\n  - [**方法2**：**实现**`Runnable接口`](#方法2实现runnable接口)\r\n  - [方法3：实现`Callable接口`](#方法3实现callable接口)\r\n  - [Thread类](#thread类)\r\n- [线程安全问题](#线程安全问题)\r\n  - [synchronized同步](#synchronized同步)\r\n    - [synchronized同步代码块](#synchronized同步代码块)\r\n    - [synchronized同步方法](#synchronized同步方法)\r\n  - [Lock锁](#lock锁)\r\n  - [线程通信](#线程通信)\r\n- [线程池](#线程池)\r\n  - [概念](#概念-5)\r\n  - [实现类ThreadPoolExecutor](#实现类threadpoolexecutor)\r\n  - [Executors工具类创建线程池](#executors工具类创建线程池)\r\n- [定时器](#定时器)\r\n  - [Timer定时器](#timer定时器)\r\n  - [ScheduledExecutorService定时器](#scheduledexecutorservice定时器)\r\n- [并发与并行](#并发与并行)\r\n  - [Thread线程生命周期6种状态](#thread线程生命周期6种状态)\r\n- [网络编程](#网络编程)\r\n  - [InetAddress的使用](#inetaddress的使用)\r\n  - [UDP数据包](#udp数据包)\r\n  - [DatagramSocket通信接口对象](#datagramsocket通信接口对象)\r\n  - [UDP的单播、组播、广播](#udp的单播组播广播)\r\n  - [TCP](#tcp)\r\n    - [Socket类](#socket类)\r\n    - [ServerSocket类](#serversocket类)\r\n    - [TCP通信测试：连接的建立与通信](#tcp通信测试连接的建立与通信)\r\n    - [TCP通信测试：服务端通过临时创建子线程服务多个客户端](#tcp通信测试服务端通过临时创建子线程服务多个客户端)\r\n  - [TCP通信测试：服务端通过线程池服务多个客户端](#tcp通信测试服务端通过线程池服务多个客户端)\r\n  - [TCP通信测试：实现简易群聊](#tcp通信测试实现简易群聊)\r\n  - [TCP通信测试：简易BS架构原理测试](#tcp通信测试简易bs架构原理测试)\r\n- [单元测试：Junit单元测试框架](#单元测试junit单元测试框架)\r\n- [反射](#反射)\r\n  - [获取Class对象](#获取class对象)\r\n  - [获取Class对象的构造器函数](#获取class对象的构造器函数)\r\n  - [使用获取到的构造函数创建对象](#使用获取到的构造函数创建对象)\r\n  - [获取Class类的属性对象](#获取class类的属性对象)\r\n  - [使用获取到的属性对象修改实例对象的属性值](#使用获取到的属性对象修改实例对象的属性值)\r\n  - [获取Class类的方法](#获取class类的方法)\r\n  - [通过获取到的类的方法来执行实例对象的方法](#通过获取到的类的方法来执行实例对象的方法)\r\n  - [应用：存储任意对象的属性值到文件](#应用存储任意对象的属性值到文件)\r\n- [注解](#注解)\r\n  - [自定义注解](#自定义注解)\r\n  - [元注解](#元注解)\r\n  - [注解的解析](#注解的解析)\r\n- [结合`反射`和`注解`实现简易`junit框架`](#结合反射和注解实现简易junit框架)\r\n- [对象的动态代理](#对象的动态代理)\r\n- [XML](#xml)\r\n  - [概述](#概述-1)\r\n  - [解析](#解析)\r\n    - [Dom4J](#dom4j)\r\n  - [检索:xPath](#检索xpath)\r\n- [工厂设计模式](#工厂设计模式)\r\n- [装饰设计模式](#装饰设计模式)\r\n\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>显示/隐藏\r\n\r\n## 学习及笔记更新日志\r\n</summary>\r\n\r\n+ 10月22日 73/200集 73集 概述 环境搭建 执行原理 注释 字面量 变量 数据类型 关键字 标识符 自动及强制类型转换 运算符 键盘录入 顺序分支循环 数组 方法 方法内存原理 方法值传递机制 方法重载 案例\r\n+ 10月23日 100/200集 27集 面向对象 面向对象内存机制 构造器 this ArrayList String常量与变量 ArrayList遍历 ATM系统项目实现 修饰符 工具类 代码块 static 单例模式\r\n+ 10月24日 110/200集 10集 继承 包 权限修饰符 final 常量 枚举 抽象类 接口 多态 内部类 匿名内部类 \r\n+ 10月25日 117/200集 7集 Objets工具类 StringBuilder Math System BigDecimal Date SimpleDateFormate Calendar JDK8新增日期API\r\n+ 10月26日 124/200集 7集 正则表达式 Arrays 选择排序 二分查找 Lambda表达式 集合Collection 集合遍历\r\n+ 10月27日 131/200集 7集 List 泛型 自定义泛型 泛型通配符 泛型上下限 Set集合 可变参数 集合操作工具类Collections\r\n+ 10月28日 136/200集 5集 洗牌发牌系统案例 Map集合 MapAPI Map遍历 Map其他实现类 集合嵌套 不可变集合 Stream流 异常分类 异常处理机制 自定义异常  \r\n+ 10月29日 147/200集 11集 Logback日志框架 电影商城项目\r\n+ 10月30日 152/200集 5集  文件 方法递归 文件搜索 IO流 文件字节输入流 \r\n+ 10月31日 157/200集 5集 文件字节输出流 缓冲流 字节缓冲流 \r\n+ 11月1日  166/200集 9集 对象序列化 反序列化 打印流 Properties commons-io 线程三种创建方式 线程方法 线程安全问题 线程同步 同步代码块 同步方法 同步锁 线程通信 线程池  \r\n+ 11月2日  175/200集 9集  线程池处理Runnable任务 线程池处理Callable任务 Executors工具类构建线程池对象 定时器 线程并发 并行 线程生命周期6种状态 网络通信 UDP单播广播组播 TCP通信结合线程池 TCP即时通讯案例 BS架构模拟\r\n+ 11月3日  187/200集 12集 Junit框架单元测试 反射获取类对象 反射获取类属性 反射获取类方法 反射获取类构造器 反射修改类属性 反射调用类方法 反射执行类构造器\r\n+ 11月4日  200/200集 13集 注解 自定义注解 元注解 注解解析 使用注解和反射实现junit框架 动态代理 XML XML文档约束 Dom4J XPath 工厂设计模式 装饰设计模式 \r\n\r\n</details>\r\n\r\n\r\n## 概述\r\n![](./images/java学习笔记/2022-10-22-08-32-16.png)\r\n\r\n![](./images/java学习笔记/2022-10-22-08-33-28.png)\r\n\r\n![](./images/java学习笔记/2022-10-22-08-36-55.png)\r\n\r\n![](./images/java学习笔记/2022-10-22-08-38-00.png)\r\n\r\n![](./images/java学习笔记/2022-10-22-08-40-13.png)\r\n\r\n## 基础语法\r\n\r\n### 注释\r\n```java\r\n// 单行注释\r\n/*\r\n    多行注释\r\n    多行注释\r\n    多行注释\r\n    多行注释\r\n */\r\n/**\r\n    文档注释\r\n    @param\t说明一个方法的参数，一般用于方法注释\t@param parameter-name explanation\r\n    @return\t说明返回值类型，一般用于方法注释，不能出现再构造方法中\t@return explanation\r\n    @author\t标识一个类的作者，一般用于类注释\r\n    @version\t指定类的版本，一般用于类注释\t@version info\r\n */\r\n```\r\n\r\n### 字面量\r\n* 数值 `123` `-321`\r\n  * 二进制 `0B11111111` => `255` `0B11111111111111111111111111111111` => `-1`\r\n  * 八进制 `0777` `0001`\r\n  * 十六进制 `0xff` `0X01`\r\n* 浮点数 `1.23` \r\n* 字符 `'a'` =>97 `'A'` =>65 `'0'` =>48  `'\\n'` `'\\t'` `'汉'`\r\n* 字符串 `\"123\"` `\"ABC\"`\r\n* 布尔值 `true` `false`\r\n* 空值 `null`\r\n\r\n### 基本数据类型\r\n* **整型** byte(1B) short(2B) int(4B,默认) long(8B)\r\n* **浮点型** float(4B) double(8B,默认)\r\n* **字符** <gold>char(2B)</gold>\r\n* **布尔** boolean(1B)\r\n\r\n* 注意点\r\n  * 变量先声明后使用\r\n  * 变量声明可无初值，**使用时必须有初值**\r\n  * 变量不能存储和声明类型不一致的数据\r\n  * <green>同一作用域及其 **子作用域** **不能有两同名变量**</green>\r\n\r\n### 标识符命名要求\r\n* 组成：字母+数字+**下划线**+**美元符**\r\n* 不能以数字开头，不能是关键字\r\n* 命名规范\r\n    * 变量名：小驼峰命名法\r\n    * 类名：大驼峰命名法\r\n\r\n## 类型转换 \r\n\r\n### 自动类型转换\r\n* **赋值时的自动类型转换：根据所占存储空间小转大：** \r\n  * byte -> short -> int -> long -> float -> double\r\n  * <green>char -> int<green>\r\n  * <warn>char -x-> float</warn>\r\n* 在表达式运算过程中的自动类型转换\r\n  * byte、short、char =(直接)=> int -> long -> float -> double\r\n```java\r\n    byte a = 1 , b = 2;\r\n    byte c = a + b; //报错\r\n    int d = a + b; //不报错\r\n```\r\n\r\n### 强制类型转换\r\n* 整型间强转：**截取低位字节**直接赋值，可能导致数据丢失\r\n* 浮点型间强转：丢掉小数部分，保留整数部分然后按**整型间强转**赋值 99.5 -> 99\r\n* \r\n![](./images/java学习笔记/2022-10-22-13-27-17.png)\r\n\r\n##  运算符\r\n### 算数运算符\r\n* 加 +\r\n* 减 -\r\n* 乘 *\r\n* 除 / 整型间相除结果仍是整型 \r\n* 余 %\r\n\r\n### 字符串连接运算符\r\n```java\r\nSystem.out.println(\"hhhh\"+\"xx\") //结果: \"hhhhxx\"\r\nSystem.out.println(\"hhhh\"+'x')  //结果: \"hhhhx\"\r\nSystem.out.println(\"hhhh\"+ 5 )  //结果: \"hhhh5\"\r\n```\r\n\r\n### 自增自减运算符\r\n```java\r\nint c = 10;\r\nint d = 5;\r\nint result = c++ + ++c - --d - ++d + 1 + c--;\r\nSystem.out.println(result);\r\n//c 10 11 12    13\r\n//d 5        4\r\n//r = 10 + 12 - 4 + 1 + 12 = 26\r\n```\r\n\r\n\r\n### 赋值运算符\r\n**基本赋值运算符**\r\n```java\r\na = 1;\r\n```\r\n\r\n**扩展运算符**：<gold>自带强制转换功能</gold>\r\n```java\r\na += 1; // 等价于 a = a(a的数据类型) + 1\r\na -= 1; // 等价于 a = a(a的数据类型) - 1\r\na *= 1; // 等价于 a = a(a的数据类型) * 1\r\na /= 1; // 等价于 a = a(a的数据类型) / 1\r\na %= 1; // 等价于 a = a(a的数据类型) % 1\r\n```\r\n\r\n\r\n```java\r\nbyte result = 1 ;\r\nbyte step = 1 ;\r\nresult =  result + step ; //报错，右侧结果为int类型，左侧变量为byte类型\r\nresult = (byte) ( result + step );//不报错\r\nresult += step;//不报错，和上面等效\r\n```\r\n\r\n### 关系运算符(条件运算符)\r\n```java\r\n/*\r\n    a == b\r\n    a != b\r\n    a >= b\r\n    a <= b\r\n    a >  b\r\n    a <  b\r\n*/\r\n```\r\n\r\n\r\n### 逻辑运算符\r\n```java\r\n/*\r\n    & 逻辑 与       左右两边都会执行\r\n    | 逻辑 或       左右两边都会执行\r\n    ! 逻辑 非       左右两边都会执行\r\n    ^ 逻辑 异或     左右两边都会执行\r\n\r\n    && 逻辑 与      左边false则不执行右边(短路)\r\n    || 逻辑 或      左边true 则不执行右边(短路)\r\n*/\r\n```\r\n\r\n### 三元运算符\r\n```java\r\nboolean result = (条件表达式)? 表达式1 : 表达式2 ;\r\n```\r\n\r\n### 运算符优先级\r\n![](./images/java学习笔记/2022-10-22-14-17-37.png)\r\n\r\n\r\n## 键盘录入API\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Scanner;//导入包\r\n\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);//创建scanner实例\r\n\r\n        System.out.println(\"请输入年龄\");\r\n        int age = sc.nextInt();//调用相关函数\r\n\r\n        System.out.println(\"请输入姓名\");\r\n        String name = sc.next();\r\n\r\n        System.out.println(\"你的姓名是：\" + name);\r\n        System.out.println(\"你的年龄是：\" + age);\r\n    }\r\n}\r\n```\r\n\r\n## 流程控制\r\n* 顺序：默认\r\n* 分支(选择)： `if` `switch` \r\n* 循环：`for(;;){}` `while(){}` `do{}while();` \r\n\r\n### 分支\r\n\r\n**if**\r\n\r\n```java\r\nif(){\r\n\r\n}else if(){\r\n\r\n}else{\r\n\r\n}\r\n```\r\n**switch**\r\n* `switch(表达式)` 表达式只能是byte char short int 枚举(jdk5) string(jdk7) \r\n* `switch(表达式)` 表达式不能是long float double\r\n* `case 值:` 中的值只能是字面量\r\n```java\r\nswitch(表达式){//表达式只能是byte char short int 枚举(jdk5) string(jdk7) 不能是：long float double\r\n    case 字面量://只能是字面量\r\n        语句;\r\n        break;//跳出switch执行\r\n    default:\r\n        语句;\r\n        break;\r\n}\r\n```\r\n\r\n```java\r\npackage com.yiguiding.package1;\r\nimport java.util.Scanner;\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        int month =  sc.nextInt();\r\n        switch (month) {\r\n            case 1:\r\n            case 3:\r\n            case 5:\r\n            case 7:\r\n            case 8:\r\n            case 10:\r\n            case 12:\r\n                System.out.println(\"32天\");\r\n                break;\r\n            case 4:\r\n            case 6:\r\n            case 9:\r\n            case 11:\r\n                System.out.println(\"30天\");\r\n                break;\r\n            case 2:\r\n                System.out.println(\"瑞年29天，非瑞年28天\");\r\n                break;\r\n            default:\r\n                System.out.println(\"输入月份不正确\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 循环\r\n\r\nfor\r\n```java\r\nfor(int i = 0; i<100 ;i++){\r\n\r\n}\r\n```\r\n\r\nwhile\r\n```java\r\nwhile(){\r\n\r\n}\r\n```\r\n\r\ndo...while();\r\n```java\r\ndo{\r\n\r\n}while();\r\n```\r\n\r\nbreak;continue;\r\n\r\n```java\r\ncontinue;//跳出本次循环，进入下一次循环\r\nbreak;//跳出并结束本次循环\r\n```\r\n\r\n\r\n## 随机数\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;//导包\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Random random = new Random();//实例化\r\n        System.out.println(random.nextInt(5,11));//获取5-10的随机数\r\n        System.out.println(random.nextInt(11));//获取0-10的随机数\r\n        System.out.println(random.nextInt(10)+1);//获取1-10的随机数\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 引用数据类型\r\n### 数组\r\n\r\n数组是引用数据类型，数组变量名存的是数组在内存中的地址。\r\n![](./images/java学习笔记/2022-10-22-15-17-19.png)\r\n\r\n**静态初始化：数组长度固定**\r\n```java\r\n// 完整写法\r\n    int[] scores = new int[]{123,456,789,101,102,103};//等效写法\r\n    int scores[] = new int[]{123,456,789,101,102,103};//等效写法\r\n// 简化写法\r\n    int[] scores = {123,456,789,101,102,103};//等效写法\r\n    int scores[] = {123,456,789,101,102,103};//等效写法\r\n```\r\n\r\n**动态初始化：数组长度可在程序中指定**\r\n```java\r\n// 完整写法\r\n    int[] empty = new int[10];\r\n    int empty[] = new int[10];\r\n// 简化写法：没有简化写法！！！\r\n    int[10] score;//错误写法\r\n    int score[10];//错误写法\r\n```\r\n\r\n**数组静态初始化和动态初始化写法相互独立不可混用**\r\n```java\r\nint[] score = new int[10]{123,456,789,101,102,103};//错误写法\r\n```\r\n\r\n\r\n**动态初始化数组元素的初始值**：\r\n* 数值型初始值： `0`\r\n* 浮点型初始值： `0.0`\r\n* `boolean`初始值： `false`\r\n* 引用类型初始值： `null`\r\n\r\n![](./images/java学习笔记/2022-10-22-15-50-47.png)\r\n\r\n\r\n**访问数组元素**\r\n```java\r\npackage com.yiguiding.package1;\r\nimport java.util.Random;\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Random random = new Random();\r\n        int[] score = new int[10];\r\n        for (int i = 0; i < score.length; i++) {\r\n            score[i] = random.nextInt(10);\r\n        }\r\n        for (int i = 0; i < score.length; i++) {\r\n            System.out.println(score[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**案例:输入一组数，按随机顺序输出这组数**\r\n方法1：\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        //案例：输入一组数，按随机顺序输出这组数\r\n        Scanner sc = new Scanner(System.in);\r\n        Random random = new Random();//实例化\r\n        int[] arr= new int[5];\r\n        for (int i = 0; i < arr.length; i++) {\r\n            System.out.println(\"请输入第\"+i+1+\"位员工的工号：\");\r\n            arr[i] = sc.nextInt();\r\n        }\r\n        System.out.println(\"员工上台演讲的顺序为：\");\r\n        for (int i = 0; i < arr.length; i++) {\r\n            while (true){\r\n                int index = random.nextInt(arr.length);\r\n                if (arr[index]!=-1){\r\n                    System.out.println(arr[index]);\r\n                    arr[index] = -1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n方法2：\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        //案例：输入一组数，按随机顺序输出这组数\r\n        Scanner sc = new Scanner(System.in);\r\n        Random random = new Random();//实例化\r\n        int[] arr= new int[5];\r\n        for (int i = 0; i < arr.length; i++) {\r\n            System.out.println(\"请输入第\"+i+1+\"位员工的工号：\");\r\n            arr[i] = sc.nextInt();\r\n        }\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            //获取随机两个下标\r\n            int indexA = random.nextInt(arr.length);\r\n            int indexB = random.nextInt(arr.length);\r\n            //交换\r\n            int temp = arr[indexA];\r\n            arr[indexA] = arr[indexB];\r\n            arr[indexB] = temp;\r\n        }\r\n        System.out.println(\"员工上台演讲的顺序为：\");\r\n        for (int i = 0; i < arr.length; i++) {\r\n            System.out.println(arr[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 在内存中的占用情况\r\n**内存区域**\r\n* 栈内存：正在执行的函数、变量\r\n* 堆内存：动态分配内存时所使用的内存区域，`new object[100]`\r\n* 方法区：程序运行时，编译后的字节码文件被加载到的区域\r\n* 本地方法区:\r\n* 寄存器:\r\n\r\n**栈、堆、方法区在程序运行过程中的使用情况**\r\n![](./images/java学习笔记/2022-10-22-16-29-56.png)\r\n\r\n\r\n**两个数组指向同一个数组对象**\r\n\r\n![](./images/java学习笔记/2022-10-22-16-32-54.png)\r\n\r\n\r\n\r\n## 方法\r\n\r\n### 定义、调用\r\n* 形参列表可有可无\r\n* 方法需严格按照形参类型传入值\r\n* 方法不需要返回值则返回类型可为void，此时则不能使用return语句;\r\n* 方法的定义顺序无所谓\r\n* 方法不能嵌套定义\r\n```java\r\n/* 格式\r\n修饰符 返回值类型 方法名(形参列表){\r\n    // 代码\r\n    return 返回值;\r\n}\r\n*/\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(sum(1,5));\r\n    }\r\n    public static int sum(int a,int b) {\r\n        return a + b;\r\n    }\r\n}\r\n```\r\n\r\n### 方法在内存中的调用流程\r\n![](./images/java学习笔记/2022-10-22-17-16-04.png)\r\n\r\n\r\n### 方法参数传递机制\r\n形式参数传递机制：值传递\r\n* 基本数据类型：传递值\r\n* 引用数据类型：传递地址\r\n\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        int[] arr1 = {111,222,333,444};\r\n        int[] arr2 = {111,222,333,444};\r\n        System.out.println(compareArrList(arr1,arr2));\r\n    }\r\n    public static boolean compareArrList(int[] arr1,int[] arr2){\r\n        if(arr1==null || arr2==null)//任意一个是空值都判断为不等\r\n            return false;\r\n        if (arr1 == arr2)//比较地址是否相同\r\n            return true;\r\n        if (arr1.length == arr2.length){\r\n            for (int i = 0; i < arr1.length; i++) {\r\n                if (arr1[i] != arr2[i])\r\n                    return false;\r\n            }\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 方法重载\r\n方法名称相同形参列表不同\r\n\r\n![](./images/java学习笔记/2022-10-22-17-41-32.png)\r\n\r\n\r\n## 基础知识巩固练习案例\r\n\r\n### 买飞机票算票价\r\n![](./images/java学习笔记/2022-10-22-18-06-18.png)\r\n```java\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Scanner scanner = new Scanner(System.in);\r\n        double price=0.0;\r\n        int month=1;\r\n        int type=2;\r\n        double result = 0.0;\r\n        do {\r\n            System.out.println(\"请输入机票原价格：\");\r\n            price = scanner.nextDouble();\r\n            System.out.println(\"请输入当前月份：(1-12)\");\r\n            month = scanner.nextInt();\r\n            System.out.println(\"请输入仓位类型：1.头等舱；2.经济舱：(1-2)\");\r\n            type = scanner.nextInt();\r\n        }while (price<=0 || month< 1 || month >12 || !( type==1 || type==2) );\r\n\r\n        if (5 <= month && month <= 10){//旺季\r\n            if (type == 1)//头等舱\r\n                result = 0.9 * price;\r\n            else //经济舱\r\n                result = 0.85 * price;\r\n        } else {//淡季\r\n            if (type == 1)//头等舱\r\n                result = 0.7 * price;\r\n            else //经济舱\r\n                result = 0.65 * price;\r\n        }\r\n        System.out.println(\"你的机票价格为：\"+result);\r\n    }\r\n}\r\n```\r\n\r\n### 找素数\r\n![](./images/java学习笔记/2022-10-22-18-07-51.png)\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n//        Scanner scanner = new Scanner(System.in);\r\n        int count = 0;\r\n        for (int i = 101; i <= 200; i++) {\r\n            if (isPrime(i)){\r\n                System.out.print(i + \"\\t\");\r\n                count++;\r\n            }\r\n        }\r\n        System.out.println(\"\\n共有素数\" + count + \"个\");\r\n    }\r\n    public static boolean isPrime(int num){\r\n        if (num <= 2)\r\n            return false;\r\n        int sqrt = (int)Math.sqrt(num);\r\n        for (int i = 2; i <= sqrt; i++) {\r\n            if (num%i == 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n结果\r\n![](./images/java学习笔记/2022-10-22-18-17-10.png)\r\n\r\n\r\n### 生成验证码\r\n![](./images/java学习笔记/2022-10-22-18-30-17.png)\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(creatCode(5));\r\n    }\r\n    public static String creatCode(int length){\r\n        String code = \"\";\r\n        Random rd = new Random();\r\n        for (int i = 0; i < length; i++) {\r\n            switch (rd.nextInt(3)){//随机0-2\r\n                case 0:\r\n                    code+=(char)(rd.nextInt('A','Z') + 1);//随机获取一个大写字母并拼接给code\r\n                    break;\r\n                case 1:\r\n                    code+=(char)(rd.nextInt('a','z') + 1);//随机获取一个小写字母并拼接给code\r\n                    break;\r\n                case 2:\r\n                    code+=(char)(rd.nextInt('0','9') + 1);\r\n                    break;\r\n            }\r\n        }\r\n        return code;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 数字加密\r\n![](./images/java学习笔记/2022-10-22-18-36-17.png)\r\n\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        int[] arr = {1,9,8,3};\r\n        printArrList(arr);//输出\r\n        enCode(arr);//加密\r\n        printArrList(arr);//输出\r\n        enCode(arr);//再次加密就是解密\r\n        printArrList(arr);//输出\r\n\r\n    }\r\n    public static int[] enCode(int[] arrList){\r\n        for (int i = 0; i < arrList.length; i++) {\r\n            arrList[i] = (arrList[i] + 5) % 10 ;\r\n        }\r\n        return reverse(arrList);\r\n    }\r\n    public static int[] reverse(int[] arrList){//翻转\r\n        for (int i = 0,j=arrList.length-1; i < arrList.length/2; i++,j--) {\r\n            int temp = arrList[i];\r\n            arrList[i] = arrList[j];\r\n            arrList[j] = temp;\r\n        }\r\n        return arrList;\r\n    }\r\n    public static void printArrList(int[] arrList){\r\n        System.out.print('[');\r\n        if (arrList != null && arrList.length != 0){\r\n            for (int i = 0; i < arrList.length; i++) {\r\n                System.out.print( (i == arrList.length-1)? arrList[i] : arrList[i]+\",\");\r\n            }\r\n        }\r\n        System.out.println(']');\r\n    }\r\n}\r\n\r\n```\r\n输出\r\n![2022-10-23-02-55](./images/java学习笔记/2022-10-22-18-54-32.png)\r\n\r\n\r\n### 双色球系统案例\r\n![](./images/java学习笔记/2022-10-23-03-44-25.png)\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        int count = 0;\r\n        int[] users = createLuckNumbers();//守号\r\n        while (true){\r\n            count++;\r\n            int[] gen = createLuckNumbers();//开奖\r\n            System.out.println(\"开奖号码：\");\r\n            printArrList( gen );//输出\r\n            System.out.println(\"你的号码：\");\r\n            printArrList( users );//输出\r\n            int result = luckType(gen,users);//返回是几等奖\r\n            if (result<=2){//若中了1或2等奖则输出\r\n                System.out.println(\"连续购买\"+ count +\"次,恭喜获得\"+result+\"等奖\");\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    public static int[] createLuckNumbers(){\r\n        int[] luckNumbers = new int[6+1];//用于存放6个红球1个蓝球的空间\r\n        int[] reds = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33};//红球33个\r\n        int[] blues = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};//蓝球16个\r\n        Random rd = new Random();\r\n        for (int i = 0; i < luckNumbers.length-1; i++) {//随机选六个红球\r\n            while (true){\r\n                int index = rd.nextInt(reds.length);\r\n                if (reds[index]!=-1){//判断是否已经被拿出\r\n                    luckNumbers[i] = reds[index];//拿出红球\r\n                    reds[index] = -1;//标记为已经拿出\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        while (true){//随机选一个个篮球\r\n            int index = rd.nextInt(blues.length);\r\n            if (blues[index]!=-1){//判断是否已经被拿出\r\n                luckNumbers[luckNumbers.length-1] = blues[index];//拿出蓝球,放到最后一个位置\r\n                reds[index] = -1;//标记为已经拿出\r\n                break;\r\n            }\r\n        }\r\n        return luckNumbers;\r\n    }\r\n    public static int luckType(int[] luckNumsTarget,int[] luckNumsUsers){\r\n        int countRed = 0;//记录红球一致个数\r\n        int countBlue = 0;//记录蓝球一致个数\r\n        for (int i = 0; i < luckNumsUsers.length-1; i++) {\r\n            for (int j = 0; j < luckNumsTarget.length-1; j++) {\r\n                if (luckNumsUsers[i] == luckNumsTarget[j])\r\n                    countRed++;\r\n            }\r\n        }\r\n        if (luckNumsUsers[luckNumsUsers.length-1] == luckNumsTarget[luckNumsTarget.length-1]){//判断最后一个球是不是一致\r\n            countBlue ++;\r\n        }\r\n        if (countRed == 6 && countBlue == 1)\r\n            return  1;//一等奖\r\n\r\n        if (countRed == 6 && countBlue == 0)\r\n            return 2;//二等奖\r\n\r\n        if (countRed == 5 && countBlue == 1)\r\n            return 3;//三等奖\r\n\r\n        if (countRed == 5 && countBlue == 0)\r\n            return 4;//四等奖\r\n        if (countRed == 4 && countBlue == 1)\r\n            return 4;//四等奖\r\n\r\n        if (countRed == 4 && countBlue == 0)\r\n            return 5;//五等奖\r\n        if (countRed == 3 && countBlue == 1)\r\n            return 5;//五等奖\r\n        if (countRed == 2 && countBlue == 1)\r\n            return 5;//五等奖\r\n\r\n        if (countRed == 1 && countBlue == 1)\r\n            return 6;//六等奖\r\n        if (countRed == 0 && countBlue == 1)\r\n            return 6;//六等奖\r\n        else\r\n            return 7;//未中奖\r\n    }\r\n    public static void printArrList(int[] arrList){\r\n        System.out.print('[');\r\n        if (arrList != null && arrList.length != 0){\r\n            for (int i = 0; i < arrList.length; i++) {\r\n                System.out.print( (i == arrList.length-1)? arrList[i] : arrList[i]+\",\");\r\n            }\r\n        }\r\n        System.out.println(']');\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-10-23-03-45-25.png)\r\n\r\n\r\n## 面向对象\r\n\r\n### 类\r\n* **类是对象的设计图**\r\n* **对象是根据设计图创建出的实体**\r\n* **注意**：\r\n    * <green>一个java文件中可以定义多个类，但只能有一个public类</green>\r\n    * <green>public修饰的类名必须为java的文件名</green>\r\n    * <green>一般不用为成员变量赋初始值</green>\r\n    * java存在自动垃圾回收器,会定期清理堆内存中没有被引用的对象\r\n\r\n**类的语法构成**\r\n```java\r\npublic class 类名{\r\n    1.成员变量，名词\r\n        语法格式：修饰符 变量类型 变量名 = 初始值(可不指定初始值);\r\n    2.成员方法，动词\r\n    3.构造器\r\n    4.代码块\r\n    5.内部类\r\n}\r\n```\r\n\r\n**类的尝试编写**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person(\"DYG\",22);\r\n        p1.sayHi();\r\n    }\r\n}\r\n class Person{\r\n    String name;//车名\r\n    int age;//年龄\r\n    Person(String name,int age){//构造函数\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n    public void sayHi(){\r\n        System.out.println(\"你好，我的名字是\"+name+\"。\");\r\n    }\r\n}\r\n```\r\n\r\n**对象在内存中的执行机制**\r\n![](./images/java学习笔记/2022-10-23-04-27-47.png)\r\n\r\n\r\n**购物车案例实现**\r\n\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        GoodsShopCar shopCar = new GoodsShopCar(1024);\r\n        Scanner sc = new Scanner(System.in);\r\n        while (true){\r\n            System.out.println(\"------------------------请输入操作类型------------------------\");\r\n            System.out.println(\"添加商品（add）\");\r\n            System.out.println(\"查看商品（shw）\");\r\n            System.out.println(\"删除商品（del）\");\r\n            System.out.println(\"修改数量（upd）\");\r\n            System.out.println(\"计算金额（pay）\");\r\n            System.out.println(\"退出程序（ext）\");\r\n            switch (sc.next()){\r\n                case \"add\":\r\n                    shopCar.add_(sc);\r\n                    break;\r\n                case \"shw\":\r\n                    shopCar.show_();\r\n                    break;\r\n                case \"del\":\r\n                    shopCar.delete_(sc);\r\n                    break;\r\n                case \"upd\":\r\n                    shopCar.update_(sc);\r\n                    break;\r\n                case \"pay\":\r\n                    shopCar.pay_();\r\n                    break;\r\n                case \"ext\":\r\n                    return;\r\n                default:\r\n                    System.out.println(\"未知操作类型，请重新输入\");\r\n                    continue;\r\n            }\r\n        }\r\n    }\r\n}\r\nclass Goods{\r\n    int id;\r\n    String name;\r\n    double price;\r\n    int buyNum;\r\n    Goods(int id,String name,double price,int buyNum){\r\n        this.id = id;\r\n        this.name = name;\r\n        this.price = price;\r\n        this.buyNum = buyNum;\r\n    }\r\n    public void changeNum(int num){\r\n        this.buyNum = num;\r\n    }\r\n}\r\nclass GoodsShopCar{\r\n    Goods[] buyList;\r\n    GoodsShopCar(int size){\r\n        this.buyList = new Goods[size];\r\n    }\r\n    public void add_(Scanner sc){\r\n        System.out.println(\"请输入要添加的商品信息......\");\r\n        System.out.println(\"请输入商品id\");\r\n        int id = sc.nextInt();\r\n        System.out.println(\"请输入商品name\");\r\n        String name = sc.next();\r\n        System.out.println(\"请输入商品price\");\r\n        double price = sc.nextDouble();\r\n        System.out.println(\"请输入商品number\");\r\n        int num = sc.nextInt();\r\n        if(this.addGoods(new Goods(id,name,price,num)) == \"OK\"){\r\n            System.out.println(\"添加商品成功\");\r\n        } else {\r\n            System.out.println(\"添加商品成功\");\r\n        }\r\n    }\r\n    private String addGoods(Goods goods) {\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            if (buyList[i] == null) {\r\n                buyList[i] = goods;\r\n                return \"OK\";\r\n            }\r\n        }\r\n        return \"ERROR\";\r\n    }\r\n    public void delete_(Scanner sc){\r\n        System.out.println(\"请输入要删除的商品id\");\r\n\r\n        if (this.deleteById(sc.nextInt()) == \"OK\") {\r\n            System.out.println(\"删除成功\");\r\n        }else{\r\n            System.out.println(\"删除失败\");\r\n        }\r\n    }\r\n    private String deleteById(int id){\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            Goods item = buyList[i];\r\n            if (item.id == id){\r\n                buyList[i] = null;\r\n                return \"OK\";\r\n            }\r\n        }\r\n        return \"ERROR\";\r\n    }\r\n    public void update_(Scanner sc){\r\n        while(true) {\r\n            System.out.println(\"请输入要执行的操作：\");\r\n            System.out.println(\"0.返回上一级\");\r\n            System.out.println(\"1.更新商品数量\");\r\n            switch (sc.nextInt()){\r\n                case 0:\r\n                    return;\r\n                case 1:\r\n                    System.out.println(\"请输入要更新的商品的id\");\r\n                    int id = sc.nextInt();\r\n                    System.out.println(\"请输入要更新的数量\");\r\n                    int num = sc.nextInt();\r\n                    if (this.updateNumById(id,num) == \"OK\"){\r\n                        System.out.println(\"更新成功\");\r\n                        return;\r\n                    }else{\r\n                        System.out.println(\"更新失败,请重新输入\");\r\n                        break;\r\n                    }\r\n                default:\r\n                    System.out.println(\"未知操作类型,请重新输入\");\r\n            }\r\n        }\r\n    }\r\n    private String updateNumById(int id,int num){\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            Goods item = buyList[i];\r\n            if (item!=null && item.id == id){\r\n                item.changeNum(num);\r\n                return \"OK\";\r\n            }\r\n        }\r\n        return \"ERROR\";\r\n    }\r\n    public void show_(){\r\n        System.out.println(\"id\\t\\tname\\t\\tprice\\t\\tnumber\\t\\t\");\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            Goods item = buyList[i];\r\n            if (item != null){\r\n                System.out.println(item.id+\"\\t\\t\"+item.name+\"\\t\\t\"+item.price+\"\\t\\t\"+item.buyNum);\r\n            }\r\n        }\r\n    }\r\n    public void pay_(){\r\n        System.out.println(\"购物车总价为：\"+this.getSumPrice()+\"元\");\r\n    }\r\n    private double getSumPrice(){\r\n        double sumPrice = 0.0;\r\n        for (int i = 0; i < buyList.length; i++) {\r\n            Goods item = buyList[i];\r\n            if (item!=null)\r\n                sumPrice += item.price * item.buyNum;\r\n        }\r\n        return sumPrice;\r\n    }\r\n}\r\n```\r\n\r\n\r\n```text\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nadd\r\n请输入要添加的商品信息......\r\n请输入商品id\r\n111\r\n请输入商品name\r\n泡面\r\n请输入商品price\r\n4.5\r\n请输入商品number\r\n10\r\n添加商品成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nadd\r\n请输入要添加的商品信息......\r\n请输入商品id\r\n222\r\n请输入商品name\r\n火腿肠\r\n请输入商品price\r\n1\r\n请输入商品number\r\n10\r\n添加商品成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nadd\r\n请输入要添加的商品信息......\r\n请输入商品id\r\n333\r\n请输入商品name\r\n辣条\r\n请输入商品price\r\n0.5\r\n请输入商品number\r\n10\r\n添加商品成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nshw\r\nid\t\tname\t\tprice\t\tnumber\t\t\r\n111\t\t泡面\t\t4.5\t\t10\r\n222\t\t火腿肠\t\t1.0\t\t10\r\n333\t\t辣条\t\t0.5\t\t10\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\ndel\r\n请输入要删除的商品id\r\n222\r\n删除成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nupd\r\n请输入要执行的操作：\r\n0.返回上一级\r\n1.更新商品数量\r\n1\r\n请输入要更新的商品的id\r\n333\r\n请输入要更新的数量\r\n5\r\n更新成功\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\nshw\r\nid\t\tname\t\tprice\t\tnumber\t\t\r\n111\t\t泡面\t\t4.5\t\t10\r\n333\t\t辣条\t\t0.5\t\t5\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\npay\r\n购物车总价为：47.5元\r\n------------------------请输入操作类型------------------------\r\n添加商品（add）\r\n查看商品（shw）\r\n删除商品（del）\r\n修改数量（upd）\r\n计算金额（pay）\r\n退出程序（ext）\r\next\r\n\r\nProcess finished with exit code 0\r\n```\r\n\r\n\r\n\r\n### 构造器\r\n* 作用: 初始化对象，返回实例化对象的地址\r\n* 分类\r\n  * 有参构造器\r\n  * 无参构造器\r\n* 任何类在定义时 **默认拥有一个无参构造器**\r\n* <green>一旦定义了有参构造器，默认的无参构造器就会消失，若任要使用无参构造器，需自己定义</green>\r\n\r\n**语法格式**\r\n```java\r\nclass 类名{\r\n    public 类名(参数列表){//有参构造器\r\n    }\r\n    public 类名(){//无参构造器\r\n    }\r\n}\r\n```\r\n\r\n**调用构造器**\r\n```java\r\n类名 变量名 = new 构造器(参数列表);\r\n类名 变量名 = new 构造器();\r\n```\r\n\r\n### this关键字\r\n* this表示当前实例对象的地址\r\n* this的值和`new 构造器()`的返回值一致\r\n* 通过this可以访问到当前实例对象的属性和方法\r\n```java\r\nclass Person{\r\n    private String name;\r\n    private int age;\r\n    public Person(String name,int age){\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n\r\n### 封装\r\n**面向对象的三大特征**\r\n* 封装：按一定原则设计对象的属性和方法\r\n* 继承\r\n* 多态\r\n\r\n**封装原则**\r\n* 对象代表什么，就封装对应的数据并提供数据对应的行为\r\n* 案例：人对象 圆对象 门对象\r\n  * 人画圆 draw()方法应当封装到圆对象中，因为画圆需要得知圆半径，而该属性在圆对象中\r\n  * 人开门 open()方法应当封装到门对象中，\r\n\r\n**更安全的封装对象**\r\n* 把成员变量用private属性修饰，使得外部不能直接访问\r\n* 提供getter setter方法向外暴露接口\r\n\r\n```java\r\nclass Person{\r\n    private String name;//私有属性\r\n    private int age;//私有属性\r\n    public setAge(int age){//修改属性值\r\n        if(0<=age && age<= 200){//判断属性值是否合法\r\n            this.age = age;//赋值\r\n        }else{//报错\r\n            System.out.print(\"ERROR\")\r\n        }\r\n    }\r\n    public getAge(){//获取属性值\r\n        return this.age;\r\n    }\r\n}\r\n```\r\n\r\n### 标准javaBean实体类\r\n\r\n**书写要求**\r\n* **必须**有一个无参构造器\r\n* **应当**使用private修饰成员变量\r\n* **应当**提供成员变量对应的setXXX() getXXX()方法\r\n\r\n```java\r\nclass Person{\r\n    private String name;//私有属性\r\n    private int age;//私有属性\r\n    Person(){\r\n        //必须有一个无参构造器\r\n    }\r\n    public setAge(int age){//修改属性值\r\n        if(0<=age && age<= 200){//判断属性值是否合法\r\n            this.age = age;//赋值\r\n        }else{//报错\r\n            System.out.print(\"ERROR\")\r\n        }\r\n    }\r\n    public getAge(){//获取属性值\r\n        return this.age;\r\n    }\r\n    public setName(int name){//修改属性值\r\n        this.name = name;//赋值\r\n    }\r\n    public getName(){//获取属性值\r\n        return this.name;\r\n    }\r\n}\r\n```\r\n\r\n### 成员变量和局部变量的区别\r\n![](./images/java学习笔记/2022-10-23-14-06-19.png)\r\n\r\n\r\n### 对象数组在内存中的占用情况\r\n<green>数组中存储的不是对象而是对象的地址<green>\r\n![](./images/java学习笔记/2022-10-23-14-09-53.png)\r\n\r\n\r\n\r\n\r\n## String字符串类及其常用API\r\n### 相关概念\r\n**`\"常量字符串\"`与`new String()`的区别**\r\n* <green>String类也称不可变字符串类型，在对象创建后不能修改</green>\r\n* 以`\"这是一个字符串常量\"`形式出现的字符串常量对象存储在**堆内存**的**字符串常量池**中\r\n* 字符串的链接操作实际是在堆中开辟了新的空间\r\n* 字符串间的`==`运算 比较的是内存地址\r\n* 相同的字符串常量的地址相同 `==运算` 结果为true\r\n* 以`String s1 = new String(chars);`方式创建的相同的字符串其地址不同 `==运算` 结果为false\r\n\r\n**字符串的链接操作实际是在堆中开辟了新的空间**\r\n![](./images/java学习笔记/2022-10-23-14-38-30.png)\r\n\r\n**相同的字符串常量的地址相同**\r\n![](./images/java学习笔记/2022-10-23-14-42-42.png)\r\n\r\n**以`String s1 = new String(chars);`方式创建的相同的字符串其地址不同**\r\n![](./images/java学习笔记/2022-10-23-14-43-44.png)\r\n\r\n\r\n### APis\r\n#### 构造器\r\n**几种使用`new String()`构造方式创建字符串对象的方法**\r\n```java\r\nString str = \"abc\"\r\nchar[] chars = {'中','国'};\r\nbyte[] bytes = {97,98};\r\n\r\nString s1 = new String();//s1 => \"\"\r\nString s2 = new String(str);//s1 => \"abc\"\r\nString s3 = new String(chars);//s1 => \"中国\"\r\nString s4 = new String(bytes);//s1 => \"ab\"\r\n```\r\n\r\n**面试题**\r\n![](./images/java学习笔记/2022-10-23-15-04-02.png)\r\n![](./images/java学习笔记/2022-10-23-15-09-05.png)\r\n![](./images/java学习笔记/2022-10-23-15-11-20.png)\r\n\r\n#### 常用成员方法\r\n**常用方法**\r\n```java\r\nString strObj1 = \"测试字符串\"\r\nboolean bo = strObj1.equals(strObj2);             //比较字符串内容是否相等\r\nboolean bo = strObj1.equalsIgnoreCase(strObj2);   //比较字符串内容是否相等（忽略大小写）\r\n\r\nint length = strObj1.length();//获取字符串长度\r\n\r\nchar ch = strObj1.charAt(0);//获取第0个字符\r\n\r\nchar[] chars = strObj1.toCharArray();//字符串转char类型数组\r\n\r\nString subStr1 = strObj1.substring(beginIndex,endIndex)//截取内容，index包括前不包括后\r\nString subStr2 = strObj1.substring(beginIndex)//截取内容，从一个下标一直截取到末尾\r\n\r\n\r\nString repStr1 = strObj1.replace(charSequence target,charSequence replacement)//子串替换 不会影响原值\r\nString repStr1 = strObj1.replace(\"金三胖\",\"***\")//敏感词替换\r\n\r\nboolean bo = strObj1.contains(\"金三胖\");//子串包含检测\r\n\r\nboolean bo = strObj1.startsWith(\"金三胖\");//检测是否以某段字符串开头\r\n\r\nString name = \"姓名1,姓名2,姓名3\";\r\nString[] names = name.split(\",\");//根据标点符号分割数组\r\n```\r\n![](./images/java学习笔记/2022-10-23-15-44-19.png)\r\n\r\n\r\n**遍历字符串**\r\n```java\r\nfor(int i = 0;i<str.length();i++ ){\r\n    char ch = charAt(i);\r\n}\r\n```\r\n\r\n### 案例\r\n**生成验证码**\r\n```java\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(genCode(10));\r\n    }\r\n    public static String genCode(int length){\r\n        String chars = \"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0123456789\";\r\n        String code = \"\";\r\n        Random rd = new Random();\r\n        for (int i = 0; i < length; i++) {\r\n            code += chars.charAt( rd.nextInt( chars.length() ) );\r\n        }\r\n        return code;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-23-15-57-23.png)\r\n\r\n**屏蔽手机号中间四位**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(encodeTel(\"17600001729\"));\r\n    }\r\n    public static String encodeTel(String telNum){\r\n        String result = \"\";\r\n        //手机号11位\r\n        result += telNum.substring(0,3);//保留前3位\r\n        result += \"****\";//屏蔽中间4位\r\n        result += telNum.substring(7);//保留最后4位\r\n        return result;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-23-16-19-52.png)\r\n\r\n\r\n## ArraryList集合容器类及其常用API\r\n### 相关概念\r\n* ArraryList是一个支持索引的集合类，和数组类似\r\n* ArraryList集合的类型不固定，大小可变\r\n* ArraryList集合支持增删改查 \r\n* ArraryList集合支持泛型\r\n* 集合（及泛型）中只能存储引用数据类型，不能存基本数据类型 \r\n  * int是基本数据类型 Integer是int的引用数据类型\r\n* <green>但集合类的大小是不固定的(优点)</green>\r\n\r\n### APIs\r\n#### 构造器\r\n```java\r\nnew ArrayList();\r\nnew ArrayList(容量大小);\r\nnew ArrayList(泛型);\r\n```\r\n\r\n**添加元素**\r\n```java\r\nobj.add(element);//添加元素到末尾,返回boolean\r\nobj.add(index,element);//添加元素到指定位置\r\n```\r\n\r\n**测试案例**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        ArrayList list = new ArrayList();\r\n        list.add(\"字符串\");\r\n        list.add('汉');\r\n        list.add(123);\r\n        list.add(0.125);\r\n        list.add(new ArrayList());\r\n        list.add(2,\"新插入的元素\");\r\n        System.out.println(list);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-23-16-23-25.png)\r\n\r\n**支持泛型**\r\n```java\r\nArrayList list1 = new ArrayList();//默认的泛型，支持所有类型\r\nArrayList<Object> list1 = new ArrayList<Object>();//默认的泛型，支持所有类型 Object所有的类型都继承自Object\r\nArrayList<String> list1 = new ArrayList<String>();//仅支持字符串类型的泛型\r\nArrayList<String> list2 = new ArrayList<>();//jdk1.7开始的可以省略后部分泛型类型声明\r\nArrayList<Integer> list3 = new ArrayList<>();//ArrayList存储的是引用数据类型\r\n// ArrayList<int> list4 = new ArrayList<>();//ArrayList不能存储基本数据类型，报错\r\n\r\nlist.add(\"只能添加字符串类型\");\r\n```\r\n#### 常用成员方法\r\n* `add(element)`//在末尾添加元素,返回true/false\r\n* `add(index,element)`//插入元素到指定位置\r\n* `get(index)`\r\n* `size()`\r\n* `E remove(index)` //返回被删除的对象\r\n* `Boolean remove(obj)` //直接删除对象(默认删第一个)，返回true/false \r\n* `E set(index,element)` //修改某位置的值，返回原数值\r\n\r\n![](./images/java学习笔记/2022-10-23-16-36-50.png)\r\n\r\n**遍历ArraryList集合**\r\n```java\r\nfor(int i = 0 ; arr.size();i++){\r\n    list.get(i);\r\n}\r\n```\r\n\r\n### 一些案例\r\n![](./images/java学习笔记/2022-10-23-16-49-06.png)\r\n```java\r\npackage com.yiguiding.package1;\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Random rd = new Random();\r\n        ArrayList<Integer> scores = new ArrayList<>();\r\n        for (int i = 0; i < 40; i++) {//40个学生\r\n            scores.add(rd.nextInt(101));//随机赋值0-100的分数\r\n        }\r\n        System.out.println(\"全班分数为：\");\r\n        System.out.println(scores);//输出\r\n        for (int i = scores.size()-1; i >= 0; i--) {\r\n            //若采用从前往后的遍历方式，删除当前所在位置的元素后，下一个元素的下标将变成本次删除元素的下标，同时下标会自增，这将导致有一个元素没有判断到。要避免这样的问题应当从后往前遍历\r\n            if (scores.get(i)<80) {\r\n                scores.remove(i);\r\n            }\r\n        }\r\n        System.out.println(\"筛选结果为：\");\r\n        System.out.println(scores);//输出\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-23-17-03-01.png)\r\n\r\n\r\n**ArrayList存取、遍历自定义对象**\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        ArrayList<Student> students = new ArrayList<>();\r\n\r\n        students.add(new Student(001,\"张三\",20));\r\n        students.add(new Student(002,\"李四\",20));\r\n        students.add(new Student(003,\"王五\",20));\r\n\r\n        System.out.println(\"id\\t\\tname\\t\\tage\");\r\n        for (int i = 0; i < students.size(); i++) {\r\n            Student stu = students.get(i);\r\n            System.out.println(stu.getId()+\"\\t\\t\"+stu.getName()+\"\\t\\t\"+stu.getAge());\r\n        }\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private int id;\r\n    private String name;\r\n    private int age;\r\n\r\n    public Student() {\r\n    }\r\n\r\n    public Student(int id, String name, int age) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\n## 面向对象高级\r\n### static关键字\r\n**static静态修饰符的作用**\r\n* 用于修饰`成员变量`和`成员方法`\r\n* <green>静态成员变量表示该成员只在内存中存储一份，可以被共享的访问和修改</green>\r\n\r\n**成员变量的分类**\r\n* 静态成员变量：由static修饰，属于类，加载一次，可被共享\r\n  * **建议**用`类名.静态成员变量名`访问，\r\n  * 也能通过`实例对象名.静态成员变量`访问\r\n* 实例成员变量：无static修饰，属于对象，\r\n  * **只能**用`实例对象名.静态成员变量名`访问\r\n\r\n**成员方法的分类**\r\n* **静态成员方法**:由static修饰，**归属于类**，\r\n  * **建议**用`类名.方法名()`访问，\r\n  * 也能通过`实例对象名.方法名()`访问\r\n* **实例成员方法**:**无**static修饰，**归属于实例对象**，\r\n  * **只能**用`实例对象名.方法名()`访问\r\n\r\n<warn>**注意事项**</warn>\r\n* 静态成员方法 **只能** 访问`静态成员方法`和`静态成员变量`\r\n* 实例方法可以访问静态成员、静态方法\r\n* 静态方法内部不存在`this`\r\n\r\n**定义和使用**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n\r\n        //通过类名访问静态变量和方法（推荐）\r\n        System.out.println(Person.count);\r\n        System.out.println(Person.getTotal());\r\n\r\n        //通过实例化对象访问静态变量和方法（不推荐）\r\n        Person person = new Person();\r\n        System.out.println(person.count);\r\n        System.out.println(person.getTotal());\r\n    }\r\n}\r\nclass Person{\r\n    public static int count=1;//向外暴露的静态变量，外部可直接访问，属于类的成员不属于实例对象的成员\r\n    private static int total=2;//私有的静态变量\r\n    public static int getTotal(){///向外暴露的静态方法，属于原型类，可以通过`类名.方法名()`调用 也可以通过 `实例对象.方法名()`\r\n        return total;//访问同一个类中的静态成员变量可以省略类名\r\n//        return Person.total;//完整写法\r\n//        return this.total;//错误写法:this无法访问到经static修饰的变量,因为静态变量属于原型类不属于实例对象\r\n    }\r\n}\r\n```\r\n\r\n**静态成员变量的内存机制**\r\n![](./images/java学习笔记/2022-10-24-00-45-07.png)\r\n\r\n**静态成员函数的内存机制**\r\n![](./images/java学习笔记/2022-10-24-01-05-49.png)\r\n\r\n\r\n**应用:工具类静态方法**\r\n```java\r\nclass Util{\r\n    static void 函数名(){//复用的静态方法\r\n        //方法\r\n    }\r\n    private Util(){//高级用法：由于工具类无需闯将对象，所以将其构造函数私有化，使其失去创建对象的能力\r\n    }\r\n}\r\n```\r\n\r\n### 代码块\r\n代码块的分类\r\n* 静态代码块 static修饰 属于类 与类一起优先加载 自动触发执行\r\n  * 作用：用于初始化静态资源\r\n* (实例)构造代码块，每次调用构造器函数前都会执行的代码块\r\n  * 作用：初始化实例资源\r\n\r\n```java\r\nclass Person{\r\n    private String name;\r\n    private int age;\r\n    static int PersonCount;\r\n    static{\r\n        System.out.print(\"------------1.静态代码块被执行-------------\");\r\n        PersonCount = 0 ;//初始化personCount\r\n    }\r\n    {\r\n        System.out.print(\"------------ 2.(实例)构造代码块被执行-------------\");\r\n        PersonCount++ ;//自增\r\n    }\r\n    Person(){\r\n        System.out.print(\"------------ 3.构造器被执行-------------\");\r\n        //构造器\r\n    }\r\n}\r\n```\r\n\r\n### 继承extends\r\n使用该关键字可以让一个类和另一个类建立父子关系，子类继承父类的成员变量和方法\r\n\r\n**基本语法**\r\n```java\r\npublic class Student extends People{}\r\nStudent 称为 子类 或 派生类\r\nPeople 称为 父类 或 基类 或 超类\r\n```\r\n\r\n**设计规范**\r\n子类们的相同的属性和方法可以放到父类中定义，子类独有的属性和方法定义在子类中。\r\n\r\n**继承的特点**\r\n* <green>子类可以继承父类的属性和行为<green>\r\n* <green>子类可以继承父类的私有属性和方法，但不能直接访问(可以暴力访问)</green>\r\n  * (是否属于继承是有争议的)\r\n* <green>子类可以访问到父类的静态属性和方法（父类共享给了子类）</green>\r\n  * （是否属于继承是有争议的，因为父类的静态属性和方法任然属于父类，子类只是能够访问它）\r\n* <green>子类不能继承父类的构造器</green>\r\n* 继承遵循**单继承模式** **一个类只能继承一个直接父类**，\r\n  * 因为如果能继承多个父类且父类中有同名的方法，子类就不知道该继承哪一个\r\n* 不支持一次继承多个类，但支持**多层继承**\r\n* java的所有类都是`Object`类的子类\r\n  * 要么默认继承 `public class Student{}`\r\n  * 要么直接继承 `public class Student extends Object{}`\r\n  * 要么间接继承 `public class newStudent extends Student{}`\r\n\r\n**继承的内存分配机制**\r\n![](./images/java学习笔记/2022-10-24-11-24-06.png)\r\n\r\n**继承后成员的访问特点**\r\n* 就近原则\r\n* 访问顺序： `局部变量名、局部函数名` => `子类成员变量名、子类成员函数名` => `父类成员变量名、父类成员函数名`\r\n\r\n**测试案例**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Student std = new Student();\r\n        std.getName();\r\n    }\r\n}\r\nclass Person{\r\n    String name = \"personName\";\r\n}\r\nclass Student extends Person{\r\n    String name = \"studentName\";\r\n    public String getName(){\r\n        String name = \"reagenName\";\r\n        System.out.println(name);//局部变量\r\n        System.out.println(this.name);//子类成员变量\r\n        System.out.println(super.name);//父类成员变量\r\n        return this.name;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-24-12-43-32.png)\r\n\r\n\r\n### 继承后的方法重写\r\n* 重写的方法名称、形参列表必须和被重写的方法一致\r\n* 一般在重写方法时，**声明不变，重新实现**\r\n* <green>父类的私有方法不能被重写</green>\r\n* 子类重写父类方法时，访问权限必须大于等于父类\r\n  * 访问权限( `默认` < `protected` < `public` )\r\n* 子类不能重写父类的静态方法\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Student std = new Student();\r\n        std.test();\r\n    }\r\n}\r\nclass Person{\r\n    String name = \"personName\";\r\n    public void sayHi(){\r\n        System.out.println(\"Hi,my name is \"+name);\r\n    }\r\n}\r\nclass Student extends Person{\r\n    String name = \"studentName\";\r\n    @Override\r\n    //@Override是重写校验注解，java建议程序员在重新的方法上加上注解，加上注解后若函数没有被以重写的方式编译，编译器会报错\r\n    //提高代码可读性\r\npublic void sayHi(){//方法重写\r\n        System.out.println(\"Hi,my name is \"+name);\r\n    }\r\n    public void test(){\r\n        sayHi();//默认调用子类成员方法\r\n        this.sayHi();//显式调用子类成员方法\r\n        super.sayHi();//显式调用父类成员方法\r\n    }\r\n}\r\n```\r\n\r\n### 继承后子类构造器的特点\r\n* 子类的任何构造器(有参/无参)被调用时，默认会先调用父类的无参构造器(若父类没有无参构造器则会报错)\r\n    ```java\r\n    //原理\r\n    class Person{\r\n\r\n    }\r\n    class Student extends Person{\r\n        Student(){\r\n            super();//写不写都有的语句，子类构造器中会默认调用父类的无参构造器\r\n        }\r\n    }\r\n    ```\r\n* 可以重新指定调用父类的有参构造器\r\n    ```java\r\n    class Person{\r\n        String name;\r\n        int age;\r\n        \r\n        Person(String name,int age){\r\n            this.name = name;\r\n            this.age = age;\r\n        }\r\n    }\r\n    class Student extends Person{\r\n        Student(String name,int age){\r\n            super(name,age);//显式调用父类构造器\r\n        }\r\n    }\r\n    ```\r\n\r\n### this和super的使用\r\n![](./images/java学习笔记/2022-10-24-13-33-25.png)\r\n\r\n**注意事项**\r\n* this()和super()都只能放在第一行，所以两者不能共同存在于一个构造器\r\n```java\r\nclass Person{\r\n    String name;\r\n    int age;\r\n\r\n    Person(String name,int age){\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\nclass Student extends Person{\r\n    Student(String name){\r\n        this(name,18);//默认18岁\r\n    }\r\n    Student(String name,int age){\r\n        super(name,age);//显式调用父类构造器\r\n    }\r\n}\r\n```\r\n\r\n## 单例设计模式\r\n### 设计模式\r\n* 开发中遇到的一些问题这些问题每个都有n种解决方案，但只有一种最优解，这些解法的总结就是设计模式\r\n* 设计模式有20种，对应20多种软件开发过程中遇到的问题\r\n* 学设计模式主要学两点\r\n    * 该模式是解决什么问题？\r\n    * 该模式是如何解决的该问题？ 该模式怎么写的？\r\n\r\n**单例模式**\r\n* 保证系统中应用该模式的这个类永远只有一个实例，也就是一个类只能实例化一个对象\r\n* 单例模式的实现方式\r\n  * 饿汉单例模式\r\n  * 懒汉...\r\n\r\n### 饿汉单例\r\n* 私有化构造器\r\n* 定义一个公开的静态成员变量，初始化为一个实例对象\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n\r\n        singleInstance s1 = singleInstance.instance;\r\n        singleInstance s2 = singleInstance.instance;\r\n        System.out.println(s1==s2);//true\r\n    }\r\n}\r\n//饿汉单例：在用户获取对象前，对象已经准备好的\r\nclass singleInstance{\r\npublic static singleInstance instance = new singleInstance(); // 由于静态成员变量只会在类加载时初始化一次，所以当通过`类名.静态属性名`访问变量时，该变量早已初始化好了\r\n    private singleInstance(){//私有化构造器后只有类自己能调用构造器,否则用户可通过构造器创建很多地址不同的对象\r\n    }\r\n}\r\n```\r\n\r\n### 懒汉单例模式\r\n* 私有化构造器\r\n* 定义一个用于保存单例对象的**私有化静态成员变量**\r\n* 公开一个静态成员方法用于获取（在第一次调用时创建）实例对象\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        singleInstance s1 = singleInstance.getInstance();\r\n        singleInstance s2 = singleInstance.getInstance();\r\n        System.out.println(s1==s2);//true\r\n    }\r\n}\r\n//饿汉单例：在用户第一次获取时，创建实例对象\r\nclass singleInstance{\r\n    private static singleInstance instance;//私有化\r\n    private singleInstance(){//私有化构造器后只有类自己能调用构造器,否则用户可通过构造器创建很多地址不同的对象\r\n    }\r\n    public static singleInstance getInstance(){\r\n        if (instance==null){\r\n            instance = new singleInstance();\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n## 包Package\r\n**概念、作用**\r\n* 用于分类管理不同的`类`,利于程序的管理和维护\r\n\r\n\r\n**建包**\r\n* 建议的建包语法格式：倒写公司域名.模块名称\r\n* 建议的键包命名规范：小写英文，有意义\r\n```java\r\npackage com.huawei.school;\r\npublic class Student{\r\n}\r\n```\r\n\r\n**导包**\r\n* 相同包下的类可以直接访问\r\n* 不同包下的类必须导包才能使用\r\n* 导包格式：`import 包名.类名;`\r\n* 若要引入两个同名的类，第二个导入的类只能使用完整包名访问类\r\n```java\r\nimport java.util.Scanner;\r\n\r\npackage com.yiguiding.package1.Student;\r\nStudent stu1 = new Student();\r\n\r\npackage com.yiguiding.package2.Student;\r\ncom.yiguiding.package2.Student stu2 =new com.yiguiding.package2.Student();\r\n```\r\n\r\n\r\n## 权限修饰符\r\n**概念**\r\n* 用于修饰成员属性，成员方法,构造器,内部类，不同的修饰符代表不同的访问权限。\r\n* 权限修饰符作用范围：（ `private` -> `默认` -> `protected` -> `public` ）\r\n* 总结\r\n\r\n| 权限修饰符名 | 同类的作用域可访问 | 同包不同类的作用域可访问 | 不同包但为其父类的作用域可访问 | 不同包不同类的作用域可访问 |\r\n| :----------: | :----------------: | :----------------------: | :----------------------------: | :------------------------: |\r\n|   private    |         √          |                          |                                |                            |\r\n|   default    |         √          |            √             |                                |                            |\r\n|  protected   |         √          |            √             |               √                |                            |\r\n|    public    |         √          |            √             |               √                |             √              |\r\n\r\n## final修饰符\r\n* final是关键字，\r\n* 意为最终\r\n* 可修饰 **类** **方法** **变量**\r\n* 作用：\r\n  * 修饰类： 类不能被继承\r\n  * 修饰方法：方法不能被重写\r\n  * 修饰变量：变量被第一次赋值后不能被修改\r\n    * 若修饰的是基本数据类型，变量存储的**数据**值不能改变\r\n    * 若修饰的是引用数据类型，变量存储的**地址**值不能改变，但地址指向的对象内容可变\r\n  \r\n**实例**\r\n```java\r\nclass Person{\r\n    final public void sayHi(){//不能被子类重写的方法\r\n        System.out.println(\"Hi~~\");\r\n    }\r\n}\r\nfinal class  Student extends Person{//不能被继承的对象\r\n    final int id;//不能被修改的变量，只能在第一次赋值\r\n    Student(int id){\r\n        this.id = id;\r\n    }\r\n}\r\n```\r\n\r\n## 常量\r\n* 常量是由`public static final`修饰的变量\r\n* 常量会在编译阶段做宏替换，程序中使用常量的地方都会被替换为字面量\r\n* 好处是执行性能和直接使用字面量一致\r\n* 命名规范是推荐单词全大写多个单词用下划线分隔\r\n```java\r\npublic static final String USER_NAME = \"admin\"\r\n```\r\n\r\n## 枚举\r\n```java\r\n修饰符 enum 枚举名称{\r\n    名称1,名称2,名称3,名称4,名称5;\r\n}\r\n\r\nenum Season{\r\n    SPRING,SUMMER,AUTUMN,WINTER;\r\n}\r\n```\r\n\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Season temp = Season.AUTUMN;\r\n        if (temp == Season.AUTUMN){\r\n            //do something\r\n        }\r\n        switch (temp){//switch中可省略`Season.AUTUMN`的访问方式\r\n            case AUTUMN:\r\n                //do something\r\n                break;\r\n            case SPRING:\r\n                //do something\r\n                break;\r\n        }\r\n    }\r\n}\r\nenum Season{\r\n    SPRING,SUMMER,AUTUMN,WINTER;\r\n}\r\n```\r\n\r\n根据编译再反编译的结果可知：\r\n* 枚举是一个类，\r\n* 枚举是最终类，不能被继承\r\n* 枚举类继承自枚举类型`java.lang.Enum`\r\n* 构造器的构造器都是私有的，对外不能创建对象\r\n* 枚举类的第一行默认是罗列枚举对象的名称\r\n* 枚举类相当于是**多例模式**\r\n\r\n![](./images/java学习笔记/2022-10-24-20-00-56.png)\r\n\r\n## 抽象类、抽象方法\r\n* 在java中abstract是抽象的意思，可以修饰类、成员方法。\r\n* abstract修饰的**类**称为**抽象类**。\r\n* abstract修饰的**方法**称为**抽象方法**。\r\n* <green>抽象方法表示这个方法的具体功能由子类来实现</green>\r\n* <green>含有抽象方法的类必须也声明为抽象类</green>\r\n* 抽象类中可以没有抽象方法，**但有抽象方法的类必为抽象类**\r\n* <warn>一个类继承了抽象类，则该类必须重写该类的所以抽象方法,否则该类必须也是抽象类</warn>\r\n* 抽象类不能修饰构造函数、代码块、成员变量\r\n* **抽象类没有实例化对象的能力（不能创建对象）**\r\n  * 面试题，为什么？\r\n  * 因为：假如抽象类可以创建对象，当用其执行`实例对象.抽象方法名()`，将执行一个没有函数体的方法，这是不合理的\r\n\r\n案例\r\n```java\r\nabstract class Person{//抽象类\r\n    abstract public void sayHi();//抽象方法：不用写方法体\r\n}\r\nclass Student extends Person{\r\n    @Override\r\n    public void sayHi(){//重写方法\r\n        System.out.println(\"你好，我是学生\");\r\n    }\r\n}\r\nclass Teacher extends Person{\r\n    @Override\r\n    public void sayHi(){//重写方法\r\n        System.out.println(\"你好，我是老师\");\r\n    }\r\n}\r\n```\r\n\r\n### final和abstract关系\r\n* final和abstract为互斥关系\r\n* final修饰的类不能被继承，abstract修饰的类需要被继承\r\n* final修饰的方法不能被重写，abstract修饰的方法需要被重写\r\n* final修饰的变量不能被修改，abstract不能修饰变量\r\n\r\n\r\n## 接口\r\n* 接口是一种规范\r\n* **接口是定义来让类实现的，**\r\n* 规范一定是公开的（默认由public修饰）\r\n* <green>实现接口的类称为**实现（implements）类**</green>\r\n* <green>**实现类**可认为是**子类**，接口可认为是实现类的**父类**</green>\r\n* <green>实现类应当重写所有接口的方法，否则实现类就应当是一个抽象类</green>\r\n* <green>接口可以**多实现**：一个实现类可以实现多个接口</green>\r\n* <green>接口可以**多继承**：一个接口可以继承多个接口</green>\r\n\r\n**jdk1.8之后的新特性**\r\n* 接口中可以定义**实例方法**，\r\n  * 必须显式由 `default` 修饰 同时默认还将被`public`修饰\r\n  * 当其被`实现类`继承时，通过`实现类`的`实例对象.实例方法名()`调用\r\n* 接口中可以定义**静态方法**，\r\n  * 必须显式由 `static` 修饰 同时默认还将被`public`修饰\r\n  * 只能通过`接口名.静态方法名()`调用,**不能**通过`实现类`调用，不能通过`实例对象`调用\r\n\r\n**jdk1.9之后的新特性**\r\n* 接口中可以定义**私有方法**，\r\n  * 实际上相当于是一个`私有的`**实例方法**\r\n  * 必须显式由 `private` 修饰 同时默认**不会**被`public`修饰\r\n  * 只能在接口内部通过`方法名()`调用\r\n\r\n**<warn>注意事项(极端语法知识、面试题)<warn>**\r\n* 接口不能创建对象（常识，接口没有构造方法）\r\n* 一个类实现多个接口，被实现的多个接口中的同名**静态方法**不会冲突（因为实现类不会继承接口的静态方法）。\r\n* 一个类实现多个接口，被实现的对各接口中的同名**默认方法**不会冲突，默认也不会继承，子类需要重写该方法\r\n* 一个类继承了父类,同时又实现了一个接口，父类方法名和接口方法名重名时，不会产生冲突，子类会默认继承父类的方法\r\n  *  `修饰符 class 实现类 extends 被继承的类名 implements 接口1,接口2,接口3{}`\r\n* 一个接口继承多个接口时，一般是没问题的，但若被继承的接口中存在声明不一致（返回值，形参列表）的同名方法时，会报错\r\n\r\n**接口定义的语法格式**\r\n```java\r\n//接口格式\r\npublic interface 接口名{\r\n    //1.常量        jdk1.8之前 默认由 `public static final` 修饰\r\n    //2.抽象方法    jdk1.8之前 默认由 `public abstract` 修饰\r\n    //3.实例方法    jdk1.8之后新增的方法 必须显式由 default 修饰，默认 还将 被public修饰\r\n    //4.静态方法    jdk1.8之后新增的方法 必须显式由 static  修饰，默认 还将 被public修饰\r\n    //4.静态方法    jdk1.9之后新增的方法 必须显式由 private 修饰，默认_不会_被public修饰\r\n\r\n    public static final String USER_NAME = \"admin\";//public 和 final都是接口默认自动添加的 可以省略不写\r\n    public abstract void getUuserName(); //public abstract 是接口默认自动添加的 可以省略不写\r\n    default void sayHi(){\r\n        System.out.println(\"在抽象方法中直接新增的实例方法，必须由default修饰\" +\r\n                \"当其被`实现类`继承时，通过`实现类`的`实例对象.实例方法名()`调用\");\r\n    }\r\n}\r\n//接口的实现（或多实现）\r\n修饰符 class 实现类 implements 接口1,接口2,接口3{\r\n    @Override\r\n    // 重写接口的所有方法\r\n}\r\n//接口的多继承\r\npublic interface 接口名 extends 其他接口1,其他接口2,其他接口3,其他接口4 {\r\n    // 新的常量\r\n    // 新的方法\r\n}\r\n```\r\n\r\n**接口的实现**\r\n```java\r\ninterface School{\r\n    void goToSchool();\r\n    void study();\r\n}\r\n\r\nclass Student implements Person,School{\r\n    @Override\r\n    public void run(){\r\n        System.out.println(\"run....\");\r\n    }\r\n    @Override\r\n    public void say(){\r\n        System.out.println(\"say.....\");\r\n    }\r\n    @Override\r\n    public void goToSchool(){\r\n        System.out.println(\"goToSchool.....\");\r\n    }\r\n    @Override\r\n    public void study(){\r\n        System.out.println(\"study.....\");\r\n    }\r\n}\r\n```\r\n\r\n## 多态\r\n>同类型的对象，调用同一个方法，表现出不同的行为\r\n\r\n**多态的前提**\r\n* 有继承/实现关系\r\n* 有父类引用指向子类引用\r\n* 有方法重写\r\n\r\n**使用形式**\r\n```java\r\n父类类型 对象名称 = new 子类构造器名();\r\n接口 对象名称  =  new 实现类构造器();\r\n```\r\n\r\n**多态的成员访问特点**\r\n* 访问成员变量,根据对象的类型访问\r\n* 访问成员方法,根据构造器返回的地址访问<green>(多态侧重于行为)</green>\r\n\r\n\r\n**多态的优势**\r\n* 在多态形式下，子类对象可以实现解耦合，便于扩展和维护\r\n    ```java\r\n    Animal cat = new Cat();\r\n    Animal tiger = new Tiger();\r\n    cat.run();//若cat的run方法的实现需要修改，只需要修改Cat类中的方法，不需要改Tiger的run方法\r\n    tiger.run();\r\n    ```\r\n* 定义方式时，函数的形参用父类型作为参数类型，便可以接收该父类的所有子类\r\n    ```java\r\n    void run(Animal animal){\r\n        //do something...\r\n    }\r\n    run(cat);\r\n    run(tiger);\r\n    ```\r\n\r\n**多态的缺点**\r\n* 多态时，不能访问子类独有的方法\r\n    ```java\r\n    Animal cat = new Cat();\r\n    Animal tiger = new Tiger();\r\n    cat.run();\r\n    tiger.run();\r\n    cat.miaoMiao();//无法调用\r\n    ```\r\n* 若要访问需要进行强制类型转换(强制转换前可用 `instalceof` 判断真实类型)\r\n    ```java\r\n    Animal cat = new Cat();\r\n    Animal tiger = new Tiger();\r\n    cat.run();\r\n    tiger.run();\r\n    if(cat instanceof Cat)//可用 `instalceof` 判断真实类型\r\n      ((Cat)cat).sayMiaoMiao();//强制转换后调用\r\n    ```\r\n\r\n### 抽象类的多态实现测试\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Animal dog = new Dog();\r\n        Animal cat = new Cat();\r\n\r\n        //多态调用，调用子类属性\r\n        dog.run();\r\n        cat.run();\r\n        //强制转换，调用子类方法\r\n        ((Dog)dog).sayWangWangWang();\r\n        ((Cat)cat).sayMiaoMiaoMiao();\r\n\r\n        //多态调用，调用父类属性\r\n        System.out.println(dog.name+\"在跑...\");\r\n        System.out.println(cat.name+\"在跑...\");\r\n\r\n        //强制转换，调用子类属性\r\n        System.out.println(((Dog)dog).name+\"在跑...\");\r\n        System.out.println(((Cat)cat).name+\"在跑...\");\r\n\r\n    }\r\n}\r\nabstract class Animal{\r\n    public String name = \"Animal\";\r\n    abstract public void run();\r\n}\r\nclass Dog extends Animal{\r\n    public String name = \"Dog\";\r\n    public void run(){\r\n        System.out.println(name+\"在跑...\");\r\n    }\r\n    public void sayWangWangWang(){\r\n        System.out.println(\"汪汪汪....\");\r\n    }\r\n}\r\nclass Cat extends Animal{\r\n    public String name = \"Cat\";\r\n    public void run(){\r\n        System.out.println(name+\"在跑...\");\r\n    }\r\n    public void sayMiaoMiaoMiao(){\r\n        System.out.println(\"喵喵喵....\");\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-25-15-43-31.png)\r\n\r\n## 内部类\r\n**内部类就是在一个类的内部又定义了一个类**\r\n\r\n**作用**\r\n* 当一个类的内部,有一部分需要一个完成的结构来描述，且这个完整的结构又只为外部事务提供服务，那么这整个内部的完整结构可以使用内部类来设计。\r\n内部类可以方便\r\n* 内部类可以方便的访问外部类的成员，甚至是私有成员\r\n* 内部类提供了更好的封装性，内部类本身可以使用private protected来修饰\r\n\r\n**一般语法格式**\r\n```java\r\npublic class People{\r\n    public class Heart{\r\n\r\n    }\r\n}\r\n```\r\n\r\n**分类**\r\n* 静态内部类【了解】\r\n* 成员内部类(非静态)【了解】\r\n* 局部内部类【了解】\r\n* 匿名内部类【重点】\r\n\r\n### 静态内部类\r\n**特点**\r\n* 经static修饰\r\n* 属于外部类本身\r\n* 特点和普通类的特点完全一致\r\n* 在静态内部类中能够访问外部类的静态属性和静态方法，但不能访问外部类的实例属性和方法。\r\n\r\n**使用示例**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person.Heart ht = new Person.Heart();\r\n\r\n        ht.getBeatRate();\r\n        ht.setBeatRate(123);\r\n\r\n        ht.getPersonHeight();\r\n        ht.setPersonHeight(321);\r\n    }\r\n}\r\nclass Person{\r\n    public static int height = 170;//外部类的静态属性\r\n    public static void setHeight(int height){//外部类的静态方法\r\n        Person.height = height;\r\n    }\r\n    public static class Heart{\r\n        private int beatRate = 60;\r\n\r\n        public int getBeatRate() {\r\n            return beatRate;\r\n        }\r\n\r\n        public void setBeatRate(int beatRate) {\r\n            this.beatRate = beatRate;\r\n        }\r\n        public int getPersonHeight(){\r\n//            return Person.height; //完整写法\r\n            return height;//省略写法\r\n        }\r\n        public void setPersonHeight(int height_){\r\n//            Person.height = height; //完整写法\r\n            height = height_; //省略写法\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 成员内部类\r\n* 未经static修饰\r\n* 属于外部类的对象\r\n* jdk16之前`成员内部类`不能定义静态成员，之后就可以了\r\n* 在成员内部类中可以访问外部类的静态属性静态方法，也能访问成员属性和成员方法。\r\n\r\n```java\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person.Heart ht = new Person().new Heart();\r\n\r\n        ht.getBeatRate();\r\n        ht.setBeatRate(123);\r\n\r\n        ht.getPersonHeight();\r\n        ht.setPersonHeight(321);\r\n\r\n        ht.getPersonWeight();\r\n        ht.setPersonWeight(111);\r\n        \r\n        Person ps = ht.getThisPerson();\r\n    }\r\n}\r\nclass Person{\r\n    public static int height = 170;//外部类的静态属性\r\n    public int weight = 90;//外部类的实例属性\r\n    public static void setHeight(int height){//外部类的静态方法\r\n        Person.height = height;\r\n    }\r\n    public void setWeight(int weight){\r\n        this.weight = weight;\r\n    }\r\n    public class Heart{\r\n        private int beatRate = 60;\r\n        private static  int size = 100;//jdk 16之后开始支持在成员内部类中定义静态成员\r\n\r\n        public int getBeatRate() {\r\n            return beatRate;\r\n        }\r\n\r\n        public void setBeatRate(int beatRate) {\r\n            this.beatRate = beatRate;\r\n        }\r\n        public int getPersonHeight(){\r\n            return height;//省略写法\r\n        }\r\n        public void setPersonHeight(int height_){\r\n            height = height_; //省略写法\r\n        }\r\n        public int getPersonWeight(){\r\n            return weight;//可以访问外部类的实例属性\r\n        }\r\n        public void setPersonWeight(int weight_){\r\n            setWeight(weight_);//可以访问外部实例方法\r\n        }\r\n        public Person getThisPerson(){\r\n            return People.this;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**面试题**\r\n\r\n![](./images/java学习笔记/2022-10-25-22-44-08.png)\r\n\r\n### 局部内部类\r\n在局部（局部作用域，函数，代码块）定义的类\r\n\r\n**实例**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        class Position{\r\n            public int x;\r\n            public int y;\r\n            Position(int x,int y){\r\n                this.x = x;\r\n                this.y = y;\r\n            }\r\n        }\r\n        \r\n        Position p1 = new Position(123,456);\r\n        Position p2 = new Position(321,654);\r\n\r\n        System.out.println(p1.x);\r\n        System.out.println(p2.y);\r\n    }\r\n}\r\n```\r\n\r\n### 匿名内部类【重点】\r\n* 本质上，匿名内部类是一个没有名字的局部内部类\r\n* 方便创建子类对象，目的是简化代码编写\r\n* 匿名内部类相当于写了一个没有名字子类继承自一个父类，同时返回了这个子类的实例对象\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Animal cat = new Animal() {\r\n            @Override\r\n            void say() {\r\n                System.out.println(\"喵喵喵.....\");\r\n            }\r\n        };\r\n        cat.say();\r\n    }\r\n}\r\nabstract class Animal{\r\n    abstract void say();\r\n}\r\n```\r\n\r\n**匿名内部类的测试案例**\r\n```java\r\nimport javax.swing.*;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        // 创建窗口\r\n        JFrame window = new JFrame(\"测试匿名内部类的窗口\");\r\n        // 创建面板\r\n        JPanel panel = new JPanel();\r\n        // 创建按钮\r\n        JButton btn = new JButton(\"测试按钮\");\r\n\r\n        //把按钮添加到面板\r\n        panel.add(btn);\r\n        //把面板添加到窗口\r\n        window.add(panel);\r\n\r\n        //设置窗口\r\n        window.setSize(400,500);\r\n        window.setLocationRelativeTo(null);//居中显示窗口\r\n        window.setVisible(true);//显示窗口\r\n\r\n//        该函数要求提供一个ActionListener类型的方法，并重写actionPerformed()方法\r\n//        btn.addActionListener(new ActionListener() { // 匿名内部类\r\n//            @Override\r\n//            public void actionPerformed(ActionEvent e) {\r\n//                JOptionPane.showMessageDialog(window,\"按钮的点击事件发生了，且触发了事件回调函数\");\r\n//            }\r\n//        });\r\n\r\n        //简化版\r\n        btn.addActionListener( e -> JOptionPane.showMessageDialog(window,\"按钮的点击事件发生了，且触发了事件回调函数\") );\r\n\r\n    }\r\n}\r\n```\r\n**运行效果**\r\n\r\n![](./images/java学习笔记/2022-10-25-23-45-07.png)\r\n\r\n\r\n## Object类及其常用APIs\r\nObject类是所有类的祖宗类\r\n\r\n### toString()\r\n* **默认**返回该对象在堆内存中的地址\r\n* 一般用法是让子类对其重写\r\n\r\n**默认toString**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person();\r\n        System.out.println(p1.toString());//toString返回地址\r\n        System.out.println(p1);//默认调用toString()\r\n    }\r\n}\r\nclass Person{\r\n    public String name = \"name...\";\r\n    public int age = 22;\r\n}\r\n```\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-01-36-34.png)\r\n\r\n\r\n**重写toString**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person();\r\n        System.out.println(p1.toString());//toString返回地址\r\n        System.out.println(p1);//默认调用toString()\r\n    }\r\n}\r\nclass Person{\r\n    public String name = \"name...\";\r\n    public int age = 22;\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Person{\" +\r\n                \"name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                '}';\r\n    }\r\n}\r\n```\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-01-36-52.png)\r\n\r\n\r\n### equals(Object) \r\n* **默认**比较两地址是否相同\r\n* 可让子类对其重写使其比较两对象成员属性是否相同\r\n\r\n\r\n**默认equals**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person(\"Dyg\",22);\r\n        Person p2 = new Person(\"Dyg\",22);\r\n        System.out.println(p1.equals(p2));//equals()判断对象的所有元素是否相同\r\n        System.out.println(p1==p2);//判断其地址是否相同\r\n    }\r\n}\r\nclass Person{\r\n    public String name;\r\n    public int age;\r\n\r\n    Person(String name,int age){\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n**结果**\r\n![](./images/java学习笔记/2022-10-26-08-24-15.png)\r\n\r\n**重写equals**\r\n\r\n```java\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        Person p1 = new Person(\"Dyg\",22);\r\n        Person p2 = new Person(\"Dyg\",22);\r\n        System.out.println(p1.equals(p2));//equals()判断对象的所有元素是否相同\r\n        System.out.println(p1==p2);//判断其地址是否相同\r\n    }\r\n}\r\nclass Person{\r\n    public String name;\r\n    public int age;\r\n\r\n    Person(String name,int age){\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;//若地址相等则直接返回true\r\n        if (o == null || getClass() != o.getClass()) return false;//若o地址为空，或两者类型不相同 返回false\r\n        Person person = (Person) o;//强制类型转换\r\n        return age == person.age && Objects.equals(name,person.name);//返回他们所有属性是否相同的条件表达式\r\n\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(name, age);\r\n    }\r\n}\r\n```\r\n\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-08-23-23.png)\r\n\r\n\r\n## Objects类及其常用APIs\r\n\r\n### Objects.equals\r\n一种更安全的比较两对象是否相等的方法   \r\n防止在调用`A.equals(B)`时 `A`为`null`产生报错\r\n\r\n**源码**\r\n```java\r\npublic static boolean equals(Object a, Object b) {\r\n    return (a == b) || (a != null && a.equals(b));\r\n}\r\n```\r\n\r\n### Objects.inNull\r\n判断一个对象是否为空\r\n\r\n**源码**\r\n```java\r\n    public static boolean isNull(Object obj) {\r\n        return obj == null;\r\n    }\r\n```\r\n\r\n## StringBuilder类及其常用APIs\r\n* String类创建的对象是一个不可变字符串\r\n* `StringBuilder类`创建的对象是一个**可变字符串**\r\n* **`StringBuilder类`创建的对象在字符串的拼接、修改操作上效率很高**\r\n\r\n\r\n### StringBuilder()构造器\r\n```java\r\n//两种常用构造器\r\nStringBuilder sb1 = new StringBuilder();\r\nStringBuilder sb2 = new StringBuilder(\"测试字符串\");\r\nSystem.out.println(sb1);\r\nSystem.out.println(sb2);\r\n```\r\n\r\n### append(任意类型)\r\n**特点**\r\n* append(形参支持任何类型) \r\n* 返回值为this，支持链式编程\r\n\r\n```java\r\nsb1.append(\"测试\");\r\nsb1.append(123);\r\nsb1.append(123.5).append(true).append(new Object());//链式编程：因为append返回this\r\nSystem.out.println(sb1);\r\nSystem.out.println(sb2);\r\n```\r\n\r\n### reverse()\r\n**特点**\r\n* 反转字符串\r\n* 返回this，支持链式\r\n\r\n```java\r\n//reverse()反转字符串，支持链式\r\nsb1.reverse().reverse();\r\nsb2.reverse();\r\nSystem.out.println(sb1);\r\nSystem.out.println(sb2);\r\n```\r\n\r\n### length()\r\n**特点**\r\n* 返回字符串长度\r\n\r\n```java\r\n//length()返回字符串长度\r\nSystem.out.println(sb1.length());\r\nSystem.out.println(sb2.length());\r\n```\r\n\r\n### toString()\r\n**特点**\r\n* 返回String字符串对象\r\n\r\n```java\r\n//toString()已被其重写，将返回字符串\r\nSystem.out.println(sb1.toString());//调用println则默认会调用toString()\r\nSystem.out.println(sb2.toString());\r\n```\r\n\r\n### 测试\r\n\r\n**输出任意数组值**\r\n```java\r\nimport java.util.Objects;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(intArrtoString(new int[]{1,2,3,4,5,6}));\r\n    }\r\n    public static String intArrtoString(int[] arr){\r\n        if (Objects.isNull(arr)) return null;\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append('[');\r\n        for (int i = 0; i < arr.length; i++) {\r\n            sb.append(arr[i]).append(i==arr.length-1? \"\":',');\r\n        }\r\n        sb.append(']');\r\n        return sb.toString();//返回string\r\n    }\r\n}\r\n```\r\n\r\n**结果**\r\n![](./images/java学习笔记/2022-10-26-11-09-09.png)\r\n\r\n\r\n\r\n**综合测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        //两种常用构造器\r\n        StringBuilder sb1 = new StringBuilder();\r\n        StringBuilder sb2 = new StringBuilder(\"测试字符串\");\r\n        System.out.println(sb1);\r\n        System.out.println(sb2);\r\n\r\n        //append(形参支持任何类型) 返回值为this，支持链式编程\r\n        sb1.append(\"测试\");\r\n        sb1.append(123);\r\n        sb1.append(123.5).append(true).append(new Object());//链式编程：因为append返回this\r\n        System.out.println(sb1);\r\n        System.out.println(sb2);\r\n\r\n        //reverse()反转字符串，支持链式\r\n        sb1.reverse().reverse();\r\n        sb2.reverse();\r\n        System.out.println(sb1);\r\n        System.out.println(sb2);\r\n\r\n        //toString()已被其重写，将返回字符串\r\n        System.out.println(sb1.toString());//调用println则默认会调用toString()\r\n        System.out.println(sb2.toString());\r\n\r\n        //length()返回字符串长度\r\n        System.out.println(sb1.length());\r\n        System.out.println(sb2.length());\r\n    }\r\n}\r\n```\r\n\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-10-49-46.png)\r\n\r\n\r\n## Math类及其常用APIs\r\n* Math是一个工具类\r\n* Math类没有向外提供构造函数，不能创建对象\r\n* **Math向外提供的成员属性和成员变量全部是静态的**\r\n* 使用方式\r\n  * `Math.属性名`\r\n  * `Math.方法名()`\r\n\r\n### 常用APIs\r\n\r\n| 方法名                                       | 说明                                  |\r\n| -------------------------------------------- | ------------------------------------- |\r\n| public static int abs(int a)                 | 获取参数绝对值                        |\r\n| public static double ceil(double a)          | 向上取整                              |\r\n| public static double floor( double a)        | 向下取整                              |\r\n| public static int round(float a)             | 四舍五入                              |\r\n| public static int max(int a,int b)           | 获取两个int值中的较大值               |\r\n| public static double pow( double a,double b) | 返回a的b次幂的值                      |\r\n| public static double random()                | 返回值为double的随机值，范围[0.0,1.0) |\r\n\r\n## System类及其常用APIs\r\n* System类没有向外提供构造函数，不能创建对象\r\n\r\n### 常用APIs\r\n\r\n| 方法名                                                                         | 说明                                       |\r\n| ------------------------------------------------------------------------------ | ------------------------------------------ |\r\n| public static void exit(int status)                                            | 终止当前运行的Java虚拟机，非零表示异常终止 |\r\n| public static long currentTimeMillis()                                         | 返回当前系统的时间毫秒值形式               |\r\n| public static void arraycopy(数据源数组,起始索引,目的地数组,起始索引,拷贝个数) | 数组拷贝                                   |\r\n\r\n\r\n**测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        //代码性能测试\r\n        long startTime = System.currentTimeMillis();\r\n        for (int i = 0; i < 100000; i++) {\r\n            System.out.println(i);\r\n        }\r\n        long endedTime = System.currentTimeMillis();\r\n        long gap = endedTime - startTime;\r\n        System.out.println(\"耗时\"+gap/1000.0+\"s\");\r\n\r\n        //数组拷贝\r\n        int[] arr1 = {111,222,333,444,555};\r\n        int[] arr2 = new int[20];// [0,0,0,0,0,0,0,0,......]\r\n        System.arraycopy(arr1,0,arr2,10,5);\r\n        System.out.println(intArrtoString(arr2));\r\n\r\n        //提前结束java虚拟机\r\n        System.exit(123);\r\n        System.out.println(\"？？？\");\r\n    }\r\n    public static String intArrtoString(int[] arr){\r\n        if (Objects.isNull(arr)) return null;\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append('[');\r\n        for (int i = 0; i < arr.length; i++) {\r\n            sb.append(arr[i]).append(i==arr.length-1? \"\":',');\r\n        }\r\n        sb.append(']');\r\n        return sb.toString();//返回string\r\n    }\r\n}\r\n```\r\n**运行结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-11-48-57.png)\r\n\r\n\r\n## BigDecimal类及其常用APIs\r\n**用于解决浮点数运算精度失真的问题:**\r\n```java\r\nSystem.out.println(0.09+0.01);\r\n```\r\n**失真的输出结果：**\r\n\r\n![](./images/java学习笔记/2022-10-26-12-38-31.png)\r\n\r\n\r\n### BigDecimal构造函数\r\n* **BigDecimal提供了多个构造函数**\r\n* **BigDecimal构造函数使用<warn>注意事项</warn>**\r\n    * BigDecimal提供了`BigDecimal(double)`的构造函数,**通过这种方式传递浮点数仍然存在浮点数的精度问题**\r\n    * 应当使用的创建BigDecimal对象的方式\r\n      * `BigDecimal(String)`\r\n      * `BigDecimal.valueOf(double)` 该方法内部使用了Double.toString方法，此方法按照double实际能表示的精度对尾数进行了截取\r\n```java\r\n//实际推荐的用法\r\nBigDecimal b1 = new BigDecimal(\"0.135\");\r\nBigDecimal b1 = new BigDecimal(0.135.toString());\r\nBigDecimal b1 = BigDecimal.valueOf(0.135);\r\n```\r\n\r\n### 常用APIs\r\n | 方法名                                                                   | 说明         |\r\n | ------------------------------------------------------------------------ | ------------ |\r\n | public BigDecimal add(BigDecimal b)                                      | 加法         |\r\n | public BigDecimal subtract(BigDecimal b)                                 | 减法         |\r\n | public BigDecimal multiply(BigDecimal b)                                 | 乘法         |\r\n | public BigDecimal divide(BigDecimal b)                                   | 除法         |\r\n | public Double doubleValue()                                              | 获取double值 |\r\n | BigDecimal.valueOf(money).setScale(2,RoundingMode.HALF_UP).doubleValue() | 四舍五入     |\r\n\r\n**add()方法使用测试**\r\n```java\r\nimport java.math.BigDecimal;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        BigDecimal b1 = BigDecimal.valueOf(0.123);\r\n        BigDecimal b2 = BigDecimal.valueOf(0.123);\r\n\r\n        BigDecimal result = b1.add(b2);\r\n        Double result_db = result.doubleValue();\r\n\r\n        System.out.println(result);\r\n        System.out.println(result_db);\r\n    }\r\n}\r\n```\r\n\r\n### 精度问题\r\nBigDecimal只能处理**有限小数**\r\n\r\n**BigDecimal无法处理无限小数**\r\n```java\r\nBigDecimal b1 = BigDecimal.valueOf(10.0);\r\nBigDecimal b2 = BigDecimal.valueOf(3.0);\r\n\r\nBigDecimal result = b1.divide(b2);//    10.0/3.0 == 0.333333333333333 报错\r\nDouble result_db = result.doubleValue();\r\n\r\nSystem.out.println(result);\r\nSystem.out.println(result_db);\r\n```\r\n![](./images/java学习笔记/2022-10-26-13-14-44.png)\r\n\r\n**正确写法:**\r\n```java\r\nBigDecimal b1 = BigDecimal.valueOf(10.0);\r\nBigDecimal b2 = BigDecimal.valueOf(3.0);\r\n\r\nBigDecimal result = b1.divide(b2,3, RoundingMode.CEILING);//    指定保留的小数位数和最后一位小数的进位模式（四舍五入、向上取整，向下取整......）\r\nDouble result_db = result.doubleValue();\r\n\r\nSystem.out.println(result);\r\nSystem.out.println(result_db);\r\n```\r\n![](./images/java学习笔记/2022-10-26-13-14-23.png)\r\n\r\n### 二次封装\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(0.09+0.01);\r\n        System.out.println(add(0.09,0.01));\r\n    }\r\n    public static double add(double a,double b){\r\n        return BigDecimal.valueOf(a).add(BigDecimal.valueOf(b)).doubleValue();\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-13-06-14.png)\r\n\r\n## Date日期对象及常用APIs\r\n\r\n### 构造器\r\n| 构造器名称      | 描述                             |\r\n| --------------- | -------------------------------- |\r\n| Date()          | 返回一个代表当前时间Date对象     |\r\n| Date(long date) | 根据传入的毫秒数返回一个Date对象 |\r\n\r\n\r\n```java\r\nDate d1 = new Date();\r\nSystem.out.println(d1);//输出值不是对象的地址，表示其toString方法被重写了\r\n```\r\n![](./images/java学习笔记/2022-10-26-13-36-10.png)\r\n\r\n\r\n### 常用方法\r\n| API名称          | 描述             |\r\n| ---------------- | ---------------- |\r\n| getTime()        | 获取毫秒值       |\r\n| setTime()        | 设置毫秒值       |\r\n| a.before(Date b) | 判断是否a在b之前 |\r\n| a.after(Date b)  | 判断是否a在b之后 |\r\n\r\n```java\r\nDate d1 = new Date();\r\nSystem.out.println(d1.getTime());\r\n```\r\n![](./images/java学习笔记/2022-10-26-13-38-06.png)\r\n\r\n\r\n## SimpleDateFormat 日期对象及常用APIs\r\n### 构造器\r\n| 构造器名称                       | 描述     |\r\n| -------------------------------- | -------- |\r\n| SimpleDateFormat()               | 默认格式 |\r\n| SimpleDateFormat(String pattern) | 指定格式 |\r\n\r\n格式\r\n| 年  | 月  | 日  | 时  | 分  | 秒  |\r\n| --- | --- | --- | --- | --- | --- |\r\n| y   | M   | d   | H   | m   | s   |\r\n\r\n**案例**\r\n```java\r\nSimpleDateFormat sfm1 = new SimpleDateFormat();//按默认格式化\r\nSimpleDateFormat sfm2 = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss EEE a\");//按指定形式格式化\r\n```\r\n\r\n### 常用方法\r\n| API名称                   | 描述                      |\r\n| ------------------------- | ------------------------- |\r\n| setTime(Object time)      | 将毫秒数格式化            |\r\n| String format(Data data)  | 将日期对象格式化          |\r\n| Data parse(String source) | e解析日期字符串为Data对象 |\r\n\r\n**测试format的案例**\r\n```java\r\nSimpleDateFormat sfm1 = new SimpleDateFormat();//按默认格式化\r\nSimpleDateFormat sfm2 = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss EEE a\");//按指定形式格式化\r\nSystem.out.println(sfm1.format(new Date()));//按默认格式化输出\r\nSystem.out.println(sfm2.format(new Date()));//按指定形式格式化输出\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-14-13-27.png)\r\n\r\n**测试parse解析日期字符串的案例（面试题）**\r\n![](./images/java学习笔记/2022-10-26-14-14-40.png)\r\n\r\n\r\n```java\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args) throws ParseException {\r\n        String source = \"2021年08月06日11点11分11秒\";\r\n        String result = \"\";\r\n\r\n        System.out.println(\"原时间：\" + source);\r\n\r\n        SimpleDateFormat sfm3 = new SimpleDateFormat(\"yyyy年MM月dd日HH点mm分ss秒\");//按指定形式格式化\r\n        Date d1 = sfm3.parse(source);\r\n        System.out.println( \"时间解析完毕：\" + d1);\r\n\r\n        //定义一些基本单位\r\n        int s = 1000;\r\n        int m = 60*s;\r\n        int h = 60*m;\r\n        int d = 24*h;\r\n        long newTime = d1.getTime() + 2 * d + 14 * h +  49 * m + 6 * s;//2天 14小时 49分 6秒 后\r\n        result = sfm3.format(new Date(newTime));\r\n\r\n        System.out.println(\"2天 14小时 49分 6秒 后的新时间为：\");\r\n        System.out.println(result);\r\n    }\r\n}\r\n\r\n```\r\n**运行结果为：**  \r\n![](./images/java学习笔记/2022-10-26-14-48-12.png)\r\n\r\n\r\n## Calendar 日历对象及常用APIs\r\n* Calendar是一个抽象类，无法直接实例化对象\r\n\r\n### APIs\r\n\r\n| API名称                               | 描述                            |\r\n| ------------------------------------- | ------------------------------- |\r\n| static Calendar getInstance()         | 获取实例化对象（默认当前时间）  |\r\n| public int get(int field)             | 获取日期中的某个字段信息。      |\r\n| public void set(int field,int value)  | 修改日历的某个字段信息。        |\r\n| public void add(int field,int amount) | 为某个字段**增加/减少**指定的值 |\r\n| public final Date getTime()           | **拿到此刻日期对象。**          |\r\n| setTime(Date)                         | **设置日历为某日期对象**        |\r\n| public long getTimeInMillis()         | 拿到此刻时间毫秒值              |\r\n\r\n**测试**\r\n```java\r\nimport java.util.Calendar;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        //获取实例化对象\r\n        Calendar ca = Calendar.getInstance();\r\n        //输出实例化对象\r\n        System.out.println(ca);\r\n\r\n        //获取日期中的某个字段信息。\r\n        System.out.println(ca.get(Calendar.YEAR));\r\n        System.out.println(ca.get(Calendar.MONTH));\r\n        System.out.println(ca.get(Calendar.DAY_OF_MONTH));\r\n\r\n        //修改日历的某个字段信息。\r\n        ca.set(Calendar.YEAR,2023);\r\n        ca.set(Calendar.MONTH,2);\r\n        ca.set(Calendar.DAY_OF_MONTH,2);\r\n\r\n        //为某个字段**增加/减少**指定的值\r\n        ca.add(Calendar.YEAR,2);\r\n        ca.add(Calendar.MONTH,2);\r\n        ca.add(Calendar.DAY_OF_MONTH,2);\r\n\r\n        //拿到此刻日期对象。\r\n        System.out.println(ca.getTime());\r\n        //修改日历时间\r\n//      ca.setTime(new Date());\r\n\r\n        //拿到此刻时间毫秒值\r\n        System.out.println(ca.getTimeInMillis());\r\n\r\n        //再次输出实例化对象\r\n        System.out.println(ca);\r\n    }\r\n}\r\n\r\n```\r\n\r\n输出结果\r\n```\r\njava.util.GregorianCalendar[time=1666769236461,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2022,MONTH=9,WEEK_OF_YEAR=44,WEEK_OF_MONTH=5,DAY_OF_MONTH=26,DAY_OF_YEAR=299,DAY_OF_WEEK=4,DAY_OF_WEEK_IN_MONTH=4,AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=27,SECOND=16,MILLISECOND=461,ZONE_OFFSET=28800000,DST_OFFSET=0]\r\n2022\r\n9\r\n26\r\nSun May 04 15:27:16 CST 2025\r\n1746343636461\r\njava.util.GregorianCalendar[time=1746343636461,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id=\"Asia/Shanghai\",offset=28800000,dstSavings=0,useDaylight=false,transitions=31,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2025,MONTH=4,WEEK_OF_YEAR=19,WEEK_OF_MONTH=2,DAY_OF_MONTH=4,DAY_OF_YEAR=124,DAY_OF_WEEK=1,DAY_OF_WEEK_IN_MONTH=1,AM_PM=1,HOUR=3,HOUR_OF_DAY=15,MINUTE=27,SECOND=16,MILLISECOND=461,ZONE_OFFSET=28800000,DST_OFFSET=0]\r\n\r\nProcess finished with exit code 0\r\n```\r\n\r\n\r\n## JDK8新增时间类\r\n### `LocalDate`、`LocalTime`、`LocalDateTime`类及其APIs\r\n\r\n**新API特点**\r\n* 严格区分了 `日期` 、 `时间` 、 `日期及时间` 对象\r\n* 对日期和时间的运算更方便\r\n* 新API的类型几乎是不变的，不必担心被修改\r\n\r\n**新增的日期类**\r\n| 类名              | 描述                       |\r\n| ----------------- | -------------------------- |\r\n| **LocalDate**     | 不包含具体时间的日期。     |\r\n| **LocalTime**     | 不含日期的时间。           |\r\n| **LocalDateTime** | 包含了日期及时间。         |\r\n| Instant           | 代表的是时间戳。           |\r\n| DateTimeFormatter | 用于做时间的格式化和解析的 |\r\n| Duration          | 用于计算两个“时间”间隔     |\r\n| Period            | 用于计算两个“日期”间隔     |\r\n\r\n\r\n\r\n\r\n#### 构造函数\r\n| 方法名 | 描述                 |\r\n| ------ | -------------------- |\r\n| now()  | 根据当前时间创建对象 |\r\n| of()   | 根据指定时间创建对象 |\r\n\r\n**使用测试**\r\n```java\r\nimport java.time.LocalDate;\r\nimport java.time.LocalDateTime;\r\nimport java.time.LocalTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDate localDate = LocalDate.now();\r\n        LocalTime localTime = LocalTime.now();\r\n        LocalDateTime localDateTime = LocalDateTime.now();\r\n\r\n        System.out.println(localDate);\r\n        System.out.println(localTime);\r\n        System.out.println(localDateTime);\r\n\r\n        LocalDate localDate1 = LocalDate.of(2022,11,11);\r\n        LocalTime localTime1 = LocalTime.of(11,11,11);\r\n        LocalDateTime localDateTime1 = LocalDateTime.of(2020,10,6,13,23,43);\r\n\r\n        System.out.println(localDate1);\r\n        System.out.println(localTime1);\r\n        System.out.println(localDateTime1);\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-16-34-10.png)\r\n\r\n\r\n#### 常用成员函数APIs\r\n\r\n | 方法名                          | 说明               |\r\n | ------------------------------- | ------------------ |\r\n | public int geYear()             | 获取年             |\r\n | public int getMonthValue()      | 获取月份（1-12)    |\r\n | Public int getDayOfMonth()      | 获取月中第几天乘法 |\r\n | Public int getDayOfYear()       | 获取年中第几天     |\r\n | Public DayOfWeek getDayofweek() | 获取星期           |\r\n\r\n\r\n**成员函数调用测试**\r\n```java\r\nimport java.time.LocalDateTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime localDateTime = LocalDateTime.now();\r\n        System.out.println(localDateTime.getYear());\r\n        System.out.println(localDateTime.getMonthValue());\r\n        System.out.println(localDateTime.getDayOfMonth());\r\n        System.out.println(localDateTime.getHour());\r\n        System.out.println(localDateTime.getMinute());\r\n        System.out.println(localDateTime.getSecond());\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-17-09-23.png)\r\n\r\n**`LocalDate` `LocalTime` `LocalDateTime`之间的类型转换**\r\n| 方法名                         | 说明                    |\r\n| ------------------------------ | ----------------------- |\r\n| public LocalDate toLocalDate() | 转换成一个LocalDate对象 |\r\n| public LocalTime toLocalTime() | 转换成一个LocalTime对象 |\r\n\r\n![](./images/java学习笔记/2022-10-26-17-05-35.png)\r\n\r\n\r\n**类型转换函数测试**\r\n```java\r\nimport java.time.LocalDate;\r\nimport java.time.LocalDateTime;\r\nimport java.time.LocalTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime ldt = LocalDateTime.now();\r\n        LocalDate ld = ldt.toLocalDate();\r\n        LocalTime lt = ldt.toLocalTime();\r\n\r\n        System.out.println(ldt);\r\n        System.out.println(ld);\r\n        System.out.println(lt);\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-17-12-08.png)\r\n\r\n**时间修改的方法**\r\n* **这些方法不会修改原对象的内容**\r\n* **方法会返回一个新对象**\r\n\r\n| 方法名                                             | 说明                                                                  |\r\n| -------------------------------------------------- | --------------------------------------------------------------------- |\r\n| plusDays, plusweeks, plusMonths, plusYears         | 向当前LocalDate对象添加几天、几周、几个月、几年                       |\r\n| minusDays, minusWeeks, minusMonths, minusYears     | 从当前LocalDate 对象减去几天、几周、几个月、几年                      |\r\n| withDayOfMonth, withDayOfYear, withMonth, withYear | 将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate对象 |\r\n| isBefore, isAfter                                  | 比较两个LocalDate                                                     |\r\n| equals                                             | 相等判断                                                              |\r\n\r\n**plus...()测试**\r\n```java\r\nimport java.time.LocalDateTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime ldt = LocalDateTime.now();\r\n\r\n        System.out.println(ldt);\r\n        System.out.println(ldt.plusYears(1));\r\n        System.out.println(ldt.plusMonths(1));\r\n        System.out.println(ldt.plusDays(1));\r\n        System.out.println(ldt.plusHours(1));\r\n        System.out.println(ldt.plusMinutes(1));\r\n        System.out.println(ldt.plusSeconds(1));\r\n        System.out.println(ldt.plusNanos(1));\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-18-26-29.png)\r\n\r\n**isBefore()、isAfter()测试**\r\n```java\r\nimport java.time.LocalDateTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime ldt1 = LocalDateTime.now();\r\n        LocalDateTime ldt2 = LocalDateTime.now();\r\n        \r\n        ldt1 = ldt1.minusDays(1);\r\n        ldt2 = ldt2.plusDays(1);\r\n        \r\n        System.out.println(ldt1);\r\n        System.out.println(ldt2);\r\n\r\n        System.out.println(ldt1.isBefore(ldt2));\r\n        System.out.println(ldt2.isAfter(ldt1));\r\n\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-26-18-38-54.png)\r\n\r\n\r\n### `Instant`类及APIs\r\n\r\n**新API特点**\r\n* 新API的类型几乎是不变的，不必担心被修改\r\n\r\n**新增的日期类**\r\n| 类名              | 描述                       |\r\n| ----------------- | -------------------------- |\r\n| LocalDate         | 不包含具体时间的日期。     |\r\n| LocalTime         | 不含日期的时间。           |\r\n| LocalDateTime     | 包含了日期及时间。         |\r\n| **Instant**       | 代表的是时间戳。           |\r\n| DateTimeFormatter | 用于做时间的格式化和解析的 |\r\n| Duration          | 用于计算两个“时间”间隔     |\r\n| Period            | 用于计算两个“日期”间隔     |\r\n\r\n\r\n#### Instant创建实例对象\r\n**Instant创建实例对象测试**\r\n```java\r\nimport java.time.Instant;\r\nimport java.time.ZoneId;\r\nimport java.time.ZonedDateTime;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Instant instant = Instant.now();//获取世界标准时间\r\n        System.out.println(instant);\r\n\r\n        ZonedDateTime zdt = instant.atZone(ZoneId.systemDefault());//获取系统默认所在地区时间\r\n        System.out.println(zdt);\r\n    }\r\n}\r\n```\r\n**输出结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-19-46-41.png)\r\n\r\n#### 一些方法\r\n> 事实上，instant就是jdk8之前的Date\r\n**Date 和 Instant 互相转换**\r\n```java\r\nimport java.time.Instant;\r\nimport java.util.Date;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Instant instant = Instant.now();//获取世界标准时间\r\n\r\n        System.out.println(instant);\r\n\r\n        //Date 和 Instant 互相转换\r\n        Date date = Date.from(instant);\r\n        instant = date.toInstant();\r\n\r\n        System.out.println(instant);\r\n        \r\n    }\r\n}\r\n```\r\n**输出**\r\n\r\n![](./images/java学习笔记/2022-10-26-20-04-12.png)\r\n\r\n\r\n### `Instant`类及APIs\r\n\r\n**新API特点**\r\n* 新API的类型几乎是不变的，不必担心被修改\r\n\r\n**新增的日期类**\r\n| 类名                  | 描述                       |\r\n| --------------------- | -------------------------- |\r\n| LocalDate             | 不包含具体时间的日期。     |\r\n| LocalTime             | 不含日期的时间。           |\r\n| LocalDateTime         | 包含了日期及时间。         |\r\n| Instant               | 代表的是时间戳。           |\r\n| **DateTimeFormatter** | 用于做时间的格式化和解析的 |\r\n| Duration              | 用于计算两个“时间”间隔     |\r\n| Period                | 用于计算两个“日期”间隔     |\r\n\r\n#### 实例化\r\n```java\r\nDateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\r\n```\r\n\r\n#### 方法\r\n\r\n**format()方法**\r\n```java\r\nimport java.time.LocalDateTime;\r\nimport java.time.format.DateTimeFormatter;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime localDateTime = LocalDateTime.now();\r\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\r\n\r\n        System.out.println(dateTimeFormatter.format(localDateTime));//正反都能调用\r\n        System.out.println(localDateTime.format(dateTimeFormatter));//正反都能调用\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-26-20-21-46.png)\r\n\r\n**解析时间字符串**\r\n```java\r\nimport java.time.LocalDateTime;\r\nimport java.time.format.DateTimeFormatter;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\r\n        LocalDateTime time = LocalDateTime.parse(\"2011-11-11 11:11:11\",dateTimeFormatter);\r\n        System.out.println(time);\r\n        System.out.println(time.getYear());//解析后可以很方便的获取年 月 日\r\n        System.out.println(time.getMonthValue());\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-26-20-26-33.png)\r\n\r\n\r\n### Period类\r\n**基本作用**\r\n* <green>**用于计算日期间隔**</green>\r\n* 提供的方法主要有`getYears() getMonths() getDays()`,**只能精确到天**\r\n* 用于`LocalDate`对象之间的计算\r\n```java\r\nimport java.time.LocalDate;\r\nimport java.time.Period;\r\n\r\npublic class HelloWorld {\r\n\r\n    public static void main(String[] args)  {\r\n        LocalDate now = LocalDate.now();\r\n        LocalDate birth = LocalDate.of(2001,9,16);\r\n        Period period = Period.between(birth,now);\r\n\r\n        System.out.println(\"你的年龄：\" + period.getYears());\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-26-20-33-38.png)\r\n\r\n\r\n### Duration类\r\n**基本作用**\r\n* <green>**用于计算时间间隔**</green>\r\n* 用于LocalDateTime之间的比较\r\n* 用于Instant之间的比较\r\n\r\n**测试**\r\n```java\r\nimport java.time.Duration;\r\nimport java.time.LocalDateTime;\r\n\r\npublic class HelloWorld {\r\n\r\n    public static void main(String[] args)  {\r\n        LocalDateTime now = LocalDateTime.now();\r\n        LocalDateTime birth = LocalDateTime.of(2001,9,16,0,0,0);\r\n        Duration duration = Duration.between(birth,now);\r\n\r\n        System.out.println(\"你至今已活天数：\" + duration.toDays());\r\n        System.out.println(\"你至今已活小时数：\" + duration.toHours());\r\n        System.out.println(\"你至今已活分钟数：\" + duration.toMinutes());\r\n        System.out.println(\"你至今已活秒数：\" + duration.toSeconds());\r\n    }\r\n}\r\n```\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-26-20-49-39.png)\r\n\r\n\r\n### ChronoUnit类\r\n\r\n**可用于比较所有单位**\r\n\r\n```java\r\nimport java.time.LocalDateTime;\r\nimport java.time.temporal.ChronoUnit;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        LocalDateTime today = LocalDateTime.now( ) ;\r\n        System.out.println(today);\r\n        LocalDateTime birthDate = LocalDateTime.of(1921,1,1,1,1,1);\r\n        System.out.println(birthDate);\r\n        System.out.println(\"相差的年数:\" + ChronoUnit.YEARS.between(birthDate,today));\r\n        System.out.println(\"相差的月数:\"+ChronoUnit.MONTHS.between(birthDate,today));\r\n        System.out.println(\"相差的周数:\" +ChronoUnit.WEEKS.between(birthDate,today));\r\n        System.out. println(\"相差的天数:\" +ChronoUnit.DAYS.between(birthDate,today));\r\n        System.out. println(\"相差的时数:\"+ChronoUnit.HOURS.between(birthDate,today));\r\n        System.out.println(\"相差的分数:\"+ChronoUnit.MINUTES.between(birthDate, today));\r\n        System.out.println(\"相差的秒数:\"+ChronoUnit.SECONDS.between(birthDate,today));\r\n        System.out.println(\"相差的毫秒数:\" +ChronoUnit.MILLIS.between(birthDate,today));\r\n        System.out.println(\"相差的微秒数:\"+ChronoUnit.NANOS.between(birthDate,today));\r\n        System.out.println(\"相差的纳秒数:\" + ChronoUnit.NANOS.between(birthDate,today));\r\n        System.out.println(\"相差的半天数:\"+ChronoUnit.HALF_DAYS.between(birthDate,today));\r\n        System.out.println(\"相差的十年数:\" +ChronoUnit.DECADES.between(birthDate,today));\r\n        System.out.println(\"相差的世纪（百年）数: \" +ChronoUnit.CENTURIES.between(birthDate,today));\r\n        System.out.println(\"相差的千年数:\" +ChronoUnit.MILLENNIA.between(birthDate,today));\r\n        System.out.println(\"相差的纪元数:\" +ChronoUnit.ERAS.between(birthDate,today));\r\n    }\r\n}\r\n```\r\n\r\n## 包装类\r\n\r\n**概念**\r\n* **包装类就是8中基本类型的引用类型**\r\n* java为实现一切皆对象，将基本数据类型进行了包装，抽象成了类\r\n* 集合与泛型只支持包装类型，不支持基本数据类型\r\n\r\n**包装类的特点**\r\n* 自动装包：基本数据类型可直接赋值给包装数据类型\r\n* 自动解包：包装数据类型可直接赋值给基本数据类型\r\n* 包装类的默认值可为null，**容错率更高**\r\n* 可以字符串转包装类(有用)\r\n  * `Integer.parseInt(\"123\")`\r\n  * `Double.parseDouble(\"12.3\")`\r\n  * `Integer.valueOf(\"123\")`\r\n  * `Double.valueOf(\"12.3\")`\r\n* 可以包装类转字符串\r\n  * `obj.toString()`\r\n  * `包装类名.toString()`\r\n\r\n\r\n| 基本数据类型 | 引用数据类型 |\r\n| ------------ | ------------ |\r\n| byte         | Byte         |\r\n| short        | Short        |\r\n| int          | Integer      |\r\n| long         | Long         |\r\n| char         | Character    |\r\n| float        | Float        |\r\n| double       | Double       |\r\n| boolean      | Boolean      |\r\n\r\n**基本使用测试**\r\n```java\r\n        int a = 10;\r\n        Integer aa = 10;\r\n//        Integer aa = new Integer(10);//写法自9起弃用\r\n        System.out.println(a);\r\n        System.out.println(aa);\r\n```\r\n\r\n## 正则表达式\r\n\r\n\r\n### API\r\n**字符串提供的匹配正则表达式的方法**\r\n| API                                                     | 描述                                                                   |\r\n| ------------------------------------------------------- | ---------------------------------------------------------------------- |\r\n| `public Boolean matches(String regex);`                 | 匹配正则成功返回true                                                   |\r\n| `public String replaceAll(String regex,String newStr);` | 对匹配到的内容替换并返回                                               |\r\n| `public String[] split(String regex);`                  | 将匹配到的内容看做分隔符，把被分割符分割的部分提取放到一个字符串数组中 |\r\n\r\n\r\n### 正则语法\r\n\r\n**单字符匹配**\r\n| 正则写法        | 意义                                               |\r\n| --------------- | -------------------------------------------------- |\r\n| `[abc]`         | 只能是a, b,或c                                     |\r\n| `[^abc]`        | 除了a, b, c之外的任何字符                          |\r\n| `[a-zA-Z]`      | (可理解为是：`[[a-z]+[A-Z]]`) a到zA到Z，           |\r\n| `[a-d[m-p]]`    | (可理解为是： `[[a-d]\\|\\|[m-p]]` ) a到d，或m通过p: |\r\n| `[a-z&&[def]]`  | (可理解为是：`[[a-z]&&[def]]`) d,e,或f             |\r\n| `[a-z&&[^bc]]`  | (可理解为是：`[[a-z]&&[^bc]]`) a到z，除了b和c:     |\r\n| `[a-z&&[Am-p]]` | (可理解为是：`[[a-z]&&[Am-p]]`) a到z，除了m到p:    |\r\n\r\n\r\n**预定义单字符匹配**\r\n| 正则写法 | 意义                            |\r\n| -------- | ------------------------------- |\r\n| `.`      | 任意字符                        |\r\n| `\\t`     | 水平制表符                      |\r\n| `\\x0b`   | 垂直制表符                      |\r\n| `\\b`     | backspace退格                   |\r\n| `\\f`     | 换页符                          |\r\n| `\\r`     | 回车CR(carriage return)0x0D     |\r\n| `\\n`     | 换行LF(Line Feed)0x0A           |\r\n| `\\d`     | 数字`[0-9]`                     |\r\n| `\\D`     | 非数字`[^0-9]`                  |\r\n| `\\s`     | 空白字符`[\\t\\x0b\\f\\b\\r\\n]`      |\r\n| `\\S`     | 非空白字符`[^\\t\\x0b\\f\\b\\r\\n]`   |\r\n| `\\w`     | 英文数字下划线`[_a-zA-Z0-9]`    |\r\n| `\\W`     | 非英文数字下划线`[^_a-zA-Z0-9]` |\r\n\r\n**关于回车换行**\r\n* **回车**是传统英文打字机的打字小车回到本行开头但不换行\r\n* **换行**是传统英文打字机的打字小车换到当前位置的下一行\r\n* windows下enter是 `\\r\\n`; \r\n* linux/unix下enter是`\\n`; \r\n* mac下enter是`\\r`\r\n\r\n\r\n\r\n**贪婪匹配**\r\n| 正则写法 | 意义               |\r\n| -------- | ------------------ |\r\n| `X?`     | X 0次或1次         |\r\n| `X*`     | X 0次或多次        |\r\n| `X+`     | X 1次或多次        |\r\n| `X{n}`   | X 正好n次          |\r\n| `X{n,}`  | X 至少n次          |\r\n| `X{n,m}` | X 至少n次不超过m次 |\r\n\r\n\r\n### 案例测试\r\n\r\n**基本使用**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        System.out.println(\"2122312311\".matches(\"[\\\\d]{5,20}\"));//匹配qq号\r\n        System.out.println(\"21223_1ajewor212311\".matches(\"[\\\\w]{6,}\"));//匹配密码：数字字母下换线至少6位\r\n        System.out.println(\"12_1\".matches(\"[0-9a-zA-Z]{4}\"));//匹配验证码：数字+字母，必须四位\r\n        System.out.println(\"12k1\".matches(\"[\\\\w&&[^_]]{4}\"));//匹配验证码：数字+字母，必须四位\r\n    }\r\n}\r\n```\r\n**结果**\r\n\r\n![](./images/java学习笔记/2022-10-27-00-45-16.png)\r\n\r\n\r\n**匹配手机号、匹配邮箱、座机号码、校验金额**\r\n```java\r\npublic class HelloWorld {\r\n\r\n    public static void main(String[] args)  {\r\n        //匹配手机号\r\n        System.out.println(\"13345678901\".matches(\"[1][3-9][\\\\d]{9}\"));//第一位是1 第二位是3~9 剩下9位数字\r\n        //匹配邮箱\r\n        System.out.println(\"176251@qq.com\".matches(\"[\\\\w]{1,}[@][\\\\w]{2,}([\\\\.][\\\\w]{2,}){1,}\"));// 至少一个字符的用户名 + @ + 至少两个字符的域名 + ( 点 + 一级/二级域名 ){至少1次, }\r\n        System.out.println(\"176251@qq.com.cn\".matches(\"[\\\\w]{1,}[@][\\\\w]{2,}([\\\\.][\\\\w]{2,}){1,}\"));\r\n        //匹配座机号码\r\n        System.out.println(\"012-111111111\".matches(\"[0][0-9]{2,5}[-]?[\\\\d]{5,}\"));//0开头 + 2~5位区号 + 可有可无的-符号 + 至少5位的数字\r\n\r\n        //校验金额\r\n        System.out.println(\"12.32\".matches(\"[\\\\d]{1,}([\\\\.][\\\\d]{1,2})?\")); //至少一位数 + 可有可无的(一个小数点 + 至少一个最多两个的数字)\r\n        System.out.println(\"12123123\".matches(\"[\\\\d]{1,}([\\\\.][\\\\d]{1,2})?\")); //至少一位数 + 可有可无的(一个小数点 + 至少一个最多两个的数字)\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-01-18-56.png)\r\n\r\n**splice测试**\r\n```java\r\npublic class HelloWorld {\r\n\r\n    public static void main(String[] args)  {\r\n        String res = \"测试文字一jie0wfj03290测试文字二fjwf2rwdf0测试文字三\";\r\n        String[] tests = res.split(\"\\\\w+\");\r\n        for (int i = 0; i < tests.length; i++) {\r\n            System.out.println(tests[i]);\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-01-28-47.png)\r\n\r\n\r\n**replaceAll测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        String res = \"测试文字一jie0wfj03290测试文字二fjwf2rwdf0测试文字三\".replaceAll(\"\\\\w+\",\"\\t\");\r\n        System.out.println(res);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-01-31-04.png)\r\n\r\n\r\n**爬取手机号邮箱号电话号**\r\n```java\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        //内容\r\n        String context = \"电话020-43422424邮箱176251@qq.com电话17625191722,17625191721\";\r\n        \r\n        //定义正则表达式\r\n        String regex = \"([1][3-9][\\\\d]{9})|\" +//匹配手机号\r\n                \"([\\\\w]{1,}[@][\\\\w]{2,}([\\\\.][\\\\w]{2,}){1,})|\" +//匹配邮箱\r\n                \"([0][0-9]{2,5}[-]?[\\\\d]{5,})\";//匹配座机号码\r\n        \r\n        //将正则表达式编译为匹配规则\r\n        Pattern pattern = Pattern.compile(regex);\r\n        \r\n        //根据匹配规则和待匹配的文本得到一个匹配器对象\r\n        Matcher matcher = pattern.matcher(context);\r\n        \r\n        //匹配\r\n        while (matcher.find()){//匹配到\r\n            String finded = matcher.group();//提取\r\n            System.out.println(finded);//输出\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-11-05-30.png)\r\n\r\n\r\n## Arrays数组的工具类\r\n用于操作数组的工具类，\r\n\r\n| 方法名                                                          | 说明                                                                                 |\r\n| --------------------------------------------------------------- | ------------------------------------------------------------------------------------ |\r\n| `public static String tostring(类型[] a)`                       | 将数组转换成字符串                                                                   |\r\n| `public static void sort(类型[]a)    `                          | 对数组进行排序，默认升序排序                                                         |\r\n| `public static <T> void sort(类型[]a, Comparator<? super T> c)` | 使用比较器对象自定义排序                                                             |\r\n| `public static int binarySearch(int[]a, int key)`               | 二分搜索数组中的数据，存在返回索引，不存在返回负数（表示应当插入位置的坐标的负数-1） |\r\n\r\n### tostring\r\n**Arrays.tostring测试**\r\n```java\r\nimport java.util.Arrays;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        int[] arr1 = {1,2,3,4,5,6,7,8,9,10};\r\n        System.out.println(arr1);\r\n        System.out.println(Arrays.toString(arr1));\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-12-18-53.png)\r\n\r\n\r\n### sort\r\n\r\n**Arrays.sort测试**\r\n```java\r\nimport java.util.Arrays;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        int[] arr1 = {10,9,8,7,6,5,4,3,2,1,0};\r\n        Arrays.sort(arr1);\r\n        System.out.println(Arrays.toString(arr1));\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-12-23-19.png)\r\n\r\n\r\n### 自定义sort排序\r\n\r\n**Arrays.sort的自定义排序测试**\r\n```java\r\nimport java.util.Arrays;\r\nimport java.util.Comparator;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Integer[] arr1 = {0,1,2,3,4,5,6,7,8,9,10};//Comparator仅支持引用数据类型\r\n        Arrays.sort(arr1, new Comparator<Integer>() {//Comparator仅支持引用数据类型\r\n            @Override //实际这里是实现了一个接口，重写了接口的compare方法，new了一个匿名的比较器类对象，sort使用了这个比较器对象compare()方法\r\n            public int compare(Integer o1, Integer o2) {\r\n                //return o1-o2;//默认的排序方式 升序排序\r\n                return -(o1-o2);//自定义的 降序排序\r\n            }\r\n        });\r\n        System.out.println(Arrays.toString(arr1));\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-12-49-33.png)\r\n\r\n\r\n**对学生数组根据年龄排序**\r\n\r\n使用Arrays.sort()通过实现Comparator接口类并重写compare()函数实现根据学生年龄排序学生对象数组的测试\r\n```java\r\nimport java.util.Arrays;\r\nimport java.util.Comparator;\r\nimport java.util.Random;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Random rd = new Random();\r\n        Student[] students = new Student[5];\r\n        for (int i = 0; i < students.length; i++) {\r\n            students[i] = new Student(\"随便写的名字\", rd.nextInt(1,50));\r\n        }\r\n        System.out.println(Arrays.toString(students));\r\n\r\n        Arrays.sort(students, new Comparator<Student>() {\r\n            @Override\r\n            public int compare(Student o1, Student o2) {\r\n                //return o1.getAge() - o2.getAge();//按年龄升序排序\r\n                //return -(o1.getAge() - o2.getAge());//按年龄降序排序\r\n                //return -Integer.compare(o1.getAge(),o2.getAge());//按年龄降序排序\r\n                return Integer.compare(o1.getAge(),o2.getAge());//按年龄升序排序\r\n            }\r\n        });\r\n        System.out.println(Arrays.toString(students));\r\n    }\r\n}\r\nclass Student{\r\n    private int age;\r\n    private String name;\r\n\r\n    public Student(String name, int age) {\r\n        this.name = name;\r\n        this.age = age;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Student{\" +\r\n                \"age=\" + age +\r\n                \", name='\" + name + '\\'' +\r\n                '}';\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-13-06-55.png)\r\n\r\n\r\n\r\n### binarySearch二分查找\r\n\r\n**Arrays.binarySearch()测试**\r\n```java\r\nimport java.util.Arrays;\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        int[] arr1 = {100,99,88,77,66,55,44,33,33,11,0};\r\n        int index;\r\n        Arrays.sort(arr1);\r\n        System.out.println(Arrays.toString(arr1));\r\n\r\n        index = Arrays.binarySearch(arr1,99);\r\n        System.out.println(index);\r\n\r\n        index = Arrays.binarySearch(arr1,55);\r\n        System.out.println(index);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-12-27-17.png)\r\n\r\n\r\n## Lambda表达式\r\n* Lambda表达式为jdk8开始的新语法特效\r\n* 作用：简化函数式接口匿名内部类的代码写法\r\n* 注意：\r\n  * 只能简化函数式接口的匿名内部类的写法\r\n  * 函数式接口：有且只有一个抽象方法的接口\r\n\r\nLambda表达式格式\r\n```java\r\n(匿名内部类要重写方法的形参列表)->{\r\n    被重写方法的方法体\r\n}\r\n\r\n单个形参 -> 单条语句同时作为函数返回值\r\n```\r\n\r\n**用法测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Animal cat = () -> {//Lambda表达式\r\n            System.out.println(\"喵喵喵\");\r\n        };\r\n        Animal dog = new Animal() {//完整写法\r\n            @Override\r\n            public void say() {\r\n                System.out.println(\"汪汪汪\");\r\n            }\r\n        };\r\n        cat.say();\r\n        dog.say();\r\n    }\r\n}\r\n@FunctionalInterface //函数式接口\r\ninterface Animal{\r\n    void say();\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-13-44-37.png)\r\n\r\n\r\n**简化测试**\r\n```java\r\nInteger[] arr1 = {0,1,2,3,4,5,6,7,8,9,10};\r\n\r\n//原始写法\r\nArrays.sort(arr1, new Comparator<Integer>() {\r\n    @Override\r\n    public int compare(Integer o1, Integer o2) {\r\n        return -(o1-o2);\r\n    }\r\n});\r\n\r\n//Lambda表达式写法\r\nArrays.sort((Integer o1, Integer o2)->{\r\n        return -(o1-o2);\r\n    }\r\n);\r\n\r\n//Lambda表达式的进一步简化写法\r\nArrays.sort(    (o1,o2)-> -(o1-o2)  );\r\n```\r\n\r\n\r\n## Collection集合\r\n\r\n### Collection集合概念\r\n\r\n**概念**\r\n* **集合是用于存储对象的容器**\r\n* **集合大小不固定，适合做元素的增删改查**\r\n* 集合只能存储引用数据类型的数据，不能存储基本数据类型，但可以存储基本数据类型的包装类\r\n\r\n**两种集合体系**\r\n* Collection单列集合，每个元素只包含一个值\r\n* Map双列集合，每个元素包含两个值（键值对）\r\n![](./images/java学习笔记/2022-10-27-14-36-24.png)\r\n\r\n\r\n\r\n**Collection集合体系**\r\n* `Collection` 是一个接口类\r\n* `List` `Set` 也是接口类, **继承** 自 `Collection` 接口\r\n* `ArrayList` 等类 是实现类\r\n* 集合的实现类**支持泛型**\r\n* 图中是一些**常见**的子接口和实现类\r\n![](./images/java学习笔记/2022-10-27-14-40-19.png)\r\n\r\n\r\n**Collection集合特点**\r\n\r\n**List集合特点：** \r\n* `ArrayList` 添加的元素**有序**、**可重复**、**有索引**\r\n* `LinkedList` 添加的元素**有序**、**可重复**、**有索引**\r\n\r\n**Set集合特点：** \r\n* `HashSet`添加的元素**无序**、**不重复**、**无索引**\r\n* `LinkedHashSet`添加的元素`有序`、**不重复**、**无索引**\r\n* `TreeSet`添加的元素`默认按大小升序排序`、**不重复**、**无索引**\r\n\r\n\r\n\r\n**ArrayList集合特点测试**\r\n* 有序\r\n* 可重复\r\n* 有索引\r\n```java\r\nimport java.util.ArrayList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n        System.out.println(al);//可重复\r\n        System.out.println(al.get(5));//有索引，有顺序\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-15-06-19.png)\r\n\r\n\r\n\r\n**HashSet集合特点测试**\r\n* 无序\r\n* 不可重复\r\n* 无索引\r\n```java\r\nimport java.util.HashSet;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        HashSet al = new HashSet<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n        System.out.println(al);//不可重复，无序\r\n        //System.out.println(al.get(5));//无索引，无法调用\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-15-10-41.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n### Collection集合常用API\r\n\r\nCollection接口类是单列集合的祖宗类，其中定义的抽象函数，其子接口和子类都会对这些抽象函数重写\r\n\r\n于是，学习Collection接口类中提供的抽象函数，就是在学习其子类们所共有的成员方法。\r\n\r\n\r\n**Collection常用API**\r\n| 方法名称                              | 说明                             |\r\n| ------------------------------------- | -------------------------------- |\r\n| `public boolean add(E e)`             | 把给定的对象添加到当前集合中     |\r\n| `public void clear()`                 | 清空集合中所有的元素             |\r\n| `public boolean remove(E e)`          | 把给定的对象在当前集合中删除     |\r\n| `public boolean contains(Object obj)` | 判断当前集合中是否包含给定的对象 |\r\n| `public boolean isEmpty()`            | 判断当前集合是否为空             |\r\n| `public int size()`                   | 返回集合中元素的个数。           |\r\n| `public Object[] toArray()`           | 把集合中的元素，存储到数组中     |\r\n\r\n\r\n\r\n\r\n### Collection集合遍历\r\n**三种常用遍历集合的方式**\r\n* 迭代器\r\n* 利用加强版`for(ElementType item:obj){}`语法特性\r\n* 结合`集合的forEach方法`和`lambda表达式`\r\n\r\n**原理**\r\n* 三种方式的**本质原理**都是`Collection的子类`**实现了**`Iterable接口`\r\n* 三种方式的依赖关系为 **对Iterable接口的实现** <- **获取Iterator迭代器** <- **使用加强版for(ElementType item:obj){}** <- **使用集合的forEach()方法**\r\n\r\n#### 迭代器\r\n* **迭代器是集合专用遍历方式**\r\n* 迭代器是指`Iterator`对象\r\n* `Iterable`本身是一个接口类，该接口类中定义了`iterator()`方法,该方法返回一个`Iterator`迭代器对象\r\n* `Collection`也是一个接口类，实现该接口类的类实现了这个`Iterable`接口类\r\n* 通过`Collection的实例对象`的`iterator()`方法可以得到一个`Iterator`迭代器实例\r\n\r\n**Collection实例对象创建Iterator的函数**\r\n| 函数名              | 描述                                   |\r\n| ------------------- | -------------------------------------- |\r\n| Iterator iterator() | 返回一个调用者（集合对象）的迭代器对象 |\r\n\r\n**Iterator的方法**\r\n| 函数名                                       | 描述                                                                                                                           |\r\n| -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |\r\n| forEachRemaining(Consumer<? super E> action) | Performs the given action for each remaining element until all elements have been processed or the action throws an exception. |\r\n| boolean hasNext()                            | Returns true if the iteration has more elements.                                                                               |\r\n| E next()                                     | Returns the next element in the iteration.                                                                                     |\r\n\r\n**迭代器使用测试**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList<String> al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n\r\n        Iterator<String> iterator = al.iterator(); //创建`Iterator`对象\r\n        while (iterator.hasNext()){//判断是否遍历完成`.hasNext()` \r\n            System.out.println(iterator.next());//获取元素`.next()`\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-16-34-03.png)\r\n\r\n#### 加强版for循环\r\n\r\n**加强版for循环**\r\n* 实现了`iterable`接口的类才能使用`加强版for循环`，而Collection是继承自`iterable`的\r\n* `加强版for循环`**可以遍历集合**，**也能遍历数组**\r\n* 内部原理依然是迭代器对象\r\n  * **猜测应该是**for循环隐式调用了这一系列方法：\r\n    * 1.创建`Iterator`对象`obj.iterator()` \r\n    * 2.判断是否遍历完成`.hasNext()` \r\n    * 3.获取元素`.next()`\r\n* 该语法特性出现于jdk5\r\n\r\n**for新特性语法格式**\r\n```java\r\nfor(ElementType item:obj){\r\n    System.out.println(item);\r\n}\r\n```\r\n\r\n**`加强版for循环`语法特性测试**\r\n```java\r\nimport java.util.ArrayList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList<String> al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n\r\n        for (String item : al) {\r\n            System.out.println(item);\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-16-48-05.png)\r\n\r\n\r\n#### 结合forEach方法和lambda表达式\r\n**关于forEach方法**\r\n* `Iterable接口类`中定义了`forEach方法`,\r\n* 而`Collection接口类`继承自`Iterable接口类`,\r\n* 所以实现了`Collection接口类`的类中也实现了`forEach方法`\r\n* 该方法接收一个**实现函数式接口类**的`匿名对象`\r\n* forEach方法的本质是利用了for的新语法特性\r\n\r\n**测试Collection集合的forEach方法**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.function.Consumer;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Collection<String> al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n\r\n        al.forEach(new Consumer<String>() {\r\n            @Override\r\n            public void accept(String s) {\r\n                System.out.println(s);\r\n            }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n**测试结合Collection集合的forEach方法和lambda表达式**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Collection<String> al = new ArrayList<String>();\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"字符串\");\r\n        al.add(\"1111\");\r\n        al.add(\"2222\");\r\n        al.add(\"3333\");\r\n        al.add(\"1111\");\r\n\r\n        al.forEach( s -> {\r\n                System.out.println(s);\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n\r\n**几种遍历集合方式的总结**\r\n```java\r\n        List<String> list = new LinkedList<>();\r\n        list.add(\"Java\");\r\n        list.add(\"JavaScript\");\r\n        list.add(\"css\");\r\n        list.add(\"html\");\r\n        list.add(\"jquery\");\r\n//1.使用迭代器遍历集合\r\n    //1.1使用迭代器+while循环遍历集合\r\n        //遍历一个集合的最原始做法就是通过集合类实现的Iterator对象来遍历\r\n        Iterator<String> iterator = list.iterator();\r\n        while (iterator.hasNext()){\r\n            String item = iterator.next();\r\n            System.out.println(item);\r\n        }\r\n    //1.2使用迭代器+for循环遍历集合，和原理上述while循环等效\r\n        for (Iterator<String> iterator2 = list.iterator(); iterator2.hasNext();  ) {\r\n            String item = iterator2.next();\r\n            System.out.println(item);\r\n        }\r\n//2.使用增强for遍历集合\r\n        //使用这种方式要求被遍历的集合必须是可迭代的\r\n        //其实实际就是上述 for循环+迭代器 的简化版\r\n        for (String item : list) {\r\n            System.out.println(item);\r\n        }\r\n//3.使用 forEach 遍历集合\r\n        //根据源代码，forEach的本质实际上是使用了 增强版的for的语法\r\n        //所以 使用forEach遍历集合 = 使用增强for遍历集合\r\n        list.forEach(item->{\r\n            System.out.println(item);\r\n        });\r\n//4.使用 for + index下标 + get() 遍历集合，\r\n        // 效率低，且只能遍历有序集合\r\n        for (int index=0 ;index<list.size();index++){\r\n            String item = list.get(index);\r\n            System.out.println(item);\r\n        }\r\n```\r\n\r\n### List系列的集合\r\n\r\n![](./images/java学习笔记/2022-10-28-19-46-48.png)\r\n\r\n**List系列特点：** \r\n* **有序**: 存和取元素的顺序一致\r\n* **可重复**: 存储的元素可以重复\r\n* **有索引**: 可以通过索引操作元素\r\n\r\n**List系列的集合共有方法**\r\n| 方法名称                      | 说明                                   |\r\n| ----------------------------- | -------------------------------------- |\r\n| void add(int index,E element) | 在此集合中的指定位置插入指定的元素     |\r\n| E remove(int index)           | 删除指定索引处的元素，返回被删除的元素 |\r\n| E set(int index,E element)    | 修改指定索引处的元素，返回被修改的元素 |\r\n| E get(int index)              | 返回指定索引处的元素                   |\r\n\r\n**List类共有方法测试**\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<String> list = new ArrayList<>();\r\n        list.add(\"Java\");\r\n        list.add(\"JavaScript\");\r\n        list.add(\"css\");\r\n        list.add(\"html\");\r\n        list.add(\"jquery\");//add\r\n        System.out.println(list);\r\n        System.out.println(list.get(3));//get\r\n        list.set(4,\"jQuery\");//set\r\n        System.out.println(list);\r\n        list.remove(1);//romove\r\n        System.out.println(list);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-27-23-09-02.png)\r\n\r\n\r\n#### ArrayList\r\n\r\n**ArrayList特点**\r\n* 底层基于数组实现\r\n* 根据索引定位元素快、增删慢\r\n* 初始容量为10，之后按1.5倍扩容\r\n\r\n\r\n\r\n#### LinkedList\r\n\r\n**LinkedList特点**\r\n* 底层基于双链表实现\r\n* 查询慢，首尾操作速度快，增删块\r\n* 能当做栈和队列来用\r\n* 有一些特有的首尾操作API\r\n  * addFirst addLast  push offerFirst\r\n  * romoveFirst removeLast pop offerLast\r\n  * getFirst getLast \r\n\r\n**LinkedList特有的首尾操作API测试**\r\n```java\r\nimport java.util.LinkedList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        //栈\r\n        LinkedList<String> stack = new LinkedList<>();\r\n        stack.push(\"111\");\r\n        stack.push(\"222\");\r\n        stack.push(\"333\");\r\n        System.out.println(stack);\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack);\r\n\r\n        //队列\r\n        LinkedList<String> queue = new LinkedList<>();\r\n        queue.add(\"111\");\r\n        queue.add(\"222\");\r\n        queue.add(\"333\");\r\n        System.out.println(queue);\r\n        System.out.println(queue.poll());\r\n        System.out.println(queue.poll());\r\n        System.out.println(queue.poll());\r\n        System.out.println(queue);\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-10-28-09-08-31.png)\r\n\r\n\r\n#### 迭代时删除元素的问题\r\n不能在迭代的过程中直接删除元素，需要利用迭代器的romove方法\r\n\r\n```java\r\nimport java.util.Iterator;\r\nimport java.util.LinkedList;\r\nimport java.util.List;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<String> list = new LinkedList<>();\r\n        list.add(\"111\");\r\n        list.add(\"222\");\r\n        list.add(\"222\");\r\n        list.add(\"333\");\r\n        System.out.println(list);\r\n\r\n        Iterator<String> iterator = list.iterator();\r\n        while (iterator.hasNext()){\r\n            String item = iterator.next();\r\n            System.out.println(item);\r\n            if (item.equals(\"222\")){\r\n                //list.remove(item);//错误写法，会使得数组中元素前移，导致迭代器获取下一个元素时错过一个元素\r\n                iterator.remove();//正确写法，移除当前元素\r\n            }\r\n        }\r\n        System.out.println(list);\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-10-28-09-28-14.png)\r\n\r\n\r\n### Set系列集合\r\n\r\n![](./images/java学习笔记/2022-10-28-19-45-29.png)\r\n\r\n\r\n**Set集合特点：** \r\n* 无序：存取顺序不一致\r\n* 不重复：可以去除重复\r\n* 无索引：<green>不能通过索引访问,没有`get(index)`方法</green>，只能通过迭代器遍历\r\n\r\n\r\n**三种集合实现类特点**\r\n| 实现类类名    | 存储顺序                                           | 重复   | 索引   |\r\n| ------------- | -------------------------------------------------- | ------ | ------ |\r\n| HashSet       | 无序：和输入顺序无关                               | 不重复 | 无索引 |\r\n| LinkedHashSet | **有序：和输入顺序有关**                           | 不重复 | 无索引 |\r\n| TreeSet       | **有序：默认按内容升序排序** <green>可排序</green> | 不重复 | 无索引 |\r\n\r\n\r\n#### HashSet\r\n\r\n**底层原理**\r\n* jdk8之前，**数组**+**链表**(没有最大长度限制)\r\n    ![](./images/java学习笔记/2022-10-28-20-37-00.png)\r\n* jdk8开始，**数组**+**链表**(允许最大长度为8)/**红黑树**(根据hash按大小排序)\r\n    ![](./images/java学习笔记/2022-10-28-20-37-41.png)\r\n* 数组初始长度为16，名为table，即hash表,\r\n* 元素的在hash表中的存储位置根据hashCode函数计算，\r\n* hash冲突时按链式存储，存储过程会调用equals()判断是否重复\r\n* 数组的加载因子为0.75，即当数组存满到16*0.75=12时，自动扩容，扩容两倍\r\n\r\n\r\n**哈希值**\r\n* JDK根据对象的**地址**，按某种规则生成的整型数值\r\n* Object类的API：`public int hashCode();`返回对象的hash值，多次调用，值一致\r\n\r\n**<warn>注意</warn>**  \r\n若希望Set集合认为2个内容一样的自定义对象是重复的，则\r\n* <warn>必须重写`hashCode()`</warn>\r\n* <warn>必须重写`equals()`</warn>\r\n\r\n**HashSet特点测试**\r\n```java\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new HashSet(); //无序：和输入顺序无关\r\n        set.add(\"java\");\r\n        set.add(\"java\");\r\n        set.add(\"HTML\");\r\n        set.add(\"js\");\r\n        set.add(\"css\");\r\n        set.add(\"css\");\r\n        System.out.println(set);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-20-13-02.png)\r\n\r\n\r\n**测试将自定义类（`不重写`hashCode、equals）存入hashset，**\r\n* **无法**实现对内容相同的元素去重\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new HashSet();\r\n        Student student1 = new Student(123,\"DYG\",21,'男');\r\n        Student student2 = new Student(123,\"DYG\",21,'男');\r\n        Student student3 = new Student(123,\"DYG\",21,'男');\r\n        Student student4 = new Student(124,\"DYG\",21,'男');\r\n\r\n        set.add(student1);\r\n        set.add(student2);\r\n        set.add(student3);\r\n        set.add(student4);\r\n\r\n        System.out.println(set);\r\n    }\r\n}\r\nclass Student{\r\n    int id;\r\n    String name;\r\n    int age;\r\n    char sex;\r\n\r\n    public Student(int id, String name, int age, char sex) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nStudent{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                \", sex=\" + sex +\r\n                '}';\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-21-32-58.png)\r\n\r\n\r\n**测试将自定义类（`重写`hashCode、equals）存入hashset，**\r\n* **能够**实现对内容相同的元素去重\r\n\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new HashSet();\r\n        Student student1 = new Student(123,\"DYG\",21,'男');\r\n        Student student2 = new Student(123,\"DYG\",21,'男');\r\n        Student student3 = new Student(123,\"DYG\",21,'男');\r\n        Student student4 = new Student(124,\"DYG\",21,'男');\r\n\r\n        set.add(student1);\r\n        set.add(student2);\r\n        set.add(student3);\r\n        set.add(student4);\r\n\r\n        System.out.println(set);\r\n    }\r\n}\r\nclass Student{\r\n    int id;\r\n    String name;\r\n    int age;\r\n    char sex;\r\n\r\n    public Student(int id, String name, int age, char sex) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nStudent{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                \", sex=\" + sex +\r\n                '}';\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        Student student = (Student) o;\r\n        return id == student.id && age == student.age && sex == student.sex && Objects.equals(name, student.name);\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(id, name, age, sex);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-21-34-26.png)\r\n\r\n\r\n\r\n#### LinkedHashSet\r\n\r\n**底层原理**\r\n* hash表+链表+双链表\r\n* 使用双链表记录添加和删除的顺序\r\n    ![](./images/java学习笔记/2022-10-28-21-42-18.png)\r\n\r\n\r\n**LinkedHashSet特点测试**\r\n\r\n\r\n\r\n```java\r\nimport java.util.LinkedHashSet;\r\nimport java.util.Set;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new LinkedHashSet(); //有序：和输入顺序有关\r\n        set.add(\"java\");\r\n        set.add(\"java\");\r\n        set.add(\"HTML\");\r\n        set.add(\"js\");\r\n        set.add(\"css\");\r\n        set.add(\"css\");\r\n        System.out.println(set);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-20-14-03.png)\r\n\r\n\r\n#### TreeSet\r\n\r\n**底层原理**\r\n* 红黑树\r\n* 增删改查性能好\r\n\r\n**注意**\r\n* 红黑树默认支持排序\r\n* 对于Integer Double,字符串，默认按升序排序\r\n* <warn>对于自定义数据类型，默认无法排序，必须提供自定义排序规则</warn>\r\n* 默认按升序排序，也可按指定规则排序\r\n\r\n**自定义比较规则**\r\n* 方法一：使 **自定义类** 实现Comparable接口\r\n  ```java\r\n    class Student implements Comparable<Student>{\r\n        int id;\r\n        String name;\r\n        int age;\r\n        char sex;\r\n        @Override\r\n        public int compareTo(Student o) {//重写Comparable的compareTo方法\r\n            //return this.id - o.id;\r\n            return Integer.compare(this.id,o.id);//对于集合来说，此处返回0则表示重复，于是便会丢弃该元素\r\n        }\r\n    }\r\n    ```\r\n* 方法二：通过传入**TreeSet()构造器**一个**比较器对象**实现\r\n    ```java\r\n    Set set  = new TreeSet<Student>(new Comparator<Student>() {\r\n        @Override\r\n        public int compare(Student o1, Student o2) {\r\n            return Integer.compare(o1.id,o2.id);\r\n        }\r\n    });\r\n\r\n    Set set  = new TreeSet<Student>((o1,o2)->Integer.compare(o1.id, o2.id));\r\n\r\n    Set set  = new TreeSet<Student>(Comparator.comparingInt(o -> o.id));\r\n    ```\r\n* <warn>注意</warn>：方法一和方法二同时被实现时，程序优先使用**TreeSet()构造器**得到的**比较器对象**\r\n\r\n\r\n**TreeSet特点测试**\r\n```java\r\nimport java.util.Set;\r\nimport java.util.TreeSet;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new TreeSet(); //有序：默认按内容升序排序\r\n        set.add(\"java\");\r\n        set.add(\"java\");\r\n        set.add(\"HTML\");\r\n        set.add(\"js\");\r\n        set.add(\"css\");\r\n        set.add(\"css\");\r\n        System.out.println(set);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-20-15-21.png)\r\n\r\n\r\n**自定义比较规则方法一测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new TreeSet();\r\n        Student student1 = new Student(123,\"DYG\",21,'男');\r\n        Student student2 = new Student(123,\"DYG\",21,'男');\r\n        Student student3 = new Student(123,\"DYG\",21,'男');\r\n        Student student4 = new Student(124,\"DYG\",21,'男');\r\n\r\n        set.add(student1);\r\n        set.add(student2);\r\n        set.add(student3);\r\n        set.add(student4);\r\n\r\n        System.out.println(set);\r\n    }\r\n}\r\nclass Student implements Comparable<Student>{\r\n    int id;\r\n    String name;\r\n    int age;\r\n    char sex;\r\n\r\n    public Student(int id, String name, int age, char sex) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nStudent{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                \", sex=\" + sex +\r\n                '}';\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Student o) {\r\n        //return this.id - o.id;\r\n        return Integer.compare(this.id,o.id);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-22-44-10.png)\r\n\r\n**自定义比较规则方法二测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set set  = new TreeSet<Student>((o1,o2)->Integer.compare(o1.id, o2.id));\r\n        Student student1 = new Student(123,\"DYG\",21,'男');\r\n        Student student2 = new Student(123,\"DYG\",21,'男');\r\n        Student student3 = new Student(123,\"DYG\",21,'男');\r\n        Student student4 = new Student(124,\"DYG\",21,'男');\r\n\r\n        set.add(student1);\r\n        set.add(student2);\r\n        set.add(student3);\r\n        set.add(student4);\r\n\r\n        System.out.println(set);\r\n    }\r\n}\r\nclass Student{\r\n    int id;\r\n    String name;\r\n    int age;\r\n    char sex;\r\n\r\n    public Student(int id, String name, int age, char sex) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"\\nStudent{\" +\r\n                \"id=\" + id +\r\n                \", name='\" + name + '\\'' +\r\n                \", age=\" + age +\r\n                \", sex=\" + sex +\r\n                '}';\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-22-58-04.png)\r\n\r\n\r\n## 可变参数\r\n\r\n**概念**\r\n* 用于接收任意`[0-n]`个函数参数\r\n* 在函数内部，可变参数本质为一个数组\r\n\r\n**注意事项**\r\n* 一个函数的形参列表只能有一个可变参数\r\n* 可变参数必须是函数形参列表的最后一个参数\r\n\r\n**语法格式**  \r\n```java\r\n修饰符 返回值 函数名(其他形参的数据类型 其他形参的形参名,可变参数的数据类型...可变参数的参数名称){\r\n\r\n}\r\npublic static void funName(int other,String...strings){\r\n\r\n}\r\n```\r\n\r\n**测试**\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        println();//不传递参数\r\n        println(\"123\");//传入一个\r\n        println(\"123\",\"1234\");//传入两个\r\n        println(new String[]{\"123\",\"456\",\"789\"});//传入一个字符串数组，携带三个元素\r\n    }\r\n    public static void println(String...strings){//strings本质为一个数组\r\n        for (String item:strings) {\r\n            System.out.print(item);\r\n        }\r\n        System.out.print('\\n');\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-23-22-12.png)\r\n\r\n\r\n## 集合的工具类：Collections类\r\n**概念**\r\n* 所在位置：java.utils.Collections\r\n* `Collections类`不属于`Collection类`，\r\n* `Collections类`是用来操作`Collection类`的**工具类**\r\n\r\n**常用API**\r\n| 函数名                                                                     | 解释                                                       |\r\n| -------------------------------------------------------------------------- | ---------------------------------------------------------- |\r\n| `public static <T> boolean addAll(Collection<? super T> c，T... elements)` | 给Collection集合对象批量添加元素                           |\r\n| `public static void shuffle(List<?> list)`                                 | 打乱List集合顺序。                                         |\r\n| `public static<T> void sort(List<T> list)`                                 | 将List集合中元素(实现了Comparable接口的)按照默认规则排序。 |\r\n| `public static<T> void sort(List<T> list，Comparator<? super T> c)`        | 将List集合中元素按照指定规则排序。                         |\r\n\r\n**常用API测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<String> names = new LinkedList<>();\r\n        Collections.addAll(names,\"DYG1\",\"DYG22\",\"DYG333\",\"LRH\",\"CYX\");\r\n        System.out.println(\"批量添加元素后：\"+names);\r\n\r\n        Collections.shuffle(names);\r\n        System.out.println(\"随机打乱后：\"+names);\r\n\r\n        Collections.sort(names);\r\n        System.out.println(\"按默认规则排序后：\"+names);\r\n\r\n        Collections.sort(names, ((o1, o2) -> o1.length()-o2.length()));\r\n        System.out.println(\"按自定规则(长度)排序后：\"+names);\r\n    }\r\n}\r\n```\r\n\r\n## 扑克牌洗牌分牌\r\n```java\r\npackage com.yiguiding.package1;\r\n\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ASetOfCards aSetOfCards = new ASetOfCards();\r\n        aSetOfCards.wash();//洗牌\r\n        List Cars = aSetOfCards.getCars();\r\n        Cars.forEach(item->{\r\n            System.out.println(item);\r\n        });\r\n    }\r\n}\r\n\r\nenum CARD_TYPE{//扑克牌花色：Spade黑桃♠、Heart红心♥、Diamond方块♦、Club梅花♣,JOKER_minor小王,JOKER_major大王\r\n    Spade(\"♠\",0),Heart(\"♥\",1),Diamond(\"♦\",2),Club(\"♣\",3),JOKER_minor(\"小王\\uD83C\\uDCCF\",4),JOKER_major(\"大王\\uD83C\\uDCCF\",5);\r\n    String name;\r\n    int value;\r\n    private CARD_TYPE(String name,int value){\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n\r\n    public int getValue() {\r\n        return this.value;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return  this.name;\r\n    }\r\n}\r\nenum CARD_NUM {//花色\r\n    A(\"A\",12),Two(\"2\",13),Three(\"3\",1),Four(\"4\",2),Five(\"5\",3),Six(\"6\",4),Seven(\"7\",5),Eight(\"8\",6),Nine(\"9\",7),Ten(\"10\",8),J(\"J\",9),Q(\"Q\",10),K(\"K\",11);\r\n    String name;\r\n    int value;\r\n    CARD_NUM(String name,int value){\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n    public int getValue(){\r\n        return this.value;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return  this.name;\r\n    }\r\n}\r\nclass Card implements Comparable<Card>{//一张牌\r\n    CARD_TYPE type;\r\n    CARD_NUM num;\r\n    public Card(CARD_TYPE type, CARD_NUM num) {\r\n        this.type = type;\r\n        this.num = num;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        if (num!=null){\r\n            return num.toString() + type.toString();\r\n        }else{\r\n            return type.toString();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Card o) {\r\n        if (this.type!=CARD_TYPE.JOKER_minor && this.type!=CARD_TYPE.JOKER_major &&\r\n                o.type!=CARD_TYPE.JOKER_minor && o.type!=CARD_TYPE.JOKER_major\r\n        ){//不是大小王则根据牌面值排序\r\n            return -Integer.compare(this.num.getValue(),o.num.getValue());\r\n        }else{//是大小王则根据牌类型排序\r\n            return -Integer.compare(this.type.getValue(),o.type.getValue());\r\n        }\r\n    }\r\n}\r\nclass ASetOfCards{//一副牌\r\n    List cards;//存放所有牌\r\n    ASetOfCards(){\r\n        cards = new LinkedList();\r\n        for(CARD_TYPE type:CARD_TYPE.values()){\r\n            if (type!=CARD_TYPE.JOKER_minor && type!=CARD_TYPE.JOKER_major){\r\n                for (CARD_NUM num:CARD_NUM.values()){\r\n                    cards.add(new Card(type,num));\r\n                }\r\n            }else{\r\n                cards.add(new Card(type,null));\r\n            }\r\n        }\r\n    }\r\n    void wash(){//洗牌\r\n        Collections.shuffle(cards);\r\n    }\r\n    public List getCars(){\r\n\r\n        List result = new LinkedList();\r\n\r\n        List player1 = cards.subList(0,17);\r\n        List player2 = cards.subList(17,34);\r\n        List player3 = cards.subList(34,51);\r\n        List player4 = cards.subList(51,54);//地主的三张牌\r\n\r\n        Collections.sort(player1);//排序\r\n        Collections.sort(player2);//排序\r\n        Collections.sort(player3);//排序\r\n\r\n        Collections.addAll(result,player1,player2,player3,player4);\r\n\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return cards.toString();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-03-51-44.png)\r\n\r\n## 泛型\r\n**泛型概述**\r\n* 泛型:是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。\r\n* 泛型的格式:<数据类型>;注意:泛型只能支持引用数据类型。\r\n* 集合体系的全部接口和实现类都是支持泛型的使用的。\r\n\r\n### 自定义泛型类\r\n**泛型类语法格式**\r\n```java\r\nclass 类名<范式类型T>{\r\n\r\n}\r\n```\r\n\r\n**使用泛型自定义的线性栈的案例**\r\n* 能自动扩容\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        myArrayStack<Object> stack = new myArrayStack<Object>();\r\n        stack.push(1);\r\n        stack.push(2);\r\n        stack.push(3);\r\n        stack.push(4);\r\n        stack.push(5);\r\n        stack.push(6);\r\n        stack.push(7);\r\n        stack.push(8);\r\n        stack.push(9);\r\n        stack.push(10);\r\n        stack.push(11);\r\n        stack.push(12);\r\n        stack.push(13);\r\n        System.out.println(stack);\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack.pop());\r\n        System.out.println(stack);\r\n    }\r\n}\r\nclass myArrayStack<T>{\r\n    int capacity;\r\n    int position;\r\n    int length;\r\n    T[] stack;\r\n    myArrayStack(){\r\n        capacity=10;\r\n        position=0;\r\n        length = 0;\r\n        stack = (T[]) new Object[capacity];\r\n    }\r\n    void getNewStack(){\r\n        capacity = (int)(capacity*1.5);//1.5倍扩容\r\n        T[] newStack =  (T[]) new Object[capacity];//1.5倍扩容\r\n        for (int i = 0; i < length; i++) {//拷贝\r\n            newStack[i] = stack[i];\r\n        }\r\n        stack = newStack;\r\n    }\r\n    void push(T E){\r\n        if (length!=capacity) {//判断栈满\r\n            length++;\r\n            stack[position++] = E;\r\n        }else{\r\n            getNewStack();//1.5倍扩容,并赋值\r\n            push(E);//重新压入栈\r\n        }\r\n    }\r\n    T pop(){\r\n        if (length!=0){//栈中没有元素了\r\n            length--;\r\n            return stack[--position];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        String result=\"\";\r\n        result+='[';\r\n        for (int i = 0; i < length; i++) {\r\n            result+= i==length-1? stack[i]:(stack[i]+\",\");\r\n        }\r\n        result+=']';\r\n        return result;\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-28-10-24-16.png)\r\n\r\n\r\n### 自定义泛型方法\r\n\r\n**泛型方法语法格式**\r\n```java\r\n函数修饰符 <范式类型> 返回类型 函数名(形式参数列表){\r\n\r\n}\r\n```\r\n\r\n**自定义泛型测试**\r\n```java\r\nimport java.util.ArrayList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList names = new ArrayList<>();\r\n        names.add(\"000\");\r\n        names.add(\"111\");\r\n        names.add(\"222\");\r\n        names.add(\"333\");\r\n        names.add(\"444\");\r\n        names.add(\"555\");\r\n\r\n        System.out.println(toString(names.toArray()));\r\n    }\r\n     public static  <T> String toString(T[] res){\r\n         String result=\"\";\r\n         result+='[';\r\n         for (int i = 0; i < res.length; i++) {\r\n             result+= i==res.length-1? res[i].toString():(res[i]+\",\");\r\n         }\r\n         result+=']';\r\n         return result;\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-10-28-12-40-00.png)\r\n\r\n### 自定义泛型接口\r\n\r\n泛型接口可以让实现类选择当前功能需要操作的数据类型\r\n\r\n**泛型接口语法格式**\r\n```java\r\n修饰符 interface 接口名 <范式类型>{\r\n\r\n}\r\n```\r\n\r\n**使用案例测试**\r\n```java\r\ninterface Data<T>{\r\n    void insert(T E);\r\n    void remove(T E);\r\n    void querry(T E);\r\n    void updata(T E);\r\n}\r\n\r\nclass List implements Data<String>{\r\n\r\n    @Override\r\n    public void insert(String E) {\r\n        \r\n    }\r\n\r\n    @Override\r\n    public void remove(String E) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void querry(String E) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void updata(String E) {\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 泛型通配符\r\n**概念**\r\n* ?表示任意泛型\r\n* ?extends Car表示泛型的上限（祖宗类）\r\n* ?super Car表示泛型的下限（子类）\r\n\r\n**应用测试**\r\n\r\n案例中，`carGo`的形式参数应当能够允许接收`ArrayList<BWM>`类和`ArrayList<Benz>`类，但是`carGo`的形式参数不能填`ArrayList<Car>`类，因为这三种类型没有任何关系，即`ArrayList<Car>`类，不是`ArrayList<BWM>`类和`ArrayList<Benz>`类的子类。\r\n\r\n`carGo`的形式参数也不能填`ArrayList<?>`类,因为这意味着,`ArrayList<Dog>`也能被传入`carGo`，这意味着 动物类 也能够参与 汽车类 的处理函数，所以还应当指定**泛型通配符的上限**，即形参应当写`ArrayList<? extends Car>`\r\n\r\n```java\r\nimport java.util.ArrayList;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        ArrayList<BWM> bwms = new ArrayList<>();\r\n        bwms.add(new BWM());\r\n        bwms.add(new BWM());\r\n        bwms.add(new BWM());\r\n        carGo(bwms);\r\n\r\n        ArrayList<Benz> benzs = new ArrayList<>();\r\n        benzs.add(new Benz());\r\n        benzs.add(new Benz());\r\n        benzs.add(new Benz());\r\n        carGo(benzs);\r\n    }\r\n    public static void carGo(ArrayList<? extends Car> cars){\r\n        cars.forEach(e->{\r\n            e.go();\r\n        });\r\n    }\r\n}\r\nabstract class Car{\r\n    abstract void go();\r\n}\r\nclass BWM extends Car{\r\n    @Override\r\n    void go(){\r\n        System.out.println(\"BWM go......\");\r\n    }\r\n}\r\nclass Benz extends Car{\r\n    @Override\r\n    void go(){\r\n        System.out.println(\"Benz go......\");\r\n    }\r\n}\r\nabstract class Animal{\r\n    abstract void go();\r\n}\r\nclass Dog extends Animal {\r\n    @Override\r\n    void go(){\r\n        System.out.println(\"Dog go.......\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n## Map集合\r\n\r\n### 概念\r\n* Map集合是<green>键值对集合</green>\r\n* Map集合独立于Collection集合\r\n* 两种集合区别\r\n  * `Map{key1:value1,key2:value2,key3:value3}`\r\n  * `Collection{value1,value2,value3}`\r\n\r\n**使用场景**\r\n```java\r\n// 购物车内的商品信息\r\nMap{商品id1:商品数量,商品id2:商品数量,商品id3:商品数量}\r\n```\r\n\r\n\r\n\r\n\r\n**Map集合体系**\r\n* ![](./images/java学习笔记/2022-10-29-11-28-37.png)\r\n* 重点为\r\n  * HashMap\r\n  * LinkedHashMap\r\n  * TreeMap\r\n\r\n### API\r\n**Map集合的共有API**\r\n| 方法名称                            | 说明                                 |\r\n| ----------------------------------- | ------------------------------------ |\r\n| v put(K key,v value)                | 添加元素                             |\r\n| v putAll(K key,v value)             | 添加另一个集合中的所有元素           |\r\n| v get(K key)                        | 获取元素，返回元素value或null        |\r\n| V remove(object key)                | 根据键删除键值对元素                 |\r\n| int size()                          | 集合的长度，也就是集合中键值对的个数 |\r\n| void clear()                        | 移除所有的键值对元素                 |\r\n| boolean isEmpty()                   | 判断集合是否为空                     |\r\n| boolean containsKey(object key)     | 判断集合是否包含指定的键             |\r\n| boolean containsValue(0bject value) | 判断集合是否包含指定的值             |\r\n| `public Set<K> keySet()`            | 获取键的集合（不重复）               |\r\n| `public Collection<V> values()`     | 获取值的集合（重复）                 |\r\n\r\n### 特点\r\n\r\n**Map集合特点**：\r\n* 由键决定\r\n* 键是无序，不重复，无索引，值不作要求\r\n* 键值可为null\r\n\r\n**实现类特点**\r\n| 类名          | 存储顺序           | 重复   | 索引   | 值         | 底层原理                                                                                                               | 特有方法 |\r\n| ------------- | ------------------ | ------ | ------ | ---------- | ---------------------------------------------------------------------------------------------------------------------- | -------- |\r\n| HashMap       | 无序               | 不重复 | 无索引 | 值不做要求 | hash表+链表，（HashSet的底层原理就是这里的HashMap）,依赖**键对象**重写的hashCode()和equals()来判断是否唯一             | 无       |\r\n| LinkedHashMap | **和存入顺序有关** | 不重复 | 无索引 | 值不做要求 | hash表+链表+双链表（LinkedHashSet的底层原理就是这里的LinkedHashMap）![](./images/java学习笔记/2022-10-29-13-34-54.png) |          |\r\n| TreeMap       | **自排序**         | 不重复 | 无索引 | 值不做要求 | 红黑树  需要`继承comparable`并重写的**compareTo**方法 **或** 需在排序时传入一个`Comparator`比较器对象                  |          |\r\n\r\n\r\n\r\n\r\n### 遍历\r\n\r\n**Map集合的遍历**\r\n* **方法1**:通过`keySet()`获取的**键的集合**,来找**值**\r\n* **方法2**:通过`entrySet()`将Map转Set，再用Set的**Iterator迭代器**遍历\r\n  * 原理是把`Map`中的**一组键值对**转换成一个包含键值的**Entry对象**`Entry{key,value}`,然后把这些对象放到Set集合中，然后通过**Iterator迭代器**遍历这个集合\r\n* **<green>方法3</green>**:直接使用jdk8提供的`forEach((key,value)->{})`方法\r\n  * 根据源码，原理实际上就是对`方法2`进行了封装\r\n\r\n**方法1测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,Integer> map = new HashMap<>();\r\n        map.put(\"java书\",1);\r\n        map.put(\"java书\",4);\r\n        map.put(\"c++\",3);\r\n        map.put(\"html\",2);\r\n        map.put(\"css\",1);\r\n        map.put(null,null);\r\n\r\n        for(String key:map.keySet()){\r\n            Integer value = map.get(key);\r\n            System.out.println(key + \"--->\" + value);\r\n        }\r\n\r\n        System.out.println(\"-------------------------------------\");\r\n\r\n        map.keySet().forEach(key->{\r\n            Integer value = map.get(key);\r\n            System.out.println(key + \"--->\" + value);\r\n        });\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-12-12-20.png)\r\n\r\n\r\n**方法2测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,Integer> map = new HashMap<>();\r\n        map.put(\"java书\",1);\r\n        map.put(\"java书\",4);\r\n        map.put(\"c++\",3);\r\n        map.put(\"html\",2);\r\n        map.put(\"css\",1);\r\n        map.put(null,null);\r\n\r\n// entrySet + Iterator + while\r\n        Set< Map.Entry<String,Integer> > entrys = map.entrySet();//map<key,value> =转换=> entrys<map元素对象{key,value}>\r\n        Iterator<Map.Entry<String,Integer>> iterator = entrys.iterator();//迭代器<map元素对象{key,value}>\r\n        while ( iterator.hasNext() ){\r\n            Map.Entry<String,Integer> item = iterator.next();//获取 map元素对象{key,value}\r\n            String key = item.getKey();\r\n            Integer value = item.getValue();\r\n            System.out.println(key + \"--->\" + value);\r\n        }\r\n\r\n        System.out.println(\"-------------------------------------\");\r\n\r\n//entrySet + 增强for\r\n        for(Map.Entry<String,Integer> item : map.entrySet()){//此处是对上述while循环的简化版\r\n            String key = item.getKey();\r\n            Integer value = item.getValue();\r\n            System.out.println(key + \"--->\" + value);\r\n        }\r\n\r\n        System.out.println(\"-------------------------------------\");\r\n\r\n//entrySet + forEach\r\n        map.entrySet().forEach(item->{//此处是对上述for循环的简化版\r\n            String key = item.getKey();\r\n            Integer value = item.getValue();\r\n            System.out.println(key + \"--->\" + value);\r\n        });\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-12-33-31.png)\r\n\r\n\r\n**方法3测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,Integer> map = new HashMap<>();\r\n        map.put(\"java书\",1);\r\n        map.put(\"java书\",4);\r\n        map.put(\"c++\",3);\r\n        map.put(\"html\",2);\r\n        map.put(\"css\",1);\r\n        map.put(null,null);\r\n\r\n        map.forEach((key,value)->{\r\n            System.out.println(key + \"--->\" + value);\r\n        });\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-12-49-46.png)\r\n\r\n\r\n### 案例\r\n**统计班级内80个人选择旅游景点ABCD的情况**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Random rd = new Random();\r\n        String[] select = {\"A\",\"B\",\"C\",\"D\"};\r\n        StringBuilder selectData = new StringBuilder();\r\n        for (int i = 0; i < 80; i++) {\r\n            selectData.append(select[rd.nextInt(select.length)]);\r\n        }\r\n        System.out.println(selectData);\r\n\r\n        Map<Character,Integer> map = new HashMap<>();\r\n        for (int i = 0; i < selectData.length(); i++) {\r\n            char key = selectData.charAt(i);\r\n            map.put(key,map.get(key)==null? 1: map.get(key)+1);\r\n        }\r\n        System.out.println(map);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-13-12-01.png)\r\n\r\n### 集合和Map的嵌套\r\n**统计班级内80个人选择旅游景点ABCD的情况**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,List<Character>> data = new HashMap<>();//数据格式：[{姓名1=['A','B','C']},{姓名2=['A','B','C']},{姓名3=['A','B','C']}]\r\n\r\n        List<Character> select1 = new ArrayList<>();//数据格式：['A','B','C']\r\n        Collections.addAll(select1,'A','B','C');\r\n        data.put(\"人名1\",select1);\r\n\r\n        List<Character> select2 = new ArrayList<>();//数据格式：['A','B','C']\r\n        Collections.addAll(select2,'A','B');\r\n        data.put(\"人名2\",select2);\r\n\r\n        List<Character> select3 = new ArrayList<>();//数据格式：['A','B','C']\r\n        Collections.addAll(select3,'A');\r\n        data.put(\"人名3\",select3);\r\n\r\n        System.out.println(\"投票结果:\"+data);\r\n\r\n        Map<Character,Integer> result = new HashMap<>();//数据格式：[A=123,B=123,C=123]\r\n        data.forEach((name,select)->{//遍历 投票结果\r\n            select.forEach(selectedItem->{//遍历 选项\r\n                if (result.containsKey(selectedItem)){//统计情况各选项\r\n                    result.put(selectedItem,result.get(selectedItem)+1);\r\n                }else {\r\n                    result.put(selectedItem,1);\r\n                }\r\n            });\r\n        });\r\n        System.out.println(\"统计结果:\"+result);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-14-05-32.png)\r\n\r\n\r\n## 不可变集合\r\n**概念**\r\n* 不可变集合就是不可以被修改的集合\r\n* 集合的数据项在创建的时候被预先提供，并在整个生命周期不可变，否则报错\r\n* 通过`List、Set、Map的构造器`提供的`of(E...elements)方法`可以创建不可变集合\r\n\r\n| 方法名称                                 | 说明                               |\r\n| ---------------------------------------- | ---------------------------------- |\r\n| `static <E> List<E> of(E...elements)`    | 创建一个具有指定元素的List集合对象 |\r\n| `static<E> Set<E> of(E...elements)`      | 创建一个具有指定元素的Set集合对象  |\r\n| `static <K,V> Map<K，V>of(E...elements)` | 创建一个具有指定元素的Map集合对象  |\r\n\r\n**List不可变集合创建、初始化、修改测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<Integer> list = List.of(111,222,333,444);\r\n        System.out.println(list);\r\n\r\n        list.add(555);//报错\r\n        System.out.println(list);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-14-36-54.png)\r\n\r\n**Set不可变集合创建、初始化、修改测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set<Integer> set = Set.of(111,222,333,444);\r\n        System.out.println(set);\r\n\r\n        set.add(555);//报错\r\n        System.out.println(set);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-14-37-49.png)\r\n\r\n\r\n**Map不可变集合创建、初始化、修改测试**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Map<String,Integer> map = Map.of(\"人名1\",18,\"人名2\",20,\"人名3\",22,\"人名4\",14);\r\n        System.out.println(map);\r\n\r\n        map.put(\"人名5\",17);//报错\r\n        System.out.println(map);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-14-41-51.png)\r\n\r\n## Stream流\r\n### 概念\r\n* 用于简化集合和数组操作的一系列API\r\n* Stream流的三类方法\r\n  * **获取Stream流**:相当于创建一条流水线，并把元素依次放到流水线上\r\n  * **中间方法**：对流水线上的元素进行操作\r\n  * **终极方法**：流水线的最后操作，一个Stream流只能有一个终极方法\r\n* **注意**：在流中无法直接修改原集合、Map、数组中的元素\r\n* **流的收集**：把Stream流操作后的结果收集到集合、Map、数组中\r\n\r\n### 获取Stream流\r\n\r\n**几种获取Stream流的方式**\r\n* 集合获取Stream流：调用实例对象的`.stream()`方法\r\n* Map获取Stream流：调用实例对象的`.entrySet().stream()`方法\r\n* 数组获取Stream流\r\n    | 名称                                             | 所属类 | 说明                                    |\r\n    | ------------------------------------------------ | ------ | --------------------------------------- |\r\n    | `public static <T> Stream<T> stream(T[ ] array)` | Arrays | 获取当前数组的Stream流                  |\r\n    | `public static<T> Stream<T> of(T... values)`     | Stream | 获取当前**数组**/**可变数据**的Stream流 |\r\n\r\n**获取Stream流测试**\r\n```java\r\nimport java.util.*;\r\nimport java.util.stream.Stream;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        /*----------------------------集合获取Stream流----------------------------*/\r\n        Collection<String> collection_names = new LinkedList<>();\r\n        Collections.addAll(collection_names,\"李四\",\"张三\",\"王五\",\"张三丰\",\"张麻子\");\r\n        Stream<String>collection_names_stream = collection_names.stream();\r\n\r\n        /*----------------------------Map获取Stream流----------------------------*/\r\n        Map<String,Integer> map_names = new HashMap<>();\r\n        map_names.put(\"李四\",22);\r\n        map_names.put(\"张三\",18);\r\n        map_names.put(\"王五\",35);\r\n        map_names.put(\"张三丰\",16);\r\n        map_names.put(\"张麻子\",14);\r\n        map_names.put(\"李四\",15);\r\n        Stream<Map.Entry<String,Integer>> map_names_stream = map_names.entrySet().stream();\r\n\r\n        /*----------------------------数组获取Stream流----------------------------*/\r\n        String[] arrary_names = {\"李四\",\"张三\",\"王五\",\"张三丰\",\"张麻子\"};\r\n        Stream<String> arrary_names_stream1 = Arrays.stream(arrary_names);//利用数组对象的静态方法stream()\r\n        Stream<String> arrary_names_stream2 = Stream.of(arrary_names);////利用Stream对象的静态方法of()\r\n    }\r\n}\r\n```\r\n\r\n### Stream的常用中间方法\r\n\r\n| 名称                                                | 说明                                                              |\r\n| --------------------------------------------------- | ----------------------------------------------------------------- |\r\n| `Stream<T> filter(Predicate<? super T> predicate)`  | 用于对流中的数据进行**过滤**。                                    |\r\n| ` Stream<T> limit( long maxSize)`                   | **获取**前几个元素                                                |\r\n| `Stream<T> skip( long n)`                           | **跳过**前几个元素                                                |\r\n| `Stream<T> distinct()`                              | **去除流中重复**的元素。<green>依赖(hashCode和equals方法)</green> |\r\n| **static**`<T> Stream<T> concat(Stream a,Stream b)` | **合并**a和b两个流为一个流                                        |\r\n| `map()`                                             | <green>加工方法</green>                                           |\r\n| `max(比较器对象)`                                   | 将获取到最大值                                                    |\r\n| `sorted(比较器对象)`                                | 排序                                                              |\r\n\r\n**Stream的常用中间方法测试**\r\n```java\r\nimport java.util.*;\r\nimport java.util.stream.Stream;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Collection<String> collection_names = new LinkedList<>();\r\n        Collections.addAll(collection_names,\"李四\",\"张三\",\"王五\",\"张三丰\",\"张麻子\",\"张麻子\");\r\n        System.out.println(\"/*----------------------------collection_names----------------------------*/\");\r\n        System.out.println(collection_names);\r\n\r\n        System.out.println(\"/*----------------------------filter测试----------------------------*/\");\r\n        collection_names.stream().filter(name->name.startsWith(\"张\")&&name.length()==3).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n\r\n        System.out.println(\"/*----------------------------limit测试----------------------------*/\");\r\n        collection_names.stream().limit(2).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n\r\n        System.out.println(\"/*----------------------------skip测试----------------------------*/\");\r\n        collection_names.stream().skip(3).forEach(System.out::println);//方法引用\r\n\r\n        System.out.println(\"/*----------------------------distinct测试----------------------------*/\");\r\n        collection_names.stream().distinct().forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n        System.out.println(\"/*----------------------------map测试----------------------------*/\");\r\n        collection_names.stream().map(name->{\r\n            return \"爱新觉罗 * \" + name;\r\n        }).map(name->{\r\n            return new Person(name);\r\n        }).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n\r\n        System.out.println(\"/*----------------------------static Stream concat测试----------------------------*/\");\r\n        Stream.concat(\r\n                collection_names.stream().limit(2),\r\n                collection_names.stream().skip(2)\r\n        ).distinct().forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n    }\r\n}\r\nclass Person{\r\n    String name;\r\n\r\n    public Person(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Person{\" +\r\n                \"name='\" + name + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-16-52-59.png)\r\n\r\n\r\n\r\n### Stream的常用终极方法\r\n| 名称                          | 说明                                 |\r\n| ----------------------------- | ------------------------------------ |\r\n| void forEach(Consumer action) | 对此流的每个元素执行遍历操作         |\r\n| long count()                  | 返回此流中的元素数                   |\r\n| E get()                       | 当前一级使用了max()时这里可以使用get |\r\n\r\n\r\n### Stream流的收集\r\n**作用**  \r\n把Stream流操作后的结果收集到集合、Map、数组中\r\n\r\n**注意**  \r\n<warn>流只能使用一次<warn>\r\n\r\n\r\n**Stream流的收集方法**\r\n| 名称                             | 说明                         |\r\n| -------------------------------- | ---------------------------- |\r\n| `R collect(collector collector)` | 开始收集Stream流，指定收集器 |\r\n| `Object[] toArray()`             | 转成数组                     |\r\n\r\n**Collectors工具类提供了具体的收集方式**\r\n| 名称                                                                       | 说明                   |\r\n| -------------------------------------------------------------------------- | ---------------------- |\r\n| `public static <T> collector toList()`                                     | 把元素收集到List集合中 |\r\n| `public static <T> collector toSet()`                                      | 把元素收集到Set集合中  |\r\n| `public static collector toMap(Function keyMapper , Function valueMapper)` | 把元素收集到Map集合中  |\r\n\r\n**具体使用步骤**\r\n```java\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.Stream;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<String> names = new ArrayList<>();\r\n        Collections.addAll(names,\"李四\",\"张三\",\"王五\",\"张三丰\",\"张麻子\",\"张麻子\");\r\n//将Stream流收集为List集合\r\n        Stream<String> stream1_names_zhang = names.stream().filter(n->n.startsWith(\"张\")&&n.length()==3);\r\n        List<String> list_names_zhang = stream1_names_zhang.collect(Collectors.toList());//转List集合\r\n        System.out.println(list_names_zhang);\r\n\r\n//将Stream流收集为Set集合\r\n        Stream<String> stream2_names_zhang = names.stream().filter(n->n.startsWith(\"张\")&&n.length()==3);//流只能使用一次，所以要再创建一次\r\n        Set<String> set_names_zhang = stream2_names_zhang.collect(Collectors.toSet());//转Set集合\r\n        System.out.println(set_names_zhang);\r\n\r\n//将Stream流收集为Array数组\r\n        Stream<String> stream3_names_zhang = names.stream().filter(n->n.startsWith(\"张\")&&n.length()==3);\r\n        Object[] arraryName_names_zhang = stream3_names_zhang.toArray();//转Array数组\r\n        System.out.println(Arrays.toString(arraryName_names_zhang));\r\n\r\n//将Stream流收集为Map集合\r\n        Map<String,Integer> persons = new HashMap<>();\r\n        persons.put(\"李四\",17);\r\n        persons.put(\"张三\",13);\r\n        persons.put(\"王五\",14);\r\n        persons.put(\"张三丰\",15);\r\n        persons.put(\"张麻子\",17);\r\n        persons.put(\"张麻子\",18);\r\n        Stream<Map.Entry<String,Integer>> stream4_persons_zhang = persons.entrySet().stream().filter(entry->entry.getKey().startsWith(\"张\")&&entry.getKey().length()==3);\r\n        Map<String,Integer> mapPersons_zhang = stream4_persons_zhang.collect( Collectors.toMap(person->person.getKey(),person->person.getValue()) );\r\n        System.out.println(mapPersons_zhang);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-20-51-08.png)\r\n\r\n\r\n### 案例\r\n\r\n**输出姓张且名字长度为3的人名**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        Set<String> names = new HashSet();\r\n        Collections.addAll(names,\"张三\",\"李四\",\"王五\",\"张三丰\",\"张麻子\");\r\n        System.out.println(names);\r\n\r\n        System.out.println(\"------------------------------------\");\r\n//使用集合的API获取姓张且名字长度为3的人名\r\n        names.forEach(name->{\r\n            if (name.startsWith(\"张\")&&name.length()==3){\r\n                System.out.println(name);\r\n            }\r\n        });\r\n//stream流式编程：filter支持链式编程\r\n        System.out.println(\"------------------------------------\");\r\n        names.stream().filter(name->name.startsWith(\"张\")).filter(name->name.length()==3).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n\r\n//stream流式编程：filter精简版\r\n        System.out.println(\"------------------------------------\");\r\n        names.stream().filter(name->name.startsWith(\"张\") && name.length()==3).forEach(name->{\r\n            System.out.println(name);\r\n        });\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-15-39-38.png)\r\n\r\n**部门员工工资数据分析**\r\n![](./images/java学习笔记/2022-10-29-19-15-58.png)\r\n```java\r\npackage com.yiguiding.package1;\r\nimport java.math.BigDecimal;\r\nimport java.math.RoundingMode;\r\nimport java.util.*;\r\nimport java.util.stream.Stream;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  {\r\n        List<Employee> department1 = new LinkedList<>();\r\n        department1.add(new Employee(\"猪八戒\",'男',30000,25000,null));\r\n        department1.add(new Employee(\"孙悟空\",'男',25000,1000,\"顶撞上司\"));\r\n        department1.add(new Employee(\"沙僧\",'男',20000,20000,null));\r\n        department1.add(new Employee(\"小白龙\",'男',20000,25000,null));\r\n\r\n        List<Employee> department2 = new LinkedList<>();\r\n        department2.add(new Employee(\"武松\",'男',15000,9000,null));\r\n        department2.add(new Employee(\"李逵\",'男',20000,10000,null));\r\n        department2.add(new Employee(\"西门庆\",'男',50000,100000,\"被打\"));\r\n        department2.add(new Employee(\"潘金莲\",'女',3500,1000,\"被打\"));\r\n        department2.add(new Employee(\"武大郎\",'男',20000,0,\"下毒\"));\r\n\r\n//1.分别筛选两部门的最高工资的员工信息\r\n        Employee dep1_max_salary = department1\r\n                .stream()\r\n                .max((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .get();\r\n        System.out.println(\"部门1最高工资的员工信息：\"+dep1_max_salary);\r\n        Employee dep2_max_salary = department2\r\n                .stream()\r\n                .max((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .get();\r\n        System.out.println(\"部门2最高工资的员工信息：\"+dep2_max_salary);\r\n\r\n//2.分别统计两部门的平局工资，要求过滤最高和最低工资\r\n        List<Double> dep1_salarys = new LinkedList();\r\n        double dep1_salary_average = 0;\r\n        department1\r\n                .stream()\r\n                .sorted((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)//排序后去除第一个\r\n                .sorted((o1, o2) -> -Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)//反排序后去再掉第一个，实现去除最高和最低工资\r\n                .forEach(employee -> {\r\n                    dep1_salarys.add(employee.getBonus()+employee.getSalary());\r\n                });\r\n        for (double salary : dep1_salarys){\r\n            dep1_salary_average+=salary;\r\n        }\r\n        BigDecimal a = BigDecimal.valueOf(dep1_salary_average);\r\n        BigDecimal b = BigDecimal.valueOf(dep1_salarys.size());\r\n        BigDecimal c ;\r\n        if (dep1_salarys.size()!=0)\r\n            c = a.divide(b,2, RoundingMode.HALF_UP);//计算平均值\r\n        else\r\n            c = a;\r\n        System.out.println(\"部门1的平局工资为：\"+c);\r\n\r\n\r\n        List<Double> dep2_salarys = new LinkedList();\r\n        double dep2_salary_average = 0;\r\n        department2\r\n                .stream()\r\n                .sorted((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)//排序后去除第一个\r\n                .sorted((o1, o2) -> -Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)//反排序后去再掉第一个，实现去除最高和最低工资\r\n                .forEach(employee -> {\r\n                    dep2_salarys.add(employee.getBonus()+employee.getSalary());\r\n                });\r\n        for (double salary : dep2_salarys){\r\n            dep2_salary_average+=salary;\r\n        }\r\n         a = BigDecimal.valueOf(dep2_salary_average);\r\n         b = BigDecimal.valueOf(dep2_salarys.size());\r\n        if (dep2_salarys.size()!=0)\r\n            c = a.divide(b,2, RoundingMode.HALF_UP);//计算平均值\r\n        else\r\n            c = a;\r\n        System.out.println(\"部门2的平局工资为：\"+c);\r\n\r\n//3.统计两个部门的平均工资，要求过滤最高和最低工资\r\n        List<Double> dep1_2_salarys = new LinkedList();\r\n        double dep1_2_salary_average = 0;\r\n        Stream<Employee> dep1_stream = department1.stream();\r\n        Stream<Employee> dep2_stream = department2.stream();\r\n        Stream.concat(dep1_stream,dep2_stream)\r\n                .sorted((o1, o2) -> Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)\r\n                .sorted((o1, o2) -> -Double.compare(o1.getSalary()+o1.getBonus(),o2.getSalary()+o2.getBonus()))\r\n                .skip(1)\r\n                .forEach(employee->{\r\n                    dep1_2_salarys.add(employee.getSalary()+employee.getBonus());\r\n                });\r\n        for (double salary : dep1_2_salarys){\r\n            dep1_2_salary_average+=salary;\r\n        }\r\n        a = BigDecimal.valueOf(dep1_2_salary_average);\r\n        b = BigDecimal.valueOf(dep1_2_salarys.size());\r\n        if (dep1_2_salarys.size()!=0)\r\n            c = a.divide(b,2, RoundingMode.HALF_UP);//计算平均值\r\n        else\r\n            c = a;\r\n        System.out.println(\"两部门的平局工资为：\"+c);\r\n    }\r\n}\r\nclass Employee{\r\n    String name;\r\n    char sex;\r\n    double salary;\r\n    double bonus;\r\n    String punish;\r\n    public Employee(String name, char sex, double salary, double bonus, String punish) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n        this.salary = salary;\r\n        this.bonus = bonus;\r\n        this.punish = punish;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public char getSex() {\r\n        return sex;\r\n    }\r\n\r\n    public void setSex(char sex) {\r\n        this.sex = sex;\r\n    }\r\n\r\n    public double getSalary() {\r\n        return salary;\r\n    }\r\n\r\n    public void setSalary(double salary) {\r\n        this.salary = salary;\r\n    }\r\n\r\n    public double getBonus() {\r\n        return bonus;\r\n    }\r\n\r\n    public void setBonus(double bonus) {\r\n        this.bonus = bonus;\r\n    }\r\n\r\n    public String getPunish() {\r\n        return punish;\r\n    }\r\n\r\n    public void setPunish(String punish) {\r\n        this.punish = punish;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Employee{\" +\r\n                \"name='\" + name + '\\'' +\r\n                \", sex=\" + sex +\r\n                \", salary=\" + salary +\r\n                \", bonus=\" + bonus +\r\n                \", punish='\" + punish + '\\'' +\r\n                '}';\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-29-19-15-15.png)\r\n\r\n\r\n## 异常处理\r\n### 概念\r\n* 异常程序在**编译**或**执行阶段**可能出现的问题\r\n* **语法错误不是异常**\r\n* 如：数组索引越界、空指针异常、日期格式化异常......\r\n* **若异常出现但不处理，程序会退出JVM虚拟机**\r\n* 研究异常、避免异常、提前处理异常、保证程序的安全健壮\r\n\r\n**异常体系**\r\n* `Throwable`是所有异常的**祖宗类**\r\n* `Error`是**系统级别的异常**，JVM退出等，<green>**程序无法干预控制**</green>\r\n* `Exception`，在java.lang包下，称为异常类，<green>**程序可以干预的异常**</green>\r\n  * `RuntimeExpection及其子类`：<green>**运行时异常**</green>，编译阶段不会报错\r\n  * `是Exception的子类但不是RuntimeExpection的子类的异常`：<green>**编译时异常**</green>，编译期必须处理的异常，否则程序不能通过编译，一般用于提醒程序员这里很容易出错\r\n\r\n![](./images/java学习笔记/2022-10-29-22-49-57.png)\r\n\r\n\r\n\r\n### 常见异常\r\n\r\n**常见运行时异常**\r\n* `ArrayIndexOutOfBoundsException` 数组访问越界异常 `arr[99999]`\r\n* `NullPointerException` 空指针访问异常 `null.getValue()`\r\n* `ClassCastException` 类型转换异常 `String a = (String) (Object) 123;`\r\n* `ArithmeticException` 数学操作异常 `a = 123/0`\r\n* `NumberFormatException` 数学转换异常 `Double.valueOf(\"abcd123.123\")`\r\n\r\n**常见编译阶段异常**\r\n```java\r\nString data = \"2021-12.25 12:24:11\";\r\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\r\nDate dt = sdf.parse(data);//无论写的对不对，parse会抛出编译时异常\r\nSystem.out.println(dt);\r\n```\r\n\r\n### 默认异常处理机制\r\n\r\n**默认编译时异常处理机制**\r\n* **不会自动向外抛出异常**\r\n* 必须手动处理\r\n\r\n**默认运行时异常处理机制**\r\n* 在出现异常的地方创建异常对象\r\n* **在这个地方抛出异常返回给调用者，层层抛出，直到抛出给JVM虚拟机**(默认会自动抛出异常)\r\n* 虚拟机输出异常的栈信息\r\n* 直接在异常点结束虚拟机\r\n\r\n`try{}cache(){}`的使用\r\n```java\r\ntry{\r\n    return;\r\n\r\n}cache(Expection e){\r\n    return -1;\r\n}cache(Expection e){\r\n    System.exit(0);//退出jvm虚拟机\r\n    return -1;\r\n}finally{//无论是否有异常（除非jvm虚拟机退出）,即使程序提前return，一定会执行的代码块，用于资源释放\r\n    //这里写return -1，则程序的结果永远是-1\r\n}\r\n```\r\n\r\n`try(resource){}cache(){}`的使用\r\n```java\r\n//jdk9语法\r\ntry(\r\n    // 资源\r\n    文件流 io = new 文件流;// 无论程序是否出现异常，程序会把此处的定义的资源（实现了[auto]Closeable接口的类）释放掉\r\n    文件流 io = new 文件流;\r\n){\r\n    操作\r\n}cache(Expection e){\r\n\r\n}\r\n```\r\n\r\n\r\n### 处理异常\r\n\r\n**对编译时异常的处理**\r\n* 通过`throws`**显式**抛给调用者\r\n* 自己捕获并处理异常`try{}cache(){}`\r\n```java\r\nimport java.text.ParseException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.*;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)  throws ParseException //需要在这里 `显式` 抛出编译时异常\r\n    {\r\n        String data = \"2021-12.25 12:24:11\";\r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\r\n        Date dt = sdf.parse(data);//无论写的对不对，parse会抛出编译时异常\r\n        System.out.println(dt);\r\n    }\r\n}\r\n```\r\n\r\n**对编译时异常的处理**\r\n* 出现异常直接抛给调用者，调用者也继续向外抛 **(默认自动抛出)**\r\n* 自己捕获并处理异常`try{}cache(){}`\r\n* 结合前两者，**被调者**抛出异常，**调用者**捕获**被调者**抛出的异常并**处理异常**\r\n* **异常处理的案例**\r\n    ```java\r\n    public class HelloWorld {\r\n        public static void main(String[] args)\r\n        {\r\n            try{\r\n                divide(123,0);\r\n            }catch (Exception e){//捕获异常\r\n                e.printStackTrace();//打印栈信息\r\n                System.out.println(\"捕获了异常\");//处理异常\r\n            }\r\n        }\r\n        public static int divide(int a ,int b) //抛出数学异常\r\n        {\r\n            return a/b;\r\n        }\r\n    }\r\n    ```\r\n\r\n### 自定义异常\r\n* 自定义编译时异常可以提醒程序员某处容易出错\r\n* 自定义异常可以通过`printStackTrace`打印栈信息，快速定位错误出现在第几行\r\n\r\n**自定义编译时异常**\r\n* 定义一个异常类，继承<green>Exception</green>\r\n* 重写构造器\r\n* 在出现异常的地方用`throw new 自定义异常构造器(参数);`抛出异常\r\n* 必须在函数声明处通过`throws 自定义异常名`手动抛出给调用者 \r\n\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) throws AgeError{ //编译时异常必须手动处理\r\n    \r\n        checkAge(-100);\r\n    }\r\n    public static void  checkAge(int age) throws AgeError{//编译时异常必须手动处理\r\n        if (age>200||age<0){\r\n            throw new AgeError(age);\r\n        }\r\n        System.out.println(\"年龄校验成功\");\r\n    }\r\n}\r\n\r\nclass AgeError extends Exception{//继承Exception\r\n    public AgeError() {\r\n    }\r\n\r\n    public AgeError(int age) {\r\n        super(\"年龄： \" + age + \" 取值范围不合理！！！\");\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-30-01-03-19.png)\r\n\r\n\r\n\r\n**自定义运行时异常**\r\n* 定义一个异常类，继承 <green>RuntimeException</green>\r\n* 重写构造器\r\n* 在出现异常的地方用`throw new 自定义异常构造器(参数);`抛出异常\r\n* 无需手动使用`throws 自定义异常名`抛出异常给调用者\r\n```java\r\npublic class HelloWorld {\r\n    public static void main(String[] args) //运行时异常将被自动抛出\r\n    {\r\n        checkAge(-100);\r\n    }\r\n    public static void  checkAge(int age){//运行时异常将被自动抛出\r\n        if (age>200||age<0){\r\n            throw new AgeRuntimeError(age);\r\n        }\r\n        System.out.println(\"年龄校验成功\");\r\n    }\r\n}\r\n\r\nclass AgeRuntimeError extends RuntimeException{//继承运行时异常\r\n    public AgeRuntimeError() {\r\n    }\r\n\r\n    public AgeRuntimeError(int age) {\r\n        super(\"年龄： \" + age + \" 取值范围不合理！！！\");\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-30-01-10-41.png)\r\n\r\n### 案例\r\n\r\n**通过异常处理使程序更稳健的案例**\r\n```java\r\nimport java.util.Scanner;\r\n\r\npublic class HelloWorld {\r\n    public static void main(String[] args)\r\n    {\r\n        Scanner sc = new Scanner(System.in);\r\n        while (true){\r\n            try {\r\n                System.out.println(\"请输入一个合理的价格：\");\r\n                Double price = Double.valueOf(sc.nextLine());\r\n                if (price<0){\r\n                    System.out.println(\"价格不能为负数，请重新输入\");\r\n                }else {\r\n                    System.out.println(\"定价成功：价格为：\"+price);\r\n                    break;\r\n                }\r\n            }catch (Exception e){\r\n                e.printStackTrace();\r\n                System.out.println(\"请输入合法数据！！！\");\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-10-30-00-37-56.png)\r\n\r\n\r\n\r\n## 日志框架\r\n\r\n### 概念\r\n* 系统在开发阶段或者上线后，一旦业务出现问题，需要有信息去定位，如何记录程序的运行信息?\r\n* 日志框架相当于飞机的黑匣子，记录程序中出现的问题\r\n\r\n**日志技术具备的优势**\r\n* 可以将系统执行的信息选择性的记录到指定的位置（控制台、文件中、数据库中）。\r\n* 可以随时以开关的形式控制是否记录日志，无需修改源代码。\r\n\r\n**日志框架和输出语句相比的具体优势**\r\n| 项目     | 输出语句                       | 日志框架                             |\r\n| -------- | ------------------------------ | ------------------------------------ |\r\n| 输出位置 | 只能是控制台                   | 可以将日志信息写入到文件或者数据库中 |\r\n| 关闭日志 | 需要修改代码，灵活性比较差     | 不需要修改代码，灵活性比较好         |\r\n| 多线程   | 性能较差，会拖累程序的业务逻辑 | 性能较好                             |\r\n\r\n\r\n### 日志框架体系结构\r\n\r\n**日志规范接口:** 一些接口，提供给日志的实现框架设计的标准。\r\n* JUL (Commons Logging)\r\n* slf4j (simple Logging Facade for java)\r\n\r\n**日志实现框架:** 牛人或者第三方公司已经做好的日志记录实现代码，后来者直接可以拿去使用。\r\n* Log4j\r\n* JCL (java.util.Logging)\r\n* **Logback**\r\n* 其他实现\r\n\r\n**发展历程**\r\n* 接口规范: Commons Logging -> slf4j\r\n* 实现框架: Log4j -> Logback\r\n\r\n## Logback日志框架\r\n\r\n### 概念\r\n* Logback是由Log4j创始人设计的另一个开源日志框架，性能更好。\r\n* 基于slf4j规范结构\r\n\r\n**Logback主要分为三个技术模块**:\r\n* **logback-core**: logback-core模块为其他两个模块奠定了基础，必须有。\r\n* **logback-classic**:它是log4j的一个改良版本，同时它完整实现了 slf4j-API.\r\n* logback-access模块与Tomcat和Jetty 等Servlet容器集成，以提供HTTP访问日志功能\r\n\r\n**使用Logback需要的模块**\r\n* **slf4j-api**: 日志规范\r\n* logback-core\r\n* logback-classic\r\n\r\n### 使用与配置\r\n* 项目下新建lib文件夹，\r\n* 导入`slf4j-api.jar`、`logback-core.jar`、`logback-classic.jar`三个文件\r\n* 添加到项目依赖库 ![](./images/java学习笔记/2022-10-30-02-13-34.png)\r\n* 将Logback的核心配置文件`logback.xml`直接拷贝到src目录下（必须是src)\r\n* 在代码中获取日志的对象\r\n    ```java\r\n    import org.slf4j.Logger;\r\n    import org.slf4j.LoggerFactory;\r\n    public class Main {\r\n        public static final Logger LOGGER = LoggerFactory.getLogger(Main.class);\r\n        public static void main(String[] args) {\r\n            LOGGER.debug(\"哈哈哈哈\");\r\n        }\r\n    }\r\n    ```\r\n* 将`logback.xml`配置文件放到`src`或`合适的目录`\r\n\r\n**logback.xml**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<configuration>\r\n    <!--\r\n        CONSOLE ：表示当前的日志信息是可以输出到控制台的。\r\n    -->\r\n    <appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n        <!--输出流对象 默认 System.out 可改为 System.err-->\r\n        <target>System.out</target>\r\n        <encoder>\r\n            <!--\r\n                格式化输出：\r\n                    %d表示日期，\r\n                    %thread表示线程名，\r\n                    %-5level：级别从左显示5个字符宽度\r\n                    %msg：日志消息，\r\n                    %n是换行符\r\n            -->\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level]  %c [%thread] : %msg%n</pattern>\r\n        </encoder>\r\n    </appender>\r\n    <!-- File是输出的方向通向文件的 -->\r\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\r\n        <encoder>\r\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\r\n            <charset>utf-8</charset>\r\n        </encoder>\r\n        <!--日志输出路径-->\r\n        <file>D:/code/data.log</file>\r\n        <!--指定日志文件拆分和压缩规则-->\r\n        <rollingPolicy\r\n                class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\r\n            <!--通过指定压缩文件名称，来确定分割文件方式-->\r\n            <fileNamePattern>D:/code/data2-%d{yyyy-MM-dd}.log%i.gz</fileNamePattern>\r\n            <!--文件拆分大小-->\r\n            <maxFileSize>1MB</maxFileSize>\r\n        </rollingPolicy>\r\n    </appender>\r\n    <!--\r\n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF\r\n   ， 默认debug\r\n    <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。\r\n    -->\r\n    <root level=\"ALL\">\r\n        <appender-ref ref=\"CONSOLE\"/>\r\n        <appender-ref ref=\"FILE\" />\r\n    </root>\r\n</configuration>\r\n```\r\n\r\n## 电影商城实现\r\n\r\n**核心功能**\r\n* 用户注册:商家注册，客户注册\r\n* 用户登录:商家登录，客户登录\r\n* 商家发布，下架，修改，电影票信息\r\n* 客户浏览，下单，支付，电影票\r\n* 客户打分，给已下单的影片打分\r\n\r\n<details>\r\n<summary> <strong>源代码<strong> </summary>\r\n\r\n```java\r\nimport java.math.BigDecimal;\r\nimport java.math.MathContext;\r\nimport java.math.RoundingMode;\r\nimport java.text.SimpleDateFormat;\r\nimport java.time.Instant;\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.Stream;\r\nimport org.slf4j.Logger;//日志系统，可以删除\r\nimport org.slf4j.LoggerFactory;//日志系统，可以删除\r\n\r\npublic class Main {\r\n\r\n  public static final Logger LOGGER = LoggerFactory.getLogger(Main.class);\r\n  public static final Map<String, List<Movie>> MOVIESINFO_DB = new HashMap<>(); // 电影信息数据库\r\n  public static final Map<String, User> USERS_DB = new HashMap<>(); // 用户信息数据库\r\n  public static final Scanner SCANNER = new Scanner(System.in);\r\n  public static final SimpleDateFormat sdf = new SimpleDateFormat(\r\n    \"yyyy-MM-dd HH:mm\"\r\n  );\r\n\r\n  public static void main(String[] args) {\r\n    USERS_DB.put(\r\n      \"123\",\r\n      new Business(\r\n        \"123\",\r\n        \"DDYYGG\",\r\n        '女',\r\n        \"123\",\r\n        \"110\",\r\n        0,\r\n        \"好看影视公司\",\r\n        \"北京新工业园区创业路1号\"\r\n      )\r\n    );\r\n    USERS_DB.put(\r\n      \"1234\",\r\n      new Customer(\"1234\", \"DingYigui\", '男', \"1234\", \"110\", 1000000)\r\n    );\r\n    MOVIESINFO_DB.put(\"123\", new LinkedList<>());\r\n\r\n    while (true) {\r\n      try {\r\n        System.out.println(\r\n          \"----------------------------重光电影院----------------------------\"\r\n        );\r\n        System.out.println(\"1.登录用户。\");\r\n        System.out.println(\"2.注册用户。\");\r\n        System.out.println(\"0.退出。\");\r\n        System.out.println(\"请输入操作类型：\");\r\n        String operator = SCANNER.nextLine();\r\n        switch (operator) {\r\n          case \"1\":\r\n            login();\r\n            break;\r\n          case \"2\":\r\n            register();\r\n            break;\r\n          case \"0\":\r\n            return;\r\n          default:\r\n            printLine();\r\n            System.out.println(\"未知操作符，请重新输入\");\r\n            break;\r\n        }\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"操作异常，请重试！！！\");\r\n        LOGGER.warn(e.toString());\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void register() {\r\n    while (true) {\r\n      System.out.println(\r\n        \"----------------------------用户注册----------------------------\"\r\n      );\r\n      System.out.println(\"1.注册商家。\");\r\n      System.out.println(\"2.注册顾客。\");\r\n      System.out.println(\"0.退出。\");\r\n      System.out.println(\"请输入操作类型：\");\r\n      String operator = SCANNER.nextLine();\r\n      switch (operator) {\r\n        case \"1\":\r\n          regUser(true);\r\n          return;\r\n        case \"2\":\r\n          regUser(false);\r\n          return;\r\n        case \"0\":\r\n          return;\r\n        default:\r\n          printLine();\r\n          System.out.println(\"未知操作符，请重新输入。\");\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void login() {\r\n    System.out.println(\r\n      \"----------------------------登录----------------------------\"\r\n    );\r\n    System.out.println(\"请输入用户名：\");\r\n    String userName = SCANNER.nextLine();\r\n    System.out.println(\"请输入密码：\");\r\n    String passwd = SCANNER.nextLine();\r\n    User user = USERS_DB.get(userName);\r\n\r\n    printLine();\r\n    if (user != null && user.getPasswd().equals(passwd)) {\r\n      System.out.println(\"登录成功！！！\");\r\n      UserMenu(user);\r\n    } else {\r\n      System.out.println(\"登录失败...\");\r\n    }\r\n  }\r\n\r\n  public static void UserMenu(User user) {\r\n    System.out.println(\r\n      \"----------------------------欢迎----------------------------\"\r\n    );\r\n    System.out.println(\"欢迎你, \" + user.getName() + \" ,别来无恙。\");\r\n    System.out.println(\"账户余额：\" + user.getMoney() + \"元\");\r\n\r\n    if (user instanceof Customer) {\r\n      customerMenu((Customer) user);\r\n    } else if (user instanceof Business) {\r\n      businessMenu((Business) user);\r\n    }\r\n  }\r\n\r\n  public static void businessMenu(Business business) {\r\n    while (true) {\r\n      System.out.println(\r\n        \"----------------------------商家菜单页----------------------------\"\r\n      );\r\n      System.out.println(\"1.用户信息。\");\r\n      System.out.println(\"2.上架影片。\");\r\n      System.out.println(\"3.修改影片。\");\r\n      System.out.println(\"4.下架影片。\");\r\n      System.out.println(\"5.影片信息。\");\r\n      System.out.println(\"6.订单信息。\");\r\n      System.out.println(\"0.返回菜单。\");\r\n      String operator = SCANNER.nextLine();\r\n      switch (operator) {\r\n        case \"1\":\r\n          showBusinessInfo(business);\r\n          break;\r\n        case \"2\":\r\n          addFilm(business);\r\n          break;\r\n        case \"3\":\r\n          updateFilmInfo(business);\r\n          break;\r\n        case \"4\":\r\n          delFilm(business);\r\n          break;\r\n        case \"5\":\r\n          showMoviesInfo(MOVIESINFO_DB.get(business.getUserName()));\r\n          break;\r\n        case \"6\":\r\n          showOrderInfo(business.getOrders());\r\n          break;\r\n        case \"0\":\r\n          return;\r\n        default:\r\n          printLine();\r\n          System.out.println(\"未知操作符，请重新输入。\");\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void updateFilmInfo(Movie movie) {\r\n    while (true) {\r\n      System.out.println(\r\n        \"----------------------影片信息修改----------------------------\"\r\n      );\r\n      System.out.println(\"1.修改影片名称\");\r\n      System.out.println(\"2.修改主演名称\");\r\n      System.out.println(\"3.修改影片时长\");\r\n      System.out.println(\"4.修改影片票价\");\r\n      System.out.println(\"5.修改影片总票数\");\r\n      System.out.println(\"0.退出\");\r\n      System.out.println(\"请输入要修改的字段：\");\r\n      String operator = SCANNER.nextLine();\r\n      switch (operator) {\r\n        case \"1\":\r\n          movie.setMovieName(Movie.genMovieName(SCANNER));\r\n          break;\r\n        case \"2\":\r\n          movie.setActors(Movie.genActors(SCANNER));\r\n          break;\r\n        case \"3\":\r\n          movie.setTimeLong(Movie.genTimeLong(SCANNER));\r\n          break;\r\n        case \"4\":\r\n          movie.setPrice(Movie.genPrice(SCANNER));\r\n          break;\r\n        case \"5\":\r\n          movie.setTotalTicket(Movie.genTotalTicket(SCANNER));\r\n          break;\r\n        case \"0\":\r\n          return;\r\n        default:\r\n          printLine();\r\n          System.out.println(\"未知操作符，请重新输入。\");\r\n          continue;\r\n      }\r\n      printLine();\r\n      System.out.println(\"修改成功\");\r\n    }\r\n  }\r\n\r\n  public static void updateFilmInfo(Business business) {\r\n    List<Movie> movies = MOVIESINFO_DB.get(business.getUserName());\r\n    if (movies.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"没有已上架电影的信息。\");\r\n      return;\r\n    }\r\n    showMoviesInfo(movies);\r\n    int index;\r\n    while (true) {\r\n      try {\r\n        printLine();\r\n        System.out.println(\"请输入要修改的影片的序号：\");\r\n        index = Integer.valueOf(SCANNER.nextLine());\r\n        if (0 <= index && index < movies.size()) {\r\n          break;\r\n        }\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"异常,请重新输入。\");\r\n      }\r\n    }\r\n    Movie movie = movies.get(index);\r\n    printLine();\r\n    if (movie == null) {\r\n      System.out.println(\"获取影片实例失败。\");\r\n    } else {\r\n      System.out.println(\"获取影片实例成功。\");\r\n      updateFilmInfo(movie);\r\n    }\r\n  }\r\n\r\n  public static void printLine() {\r\n    System.out.println(\r\n      \"-----------------------------操作结果----------------------------------\"\r\n    );\r\n  }\r\n\r\n  public static void printLineWithTitle(String title) {\r\n    System.out.println(\r\n      \"----------------------------\" + title + \"----------------------------\"\r\n    );\r\n  }\r\n\r\n  public static void addFilm(Business business) {\r\n    MOVIESINFO_DB\r\n      .get(business.getUserName())\r\n      .add(\r\n        new Movie(\r\n          Movie.genMovieName(SCANNER),\r\n          Movie.genActors(SCANNER),\r\n          Movie.genTimeLong(SCANNER),\r\n          Movie.genPrice(SCANNER),\r\n          Movie.genTotalTicket(SCANNER),\r\n          Movie.genBeOn(SCANNER),\r\n          business.getUserName()\r\n        )\r\n      );\r\n    printLine();\r\n    System.out.println(\"电影上架成功！\");\r\n  }\r\n\r\n  public static void delFilm(Business business) {\r\n    List movies = MOVIESINFO_DB.get(business.getUserName());\r\n    if (movies.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"没有已上架电影的信息。\");\r\n      return;\r\n    }\r\n    showMoviesInfo(movies);\r\n    int index;\r\n    while (true) {\r\n      try {\r\n        printLine();\r\n        System.out.println(\"请输入要下架影片的序号：\");\r\n        index = Integer.valueOf(SCANNER.nextLine());\r\n        if (0 <= index && index < movies.size()) {\r\n          break;\r\n        }\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"异常,请重新输入。\");\r\n      }\r\n    }\r\n    printLine();\r\n    if (movies.remove(index) == null) {\r\n      System.out.println(\"影片下架失败\");\r\n    } else {\r\n      System.out.println(\"影片下架成功\");\r\n    }\r\n  }\r\n\r\n  public static void showMoviesInfo(List<Movie> movies) {\r\n    if (movies == null || movies.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"\\t无影片信息\");\r\n      return;\r\n    }\r\n    String leftAlignFormat =\r\n      \"| %-5s | %-20s | %-20s | %-10s | %-10s | %-10s | %-10s | %-10s | %-15s |%n\";\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+------------+------------+------------+------------+------------+-----------------+%n\"\r\n    );\r\n    System.out.format(\r\n      \"|  序号  |       影片名称        |          主演         |     评分    |     时长    |    票价    |     余票    |     总票    |       上映       |%n\"\r\n    );\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+------------+------------+------------+------------+------------+-----------------+%n\"\r\n    );\r\n\r\n    int index = 0;\r\n    for (Movie movie : movies) {\r\n      System.out.format(\r\n        leftAlignFormat,\r\n        index++,\r\n        movie.getMovieName(),\r\n        movie.getActorsToStr(),\r\n        movie.getScore(),\r\n        movie.getTimeLong(),\r\n        movie.getPrice(),\r\n        movie.getRestTicket(),\r\n        movie.getTotalTicket(),\r\n        sdf.format(movie.getBeOn())\r\n      );\r\n    }\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+------------+------------+------------+------------+------------+-----------------+%n\"\r\n    );\r\n  }\r\n\r\n  public static void showBusinessInfo(Business business) {\r\n    printLineWithTitle(\"商家信息\");\r\n    System.out.println(\"用户名：\" + business.getUserName());\r\n    System.out.println(\"账户余额：\" + business.getMoney());\r\n    System.out.println(\"姓名：\" + business.getName());\r\n    System.out.println(\"性别：\" + business.getSex());\r\n    System.out.println(\"手机号：\" + business.getTelNum());\r\n    System.out.println(\"公司名称：\" + business.getCompanyName());\r\n    System.out.println(\"公司地址：\" + business.getCompanyAddress());\r\n  }\r\n\r\n  public static void showCustomInfo(Customer customer) {\r\n    printLineWithTitle(\"客户信息\");\r\n    System.out.println(\"用户名：\" + customer.getUserName());\r\n    System.out.println(\"账户余额：\" + customer.getMoney());\r\n    System.out.println(\"姓名：\" + customer.getName());\r\n    System.out.println(\"性别：\" + customer.getSex());\r\n    System.out.println(\"手机号：\" + customer.getTelNum());\r\n  }\r\n\r\n  public static void showOrderInfo(List<Order> orders) {\r\n    if (orders == null || orders.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"\\t无订单信息\");\r\n      return;\r\n    }\r\n    String leftAlignFormat =\r\n      \"| %-5s | %-20s | %-20s | %-20s | %-10s | %-10s | %-15s |%n\";\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+----------------------+------------+------------+-----------------+%n\"\r\n    );\r\n    System.out.format(\r\n      \"|  序号  |        电影名         |       商家用户名       |       客户用户名       |    票价     |    票数    |       订单总额    |%n\"\r\n    );\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+----------------------+------------+------------+-----------------+%n\"\r\n    );\r\n    int index = 0;\r\n    for (Order order : orders) {\r\n      System.out.format(\r\n        leftAlignFormat,\r\n        index++,\r\n        order.getMovieName(),\r\n        order.getBusinessUserName(),\r\n        order.getCustomUserName(),\r\n        order.getTicketPrice(),\r\n        order.getTicketNum(),\r\n        order.getTotalPrice()\r\n      );\r\n    }\r\n    System.out.format(\r\n      \"+-------+----------------------+----------------------+----------------------+------------+------------+-----------------+%n\"\r\n    );\r\n  }\r\n\r\n  public static void customerMenu(Customer custom) {\r\n    while (true) {\r\n      System.out.println(\r\n        \"----------------------------客户菜单页----------------------------\"\r\n      );\r\n      System.out.println(\"1.用户信息。\");\r\n      System.out.println(\"2.买电影票。\");\r\n      System.out.println(\"3.查看订单。\");\r\n      System.out.println(\"4.影片评分。\");\r\n      System.out.println(\"5.余额充值。\");\r\n      System.out.println(\"0.退出。\");\r\n      String operator = SCANNER.nextLine();\r\n      switch (operator) {\r\n        case \"1\":\r\n          showCustomInfo(custom);\r\n          break;\r\n        case \"2\":\r\n          buyTicket(custom);\r\n          break;\r\n        case \"3\":\r\n          showOrderInfo(custom.getOrders());\r\n          break;\r\n        case \"4\":\r\n          evaluateMovie(custom);\r\n          break;\r\n        case \"5\":\r\n          addMoney(custom);\r\n          break;\r\n        case \"0\":\r\n          return;\r\n        default:\r\n          System.out.println(\"未知操作符，请重新输入。\");\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void addMoney(Customer customer) {\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入充值金额：\");\r\n        Double addMoney = Double.valueOf(SCANNER.nextLine());\r\n        if (addMoney < 0) {\r\n          System.out.println(\"输入金额不能为负数。\");\r\n          continue;\r\n        }\r\n        customer.setMoney(customer.getMoney() + addMoney);\r\n        printLine();\r\n        System.out.println(\"充值成功。\");\r\n        System.out.println(\"当前余额：\" + customer.getMoney());\r\n        break;\r\n      } catch (Exception e) {\r\n        System.out.println(\"异常，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static List<Movie> getMoviesInOrders(List<Order> orders) {\r\n    Stream<Movie> movieStream = orders\r\n      .stream()\r\n      .map(targetOrder -> {\r\n        for (Movie movie : MOVIESINFO_DB.get(\r\n          targetOrder.getBusinessUserName()\r\n        )) {\r\n          if (\r\n            movie.getMovieBirthHash_id() == targetOrder.getMovieId()\r\n          ) return movie;\r\n        }\r\n        return null;\r\n      })\r\n      .filter(movie -> movie != null);\r\n    return movieStream.collect(Collectors.toList());\r\n  }\r\n\r\n  public static void evaluateMovie(Movie movie) {\r\n    while (true) {\r\n      try {\r\n        System.out.println(\r\n          \"请输入你评分（0.0 - 10.0 ）,低于0分判定为0，高于10分判定为10：\"\r\n        );\r\n        movie.evaluateScore(Double.valueOf(SCANNER.nextLine()));\r\n        printLine();\r\n        System.out.println(\"评分成功\");\r\n        return;\r\n      } catch (Exception e) {\r\n        System.out.println(\"非法字符，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void evaluateMovie(Customer customer) {\r\n    List<Order> customOrders = customer.getOrders();\r\n\r\n    if (customOrders.size() == 0) {\r\n      printLine();\r\n      System.out.println(\"订单为空，无观看影片信息。\");\r\n      return;\r\n    }\r\n    List<Movie> moviesInOrders = getMoviesInOrders(customOrders);\r\n    showMoviesInfo(moviesInOrders);\r\n\r\n    int index;\r\n    while (true) {\r\n      try {\r\n        printLine();\r\n        System.out.println(\"请输入要评分的影片的序号：\");\r\n        index = Integer.valueOf(SCANNER.nextLine());\r\n        if (0 <= index && index < moviesInOrders.size()) {\r\n          break;\r\n        }\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"异常,请重新输入。\");\r\n      }\r\n    }\r\n    Movie movie = moviesInOrders.get(index);\r\n    printLine();\r\n    if (movie == null) {\r\n      System.out.println(\"获取影片实例失败。\");\r\n    } else {\r\n      System.out.println(\"获取影片实例成功。\");\r\n      evaluateMovie(movie);\r\n    }\r\n  }\r\n\r\n  public static List<Movie> getAllMovies() {\r\n    List<Movie> list_movie = new LinkedList<>();\r\n    MOVIESINFO_DB\r\n      .values()\r\n      .forEach(movies -> {\r\n        list_movie.addAll(movies);\r\n      });\r\n    return list_movie;\r\n  }\r\n\r\n  public static void buyTicket(Customer customer) {\r\n    List<Movie> allMovies = getAllMovies();\r\n    while (true) {\r\n      try {\r\n        printLineWithTitle(\"购票子系统\");\r\n        if (allMovies.size() == 0) {\r\n          System.out.println(\"无法购票\");\r\n          return;\r\n        }\r\n        showMoviesInfo(allMovies);\r\n\r\n        Movie selectMovie;\r\n\r\n        int index;\r\n        while (true) {\r\n          try {\r\n            System.out.println(\"请输入要购买的影片序号：\");\r\n            index = Integer.valueOf(SCANNER.nextLine());\r\n            if (0 <= index && index < allMovies.size()) {\r\n              selectMovie = allMovies.get(index);\r\n              break;\r\n            }\r\n          } catch (Exception e) {\r\n            System.out.println(\"输入数字不合法，请重试\");\r\n          }\r\n        }\r\n\r\n        int ticketNum;\r\n        System.out.println(\"请输入要购买的张数：\");\r\n        while (true) {\r\n          ticketNum = Integer.valueOf(SCANNER.nextLine());\r\n          if (0 < ticketNum && index <= selectMovie.getRestTicket()) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        // 创建订单\r\n        Order order = new Order(\r\n          customer.getUserName(),\r\n          selectMovie.getPiblisherUserName(),\r\n          selectMovie.getMovieBirthHash_id(),\r\n          selectMovie.getMovieName(),\r\n          ticketNum,\r\n          selectMovie.getPrice()\r\n        );\r\n        printLineWithTitle(\"订单信息\");\r\n        System.out.println(\"影片名称：\" + order.getMovieName());\r\n        System.out.println(\"票价：\" + order.getTicketPrice());\r\n        System.out.println(\"购票数量：\" + order.getTicketNum());\r\n        System.out.println(\"购票总价：\" + order.getTotalPrice());\r\n        System.out.println(\"购票方用户名：\" + order.getCustomUserName());\r\n        System.out.println(\"账户余额：\" + customer.getMoney());\r\n\r\n        System.out.println(\"是否确认订单(y/n)：\");\r\n        String operator = SCANNER.nextLine();\r\n\r\n        printLine();\r\n\r\n        if (operator == \"n\") {\r\n          System.out.println(\"订单取消成功\");\r\n          break;\r\n        }\r\n        if (customer.getMoney() < order.getTotalPrice()) {\r\n          System.out.println(\"购票失败,账户余额不足。\");\r\n          break;\r\n        }\r\n        if (selectMovie.getRestTicket() < order.getTicketNum()) {\r\n          System.out.println(\"购票失败,余票不足。\");\r\n          break;\r\n        }\r\n\r\n        User business = USERS_DB.get(order.getBusinessUserName());\r\n        business.getOrders().add(order);\r\n        business.setMoney(business.getMoney() + order.getTotalPrice());\r\n\r\n        customer.getOrders().add(order);\r\n        customer.setMoney(customer.getMoney() - order.getTotalPrice());\r\n\r\n        selectMovie.setSaledTicket(\r\n          selectMovie.getSaledTicket() + order.getTicketNum()\r\n        );\r\n\r\n        System.out.println(\"购票成功!\");\r\n        break;\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入字段不合法，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static void regUser(boolean isBusiness) {\r\n    while (true) {\r\n      try {\r\n        if (isBusiness) {\r\n          System.out.println(\r\n            \"----------------------------商家注册----------------------------\"\r\n          );\r\n        } else {\r\n          System.out.println(\r\n            \"----------------------------顾客注册----------------------------\"\r\n          );\r\n        }\r\n\r\n        String userName = \"\";\r\n        while (true) {\r\n          System.out.println(\"请输入用户名:\");\r\n          userName = SCANNER.nextLine();\r\n          if (userName.length() < 4) {\r\n            System.out.println(\"用户名过短,请重新输入！！！\");\r\n          } else if (isRegistered(userName)) { // 检查用户名是否已被注册\r\n            System.out.println(\"用户名已被注册,请重新输入！！！\");\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        String passwd = \"\";\r\n        String checkpasswd = \"\";\r\n        while (true) {\r\n          System.out.println(\"请输入密码:\");\r\n          passwd = SCANNER.nextLine();\r\n          System.out.println(\"请输入确认密码:\");\r\n          checkpasswd = SCANNER.nextLine();\r\n          if (!passwd.equals(checkpasswd)) {\r\n            System.out.println(\"两次输入密码不一致，请重新输入。\");\r\n            continue;\r\n          }\r\n          if (passwd.length() < 6) {\r\n            System.out.println(\"密码不得小于6位，请重新输入。\");\r\n            continue;\r\n          }\r\n          break;\r\n        }\r\n\r\n        String name = \"\";\r\n        while (true) {\r\n          printLine();\r\n          System.out.println(\"请输入真实姓名:\");\r\n          name = SCANNER.nextLine();\r\n          if (name.length() == 0) {\r\n            System.out.println(\"姓名不得为空，请重新输入.\");\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        char sex = '男';\r\n        while (true) {\r\n          printLine();\r\n          System.out.println(\"请输入性别:\");\r\n          String sex_str = SCANNER.nextLine();\r\n          if ((sex_str != \"男\" && sex_str != \"女\")) {\r\n            System.out.println(\"性别字段不合法,请重新输入！！！\");\r\n          } else {\r\n            sex = sex_str.charAt(0);\r\n            break;\r\n          }\r\n        }\r\n\r\n        String telNum = \"\";\r\n        while (true) {\r\n          printLine();\r\n          System.out.println(\"请输入手机号:\");\r\n          telNum = SCANNER.nextLine();\r\n          if (!telNum.matches(\"[\\\\d]{5,15}\")) {\r\n            System.out.println(\"请输入合法手机号。\");\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n\r\n        // System.out.println(\"请输入账户余额:\");\r\n        double money = 0;\r\n\r\n        if (isBusiness) { // 商家注册\r\n          String companyName = \"\";\r\n          while (true) {\r\n            printLine();\r\n            System.out.println(\"请输入公司名称:\");\r\n            companyName = SCANNER.nextLine();\r\n            if (companyName.length() == 0) {\r\n              System.out.println(\"公司名称不能为空，请重新输入。\");\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n          String companyAddress = \"\";\r\n          while (true) {\r\n            printLine();\r\n            System.out.println(\"请输入公司地址:\");\r\n            companyAddress = SCANNER.nextLine();\r\n            if (companyAddress.length() == 0) {\r\n              System.out.println(\"公司地址不能为空，请重新输入。\");\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n          USERS_DB.put(\r\n            userName,\r\n            new Business(\r\n              userName,\r\n              name,\r\n              sex,\r\n              passwd,\r\n              telNum,\r\n              money,\r\n              companyName,\r\n              companyAddress\r\n            )\r\n          );\r\n          MOVIESINFO_DB.put(userName, new LinkedList());\r\n        } else { // 顾客注册\r\n          USERS_DB.put(\r\n            userName,\r\n            new Customer(userName, name, sex, passwd, telNum, money)\r\n          );\r\n        }\r\n        printLine();\r\n        System.out.println(\"注册成功！！！\");\r\n        break;\r\n      } catch (Exception e) {\r\n        printLine();\r\n        System.out.println(\"检测到不合法输入，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static boolean isRegistered(String userName) { // 检测用户名是否已注册\r\n    return USERS_DB.containsKey(userName);\r\n  }\r\n}\r\n\r\nclass User {\r\n\r\n  String userName;\r\n  String passwd;\r\n  String name; // 真实姓名\r\n  char sex;\r\n  String telNum; // 手机号\r\n  double money; // 账户余额\r\n  List<Order> orders = new LinkedList<>();\r\n\r\n  public User(\r\n    String userName,\r\n    String name,\r\n    char sex,\r\n    String passwd,\r\n    String telNum,\r\n    double money\r\n  ) {\r\n    this.userName = userName;\r\n    this.name = name;\r\n    this.sex = sex;\r\n    this.passwd = passwd;\r\n    this.telNum = telNum;\r\n    this.money = money;\r\n  }\r\n\r\n  @Override\r\n  public boolean equals(Object o) { // 根据用户名判断是否为同一用户\r\n    if (this == o) return true;\r\n    if (o == null || !(o instanceof User)) return false; // o不能为空，o需为User类或其子类\r\n    User user = (User) o;\r\n    return Objects.equals(userName, user.userName);\r\n  }\r\n\r\n  @Override\r\n  public int hashCode() { // 根据用户名计算hash\r\n    return Objects.hash(userName);\r\n  }\r\n\r\n  public List<Order> getOrders() {\r\n    return orders;\r\n  }\r\n\r\n  public String getUserName() {\r\n    return userName;\r\n  }\r\n\r\n  public void setUserName(String userName) {\r\n    this.userName = userName;\r\n  }\r\n\r\n  public String getName() {\r\n    return name;\r\n  }\r\n\r\n  public void setName(String name) {\r\n    this.name = name;\r\n  }\r\n\r\n  public char getSex() {\r\n    return sex;\r\n  }\r\n\r\n  public void setSex(char sex) {\r\n    this.sex = sex;\r\n  }\r\n\r\n  public String getPasswd() {\r\n    return passwd;\r\n  }\r\n\r\n  public void setPasswd(String passwd) {\r\n    this.passwd = passwd;\r\n  }\r\n\r\n  public String getTelNum() {\r\n    return telNum;\r\n  }\r\n\r\n  public void setTelNum(String telNum) {\r\n    this.telNum = telNum;\r\n  }\r\n\r\n  public double getMoney() {\r\n    return BigDecimal\r\n      .valueOf(money)\r\n      .setScale(2, RoundingMode.HALF_UP)\r\n      .doubleValue();\r\n  }\r\n\r\n  public void setMoney(double money) {\r\n    this.money =\r\n      BigDecimal.valueOf(money).setScale(2, RoundingMode.HALF_UP).doubleValue();\r\n  }\r\n}\r\n\r\nclass Business extends User {\r\n\r\n  String companyName; // 公司名\r\n  String companyAddress; // 公司地址\r\n\r\n  Business(\r\n    String userName,\r\n    String name,\r\n    char sex,\r\n    String passwd,\r\n    String telNum,\r\n    double money,\r\n    String companyName,\r\n    String companyAddress\r\n  ) {\r\n    super(userName, name, sex, passwd, telNum, money);\r\n    this.companyName = companyName;\r\n    this.companyAddress = companyAddress;\r\n  }\r\n\r\n  public String getCompanyName() {\r\n    return companyName;\r\n  }\r\n\r\n  public void setCompanyName(String companyName) {\r\n    this.companyName = companyName;\r\n  }\r\n\r\n  public String getCompanyAddress() {\r\n    return companyAddress;\r\n  }\r\n\r\n  public void setCompanyAddress(String companyAddress) {\r\n    this.companyAddress = companyAddress;\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return (\r\n      \"Business{\" +\r\n      \"companyName='\" +\r\n      companyName +\r\n      '\\'' +\r\n      \", companyAddress='\" +\r\n      companyAddress +\r\n      '\\'' +\r\n      \", userName='\" +\r\n      userName +\r\n      '\\'' +\r\n      \", passwd='\" +\r\n      passwd +\r\n      '\\'' +\r\n      \", name='\" +\r\n      name +\r\n      '\\'' +\r\n      \", sex=\" +\r\n      sex +\r\n      \", telNum='\" +\r\n      telNum +\r\n      '\\'' +\r\n      \", money=\" +\r\n      money +\r\n      '}'\r\n    );\r\n  }\r\n}\r\n\r\nclass Customer extends User {\r\n\r\n  public Customer(\r\n    String userName,\r\n    String name,\r\n    char sex,\r\n    String passwd,\r\n    String telNum,\r\n    double money\r\n  ) {\r\n    super(userName, name, sex, passwd, telNum, money);\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return (\r\n      \"Customer{\" +\r\n      \"userName='\" +\r\n      userName +\r\n      '\\'' +\r\n      \", passwd='\" +\r\n      passwd +\r\n      '\\'' +\r\n      \", name='\" +\r\n      name +\r\n      '\\'' +\r\n      \", sex=\" +\r\n      sex +\r\n      \", telNum='\" +\r\n      telNum +\r\n      '\\'' +\r\n      \", money=\" +\r\n      money +\r\n      '}'\r\n    );\r\n  }\r\n}\r\n\r\nclass Movie {\r\n\r\n  String movieName;\r\n  String[] actors;\r\n  double score = 5.0;\r\n  int timeLong; // 时长\r\n  double price; // 价格\r\n  int totalTicket; // 总票数\r\n  int saledTicket = 0; // 卖出票数\r\n  Date beOn;\r\n  String piblisherUserName; //发布者用户名\r\n\r\n  String movieBirthHash;\r\n\r\n  {\r\n    movieBirthHash = Integer.toString(Objects.hash(Instant.now().toString()));\r\n  }\r\n\r\n  public Movie(\r\n    String movieName,\r\n    String[] actors,\r\n    int timeLong,\r\n    double price,\r\n    int totalTicket,\r\n    Date beOn,\r\n    String piblisherUserName\r\n  ) {\r\n    this.movieName = movieName;\r\n    this.actors = actors;\r\n    this.timeLong = timeLong;\r\n    this.price = price;\r\n    this.totalTicket = totalTicket;\r\n    this.beOn = beOn;\r\n    this.piblisherUserName = piblisherUserName;\r\n  }\r\n\r\n  public String getMovieBirthHash_id() {\r\n    return movieBirthHash;\r\n  }\r\n\r\n  public int getRestTicket() {\r\n    return totalTicket - saledTicket;\r\n  }\r\n\r\n  public String getPiblisherUserName() {\r\n    return piblisherUserName;\r\n  }\r\n\r\n  public int getSaledTicket() {\r\n    return saledTicket;\r\n  }\r\n\r\n  public void setSaledTicket(int saledTicket) {\r\n    this.saledTicket = saledTicket;\r\n  }\r\n\r\n  public Date getBeOn() {\r\n    return beOn;\r\n  }\r\n\r\n  public void setBeOn(Date beOn) {\r\n    this.beOn = beOn;\r\n  }\r\n\r\n  public String getMovieName() {\r\n    return movieName;\r\n  }\r\n\r\n  public void setMovieName(String movieName) {\r\n    this.movieName = movieName;\r\n  }\r\n\r\n  public String[] getActors() {\r\n    return actors;\r\n  }\r\n\r\n  public String getActorsToStr() {\r\n    StringBuilder sb = new StringBuilder();\r\n    for (String name : actors) {\r\n      sb.append(name);\r\n      sb.append(\" \");\r\n    }\r\n    return sb.toString();\r\n  }\r\n\r\n  public void setActors(String[] actors) {\r\n    this.actors = actors;\r\n  }\r\n\r\n  public double getScore() {\r\n    return BigDecimal\r\n      .valueOf(score)\r\n      .round(new MathContext(3, RoundingMode.HALF_UP))\r\n      .doubleValue();\r\n  }\r\n\r\n  public void setScore(double score) {\r\n    this.score = normalizScore(score);\r\n  }\r\n\r\n  private double normalizScore(double score) {\r\n    return score >= 10 ? 10 : score <= 0 ? 0 : score;\r\n  }\r\n\r\n  public void evaluateScore(double customScore) {\r\n    customScore = normalizScore(customScore);\r\n    double newScore = score + (customScore - score) * 0.001;\r\n    setScore(newScore);\r\n  }\r\n\r\n  public int getTimeLong() {\r\n    return timeLong;\r\n  }\r\n\r\n  public void setTimeLong(int timeLong) {\r\n    this.timeLong = timeLong;\r\n  }\r\n\r\n  public double getPrice() {\r\n    return price;\r\n  }\r\n\r\n  public void setPrice(double price) {\r\n    this.price = price;\r\n  }\r\n\r\n  public int getTotalTicket() {\r\n    return totalTicket;\r\n  }\r\n\r\n  public void setTotalTicket(int totalTicket) {\r\n    this.totalTicket = totalTicket;\r\n  }\r\n\r\n  public static String genMovieName(Scanner SCANNER) {\r\n    String movieName;\r\n    while (true) {\r\n      System.out.println(\"请输入影片名：\");\r\n      movieName = SCANNER.nextLine();\r\n      if (movieName.length() == 0) {\r\n        System.out.println(\"影片名不能为空,请重新输入。\");\r\n      } else {\r\n        return movieName;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static String[] genActors(Scanner SCANNER) {\r\n    String[] actors;\r\n    while (true) {\r\n      System.out.println(\"请输入主演名并以空格分隔\");\r\n      String names_str = SCANNER.nextLine();\r\n      if (names_str.length() == 0) {\r\n        System.out.println(\"主演名称不能为空，请重新输入。\");\r\n      } else {\r\n        actors = names_str.split(\"[\\\\s]\");\r\n        return actors;\r\n      }\r\n    }\r\n  }\r\n\r\n  public static int genTimeLong(Scanner SCANNER) {\r\n    int timeLong;\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入电影时长（分钟）:\");\r\n        timeLong = Integer.valueOf(SCANNER.nextLine());\r\n        if (timeLong < 0) {\r\n          System.out.println(\"时长不能为负，请重新输入。\");\r\n        } else {\r\n          return timeLong;\r\n        }\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入数据有误，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static double genPrice(Scanner SCANNER) {\r\n    double price;\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入电影票价:\");\r\n        price = Double.valueOf(SCANNER.nextLine());\r\n        if (price < 0) {\r\n          System.out.println(\"票价不能为负，请重新输入。\");\r\n        } else {\r\n          return price;\r\n        }\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入数据有误，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static int genTotalTicket(Scanner SCANNER) {\r\n    int totalTicket;\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入电影票总票数\");\r\n        totalTicket = Integer.valueOf(SCANNER.nextLine());\r\n        if (totalTicket <= 0) {\r\n          System.out.println(\"票数不能为负.不能为0，请重新输入。\");\r\n        } else {\r\n          return totalTicket;\r\n        }\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入数据有误，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n\r\n  public static Date genBeOn(Scanner SCANNER) {\r\n    Date beOn;\r\n    while (true) {\r\n      try {\r\n        System.out.println(\"请输入上映日期（格式：2022-12-15 23:30）：\");\r\n        beOn =\r\n          new SimpleDateFormat(\"yyyy-MM-dd hh:mm\").parse(SCANNER.nextLine());\r\n        return beOn;\r\n      } catch (Exception e) {\r\n        System.out.println(\"输入日期格式有误，请重新输入。\");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass Order {\r\n\r\n  String customUserName;\r\n  String businessUserName;\r\n  String movieId;\r\n  String movieName;\r\n  int ticketNum;\r\n  double ticketPrice;\r\n\r\n  public Order(\r\n    String customUserName,\r\n    String businessUserName,\r\n    String movieId,\r\n    String movieName,\r\n    int ticketNum,\r\n    double ticketPrice\r\n  ) {\r\n    this.customUserName = customUserName;\r\n    this.businessUserName = businessUserName;\r\n    this.movieId = movieId;\r\n    this.movieName = movieName;\r\n    this.ticketNum = ticketNum;\r\n    this.ticketPrice = ticketPrice;\r\n  }\r\n\r\n  public double getTotalPrice() {\r\n    return BigDecimal\r\n      .valueOf(\r\n        BigDecimal\r\n          .valueOf(ticketPrice)\r\n          .multiply(BigDecimal.valueOf(ticketNum))\r\n          .doubleValue()\r\n      )\r\n      .doubleValue();\r\n  }\r\n\r\n  public void setCustomUserName(String customUserName) {\r\n    this.customUserName = customUserName;\r\n  }\r\n\r\n  public String getCustomUserName() {\r\n    return customUserName;\r\n  }\r\n\r\n  public String getBusinessUserName() {\r\n    return businessUserName;\r\n  }\r\n\r\n  public void setBusinessUserName(String businessUserName) {\r\n    this.businessUserName = businessUserName;\r\n  }\r\n\r\n  public String getMovieId() {\r\n    return movieId;\r\n  }\r\n\r\n  public void setMovieId(String movieId) {\r\n    this.movieId = movieId;\r\n  }\r\n\r\n  public String getMovieName() {\r\n    return movieName;\r\n  }\r\n\r\n  public void setMovieName(String movieName) {\r\n    this.movieName = movieName;\r\n  }\r\n\r\n  public int getTicketNum() {\r\n    return ticketNum;\r\n  }\r\n\r\n  public void setTicketNum(int ticketNum) {\r\n    this.ticketNum = ticketNum;\r\n  }\r\n\r\n  public double getTicketPrice() {\r\n    return ticketPrice;\r\n  }\r\n\r\n  public void setTicketPrice(double ticketPrice) {\r\n    this.ticketPrice = ticketPrice;\r\n  }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n\r\n**使用测试**\r\n\r\n![](./images/java学习笔记/2022-10-31-14-21-14.png)\r\n![](./images/java学习笔记/2022-10-31-14-21-45.png)\r\n![](./images/java学习笔记/2022-10-31-14-22-55.png)\r\n![](./images/java学习笔记/2022-10-31-14-23-48.png)\r\n![](./images/java学习笔记/2022-10-31-14-24-29.png)\r\n![](./images/java学习笔记/2022-10-31-14-25-30.png)\r\n![](./images/java学习笔记/2022-10-31-14-26-03.png)\r\n![](./images/java学习笔记/2022-10-31-14-26-28.png)\r\n![](./images/java学习笔记/2022-10-31-14-26-47.png)\r\n![](./images/java学习笔记/2022-10-31-14-28-40.png)\r\n![](./images/java学习笔记/2022-10-31-14-28-59.png)\r\n![](./images/java学习笔记/2022-10-31-14-29-48.png)\r\n\r\n[源代码](./upload/javaDemo_movie.java)\r\n\r\n\r\n## 字符集编码解码\r\n**String编码**\r\n| 方法名称                            | 说明                                                                    |\r\n| ----------------------------------- | ----------------------------------------------------------------------- |\r\n| byte[] getBytes()                   | 使用平台的默认字符集将该String编码为一系列字节， 将结果存储到新的字节数 | 组中 |\r\n| byte[] getBytes(String charsetName) | 使用指定的字符集将该String编码为一系列字节， 将结果存储到新的字节数组中 |\r\n\r\n**String解码**\r\n| String的构造器                                  | 说明                                                       |\r\n| ----------------------------------------------- | ---------------------------------------------------------- |\r\n| String(byte[] bytes)                            | 通过使用平台的默认字符集解码指定的字节数组来构造新的String |\r\n| String String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来构造新的String         |\r\n\r\n\r\n\r\n**编解码测试**\r\n```java\r\nimport java.util.Arrays;\r\n\r\npublic class File_test {\r\n    public static void main(String[] args) throws Exception {\r\n        //编码\r\n        String str = \"123abc中文\";\r\n        byte[] default_encode_str = str.getBytes();//以平台默认的字符集编码\r\n        byte[] GBK_encode_str = str.getBytes(\"GBK\");//以GBK编码\r\n\r\n        System.out.println(default_encode_str.length);// 10\r\n        System.out.println(Arrays.toString(default_encode_str));//[49, 50, 51, 97, 98, 99, -42, -48, -50, -60]\r\n        System.out.println(GBK_encode_str.length);// 10\r\n        System.out.println(Arrays.toString(GBK_encode_str));//[49, 50, 51, 97, 98, 99, -42, -48, -50, -60]\r\n\r\n        //解码\r\n        String defString = new String(default_encode_str);//以平台默认的字符集解码\r\n        String gBKString = new String(GBK_encode_str,\"GBK\");//以GBK解码\r\n\r\n        System.out.println(defString);// 123abc中文\r\n        System.out.println(gBKString);// 123abc中文\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## File文件\r\n**概述**\r\n* File类用于根据文件的**绝对路径**或**相对路径**打开文件\r\n* **File类不能读写文件内容**\r\n* **读写文件需要使用IO流**\r\n\r\n### 构造器\r\n| 函数名                               | 使用案例                                                 |\r\n| ------------------------------------ | -------------------------------------------------------- |\r\n| File(File parent, String \"相对路径\") | File(new File(\"父文件夹路径\"), String \"相对路径\")        |\r\n| File(String pathname)                | `File(\".\\\\images\\\\123.jpg\")`  `File(\"./images/123.jpg\")` |\r\n| File(String parent, String child)    |\r\n| File(URI uri)                        |\r\n\r\n**注意**：\r\n* **File可以是文件可以是文件夹**\r\n* **传入的路径可以不存在，可以用exists()判断是否存在**\r\n\r\n\r\n### 常用方法\r\n| 方法名称                        | 说明                                       |\r\n| ------------------------------- | ------------------------------------------ |\r\n| public boolean isDirectory( )   | 测试此抽象路径名表示的File是否为文件夹     |\r\n| public boolean isFile()         | 测试此抽象路径名表示的File是否为文件       |\r\n| public boolean exists()         | 测试此抽象路径名表示的File是否存在         |\r\n| public String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串         |\r\n| public String getPath()         | 将此抽象路径名转换为路径名字符串           |\r\n| public String getName()         | 返回由此抽象路径名表示的文件或文件夹的名称 |\r\n| public long lastModified()      | 返回文件最后修改的时间毫秒值               |\r\n\r\n**File类创建文件的功能**\r\n| 方法名称                        | 说明                 |\r\n| ------------------------------- | -------------------- |\r\n| public boolean createNewFile( ) | 创建一个新的空的文件 |\r\n| public boolean mkdir( )         | 只能创建一级文件夹   |\r\n| public boolean mkdirs()         | 可以创建多级文件夹   |\r\n\r\n**File类删除文件的功能**\r\n| 方法名称                | 说明                                         |\r\n| ----------------------- | -------------------------------------------- |\r\n| public boolean delete() | 删除由此抽象路径名表示的文件或空文件夹(默认) |\r\n\r\n\r\n**File类的遍历功能**\r\n| 方法名称                        | 说明                                                                                                                                     |\r\n| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |\r\n| public String[] list()          | 获取当前目录下所有的\"一级文件名称\"到一个字符串数组中去返回。                                                                             |\r\n| public File[] listFiles()(常用) | 获取当前目录下所有的\"一级文件对象\"到一个文件对象数组中去返回(重点,若调用者不存在或者是文件则函数返回null，调用者是空文件夹则返回长度为0) |\r\n\r\n\r\n**递归遍历查找指定文件夹下的文件名**\r\n```java\r\npublic class File_test {\r\n    public static void main(String[] args) {\r\n        searchFireName(new File(\"./com\"),\"Student\");\r\n    }\r\n    public static void searchFireName(File father,String fileName){\r\n        if(father==null || father.isFile())\r\n            return;\r\n        for (File file : father.listFiles()) {\r\n            if(file.isFile() && file.getName().contains(fileName))\r\n                System.out.println(file.getAbsolutePath());\r\n            if(file.isDirectory())\r\n                searchFireName(file, fileName);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 流\r\n\r\n流的种类\r\n* 基础IO流\r\n* 缓冲流\r\n* 转换流\r\n* 打印流\r\n\r\n### 基础IO流\r\n**IO流的概念**\r\n* I: input,输入，将数据读取到内存\r\n* O: output,输出，将数据写入到磁盘\r\n\r\n**IO流分类**\r\n* 按流的方向\r\n  * 输入流\r\n  * 输出流\r\n* 按流的内容\r\n  * 字节流，读写数据，图片，视频，音乐\r\n  * 字符流，读写文本\r\n* 按读写性能\r\n  * 基础流\r\n  * 缓冲流\r\n\r\n\r\n**IO流体系图**\r\n![](./images/java学习笔记/2022-11-01-10-24-41.png)\r\n\r\n#### FileInputStream\r\n\r\n| 构造器                                  | 说明                               |\r\n| --------------------------------------- | ---------------------------------- |\r\n| public FileInputStream(File file)       | 创建字节输入流管道与源文件对象接通 |\r\n| public FilelnputStream(String pathname) | 创建字节输入流管道与源文件路径接通 |\r\n\r\n\r\n| 方法名称                       | 说明                                                                       |\r\n| ------------------------------ | -------------------------------------------------------------------------- |\r\n| public int read()              | 每次读取一个字节,返回读取到的字节的值，如果字节已经没有可读的返回-1        |\r\n| public int read(byte[] buffer) | 每次读取一个字节数组，返回读取到的字节的长度，如果字节已经没有可读的返回-1 |\r\n\r\n\r\n```java\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\n\r\npublic class File_test {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建输入流\r\n        InputStream inStream = new FileInputStream(new File(\"./File_test.java\"));\r\n\r\n        //一次读取1字节\r\n        byte bt;\r\n        while((bt = (byte)inStream.read())!=-1){ // 如果用来读取字符文件，无法避免中文乱码\r\n            System.out.print((char)bt);\r\n        }\r\n\r\n        byte[] buffer = new byte[1024];//一次读取1kB     \r\n        int length;\r\n        while((length = inStream.read(buffer))!=-1){// 如果用来读取字符文件，无法避免中文乱码\r\n            System.out.print(new String(buffer,0,length));\r\n        }\r\n\r\n        byte[] buffer =inStream.readAllBytes();//一次读取全部（实际调用了 readNBytes(Integer.MAX_VALUE) 只能读取Integer.MAX_VALUE个字节）\r\n        System.out.println(new String(buffer,\"UTF-8\"));\r\n    }\r\n}\r\n```\r\n\r\n#### FileOutputStream\r\n| 构造器                                                   | 说明                                               |\r\n| -------------------------------------------------------- | -------------------------------------------------- |\r\n| public FileOutputStream(File file)                       | 创建字节输出流管道与源文件对象接通                 |\r\n| public FileOutputStream(File file, boolean append)       | 创建字节输出流管道与源文件对象接通，可**追加**数据 |\r\n| public FileOutputStream(String filepath)                 | 创建字节输出流管道与源文件路径接通                 |\r\n| public FileOutputStream(String filepath, boolean append) | 创建字节输出流管道与源文件路径接通，可**追加**数据 |\r\n\r\n| 方法名称                                            | 说明                         |\r\n| --------------------------------------------------- | ---------------------------- |\r\n| public void write(int a)                            | 写一个字节出去               |\r\n| public void write(byte[] buffer)                    | 写一个字节数组出去           |\r\n| public void write(byte[] buffer ，int pos，int len) | 写一个字节数组的一部分出去。 |\r\n| flush()                                             | 写入                         |\r\n| close()                                             | 关闭                         |\r\n\r\n\r\n\r\n\r\n\r\n**构造器、方法测试**\r\n```java\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStream;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建输入流\r\n        OutputStream os = new FileOutputStream(new File(\"./123.java\"));\r\n        os.write('a');\r\n        os.write('b');\r\n        os.write('c');\r\n        os.write(\"中文字符串\".getBytes(\"UTF-8\"));//写入 byte[] :  \"中文字符串\"\r\n        os.write(\"\\r\\n\".getBytes());//换行\r\n        os.write(\"中文字符串\".getBytes(\"UTF-8\"),3,6);//写入 byte[] 的部分 : \"文字\"\r\n        os.flush();//写入\r\n        os.close();//关闭流（包含flush）\r\n    }\r\n}\r\n```\r\n\r\n**文件拷贝**\r\n```java\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        OutputStream os = new FileOutputStream(new File(\"./123.java\"));//文件输出流\r\n        InputStream is = new FileInputStream(new File(\"./Main.java\"));//文件输出流\r\n\r\n        byte[] buffer = new byte[1024];\r\n        int length = 0 ;//用于记录每次读取的字节长度\r\n        while((length = is.read(buffer))!=-1){\r\n            os.write(buffer,0,length);\r\n        }\r\n        os.close();\r\n        is.close();\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### FileReader\r\n\r\n| 构造器                             | 说明                               |\r\n| ---------------------------------- | ---------------------------------- |\r\n| public FileReader(File file)       | 创建字符输入流管道与源文件对象接通 |\r\n| public FileReader(String pathname) | 创建字符输入流管道与源文件路径接通 |\r\n\r\n| 方法名称                      | 说明                                                                   |\r\n| ----------------------------- | ---------------------------------------------------------------------- |\r\n| public int read()             | 每次读取一个字符返回，如果字符已经没有可读的返回-1                     |\r\n| public int read(char[ buffer) | 每次读取一个字符数组，返回读取的字符个数，如果字符已经没有可读的返回-1 |\r\n\r\n\r\n**测试**\r\n```java\r\nimport java.io.FileReader;\r\nimport java.io.Reader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Reader  read = new FileReader(\"./Main.java\");\r\n        int ch;\r\n        while((ch=read.read())!=-1){\r\n            System.out.print((char)ch);//一次获取一个字符，无论其实际在文件中到底占几个字节\r\n        }\r\n        read.close();\r\n    }\r\n}\r\n```\r\n\r\n#### FileWriter\r\n\r\n| 构造器                             | 说明                               |\r\n| public FileWriter(String filepath, boolean append) | 道与源文件路径接通，可追加数据 |\r\n\r\n\r\n| 方法名称                                  | 说明                 |\r\n| ----------------------------------------- | -------------------- |\r\n| void write(int c)                         | 写一个字符           |\r\n| void write(char[] cbuf)                   | 写入一个字符数组     |\r\n| void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 |\r\n| void write(String str)                    | 写一个字符串         |\r\n| void write(\"\\r\\n\")                        | 写一个字符           |\r\n| void write(String str, int off, int len)  | 写一个字符串的一部分 |\r\n| void write(int c)                         | 写一个字符           |\r\n| flush()                                   | 写入                 |\r\n| close()                                   | 关闭                 |\r\n\r\n\r\n\r\n### 缓冲IO流\r\n* 缓冲流也称高效流，高级流\r\n* 缓冲流就是将基础流包装了一层\r\n* 缓冲流**自带缓冲区（长度8192，8kB,2000H），可以提高原始字节流、字符流读写数据的性能**\r\n\r\n![](./images/java学习笔记/2022-11-01-20-58-44.png)\r\n\r\n#### 缓冲文件流 BufferedOutputStream BufferedInputStream\r\n\r\n**复制文件**\r\n```java\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStream;\r\nimport java.io.OutputStream;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        OutputStream os = new FileOutputStream(new File(\"./123.java\"));//文件输出流\r\n        InputStream is = new FileInputStream(new File(\"./Main.java\"));//文件输出流\r\n\r\n        OutputStream fuffered_os = new BufferedOutputStream(os);//文件输出流\r\n        InputStream buffered_is = new BufferedInputStream(is);//文件输出流\r\n\r\n        byte[] buffer = new byte[1024];\r\n        int length = 0 ;//用于记录每次读取的字节长度\r\n        while((length = buffered_is.read(buffer))!=-1){\r\n            fuffered_os.write(buffer,0,length);\r\n        }\r\n        fuffered_os.close();\r\n        buffered_is.close();\r\n    }\r\n}\r\n```\r\n\r\n\r\n#### 缓冲字符流 BufferedReader BufferedWriter\r\n\r\n**BufferedReader**\r\n| BufferedReader构造器           | 说明                                                                                       |\r\n| ------------------------------ | ------------------------------------------------------------------------------------------ |\r\n| public String BufferedReader() | 可以把低级的字符读取流包装成-一个高级的缓 冲字符读取流管道，从而提高字符读取流写数据的性能 |\r\n\r\n\r\n| BufferedReader方法         | 说明                  |\r\n| -------------------------- | --------------------- |\r\n| `public String readLine()` | Reads a line of text. |\r\n\r\n**BufferedWriter**\r\n| BufferedWriter构造器            | 说明                                                                                       |\r\n| ------------------------------- | ------------------------------------------------------------------------------------------ |\r\n| public BufferedWriter(Writer w) | 可以把低级的字符输出流包装成-一个高级的缓 冲字符输出流管道，从而提高字符输出流写数据的性能 |\r\n\r\n\r\n| BufferedWriter方法      | 说明     |\r\n| ----------------------- | -------- |\r\n| `public void newline()` | 换行操作 |\r\n\r\n\r\n\r\n**测试**\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.Reader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Reader  read = new FileReader(\"./Main.java\",java.nio.charset.Charset.forName(\"UTF-8\"));\r\n        Reader  read_bf = new BufferedReader(read);\r\n\r\n        char[] buffer = new char[1024];\r\n        int length = 0 ;//用于记录每次读取的字节长度\r\n        while((length = read_bf.read(buffer))!=-1){\r\n            System.out.println(String.copyValueOf(buffer, 0, length));\r\n        }\r\n        read_bf.close();\r\n    }\r\n}\r\n```\r\n\r\n**独有方法测试**\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.Reader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Reader  read = new FileReader(\"./Main.java\",java.nio.charset.Charset.forName(\"UTF-8\"));\r\n        BufferedReader  read_bf = new BufferedReader(read);\r\n\r\n        String line;\r\n        while((line = read_bf.readLine())!=null){// 独有方法，读取一行\r\n            System.out.println(line);\r\n        }\r\n        read_bf.close();\r\n    }\r\n}\r\n```\r\n\r\n#### 字符输入/输出转换流\r\n![](./images/java学习笔记/2022-11-02-00-18-50.png)\r\n\r\n| 构造器                                                     | 说明                                                                                   |\r\n| ---------------------------------------------------------- | -------------------------------------------------------------------------------------- |\r\n| public InputStreamReader(InputStream is)                   | 可以把原始的字节流按照代码默认编码转换成字符输入流。几乎不用，与默认的FileReader一样。 |\r\n| `public InputStreamReader(InputStream is，String charset)` | 可以把原始的字节流**按照指定编码转换成字符输入流**，这样字符流中的字符就不乱码了(重点) |\r\n\r\n| 构造器                                                       | 说明                                                               |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------------ |\r\n| public OutputStreamWriter(OutputStream os)                   | 可以把原始的字节输出流按照代码默认编码转换成字符输出流。几乎不用。 |\r\n| `public OutputStreamWriter(OutputStream os, String charset)` | 可以把原始的字节输出流**按照指定编码转换成字符输出流**(重点)       |\r\n\r\n**综合案例：用指定编码读写文件**\r\n```java\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Writer;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 用UTF-8编码读取并解析文件\r\n        // 用GBK编码写入文件\r\n        Reader file1 = new InputStreamReader(new BufferedInputStream(new FileInputStream(\"./Main.java\")),\"UTF-8\");\r\n        Writer file2 = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(\"./123.txt\")),\"GBK\");\r\n\r\n        char[] buffer = new char[1024];\r\n        int length = 0;\r\n        while((length = file1.read(buffer)) != -1){\r\n            file2.write(buffer, 0, length);\r\n        }\r\n\r\n        file1.close();\r\n        file2.close();\r\n    }\r\n}\r\n```\r\n\r\n### 对象序列化(对象字节输出流)\r\n* 简单来说，就是把java中的通过关键字 `new` 创建的对象保存到硬盘上。\r\n* 作用:以内存为基准，把内存中的对象存储到磁盘文件中去,称为对象序列化。\r\n* 使用到的流是对象字节输出流: ObjectOutputStream\r\n* <green> 把一个对象写入到文件中，该对象必须实现了序列化接口`Serializable` </green>\r\n  * 其中实现类中`static final long serialVersionUID`用于指定在反序列化是的版本标记\r\n\r\n![](./images/java学习笔记/2022-11-02-01-02-58.png)\r\n\r\n**测试**\r\n```java\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.InputStream;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.util.LinkedList;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建一个java对象，写入到文件\r\n        ObjectOutputStream file1 = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(\"./123.temp\")));\r\n        file1.writeObject(new LinkedList<>());;\r\n        file1.close();\r\n\r\n        //从文件读取写入的java对象\r\n        ObjectInputStream  file2 = new ObjectInputStream(new BufferedInputStream(new FileInputStream(\"./123.temp\")));\r\n        LinkedList  list =  (LinkedList)file2.readObject();\r\n        file2.close();\r\n\r\n        System.out.println(list.size());\r\n    }\r\n}\r\n```\r\n\r\n### 打印流\r\n打印流\r\n* 作用:打印流可以实现方便、高效的打印数据到文件中去。打印流一般是指: PrintStream, PrintWriter两个类。\r\n* 可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97,打印boolean的true，写出去就是true。\r\n\r\n![](./images/java学习笔记/2022-11-02-01-29-14.png)\r\n\r\n**`PrintStream`和`PrintWriter`的区别**\r\n* 打印数据功能上是一模一样的，都是使用方便，性能高效(核心优势)\r\n* PrintStream继承自字节输出流OutputStream, 支持写**字节数据**的方法。\r\n* PrintWriter继承自字符输出流Writer, 支持写**字符数据**出去。\r\n\r\n\r\n\r\n**PrintStream**\r\n| 构造器                                     | 说明                                 |\r\n| ------------------------------------------ | ------------------------------------ |\r\n| public PrintStream( OutputStream os)       | 打印流直接通向字节输出流管道         |\r\n| public PrintStream(File f)                 | 打印流直接通向文件对象               |\r\n| public PrintStream(File f,Charset charset) | 打印流直接通向文件对象(以指定字符集) |\r\n| public PrintStream(String filepath)        | 打印流直接通向文件路径               |\r\n  \r\n| 方法                      | 说明                   |\r\n| ------------------------- | ---------------------- |\r\n| public void print(Xxx xx) | 打印任意类型的数据出去 |\r\n\r\n\r\n**PrintWriter**\r\n| 构造器                               | 说明                         |\r\n| ------------------------------------ | ---------------------------- |\r\n| public PrintWriter(OutputStream os ) | 打印流直接通向字节输出流管道 |\r\n| public PrintWriter (Writer w)        | 打印流直接通向字符输出流管道 |\r\n| public PrintWriter (File f)          | 打印流直接通向文件对象       |\r\n| public PrintWriter (String filepath) | 打印流直接通向文件路径       |\r\n\r\n\r\n| 方法                      | 说明                   |\r\n| ------------------------- | ---------------------- |\r\n| public void print(Xxx xX) | 打印任意类型的数据出去 |\r\n\r\n\r\n**两种打印流的使用**\r\n```java\r\nimport java.io.File;\r\nimport java.io.PrintStream;\r\nimport java.io.PrintWriter;\r\nimport java.nio.charset.Charset;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        PrintStream pStream = new PrintStream(new File(\"./123.txt\"),Charset.forName(\"GBK\"));\r\n        pStream.print(123);\r\n        pStream.print(123.123);\r\n        pStream.print(true);\r\n        pStream.print(\"1231212312312中文\");\r\n        pStream.print(new Object());\r\n        pStream.write(\"1231221312332\".getBytes());      //打印字节流的write只能写字节\r\n        pStream.close();\r\n\r\n        PrintWriter pWriter = new PrintWriter(new File(\"./123.txt\"),Charset.forName(\"GBK\"));\r\n        pWriter.print(123);\r\n        pWriter.print(123.123);\r\n        pWriter.print(true);\r\n        pWriter.print(\"1231212312312中文\");\r\n        pWriter.print(new Object());\r\n        pWriter.write(\"1231221312332\");         //打印字符流的write能写字节也能写字符\r\n        pWriter.close();\r\n    }\r\n}\r\n```\r\n\r\n**重定向控制台输出到打印流**\r\n```java\r\nimport java.io.File;\r\nimport java.io.PrintStream;\r\nimport java.nio.charset.Charset;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        PrintStream pStream = new PrintStream(new File(\"./123.txt\"),Charset.forName(\"GBK\"));\r\n        System.setOut(pStream);//重定向控制台输出到打印流\r\n\r\n        System.out.println(\"12312123\");\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Properties属性集对象\r\n\r\n**作用**\r\n* **Properties本质为一个Map集合，但其实际常用于配置文件的读取、写入操作**\r\n* Properties对象表示一个属性文件\r\n* 用于存储对象中的键值对信息到一个属性文件中\r\n* 属性文件：后缀为`.properties` 内容为`key=value`,用于做系统配置\r\n\r\n| 方法                                                | 说明                                                                                                |\r\n| --------------------------------------------------- | --------------------------------------------------------------------------------------------------- |\r\n| void load(InputStream inStream)                     | 从输入字节流读取属性列表(键和元素对)                                                                |\r\n| **void load(Reader reader)**                        | 从输入字符流读取属性列表(键和元素对)、                                                              |\r\n| void store(OutputStream out, String comments)       | 将此属性列表(键和元素对)写入此Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流 |\r\n| **void store(Writer writer, String comments )**     | 将此属性列表(键和元素对)写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流        |\r\n| public object setProperty(String key, String value) | 保存键值对(put)                                                                                     |\r\n| public String getProperty(String key)               | 使用此属性列表中指定的键搜索属性值(get)                                                             |\r\n| `public Set<String> stringPropertyNames()`          | 所有键的名称的集合(keySet())                                                                        |\r\n\r\n\r\n使用测试\r\n```java\r\nimport java.io.BufferedWriter;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.OutputStreamWriter;\r\nimport java.nio.charset.Charset;\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建\r\n        Properties properties = new Properties();\r\n        System.out.println(properties);\r\n\r\n        //写入\r\n        properties.setProperty(\"用户名\", \"admin\");\r\n        properties.setProperty(\"密码\", \"admin\");\r\n        properties.store(new FileWriter(\"./123.properties\",Charset.forName(\"UTF-8\")), \"注释\");\r\n\r\n        //加载\r\n        properties.load(new FileReader(\"./123.properties\",Charset.forName(\"UTF-8\")));\r\n        System.out.println(properties);\r\n        System.out.println(properties.getProperty(\"用户名\"));\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-02-17-21-50.png)\r\n\r\n\r\n### IO框架：commons-io\r\n**概述**\r\n* commons-io是apache开源基金组织提供的一组有关I0操作的类库，可以提高I0功能开发的效率。\r\n* commons-io工具包提供了很多有关io操作的类。有两个主要的类 `FileUtils` , `lOUtils`\r\n* \r\nFileUtils主要方法:\r\n| 方法名                                                   | 说明                         |\r\n| -------------------------------------------------------- | ---------------------------- |\r\n| String readFileToString(File file, String encoding)      | 读取文件中的数据，返回字符串 |\r\n| void copyFile(File srcFile, File destFile)               | 复制文件。                   |\r\n| void copyDirectoryToDirectory(File srcDir, File destDir) | 复制文件夹。                 |\r\n\r\n**测试**\r\n```java\r\nimport java.io.File;\r\nimport java.util.*;\r\n\r\nimport org.apache.commons.io.FileUtils;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //读取文件内容\r\n        String str = FileUtils.readFileToString(new File(\"./123.txt\"), \"UTF-8\");\r\n        System.out.println(str);\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 中文进制转十进制\r\n\r\n<details>\r\n<summary> <strong> 源代码 </strong> </summary>\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.Reader;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        String str = \"一千万零四十五\";\r\n        System.out.println(str);\r\n        System.out.println(HanToNum(str));\r\n    }\r\n\r\n    public static final Map<Character,Integer> HanNum_charset = new HashMap();\r\n    static{\r\n        HanNum_charset.put('零',0);\r\n        HanNum_charset.put('一',1);\r\n        HanNum_charset.put('二',2);\r\n        HanNum_charset.put('三',3);\r\n        HanNum_charset.put('四',4);\r\n        HanNum_charset.put('五',5);\r\n        HanNum_charset.put('六',6);\r\n        HanNum_charset.put('七',7);\r\n        HanNum_charset.put('八',8);\r\n        HanNum_charset.put('九',9);\r\n        HanNum_charset.put('十',10);\r\n\r\n        HanNum_charset.put('壹',1);\r\n        HanNum_charset.put('贰',2);\r\n        HanNum_charset.put('叁',3);\r\n        HanNum_charset.put('肆',4);\r\n        HanNum_charset.put('伍',5);\r\n        HanNum_charset.put('陆',6);\r\n        HanNum_charset.put('柒',7);\r\n        HanNum_charset.put('捌',8);\r\n        HanNum_charset.put('玖',9);\r\n        HanNum_charset.put('拾',10);\r\n    }\r\n    public static final Map<Character,Integer> HanNum_unit = new HashMap();\r\n    static{\r\n        HanNum_unit.put('十',10);\r\n        HanNum_unit.put('拾',10);\r\n\r\n        HanNum_unit.put('百',100);\r\n        HanNum_unit.put('佰',100);\r\n        HanNum_unit.put('陌',100);\r\n\r\n        HanNum_unit.put('千',1000);\r\n        HanNum_unit.put('仟',1000);\r\n        HanNum_unit.put('阡',1000);\r\n\r\n        HanNum_unit.put('万',10000);\r\n        HanNum_unit.put('亿',100000000);\r\n    }\r\n    public static int HanToNum(String Han_num){// 一千五百 零 四 万亿 零 五千 零 八百\r\n        int result = 0 ;\r\n        int stackNum = 0;\r\n        for (int i = 0; i < Han_num.length(); i++) {\r\n            char ch = Han_num.charAt(i);\r\n            Integer value =  HanNum_charset.get(ch);\r\n            Integer unit =  HanNum_unit.get(ch);\r\n\r\n            if(unit!=null && unit==10 && stackNum==0){\r\n                stackNum = 10;\r\n                continue;\r\n            }\r\n            if(unit!=null && unit==10 && stackNum!=0){\r\n                stackNum *= 10;\r\n                continue;\r\n            }\r\n\r\n            if(unit!=null && value!=null && value==0){\r\n                result+=value;\r\n                value=0;\r\n                continue;\r\n            }\r\n\r\n            if(value!=null){\r\n                stackNum+=value;\r\n                continue;\r\n            }\r\n            if(unit!=null){\r\n                stackNum*=unit;\r\n                continue;\r\n            }\r\n            \r\n        }\r\n        result+=stackNum;\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n</details>\r\n\r\n**实现效果**\r\n![](./images/java学习笔记/2022-11-02-00-13-17.png)\r\n\r\n## 多线程\r\n\r\n| 方式             | 优点                                                                 | 缺点                                                             |\r\n| ---------------- | -------------------------------------------------------------------- | ---------------------------------------------------------------- |\r\n| 继承Thread类     | 编程比较简单，可以直接使用Thread                                     | 扩展性较差，不能再继承其他的类，不能返回类中的方法线程执行的结果 |\r\n| 实现Runnable接口 | 扩展性强，实现该接口的同时还可以继承其他的类。                       | 编程相对复杂，不能返回线程执行的结果                             |\r\n| 实现Callable接口 | 扩展性强，实现该接口的同时还可以继承其他的类。可以得到线程执行的结果 | 编程相对复杂                                                     |\r\n\r\n\r\n\r\n### 方法1: **继承**`Thread类`\r\n* 步骤\r\n    * **继承**`Thread类`\r\n    * 重写`run()方法`\r\n    * 创建`实例对象`\r\n    * 调用`start()类`,内部会创建线程，并在线程中调用重写的`run()方法`\r\n* 缺点：由于一个类只能继承一个父类，无法继承其他类，不利于扩展\r\n\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Thread myThread1 = new MyThread();\r\n        myThread1.start();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"\\t主线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\nclass MyThread extends Thread{\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"子线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-02-19-20-53.png)\r\n\r\n\r\n### **方法2**：**实现**`Runnable接口`\r\n* 步骤\r\n    * **实现**`Runnable接口`\r\n    * **实现**`run()方法`\r\n    * 创建实例对象，丢给Thread的构造函数\r\n    * 调用`start()方法`\r\n* 优点，**可以继承其他类**\r\n* 缺点，**线程的执行结果不能直接返回**\r\n\r\n**写法一：实现`Runnable接口`**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Thread myThread1 = new Thread(new MyThread());\r\n        myThread1.start();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"\\t主线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\nclass MyThread implements Runnable{\r\n\r\n    @Override\r\n    public void run() {\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"子线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\n```\r\n**写法二：匿名类**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        \r\n        Thread myThread1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i < 10; i++) {\r\n                    System.out.println(\"子线程输出：\"+i);\r\n                }\r\n            }\r\n        }\r\n        );\r\n\r\n        myThread1.start();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"\\t主线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\n```\r\n**写法三：Lambda表达式写法**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        \r\n        Thread myThread1 = new Thread(()->{\r\n            for (int i = 0; i < 10; i++) {\r\n                System.out.println(\"子线程输出：\"+i);\r\n            }\r\n        });\r\n\r\n        myThread1.start();\r\n\r\n        for (int i = 0; i < 10; i++) {\r\n            System.out.println(\"\\t主线程输出：\"+i);\r\n        }\r\n    }\r\n}\r\n```\r\n***写法四：最简写法**\r\n```java\r\nnew Thread(()->{\r\n    for (int i = 0; i < 10; i++) {\r\n        System.out.println(\"子线程输出：\"+i);\r\n    }\r\n}).start();\r\n```\r\n\r\n### 方法3：实现`Callable接口`\r\n\r\n* 步骤\r\n  * 实现`Callable接口`\r\n  * 重写`call()方法`\r\n  * 用FutrueTask把Callable对象封装成**线程任务对象**\r\n  * 把**线程任务对象**丢给`Thread的构造器`\r\n  * 调用`Thread`的`start方法`\r\n  * 主线程中调用`FutureTask`的`get方法`等待并获取`call方法`的**返回结果**\r\n* 优点\r\n  * 可继承一个实现类\r\n  * 可获取方法的返回值\r\n* **FutureTask**方法\r\n    | 方法名称                           | 说明                                 |\r\n    | ---------------------------------- | ------------------------------------ |\r\n    | public FutureTask<>(Callable call) | 把Callable对象封装成FutureTask对象。 |\r\n    | public V get() throws Exception    | 获取线程执行call方法返回的结果。     |\r\n\r\n**写法**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.FutureTask;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        MyCallable myCallable = new MyCallable();\r\n        FutureTask<String> ft = new FutureTask<>(myCallable);\r\n        Thread mytThread = new Thread(ft);\r\n        \r\n        mytThread.start();\r\n\r\n        String result = ft.get();//get也会抛出线程的异常\r\n\r\n        System.out.println(\"result: \"+result);\r\n    }\r\n}\r\nclass MyCallable implements Callable<String>{\r\n\r\n    @Override\r\n    public String call() throws Exception {\r\n        for (int i = 0; i < 1000; i++) {\r\n            System.out.println(\"子线程执行...\"+i);\r\n        }\r\n        return \"子线程执行完毕\";\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-02-20-59-28.png)\r\n\r\n\r\n### Thread类\r\n\r\n\r\n**Thread的构造器**\r\n| 方法名称                                      | 说明                                         |\r\n| --------------------------------------------- | -------------------------------------------- |\r\n| public Thread(String name)                    | 可以为当前线程指定名称                       |\r\n| public Thread(Runnable target)                | 封装Runnable对象成为线程对象                 |\r\n| public Thread( Runnable target ,String name ) | 封装Runnable对象成为线程对象，并指定线程名称 |\r\n\r\n**Thread的主要方法**\r\n| 方法名称            | 说明         |\r\n| ------------------- | ------------ |\r\n| public void run( )  | 线程任务方法 |\r\n| public void start() | 线程启动方法 |\r\n\r\n**Thread获取和设置线程名称**\r\n| 方法名称                   | 说明                                                         |\r\n| -------------------------- | ------------------------------------------------------------ |\r\n| String getName()           | 获取当前线程的名称，默认线程名称是Thread-索引                |\r\n| void setName(String name ) | 将此线程的名称更改为指定的名称，通过构造器也可以设置线程名称 |\r\n\r\n**Thread类获得当前线程的对象**\r\n| 方法名称                             | 说明                               |\r\n| ------------------------------------ | ---------------------------------- |\r\n| public static Thread currentThread() | 返回对当前正在执行的线程对象的引用 |\r\n\r\n**Thread类的线程休眠方法**\r\n| 方法名称                            | 说明                                               |\r\n| ----------------------------------- | -------------------------------------------------- |\r\n| public static void sleep(long time) | 让当前线程休眠指定的时间后再继续执行，单位为毫秒。 |\r\n\r\n\r\n\r\n\r\nThread常用API说明\r\n* **区分线程**：获取线程名称getName()、 设置名称setName()、获取当前线程对象currentThread()（**静态**）\r\n* **其他方法**：至于Thread类 提供的诸如: yield、join、interrupt、 不推荐的方法stop、守护线程、线程优先级等线程的控制方法，\r\n\r\n**区分线程**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.FutureTask;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n       Thread thread1 = new Thread(()->{\r\n        Thread self = Thread.currentThread();\r\n        for(int i =0 ;i<5;i++)\r\n            System.out.println(self.getName() +  \"子线程执行...\"+i);\r\n       });\r\n       thread1.setName(\"thread1:\");\r\n       \r\n       Thread thread2 = new Thread(()->{\r\n        Thread self = Thread.currentThread();\r\n        for(int i =0 ;i<5;i++)\r\n            System.out.println(self.getName() +  \"子线程执行...\"+i);\r\n       });\r\n       thread2.setName(\"thread2:\");\r\n\r\n       thread1.start();\r\n       thread2.start();\r\n\r\n        Thread self = Thread.currentThread();\r\n        for(int i =0 ;i<5;i++)\r\n            System.out.println(self.getName() +  \"主线程执行...\"+i);\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-02-21-30-10.png)\r\n\r\n\r\n\r\n## 线程安全问题\r\n\r\n**出现原因**\r\n* 并发线程\r\n* 同时访问共享的资源\r\n* 同时修改共享的资源\r\n\r\n**线程安全问题演示:**\r\n\r\n`public_resource`的值被修改成了负数\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static double public_resource = 100.0;// 公共资源\r\n\r\n    public static void changeResource(double newVal) {\r\n\r\n        if (public_resource > 0) {// 只准在public_resource大于0的时候操作数值\r\n            public_resource -= newVal;\r\n\r\n            String threadName = Thread.currentThread().getName();\r\n            System.out.println(threadName + \"线程改变了内容\");\r\n            System.out.println(\"public_resource\" + \"的值变为\" + public_resource);\r\n        }\r\n\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        Thread thread1 = new Thread(() -> {\r\n            while (true) {\r\n                Main.changeResource(100);\r\n            }\r\n        });\r\n\r\n        Thread thread2 = new Thread(() -> {\r\n            while (true) {\r\n                Main.changeResource(100);\r\n            }\r\n        });\r\n\r\n        thread1.start();\r\n        thread2.start();\r\n\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-00-52-42.png)\r\n\r\n\r\n### synchronized同步\r\n\r\n\r\n#### synchronized同步代码块\r\n* 作用：把出现线程安全问题的核心代码上锁\r\n* 原理：每次只允许一个线程进入，执行完毕后自动解锁，解锁后其他线程才能进入\r\n* 对于实例方法，同步代码块建议使用`this`作为锁的对象\r\n* 对于静态方法，同步代码块建议使用`类名.class`作为锁对象\r\n```java\r\nsynchronized(同步锁对象){//锁住一个共享资源对象，当不同的线程同时访问时，只有一个能访问，其他的要等待\r\n    操作共享资源的代码\r\n}\r\n```\r\n\r\n**使用同步代码块来锁定公共资源**\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static Double public_resource = 100.0;//公共资源\r\n    public static void changeResource(double newVal){\r\n        synchronized(public_resource){// 同步代码块：锁住 public_resource ，只允许一个线程来操作,等一个线程操作完毕后，其他线程才能访问\r\n            if(public_resource>0){// 只准在public_resource大于0的时候操作数值\r\n                public_resource-=newVal;\r\n    \r\n                String threadName = Thread.currentThread().getName();\r\n                System.out.println(threadName + \"线程改变了内容\");\r\n                System.out.println(\"public_resource\"+\"的值变为\"+public_resource);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-00-54-51.png)\r\n\r\n#### synchronized同步方法\r\n\r\n* 每次只能一个线程进入方法，执行完毕后自动解锁\r\n* 作用：把出现线程问题的核心**方法**上锁。\r\n* 原理：每次只能一个线程进入，进入就上锁，执行完毕后自动解锁，解锁后其他线程才能进入。\r\n* 底层原理是有一个隐式的锁（锁的对象），锁的范围是整个方法的代码\r\n* 对于实例方法，同步方法默认用`this`作为**锁的对象**\r\n* 对于静态方法，同步方法默认用`类名.class`作为**锁的对象**\r\n```java\r\n修饰符 synchronized 返回值类型 方法名称(形参){\r\n    操作共享资源的代码\r\n}\r\n```\r\n\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static Double public_resource = 100.0;//公共资源\r\n    public synchronized static void changeResource(double newVal){ // 同步方法：锁住了整个方法的代码 ，只允许一个线程来操作,等一个线程操作完毕后，其他线程才能访问\r\n        if(public_resource>0){// 只准在public_resource大于0的时候操作数值\r\n            public_resource-=newVal;\r\n\r\n            String threadName = Thread.currentThread().getName();\r\n            System.out.println(threadName + \"线程改变了内容\");\r\n            System.out.println(\"public_resource\"+\"的值变为\"+public_resource);\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-00-59-54.png)\r\n\r\n\r\n\r\n\r\n### Lock锁\r\n\r\n* 为了更清晰的表达如何加锁和释放锁，JDK5以后提供了新的锁对象Lock\r\n* **Lock是接口类不是实现类**\r\n* Lock的实现类为`ReentrantLock`\r\n\r\n| 构造器名称             | 说明                   |\r\n| ---------------------- | ---------------------- |\r\n| public ReentrantLock() | 获得Lock锁的实例类对象 |\r\n\r\n| 方法名        | 说明   |\r\n| ------------- | ------ |\r\n| void lock()   | 获得锁 |\r\n| void unlock() | 释放锁 |\r\n\r\n**官方文档推荐用法**\r\n```java\r\n class X {\r\n   private final ReentrantLock lock = new ReentrantLock();//防止被修改，被撬锁\r\n   // ...\r\n\r\n   public void m() {\r\n     lock.lock();  // 上锁\r\n     try {\r\n       // ... method body\r\n     } finally {\r\n        //finally可以保证即使方法异常，也会解锁\r\n       lock.unlock();//解锁\r\n     }\r\n   }\r\n }\r\n```\r\n\r\n**测试**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\npublic class Main {\r\n   private static final ReentrantLock lock = new ReentrantLock();//定义一个锁，用final修饰防止被修改，被撬锁\r\n    public static Double public_resource = 100.0;//公共资源\r\n\r\n    public static void changeResource(double newVal){\r\n        lock.lock();  //上锁 // 只允许一个线程来操作,等一个线程操作完毕后，其他线程才能访问\r\n        try{\r\n\r\n            if(public_resource>0){// 只准在public_resource大于0的时候操作数值\r\n                public_resource-=newVal;\r\n                String threadName = Thread.currentThread().getName();\r\n                System.out.println(threadName + \"线程改变了内容\");\r\n                System.out.println(\"public_resource\"+\"的值变为\"+public_resource);\r\n            }\r\n\r\n        }catch(Exception e){\r\n            e.printStackTrace();\r\n        }finally{\r\n            lock.unlock();//放在finally中，保证函数一定被解锁\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n\r\n        new Thread(()->{\r\n            while(true){\r\n                Main.changeResource(100);\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-01-23-53.png)\r\n\r\n\r\n### 线程通信\r\n**Object类的等待和唤醒方法**:\r\n\r\n**这些方法应当使用当前`同步锁对象`调用**\r\n* 实例方法的**锁对象**是`this`\r\n* 静态方法的**锁对象**是`类名.class`\r\n* 只有锁对象知道有哪些线程在排队\r\n\r\n| 方法名称         | 说明                                                                         |\r\n| ---------------- | ---------------------------------------------------------------------------- |\r\n| void wait()      | 让当前线程等待并释放所占锁，直到另一个线程调用notify( )方法或notifyAll()方法 |\r\n| void notify()    | 唤醒正在等待的单个线程                                                       |\r\n| void notifyAll() | 唤醒正在等待的所有线程                                                       |\r\n\r\n\r\n```java\r\nimport java.util.*;\r\n\r\npublic class Main {\r\n    public static Double public_resource = 100.0;// 公共资源\r\n\r\n    public synchronized static void getResource(double newVal){ // 获取资源\r\n        try{\r\n            Object locker = Main.class;//当前的锁是 Main.class\r\n            if(public_resource > newVal){// 只准在资源足够的时候获取资源\r\n                public_resource-=newVal;\r\n    \r\n                String threadName = Thread.currentThread().getName();\r\n                System.out.println(\"\" + threadName + \"线程改变了内容,\" + \"public_resource\"+\"资源被获取\"+public_resource);\r\n    \r\n                //唤醒其他线程，告知资源已经操作完毕\r\n                locker.notifyAll();\r\n                //自身线程进入等待状态,等待被其他线程唤醒\r\n                locker.wait();\r\n            }else{\r\n                //唤醒其他线程，告知其他线程来补充资源\r\n                locker.notifyAll();\r\n                //自身线程进入等待状态,等待被其他线程唤醒\r\n                locker.wait();\r\n            }\r\n        }catch(Exception exception){\r\n            exception.fillInStackTrace();\r\n        }\r\n    }\r\n\r\n    public synchronized static void addResource(double newVal){ // 获取资源\r\n\r\n        try{\r\n            Object locker = Main.class;//当前的锁是 Main.class\r\n\r\n            if(public_resource < 1000){// 只在资源快将耗尽的时候补充资源\r\n                public_resource+=newVal;\r\n\r\n                String threadName = Thread.currentThread().getName();\r\n                System.out.println(\"\\t\" + threadName + \"线程改变了内容,\" + \"public_resource\"+\"资源被补充\"+public_resource);\r\n\r\n                //唤醒其他线程，告知资源已经补充完毕\r\n                locker.notifyAll();\r\n                //自身线程进入等待状态,等待被其他线程唤醒\r\n                locker.wait();\r\n            }else{\r\n                //唤醒其他线程，告知其他线程来获取资源\r\n                locker.notifyAll();\r\n                //自身线程进入等待状态,等待被其他线程唤醒\r\n                locker.wait();\r\n            }\r\n        }catch(Exception exception){\r\n            exception.fillInStackTrace();\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        new Thread(() -> {\r\n            while (true) {\r\n                Main.getResource(100);\r\n            }\r\n        }).start();\r\n\r\n        new Thread(() -> {\r\n            while (true) {\r\n                Main.addResource(1000);\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-02-07-58.png)\r\n\r\n\r\n\r\n## 线程池\r\n\r\n### 概念\r\n* **一种线程的复用技术，因为线程的创建开销很大。**\r\n* JDK5.0起，`ExecutorService接口类`代表线程池\r\n\r\n\r\n**线程池工作原理**\r\n![](./images/java学习笔记/2022-11-03-02-15-46.png)\r\n\r\n**线程池的创建**\r\n* 方式一:使用`ExecutorService接口类`的`实现类ThreadPoolExecutor`创建线程池对象\r\n* 方式二:使用`Executors线程池工具类`调用方法返回不同特点的线程池对象\r\n\r\n\r\n### 实现类ThreadPoolExecutor\r\n**ExecutorService的常用方法**\r\n| 方法名称                             | 说明                                                               |\r\n| ------------------------------------ | ------------------------------------------------------------------ |\r\n| `void execute( Runnable command)`    | 执行任务/命令，没有返回值，一般用来执行Runnable 任务               |\r\n| `Future<T> submit(Cal1ab1e<T> task)` | 执行任务，返回未来任务对象获取线程结果，一般拿来执行 Callable 任务 |\r\n| `void shutdown()`                    | 等任务执行完毕后关闭线程池                                         |\r\n| `List<Runnab1e> shutdownNow()`       | 立刻关闭，停止正在执行的任务，并返回队列中未执行的任务             |\r\n\r\n**新任务拒绝策略**\r\n| 策略                                   | 详解                                                             |\r\n| -------------------------------------- | ---------------------------------------------------------------- |\r\n| ThreadPoolExecutor.AbortPolicy         | 丢弃任务并抛出`RejectedExecutionException`异常。**是默认的策略** |\r\n| ThreadPoolExecutor.DiscardPolicy:      | 丢弃任务，但是不抛出异常这是不推荐的做法                         |\r\n| ThreadPoolExecutor.Discard0ldestPolicy | 抛弃队列中等待最久的任务然后把当前任务加入队列中                 |\r\n| ThreadPoolExecutor.CallerRunsPolicy    | 由主线程负责调用任务的run()方法从而绕过线程池直接执行            |\r\n\r\n\r\n**实现类ThreadPoolExecutor的构造器**\r\n```java\r\npublic ThreadPoolExecutor(int corePoolSize,//核心线程数，固定线程数\r\n                          int maximumPoolSize,//最大线程数，动态线程数\r\n                          long keepAliveTime,//动态线程的生命期\r\n                          TimeUnit unit,//生命期单位，秒，分，时，天\r\n                          BlockingQueue<Runnable> workQueue,//任务队列\r\n                          ThreadFactory threadFactory,//创建线程的工厂\r\n                          RejectedExecutionHandler handler//指定线程忙，任务队列慢的回调\r\n                          ) \r\n                          {\r\n}\r\n```\r\n**线程池常见面试题**\r\n* 临时线程什么时候创建啊?\r\n* 新任务提交时发现核心线程都在忙,**任务队列也满了**，并且还可以创建临时线程，此时才会创建临时线程。\r\n* 什么时候会开始拒绝任务?\r\n* 核心线程和临时线程都在忙,任务队列也满了，新的任务过来的时候才会开始任务拒绝。\r\n\r\n**ThreadPoolExecutor测试:处理Runnable对象**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建线程池\r\n        ThreadPoolExecutor threads = new ThreadPoolExecutor(\r\n            3,//核心线程数，固定线程数\r\n         6,//总线程数（核心+临时线程）\r\n         10,TimeUnit.SECONDS, //临时线程的生命周期，及单位\r\n         new ArrayBlockingQueue<>(5),// 任务队列\r\n         new ThreadPoolExecutor.AbortPolicy()// 拒绝策略（默认）\r\n         );\r\n\r\n         //创建一个可执行的任务\r\n        Runnable runnable1 = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i < 1; i++) {\r\n                    System.out.println(Thread.currentThread().getName() + \"执行了HelloWord X \" + i + \"次\");\r\n                }    \r\n            }\r\n        };\r\n        Runnable runnable2 = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (int i = 0; i < 1; i++) {\r\n                    System.out.println(Thread.currentThread().getName() + \"执行了HelloWord X \" + i + \"次\");\r\n                }\r\n                try{\r\n                    System.out.println(Thread.currentThread().getName() + \"该线程即将被休眠......\");\r\n                    Thread.sleep(1000000000);//休眠线程\r\n                }catch(Exception e){\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        };\r\n\r\n        //把可执行的任务丢入线程池的任务队列处理\r\n        threads.execute(runnable1);//核心线程将被占用一个，但任务执行完毕后，线程将会交给其他任务\r\n        threads.execute(runnable1);//核心线程将被占用一个，但任务执行完毕后，线程将会交给其他任务\r\n        threads.execute(runnable1);//核心线程将被占用一个，但任务执行完毕后，线程将会交给其他任务\r\n\r\n        threads.execute(runnable2);//核心线程将被占用一个，线程将被休眠 任务队列共有5个空位，当前占用1个位置\r\n        threads.execute(runnable2);//核心线程将被占用一个，线程将被休眠 任务队列共有5个空位，当前占用2个位置\r\n        threads.execute(runnable2);//核心线程将被占用一个，线程将被休眠 任务队列共有5个空位，当前占用3个位置\r\n\r\n        threads.execute(runnable2);//三个核心线程都被占用了，但任务队列共有5个空位，当前占用4个位置，未满，不会创建临时线程，该任务不会执行\r\n        threads.execute(runnable2);//三个核心线程都被占用了，但任务队列共有5个空位，当前占用5个位置，未满，不会创建临时线程，该任务不会执行\r\n        threads.execute(runnable2);//三个核心线程都被占用了，任务队列的5个位置已满，将创建临时线程，该任务不会执行，但会执行任务队列中第一个任务。\r\n\r\n        // threads.shutdown();//待任务队列中的任务执行完毕后再关闭线程池\r\n        // threads.shutdownNow();//立即关闭线程池\r\n    }\r\n}\r\n```\r\n\r\n**ThreadPoolExecutor测试:处理Runnable对象**\r\n```java\r\nimport java.util.*;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.Callable;\r\nimport java.util.concurrent.Future;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        // 创建线程池\r\n        ThreadPoolExecutor threads = new ThreadPoolExecutor(\r\n            3,//核心线程数，固定线程数\r\n         6,//总线程数（核心+临时线程）\r\n         10,TimeUnit.SECONDS, //临时线程的生命周期，及单位\r\n         new ArrayBlockingQueue<>(5),// 任务队列\r\n         new ThreadPoolExecutor.AbortPolicy()// 拒绝策略（默认）\r\n         );\r\n\r\n         //创建一个可执行的任务\r\n         Callable<String>  callable1 = new Callable<String>() {\r\n            @Override\r\n            public String call() {\r\n                for (int i = 0; i < 5; i++) {\r\n                    System.out.println(Thread.currentThread().getName() + \"执行了HelloWord X \" + i + \"次\");\r\n                }\r\n                return Thread.currentThread().getName() + \"线程执行完毕\";  \r\n            }\r\n        };\r\n        \r\n        //把可执行的任务丢入线程池的任务队列处理\r\n        Future<String> future1 = threads.submit(callable1);\r\n        Future<String> future2 = threads.submit(callable1);\r\n        Future<String> future3 = threads.submit(callable1);\r\n        Future<String> future4 = threads.submit(callable1);\r\n        Future<String> future5 = threads.submit(callable1);\r\n        Future<String> future6 = threads.submit(callable1);\r\n        Future<String> future7 = threads.submit(callable1);\r\n\r\n        System.out.println(future1.get());\r\n        System.out.println(future2.get());\r\n        System.out.println(future3.get());\r\n        System.out.println(future4.get());\r\n        System.out.println(future5.get());\r\n        System.out.println(future6.get());\r\n        System.out.println(future7.get());\r\n\r\n        // threads.shutdown();//待任务队列中的任务执行完毕后再关闭线程池\r\n        // threads.shutdownNow();//立即关闭线程池\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-03-51-59.png)\r\n\r\n\r\n### Executors工具类创建线程池\r\n* Executors: 线程池的工具类通过调用方法返回不同类型的线程池对象。\r\n* 注意: Executors的底层其实也是`基于线程池的实现类ThreadPoolExecutor`创建线程池对象的。\r\n* <green>这种方式创建线程在大型并发项目中存在多种弊端，被阿里巴巴公约禁止，建议使用原始方式<green>\r\n\r\n**Executors得到线程池对象的常用方法**\r\n| 方法名称                                                                        | 说明                                                                                            |\r\n| ------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |\r\n| public static ExecutorService newCachedThreadPool()                             | 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了一段时间则会被回收掉。                  |\r\n| public static ExecutorService newF ixedThreadPool( int nThreads )               | 创建有固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个 新线程替代它。 |\r\n| public static ExecutorService newSingleThreadExecutor ()                        | 创建只有一个线程的线程池对象， 如果该线程出现异常而结束，那么线程池会补充一个新线程。           |\r\n| public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) | 创建一个线程池， 可以实现在给定的延迟后运行任务，或者定期执行任务。                             |\r\n\r\n**在大型并发项目中使用Executors所存在的问题**\r\n![](./images/java学习笔记/2022-11-03-08-02-44.png)\r\n\r\n\r\n\r\n## 定时器\r\n\r\n### Timer定时器\r\n\r\nTimer定时器的特点和存在的问题\r\n* 1、Timer是**单线程**，处理多个任务按照**顺序执行**，存在延时与设置定时器的时间有出入。\r\n* 2、<green>可能因为其中的某个任务的异常使Timer线程死掉，从而影响后续任务执行</green>\r\n\r\n\r\n| 构造器         | 说明                |\r\n| -------------- | ------------------- |\r\n| public Timer() | 创建Timer定时器对象 |\r\n\r\n| 方法                                                          | 说明                                      |\r\n| ------------------------------------------------------------- | ----------------------------------------- |\r\n| public void schedule(TimerTask task, long delay)              | 开启一个定时器，按照计划处理TimerTask任务 |\r\n| public void schedule(TimerTask task, long delay, long period) | 开启一个定时器，按照计划处理TimerTask任务 |\r\n\r\n\r\n**测试代码**\r\n```java\r\nimport java.util.Timer;\r\nimport java.util.TimerTask;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Timer timer = new Timer();//定时器是一个单线程任务,处理多个任务按顺序执行\r\n        Runnable task1 = new TimerTask() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(Thread.currentThread().getName() + \"执行了.\");    \r\n                try {\r\n                    Thread.sleep(2000);//某条任务的执行时间过长会导致任务队列中的其余任务持续等待。\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }            \r\n            }\r\n        };\r\n        timer.schedule( (TimerTask) task1, 500, 500);\r\n    }\r\n}\r\n```\r\n\r\n### ScheduledExecutorService定时器\r\n* ScheduledExecutorService是一个线程池\r\n* \r\n\r\n| Executors工具类的方法                                                           | 说明           |\r\n| ------------------------------------------------------------------------------- | -------------- |\r\n| public static ScheduledExecutorService newScheduledThreadPoo1(int corePoolSize) | 得到线程池对象 |\r\n\r\n| ScheduledExecutorService的方法                                                                                 | 说明                                                                           |\r\n| -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |\r\n| public ScheduledFuture<?> scheduleAtFixedRate( Runnable command, long initialDelay, long period,TimeUnit unit) | 周期调度方法，循环执行：先延迟initialDelay时间，而后以period时间为周期循环执行 |\r\n| public ScheduledFuture<?> schedule(Runnable command,long delay, TimeUnit unit);                                | 只执行一次：先延迟后执行                                                       |\r\n\r\n```java\r\nimport java.util.Timer;\r\nimport java.util.TimerTask;\r\nimport java.util.concurrent.Executor;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(10);\r\n        Runnable task1 =  new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(Thread.currentThread().getName()+\"线程执行了该任务1...\");\r\n                try {\r\n                    System.out.println(Thread.currentThread().getName()+\"线程被休眠5秒....\");\r\n                    Thread.sleep(5000);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }//\r\n            }\r\n        };\r\n        Runnable task2 =  new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(Thread.currentThread().getName()+\"线程执行了该任务2...\");\r\n            }\r\n        };\r\n        // newScheduledThreadPool.schedule(task1, 2, TimeUnit.SECONDS);//只执行一次：先延迟后执行\r\n        newScheduledThreadPool.scheduleAtFixedRate(task1, 0, 1, TimeUnit.SECONDS);// 循环执行：先延迟2秒，而后以4秒为周期循环执行\r\n        newScheduledThreadPool.scheduleAtFixedRate(task2, 0, 1, TimeUnit.SECONDS);// 循环执行：先延迟2秒，而后以4秒为周期循环执行\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-09-37-55.png)\r\n\r\n\r\n## 并发与并行\r\n**并发**: CPU的单个核心，计算资源有限，**分时**轮询为多个线程提供服务，称为并发。\r\n**并行**: 多核CPU,计算资源富余，一个核心负责一个线程，多个核心上执行的线程为**同时**执行，称为并行。\r\n\r\n### Thread线程生命周期6种状态\r\n* java线程有6种状态\r\n* 6种状态都定义在Thread类的n内部枚举类中\r\n  ```java\r\n  public enum Thread.State {\r\n        NEW,//新建状态\r\n        RUNNABLE,//可运行状态\r\n        BLOCKED,//阻塞状态（被锁住） \r\n        WAITING,//无限等待状态\r\n        TIMED_WAITING,//计时状态\r\n        TERMINATED;//被终止状态\r\n    }\r\n  ```\r\n* ![](./images/java学习笔记/2022-11-03-11-54-54.png)\r\n\r\n| 线程状态                | 描述                                                                                                                             |\r\n| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------- |\r\n| NEW(新建)               | 线程刚被创建，但是并未启动。                                                                                                     |\r\n| Runnable(可运行)        | 线程已经调用了start()等待CPU调度                                                                                                 |\r\n| Blocked(锁阻塞)         | 线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态;。                                                                       |\r\n| Waiting(无限等待)       | 一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒                                                         |\r\n| Timed Waiting(计时等待) | 同waiting状态，有几个方法有超时参数,调用他们将进入Timed Waiting状态。带有超时参数的常用方法有Thread.sleep(num)、Object.wait(num) |\r\n| Teminated(被终止)       | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。                                                           |\r\n\r\n\r\n## 网络编程\r\n\r\n### InetAddress的使用\r\n* 此类表示Internet协议 (IP) 地址。\r\n**InetAddress API如下**\r\n\r\n| 名称                                              | 说明                                             |\r\n| ------------------------------------------------- | ------------------------------------------------ |\r\n| public static InetAddress getLocalHost()          | 返回本主机的地址对象                             |\r\n| public static InetAddress getByName(String host ) | 得到指定主机的IP地址对象，参数是域名或者IP地址   |\r\n| public String getHostName()                       | 获取此IP地址的主机名                             |\r\n| public String getHostAddress()                    | 返回IP地址字符串                                 |\r\n| public boolean isReachable(int timeout )          | 在指定毫秒内连通该IP地址对应的主机，连通返回true |\r\n\r\n**测试**\r\n```java\r\nimport java.net.InetAddress;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //获取InetAddress\r\n        InetAddress localHost_host = InetAddress.getLocalHost();\r\n        InetAddress localHost_baidu = InetAddress.getByName(\"baidu.com\");//填域名或ip\r\n\r\n        System.out.println(localHost_host);\r\n        System.out.println(localHost_baidu);\r\n\r\n        //获取域名\r\n        System.out.println(localHost_host.getHostName());\r\n        System.out.println(localHost_baidu.getHostName());\r\n\r\n        //获取IP地址\r\n        System.out.println(localHost_host.getHostAddress());\r\n        System.out.println(localHost_baidu.getHostAddress());\r\n\r\n        //测试连通性\r\n        System.out.println(localHost_host.isReachable(1000));\r\n        System.out.println(localHost_baidu.isReachable(1000));\r\n\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-12-35-17.png)\r\n\r\n\r\n### UDP数据包\r\n| DatagramPacket数据包对象构造器                                               | 说明                                                                                                                     |\r\n| ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |\r\n| public DatagramPacket(byte[] buf, int length, InetAddress address, int port) | 创建发送端数据包对象buf:要发送的内容，字节数组 length:要发送内容的字节长度 address:接收端的IP地址对象port:接收端的端口号 |\r\n| public DatagramPacket(byte[] buf, int length)                                | 创建接收端的数据包对象buf:用来存储接收的内容 length:能够接收内容的长度                                                   |\r\n\r\n**DatagramPacket常用方法**\r\n| 方法                          | 说明                                  |\r\n| ----------------------------- | ------------------------------------- |\r\n| public int getLength()        | 获得实际接收到的字节个数              |\r\n| public int getSocketAddress() | 获得实际接收到的数据包中的InetAddress |\r\n\r\n### DatagramSocket通信接口对象\r\n**DatagramSocket(UDP通信接口对象)**\r\n| DatagramSocket构造器                              | 说明                                                               |\r\n| ------------------------------------------------- | ------------------------------------------------------------------ |\r\n| public DatagramSocket()                           | 创建发送端的Socket对象，系统会随机分配一个端口号。                 |\r\n| public DatagramSocket(int port)                   | 创建接收端的Socket对象并指定端口号                                 |\r\n| public DatagramSocket(int port,InetAddress laddr) | **简单来说就是要说明数据从哪一个端口出去，从哪一个ip网卡接口出去** |\r\n\r\n**DatagramSocket类成员方法**\r\n| 方法                                  | 说明       |\r\n| ------------------------------------- | ---------- |\r\n| public void send(DatagramPacket dp)   | 发送数据包 |\r\n| public void receive(DatagramPacket p) | 接收数据包 |\r\n\r\n使用多线程模拟服务端和客户端的UDP的通信\r\n```java\r\nimport java.io.IOException;\r\nimport java.net.DatagramPacket;\r\nimport java.net.DatagramSocket;\r\nimport java.net.InetAddress;\r\nimport java.time.LocalTime;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        // 接收端\r\n        new Thread(() -> {\r\n            try (DatagramSocket socket = new DatagramSocket(9999, InetAddress.getLocalHost())) {\r\n                byte[] buffer = new byte[64 * 1024];// UDP包最大64KB\r\n                DatagramPacket packet = new DatagramPacket(\r\n                        buffer,\r\n                        0, buffer.length// buffer\r\n                );\r\n\r\n                while (true) {\r\n                    socket.receive(packet);\r\n\r\n                    String context = new String(buffer, 0, packet.getLength());\r\n                    System.out.println(\"接收到来自\"+packet.getSocketAddress()+\"的数据：\" + context);\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n\r\n        // 发送端\r\n        new Thread(() -> {\r\n            try (// 创建UDP数据报的发送接口\r\n            DatagramSocket socket = new DatagramSocket(8888, InetAddress.getLocalHost())) {\r\n                // 发送数据包\r\n                while (true) {\r\n                    String message =  \"当前时间为:\" + LocalTime.now().toString();\r\n                    byte[] buffer = message.getBytes();\r\n\r\n                    //// 封装数据包: 数据，数据长度，目标地址，目标端口\r\n                    socket.send(new DatagramPacket(buffer,buffer.length,\r\n                        InetAddress.getByName(\"255.255.255.255\"),9999//向局域网所有主机的9999端口广播\r\n                        ));\r\n                    \r\n                    Thread.sleep(1000);//延迟\r\n                }\r\n            } catch (IOException | InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-14-53-41.png)\r\n\r\n### UDP的单播、组播、广播\r\n\r\n**总结**\r\n| 类型 | 概念                                       | 目的ip地址，                                                                  | 目的端口地址                                 |\r\n| ---- | ------------------------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------- |\r\n| 单播 | 一台主机向另**一台**主机发送数据包         | 目的地址为目标主机地址                                                        | 端口一致（目的端口为对方主机程序的监听端口） |\r\n| 组播 | 一台主机向另**一组**主机发送数据包         | **目的地址**为**目标主机**所**绑定**的**组播地址**`224.0.0.0-239.255.255.255` | 端口一致                                     |\r\n| 广播 | 一台主机向**所在网络的所有主机**发送数据包 | 目的地址为广播地址`255.255.255.255`                                           | 端口一致                                     |\r\n\r\n![](./images/java学习笔记/2022-11-03-15-37-11.png)\r\n\r\n**组播通信测试**\r\n```java\r\nimport java.io.IOException;\r\nimport java.net.DatagramPacket;\r\nimport java.net.DatagramSocket;\r\nimport java.net.InetAddress;\r\nimport java.net.InetSocketAddress;\r\nimport java.net.MulticastSocket;\r\nimport java.net.NetworkInterface;\r\nimport java.time.LocalTime;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        // 接收端1\r\n        new Thread(() -> {\r\n\r\n            try (\r\n                MulticastSocket socket = new MulticastSocket(9999);\r\n\r\n                ) {\r\n                // 把当前socket加入到组播地址，网段为当前所在网段\r\n                socket.joinGroup(\r\n                    new InetSocketAddress(InetAddress.getByName(\"224.0.0.1\"), 0), \r\n                    NetworkInterface.getByInetAddress(InetAddress.getLocalHost())//网段为本机网段\r\n                );\r\n\r\n                byte[] buffer = new byte[64 * 1024];// UDP包最大64KB\r\n                DatagramPacket packet = new DatagramPacket(\r\n                        buffer,\r\n                        0, buffer.length// buffer\r\n                );\r\n\r\n                while (true) {\r\n                    socket.receive(packet);\r\n\r\n                    String context = new String(buffer, 0, packet.getLength());\r\n                    System.out.println( Thread.currentThread().getName() + \"线程 \" + \"接收到来自\"+packet.getSocketAddress()+\"的数据：\" + context);\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n\r\n\r\n        // 发送端\r\n        new Thread(() -> {\r\n            try (// 创建UDP数据报的发送接口\r\n            DatagramSocket socket = new DatagramSocket(8888, InetAddress.getLocalHost())) {\r\n                // 发送数据包\r\n                while (true) {\r\n                    String message =  \"当前时间为:\" + LocalTime.now().toString();\r\n                    byte[] buffer = message.getBytes();\r\n\r\n                    //// 封装数据包: 数据，数据长度，目标地址，目标端口\r\n                    socket.send(new DatagramPacket(buffer,buffer.length,\r\n                        InetAddress.getByName(\"224.0.0.1\"),9999         //向局域网的一个组播地址发送数据\r\n                        ));\r\n                    Thread.sleep(1000);//延迟\r\n                }\r\n            } catch (IOException | InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-03-17-47-45.png)\r\n\r\n### TCP\r\n\r\n#### Socket类\r\n| Socket构造器                         | 说明                                                             |\r\n| ------------------------------------ | ---------------------------------------------------------------- |\r\n| public Socket(String host，int port) | 创建发送端的Socket对象与服务端连接，参数为服务端程序的ip和端口。 |\r\n\r\n\r\n| Socket类成员方法               | 说明               |\r\n| ------------------------------ | ------------------ |\r\n| OutputStream getoutputStream() | 获得字节输出流对象 |\r\n| InputStream getInputStream( )  | 获得字节输入流对象 |\r\n\r\n#### ServerSocket类\r\n\r\n| ServerSocket类构造器          | 说明           |\r\n| ----------------------------- | -------------- |\r\n| public ServerSocket(int port) | 注册服务端端口 |\r\n\r\n| ServerSocket类方法     | 说明                                                                       |\r\n| ---------------------- | -------------------------------------------------------------------------- |\r\n| public Socket accept() | 等待接收客户端的Socket通信连接连接成功返回Socket对象与客户端建立端到端通信 |\r\n\r\n#### TCP通信测试：连接的建立与通信\r\n\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.time.LocalDateTime;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        // 服务端\r\n        new Thread(() -> {\r\n            try {\r\n                System.out.println(\"服务端启动\");\r\n                ServerSocket server = new ServerSocket(8888);//创建一个TCP服务器\r\n\r\n                //等待并获取一个TCP请求\r\n                Socket socket = server.accept();\r\n\r\n                //获取字节流数据\r\n                OutputStream os = socket.getOutputStream();\r\n                InputStream is = socket.getInputStream();\r\n\r\n                //包装成字符流\r\n                BufferedReader request_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                String message_req;\r\n                while ((message_req = request_Reader.readLine()) != null) {\r\n                    System.out.println(\"服务端收到客户端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n\r\n                    reponse_Writer.write(\"你发来的数据是：\"+message_req);//响应\r\n                    reponse_Writer.newLine();\r\n                    reponse_Writer.flush();\r\n                }\r\n\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n\r\n        }).start();\r\n\r\n        // 客户端\r\n        new Thread(() -> {\r\n            try {\r\n\r\n                Thread.sleep(1000);\r\n                System.out.println(\"客户端启动\");\r\n\r\n                Socket socket = new Socket(\"127.0.0.1\", 8888);\r\n\r\n                OutputStream os = socket.getOutputStream();\r\n                InputStream is = socket.getInputStream();\r\n\r\n                BufferedReader rsponse_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                BufferedWriter request_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                new Thread(()->{//获取服务端的响应\r\n                    try {\r\n                        String message_req;\r\n                        while ((message_req = rsponse_Reader.readLine()) != null) {\r\n                            System.out.println(\"\\t客户端收到服务端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n                        }\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }).start();\r\n\r\n                while(true){\r\n                    request_Writer.write(\"helloWorld \" + LocalDateTime.now() );//请求\r\n                    request_Writer.newLine();\r\n                    request_Writer.flush();\r\n                    Thread.sleep(1000);\r\n                }\r\n\r\n            } catch (IOException | InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n\r\n        }).start();\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-04-00-22-20.png)\r\n\r\n#### TCP通信测试：服务端通过临时创建子线程服务多个客户端\r\n`Server.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\npublic class Server {\r\n    public static void main(String[] args) {\r\n        try {\r\n            System.out.println(\"服务端启动\");\r\n            ServerSocket server = new ServerSocket(8888);\r\n            while (true) {\r\n                Socket socket = server.accept();//获取到一个链接就创建一个子线程来处理\r\n                System.out.println(\"新连接已建立...\\n交由子线程处理...\");\r\n                new Thread(() -> {\r\n                    try {\r\n                        OutputStream os = socket.getOutputStream();\r\n                        InputStream is = socket.getInputStream();\r\n\r\n                        BufferedReader request_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                        BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                        String message_req;\r\n                        while ((message_req = request_Reader.readLine()) != null) {\r\n                            System.out.println(\"服务端收到客户端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n\r\n                            reponse_Writer.write(\"你发来的数据是：\" + message_req);// 响应\r\n                            reponse_Writer.newLine();\r\n                            reponse_Writer.flush();\r\n                        }\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n\r\n                }).start();\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`Client.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.Socket;\r\nimport java.time.LocalDateTime;\r\nimport java.util.Scanner;\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        try {\r\n            Thread.sleep(1000);\r\n            System.out.println(\"客户端启动\");\r\n\r\n            Socket socket = new Socket(\"127.0.0.1\", 8888);\r\n\r\n            OutputStream os = socket.getOutputStream();\r\n            InputStream is = socket.getInputStream();\r\n\r\n            BufferedReader rsponse_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n            BufferedWriter request_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n            new Thread(()->{//获取服务端的响应\r\n                try {\r\n                    String message_req;\r\n                    while ((message_req = rsponse_Reader.readLine()) != null) {\r\n                        System.out.println(\"\\t客户端收到服务端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n\r\n            while(true){\r\n                System.out.println(\"请输入要发送的数据：\");\r\n                request_Writer.write( sc.nextLine() + LocalDateTime.now() );//请求\r\n                request_Writer.newLine();\r\n                request_Writer.flush();\r\n            }\r\n\r\n        } catch (IOException | InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**服务端**\r\n\r\n![](./images/java学习笔记/2022-11-04-00-59-07.png)\r\n\r\n**客户端1**\r\n\r\n![](./images/java学习笔记/2022-11-04-00-59-38.png)\r\n\r\n**客户端2**\r\n\r\n![](./images/java学习笔记/2022-11-04-00-59-49.png)\r\n\r\n### TCP通信测试：服务端通过线程池服务多个客户端\r\n`Server.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.BlockingQueue;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Server {\r\n    public static void main(String[] args) {\r\n        try {\r\n            ServerSocket server = new ServerSocket(8888);\r\n            ThreadPoolExecutor Pool = new ThreadPoolExecutor(//创建线程池\r\n                10, 20,//核心线程数，最大线程数量\r\n                 10, TimeUnit.SECONDS,//空闲时间\r\n                 new ArrayBlockingQueue<>(20),//任务队列大小\r\n                 new ThreadPoolExecutor.AbortPolicy()//任务队列满后又有新任务时的策略\r\n                 );\r\n            System.out.println(\"服务端启动了\");\r\n            while (true) {\r\n                Socket socket = server.accept();//获取到一个链接就创建一个子线程来处理\r\n                System.out.println(\"新连接已建立...\\n交由线程池处理...\");\r\n\r\n                //把任务交给线程池\r\n                Pool.execute(()->{\r\n                    try {\r\n                        OutputStream os = socket.getOutputStream();\r\n                        InputStream is = socket.getInputStream();\r\n\r\n                        BufferedReader request_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                        BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                        String message_req;\r\n                        while ((message_req = request_Reader.readLine()) != null) {\r\n                            System.out.println(\"服务端收到客户端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n\r\n                            reponse_Writer.write(\"你发来的数据是：\" + message_req);// 响应\r\n                            reponse_Writer.newLine();\r\n                            reponse_Writer.flush();\r\n                            if(message_req.equals(\"exit\")){\r\n                                reponse_Writer.write(message_req);// 响应\r\n                                reponse_Writer.newLine();\r\n                                reponse_Writer.flush();\r\n                                break;\r\n                            }\r\n                        }\r\n                        System.out.println(\"线程资源被释放...\");\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                });\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`Client.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.Socket;\r\nimport java.time.LocalDateTime;\r\nimport java.util.Scanner;\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        try {\r\n            Thread.sleep(1000);\r\n            System.out.println(\"客户端启动\");\r\n\r\n            Socket socket = new Socket(\"127.0.0.1\", 8888);\r\n\r\n            OutputStream os = socket.getOutputStream();\r\n            InputStream is = socket.getInputStream();\r\n\r\n            BufferedReader rsponse_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n            BufferedWriter request_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n            new Thread(()->{//获取服务端的响应\r\n                try {\r\n                    String message_req;\r\n                    while ((message_req = rsponse_Reader.readLine()) != null) {\r\n                        System.out.println(\"\\t客户端收到服务端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n                        if(message_req.equals(\"exit\"))\r\n                            break;\r\n                    }\r\n                } catch (IOException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n\r\n            while(true){\r\n                System.out.println(\"请输入要发送的数据：\");\r\n                String messageString = sc.nextLine();\r\n                request_Writer.write( messageString );//请求\r\n                request_Writer.newLine();\r\n                request_Writer.flush();\r\n                if(messageString.equals(\"exit\"))\r\n                    break;\r\n            }\r\n\r\n        } catch (IOException | InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-04-02-03-14.png)\r\n\r\n![](./images/java学习笔记/2022-11-04-02-03-34.png)\r\n\r\n![](./images/java学习笔记/2022-11-04-02-04-00.png)\r\n\r\n\r\n### TCP通信测试：实现简易群聊\r\n\r\n`Server.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.BlockingQueue;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Server {\r\n    public static Set<Socket> ALL_ONLINE_USERS = new HashSet<>();\r\n    public static void main(String[] args) {\r\n        try {\r\n            ServerSocket server = new ServerSocket(8888);\r\n            ThreadPoolExecutor Pool = new ThreadPoolExecutor(//创建线程池\r\n                10, 20,//核心线程数，最大线程数量\r\n                 10, TimeUnit.SECONDS,//空闲时间\r\n                 new ArrayBlockingQueue<>(20),//任务队列大小\r\n                 new ThreadPoolExecutor.AbortPolicy()//任务队列满后又有新任务时的策略\r\n                 );\r\n            System.out.println(\"服务端启动了\");\r\n            while (true) {\r\n                Socket socket = server.accept();//获取到一个链接就创建一个子线程来处理\r\n                System.out.println(\"新连接已建立...\\n交由线程池处理...\");\r\n                \r\n                //把任务交给线程池执行\r\n                Pool.execute(()->{\r\n                    try {\r\n                        ALL_ONLINE_USERS.add(socket);//保存线程\r\n                        OutputStream os = socket.getOutputStream();\r\n                        InputStream is = socket.getInputStream();\r\n\r\n                        BufferedReader request_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n                        BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n                        String message_req;\r\n                        while ((message_req = request_Reader.readLine()) != null) {\r\n                            System.out.println(\"收到客户端的消息：\"+ message_req);\r\n                            if(message_req.equals(\"exit\")){\r\n                                ALL_ONLINE_USERS.remove(socket);//移除socket\r\n                                socket.close();//关闭连接\r\n                                System.out.println(\"线程资源被释放...\");\r\n                                break;\r\n                            }\r\n                            \r\n                            reponse_Writer.write(\"已收到你的消息，开始群发\");\r\n                            reponse_Writer.newLine();\r\n                            reponse_Writer.flush();\r\n                            sendMsgToAll(message_req);\r\n                            \r\n                        }\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                });\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public static void sendMsgToAll(String msg) throws Exception{\r\n        for(Socket socket:ALL_ONLINE_USERS){\r\n            BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), \"UTF-8\"));\r\n            reponse_Writer.write(msg);\r\n            reponse_Writer.newLine();\r\n            reponse_Writer.flush();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n`Client.java`\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.Socket;\r\nimport java.time.LocalDateTime;\r\nimport java.util.Scanner;\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        Scanner sc = new Scanner(System.in);\r\n        try {\r\n            Thread.sleep(1000);\r\n            System.out.println(\"客户端启动\");\r\n\r\n            Socket socket = new Socket(\"127.0.0.1\", 8888);\r\n\r\n            OutputStream os = socket.getOutputStream();\r\n            InputStream is = socket.getInputStream();\r\n\r\n            BufferedReader rsponse_Reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\r\n            BufferedWriter request_Writer = new BufferedWriter(new OutputStreamWriter(os, \"UTF-8\"));\r\n\r\n            new Thread(()->{//获取服务端的响应\r\n                try {\r\n                    String message_req;\r\n                    while ((message_req = rsponse_Reader.readLine()) != null) {\r\n                        System.out.println(\"\\t客户端收到服务端发来的数据：\\\" \" + message_req + \" \\\" \");\r\n                    }\r\n                } catch (IOException e) {\r\n                    System.out.println(\"你已退出群聊。\");\r\n                    e.printStackTrace();\r\n                }\r\n            }).start();\r\n\r\n            while(true){\r\n                System.out.println(\"请输入要群发的数据：\");\r\n                String messageString = sc.nextLine();\r\n                request_Writer.write( messageString );//请求\r\n                request_Writer.newLine();\r\n                request_Writer.flush();\r\n                if(messageString.equals(\"exit\"))\r\n                    break;\r\n            }\r\n\r\n        } catch (IOException | InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**服务端**\r\n\r\n![](./images/java学习笔记/2022-11-04-02-44-38.png)\r\n\r\n**客户端1**\r\n\r\n![](./images/java学习笔记/2022-11-04-02-44-52.png)\r\n\r\n**客户端2**\r\n\r\n![](./images/java学习笔记/2022-11-04-02-45-03.png)\r\n\r\n**客户端3**\r\n\r\n![](./images/java学习笔记/2022-11-04-02-45-18.png)\r\n\r\n### TCP通信测试：简易BS架构原理测试\r\n```java\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\nimport java.util.concurrent.ArrayBlockingQueue;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class Server {\r\n    public static Set<Socket> ALL_ONLINE_USERS = new HashSet<>();\r\n    public static void main(String[] args) {\r\n        try {\r\n            ServerSocket server = new ServerSocket(8888);\r\n            ThreadPoolExecutor Pool = new ThreadPoolExecutor(10, 20,10, TimeUnit.SECONDS,new ArrayBlockingQueue<>(20),new ThreadPoolExecutor.AbortPolicy());\r\n            System.out.println(\"服务端启动了......\");\r\n            while (true) {\r\n                Socket socket = server.accept();//获取到一个链接就创建一个子线程来处理\r\n                System.out.println(\"新连接已建立...\\n交由线程池处理...\");\r\n                Pool.execute(socketHandle(socket));//把任务交给线程池执行\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public static Runnable socketHandle(Socket socket){\r\n        return ()->{\r\n            try{\r\n                BufferedReader request_Reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), \"UTF-8\"));\r\n                BufferedWriter reponse_Writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), \"UTF-8\"));\r\n\r\n                reponse_Writer.write(\"HTTP/1.1 200 OK\");\r\n                reponse_Writer.newLine();//换行\r\n                reponse_Writer.write(\"Content-Type:text/html;charset=UTF-8\");\r\n                reponse_Writer.newLine();//换行\r\n                reponse_Writer.newLine();//空行\r\n\r\n                reponse_Writer.write(\"<h1>Hello B/S </h1>\");\r\n                reponse_Writer.newLine();//换行\r\n\r\n                reponse_Writer.flush();//发送\r\n                reponse_Writer.close();//关闭\r\n                socket.close();//关闭连接\r\n                System.out.println(\"执行完毕，线程释放\");\r\n            }catch(Exception e){\r\n            }\r\n        };\r\n    }\r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-04-03-17-53.png)\r\n\r\n\r\n## 单元测试：Junit单元测试框架\r\n* Java程序的最小单元是函数，单元测试就是测试这些函数\r\n* Junit单元测试框架是开源框架，用java编写的\r\n\r\n测试案例\r\n\r\n`FunctionA.java`\r\n```java\r\npackage functiona;\r\n\r\npublic class FunctionA {\r\n    public String getUserNameById(int userId){\r\n        if(userId==0)\r\n            return \"admin\";\r\n        else\r\n        return \"DingYigui\";\r\n    }\r\n    public int devide(int a,int b){\r\n        return a/b;\r\n    }\r\n}\r\n```\r\n\r\n`TestFunctionA.java`\r\n```java\r\npackage functiona;\r\n\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n\r\npublic class TestFunctionA{\r\n    // 测试方法必须是public void\r\n    // 测试方法必须导入Test，然后用@Test修饰,表示这是一个测试方法\r\n\r\n    @Test \r\n    public void testGetUserNameById(){\r\n        FunctionA funA = new FunctionA();\r\n        Assert.assertEquals(\"admin\", funA.getUserNameById(0));\r\n        Assert.assertEquals(\"DingYigui\", funA.getUserNameById(1));\r\n    }\r\n\r\n    @Test\r\n    public void testDevide(){\r\n        FunctionA funA = new FunctionA();\r\n        Assert.assertEquals(5, funA.devide(10,2));\r\n        Assert.assertEquals(0, funA.devide(1,0));//异常\r\n    }\r\n}\r\n```\r\n\r\n**测试效果**\r\n![](./images/java学习笔记/2022-11-04-04-07-47.png)\r\n\r\n**Junit常用注解Uunit 4.xxxx版本)**\r\n| 注解         | 说明                                                         |\r\n| ------------ | ------------------------------------------------------------ |\r\n| @Test        | 测试方法                                                     |\r\n| @Before      | 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。 |\r\n| @After       | 用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次。 |\r\n| @BeforeClass | 用来静态修饰方法，该方法会在所有测试方法之前只执行一次。     |\r\n| @AfterClass  | 用来静态修饰方法，该方法会在所有测试方法之后只执行一次。     |\r\n\r\n\r\n**Junit常用注解Uunit 5.xxxx版本)**\r\n| 注解        | 说明                                                          |\r\n| ----------- | ------------------------------------------------------------- |\r\n| @Test       | 测试方法                                                      |\r\n| @BeforeEach | 用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次。  |\r\n| @AfterEach  | 用来修饰实例方法，该方法会在每一一个测试方法执行之后执行 次。 |\r\n| @BeforeAll  | 用来静态修饰方法，该方法会在所有测试方法之前只执行一次。      |\r\n| @AfterAll   | 用来静态修饰方法，该方法会在所有测试方法之后只执行一次。      |\r\n\r\n## 反射\r\n通过反射可以在程序的运行的过程中,通过类的Class字节码文件对象，获取到一个类的全部**属性Field**、**构造器Constructor**、**方法Method**的对象，无论是私有的还是公开的。\r\n\r\n通过反射可以获取任意一个实例对象的所有属性，所有方法，所有构造函数，并且可以查看、设置、调用他们，无论他们是否是私有的。\r\n\r\n反射的最主要应用是做企业通用框架\r\n\r\n### 获取Class对象\r\n**获取Class对象的三种方式**\r\n* 通过 `Class类` 的`forName()方法`,`形参className`填 `包名.类名`\r\n  * tips: `Class.forName(\"xx.xxx.xxx\")`的另一个作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。\r\n* 通过 `Student抽象类` 的 `Class属性 `获取\r\n* 通过 `Student实例对象` 的 `getClass方法` 获取\r\n\r\n```java\r\nimport java.lang.Class;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //获取Class对象的三种方式\r\n        Class class1 = Class.forName(\"Student\");//1.通过 Class类 的forName()方法,形参className填 包名.类名\r\n        Class class2 = Student.class;//通过 Student抽象类 的Class属性获取\r\n        Class class3 = new Student().getClass();//通过 Student实例对象 的getClass方法\r\n        System.out.println(class1);\r\n        System.out.println(class2);\r\n        System.out.println(class3);\r\n    }\r\n}\r\nclass Student{\r\n    String name;\r\n    int age;\r\n    char sex;\r\n}\r\n\r\n```\r\n\r\n### 获取Class对象的构造器函数\r\n| 方法                                                                | 说明                                         |\r\n| ------------------------------------------------------------------- | -------------------------------------------- |\r\n| Constructor<?>[] getConstructors( )                                 | 返回**所有**构造器对象的数组(只能拿public的) |\r\n| Constructor<?>[] getDeclaredConstructors()                          | 返回**所有**构造器对象的数组(能拿私有的)     |\r\n| `Constructor<T> getConstructor(Class<?>... parameterTypes)`         | 返回单个构造器对象(只能拿public的)           |\r\n| `Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)` | 返回单个构造器对象(能拿私有的)               |\r\n\r\n\r\n**测试**\r\n```java\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Constructor;\r\nimport java.util.Arrays;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        Class class1 = Student.class;//通过 Student抽象类 的Class属性获取\r\n\r\n        //获取所有公开的构造函数\r\n        Constructor[] constructors1 =  class1.getConstructors();\r\n        System.out.println(Arrays.toString(constructors1));\r\n        // 输出：   [public Student(java.lang.String,int,char)]\r\n\r\n        //获取所有构造函数（包括私有）\r\n        Constructor[] constructors2 =  class1.getDeclaredConstructors();\r\n        System.out.println(Arrays.toString(constructors2));\r\n        //输出：    [private Student(java.lang.String,int), public Student(java.lang.String,int,char)]\r\n\r\n        //根据形式参数类型获取单个公开的构造函数\r\n        Constructor constructor1 = class1.getConstructor(String.class,int.class,char.class);//形式参数必须完全匹配\r\n        System.out.println(constructor1);\r\n        //输出：    public Student(java.lang.String,int,char)\r\n\r\n        //根据形式参数类型获取单个构造函数（包括私有）\r\n        Constructor constructor2 = class1.getDeclaredConstructor(String.class,int.class);//形式参数必须完全匹配\r\n        System.out.println(constructor2);\r\n        //输出：    private Student(java.lang.String,int)\r\n    }\r\n}\r\nclass Student{\r\n    String name;\r\n    int age;\r\n    char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-08-22-09.png)\r\n\r\n### 使用获取到的构造函数创建对象\r\n\r\n**Constructor实例对象的用于创建对象的方法**\r\n| 符号                                    | 说明                                           |\r\n| --------------------------------------- | ---------------------------------------------- |\r\n| T newInstance(Object... initargs)       | 根据指定的构造器创建对象                       |\r\n| public void setAccessible(boolean flag) | 设置为true,表示取消访问检查进行暴力反射,也就是 |\r\n\r\n**测试**\r\n```java\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Constructor;\r\nimport java.util.Arrays;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //通过 Student抽象类 的Class属性获取\r\n        Class class1 = Student.class;\r\n\r\n        //根据形式参数类型获取单个构造函数（包括私有）\r\n        Constructor constructor = class1.getDeclaredConstructor(String.class,int.class,char.class);//形式参数必须完全匹配\r\n        constructor.setAccessible(true);//设置允许强制访问私有构造器\r\n        Student student = (Student) constructor.newInstance(\"DYG\",20,'男');\r\n        System.out.println(student);// 输出 Student [name=DYG, age=20, sex=男]\r\n    }\r\n}\r\nclass Student{\r\n    String name;\r\n    int age;\r\n    char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Student [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-08-40-03.png)\r\n\r\n### 获取Class类的属性对象\r\n\r\n| 函数名                              | 描述                                       |\r\n| ----------------------------------- | ------------------------------------------ |\r\n| Field[] getFields()                 | 返回所有成员变量对象的数组(只能拿public的) |\r\n| Field[ getDeclaredFields()          | 返回所有成员变量对象的数组，存在就能拿到   |\r\n| Field getField(String name)         | 返回单个成员变量对象(只能拿public的)       |\r\n| Field getDeclaredField(String name) | 返回单个成员变量对象，存在就能拿到         |\r\n\r\n```java\r\nimport java.io.ObjectInputStream.GetField;\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Arrays;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //通过 Student抽象类 的Class属性获取\r\n        Class class1 = Student.class;\r\n\r\n        Field[] stu_Fields = class1.getFields();\r\n        Field[] stu_Fields_all = class1.getDeclaredFields();\r\n\r\n        System.out.println(Arrays.toString(stu_Fields));        // [public java.lang.String Student.name]\r\n        System.out.println(Arrays.toString(stu_Fields_all));    // [public java.lang.String Student.name, int Student.age, char Student.sex]\r\n\r\n        Field student_namField =  class1.getField(\"name\");          \r\n        Field student_ageField =  class1.getDeclaredField(\"age\");   \r\n\r\n        System.out.println(student_namField);   //public java.lang.String Student.name\r\n        System.out.println(student_ageField);   //int Student.age\r\n\r\n    }\r\n}\r\nclass Student{\r\n    public String name;\r\n    int age;\r\n    char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Student [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n### 使用获取到的属性对象修改实例对象的属性值\r\n\r\n```java\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Field;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //通过 Student抽象类 的Class属性获取\r\n        Class class1 = Student.class;\r\n\r\n        Student student =new Student(\"DYG\",20,'男');\r\n        System.out.println(student);// 输出 Student [name=DYG, age=20, sex=男]\r\n\r\n        Field student_namField =  class1.getField(\"name\");\r\n        Field student_ageField =  class1.getDeclaredField(\"age\");\r\n        Field student_sexField =  class1.getDeclaredField(\"sex\");\r\n        \r\n        System.out.println((String)student_namField.get(student));// DYG\r\n        System.out.println((int)student_ageField.get(student));//20\r\n        student_sexField.setAccessible(true);//允许强制访问\r\n        System.out.println((char)student_sexField.get(student));//'男'\r\n\r\n        student_namField.set(student, \"DingYigui\");\r\n        student_ageField.set(student, 20);\r\n        student_sexField.setAccessible(true);//允许强制访问\r\n        student_sexField.set(student, '女');\r\n\r\n        System.out.println(student);// Student [name=DingYigui, age=20, sex=女]\r\n    }\r\n}\r\n\r\nclass Student{\r\n    public String name;\r\n    int age;\r\n    private char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Student [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-10-02-45.png)\r\n\r\n### 获取Class类的方法\r\n\r\n| 方法                                                              | 说明                                       |\r\n| ----------------------------------------------------------------- | ------------------------------------------ |\r\n| Method[] getMethods()                                             | 返回所有成员方法对象的数组(只能拿public的) |\r\n| Method[] getDeclaredMethods()                                     | 返回所有成员方法对象的数组，存在就能拿到   |\r\n| Method getMethod(String name, Class<?>... parameterTypes )        | 返回单个成员方法对象(只能拿public的)       |\r\n| Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 返回单个成员方法对象，存在就能拿到         |\r\n\r\n\r\n### 通过获取到的类的方法来执行实例对象的方法\r\n\r\n| 函数名                                    | 说明                         | 运行方法                                                                                                   |\r\n| ----------------------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------- |\r\n| object invoke(Object obj, object... args) | Method类中用于触发执行的方法 | 参数一:用obj对象调用该方法 参数二:调用方法的传递的参数(如果没有就不写) 返回值:方法的返回值(如果没有就不写) |\r\n\r\n\r\n```java\r\nimport java.lang.Class;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Method;\r\nimport java.util.Arrays;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n        //通过 Student抽象类 的Class属性获取\r\n        Class class1 = Student.class;\r\n\r\n        Student student =new Student(\"DYG\",20,'男');\r\n        System.out.println(student);// 输出 Student [name=DYG, age=20, sex=男]\r\n\r\n        Method toStrMethod = class1.getMethod(\"toString\",null);\r\n        System.out.println(toStrMethod.getName());\r\n        System.out.println(toStrMethod.getReturnType());\r\n        System.out.println(Arrays.toString(toStrMethod.getParameterTypes()));\r\n        System.out.println(Arrays.toString(toStrMethod.getParameters()));\r\n\r\n        System.out.println( toStrMethod.invoke(student, null));// 输出 Student [name=DYG, age=20, sex=男]\r\n    }\r\n}\r\n\r\nclass Student{\r\n    public String name;\r\n    int age;\r\n    private char sex;\r\n    private Student(String name, int age) {\r\n        this.name = name;\r\n        this.sex = sex;\r\n    }\r\n    public Student(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public String toString() {\r\n        return \"Student [name=\" + name + \", age=\" + age + \", sex=\" + sex + \"]\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n### 应用：存储任意对象的属性值到文件\r\n```java\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileOutputStream;\r\nimport java.io.PrintStream;\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.lang.reflect.Field;\r\npublic class Main {\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        Student student =new Student(\"DYG\",20,'男',\"110\",\"银河系太阳系地球\");\r\n        saveObjAttrToFile(student,new File(\"./123.txt\"));\r\n    }\r\n    static void saveObjAttrToFile(Object obj,File file) throws UnsupportedEncodingException, FileNotFoundException, IllegalArgumentException, IllegalAccessException{\r\n        PrintStream ps = new PrintStream(new BufferedOutputStream(new FileOutputStream(file)),true,\"UTF-8\");\r\n        for(Field field:obj.getClass().getDeclaredFields())\r\n        {\r\n            field.setAccessible(true);\r\n            ps.println(field.getName() + \"=\" + field.get(obj).toString());\r\n            ps.flush();\r\n        }\r\n        ps.close();\r\n    }\r\n}\r\n\r\nclass Student{\r\n    private String name;\r\n    private int age;\r\n    private char sex;\r\n    private String tel;\r\n    private String add;\r\n    public Student(String name, int age, char sex, String tel, String add) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n        this.tel = tel;\r\n        this.add = add;\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-10-36-20.png)\r\n\r\n\r\n## 注解\r\n* Java注解Annotation,也叫Java标注，\r\n* JDK5.0之后的标准\r\n* 类、构造器、属性、方法、成员变量、参数、都可以加注解\r\n* 作用：对标记的部分做特殊处理\r\n* 如：`@Override`标记的函数表示重写。编译阶段将检测是否正确重写\r\n\r\n### 自定义注解\r\n```java\r\npublic @interface 注解名称{\r\n    public 属性类型 属性名() default 默认值;\r\n}\r\n\r\n@注解名称(属性名1=123,属性名2=\"123\",属性名3={\"123\",\"123\"},属性名4={1,2,3})\r\n@注解名称(属性名=123)\r\n@注解名称(123)\r\npublic void main(){\r\n}\r\n```\r\n\r\n**使用测试**\r\n```java\r\npublic class Main {\r\n    @MyNote(tittle = \"测试0\")\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        @MyNote(tittle = \"输出\",context = \"测试输出语句\")\r\n        String str = \"12312\";\r\n        System.out.println(123213123);\r\n    }\r\n    @MyNote(tittle = \"测试1\")\r\n    public static void test(){\r\n\r\n    }\r\n}\r\n@interface MyNote{\r\n    public String tittle() default \"none\";\r\n    public String context() default \"none\";\r\n}\r\n```\r\n\r\n### 元注解\r\n元注解是注解的注解\r\n\r\n元注解有两：\r\n*` @Target` 约束自定义注解只能在哪些地方使用\r\n*` @Retention` 约束自定义注解的存活范围\r\n\r\n**写法**\r\n```java\r\n@Target\r\n@Target({ElementType.????,ElementType.????}) //Target使得MyNote只能注解什么类型\r\n@Retention(RetentionPolicy.????)//指定注解作用在什么阶段\r\npublic @interface 注解名称{\r\n    public 属性类型 属性名() default 默认值;\r\n}\r\n\r\n@Target({ElementType.METHOD,ElementType.FIELD}) //Target使得MyNote只能注解方法METHOD、成员属性FIELD\r\n@Retention(RetentionPolicy.RUNTIME)//指定注解作用在运行阶段\r\npublic @interface 注解名称{\r\n    public 属性类型 属性名() default 默认值;\r\n}\r\n```\r\n\r\n`@Target`中可使用的值定义在`ElementType枚举类`中，常用值如下\r\n* `TYPE`,类,接口\r\n* `FIELD`,成员变量\r\n* `METHOD`,成员方法\r\n* `PARAMETER`,方法参数\r\n* `CONSTRUCTOR`,构造器\r\n* `LOCAL_VARIABLE`,局部变量\r\n\r\n`@Retention`中可使用的值定义在`RetentionPolicy枚举类`中，常用值如下\r\n* `SOURCE` : 注解只作用在**源码阶段**，生成的字节码文件中不存在\r\n* `CLASS` : 注解作用在**源码阶段**，**字节码文件阶段**,运行阶段不存在，默认值.\r\n* `RUNTIME` : 注解作用在**源码阶段**,**字节码文件阶段**,**运行阶段**(开发常用)\r\n\r\n### 注解的解析\r\n注解的操作中经常需要进行解析，**注解的解析就是判断是否存在注解**，**存在注解就解析出内容**。\r\n\r\n**Annotation接口**\r\n* Annotation: 注解的顶级接口，\r\n* 注解都是Annotation类型的对象\r\n\r\n**AnnotatedElement接口**\r\n* 定义了与注解解析相关的**解析方法**\r\n\r\n**反射与注解**\r\n\r\n所有的**反射**的**类的成分** `Class`, `Method` , `Field` , `Constructor`, 都实现了`AnnotatedElement接口`他们都拥**有解析注解的能力**\r\n\r\n| 方法                                                               | 说明                                                                 |\r\n| ------------------------------------------------------------------ | -------------------------------------------------------------------- |\r\n| `Annotation[] getDeclaredAnnotations()`                            | 获得当前对象上使用的**所有注解**，返回注解数组。                     |\r\n| `T getDeclaredAnnotation(Class <T> annotationClass)`               | 根据**注解类型**获得对应注解对象                                     |\r\n| `boolean isAnnotationPresent(Class < Annotation> annotationClass)` | **判断**当前对象是否使用了指定的注解，如果使用了则返回true,否则false |\r\n  \r\n**解析类和方法上的注解测试**\r\n```java\r\nimport java.lang.annotation.Annotation;\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\nimport java.lang.reflect.Method;\r\nimport java.util.Arrays;\r\n\r\npublic class Main  {\r\n    static{\r\n        //解析类上的MyNote注解\r\n        Class stu = Student.class;\r\n        if (stu.isAnnotationPresent(MyNote.class)) {//判断是否存在指定注解\r\n            MyNote myNote = (MyNote) stu.getDeclaredAnnotation(MyNote.class);//获取指定注解\r\n            System.out.println(\"类上的注解属性: \" + myNote.tittle());\r\n            System.out.println(\"类上的注解属性: \" + myNote.context());\r\n        }\r\n\r\n        //解析方法上的MyNote注解\r\n        Method[] stuMethods = Student.class.getDeclaredMethods();//获取类的所有方法\r\n        for(Method sMethod:stuMethods){//遍历方法\r\n            if(sMethod.isAnnotationPresent(MyNote.class)){//判断是否存在指定注解\r\n                MyNote myNote = (MyNote) sMethod.getDeclaredAnnotation(MyNote.class);//获取指定注解\r\n                System.out.println(\"方法上的注解属性: \" + myNote.tittle());\r\n                System.out.println(\"方法上的注解属性: \" + myNote.context());\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n    }\r\n\r\n}\r\n\r\n@Target({ElementType.TYPE,ElementType.METHOD}) //Target使得MyNote只能注解类和方法 \r\n@Retention(RetentionPolicy.RUNTIME)//指定注解作用在运行阶段\r\n@interface MyNote{\r\n    public String tittle() default \"none\";\r\n    public String context() default \"none\";\r\n}\r\n\r\n@MyNote(tittle = \"名称\",context = \"内容\")\r\nclass Student{\r\n    String name;\r\n    int age;\r\n    char sex;\r\n    String tel;\r\n\r\n    public Student(String name, int age, char sex, String tel) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n        this.tel = tel;\r\n    }\r\n\r\n    @MyNote(tittle = \"名称\",context = \"内容\")\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public int getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public char getSex() {\r\n        return sex;\r\n    }\r\n\r\n    public void setSex(char sex) {\r\n        this.sex = sex;\r\n    }\r\n\r\n    public String getTel() {\r\n        return tel;\r\n    }\r\n\r\n    public void setTel(String tel) {\r\n        this.tel = tel;\r\n    }\r\n    \r\n}\r\n```\r\n![](./images/java学习笔记/2022-11-04-13-00-59.png)\r\n\r\n## 结合`反射`和`注解`实现简易`junit框架`\r\n```java\r\nimport java.lang.annotation.ElementType;\r\nimport java.lang.annotation.Retention;\r\nimport java.lang.annotation.RetentionPolicy;\r\nimport java.lang.annotation.Target;\r\nimport java.lang.reflect.Method;\r\n\r\n\r\npublic class Test{\r\n\r\n    @MyTest\r\n    public void test1(){\r\n        System.out.println(\"测试代码块1\");\r\n    }\r\n\r\n    public void test2(){\r\n        System.out.println(\"测试代码块2\");\r\n    }\r\n\r\n    @MyTest\r\n    public void test3(){\r\n        System.out.println(\"测试代码块3\");\r\n    }\r\n\r\n    public void test4(){\r\n        System.out.println(\"测试代码块4\");\r\n    }\r\n\r\n    @MyTest\r\n    public void test5(){\r\n        System.out.println(\"测试代码块5\");\r\n        System.out.println(100/0);//计算除0\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception{\r\n        //解析方法上的MyNote注解\r\n        Method[] testMethods = Test.class.getMethods();//获取类的所有公开方法\r\n        for(Method testMethod:testMethods){//遍历方法\r\n            if(testMethod.isAnnotationPresent(MyTest.class)){//判断是否存在指定注解\r\n                try {\r\n                    testMethod.invoke(new Test(), (Object[])null);//执行方法\r\n                    System.out.println(testMethod.getName() + \"测试通过!!!\");\r\n                } catch (Exception e) {\r\n                    System.out.println(testMethod.getName() + \"捕获到下列异常,测试未通过!!!\");\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n@Target({ElementType.METHOD}) //使得 MyTest 只能注解方法 \r\n@Retention(RetentionPolicy.RUNTIME)//指定注解作用在运行阶段\r\n@interface MyTest{\r\n    \r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-13-32-58.png)\r\n\r\n## 对象的动态代理\r\n代理就是一个**对象**，用来为**被代理对象**的**行为**做一些辅助工作。\r\n\r\n**实现步骤**\r\n* 把要对外公开的功能**定义接口类**\r\n* 被代理对象要**实现接口**\r\n* 使用 `Proxy.newProxyInstance(被代理对象的加载器,要向外公开的接口,代理的处理函数)` 来获取代理对象的实例\r\n* 可以使用泛型或直接使用Object来作为返回值和形参列表使得代理支持任意类型的被代理对象\r\n\r\n**应用场景**\r\n\r\n![](./images/java学习笔记/2022-11-04-15-59-48.png)\r\n\r\n```java\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Programmer programmer = new Programmer(\"DYG\", 20, '男');//程序员\r\n        ProgrammerActions programmerActionsProxy = ProgrammerActionsProxy.getProxy(programmer);//程序员的行为的代理\r\n\r\n        System.out.println(\"我是需求方，我需要做一个项目...\");\r\n        String result = (String) programmerActionsProxy.coding();//调用代理的coding\r\n        System.out.println(\"我是需求方，我拿到了项目的源代码...:\" + result);\r\n    }\r\n}\r\ninterface ProgrammerActions{//Programmer程序员对象的行为\r\n    Object coding();//敲代码\r\n}\r\nclass Programmer implements ProgrammerActions{//Programmer程序员对象\r\n    String name;\r\n    int age;\r\n    char sex;\r\n    public Programmer(String name, int age, char sex) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this.sex = sex;\r\n    }\r\n    @Override\r\n    public Object coding() {\r\n        System.out.println(\"我是程序员，我负责敲代码...\");\r\n        System.out.println(\"我是程序员，代码敲完了...\");\r\n        return \"{Hello,World}\";\r\n    }\r\n    private void eat() {//私有方法 吃饭\r\n        System.out.println(\"吃饭...\");        \r\n    }\r\n    private void sleep() {//私有方法 睡觉\r\n        System.out.println(\"睡觉...\");        \r\n    }\r\n}\r\nclass ProgrammerActionsProxy{//Programmer程序员行为的代理对象\r\n    public static ProgrammerActions getProxy(Programmer programmer){\r\n        return (ProgrammerActions) Proxy.newProxyInstance(//获取代理实例对象\r\n            programmer.getClass().getClassLoader(),//获取程序员对象的加载器\r\n            programmer.getClass().getInterfaces(),//获取程序员对象的行为的接口\r\n            new InvocationHandler() {//代理对程序员行为的处理函数\r\n                @Override\r\n                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                    System.out.println(\"我是代理，我负责接项目...\");//预处理\r\n                    Object result = method.invoke(programmer, args);//处理\r\n                    System.out.println(\"我是代理，我负责项目的交付...\");//收尾工作\r\n                    return result;//返回结果\r\n                }\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n## XML\r\n\r\n### 概述\r\n* 纯文本，默认UTF-8\r\n* Extensiable Markup Language 可扩展标记语言\r\n* 是一种数据表示格式 可描述非常复杂的数据结构 常用于传输和存储数据 网络消息传输 配置文件\r\n\r\n**基本语法**\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"   ?>\r\n<!-- 文档声明必须第一行 -->\r\n\r\n<root comment=\"必须包含一个根标签，有且只能有一个\" >\r\n\r\n    <!-- 这个是注释 -->\r\n    <important>version必须存在</important>\r\n\r\n    <name>标签必须成对出现</name>\r\n\r\n    <br>特殊标签可以不成对</br>\r\n    <br/>\r\n    <br/>\r\n\r\n    <attr id=\"标签中可有属性,属性值必须引号包裹\" name='男'>测试</attr>\r\n    \r\n    <test1>\r\n        <span> 特殊符号 </span>\r\n        <span> &lt; 小于</span>\r\n        <span> &gt;  大于</span>\r\n        <span> &amp; and号</span>\r\n        <span> &apos; 单引号</span>\r\n        <span> &quot; 双引号</span>\r\n    </test1>\r\n\r\n    <![CDATA[\r\n            特殊字符: > < & ' \"  \r\n    ]]>\r\n\r\n</root>\r\n```\r\n\r\n**DTD文档约束**\r\n* 可以约束XML的标签\r\n* 不能约束XML标签的内容\r\n\r\n```DTD\r\n<!ELEMENT 书架 (书+)>\r\n<!ELEMENT 书 (书名,作者,价格)>\r\n<!ELEMENT 书名 (#PCDATA)>\r\n<!ELEMENT 作者 (#PCDATA)>\r\n<!ELEMENT 价格 (#PCDATA)>\r\n```\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE 书架 SYSTEM \"test.dtd\"> <!-- 引入DTD约束文件 -->\r\n<书架>\r\n    <书>\r\n        <书名>123</书名>\r\n        <作者>123</作者>\r\n        <价格>不能约束数据类型</价格>\r\n    </书>\r\n    <书>\r\n        <书名>123</书名>\r\n        <作者>123</作者>\r\n        <价格>不能约束数据类型</价格>\r\n    </书>\r\n    <书>\r\n        <书名>123</书名>\r\n        <作者>123</作者>\r\n        <价格>不能约束数据类型</价格>\r\n    </书>\r\n    <书>\r\n        <书名>123</书名>\r\n        <作者>123</作者>\r\n        <价格>不能约束数据类型</价格>\r\n    </书>\r\n</书架>\r\n```\r\n\r\n**schema约束**\r\n* schema用来约束其他xml文件的数据类型\r\n* schema本身是一个xml文件,schema能被其他文件约束\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<书架 xmlns=\"http://www.itcast.cn\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"http://www.itcast.cn data.xsd\">\r\n    <!-- xmlns=\"http://www.itcast.cn\"  基本位置\r\n         xsi:schemaLocation=\"http://www.itcast.cn books02.xsd\" 具体的位置 -->\r\n    <书>\r\n        <书名>神雕侠侣</书名>\r\n        <作者>金庸</作者>\r\n        <售价>399.9</售价>\r\n    </书>\r\n    <书>\r\n        <书名>神雕侠侣</书名>\r\n        <作者>金庸</作者>\r\n        <售价>19.5</售价>\r\n    </书>\r\n\r\n</书架>\r\n```\r\n\r\n`data.xsd`\r\n```xsd\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<schema xmlns=\"http://www.w3.org/2001/XMLSchema\"\r\n        targetNamespace=\"http://www.itcast.cn\"\r\n        elementFormDefault=\"qualified\" >\r\n    <!-- targetNamespace:申明约束文档的地址（命名空间）-->\r\n    <element name='书架'>\r\n        <!-- 写子元素 -->\r\n        <complexType>\r\n            <!-- maxOccurs='unbounded': 书架下的子元素可以有任意多个！-->\r\n            <sequence maxOccurs='unbounded'>\r\n                <element name='书'>\r\n                    <!-- 写子元素 -->\r\n                    <complexType>\r\n                        <sequence>\r\n                            <element name='书名' type='string'/>\r\n                            <element name='作者' type='string'/>\r\n                            <element name='售价' type='double'/>\r\n                        </sequence>\r\n                    </complexType>\r\n                </element>\r\n            </sequence>\r\n        </complexType>\r\n    </element>\r\n</schema>\r\n```\r\n\r\n\r\n### 解析\r\n常见解析工具\r\n| 解析工具  | 描述                                                                                                                                                                           |\r\n| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| JAXP      | SUN公司提供的一套XML的解析的API                                                                                                                                                |\r\n| JDOM      | JDOM是一个开源项目，它基于树型结构，利用纯JAVA的技术对XML文档实现解析、生成、序列化以及多种操作。                                                                              |\r\n| **dom4j** | 是JDOM的升级品，用来读写XML文件的。具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom技术，同时它也是一个开放源代码的软件，Hibernate也用它来读写配置文件。 |\r\n| jsoup     | 功能强大DOM方式的XML解析开发包，尤其对HTML解析更加方便                                                                                                                         |\r\n\r\n**两种解析方式**\r\n* SAX解析 一行一行解析\r\n* DOM解析 整个文件读入内存解析\r\n\r\n![](./images/java学习笔记/2022-11-04-19-10-54.png)\r\n\r\n\r\n\r\n#### Dom4J\r\n\r\n![](./images/java学习笔记/2022-11-04-19-38-23.png)\r\n![](./images/java学习笔记/2022-11-04-19-39-41.png)\r\n**dom4j解析xml文档**\r\n\r\n```java\r\nimport java.io.InputStream;\r\nimport org.dom4j.Document;\r\nimport org.dom4j.Element;\r\nimport org.dom4j.io.SAXReader;\r\n\r\npublic class Main {\r\n    public static void main(String[] args)throws Exception {\r\n        SAXReader saxReader = new SAXReader();\r\n        InputStream is = Main.class.getResourceAsStream(\"/test.xml\");//当前目录下搜索\r\n        Document document = saxReader.read(is);//读取文档\r\n\r\n        Element root = document.getRootElement();//获取根标签\r\n        System.out.println(root);\r\n    }\r\n}\r\n```\r\n\r\n![](./images/java学习笔记/2022-11-04-20-21-17.png)\r\n\r\n\r\n\r\n### 检索:xPath\r\n![](./images/java学习笔记/2022-11-04-19-56-34.png)\r\n![](./images/java学习笔记/2022-11-04-19-58-01.png)\r\n\r\n**xPath**\r\n* 检索XML文件中的信息\r\n* 绝对路径: `/根元素/子元素/孙元素`\r\n* 相对路径: `./子元素/孙元素`\r\n* 全文检索: `//contact`\r\n* 属性查找: `//@属性名`、`//元素[@属性名]`、`//元素//[@属性名='值']`\r\n\r\n**绝对路径检索**\r\n![](./images/java学习笔记/2022-11-04-20-22-47.png)\r\n\r\n**绝对路径检索**\r\n![](./images/java学习笔记/2022-11-04-20-23-34.png)\r\n\r\n**全文检索检索**\r\n\r\n![](./images/java学习笔记/2022-11-04-20-27-39.png)\r\n![](./images/java学习笔记/2022-11-04-20-24-39.png)\r\n\r\n**属性查找检索**\r\n![](./images/java学习笔记/2022-11-04-20-25-32.png)\r\n\r\n\r\n\r\n## 工厂设计模式\r\n**概念**\r\n* 工厂模式(Factory Pattern) 是Java中最常用的设计模式之一 ，这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。\r\n* 工厂的方法可以封装对象的创建细节，比如:为该对象进行加工和数据注入。\r\n* 可以实现类与类之间的解耦操作(核心思想)\r\n\r\n**工厂设计模式：封装对象的创建细节**\r\n```java\r\nimport java.util.Objects;\r\n\r\npublic class Main {\r\n    public static void main(String[] args)throws Exception {\r\n        Computer mac = ComputerFactory.gComputer(\"Mac\");\r\n        Computer huawei = ComputerFactory.gComputer(\"HuaWei\");\r\n    }\r\n}\r\n\r\nclass ComputerFactory{\r\n    public static Computer gComputer(String brand) {//工厂模式\r\n        if(Objects.equals(brand,\"Mac\")){\r\n            return new Mac(\"Mac\", 9000, 18, 40, 50);\r\n        }else\r\n        if(Objects.equals(brand,\"HuaWei\")){\r\n            return new Mac(\"HuaWei\", 5000, 20, 30, 45);\r\n        }\r\n        return null;\r\n    }\r\n}\r\nclass Computer{\r\n    String brand;//品牌\r\n    double price;//价格\r\n    int size;//尺寸\r\n    int length;//长度\r\n    int width;//宽度\r\n    public Computer(String brand, double price, int size, int length, int width) {\r\n        this.brand = brand;\r\n        this.price = price;\r\n        this.size = size;\r\n        this.length = length;\r\n        this.width = width;\r\n    }\r\n}\r\nclass Mac extends Computer{\r\n    public Mac(String brand, double price, int size, int length, int width){\r\n        super(brand,price,size,length,width);\r\n    }\r\n}\r\n\r\nclass HuaWei extends Computer{\r\n    public HuaWei(String brand, double price, int size, int length, int width){\r\n        super(brand,price,size,length,width);\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 装饰设计模式\r\n什么是装饰设计模式?\r\n* **创建一个新类**，**包装原始类**,从而在新类中提升原来类的功能。\r\n* 装饰模式指的是在**不改变原类的基础**.上,动态地扩展-个类的功能\r\n\r\n**装饰设计模式的作用**:\r\n* 装饰模式指的是在不改变原类的基础上,动态地扩展-个类的功能。\r\n> InputStream (抽象父类)\r\n> FileInputStream (实现子类，但读写性能较差)\r\n> BufferedInputStream (实现子类，装饰类，读写性能高)\r\n\r\n**创建步骤**\r\n* 定义父类。\r\n* 定义原始类,继承父类,定义功能。\r\n* 定义装饰类,继承父类,包装原始类,增强功能! !\r\n\r\n\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>"},{"shortInfo":{"title":"jQuery学习笔记","date":"2022-07-07T19:16:00.000Z","cover":"\\self_server\\assets\\images\\jQuery学习笔记\\2022-12-04-01-25-12.png","tags":["jQuery"],"categories":"笔记","requirejQuery":true,"id":4261251047,"countWords":12261,"readSeconds":1226.1,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/jQuery学习笔记/2022-12-04-01-25-12.png) -->\r\n\r\n# jQuery学习笔记\r\n\r\n## 目录\r\n- [jQuery学习笔记](#jquery学习笔记)\r\n  - [目录](#目录)\r\n  - [概述](#概述)\r\n  - [jQuery基本使用](#jquery基本使用)\r\n    - [版本区别](#版本区别)\r\n    - [$符号](#符号)\r\n    - [JQuery对象和DOM对象](#jquery对象和dom对象)\r\n    - [入口函数](#入口函数)\r\n  - [jQuery选择器](#jquery选择器)\r\n    - [隐式迭代](#隐式迭代)\r\n    - [链式编程](#链式编程)\r\n    - [项目练习](#项目练习)\r\n      - [测试](#测试)\r\n      - [下拉菜单](#下拉菜单)\r\n      - [排他思想](#排他思想)\r\n      - [简易轮播图](#简易轮播图)\r\n  - [jQuery样式操作](#jquery样式操作)\r\n    - [案例练习](#案例练习)\r\n      - [tab栏切换](#tab栏切换)\r\n  - [jQuery效果](#jquery效果)\r\n    - [显示隐藏](#显示隐藏)\r\n    - [滑动](#滑动)\r\n    - [淡入淡出](#淡入淡出)\r\n    - [自定义动画](#自定义动画)\r\n    - [测试使用效果](#测试使用效果)\r\n      - [显示/隐藏测试](#显示隐藏测试)\r\n      - [滑动测试](#滑动测试)\r\n      - [淡入淡出测试1](#淡入淡出测试1)\r\n      - [淡入淡出测试2](#淡入淡出测试2)\r\n      - [动画测试](#动画测试)\r\n    - [案例练习](#案例练习-1)\r\n  - [hover事件切换](#hover事件切换)\r\n  - [动画：stop()停止排队](#动画stop停止排队)\r\n  - [Jquery内容操作](#jquery内容操作)\r\n    - [案例练习](#案例练习-2)\r\n  - [Jquery属性操作](#jquery属性操作)\r\n  - [元素操作](#元素操作)\r\n    - [遍历](#遍历)\r\n      - [each()遍历](#each遍历)\r\n      - [$.each()遍历](#each遍历-1)\r\n    - [创建、添加、删除元素](#创建添加删除元素)\r\n  - [jQuery尺寸及位置](#jquery尺寸及位置)\r\n    - [jQuery尺寸](#jquery尺寸)\r\n    - [jQuery位置](#jquery位置)\r\n  - [JQuery事件](#jquery事件)\r\n    - [事件注册](#事件注册)\r\n    - [事件解绑](#事件解绑)\r\n    - [事件处理](#事件处理)\r\n    - [触发事件](#触发事件)\r\n    - [事件对象](#事件对象)\r\n    - [案例测试](#案例测试)\r\n  - [jQuery拷贝](#jquery拷贝)\r\n  - [多库共存](#多库共存)\r\n  - [jquery插件](#jquery插件)\r\n  - [元素的缓存数据](#元素的缓存数据)\r\n\r\n## 概述\r\n* jQuery是一个用原生js写成的库，用于方便的操作DOM \r\n* j就是js，query就是查询，jQuery就是把原生js中的DOM操作做了封装\r\n* 其设计宗旨是“write less，do more”，倡导写更少的代码做更多的事\r\n* jQuery封装了js常用功能，优化了DOM操作、事件处理，动画设计，Ajax交互\r\n* 学习jQuery就是学习使用这些函数\r\n\r\n## jQuery基本使用\r\n### 版本区别\r\n* 1.X 支持ie678,不再更新维护\r\n* 2.X 不支持ie678,不再更新维护\r\n* 3.X 不支持ie678,官网更新维护\r\n    * production 版本，用于生产环境，代码经过压缩，jQuery.mini.js\r\n    * development 版本，开发版本，代码保留了注释和缩进格式\r\n\r\n\r\n### $符号\r\n`$`符号是jQuery的**别称**\r\n```js\r\n//两种写法等效\r\n$(\"div\").hide();\r\njQuery(\"div\").hide();\r\n```\r\n`$`符号、或者说`jQuery`，是jQuery的**顶级对象**\r\n  * jQuery对象以**伪数组**形式存储，数组的**每个元素为DOM对象**\r\n  * jQuery对象本质就是对DOM对象进行了封装，增添了一些属性和方法\r\n```js\r\n//$(\"div\") 和 jQuery(\"div\") 等效，\r\n//是一个jQuery对象，能够调用在jQuery中定义的属性和方法\r\n$(\"div\").hide()\r\njQuery(\"div\").hide()\r\n```\r\n\r\n### JQuery对象和DOM对象\r\n* DOM对象: \r\n  * `document.querySelector(\"#DEMOwoejwe\")`\r\n  * 获取DOM对象的方法不止这一种\r\n* JQuery对象: \r\n  * 几种不同的写法：\r\n    * `jQuery(document.querySelector(\"#DEMOwoejwe\"))`\r\n    * `$(document.querySelector(\"#DEMOwoejwe\"))`\r\n    * `$(\"#DEMOwoejwe\")`\r\n* 相互转换\r\n  * DOM对象->Jquery对象: `$(DOM对象)`\r\n  * Jquery对象->DOM对象：\r\n    * `Jquery对象[0]`\r\n    * `Jquery对象.get(0)`\r\n\r\n```js\r\n// 以下写法是等效的\r\n\r\n// 通过Jquery对象操作元素:\r\n$(document.querySelector(\"div\")).hide()\r\n$(\"div\").hide()\r\n\r\n//通过DOM对象操作元素:\r\ndocument.querySelector(\"div\").style.display=\"none\"\r\n$(\"div\")[0].style.display=\"none\"\r\n$(\"div\").get(0).style.display=\"none\"\r\n```\r\n\r\n\r\n\r\n### 入口函数\r\n```js\r\n//隐藏元素，但只能操作已经加载完毕的DOM元素\r\n$(\"div\").hide();\r\n\r\n//等到dom结构加载完毕后再执行回调函数，相当于DOMContentLoaded事件,不是load事件\r\n$(document).ready(\r\n    function(){\r\n        $(\"div\").hide();\r\n    }\r\n)\r\n\r\n//更简洁的写法，功能同上，等待dom结构加载完毕后再执行回调函数\r\n$(\r\n    function(){\r\n        $(\"div\").hide();\r\n    }\r\n)\r\n```\r\n\r\n## jQuery选择器\r\n原生js获取元素的方式多而杂，jQuery对此做了封装，通过css选择器的语法格式来选中元素\r\n```js\r\n$(\"css选择器格式\")\r\n```\r\n\r\n普通选择器\r\n* `$(\"div\")` 标签选择器\r\n* `$(\"*\")` 全选选择器\r\n* `$(\"#id\")` id选择器\r\n* `$(\".class\")` 类名选择器\r\n* `$(\"div.class#id\")` 交集选择器\r\n* `$(\"div,class,id\")` 并集选择器\r\n\r\n层级选择器\r\n* `$(\"ul>li>a\")` 子代选择器\r\n* `$(\"ul li a\")` 后代选择器\r\n\r\n筛选选择器\r\n* `$(选择器:first)` 获取第一个元素\r\n* `$(选择器:last)` 获取最后一个元素\r\n* `$(选择器:eq(index))` 获取第Index个元素(第一个为0)\r\n* `$(选择器:obb)` 获取索引号为奇数的选择器\r\n* `$(选择器:even)` 获取索引号为偶数的选择器\r\n\r\n筛选函数\r\n* ★`jQueryObj.parent()` 查找直系父级\r\n* ★`jQueryObj.parents()` 获取所有父级，伪数组，第0个元素为直系父级 \r\n* ★`jQueryObj.parents(\"css格式选择器\")` 获取所有满足条件的父级，伪数组，下标越大，辈分越高。\r\n* ★`jQueryObj.children(\"css格式选择器\")` 查找子元素，子代选择器\r\n* `jQueryObj.find(\"css格式选择器\")` 查找后代元素，后代选择器\r\n* ★`jQueryObj.siblings(\"css格式选择器\")` 查找兄弟元素，不包括自身\r\n* `jQueryObj.nextAll([expr])` 查找之后的所有兄弟节点\r\n* `jQueryObj.prevAll([expr])` 查找之前的所有兄弟节点\r\n* ★`jQueryObj.hasClass(\"类名\")` 检测当前元素是否有某类名\r\n* ★`jQueryObj.eq(index)` 获取当前元素中第Index个元素\r\n\r\n\r\n\r\n### 隐式迭代\r\n* 遍历jQuery对象内部存储的DOM元素的过程就称为**隐式迭代**\r\n* 如：`$(\"div a\")` 是一个JQuery对象，其存储形式是一个伪数组，该数组中的每一个元素都是一个DOM对象，隐式迭代就是遍历该JQuery伪数组中的每一个DOM对象，对其执行相同的操作，省去了手动写for循环的过程\r\n```js\r\n//div中的所有a的背景色都会改变\r\n$(\"div a\").css(\"background-color\",\"skyblue\");\r\n```\r\n\r\n### 链式编程\r\n```js\r\n//这种写法，需要将选择器$(\"#demoBoxj02r002 .right li\")写两遍，会使得代码变得冗长\r\n$(\"#demoBoxj02r002 .right li\").css(\"background-color\",\"red\")\r\n$(\"#demoBoxj02r002 .right li\").show()\r\n//上面两句话可以合并写成一句\r\n$(\"#demoBoxj02r002 .right li\").css(\"background-color\",\"red\").show()\r\n```\r\n\r\n### 项目练习\r\n\r\n#### 测试\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<div id=\"test\">已引入jQuery库</div>\r\n<style>\r\n    #test{\r\n        display: none;\r\n        min-width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        line-height: 100px;\r\n        text-align: center;\r\n        color: white;\r\n    }\r\n</style>\r\n<script>\r\n    $(\"#test\").css(\"display\",\"inline-block\")\r\n</script>\r\n\r\n```html\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<div id=\"test\">已引入jQuery库</div>\r\n<style>\r\n    #test{\r\n        display: none;\r\n        min-width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        line-height: 100px;\r\n        text-align: center;\r\n        color: white;\r\n    }\r\n</style>\r\n<script>\r\n    $(\"#test\").css(\"display\",\"inline-block\")\r\n</script>\r\n```\r\n\r\n#### 下拉菜单  \r\n\r\n<script>\r\n$(function () {//DOMContentLoaded\r\n        $(\"ul#demoXLCD>li\").mouseenter(function () { //应当注册给不支持冒泡的mouseenter事件\r\n            $(this).children(\"ul\").show()\r\n        });\r\n        $(\"ul#demoXLCD>li\").mouseleave(function () { //应当注册给不支持冒泡的mouseleave事件\r\n            $(this).children(\"ul\").hide()\r\n        });\r\n    }\r\n);\r\n</script>\r\n<ul id=\"demoXLCD\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demoXLCD,\r\n    ul#demoXLCD *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demoXLCD *::before,\r\n    ul#demoXLCD *::after{\r\n        content: none;\r\n    }\r\n    ul#demoXLCD{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demoXLCD>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demoXLCD>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demoXLCD>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demoXLCD>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demoXLCD>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demoXLCD>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demoXLCD>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script>\r\n$(function () {//DOMContentLoaded\r\n        $(\"ul#demoXLCD>li\").mouseenter(function () { //应当注册给不支持冒泡的mouseenter事件\r\n            $(this).children(\"ul\").show()\r\n        });\r\n        $(\"ul#demoXLCD>li\").mouseleave(function () { //应当注册给不支持冒泡的mouseleave事件\r\n            $(this).children(\"ul\").hide()\r\n        });\r\n    }\r\n);\r\n</script>\r\n<ul id=\"demoXLCD\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demoXLCD,\r\n    ul#demoXLCD *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demoXLCD *::before,\r\n    ul#demoXLCD *::after{\r\n        content: none;\r\n    }\r\n    ul#demoXLCD{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demoXLCD>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demoXLCD>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demoXLCD>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demoXLCD>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demoXLCD>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demoXLCD>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demoXLCD>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n```\r\n\r\n#### 排他思想\r\n\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<div id=\"DemoTEST123\">\r\n    <button>测试1</button>\r\n    <button>测试2</button>\r\n    <button>测试3</button>\r\n    <button>测试4</button>\r\n    <button>测试5</button>\r\n</div>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#DemoTEST123>button\").click(function(){\r\n            $(this).siblings().css(\"color\",\"red\")\r\n            $(this).css(\"color\",\"green\")\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<div id=\"DemoTEST123\">\r\n    <button>测试1</button>\r\n    <button>测试2</button>\r\n    <button>测试3</button>\r\n    <button>测试4</button>\r\n    <button>测试5</button>\r\n</div>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#DemoTEST123>button\").click(function(){\r\n            $(this).siblings().css(\"color\",\"red\")\r\n            $(this).css(\"color\",\"green\")\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### 简易轮播图\r\n注意：\r\n* 可以通过`$(this).index()`函数获取当前元素的索引号\r\n* 需通过`jQueryObj.eq(index)`获取jQuery元素，`jQueryObj[index]`获取到的是DOM元素\r\n\r\n\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoBoxj02r002 .left li\").mouseenter(function(){\r\n            $(\"#demoBoxj02r002 .right li\").hide()\r\n            $(\"#demoBoxj02r002 .right li\").eq($(this).index()).show()\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demoBoxj02r002\">\r\n    <ul class=\"left\">\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n    </ul>\r\n    <ul class=\"right\">\r\n        <li style=\"background-color:skyblue;\">图片切换区</li>\r\n        <li style=\"background-color:pink;display: block;\">图片切换区</li>\r\n        <li style=\"background-color:green;\">图片切换区</li>\r\n        <li style=\"background-color:greenyellow;\">图片切换区</li>\r\n        <li style=\"background-color:yellow;\">图片切换区</li>\r\n        <li style=\"background-color:gold;\">图片切换区</li>\r\n        <li style=\"background-color:red;\">图片切换区</li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    #demoBoxj02r002 *,\r\n    #demoBoxj02r002 *::after,\r\n    #demoBoxj02r002 *::before{\r\n        content: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    #demoBoxj02r002{\r\n        display: flex;\r\n        justify-content: space-between;\r\n        align-items: flex-start;\r\n        width: 400px;\r\n        height: 400px;\r\n        background-color: #fff;\r\n    }\r\n    #demoBoxj02r002 .left{\r\n        display: flex;\r\n        flex-direction: column;\r\n        justify-content: space-evenly;\r\n        width: 100px;\r\n        height: 100%;\r\n        background-color: green;\r\n    }\r\n    #demoBoxj02r002 .left li{\r\n        flex: 1;\r\n        width: 100%;\r\n        background-color: white;\r\n        /* border: 5px solid gray; */\r\n        box-sizing: border-box;\r\n        color: black;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n    }\r\n    #demoBoxj02r002 .left li:hover{\r\n        background-color: gray;\r\n    }\r\n    #demoBoxj02r002 .right{\r\n        flex: 1;\r\n        height: 100%;\r\n        /* background-color: blue; */\r\n    }\r\n    #demoBoxj02r002 .right li{\r\n        display: none;\r\n        width: 100%;\r\n        height: 100%;\r\n        color: black;\r\n    }\r\n</style>\r\n\r\n\r\n```html\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoBoxj02r002 .left li\").mouseenter(function(){\r\n            $(\"#demoBoxj02r002 .right li\").hide()\r\n            $(\"#demoBoxj02r002 .right li\").eq($(this).index()).show()\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demoBoxj02r002\">\r\n    <ul class=\"left\">\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n    </ul>\r\n    <ul class=\"right\">\r\n        <li style=\"background-color:skyblue;\">图片切换区</li>\r\n        <li style=\"background-color:pink;display: block;\">图片切换区</li>\r\n        <li style=\"background-color:green;\">图片切换区</li>\r\n        <li style=\"background-color:greenyellow;\">图片切换区</li>\r\n        <li style=\"background-color:yellow;\">图片切换区</li>\r\n        <li style=\"background-color:gold;\">图片切换区</li>\r\n        <li style=\"background-color:red;\">图片切换区</li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    #demoBoxj02r002 *,\r\n    #demoBoxj02r002 *::after,\r\n    #demoBoxj02r002 *::before{\r\n        content: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    #demoBoxj02r002{\r\n        display: flex;\r\n        justify-content: space-between;\r\n        align-items: flex-start;\r\n        width: 400px;\r\n        height: 400px;\r\n        background-color: #fff;\r\n    }\r\n    #demoBoxj02r002 .left{\r\n        display: flex;\r\n        flex-direction: column;\r\n        justify-content: space-evenly;\r\n        width: 100px;\r\n        height: 100%;\r\n        background-color: green;\r\n    }\r\n    #demoBoxj02r002 .left li{\r\n        flex: 1;\r\n        width: 100%;\r\n        background-color: white;\r\n        /* border: 5px solid gray; */\r\n        box-sizing: border-box;\r\n        color: black;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n    }\r\n    #demoBoxj02r002 .left li:hover{\r\n        background-color: gray;\r\n    }\r\n    #demoBoxj02r002 .right{\r\n        flex: 1;\r\n        height: 100%;\r\n        /* background-color: blue; */\r\n    }\r\n    #demoBoxj02r002 .right li{\r\n        display: none;\r\n        width: 100%;\r\n        height: 100%;\r\n        color: black;\r\n    }\r\n</style>\r\n``` \r\n\r\n## jQuery样式操作\r\n* 对于**简单的样式**修改，可用css()方法实现\r\n  * **修改**css属性值：\r\n    * 方法1：`jQueryObj.css(\"属性名\"，属性值);`\r\n      * 属性名必须加双引号\r\n      * 属性名属性格式和css一致\r\n      * 属性值若是数字可以不加单位，不加双引号\r\n    * 方法2：`jQueryObj.css({\"属性名1\":属性值1,\"属性名2\":属性值2});`\r\n      * css(参数)；参数是一个对象\r\n      * 属性名可以不加双引号，若不加双引号则遵循驼峰命名法\r\n      * 属性名加双引号时，属性名书写和css属性名一致\r\n      * 属性值若是数字可以不加单位，不加引号\r\n  * **获取**css属性值：`jQueryObj.css(\"属性名\");`\r\n* 对**于复杂的样式**修改，可通过附加类名的方式实现\r\n  * 添加类名：`jQueryObj.addClass(\"类名\");`\r\n  * 移除类名：`jQueryObj.removeClass(\"类名\");`\r\n  * 切换类名：`jQueryObj.toggleClass(\"类名\");` 如果没有该类名，则附加，若有则移除\r\n\r\n\r\n\r\n### 案例练习\r\n#### tab栏切换\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n$(document).ready(function(){\r\n    $(\"#demo234r034930>ul>li\").click(function(){\r\n        $(this).addClass(\"actived\").siblings().removeClass(\"actived\")\r\n        $(\"#demo234r034930>ol>li\").eq($(this).index()).addClass(\"actived\").siblings().removeClass(\"actived\")\r\n    })\r\n})\r\n</script>\r\n<div id=\"demo234r034930\">\r\n    <ul>\r\n        <li class=\"actived\">栏目1</li>\r\n        <li>栏目2</li>\r\n        <li>栏目3</li>\r\n        <li>栏目4</li>\r\n    </ul>\r\n    <ol>\r\n        <li class=\"actived\">测试内容1</li>\r\n        <li>测试内容2</li>\r\n        <li>测试内容3</li>\r\n        <li>测试内容4</li>\r\n    </ol>\r\n</div>\r\n<style>\r\n    #demo234r034930 *,\r\n    #demo234r034930 *::after,\r\n    #demo234r034930 *::before{\r\n        content: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    #demo234r034930{\r\n        display: flex;\r\n        flex-direction:column;\r\n        justify-content: flex-start;\r\n        align-self: start;\r\n        width: 100%;\r\n        min-height: 500px;\r\n        background-color: #fff;\r\n    }\r\n    #demo234r034930>ul{\r\n        display: flex;\r\n        justify-content: flex-start;\r\n        align-items: center;\r\n        height: 50px;\r\n        /* background-color: gray; */\r\n    }\r\n    #demo234r034930>ul>li{\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        height: 100%;\r\n        font-size: 15px;\r\n        font-weight: bold;\r\n        padding: 0 20px;\r\n        color: black;\r\n    }\r\n    #demo234r034930>ul>li:hover{\r\n        background-color: red;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ul>li.actived{\r\n        background-color: red;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ol{\r\n        flex: 1;\r\n        background-color: skyblue;\r\n    }\r\n    #demo234r034930>ol>li{\r\n        display: none;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ol>li.actived{\r\n        display: block;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n$(document).ready(function(){\r\n    $(\"#demo234r034930>ul>li\").click(function(){\r\n        $(this).addClass(\"actived\").siblings().removeClass(\"actived\")\r\n        $(\"#demo234r034930>ol>li\").eq($(this).index()).addClass(\"actived\").siblings().removeClass(\"actived\")\r\n    })\r\n})\r\n</script>\r\n<div id=\"demo234r034930\">\r\n    <ul>\r\n        <li class=\"actived\">栏目1</li>\r\n        <li>栏目2</li>\r\n        <li>栏目3</li>\r\n        <li>栏目4</li>\r\n    </ul>\r\n    <ol>\r\n        <li class=\"actived\">测试内容1</li>\r\n        <li>测试内容2</li>\r\n        <li>测试内容3</li>\r\n        <li>测试内容4</li>\r\n    </ol>\r\n</div>\r\n<style>\r\n    #demo234r034930 *,\r\n    #demo234r034930 *::after,\r\n    #demo234r034930 *::before{\r\n        content: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    #demo234r034930{\r\n        display: flex;\r\n        flex-direction:column;\r\n        justify-content: flex-start;\r\n        align-self: start;\r\n        width: 100%;\r\n        min-height: 500px;\r\n        background-color: #fff;\r\n    }\r\n    #demo234r034930>ul{\r\n        display: flex;\r\n        justify-content: flex-start;\r\n        align-items: center;\r\n        height: 50px;\r\n        /* background-color: gray; */\r\n    }\r\n    #demo234r034930>ul>li{\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        height: 100%;\r\n        font-size: 15px;\r\n        font-weight: bold;\r\n        padding: 0 20px;\r\n        color: black;\r\n    }\r\n    #demo234r034930>ul>li:hover{\r\n        background-color: red;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ul>li.actived{\r\n        background-color: red;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ol{\r\n        flex: 1;\r\n        background-color: skyblue;\r\n    }\r\n    #demo234r034930>ol>li{\r\n        display: none;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ol>li.actived{\r\n        display: block;\r\n    }\r\n</style>\r\n```\r\n\r\n## jQuery效果\r\n### 显示隐藏\r\n* `jQueryObj.hide([speed,[easing],[callback]])`\r\n* `jQueryObj.show()`\r\n* `jQueryObj.toggle()` 显示隐藏效果的切换\r\n\r\n### 滑动\r\n* `jQueryObj.slideDown([speed,[easing],[callback]])`\r\n* `jQueryObj.slideUp([speed,[easing],[callback]])`\r\n* `jQueryObj.slideToggle([speed,[easing],[callback]])`\r\n\r\n### 淡入淡出\r\n* `jQueryObj.fadeIn([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeOut([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeToggle([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeTo()`\r\n\r\n### 自定义动画\r\n* `jQueryObj.animate()`\r\n\r\n\r\n### 测试使用效果\r\n\r\n#### 显示/隐藏测试\r\n\r\n* `jQueryObj.show([speed,[easing],[callback]])`\r\n* `jQueryObj.toggle([speed,[easing],[callback]])`\r\n* `jQueryObj.hide([speed,[easing],[callback]])`\r\n\r\n这几个函数的参数取值一致\r\n* **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n* **easing**取值: \r\n    * \"swing\" 慢-快-慢；默认取值\r\n    * \"linear\" 线性匀速\r\n* **callback** 回调函数 \r\n\r\n\r\n\r\n<button id=\"demoTesthide_btn1\" >不带参数show/hide：显示/隐藏测试</button>\r\n<button id=\"demoTesthide_btn2\" >带参数的show/hide：显示/隐藏测试</button>\r\n<div id=\"demoTesthide\" style=\"width: 100px;height: 100px;background-color: skyblue;\">显示/隐藏测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoTesthide_btn1\").click(function(){\r\n            $(\"#demoTesthide\").toggle()\r\n        })\r\n        $(\"#demoTesthide_btn2\").click(function(){\r\n            $(\"#demoTesthide\").toggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demoTesthide_btn1\" >不带参数show/hide：显示/隐藏测试</button>\r\n<button id=\"demoTesthide_btn2\" >带参数的show/hide：显示/隐藏测试</button>\r\n<div id=\"demoTesthide\" style=\"width: 100px;height: 100px;background-color: skyblue;\">显示/隐藏测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoTesthide_btn1\").click(function(){\r\n            $(\"#demoTesthide\").toggle()\r\n        })\r\n        $(\"#demoTesthide_btn2\").click(function(){\r\n            $(\"#demoTesthide\").toggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### 滑动测试\r\n\r\n\r\n* `jQueryObj.slideDown([speed,[easing],[callback]])`\r\n* `jQueryObj.slideUp([speed,[easing],[callback]])`\r\n* `jQueryObj.slideToggle([speed,[easing],[callback]])`\r\n\r\n这几个函数的参数取值一致\r\n* **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n* **easing**取值: \r\n    * \"swing\" 慢-快-慢；默认取值\r\n    * \"linear\" 线性匀速\r\n* **callback** 回调函数  \r\n\r\n<button id=\"demoTowweijfwe1\">不带参数slide：下滑动、上滑动测试</button>\r\n<button id=\"demoTowweijfwe2\">带参数的slide：下滑动、上滑动测试</button>\r\n<div id=\"demoTowweijfwe3\" style=\"width: 100px;height: 100px;background-color: skyblue;\">下滑动、上滑动测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoTowweijfwe1\").click(function(){\r\n            $(\"#demoTowweijfwe3\").slideToggle()\r\n        })\r\n        $(\"#demoTowweijfwe2\").click(function(){\r\n            $(\"#demoTowweijfwe3\").slideToggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n```html\r\n<button id=\"demoTowweijfwe1\">不带参数slide：下滑动、上滑动测试</button>\r\n<button id=\"demoTowweijfwe2\">带参数的slide：下滑动、上滑动测试</button>\r\n<div id=\"demoTowweijfwe3\" style=\"width: 100px;height: 100px;background-color: skyblue;\">下滑动、上滑动测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoTowweijfwe1\").click(function(){\r\n            $(\"#demoTowweijfwe3\").slideToggle()\r\n        })\r\n        $(\"#demoTowweijfwe2\").click(function(){\r\n            $(\"#demoTowweijfwe3\").slideToggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n#### 淡入淡出测试1\r\n\r\n* `jQueryObj.fadeIn([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeOut([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeToggle([speed,[easing],[callback]])`\r\n\r\n这几个函数的参数取值一致\r\n* **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n* **easing**取值: \r\n    * \"swing\" 慢-快-慢；默认取值\r\n    * \"linear\" 线性匀速\r\n* **callback** 回调函数  \r\n\r\n<button id=\"demofnwfo\">不带参数fade：淡入淡出测试</button>\r\n<button id=\"demofwioefog\">带参数的fade：淡入淡出测试</button>\r\n<div id=\"demoTowwedfwofwfp\" style=\"width: 100px;height: 100px;background-color: skyblue;\">淡入淡出测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnwfo\").click(function(){\r\n            $(\"#demoTowwedfwofwfp\").fadeToggle()\r\n        })\r\n        $(\"#demofwioefog\").click(function(){\r\n            $(\"#demoTowwedfwofwfp\").fadeToggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demofnwfo\">不带参数fadeToggle：淡入淡出测试</button>\r\n<button id=\"demofwioefog\">带参数的fadeToggle：淡入淡出测试</button>\r\n<div id=\"demoTowwedfwofwfp\" style=\"width: 100px;height: 100px;background-color: skyblue;\">淡入淡出测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnwfo\").click(function(){\r\n            $(\"#demoTowwedfwofwfp\").fadeToggle()\r\n        })\r\n        $(\"#demofwioefog\").click(function(){\r\n            $(\"#demoTowwedfwofwfp\").fadeToggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### 淡入淡出测试2\r\n\r\n* `jQueryObj.fadeTo( speed ,  opacity  [,[easing],[callback]])`\r\n\r\n* **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n* **opacity**取值： 透明度，小数\r\n* **easing**取值: \r\n    * \"swing\" 慢-快-慢；默认取值\r\n    * \"linear\" 线性匀速\r\n* **callback** 回调函数  \r\n\r\n<button id=\"demofnwfo123\">fadeTo测试</button>\r\n<div id=\"demoTowwedfwofwfp111\" style=\"width: 100px;height: 100px;background-color: skyblue;\">fadeTo测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnwfo123\").click(function(){\r\n            $(\"#demoTowwedfwofwfp111\").fadeTo(\"fast\",0.5)\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demofnwfo123\">fadeTo测试</button>\r\n<div id=\"demoTowwedfwofwfp111\" style=\"width: 100px;height: 100px;background-color: skyblue;\">fadeTo测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnwfo123\").click(function(){\r\n            $(\"#demoTowwedfwofwfp111\").fadeTo(\"fast\",0.5)\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### 动画测试\r\n* `jQueryObj.animate(params  [,speed,[easing],[callback]])`\r\n    * params是一个对象，其中属性名可以不带引号，复合属性需要驼峰命名法或者带引号\r\n    * 其他参数都可以省略\r\n    * **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n    * **easing**取值: \r\n        * \"swing\" 慢-快-慢；默认取值\r\n        * \"linear\" 线性匀速\r\n    * **callback** 回调函数  \r\n\r\n<button id=\"demofnfwef\">动画测试</button>\r\n<div style=\"position:relative;width: 100px;height: 100px;\">\r\n    <div id=\"demoToww3432\" style=\"position: absolute; width: 100px;height: 100px;background-color: skyblue;\">动画测试</div>\r\n</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnfwef\").click(function(){\r\n            $(\"#demoToww3432\").animate(\r\n                {\r\n                    \"top\":50,\r\n                    \"left\":100,\r\n                    \"opacity\":0.5,\r\n                    \"width\":50,\r\n                    \"height\":50\r\n                },\r\n                1000,//速度 1s\r\n                \"swing\"\r\n            )\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demofnfwef\">动画测试</button>\r\n<div style=\"position:relative;width: 100px;height: 100px;\">\r\n    <div id=\"demoToww3432\" style=\"position: absolute; width: 100px;height: 100px;background-color: skyblue;\">动画测试</div>\r\n</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnfwef\").click(function(){\r\n            $(\"#demoToww3432\").animate(\r\n                {\r\n                    \"top\":50,\r\n                    \"left\":100,\r\n                    \"opacity\":0.5,\r\n                    \"width\":50,\r\n                    \"height\":50\r\n                },\r\n                1000,//速度 1s\r\n                \"swing\"\r\n            )\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n### 案例练习\r\n\r\n王者荣耀手风琴效果\r\n\r\n主要思路：\r\n* 动画调整大盒子li的宽度\r\n* fadeIn、fadeOUt\r\n\r\n![](./images/jQuery学习笔记/2022-07-09-07-17-10.png)\r\n\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n$(document).ready(function(){\r\n    $(\"#wzryBox ul li\").mouseenter(function(){\r\n        // \r\n        $(this).siblings().stop().animate({width:50})\r\n        $(this).siblings().find(\".small\").stop().fadeIn()\r\n        $(this).siblings().find(\".big\").stop().fadeOut()\r\n        // \r\n        $(this).stop().animate({width:150})\r\n        $(this).find(\".small\").stop().fadeOut()\r\n        $(this).find(\".big\").stop().fadeIn()\r\n    })\r\n})\r\n</script>\r\n<div id=\"wzryBox\">\r\n    <h2>文字介绍</h2>\r\n    <ul>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    #wzryBox *,\r\n    #wzryBox *::after,\r\n    #wzryBox *::before{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        content: none;\r\n    }\r\n    #wzryBox{\r\n        padding: 0 5px;\r\n        width: 650px;\r\n        height: 85px;\r\n        background-color: skyblue;\r\n    }\r\n    #wzryBox h2{\r\n        display: inline-block;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        font-size: 10px;\r\n        color: gray;\r\n    }\r\n    #wzryBox ul{\r\n        display: flex;\r\n    }\r\n    #wzryBox ul li{\r\n        margin: 0 2.5px;\r\n        height: 50px;\r\n        width: 50px;\r\n        border-radius: 5px;\r\n        /* background-color: white; */\r\n    }\r\n    #wzryBox ul li a{\r\n        position: relative;\r\n        display: block;\r\n        height: 50px;\r\n        min-width: 50px;\r\n    }\r\n    #wzryBox ul li a .small{\r\n        display: block;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: red;\r\n        border-radius: 5px;\r\n    }\r\n    #wzryBox ul li a .big{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        width: 150px;\r\n        height: 50px;\r\n        background-color: green;\r\n        border-radius: 5px;\r\n    }\r\n    #wzryBox ul li:nth-child(1){\r\n        width: 150px;\r\n    }\r\n    #wzryBox ul li:nth-child(1) a .big{\r\n        display: block;\r\n    }\r\n    #wzryBox ul li:nth-child(1) a .small{\r\n        display: none;\r\n    }\r\n</style>\r\n\r\n\r\n```html\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n$(document).ready(function(){\r\n    $(\"#wzryBox ul li\").mouseenter(function(){\r\n        // \r\n        $(this).siblings().stop().animate({width:50})\r\n        $(this).siblings().find(\".small\").stop().fadeIn()\r\n        $(this).siblings().find(\".big\").stop().fadeOut()\r\n        // \r\n        $(this).stop().animate({width:150})\r\n        $(this).find(\".small\").stop().fadeOut()\r\n        $(this).find(\".big\").stop().fadeIn()\r\n    })\r\n})\r\n</script>\r\n<div id=\"wzryBox\">\r\n    <h2>文字介绍</h2>\r\n    <ul>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    #wzryBox *,\r\n    #wzryBox *::after,\r\n    #wzryBox *::before{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        content: none;\r\n    }\r\n    #wzryBox{\r\n        padding: 0 5px;\r\n        width: 650px;\r\n        height: 85px;\r\n        background-color: skyblue;\r\n    }\r\n    #wzryBox h2{\r\n        display: inline-block;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        font-size: 10px;\r\n        color: gray;\r\n    }\r\n    #wzryBox ul{\r\n        display: flex;\r\n    }\r\n    #wzryBox ul li{\r\n        margin: 0 2.5px;\r\n        height: 50px;\r\n        width: 50px;\r\n        border-radius: 5px;\r\n        /* background-color: white; */\r\n    }\r\n    #wzryBox ul li a{\r\n        position: relative;\r\n        display: block;\r\n        height: 50px;\r\n        min-width: 50px;\r\n    }\r\n    #wzryBox ul li a .small{\r\n        display: block;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: red;\r\n        border-radius: 5px;\r\n    }\r\n    #wzryBox ul li a .big{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        width: 150px;\r\n        height: 50px;\r\n        background-color: green;\r\n        border-radius: 5px;\r\n    }\r\n    #wzryBox ul li:nth-child(1){\r\n        width: 150px;\r\n    }\r\n    #wzryBox ul li:nth-child(1) a .big{\r\n        display: block;\r\n    }\r\n    #wzryBox ul li:nth-child(1) a .small{\r\n        display: none;\r\n    }\r\n</style>\r\n```\r\n\r\n## hover事件切换\r\n`jQueryObj.hover([over,]out)`\r\n* over:回调函数，mouseenter事件触发后调用\r\n* out：回调函数，mouseleaver事件触发后调用\r\n* 只写一个回调函数时表示，mouseenter事件和mouseleaver事件触发均调用该函数\r\n\r\n<script>\r\n    $(function () {//DOMContentLoaded\r\n    //原先写法：\r\n            // $(\"ul#demofiwuwhfi>li\").mouseenter(function () { //应当注册给不支持冒泡的mouseenter事件\r\n            //     $(this).children(\"ul\").show()\r\n            // });\r\n            // $(\"ul#demofiwuwhfi>li\").mouseleave(function () { //应当注册给不支持冒泡的mouseleave事件\r\n            //     $(this).children(\"ul\").hide()\r\n            // });\r\n    //hover写法：\r\n        //hover的两个实参均为回调函数，分别对应mouseenter和mouseleave事件\r\n            // $(\"ul#demofiwuwhfi>li\").hover(\r\n            //     function () {\r\n            //         $(this).children(\"ul\").slideDown(200)\r\n            //     },\r\n            //     function(){\r\n            //         $(this).children(\"ul\").slideUp(100)\r\n            //     }\r\n            // );\r\n        //hover只写一个参数时，表示两个事件均触发该事件\r\n            $(\"ul#demofiwuwhfi>li\").hover(function () {\r\n                $(this).children(\"ul\").slideToggle(200)\r\n            });\r\n    });\r\n</script>\r\n<ul id=\"demofiwuwhfi\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demofiwuwhfi,\r\n    ul#demofiwuwhfi *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demofiwuwhfi *::before,\r\n    ul#demofiwuwhfi *::after{\r\n        content: none;\r\n    }\r\n    ul#demofiwuwhfi{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demofiwuwhfi>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demofiwuwhfi>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demofiwuwhfi>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demofiwuwhfi>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script>\r\n    $(function () {//DOMContentLoaded\r\n    //原先写法：\r\n            // $(\"ul#demofiwuwhfi>li\").mouseenter(function () { //应当注册给不支持冒泡的mouseenter事件\r\n            //     $(this).children(\"ul\").show()\r\n            // });\r\n            // $(\"ul#demofiwuwhfi>li\").mouseleave(function () { //应当注册给不支持冒泡的mouseleave事件\r\n            //     $(this).children(\"ul\").hide()\r\n            // });\r\n    //hover写法：\r\n        //hover的两个实参均为回调函数，分别对应mouseenter和mouseleave事件\r\n            // $(\"ul#demofiwuwhfi>li\").hover(\r\n            //     function () {\r\n            //         $(this).children(\"ul\").slideDown(200)\r\n            //     },\r\n            //     function(){\r\n            //         $(this).children(\"ul\").slideUp(100)\r\n            //     }\r\n            // );\r\n        //hover只写一个参数时，表示两个事件均触发该事件\r\n            $(\"ul#demofiwuwhfi>li\").hover(function () {\r\n                $(this).children(\"ul\").slideToggle(200)\r\n            });\r\n    });\r\n</script>\r\n<ul id=\"demofiwuwhfi\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demofiwuwhfi,\r\n    ul#demofiwuwhfi *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demofiwuwhfi *::before,\r\n    ul#demofiwuwhfi *::after{\r\n        content: none;\r\n    }\r\n    ul#demofiwuwhfi{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demofiwuwhfi>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demofiwuwhfi>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demofiwuwhfi>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demofiwuwhfi>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n```\r\n\r\n## 动画：stop()停止排队\r\n* stop()函数可以停止排队,必须写在动画之前\r\n* 用来暂停队列中未播放完毕的动画\r\n\r\n<script>\r\n    $(function () {//DOMContentLoaded\r\n        //原先写法： 当鼠标在li之间快速移动时，由于动画是被丢入了队列，动画会排队播放完毕后再播放下一个动画\r\n            // $(\"ul#demonwoefh945fj0e>li\").hover(function () {\r\n                // $(this).children(\"ul\").slideToggle(200)\r\n            // });\r\n        // stop()函数可以停止排队\r\n            $(\"ul#demonwoefh945fj0e>li\").hover(function () {\r\n                $(this).children(\"ul\").stop()\r\n                $(this).children(\"ul\").slideToggle(200)\r\n                // $(this).children(\"ul\").stop().slideToggle(200) //链式写法\r\n            }); \r\n    });\r\n</script>\r\n<ul id=\"demonwoefh945fj0e\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demonwoefh945fj0e,\r\n    ul#demonwoefh945fj0e *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demonwoefh945fj0e *::before,\r\n    ul#demonwoefh945fj0e *::after{\r\n        content: none;\r\n    }\r\n    ul#demonwoefh945fj0e{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demonwoefh945fj0e>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demonwoefh945fj0e>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demonwoefh945fj0e>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script>\r\n    $(function () {//DOMContentLoaded\r\n        //原先写法： 当鼠标在li之间快速移动时，由于动画是被丢入了队列，动画会排队播放完毕后再播放下一个动画\r\n            // $(\"ul#demonwoefh945fj0e>li\").hover(function () {\r\n                // $(this).children(\"ul\").slideToggle(200)\r\n            // });\r\n        // stop()函数可以停止排队\r\n            $(\"ul#demonwoefh945fj0e>li\").hover(function () {\r\n                $(this).children(\"ul\").stop()\r\n                $(this).children(\"ul\").slideToggle(200)\r\n                // $(this).children(\"ul\").stop().slideToggle(200) //链式写法\r\n            }); \r\n    });\r\n</script>\r\n<ul id=\"demonwoefh945fj0e\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demonwoefh945fj0e,\r\n    ul#demonwoefh945fj0e *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demonwoefh945fj0e *::before,\r\n    ul#demonwoefh945fj0e *::after{\r\n        content: none;\r\n    }\r\n    ul#demonwoefh945fj0e{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demonwoefh945fj0e>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demonwoefh945fj0e>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demonwoefh945fj0e>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n```\r\n\r\n## Jquery内容操作\r\n**设置/获取元素内容**\r\n* `jQueryObj.html()` 获取内容，相当于`element.innerHTML`\r\n* `jQueryObj.html(value)` 写入内容，相当于`element.innerHTML=value`\r\n\r\n**设置/获取元素文本**\r\n* `jQueryObj.text()` 获取内容，相当于`element.innerText`\r\n* `jQueryObj.text(value)` 写入内容，相当于`element.innerText=value`\r\n\r\n**设置/获取表单值**\r\n* `jQueryObj.val()` 获取内容，相当于`element.value`\r\n* `jQueryObj.val(value)` 写入内容，相当于`element.value=value`\r\n\r\n### 案例练习\r\n\r\n**增减商品数量**\r\n* 若要根据单价计算总价，如要保留两位小数，使用`value.toFixed(2)`函数\r\n\r\n\r\n<script>\r\n    $(document).ready(function(){\r\n        //按钮+\r\n        $(\"#demo2j4r20 > .box > .add\").click(function(){\r\n            var value = $(this).siblings(\".count\").val()\r\n            value++;\r\n            $(this).siblings(\".count\").val(value)\r\n            $(this).siblings(\".count\").text( value )\r\n            $(this).siblings(\"span\").text(value.toFixed(2))//测试\r\n        });\r\n        //按钮-\r\n        $(\"#demo2j4r20 > .box > .min\").click(function(){\r\n            var value = $(this).siblings(\".count\").val()\r\n            if(value>1){\r\n                value--;\r\n                $(this).siblings(\".count\").val(value)\r\n            }\r\n            $(this).siblings(\".count\").text( value )\r\n            $(this).siblings(\"span\").text(value.toFixed(2))//测试\r\n        });\r\n        //文本框输入\r\n        $(\"#demo2j4r20 > .box > .count\").keyup(function(){\r\n            var value =Number( $(this).val() )\r\n            if(typeof value == \"number\" && value>=1)//判断是否是数字,且大于1\r\n            {\r\n                $(this).val(value)\r\n                $(this).siblings(\"span\").text(value.toFixed(2))//测试\r\n            }else\r\n            {\r\n                $(this).val(1)\r\n                $(this).siblings(\"span\").text(\"1.00\")//测试\r\n            }\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demo2j4r20\">\r\n    <div class=\"box\" >\r\n        <button class=\"min\">-</button><input  class=\"count\" type=\"text\" value=\"1\"><button class=\"add\">+</button>\r\n        <br>当前值（保留两位小数测试）：<span>1.00</span>\r\n    </div>\r\n    <div class=\"box\">\r\n        <button class=\"min\">-</button><input  class=\"count\" type=\"text\" value=\"1\"><button class=\"add\">+</button>\r\n        <br>当前值（保留两位小数测试）：<span>1.00</span>\r\n    </div>\r\n</div>\r\n<style>\r\n    #demo2j4r20 .box button,\r\n    #demo2j4r20 .box .count{\r\n        display: inline-block;\r\n        padding: 0;\r\n        margin: 0;\r\n        height:25px;\r\n        line-height:25px;\r\n        border: 1px solid gray;\r\n        box-sizing: border-box;\r\n        outline: none;\r\n        text-align: center;\r\n        vertical-align: middle;\r\n        background-color: white;\r\n        color: black;\r\n    }\r\n    #demo2j4r20  .box button{\r\n        width:25px;\r\n        cursor: pointer;\r\n    }\r\n    #demo2j4r20  .box .count{\r\n        width: 40px;\r\n        background-color: whitesmoke;\r\n    }\r\n    #demo2j4r20  .box p{\r\n        width: 40px;\r\n    }\r\n</style>\r\n\r\n\r\n```html\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demo2j4r20> .box >.add\").click(function(){\r\n            var value = $(this).siblings(\".count\").val()\r\n            value++;\r\n            $(this).siblings(\".count\").val(value)\r\n            $(this).siblings(\".count\").text( value )\r\n            $(this).siblings(\"span\").text(value.toFixed(2))//测试\r\n        });\r\n        $(\"#demo2j4r20> .box>.min\").click(function(){\r\n            var value = $(this).siblings(\".count\").val()\r\n            if(value>1){\r\n                value--;\r\n                $(this).siblings(\".count\").val(value)\r\n            }\r\n            $(this).siblings(\".count\").text( value )\r\n            $(this).siblings(\"span\").text(value)//测试\r\n        });\r\n        $(\"#demo2j4r20>.count\").keyup(function(){\r\n            var value = $(this).val()\r\n            $(this).val(value)\r\n            $(this).siblings(\"span\").text(value)//测试\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demo2j4r20\">\r\n    <div class=\"box\" >\r\n        <button class=\"min\">-</button><input  class=\"count\" type=\"text\" value=\"1\"><button class=\"add\">+</button>\r\n        <br>当前值（保留两位小数测试）：<span>1.00</span>\r\n    </div>\r\n    <div class=\"box\">\r\n        <button class=\"min\">-</button><input  class=\"count\" type=\"text\" value=\"1\"><button class=\"add\">+</button>\r\n        <br>当前值（保留两位小数测试）：<span>1.00</span>\r\n    </div>\r\n</div>\r\n<style>\r\n    #demo2j4r20 .box button,\r\n    #demo2j4r20 .box .count{\r\n        display: inline-block;\r\n        padding: 0;\r\n        margin: 0;\r\n        height:25px;\r\n        line-height:25px;\r\n        border: 1px solid gray;\r\n        box-sizing: border-box;\r\n        outline: none;\r\n        text-align: center;\r\n        vertical-align: middle;\r\n        background-color: white;\r\n        color: black;\r\n    }\r\n    #demo2j4r20  .box button{\r\n        width:25px;\r\n        cursor: pointer;\r\n    }\r\n    #demo2j4r20  .box .count{\r\n        width: 40px;\r\n        background-color: whitesmoke;\r\n    }\r\n    #demo2j4r20  .box p{\r\n        width: 40px;\r\n    }\r\n</style>\r\n```\r\n\r\n## Jquery属性操作\r\n* `jQueryObj.prop(\"固有属性名\")` 获取属性值 类似原生js的 `element.内置属性名`\r\n* `jQueryObj.prop(\"固有属性名\",value)` 设置属性值 类似原生js的 `element.内置属性名=属性值`\r\n* `jQueryObj.attr(\"自定义属性名\")` 获取属性值 类似原生js的`getAttribute()`\r\n* `jQueryObj.attr(\"自定义属性名\",value)` 设置属性值 类似原生js的`setAttribute()`\r\n* `jQueryObj.data(\"键名\")` **数据缓存** 获取存放在dom对象中的键值 \r\n* `jQueryObj.data(\"键名\",键值)` **数据缓存** 设置存放在dom对象中的键值对 \r\n    * 注意这种方式的键值对不是存放在html标签中的，而是存储在标签的dom对象中的，且经测试，可以包含中划线，甚至是中文，\r\n    * 经测试data()无法获取到html标签的属性data-yearlyPlan,似乎不能支持大小写\r\n    * 这种方式也能获取data-index的属性值，data(\"index\")，且相比于getAttribute有一点不同，该函数能获取到数字的值\r\n    * `element.dataset[\"index\"]`这种方式获取到的是html标签中的data-index属性\r\n    * `jQueryObj.data(\"index\")` 这种方式获取到的是html标签的DOM对象中的data-index属性,也可以获取html标签中data-开头的属性\r\n\r\n\r\n**属性操作测试**\r\n\r\n<div id=\"demofwuf210\">\r\n    <a href=\"https://test1.com\">这里有一个固有属性href，其值为: </a>\r\n    <br>\r\n    <a index=\"测试2\">这里有一个自定义属性index，其值为: </a>\r\n    <br>\r\n    <a >该标签的DOM对象中存储了一个属性，其值为: </a>\r\n</div>\r\n<script>\r\n    $(\"#demofwuf210>a:eq(0)\")[0].innerText+=$(\"#demofwuf210>a:eq(0)\").prop(\"href\")\r\n    $(\"#demofwuf210>a:eq(1)\")[0].innerText+=$(\"#demofwuf210>a:eq(1)\").attr(\"index\")\r\n    $(\"#demofwuf210>a:eq(2)\").data(\"test3-中文\",\"测试3\")\r\n    $(\"#demofwuf210>a:eq(2)\")[0].innerText+=$(\"#demofwuf210>a:eq(2)\").data(\"test3-中文\")\r\n</script>\r\n\r\n```html\r\n<div id=\"demofwuf210\">\r\n    <a href=\"https://test1.com\">这里有一个固有属性href，其值为: </a>\r\n    <br>\r\n    <a index=\"测试2\">这里有一个自定义属性index，其值为: </a>\r\n    <br>\r\n    <a >该标签的DOM对象中存储了一个属性，其值为: </a>\r\n</div>\r\n<script>\r\n    $(\"#demofwuf210>a:eq(0)\")[0].innerText+=$(\"#demofwuf210>a:eq(0)\").prop(\"href\")\r\n    $(\"#demofwuf210>a:eq(1)\")[0].innerText+=$(\"#demofwuf210>a:eq(1)\").attr(\"index\")\r\n    $(\"#demofwuf210>a:eq(2)\").data(\"test3-中文\",\"测试3\")\r\n    $(\"#demofwuf210>a:eq(2)\")[0].innerText+=$(\"#demofwuf210>a:eq(2)\").data(\"test3-中文\")\r\n</script>\r\n```\r\n\r\n案例练习\r\n\r\n<script>\r\n    $(document).ready(function()\r\n    {\r\n        $(\"#demo2j3r0924>.checkAll\").change(function(){\r\n            //单选框的状态由全选框的状态决定\r\n            $(\"#demo2j3r0924>input\").prop(\"checked\",$(this).prop(\"checked\"))\r\n        })\r\n        $(\"#demo2j3r0924>.items\").change(function(){\r\n            //功能：所以单选框打钩后，将全选框也打钩，若有任何单选框为打钩，则全选框不打勾\r\n            //判断是否全部打钩\r\n            if($(\"#demo2j3r0924>.items:checked\").length== $(\"#demo2j3r0924>.items\").length)\r\n            {\r\n                //给全选框打钩\r\n                $(this).siblings(\".checkAll\").prop(\"checked\",true)\r\n            }else{\r\n                //给全选框取消打钩\r\n                $(this).siblings(\".checkAll\").prop(\"checked\",false)\r\n            }\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demo2j3r0924\">\r\n    全选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"checkAll\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    全选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"checkAll\"><br>\r\n</div>\r\n\r\n```html\r\n<script>\r\n    $(document).ready(function()\r\n    {\r\n        $(\"#demo2j3r0924>.checkAll\").change(function(){\r\n            //单选框的状态由全选框的状态决定\r\n            $(\"#demo2j3r0924>input\").prop(\"checked\",$(this).prop(\"checked\"))\r\n        })\r\n        $(\"#demo2j3r0924>.items\").change(function(){\r\n            //功能：所以单选框打钩后，将全选框也打钩，若有任何单选框为打钩，则全选框不打勾\r\n            //判断是否全部打钩\r\n            if($(\"#demo2j3r0924>.items:checked\").length== $(\"#demo2j3r0924>.items\").length)\r\n            {\r\n                //给全选框打钩\r\n                $(this).siblings(\".checkAll\").prop(\"checked\",true)\r\n            }else{\r\n                //给全选框取消打钩\r\n                $(this).siblings(\".checkAll\").prop(\"checked\",false)\r\n            }\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demo2j3r0924\">\r\n    全选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"checkAll\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    全选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"checkAll\"><br>\r\n</div>\r\n```\r\n\r\n\r\n\r\n## 元素操作\r\n\r\n### 遍历\r\n\r\n\r\n#### each()遍历\r\n* each遍历操作用于针对同一类元素做不同操作，类似for但又比for强大\r\n* each()的回调函数的**第一个参数是索引**，**第二个参数是元素的DOM对象**\r\n\r\n**例程**\r\n<div id=\"demownefu02\">\r\n    <div>1</div>\r\n    <div>2</div>\r\n    <div>3</div>\r\n    <div>4</div>\r\n    <div>5</div>\r\n    <div>6</div>\r\n    <div>7</div>\r\n    <div>8</div>\r\n    <div>9</div>\r\n    <div>10</div>\r\n</div>\r\n<script>\r\n    $(document).ready(function(){\r\n        function getColor(r,g,b)\r\n        {\r\n            return \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        }\r\n        $(\"#demownefu02>div\").each(function(index,DOMElementObj){\r\n            if(index%3==0)\r\n                $(DOMElementObj).css(\"background-color\",getColor(index*30,0,0))\r\n            else if(index%3==1)\r\n                $(DOMElementObj).css(\"background-color\",getColor(0,index*30,0))\r\n            else\r\n                $(DOMElementObj).css(\"background-color\",getColor(0,0,index*30))\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demownefu02\">\r\n    <div>1</div>\r\n    <div>2</div>\r\n    <div>3</div>\r\n    <div>4</div>\r\n    <div>5</div>\r\n    <div>6</div>\r\n    <div>7</div>\r\n    <div>8</div>\r\n    <div>9</div>\r\n    <div>10</div>\r\n</div>\r\n<script>\r\n    $(document).ready(function(){\r\n        function getColor(r,g,b)\r\n        {\r\n            return \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        }\r\n        $(\"#demownefu02>div\").each(function(index,DOMElementObj){\r\n            if(index%3==0)\r\n                $(DOMElementObj).css(\"background-color\",getColor(index*30,0,0))\r\n            else if(index%3==1)\r\n                $(DOMElementObj).css(\"background-color\",getColor(0,index*30,0))\r\n            else\r\n                $(DOMElementObj).css(\"background-color\",getColor(0,0,index*30))\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### $.each()遍历\r\n* $.each()主要用于数据处理,遍历数组，对象\r\n* each()的第一个参数是待遍历的数据对象，第二个参数是回调函数，回调函数的**第一个参数是数据的索引**，**第二个参数数据的值**\r\n* 格式：$.each(遍历数据,function(index,DOMElementObj){})\r\n* 用处：可以用来遍历表单，获取关键值，做数据处理工作\r\n\r\n**遍历数据：遍历数组测试**\r\n<div id=\"demojfi02rjf0\"></div>\r\n<script>\r\n    var list=[\"DingYigui\",\"HaHaHa\",\"男\"];\r\n    $.each(list,function(index,value){\r\n        $(\"#demojfi02rjf0\").html($(\"#demojfi02rjf0\").html() + index + \":\" + value + \"<br>\" )\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demojfi02rjf0\"></div>\r\n<script>\r\n    var list=[\"DingYigui\",\"HaHaHa\",\"男\"];\r\n    $.each(list,function(index,value){\r\n        $(\"#demojfi02rjf0\").html($(\"#demojfi02rjf0\").html() + index + \":\" + value + \"<br>\" )\r\n    })\r\n</script>\r\n```\r\n\r\n**遍历数据：遍历对象测试**\r\n\r\n<div id=\"demojfi0123123dfw\"></div>\r\n<script>\r\n    var list={\r\n        \"键1\":\"值1\",\r\n        \"键2\":\"值2\",\r\n        \"键3（数组）\":[0,1,2],\r\n        \"键4（对象）\":{\r\n            \"1\":1,\r\n            \"2\":2\r\n        }\r\n    };\r\n    $.each(list,function(index,value){\r\n        $(\"#demojfi0123123dfw\").html($(\"#demojfi0123123dfw\").html() + index + \":\" + value + \"<br>\" )\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demojfi0123123dfw\"></div>\r\n<script>\r\n    var list={\r\n        \"键1\":\"值1\",\r\n        \"键2\":\"值2\",\r\n        \"键3（数组）\":[0,1,2],\r\n        \"键4（对象）\":{\r\n            \"1\":1,\r\n            \"2\":2\r\n        }\r\n    };\r\n    $.each(list,function(index,value){\r\n        $(\"#demojfi0123123dfw\").html($(\"#demojfi0123123dfw\").html() + index + \":\" + value + \"<br>\" )\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n### 创建、添加、删除元素\r\n\r\n* 创建元素： `var newjQueryObj = $(\"<div></div>\");`\r\n* 添加元素：\r\n    * 内部末尾附加：`jQueryObj.append(newjQueryObj);`\r\n    * 内部开头附加：`jQueryObj.prepend(newjQueryObj);`\r\n    * 外部之后附加：`jQueryObj.after(newjQueryObj);`\r\n    * 外部之前附加：`jQueryObj.before(newjQueryObj);`\r\n* 删除元素：\r\n    * 删除元素本身：`jQueryObj.remove();`\r\n    * 删除元素子集：`jQueryObj.remove(选择器表达式);`\r\n    * 删除元素内容：`jQueryObj.empty();`\r\n    * 删除元素内容：`jQueryObj.html(\"\");`\r\n    \r\n<div id=\"demo3je02\">\r\n\r\n</div>\r\n<script>\r\n    var newDiv = $(\"<div>1</div>\");\r\n    $(\"#demo3je02\").append(newDiv);\r\n    $(\"#demo3je02\").prepend(newDiv);\r\n    $(\"#demo3je02\").after(newDiv);\r\n    $(\"#demo3je02\").before(newDiv);\r\n    $(\"#demo3je02\").remove()\r\n</script>\r\n<style>\r\n    #demo3je02,\r\n    #demo3je02 *{\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n\r\n\r\n## jQuery尺寸及位置\r\n### jQuery尺寸\r\n\r\n**设置或获取jQuery尺寸：**\r\n* 参数为空时，作用为获取相应值，返回数字型，无单位\r\n* 参数为数时，作用为设置相应值，实参数字型，无单位\r\n* 方法\r\n    * `jQweryObj.width()` content\r\n    * `jQweryObj.height()` content\r\n    * `jQweryObj.innerWidth()` content+padding\r\n    * `jQweryObj.innerHeight()` content+padding\r\n    * `jQweryObj.outerWidth()` content+padding+border\r\n    * `jQweryObj.outerHeight()` content+padding+border\r\n    * `jQweryObj.outerWidth(true)` content+padding+border+margin\r\n    * `jQweryObj.outerHeight(true)` content+padding+border+margin\r\n\r\n![](./images/jQuery学习笔记/2022-07-13-06-16-23.png)\r\n\r\n### jQuery位置\r\n* `jQweryObj.offset()` 相对于**文档**的位置；\r\n    * 无参数返回的是对象，拥有top，left属性，数值型，无单位\r\n    * 有参数是设置,传入的是对象，`jQweryObj.offset({top:100,left:100})`\r\n* `jQweryObj.position()`  相对于有定位的父级，没有定位则相对于文档\r\n    * 该方法只能获取偏移值，不能设置\r\n* `jQweryObj.scrollTop()` 被卷去的顶部的高度\r\n    * 可以传入参数，设置被卷去的高度\r\n* `jQweryObj.scrollLeft()` 被卷去的左侧的宽度\r\n\r\n\r\n**页面滚动到指定位置后显示某元素**\r\n<div id=\"demofwuf0h9\" style=\"width: 200px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; color: black;\">\r\n    页面滚动到指定位置后显示测试\r\n</div>\r\n<script>\r\n    var offsetTop =  $(\"#demofwuf0h9\").offset().top\r\n    $(window).scroll(function(){\r\n        if($(this).scrollTop()>offsetTop-200)\r\n            $(\"#demofwuf0h9\").fadeIn()\r\n        else\r\n            $(\"#demofwuf0h9\").fadeOut()\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demofwuf0h9\" style=\"width: 100px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; color: black;\">\r\n    返回顶部\r\n</div>\r\n<script>\r\n    $(window).scroll(function(){\r\n        if($(this).scrollTop()>100)\r\n            $(\"#demofwuf0h9\").fadeIn()\r\n        else\r\n            $(\"#demofwuf0h9\").fadeOut()\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n**动态返回顶部按钮测试**\r\n* 利用animate方法中的scrollTop\r\n* 注意事件添加给body,html\r\n\r\n<div id=\"demofi2f0\" style=\"width: 100px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; color: black;\">\r\n    动态返回顶部\r\n</div>\r\n<script>\r\n    $(\"#demofi2f0\").click(function(){\r\n        // $(document).scrollTop(0) //返回顶部无动画版\r\n        $(\"html,body\").animate({scrollTop:0})\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demofi2f0\" style=\"width: 100px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; color: black;\">\r\n    动态返回顶部\r\n</div>\r\n<script>\r\n    $(\"#demofi2f0\").click(function(){\r\n        // $(document).scrollTop(0) //返回顶部无动画版\r\n        $(\"html,body\").animate({scrollTop:0})\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n<!-- **电梯导航** -->\r\n<!-- <div id=\"demof82040\"></div>\r\n<script>\r\n    function getItems(selector){\r\n        var ul = $(\"<ul></ul>\" )\r\n        $(selector).each(function(index,DOMelement){\r\n            var li = $(\"<li></li>\" )\r\n            ul.append( $(DOMelement).text() )\r\n        });\r\n        return ul;\r\n    }\r\n    var ul = $(\"<ul></ul>\" )\r\n    // var currentTagName = \r\n        $(\"h1,h2,h3,h4,h5,h6\").each(function(index,DOMelement){\r\n            if(DOMelement.tagName<=currentTagName)\r\n            {\r\n                var li = $(\"<li></li>\" )\r\n            }\r\n\r\n            ul.append( $(DOMelement).text() )\r\n        });\r\n    $(\"#demof82040\").append(ul)\r\n</script> -->\r\n\r\n## JQuery事件\r\n\r\n### 事件注册\r\n```js\r\njQueryObj.事件名(function(){事件处理程序})\r\n```\r\n\r\n### 事件解绑\r\n* `jQueryObj.off()` 解绑所有事件处理程序\r\n* `jQueryObj.off(\"click\")` 解绑所有click事件处理程序\r\n* `jQueryObj.off(\"click\",\"li\")` 解绑对li的click事件委托\r\n* 对于想只触发一次的事件后就解绑的事件，可用one()方法来绑定\r\n\r\n### 事件处理\r\n* `on()`方法可在元素上为**多个事件**绑定事件处理处理函数\r\n* 优点\r\n    * 多个事件可共用一个事件处理函数\r\n    * 可分别为不同事件指定事件处理函数\r\n    * 该方法对于绑定事件之后动态创建的元素仍然生效\r\n\r\n* 语法： `jQueryObj.on(events,[selector],callback)`\r\n    * `events` 一个或多个用空格分隔的事件类型\r\n    * `selector` 元素的子元素选择器\r\n    * `callback` 回调函数\r\n* `on()`方法 对应老版本的`bind()` `live()` `delegate()`方法\r\n\r\n**多个事件共用一个事件处理函数**\r\n```js\r\njQueryObj.on(\"mouseenter click mouseleave\",function(){\r\n    //do someting\r\n})\r\n```\r\n\r\n**分别为不同事件指定事件处理函数**\r\n```js\r\njQueryObj.on({\r\n    mouseenter:function(){\r\n        //do someting \r\n    }\r\n    mouseleave:function(){\r\n        //do someting \r\n    }\r\n})\r\n```\r\n\r\n**事件委派**\r\n```js\r\n$(\"ul\").on(\"click\",\"li\",function(){\r\n    // do someting\r\n})\r\n```\r\n\r\n\r\n### 触发事件\r\n* `jQueryObj.事件名()`\r\n    * 会触发元素的默认行为\r\n    * 默认行为：如表单获取焦点后会有光标闪烁\r\n* `jQueryObj.trigger(\"事件名\")`\r\n    * 会触发元素的默认行为\r\n* `jQueryObj.triggerHandler(\"事件名\")` \r\n    * 不会触发元素的默认行为\r\n\r\n### 事件对象\r\n* event就是事件对象\r\n* 阻止默认行为：\r\n    * event.preventDefault()\r\n    * return false\r\n* 阻止冒泡：\r\n    * event.stopPropagation()\r\n```js\r\n$(\"ul\").on(\"click\",\"li\",function(event){\r\n    // do someting\r\n})\r\n```\r\n\r\n\r\n### 案例测试\r\n\r\n**事件委派测试：留言板删除键**\r\n\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demov92wufh9>div>button\").click(function(){\r\n            var text = $(this).siblings(\"textarea\").val()\r\n            if(text!=\"\")\r\n            {\r\n                var newLi = $(\"<li></li>\")\r\n                newLi.html(text+ \"<button>删除</button>\")\r\n                newLi.hide()\r\n                $(\"#demov92wufh9 > ul\").prepend(newLi)\r\n                newLi.slideDown()\r\n                $(this).siblings(\"textarea\").val(\"\")\r\n            }\r\n        })\r\n        $(\"#demov92wufh9>ul\").on(\"click\",\"button\",function(){\r\n            $(this).parent().slideUp(function(){\r\n                $(this).remove()\r\n            })\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demov92wufh9\">\r\n    <div>\r\n        <textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"></textarea><button>发布</button>\r\n    </div>\r\n    <ul>\r\n        <li>测试文字1<button>删除</button></li>\r\n        <li>测试文字2<button>删除</button></li>\r\n        <li>测试文字3<button>删除</button></li>\r\n        <li>测试文字4<button>删除</button></li>\r\n    </ul>\r\n</div>\r\n<style>\r\n     #demov92wufh9 *::after,\r\n     #demov92wufh9 *::before{\r\n        content: none;\r\n        display: none;\r\n     }\r\n    #demov92wufh9 *{\r\n        border: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        box-sizing: border-box;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n    #demov92wufh9{\r\n        width: 100%;\r\n        height: 500px;\r\n        background-color: skyblue;\r\n    }\r\n    #demov92wufh9 textarea{\r\n        margin: 0 auto;\r\n        width: 90%;\r\n        height: 50px;\r\n        outline: none;/*边线不显示*/\r\n        resize: none;/*禁止拉伸*/\r\n        border: none;\r\n        vertical-align: top;\r\n    }\r\n    #demov92wufh9 > div >button{\r\n        display: inline-block;\r\n        width: 10%;\r\n        height: 50px;\r\n        vertical-align: top;\r\n        border: none;\r\n        background-color: whitesmoke;\r\n        font-size: 15px;\r\n    }\r\n    #demov92wufh9 ul{\r\n        width: 100%;\r\n    }\r\n    #demov92wufh9 li{\r\n        position: relative;\r\n        margin: 10px;\r\n        margin-bottom: 0;\r\n        padding-bottom: 20px;\r\n        /* min-height: 50px; */\r\n        background-color: white;\r\n    }\r\n    #demov92wufh9 > ul>li >button{\r\n        display: inline-block;\r\n        position: absolute;\r\n        bottom: 0;\r\n        right: 0;\r\n        width: 40px;\r\n        height: 20px;\r\n        font-size: 10px;\r\n        background-color: whitesmoke;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demov92wufh9>div>button\").click(function(){\r\n            var text = $(this).siblings(\"textarea\").val()\r\n            if(text!=\"\")\r\n            {\r\n                var newLi = $(\"<li></li>\")\r\n                newLi.html(text+ \"<button>删除</button>\")\r\n                newLi.hide()\r\n                $(\"#demov92wufh9 > ul\").prepend(newLi)\r\n                newLi.slideDown()\r\n                $(this).siblings(\"textarea\").val(\"\")\r\n            }\r\n        })\r\n        $(\"#demov92wufh9>ul\").on(\"click\",\"button\",function(){\r\n            $(this).parent().slideUp(function(){\r\n                $(this).remove()\r\n            })\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demov92wufh9\">\r\n    <div>\r\n        <textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"></textarea><button>发布</button>\r\n    </div>\r\n    <ul>\r\n        <li>测试文字1<button>删除</button></li>\r\n        <li>测试文字2<button>删除</button></li>\r\n        <li>测试文字3<button>删除</button></li>\r\n        <li>测试文字4<button>删除</button></li>\r\n    </ul>\r\n</div>\r\n<style>\r\n     #demov92wufh9 *::after,\r\n     #demov92wufh9 *::before{\r\n        content: none;\r\n        display: none;\r\n     }\r\n    #demov92wufh9 *{\r\n        border: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        box-sizing: border-box;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n    #demov92wufh9{\r\n        width: 100%;\r\n        height: 500px;\r\n        background-color: skyblue;\r\n    }\r\n    #demov92wufh9 textarea{\r\n        margin: 0 auto;\r\n        width: 90%;\r\n        height: 50px;\r\n        outline: none;/*边线不显示*/\r\n        resize: none;/*禁止拉伸*/\r\n        border: none;\r\n        vertical-align: top;\r\n    }\r\n    #demov92wufh9 > div >button{\r\n        display: inline-block;\r\n        width: 10%;\r\n        height: 50px;\r\n        vertical-align: top;\r\n        border: none;\r\n        background-color: whitesmoke;\r\n        font-size: 15px;\r\n    }\r\n    #demov92wufh9 ul{\r\n        width: 100%;\r\n    }\r\n    #demov92wufh9 li{\r\n        position: relative;\r\n        margin: 10px;\r\n        margin-bottom: 0;\r\n        padding-bottom: 20px;\r\n        /* min-height: 50px; */\r\n        background-color: white;\r\n    }\r\n    #demov92wufh9 > ul>li >button{\r\n        display: inline-block;\r\n        position: absolute;\r\n        bottom: 0;\r\n        right: 0;\r\n        width: 40px;\r\n        height: 20px;\r\n        font-size: 10px;\r\n        background-color: whitesmoke;\r\n    }\r\n</style>\r\n```\r\n\r\n## jQuery拷贝\r\n* 语法：`$.extend([deep],target,object1,[objectN])`\r\n* extend有合并的意思\r\n* deep: true or false是否为深拷贝\r\n* target：要拷贝到的目标对象\r\n* object1：待拷贝的对象1\r\n\r\n```js\r\nvar tempA = {\r\n    id:0,           //浅拷贝时将被覆盖\r\n    msg:{           //浅拷贝时整个对象将被覆盖\r\n        index:20    //深拷贝时，index将被保留 表现为合并对象\r\n    }\r\n}\r\nvar tempB = {\r\n    id:1,\r\n    name:\"string\",  //name是简单数据类型\r\n    msg:{           //msg是一个复杂数据类型，浅拷贝时仅拷贝地址\r\n        age:18\r\n    }\r\n}\r\n$.extend(tempA,tempB);\r\nconsole.log(tempA)\r\n```\r\n\r\n## 多库共存\r\n当使用的其他js库中也使用了$符号时，就会造成标识符的冲突\r\n\r\n**解决方案**\r\n\r\n* 若是因为`$`符号导致的冲突，则可以使用标识符`jQuery`来代替\r\n* 若标识符`JQuery`仍然冲突，则可使用`var 自定义标识符 = jQuery.noConflict()` 来定义\r\n\r\n## jquery插件\r\n[jQuery插件库](http://www.jq22.com)  \r\n[jQuery之家](http://www.htmleaf.com)\r\n\r\n* 瀑布流\r\n* 懒惰加载EasyLazyload\r\n* 全屏滚动fullpage.js\r\n\r\n瀑布流\r\n![](./images/jQuery学习笔记/2022-07-13-17-13-17.png)\r\n\r\n\r\n```html\r\n<script src=\"_js/jQuery.js\"></script>\r\n<script src=\"_PinterestGrid/js/pinterest_grid.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#gallery-wrapper\").pinterest_grid({\r\n\t\t\t\tno_columns: 4,\r\n                padding_x: 10,\r\n                padding_y: 10,\r\n                margin_bottom: 50,\r\n                single_column_breakpoint: 700\r\n\t\t\t});\r\n    })\r\n</script>\r\n<section id=\"gallery-wrapper\">\r\n    <article class=\"white-panel\"> \r\n      <img src=\"./_PinterestGrid/img/1.jpg\" alt=\"...\">\r\n      <h1><a href=\"#\">Title 1</a></h1>\r\n      <p>Description 1</p>\r\n    </article>\r\n    <article class=\"white-panel\"> \r\n      <img src=\"./_PinterestGrid/img/2.jpg\" alt=\"...\">\r\n      <h1><a href=\"#\">Title 2</a></h1>\r\n      <p>Description 2</p>\r\n    </article>\r\n    <article class=\"white-panel\"> \r\n        <img src=\"./_PinterestGrid/img/3.jpg\" alt=\"...\">\r\n        <h1><a href=\"#\">Title 3</a></h1>\r\n        <p>Description 3</p>\r\n      </article>\r\n      <article class=\"white-panel\"> \r\n        <img src=\"./_PinterestGrid/img/4.jpg\" alt=\"...\">\r\n        <h1><a href=\"#\">Title 3</a></h1>\r\n        <p>Description 3</p>\r\n      </article>\r\n      <article class=\"white-panel\"> \r\n        <img src=\"./_PinterestGrid/img/5.jpg\" alt=\"...\">\r\n        <h1><a href=\"#\">Title 3</a></h1>\r\n        <p>Description 3</p>\r\n      </article>\r\n      <article class=\"white-panel\"> \r\n        <img src=\"./_PinterestGrid/img/6.jpg\" alt=\"...\">\r\n        <h1><a href=\"#\">Title 3</a></h1>\r\n        <p>Description 3</p>\r\n      </article>\r\n  </section>  \r\n<style>\r\n    #gallery-wrapper {\r\n        position: relative;\r\n        max-width: 100%;\r\n        width: 100%;\r\n    }\r\n    img.thumb {\r\n        width: 100%;\r\n        max-width: 100%;\r\n        height: auto;\r\n    }\r\n    .white-panel {\r\n        position: absolute;\r\n        background: white;\r\n        border-radius: 5px;\r\n        box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3);\r\n        padding: 10px;\r\n    }\r\n    .white-panel h1 {\r\n        font-size: 1em;\r\n    }\r\n    .white-panel h1 a {\r\n        color: #A92733;\r\n    }\r\n    .white-panel:hover {\r\n        box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5);\r\n        margin-top: -5px;\r\n        -webkit-transition: all 0.3s ease-in-out;\r\n        -moz-transition: all 0.3s ease-in-out;\r\n        -o-transition: all 0.3s ease-in-out;\r\n        transition: all 0.3s ease-in-out;\r\n    }\r\n</style>\r\n```\r\n\r\n![](./images/jQuery学习笔记/2022-07-13-18-26-32.png)\r\n```html\r\n<img data-lazy-src=\"/images/jQuery学习笔记/2022-07-13-18-26-32.png\" />\r\n<img data-lazy-src=\"/images/jQuery学习笔记/2022-07-13-18-26-32.png\" />\r\n<img data-lazy-src=\"/images/jQuery学习笔记/2022-07-13-18-26-32.png\" />\r\n<script src=\"./_EasyLazyload/EasyLazyload.js\"></script>\r\n<script>\r\n    lazyLoadInit({\r\n        coverColor:\"white\",\r\n        coverDiv:\"<h1>test</h1>\",\r\n        offsetBottom:0,\r\n        offsetTopm:0,\r\n        showTime:1100,\r\n        onLoadBackEnd:function(i,e){\r\n            console.log(\"onLoadBackEnd:\"+i);\r\n        }\r\n        ,onLoadBackStart:function(i,e){\r\n            console.log(\"onLoadBackStart:\"+i);\r\n        }\r\n    });\r\n</script>\r\n```\r\n \r\n\r\n## 元素的缓存数据\r\n\r\n实际使用过程中碰到的问题，这里记录一下\r\n\r\n* 键名相同会覆盖，以下两个元素对象不同，但其键名相同，键值会覆盖\r\n    * jQueryElementObj1.data(\"键名\",键值)\r\n    * jQueryElementObj2.data(\"键名\",键值2)\r\n* 键名相同不覆盖，以下两个元素对象不同，但其键名相同，键值不会覆盖\r\n    * $.data(element,\"键名\",键值)\r\n    * $.data(element,\"键名\",键值2)\r\n* 使用深拷贝$.extend()函数时，由于克隆的整个元素，所以也能够访问键值，但拷贝前的元素remove()后，深拷贝的元素也将不存在\r\n* jquery.clone() 函数无法克隆元素的缓存数据\r\n\r\n\r\n克隆元素同时克隆缓存数据的方法：\r\n\r\n```\r\n// 方法1：\r\nnewObj.data(oldObj.data()) //这种方式对于ele.data(\"key\",value) 或 ele.data({\"key\":value}) 方式设置的数据生效\r\n\r\n//方法2：\r\n// $.data(DOMelement,key,value) // 设置键值\r\n// $.data(DOMelement,key) // 获取键值\r\n// $.data(DOMelement) // 获取一个包含所有键值对的js对象,jQuery内部自身使用这个方法来绑定数据,所以这类数据也包含在其中，\r\n\r\n// 所以这种方法只能使用指定键名的方式重新设置值，因为键名是不可省略的参数\r\n$.data(oldObj,key,$.data(oldObj,key))\r\n\r\n```\r\n"},{"shortInfo":{"title":"jsWebApis学习笔记之BOM","date":"2022-07-03T16:19:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["JavaScript","WebApis","BOM","DOM","前端"],"hideAtIndex":true,"categories":"笔记","id":3743964398,"countWords":2629,"readSeconds":262.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# jsWebApis学习笔记之BOM\r\n\r\n## 目录\r\n- [jsWebApis学习笔记之BOM](#jswebapis学习笔记之bom)\r\n  - [目录](#目录)\r\n  - [概述](#概述)\r\n  - [window对象构成：](#window对象构成)\r\n  - [window对象事件](#window对象事件)\r\n  - [定时器](#定时器)\r\n    - [倒计时案例](#倒计时案例)\r\n    - [发送短信按钮案例](#发送短信按钮案例)\r\n  - [this指向问题](#this指向问题)\r\n  - [js执行机制](#js执行机制)\r\n    - [原来存在的问题](#原来存在的问题)\r\n    - [新标准](#新标准)\r\n  - [window的location对象](#window的location对象)\r\n    - [URL](#url)\r\n  - [window.navigator对象](#windownavigator对象)\r\n  - [window.history对象](#windowhistory对象)\r\n\r\n## 概述\r\n* BOM(Browser Object Model浏览器对象模型)\r\n* 提供了**与浏览器窗口进行交互的对象**，\r\n* 核心对象是`window`\r\n* **BOM最初是Netscape浏览器标准的一部分**\r\n* BOM是浏览器厂商在各自浏览器上定义的，兼容性差\r\n    * alert() 在不同的浏览器有不同的外观\r\n\r\n## window对象构成：\r\n* **DOM是BOM的一部分**\r\n![](./images/jsWebApis学习笔记之BOM/2022-07-07-07-45-10.png)\r\n\r\n* window对象是浏览器**顶级对象**，有双重角色\r\n    * 它是**js访问浏览器窗口的API**\r\n    * 它是全局对象，**定义在全局作用域的变量函数都会变成window对象的属性和方法**\r\n    * **在调用时可以省略`window.`**\r\n        * `window.alert()`  和  `alert()` \r\n        * `window.prompt()`  和  `prompt()`\r\n\r\n## window对象事件\r\n* `window.onload`是窗口（页面）加载事件，**当文档内容（图像，脚本，CSS等）完全加载完毕后触发**\r\n    <script>\r\n    //通过window.onload事件，可以把js代码写在元素代码之前\r\n    window.addEventListener(\"load\",function(){\r\n        var demoButtonwoefjwe93 = document.querySelector(\"#demoButtonwoefjwe93\")\r\n        demoButtonwoefjwe93.addEventListener(\"click\",function(){\r\n        window.alert(\"页面加载完毕：点击了按钮\")\r\n        })\r\n    })\r\n    </script>\r\n    <button id=\"demoButtonwoefjwe93\">测试</button>\r\n\r\n    ```html\r\n    <script>\r\n    //通过window.onload事件，可以把js代码写在元素代码之前\r\n    window.addEventListener(\"load\",function(){\r\n        var demoButtonwoefjwe93 = document.querySelector(\"#demoButtonwoefjwe93\")\r\n        demoButtonwoefjwe93.addEventListener(\"click\",function(){\r\n        window.alert(\"页面加载完毕：点击了按钮\")\r\n        })\r\n    })\r\n    </script>\r\n    <button id=\"demoButtonwoefjwe93\">测试</button>\r\n    ```\r\n\r\n* `window.onDOMContentLiaded` **DOM内容（html元素）加载完毕后触发的事件**，在CSS、图片 flash加载前触发，如果页面中图片很多，那么onload事件触发就要等很久，而该事件就不用\r\n\r\n* `window.onresize` 浏览器窗口调整后触发的事件，常配合`window.innerWidth`属性来做响应式布局\r\n\r\n\r\n\r\n## 定时器\r\n* `window.setTimeout(回调函数,[延迟毫秒数])` 用来延迟执行某个函数 **先延迟后执行**\r\n    * 回调函数的几种写法\r\n        * 匿名函数\r\n        * 函数名\r\n        * '函数名()'\r\n    * 延迟毫秒数不填默认为0\r\n    * 返回值，定时器ID\r\n    * `window.clearTimeout(定时器ID)`清除定时器\r\n* `window.setInterval(回调函数,[延迟毫秒数])` 用来**循环**延迟执行某个函数 **先延迟后执行**\r\n    * `window.clearInterval(定时器ID)`清除定时器\r\n\r\n### 倒计时案例\r\n\r\n<div id=\"demoJOIJE123\">\r\n    <span id=\"hh\">00</span>\r\n    <span id=\"mm\">00</span>\r\n    <span id=\"ss\">00</span>\r\n</div>\r\n<style>\r\n    #demoJOIJE123 span{\r\n        display: inline-block;\r\n        margin: 0 5px;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        color: white;\r\n        font-size: 40px;\r\n        line-height: 50px;        \r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n    var hh=document.querySelector(\"#hh\")\r\n    var mm=document.querySelector(\"#mm\")\r\n    var ss=document.querySelector(\"#ss\")\r\n    var targetTime =+new Date(\"9922-07-04T04:45:00\")//设置目标时间\r\n    updateTime()//防止刷新页面后要等1秒才更新倒计时\r\n    var timeDown = setInterval(updateTime,1000)\r\n    function updateTime(){\r\n        var now =+new Date();\r\n        var gap = targetTime - now;\r\n        if(gap<0)\r\n        {\r\n            gap = 0;//防止出现负号\r\n            clearInterval(timeDown)\r\n        }\r\n        var h = parseInt(gap/1000/60/60%24)\r\n        var m = parseInt(gap/1000/60%60)\r\n        var s = parseInt(gap/1000%60)\r\n        h = h<10? \"0\"+h:h\r\n        m = m<10? \"0\"+m:m\r\n        s = s<10? \"0\"+s:s\r\n        hh.innerText=h\r\n        mm.innerText=m\r\n        ss.innerText=s\r\n    }\r\n</script>\r\n\r\n\r\n```html\r\n<div id=\"demoJOIJE123\">\r\n    <span id=\"hh\">00</span>\r\n    <span id=\"mm\">00</span>\r\n    <span id=\"ss\">00</span>\r\n</div>\r\n<style>\r\n    #demoJOIJE123 span{\r\n        display: inline-block;\r\n        margin: 0 5px;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        color: white;\r\n        font-size: 40px;\r\n        line-height: 50px;        \r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n    var hh=document.querySelector(\"#hh\")\r\n    var mm=document.querySelector(\"#mm\")\r\n    var ss=document.querySelector(\"#ss\")\r\n    var targetTime =+new Date(\"9922-07-04T04:45:00\")//设置目标时间\r\n    updateTime()//防止刷新页面后要等1秒才更新倒计时\r\n    var timeDown = setInterval(updateTime,1000)\r\n    function updateTime(){\r\n        var now =+new Date();\r\n        var gap = targetTime - now;\r\n        if(gap<0)\r\n        {\r\n            gap = 0;//防止出现负号\r\n            clearInterval(timeDown)\r\n        }\r\n        var h = parseInt(gap/1000/60/60%24)\r\n        var m = parseInt(gap/1000/60%60)\r\n        var s = parseInt(gap/1000%60)\r\n        h = h<10? \"0\"+h:h\r\n        m = m<10? \"0\"+m:m\r\n        s = s<10? \"0\"+s:s\r\n        hh.innerText=h\r\n        mm.innerText=m\r\n        ss.innerText=s\r\n    }\r\n</script>\r\n```\r\n\r\n### 发送短信按钮案例\r\n\r\n<div id=\"demoInput12381039\">\r\n    <input type=\"text\" name=\"\" id=\"\"><button>发送</button>\r\n</div>\r\n<style>\r\n    #demoInput12381039 * {\r\n        box-sizing: border-box;\r\n        padding: 0;\r\n        margin: 0;\r\n        height: 25px;\r\n        padding: 0 5px;\r\n        vertical-align: middle;\r\n    }\r\n</style>\r\n<script>\r\n    var btn=document.querySelector(\"#demoInput12381039>button\")\r\n    var ipt=document.querySelector(\"#demoInput12381039>input\")\r\n    btn.addEventListener(\"click\",function(){\r\n        if(ipt.value){//检查输入框是否满足要求\r\n            btn.disabled=true; //禁用\r\n            var ss = 5; //倒计时\r\n            callback(); //先显示一次\r\n            var timmer = setInterval(callback,1000);\r\n            function callback(){//回调函数\r\n                btn.innerText = \"再次发送需等待\" + ss + \"秒\";\r\n                if(ss--<0){\r\n                    clearInterval(timmer);\r\n                    btn.innerText = \"发送\";\r\n                    btn.disabled = false;\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n\r\n```html\r\n<div id=\"demoInput12381039\">\r\n    <input type=\"text\" name=\"\" id=\"\"><button>发送</button>\r\n</div>\r\n<style>\r\n    #demoInput12381039 * {\r\n        box-sizing: border-box;\r\n        padding: 0;\r\n        margin: 0;\r\n        height: 25px;\r\n        padding: 0 5px;\r\n        vertical-align: middle;\r\n    }\r\n</style>\r\n<script>\r\n    var btn=document.querySelector(\"#demoInput12381039>button\")\r\n    var ipt=document.querySelector(\"#demoInput12381039>input\")\r\n    btn.addEventListener(\"click\",function(){\r\n        if(ipt.value){//检查输入框是否满足要求\r\n            btn.disabled=true; //禁用\r\n            var ss = 5; //倒计时\r\n            callback(); //先显示一次\r\n            var timmer = setInterval(callback,1000);\r\n            function callback(){//回调函数\r\n                btn.innerText = \"再次发送需等待\" + ss + \"秒\";\r\n                if(ss--<0){\r\n                    clearInterval(timmer);\r\n                    btn.innerText = \"发送\";\r\n                    btn.disabled = false;\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n## this指向问题\r\n\r\n全局作用域或普通函数中的this指向window对象\r\n```js\r\nconsole.log(this)//输出window \r\n//----------------------------------------------------//\r\nfunction test1(){\r\n    console.log(this)//输出window \r\n}\r\ntest1(); //相当于是window.test1();\r\n//----------------------------------------------------//\r\nwindow.setInterval(function(){\r\n    console.log(this) //输出window\r\n},1000)\r\n```\r\n\r\n对象的方法中的this指向调用者，也就是这个对象本身\r\n```js\r\nvar obj={\r\n    test2:function(){\r\n        console.log(this)//输出obj\r\n    }\r\n}\r\nobj.test2();\r\n//----------------------------------------------------//\r\nvar btn = document.querySelector(\"bhtton\");\r\nbtn.onclick = function(){\r\n    console.log(this);//输出btn对象 ,相当于在触发click事件后会自动调用btn.onclick();函数\r\n};\r\nbtn.addEventListener(\"click\",function(){\r\n    console.log(this);//输出btn对象\r\n});\r\n//----------------------------------------------------//\r\n```\r\n\r\n构造函数中的this指向返回的实例化后的对象\r\n```js\r\nfunction Obj(){\r\n    console.log(this);\r\n}\r\nvar obj1 = new Obj(); //控制台打印输出obj1\r\nvar obj2 = new Obj(); //控制台打印输出obj2\r\n```\r\n\r\nthis的指向是可以更改的\r\n\r\n\r\n## js执行机制\r\n### 原来存在的问题\r\n* js语言的特点是单线程，同时只能做一件事\r\n* 单线程的特点由js诞生的使命造成，js是为了处理页面交互，DOM的增删改。\r\n* 单线程意味着所有任务需要排队，前一个执行完毕才能执行下一个\r\n* 单线程的问题是，当单个任务耗费时间较长时会造成任务队列的堵塞\r\n\r\n### 新标准\r\n为了解决这样的问题，HTML5提出了Web Worker标准，允许js创建多个线程，利用多核cpu的计算能力，于是js中出现了同步和异步的概念\r\n\r\n* 同步任务: 同步任务都在主线程上执行，形成一个**执行栈**\r\n\r\n* 异步任务  \r\n    * js异步是通过回调函数实现  \r\n    * 回调函数会被添加到**任务队列**（消息队列）\r\n    * 异步任务一般分三类\r\n        * 普通事件：click resize 等\r\n        * 资源加载：load error 等\r\n        * 定时器： setInterval() setTimeout() 等\r\n\r\n* 执行机制\r\n    * 0.先执行**执行栈**中的同步任务\r\n    * 1.碰到异步任务则将其提交给对应的**异步进程处理程序**\r\n        * **异步进程处理程序**在事件触发、定时器等到、ajax返回后，将相应的异步任务放入**任务队列**中\r\n    * 3.等到同步任务执行完毕后，再到**任务队列**中查询是否有任务，如果有，就取出一个放入**执行栈**处理\r\n    * 1->2->3 称之为**事件循环**\r\n![](./images/jsWebApis学习笔记之BOM/2022-07-07-08-15-13.png)\r\n\r\n案例\r\n* 输出顺序为`1`->`2` 但`3`和`click`的顺序不定，主要看回调函数被添加到任务队列的顺序，该顺序由延迟时间，click时间发生的时间共同觉得\r\n* ![](./images/jsWebApis学习笔记之BOM/2022-07-07-08-30-54.png)\r\n\r\n## window的location对象\r\nlocation对象**属性**\r\n* `location.href` **获取或设置整个url**\r\n* `location.host` 返回域名 `www.baidu.com`\r\n* `location.hostname` 返回域名 `www.baidu.com`\r\n* `location.port` 返回端口号，默认为空字符串 `\"\"` \r\n* `location.pathname` 路径 `/index.html`\r\n* `location.search` **参数**  `?name=andy&age=18`\r\n* `location.hash` #片段 `#锚点名`\r\n\r\nlocation对象**方法**\r\n* location.assign() 和herf一样可以跳转页面，也称重定向页面 ，记录历史记录\r\n* location.replace() 替换当前页面，不记录历史记录，不能后退页面\r\n* location.reload() 重新加载页面，\r\n    * 参数为空或false时，相当于刷新或f5（使用缓存）  \r\n    * 参数为true则相当于ctrl+f5强制刷新页面（不使用缓存，而直接从服务器重新获取数据）\r\n\r\n\r\n### URL\r\n* 格式：`传输协议://域名或ip[:端口][/地址][?查询键值对][#片段]`\r\n* 示例：`https://www.baidu.com:80/index.html?wd=搜索内容`\r\n    * protocol 通信协议，http ftp maito\r\n    * host 主机，域名或ip地址\r\n    * port 端口，省略时使用协议的默认端口，如http是80端口\r\n    * path 路径，表示一个目录或文件\r\n    * query 参数,以键值对形式，通过&符号分隔，如`?name=andy&age=18`\r\n    * fragment 片段 `#锚点名` 常见于链接、锚点\r\n\r\n\r\n\r\n\r\n<button id=\"demoOHf9we8\">点击跳转到百度</button>\r\n<script>\r\n    var demoOHf9we8 = document.querySelector(\"#demoOHf9we8\")\r\n    demoOHf9we8.addEventListener(\"click\",function(){\r\n        var ss = 5;\r\n        reflash();\r\n        var timer = setInterval(reflash,1000)\r\n        function reflash(){\r\n            demoOHf9we8.innerText=\"即将在\"+ ss +\"秒后跳转到百度\";\r\n            if(ss--<=0)\r\n            {\r\n                clearInterval(timer)\r\n                location.href=\"https://baidu.com\"\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demoOHf9we8\">点击跳转到百度</button>\r\n<script>\r\n    var demoOHf9we8 = document.querySelector(\"#demoOHf9we8\")\r\n    demoOHf9we8.addEventListener(\"click\",function(){\r\n        var ss = 5;\r\n        reflash();\r\n        var timer = setInterval(reflash,1000)\r\n        function reflash(){\r\n            if(ss>0)\r\n            {\r\n                demoOHf9we8.innerText=\"即将在\"+ ss +\"秒后跳转到百度\";\r\n                ss--;\r\n            }\r\n            else\r\n            {\r\n                clearInterval(timer)\r\n                location.href=\"https://baidu.com\";\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n将一个页面的数据送到另一个页面\r\n\r\n```html\r\n//login.html\r\n\r\n//form默认get\r\n<form action=\"index.html\">\r\n    用户名：<input type=\"text\" name=\"username\" ><input type=\"submit\" value=\"登录\">\r\n</form>\r\n```\r\n\r\n```html\r\n//index.html\r\n\r\n<p id=\"demowenwfj9230\"></p>\r\n<script>\r\n    var demowenwfj9230 = document.querySelector(\"#demowenwfj9230\") \r\n    var list = location.search.substr(1).split(\"=\")//去除？后再根据=分隔为数组\r\n    var uname = list[1]\r\n    demowenwfj9230.innerHTML=\"欢迎你，\" + uname\r\n</script>\r\n```\r\n\r\n## window.navigator对象\r\n常用属性\r\n* `navigator.userAgent` 可获取客户端发送给服务端的user-agent头部值，用来判断是移动端还是pc端\r\n\r\n**判断是移动端还是pc端**\r\n```js\r\nfunction isPhone(){\r\n    if(window.navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))\r\n    {\r\n      return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n## window.history对象\r\n* 该对象允许用户于浏览器历史记录进行交互\r\n* 该对象包含用户（在浏览器窗口中）访问过的URL\r\n\r\n常用方法\r\n* history.back() 后退一个页面\r\n* history.forward() 前进一个页面\r\n* history.go(参数) 参数是1前进一个页面，-1后退一个页面\r\n\r\n使用场景：\r\n![](./images/jsWebApis学习笔记之BOM/2022-07-07-08-31-52.png)\r\n"},{"shortInfo":{"title":"jsWebApis学习笔记之DOM","date":"2022-06-28T00:55:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["JavaScript","WebApis","BOM","DOM","前端"],"hideAtIndex":true,"categories":"笔记","id":319433960,"countWords":10828,"readSeconds":1082.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# jsWebApis学习笔记之DOM\r\n\r\n## 目录\r\n- [jsWebApis学习笔记之DOM](#jswebapis学习笔记之dom)\r\n  - [目录](#目录)\r\n  - [内容组成](#内容组成)\r\n    - [Web API](#web-api)\r\n    - [DOM](#dom)\r\n      - [DOM的一些概念](#dom的一些概念)\r\n  - [获取元素](#获取元素)\r\n    - [根据ID获取](#根据id获取)\r\n    - [根据标签获取](#根据标签获取)\r\n    - [根据类名获取](#根据类名获取)\r\n    - [查询选择器](#查询选择器)\r\n    - [特殊元素标签的获取](#特殊元素标签的获取)\r\n  - [事件](#事件)\r\n    - [常用事件类型](#常用事件类型)\r\n      - [面试题：mousemove与mouseenter的区别](#面试题mousemove与mouseenter的区别)\r\n    - [DOM事件流](#dom事件流)\r\n    - [注册事件](#注册事件)\r\n      - [传统注册方式](#传统注册方式)\r\n      - [方法监听注册方式](#方法监听注册方式)\r\n        - [事件监听方法的使用](#事件监听方法的使用)\r\n      - [解绑事件](#解绑事件)\r\n      - [事件委托](#事件委托)\r\n        - [面试题：事件委托原理](#面试题事件委托原理)\r\n    - [事件对象](#事件对象)\r\n      - [事件对象的属性和方法](#事件对象的属性和方法)\r\n    - [鼠标事件对象](#鼠标事件对象)\r\n      - [获取鼠标在页面中的坐标](#获取鼠标在页面中的坐标)\r\n      - [案例：拖拽移动元素](#案例拖拽移动元素)\r\n    - [键盘事件对象](#键盘事件对象)\r\n      - [案例：使输入框获得焦点](#案例使输入框获得焦点)\r\n      - [案例：放大显示输入内容](#案例放大显示输入内容)\r\n  - [操作元素](#操作元素)\r\n    - [修改元素内容](#修改元素内容)\r\n    - [修改元素属性](#修改元素属性)\r\n    - [修改元素样式](#修改元素样式)\r\n    - [修改元素类名](#修改元素类名)\r\n    - [单标签(表单)元素属性的修改](#单标签表单元素属性的修改)\r\n    - [操作元素示例](#操作元素示例)\r\n  - [节点操作](#节点操作)\r\n  - [元素偏移量offset系列属性](#元素偏移量offset系列属性)\r\n  - [元素可视区client系列属性](#元素可视区client系列属性)\r\n  - [元素滚动scroll系列属性](#元素滚动scroll系列属性)\r\n  - [页面window.scroll](#页面windowscroll)\r\n  - [offset、client、scroll三系列总结](#offsetclientscroll三系列总结)\r\n  - [dom核心知识点总结](#dom核心知识点总结)\r\n    - [创建](#创建)\r\n    - [增](#增)\r\n    - [删](#删)\r\n    - [改](#改)\r\n    - [查](#查)\r\n    - [属性操作](#属性操作)\r\n    - [事件操作](#事件操作)\r\n  - [一些案例](#一些案例)\r\n    - [全选框](#全选框)\r\n    - [tab栏切换制作](#tab栏切换制作)\r\n    - [新浪下拉菜单](#新浪下拉菜单)\r\n    - [简单留言发布案例实现](#简单留言发布案例实现)\r\n    - [动态生成表格](#动态生成表格)\r\n    - [实例：防止复制内容](#实例防止复制内容)\r\n      - [禁止鼠标右键菜单](#禁止鼠标右键菜单)\r\n      - [禁止鼠标选中文字](#禁止鼠标选中文字)\r\n      - [禁止f12键](#禁止f12键)\r\n    - [实例：阻止链接跳转](#实例阻止链接跳转)\r\n\r\n\r\n## 内容组成\r\n* JavaScript基础语法是ECMA组织制定的\r\n* Web Apis 是W3C组织制定的标准\r\n    * 主要学习BOM DOM\r\n\r\n![](./images/jsWebApis学习笔记之DOM/2022-06-28-08-58-57.png)\r\n\r\n\r\n\r\n### Web API\r\n* **API**（application programming interface应用程序编程接口）是一些预先定义的函数，提供给应用程序和开发人员基于某软件或硬件访问一组例程的能力，而又无需访问源码、理解内部工作机制细节\r\n* **Web API**是浏览器提供的一套操作浏览器功能和页面的API （BOM DOM）\r\n    * alert()是BOM API\r\n\r\n\r\n### DOM\r\n* **DOM**（Document Object Model文档对象模型），是**W3C**组织推荐的处理**可扩展标记语言**的标准**编程接口**\r\n    * 可扩展标记语言：\r\n        * HTML\r\n        * XML\r\n#### DOM的一些概念\r\n* **DOM树**\r\n    ![](./images/jsWebApis学习笔记之DOM/2022-06-28-09-16-59.png)\r\n* **文档document** ：一个页面就是一个文档\r\n* **元素element** ：页面中所有的标签都是元素\r\n* **节点node** ：页面中所有内容都可看做节点（标签，属性，文本，注释等）\r\n\r\n* **对象** ，DOM把文档，元素，节点看做对象\r\n\r\n## 获取元素\r\n* 根据ID获取\r\n* 根据标签获取\r\n* 根据HTML5新增方法获取\r\n* 特殊元素获取\r\n\r\n\r\n### 根据ID获取  \r\n`document.getElementById(\"idName\")`\r\n```html\r\n<div id=\"Demo1\">123</div>\r\n<script>\r\n    //参数是区分大小写的字符串\r\n    //返回一个对象\r\n    var Demo1=document.getElementById(\"Demo1\")\r\n\r\n    //测试：\r\n    console.log(Demo1)// <div id=\"Demo1\">123</div>\r\n    console.log(typeof Demo1)// object\r\n    console.dir(Demo1)// dir()用于打印查看元素对象，可以看到其属性和方法\r\n\r\n//注意：默认情况下，script标签需写在#Demo1 标签之后，因为文档页面从上往下加载，script加载时#Demo1标签必须已经存在，\r\n</script>\r\n```\r\n\r\n### 根据标签获取  \r\n获取整个页面的某标签`document.getElementsByTagName()`\r\n```html\r\n<ul>\r\n    <li>1</li>\r\n    <li>2</li>\r\n    <li>3</li>\r\n    <li>4</li>\r\n    <li>5</li>\r\n</ul>\r\n<script>\r\n    // 获得元素是动态的。个人理解：对元素的修改会同步到html，对html的修改会同步到获得到的元素\r\n\r\n    //返回值为获取的元素对象的集合，是伪数组\r\n    // 即使只有一个li，用该函数获取是有一个元素的伪数组，\r\n    //如果页面中没有li标签，返回值是空的伪数组\r\n    // document.getElementsByTagName获取到的是整个页面的相应标签\r\n    var elements2=document.getElementsByTagName(\"li\")\r\n    console.log(elements2)\r\n    console.log(elements2[0])\r\n    console.dir(elements2)\r\n    console.dir(elements2[0])\r\n\r\n</script>\r\n```\r\n获取某个标签的子标签`element.getElementsByTagName()`\r\n```html\r\n<ul>\r\n    <li>0</li>\r\n    <li>0</li>\r\n    <li>0</li>\r\n    <li>0</li>\r\n    <li>0</li>\r\n</ul>\r\n<ol id=\"olDemo\">\r\n    <li>1</li>\r\n    <li>2</li>\r\n    <li>3</li>\r\n    <li>4</li>\r\n    <li>5</li>\r\n</ol>\r\n<script>\r\n    // element.getElementsByTagName 获取到的是某元素的所有子标签\r\n    var ol=document.getElementById(\"olDemo\")\r\n    var ol_li=ol.getElementsByTagName(\"li\")\r\n    console.log(ol_li)\r\n    console.log(ol_li[0])\r\n    console.dir(ol_li)\r\n    console.dir(ol_li[0])\r\n</script>\r\n```\r\n\r\n### 根据类名获取  \r\n* getElementsByClassName()\r\n* **该方法是是HTML5标准**，ie678不支持html5  \r\n\r\n获取整个页面的某标签`document.getElementsByClassName()`\r\n\r\n```html\r\n<div class=\"classN1\">1</div>\r\n<div class=\"classN1\">2</div>\r\n\r\n<script>\r\n    var divs=document.getElementsByClassName(\"classN1\")\r\n    console.log(divs);\r\n    console.dir(divs);\r\n</script>\r\n```\r\n\r\n### 查询选择器  \r\n* **该方法是HTML5标准**  \r\n\r\nquerySelector返回查询到的**第一个**元素\r\n```html\r\n    <div class=\"father\">\r\n        <div id=\"id1\" class=\"class1\">1</div>\r\n        <div class=\"class1\">2</div>\r\n    </div>\r\n\r\n    <script>\r\n        // 传入的字符串类似css的选择器语法\r\n        // querySelector返回第一个查询到的元素\r\n        var divs=document.querySelector(\".father>div#id1.class1\")\r\n        console.log(divs);\r\n        console.dir(divs);\r\n    </script>\r\n```\r\n\r\nquerySelectorAll返回查询到的**所有**元素\r\n```html\r\n    <div class=\"father\">\r\n        <div id=\"id1\" class=\"class1\">1</div>\r\n        <div class=\"class1\">2</div>\r\n    </div>\r\n\r\n    <script>\r\n        // 返回值为存放节点的伪数组\r\n        var divs=document.querySelectorAll(\".father>div.class1\")\r\n        console.log(divs);\r\n        console.dir(divs);\r\n    </script>\r\n```\r\n\r\n\r\n### 特殊元素标签的获取\r\n```html\r\n<script>\r\n    //body标签直接用document.body获取\r\n    var bodyEle=document.body\r\n    console.log(bodyEle);\r\n    console.dir(bodyEle);\r\n\r\n    //body标签用document.documentElement获取\r\n    var htmlEle=document.documentElement\r\n    console.log(htmlEle);\r\n    console.dir(htmlEle);\r\n</script>\r\n```\r\n\r\n## 事件\r\n* 事件是可以被js检测到的行为\r\n* 可以理解为触发响应机制\r\n* 事件三要素（组成）\r\n    * 事件源：事件被触发的元素对象\r\n    * 事件类型：事件是如何触发的，鼠标点击？ 鼠标经过？\r\n    * 事件处理程序: 通过函数赋值的方式完成\r\n* 执行事件的步骤\r\n    * 获取事件源\r\n    * 注册事件（绑定事件）\r\n    * 添加事件处理程序（函数赋值）\r\n\r\n**示例**\r\n```html\r\n<button id=\"btn\">点击</button>\r\n<script>\r\n    //事件源\r\n    var btn=document.getElementById(\"btn\")\r\n    //事件类型，事件处理程序\r\n    btn.onclick = function(){\r\n        //do something...\r\n        alert(\"点击了按钮\")\r\n    }\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 常用事件类型\r\n* `element.onclick` 鼠标点击\r\n* `element.onfocus` 获得鼠标焦点\r\n* `element.onblur` 失去鼠标焦点\r\n* `element.onmouseover` 鼠标经过\r\n* `element.onmouseout` 鼠标离开\r\n* `element.onmousemove` 鼠标移动\r\n* `element.onmouseup` 鼠标弹起触发\r\n* `element.onmousedown` 鼠标按下触发\r\n* `element.onkeyup` 键盘弹起 松开按键时会触发一次\r\n* `element.onkeydown` 键盘按下 按下后会一直不断触发\r\n* `element.onkeypress` 键盘按下，按下后会一直不断触发 但不能识别功能键，如ctrl shift\r\n* 按键事件执行顺序为down->press->up\r\n\r\n#### 面试题：mousemove与mouseenter的区别\r\n* 当鼠标移动到元素上时就会触发moseenter事件\r\n* mouseover是鼠标经过自身盒子会触发，经过子盒子，父盒子也会触发该事件\r\n* moseenter是只有鼠标经过自身盒子才会触发，\r\n*  因为moseenter不支持冒泡，子元素的事件不会传播到父级\r\n*  常和moseenter搭配的mouseleave也不支持冒泡，\r\n\r\n### DOM事件流\r\n* 事件流描述的是从页面中接收事件的顺序\r\n* 时间发生时，事件会在元素节点之间按特定顺序传播，该过程称为DOM事件流\r\n* 模型三阶段\r\n    * 捕获阶段、\r\n    * 目标阶段、\r\n    * 冒泡阶段\r\n* 事件冒泡：IE提出\r\n* 事件冒泡：网景提出\r\n* 注意\r\n    * js代码中只能执行捕捉阶段和冒泡阶段中的一种事件\r\n    * onclick和attachEvent只能得到冒泡阶段的事件\r\n    * addEventListener\r\n        * 可以得到两种中任意一种阶段的事件，\r\n        * 默认接收冒泡阶段的事件，\r\n        * 第三个参数设置为true时，接收捕获阶段的事件\r\n    * 实际开发中很少使用事件捕捉，更关注事件冒泡\r\n    * 有些事件没有冒泡：onblur onfocus onmouseenter onmouseleave\r\n    * 事件冒泡有事会带来麻烦，有时又很有用\r\n\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-02-01-36-52.png)\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-02-01-31-07.png)\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-02-01-33-57.png)\r\n\r\n\r\n**两种事件传播方式测试**\r\n\r\n<div id=\"demoVMOWIEJF\" style=\"display: inline-block;background-color: skyblue; \">\r\n    <div>\r\n        <button style=\"margin: 20px;\">捕获阶段事件传播测试</button>\r\n    </div>\r\n</div>\r\n<div id=\"demoFBERT45\" style=\"display: inline-block;background-color: skyblue; \">\r\n    <div>\r\n        <button style=\"margin: 20px;\">冒泡阶段事件传播测试</button>\r\n    </div>\r\n</div>\r\n<script>\r\n    var father1=document.querySelector(\"#demoVMOWIEJF>div\")\r\n    father1.addEventListener(\"click\",function(){\r\n        alert(\"father:检测到捕获阶段事件click\")\r\n    },\r\n    true\r\n    )\r\n    father1.firstElementChild.addEventListener(\"click\",function(){\r\n        alert(\"child:检测到捕获阶段事件click\")\r\n    },\r\n    true\r\n    )\r\n    var father2=document.querySelector(\"#demoFBERT45>div\")\r\n    father2.addEventListener(\"click\",function(){\r\n        alert(\"father:检测到冒泡阶段事件click\")\r\n    },\r\n    false\r\n    )\r\n    father2.firstElementChild.addEventListener(\"click\",function(){\r\n        alert(\"child:检测到冒泡阶段事件click\")\r\n    },\r\n    false\r\n    )\r\n</script>\r\n\r\n```html\r\n<div id=\"demoVMOWIEJF\" style=\"display: inline-block;background-color: skyblue; \">\r\n    <div>\r\n        <button style=\"margin: 20px;\">捕获阶段事件传播测试</button>\r\n    </div>\r\n</div>\r\n<div id=\"demoFBERT45\" style=\"display: inline-block;background-color: skyblue; \">\r\n    <div>\r\n        <button style=\"margin: 20px;\">冒泡阶段事件传播测试</button>\r\n    </div>\r\n</div>\r\n<script>\r\n    var father1=document.querySelector(\"#demoVMOWIEJF>div\")\r\n    father1.addEventListener(\"click\",function(){\r\n        alert(\"father:检测到捕获阶段事件click\")\r\n    },\r\n    true\r\n    )\r\n    father1.firstElementChild.addEventListener(\"click\",function(){\r\n        alert(\"child:检测到捕获阶段事件click\")\r\n    },\r\n    true\r\n    )\r\n\r\n    var father2=document.querySelector(\"#demoFBERT45>div\")\r\n    father2.addEventListener(\"click\",function(){\r\n        alert(\"father:检测到冒泡阶段事件click\")\r\n    },\r\n    false\r\n    )\r\n    father2.firstElementChild.addEventListener(\"click\",function(){\r\n        alert(\"child:检测到冒泡阶段事件click\")\r\n    },\r\n    false\r\n    )\r\n    \r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n### 注册事件\r\n\r\n* 给元素添加事件称为注册事件或绑定事件\r\n* 注册事件有两种方式\r\n    * 传统方式\r\n    * 方法监听注册方式\r\n \r\n\r\n#### 传统注册方式\r\n * 利用on开头的事件名注册，如onclick\r\n * `<button onclick=\"alert('hi~')\"></button>`\r\n * `btn.onclick=function(){}`\r\n * 特点：注册事件的**唯一性** 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数\r\n\r\n#### 方法监听注册方式\r\n* w3c标准 推荐的方式\r\n* `addEventListener()` **方法监听** ie678不支持\r\n* `attachEvent(eventNameWithOn,callback)`代替，**仅ie8及之前支持** 是一个非标准特性，应尽量不要在生产环境中使用\r\n* 同一个元素同一个事件可以注册多个**监听器（事件处理函数）**\r\n* 按注册顺序依次执行 \r\n\r\n##### 事件监听方法的使用\r\n* `element.addEventListener(type,listener[,useCapture])`\r\n* `type`:事件类型字符串，如click moseover 注意不带on\r\n* `listener`：事件处理函数，事件发生时，会调用该监听函数\r\n* `useCapture`:可选参数，布尔值，默认false，与DOM事件流相关\r\n\r\n\r\n#### 解绑事件\r\n* 传统方法：`element.onclick=null`\r\n* 事件监听方法: \r\n    1. 注册：`element.addEventListener(事件类型,非匿名函数名)`\r\n    2. 解绑：\r\n        * `element.addEventListener(事件类型,非匿名函数名)`\r\n        *  或  `element.detachEvent(eventNameWithOn,非匿名函数名)` **仅ie8及之前支持**\r\n\r\n**两种方法的测试**\r\n\r\n<div id=\"demoBIUBITYy\">\r\n    <button>传统注册事件</button>\r\n    <button>方法监听注册事件</button>\r\n</div>\r\n<script>\r\n    var buttons=document.querySelectorAll(\"#demoBIUBITYy>button\")\r\n    buttons[0].onclick=function(){\r\n        alert(\"传统注册事件,触发消息1\")\r\n    }\r\n    buttons[0].onclick=function(){\r\n        alert(\"传统注册事件,触发消息2\")\r\n    }\r\n    buttons[1].addEventListener(\"click\",function(){\r\n        alert(\"方法监听注册事件,触发消息1\")\r\n    })\r\n    buttons[1].addEventListener(\"click\",function(){\r\n        alert(\"方法监听注册事件,触发消息2\")\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demoBIUBITYy\">\r\n    <button>传统注册事件</button>\r\n    <button>方法监听注册事件</button>\r\n</div>\r\n<script>\r\n    var buttons=document.querySelectorAll(\"#demoBIUBITYy>button\")\r\n    buttons[0].onclick=function(){\r\n        alert(\"传统注册事件,触发消息1\")\r\n    }\r\n    buttons[0].onclick=function(){\r\n        alert(\"传统注册事件,触发消息2\")\r\n    }\r\n    \r\n    buttons[1].addEventListener(\"click\",function(){\r\n        alert(\"方法监听注册事件,触发消息1\")\r\n    })\r\n    buttons[1].addEventListener(\"click\",function(){\r\n        alert(\"方法监听注册事件,触发消息2\")\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n**封装兼容性事件注册函数**\r\n```js\r\n    function myAddEventListener(element,eventName,callback)\r\n    {\r\n        if(document.addEventListener)//兼容性处理原则：首先照顾大多数浏览器，再处理特殊浏览器\r\n        {\r\n            element.addEventListener(eventName,callback);\r\n        }else if(document.attachEvent)\r\n        {\r\n            element.attachEvent(\"on\"+eventName,callback);\r\n        }else{\r\n            element[\"on\"+eventName]=callback;\r\n        }\r\n    }\r\n```\r\n\r\n**封装兼容性事件解绑函数**\r\n```js\r\n    function myAddEventListener(element,eventName,callback)\r\n    {\r\n        if(document.removeEventListener)//兼容性处理原则：首先照顾大多数浏览器，再处理特殊浏览器\r\n        {\r\n            element.addEventListener(eventName,callback);\r\n        }else if(document.detachEvent)\r\n        {\r\n            element.detachEvent(\"on\"+eventName,callback);\r\n        }else{\r\n            element[\"on\"+eventName]=null;\r\n        }\r\n    }\r\n```\r\n\r\n\r\n#### 事件委托\r\n* 时间委托也称事件代理，在JQuery中称事件委派\r\n* 对于ul>li这样结构的元素标签，实现点击li后弹出对话框，需要给所有li注册事件，li越多，访问DOM的次数也越多，这就会延长整个页面交互就绪的时间。\r\n\r\n##### 面试题：事件委托原理\r\n不是用for循环为每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用event.target属性和冒泡原理控制每个子节点\r\n\r\n**事件委托测试**\r\n\r\n<ul id=\"demoHsfweo9\">\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n</ul>\r\n<script>\r\n    var ul = document.querySelector(\"#demoHsfweo9\");\r\n    ul.addEventListener(\"click\",function(event){\r\n        for(var i=0;i<ul.children.length;i++)\r\n        {\r\n            ul.children[i].style.backgroundColor=\"\"\r\n        }\r\n        event.target.style.backgroundColor=\"pink\"\r\n    })\r\n</script>\r\n\r\n```html\r\n<ul id=\"demoHsfweo9\">\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n</ul>\r\n<script>\r\n    var ul = document.querySelector(\"#demoHsfweo9\");\r\n    ul.addEventListener(\"click\",function(event){\r\n        for(var i=0;i<ul.children.length;i++)\r\n        {\r\n            ul.children[i].style.backgroundColor=\"\"\r\n        }\r\n        event.target.style.backgroundColor=\"pink\"\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 事件对象\r\n```js\r\nelement.onclick=function(event){\r\n    console.log(event)\r\n}\r\n```\r\n* 事件对象代表了事件的状态，如键盘按下的状态，鼠标的位置，鼠标的按钮状态\r\n* 事件对象是事件处理函数的第一个形参获取到的对象\r\n* 事件对象只有事件发生才会存在，是系统自动创建并传递的\r\n* 事件对象是与事件相关的一系列数据的集合，\r\n    * 如鼠标点击事件发生后，事件对象中就包含鼠标的坐标信息\r\n* 事件对象的形参名可以自定义\r\n* 兼容性问题：ie678需要通过window.event来获取事件对象\r\n    * 兼容性写法 `event=event||window.event`\r\n  \r\n#### 事件对象的属性和方法\r\n1. **获取的是触发事件的元素对象** `event.target` \r\n    * 与`this`的区别：this永远指向被绑定事件的元素\r\n    * 简单来说：对于click事件，this返回的是绑定该事件的元素，target返回的是被点击的元素\r\n    * `event.currentTarget` 和 `this` 的值一致\r\n    * 兼容性问题：**ie678**仅支持`event.srcElement`属性\r\n    * 兼容性写法：\r\n        1. `var e=event||window.event;` \r\n        1. `var target=e.target||e.srcElement`\r\n1. **获取事件类型** `event.type` ，不带on\r\n1. **阻止默认事件默认行为** `event.preventDefault()` dom标准函数，阻止默认事件默认行为，如不让链接跳转\r\n    * 兼容性问题：\r\n        * **ie678** 调用该属性：`e.returnValue;`\r\n        * 新旧浏览器通用写法： return false; 但只能用于传统的注册方式\r\n1. **阻止冒泡** `event.stopPropagation()` dom标准方法 直译为停止传播\r\n    * 兼容性问题：ie678仅支持 event.cancelBubble=true 直译为取消冒泡\r\n\r\n\r\n### 鼠标事件对象\r\n#### 获取鼠标在页面中的坐标\r\n* 鼠标相关事件能获取到坐标\r\n* `event.clientX` 鼠标相对于**浏览器窗口可视区域**的X坐标,**左上角为(0,0)**,无论页面是否拖动\r\n* `event.clientY`\r\n* `event.pageX` 鼠标相对于**整个html文档页面**的X坐标 **IE678不支持** \r\n* `event.pageY`\r\n* `event.screenX` 鼠标相对于**电脑屏幕**的X坐标\r\n* `event.screenY`\r\n\r\n* 画了张图：\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-02-22-22-00.png)\r\n\r\n#### 案例：拖拽移动元素\r\n\r\n<div id=\"demoKjowejf9\" style=\"position: fixed; background-color:skyblue;width:100px;height:100px; cursor:move;\"></div>\r\n<script>\r\n    var demoKjowejf9=document.querySelector(\"#demoKjowejf9\")\r\n    function move(event){\r\n        // console.log(event.target);\r\n        demoKjowejf9.style.left=event.clientX - parseInt(demoKjowejf9.style.width)/2  +\"px\"\r\n        demoKjowejf9.style.top=event.clientY -  parseInt(demoKjowejf9.style.height)/2  +\"px\"\r\n    }\r\n    demoKjowejf9.addEventListener(\"mousedown\",function(event){\r\n        // console.log(event);\r\n        document.addEventListener(\"mousemove\",move)\r\n    })\r\n    demoKjowejf9.addEventListener(\"mouseup\",function(event){\r\n        // console.log(event);\r\n        document.removeEventListener(\"mousemove\",move)\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demoKjowejf9\" style=\"position: fixed; background-color:skyblue;width:100px;height:100px; cursor:move;\"></div>\r\n<script>\r\n    var demoKjowejf9=document.querySelector(\"#demoKjowejf9\")\r\n    function move(event){\r\n        // console.log(event.target);\r\n        demoKjowejf9.style.left=event.clientX - parseInt(demoKjowejf9.style.width)/2  +\"px\"\r\n        demoKjowejf9.style.top=event.clientY -  parseInt(demoKjowejf9.style.height)/2  +\"px\"\r\n    }\r\n    demoKjowejf9.addEventListener(\"mousedown\",function(event){\r\n        // console.log(event);\r\n        document.addEventListener(\"mousemove\",move)\r\n    })\r\n    demoKjowejf9.addEventListener(\"mouseup\",function(event){\r\n        // console.log(event);\r\n        document.removeEventListener(\"mousemove\",move)\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n\r\n### 键盘事件对象\r\n触发事件名\r\n* 按键事件执行顺序为down->press->up\r\n* `element.onkeyup` 键盘弹起 松开按键时会触发一次\r\n* `element.onkeydown` 键盘按下 按下后会一直不断触发\r\n* `element.onkeypress` 键盘按下，按下后会一直不断触发 但不能识别功能键，如ctrl shift\r\n键盘事件对象属性\r\n* `event.key` 按键值，低版本浏览器不支持\r\n* `event.keyCode` 按键ASCII值\r\n* `keyup` 和 `keydown` 事件不区分字母大小写，a和A都是65\r\n* `keypress` 事件区分字母大小写，a是97 A是65\r\n\r\n#### 案例：使输入框获得焦点\r\n\r\n<input type=\"text\" id=\"demoNFOEWFH1234\">\r\n<script>\r\n    var demoNFOEWFH1234 = document.querySelector(\"#demoNFOEWFH1234\")\r\n    document.addEventListener(\"keyup\",function(e){//用keyup可以避免字符被输入进文本框\r\n        // console.log(e.keyCode);\r\n        if(e.keyCode==83)\r\n        {\r\n            demoNFOEWFH1234.focus();//使输入框获得焦点\r\n        }\r\n    })\r\n</script>\r\n\r\n```html\r\n<input type=\"text\" id=\"demoNFOEWFH1234\">\r\n<script>\r\n    var demoNFOEWFH1234 = document.querySelector(\"#demoNFOEWFH1234\")\r\n    document.addEventListener(\"keyup\",function(e){//用keyup可以避免字符被输入进文本框\r\n        // console.log(e.keyCode);\r\n        if(e.keyCode==83)\r\n        {\r\n            demoNFOEWFH1234.focus();//使输入框获得焦点\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n#### 案例：放大显示输入内容\r\n\r\n注意对于文本框来说，keydown keypress事件发生时，文字还未填入文本框中\r\nkeyup事件发生时，文字已经落入文本框\r\n\r\n<style>\r\n     #demo123WEFWF{\r\n        position: relative;\r\n     }\r\n    #demo123WEFWF input{\r\n        padding: 0;\r\n        margin-top: 0px;\r\n        height: 20px;\r\n        width: 200px;\r\n        box-sizing: border-box;\r\n        outline: none;\r\n        /* height: 50px; */\r\n    }\r\n    #demo123WEFWF div{\r\n        box-sizing: border-box;\r\n        display: none;\r\n        margin-bottom: 8px;\r\n        padding-left: 10px;\r\n        height:40px;\r\n        width: 200px;\r\n        background-color: white;\r\n        box-shadow: 0 0 8px gray;\r\n        line-height: 40px;\r\n        font-size: 30px;\r\n\r\n        word-break: keep-all;\r\n        overflow-x: auto;\r\n        overflow-y: hidden;\r\n    }\r\n    #demo123WEFWF div::-webkit-scrollbar{\r\n    /* 清除滚动条 */\r\n        /* display: none; */\r\n        height: 2px;\r\n    }\r\n    #demo123WEFWF div::-webkit-scrollbar-thumb{\r\n        /* height: 3px; */\r\n        background-color: gray;\r\n    }\r\n    #demo123WEFWF::after{\r\n        position:absolute;\r\n        top: 40px;\r\n        left: 10px;\r\n        display: block;\r\n        content: \"\";\r\n        width: 0;\r\n        height: 0;\r\n        border-top: 5px solid white;\r\n        border-bottom: 5px solid transparent;\r\n        border-left: 5px solid transparent;\r\n        border-right: 5px solid transparent;\r\n    }\r\n</style>\r\n<div id=\"demo123WEFWF\">\r\n    <div></div>\r\n    <input type=\"text\" >\r\n</div>\r\n<script>\r\n    var demo123WEFWF = document.querySelector(\"#demo123WEFWF\")\r\n    var input = demo123WEFWF.querySelector(\"input\")\r\n    var div = demo123WEFWF.querySelector(\"div\")\r\n    input.addEventListener(\"keyup\",function(event){\r\n        if(this.value==\"\")\r\n        {\r\n            div.style.display=\"none\"\r\n        }else{\r\n            div.style.display=\"block\"\r\n            div.innerHTML=this.value;\r\n            div.scrollLeft =div.scrollWidth;//使滚动条右对齐，以始终显示最新内容\r\n        }\r\n    })\r\n    input.addEventListener(\"focus\",function(){//获得焦点后显示盒子\r\n        if(this.value!=\"\")\r\n            div.style.display=\"block\"\r\n    })\r\n    input.addEventListener(\"blur\",function(){//失去焦点后隐藏盒子\r\n        div.style.display=\"none\"\r\n    })\r\n</script>\r\n\r\n```html\r\n<style>\r\n     #demo123WEFWF{\r\n        position: relative;\r\n     }\r\n    #demo123WEFWF input{\r\n        padding: 0;\r\n        margin-top: 0px;\r\n        height: 20px;\r\n        width: 200px;\r\n        box-sizing: border-box;\r\n        outline: none;\r\n        /* height: 50px; */\r\n    }\r\n    #demo123WEFWF div{\r\n        box-sizing: border-box;\r\n        display: none;\r\n        margin-bottom: 8px;\r\n        padding-left: 10px;\r\n        height:40px;\r\n        width: 200px;\r\n        background-color: white;\r\n        box-shadow: 0 0 8px gray;\r\n        line-height: 40px;\r\n        font-size: 30px;\r\n\r\n        word-break: keep-all;\r\n        overflow-x: auto;\r\n        overflow-y: hidden;\r\n    }\r\n    #demo123WEFWF div::-webkit-scrollbar{\r\n    /* 清除滚动条 */\r\n        /* display: none; */\r\n        height: 2px;\r\n    }\r\n    #demo123WEFWF div::-webkit-scrollbar-thumb{\r\n        /* height: 3px; */\r\n        background-color: gray;\r\n    }\r\n    #demo123WEFWF::after{\r\n        position:absolute;\r\n        top: 40px;\r\n        left: 10px;\r\n        display: block;\r\n        content: \"\";\r\n        width: 0;\r\n        height: 0;\r\n        border-top: 5px solid white;\r\n        border-bottom: 5px solid transparent;\r\n        border-left: 5px solid transparent;\r\n        border-right: 5px solid transparent;\r\n    }\r\n</style>\r\n<div id=\"demo123WEFWF\">\r\n    <div></div>\r\n    <input type=\"text\" >\r\n</div>\r\n<script>\r\n    var demo123WEFWF = document.querySelector(\"#demo123WEFWF\")\r\n    var input = demo123WEFWF.querySelector(\"input\")\r\n    var div = demo123WEFWF.querySelector(\"div\")\r\n    input.addEventListener(\"keyup\",function(event){\r\n        if(this.value==\"\")\r\n        {\r\n            div.style.display=\"none\"\r\n        }else{\r\n            div.style.display=\"block\"\r\n            div.innerHTML=this.value;\r\n            div.scrollLeft =div.scrollWidth;//使滚动条右对齐，以始终显示最新内容\r\n        }\r\n    })\r\n    input.addEventListener(\"focus\",function(){//获得焦点后显示盒子\r\n        if(this.value!=\"\")\r\n            div.style.display=\"block\"\r\n    })\r\n    input.addEventListener(\"blur\",function(){//失去焦点后隐藏盒子\r\n        div.style.display=\"none\"\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 操作元素\r\n### 修改元素内容\r\n* `element.innerText` \r\n    * IE发起的标准\r\n    * 写入的字符串被当成纯文本 \r\n    * 读取时会过滤掉html标签、空格、换行\r\n* `element.innerHtml`\r\n    * W3C发起的标准\r\n    * 写入的文本有html标签则会解析 \r\n    * 读取时保留html标签、空格、换行\r\n\r\n**修改元素内容示例**\r\n\r\n<button id=\"btn\">修改元素内容</button>\r\n<p id=\"textBox1\"></p>\r\n<p id=\"textBox2\"></p>\r\n<script>\r\n    var btn=document.getElementById(\"btn\")\r\n    var textBox1=document.getElementById(\"textBox1\")\r\n    btn.onclick = function(){\r\n        var date=new Date()\r\n        console.log(date);\r\n        //写入纯文本\r\n        textBox1.innerText='<strong>' + date + \"</strong>\"\r\n        //写入可包含html标签的文本\r\n        textBox2.innerHTML='<strong>' + date + \"</strong>\"\r\n    }\r\n</script>\r\n\r\n```html\r\n    <button id=\"btn\">修改元素内容</button>\r\n    <p id=\"textBox1\"></p>\r\n    <p id=\"textBox2\"></p>\r\n    <script>\r\n        var btn=document.getElementById(\"btn\")\r\n        var textBox1=document.getElementById(\"textBox1\")\r\n        btn.onclick = function(){\r\n            var date=new Date()\r\n            console.log(date);\r\n            //写入纯文本\r\n            textBox1.innerText='<strong>' + date + \"</strong>\"\r\n            //写入可包含html标签的文本\r\n            textBox2.innerHTML='<strong>' + date + \"</strong>\"\r\n        }\r\n    </script>\r\n```\r\n\r\n\r\n### 修改元素属性\r\n获取、修改标签内置属性\r\n* `element.src`\r\n* `element.title`\r\n* `element.herf`\r\n* `element.id`\r\n* `element.alt`\r\n* `element.display`\r\n\r\n获取、修改标签自定义属性\r\n* `element.getAttribute(\"标签内置属性名\")`\r\n* `element.getAttribute(\"自定义属性名\")`\r\n* `element.setAttribute(\"标签内置属性名\",\"属性值\")`\r\n* `element.setAttribute(\"自定义属性名\",\"属性值\")`\r\n* H5新增方法:\r\n    * h5规定自定义属性以`data-`开头，下述方法只能获取以这种方式命名的属性\r\n    * `element.dataset.index` 获取的是`data-index`属性 \r\n    * `element.dataset[\"index\"]` 获取的是`data-index`属性\r\n    * `element.dataset.listName` 获取的是`data-list-name`属性 \r\n\r\n移除属性\r\n* `element.removeAttribute(\"属性名\")`\r\n\r\n```html\r\n<div 自定义属性名=\"属性值\"></div>\r\n<script>\r\n    var div=document.querySelector(\"div\")\r\n    console.log(div.getAttribute(\"自定义属性名\"))\r\n    div.setAttribute(\"自定义属性名\",\"属性值\")\r\n</script>\r\n\r\n```\r\n\r\n### 修改元素样式\r\n* `element.style` **行内样式属性** 优先级较高\r\n    * `element.style.backgroundColor=\"pink\"` 修改背景颜色，驼峰命名法\r\n    * `element.style.fontSize` \r\n    * `element.style.width` \r\n  \r\n### 修改元素类名\r\n* `element.ClassName` **类名样式属性**\r\n    * 因为class是保留字，所以不能使用，名为ClassName\r\n    * `element.ClassName=\"类名1 类名2\"` 修改背景颜色，驼峰命名法\r\n\r\n### 单标签(表单)元素属性的修改\r\n* 对于`input`等的单标签，需通过`element.value`更改标签内容\r\n* element.type\r\n* element.value\r\n* element.value.length\r\n* element.checked\r\n* element.selected\r\n* element.disabled\r\n\r\n\r\n### 操作元素示例\r\n\r\n\r\n\r\n**修改单标签元素内容**\r\n\r\n<input id=\"input2\" type=\"text\" value=\"请输入内容\" style=\"color: #999;\">\r\n<button id=\"btn2\">提交</button>\r\n<script>\r\n    var btn2=document.getElementById(\"btn2\")\r\n    var input2=document.getElementById(\"input2\")\r\n    btn2.onclick = function(){//点击按钮后禁用输入框和按钮\r\n        //this 表示函数的调用者，也就是btn2\r\n        this.disabled=true\r\n        input2.disabled=true\r\n        input2.value+=\" 数据已锁定\"\r\n    }\r\n    input2.onfocus=function(){//点击后获得焦点 清空输入框默认值\r\n        if(this.value==\"请输入内容\")\r\n            this.value=\"\"\r\n        this.style.color=\"#333\"\r\n    }\r\n    input2.onblur=function(){//失去焦点后 若输入框为空 填写默认值\r\n        if(this.value==\"\")\r\n            this.value=\"请输入内容\"\r\n        this.style.color=\"#999\"\r\n    }\r\n</script>\r\n\r\n```html\r\n<input id=\"input2\" type=\"text\" value=\"请输入内容\" style=\"color: #999;\">\r\n<button id=\"btn2\">提交</button>\r\n<script>\r\n    var btn2=document.getElementById(\"btn2\")\r\n    var input2=document.getElementById(\"input2\")\r\n    btn2.onclick = function(){//点击按钮后禁用输入框和按钮\r\n        //this 表示函数的调用者，也就是btn2\r\n        this.disabled=true\r\n        input2.disabled=true\r\n        input2.value+=\" 数据已锁定\"\r\n    }\r\n    input2.onfocus=function(){//点击后获得焦点 清空输入框默认值\r\n        if(this.value==\"请输入内容\")\r\n            this.value=\"\"\r\n        this.style.color=\"#333\"\r\n    }\r\n    input2.onblur=function(){//失去焦点后 若输入框为空 填写默认值\r\n        if(this.value==\"\")\r\n            this.value=\"请输入内容\"\r\n        this.style.color=\"#999\"\r\n    }\r\n</script>\r\n```\r\n\r\n**密码框明文密文显示切换**\r\n\r\n<input id=\"input3\" type=\"password\" value=\"密码123\">\r\n<button id=\"btn3\">切换显示方式</button>\r\n<script>\r\n    var btn3=document.getElementById(\"btn3\")\r\n    var input3=document.getElementById(\"input3\")\r\n    btn3.onclick = function(){//点击按钮后显示明文密码\r\n        if(input3.type==\"password\")\r\n            input3.type=\"text\"\r\n        else\r\n            input3.type=\"password\"\r\n    }\r\n</script>\r\n\r\n```html\r\n<input id=\"input3\" type=\"password\" value=\"密码123\">\r\n<button id=\"btn3\">切换显示方式</button>\r\n<script>\r\n    var btn3=document.getElementById(\"btn3\")\r\n    var input3=document.getElementById(\"input3\")\r\n    btn3.onclick = function(){//点击按钮后显示明文密码\r\n        if(input3.type==\"password\")\r\n            input3.type=\"text\"\r\n        else\r\n            input3.type=\"password\"\r\n    }\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n## 节点操作\r\n* 节点类型 `node.nodeType`\r\n    * 元素节点：nodeType=1\r\n    * 属性节点：nodeType=2\r\n    * 文本节点：nodeType=3 包含文本空格换行等...）\r\n* 节点名 `node.nodeName`\r\n* 节点值 `node.nodeValue`\r\n* **获取父节点** `node.parentNode` 没有父节点返回空\r\n* **获取子节点** `node.childNodes` （标准） 包含元素子节点间的换行 空格等 可以用for循环遍历所有的子节点提取出节点类型为文本节点的节点 但一般不使用这种方式\r\n* **获取子元素节点** `node.children` （非标准，但已得到各浏览器支持）是一个只读属性\r\n* 第一个子节点 `node.firstChild` 包括文本节点\r\n* 最后一个子节点 `node.lastChild` 包括文本节点\r\n* 第一个子元素节点 `node.firstElementChild` 找不到返回null 存在兼容性问题ie678不支持\r\n* 最后一个子元素节点 `node.lastElementChild` 找不到返回null 存在兼容性问题\r\n* 解决兼容性的实际开发写法 \r\n    *  第一个子元素节点 `node.children[0]`\r\n    * 最后一个子元素节点 `node.children[node.children.length - 1 ]`\r\n* **获取下一个兄弟节点** `node.nextSibling`\r\n* **获取前一个兄弟节点** `node.previousSibling`\r\n* **获取下一个兄弟元素节点** `node.nextElementSibling` ie678不支持\r\n* **获取前一个兄弟元素节点** `node.previousElementSibling` ie678不支持\r\n* **兼容性获取兄弟元素节点**\r\n    ```js\r\n    function getNextElementSibling(node)\r\n    {\r\n        for(var i=0;i<node.children.length;i++)\r\n        {\r\n            if(node.children[i].nodeType==1)\r\n            {\r\n                return node.children[i]\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    ```\r\n* **创建元素节点** `document.createElement(\"标签名\")`\r\n* **附加子节点** node.appendChild(newNode)\r\n* **在某个子元素之前附加子节点** node.insertBefore(newNode,基准元素)\r\n\r\n* **删除节点** `node.removeChild(待删除的子节点)` 返回删除的节点\r\n\r\n* **克隆节点** `待克隆节点Node.cloneNode()` 参数为空或为false是浅拷贝，没有元素内容；参数为true是深拷贝\r\n\r\n* `document.write(\"<div></div>\")` 直接将n内容写入页面的内容流，**如果文档流已经执行完毕，执行该语句会导致页面全部重绘**\r\n\r\n* 创建元素的效率问题（经典面试题）\r\n    * 方法1\r\n        * `document.write(\"<div></div>\")` **如果文档流已经执行完毕，执行该语句会导致页面全部重绘**\r\n    * 方法2\r\n        * `node.appendChild(document.createElement(\"div\"))` **效率高** 循环执行1000次耗时17ms\r\n    * 方法3\r\n        * `node.innerHtml+=\"<div></div>\"`  **效率低** 循环执行1000次耗时3s 因为要拼接字符串\r\n    * 方法4\r\n        1. `list=[];` \r\n        2. `list.push(\"<div>循环执行1000次</div>\");`\r\n        3. `node.innerHtml=list.join(\"\")` **效率最高** 耗时8ms 不用拼接字符串\r\n\r\n\r\n## 元素偏移量offset系列属性\r\n* 可以动态的获取元素的**位置**，**大小**\r\n* 获取的元素**位置**偏移量是相对于带有定位属性的父元素的，若所有父元素都没有定位属性则相对于body\r\n* 获取的元素**大小**，也就是宽高，包含**width/height + padding + border**\r\n* 返回的数值**没有单位**\r\n* 是一个**只读**属性\r\n\r\n**常用属性**\r\n* `element.offsetParent` 返回该元素**带有定位属性的父级**，如果找不到则返回body\r\n* `element.offsetTop` 返回元素的上偏移（相对于offsetParent）\r\n* `element.offsetLeft` 返回元素的左偏移（相对于offsetParent）\r\n* `element.offsetWidth` 返回元素的宽度（包含width padding border）\r\n* `element.offsetHeight` 返回元素的宽度（包含height padding border）\r\n\r\noffset和style属性的区别\r\n* offset得到的是元素盒子的宽高（包含padding border），style得到的是元素行内样式中设置的宽高（不包含padding border）\r\n* offset没有单位 style有单位\r\n* offset是只读属性 style是可读写属性\r\n\r\n\r\n**商品细节展示**\r\n\r\n效果图:\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-05-04-58-49.png)\r\n\r\n```html\r\n<!-- div#demoOHdfn9e的父级需为body -->\r\n<style>\r\n    #demoOHdfn9e{\r\n        position: relative;\r\n        margin: 0;\r\n        width: 400px;\r\n        height: 400px;\r\n        background: url(./images/jsWebApis学习笔记之DOM/2022-07-05-04-19-00.png);\r\n        background-size: contain;\r\n    }\r\n    #demoOHdfn9e .mask{\r\n        display: none;\r\n        position: absolute;\r\n        width: 200px;\r\n        height: 200px;\r\n        background-color: gold;\r\n        opacity: 0.5;\r\n        cursor: move;\r\n    }\r\n    #demoOHdfn9e .big{\r\n        display: none;\r\n        position: absolute;\r\n        left: 100%;\r\n        top: 0;\r\n        width: 500px;\r\n        height: 500px;\r\n        overflow: hidden;\r\n    }\r\n    #demoOHdfn9e .big img{\r\n        position: absolute;\r\n\r\n    }\r\n</style>\r\n<div id=\"demoOHdfn9e\">\r\n    <div class=\"mask\"></div>\r\n    <div class=\"big\"><img src=\"/images/jsWebApis学习笔记之DOM/2022-07-05-04-19-00.png\" alt=\"\"></div>\r\n</div>\r\n<script>\r\n    var demoOHdfn9e = document.querySelector(\"#demoOHdfn9e\")\r\n    var mask = document.querySelector(\"#demoOHdfn9e>.mask\")\r\n    var big = document.querySelector(\"#demoOHdfn9e>.big\")\r\n    var img = document.querySelector(\"#demoOHdfn9e>.big>img\")\r\n    function updataPos(e){//更新子盒子的位置\r\n            //鼠标相对于父级盒子的坐标\r\n            var innerMousePosX = e.pageX - demoOHdfn9e.offsetLeft\r\n            var innerMousePosY = e.pageY - demoOHdfn9e.offsetTop\r\n            //计算子盒子相对于父盒子的偏移\r\n            var newMaskPosX = innerMousePosX-mask.offsetWidth/2\r\n            var newMaskPosY = innerMousePosY-mask.offsetHeight/2\r\n            //限制小盒子的移动范围\r\n            if(newMaskPosX < 0)\r\n            {\r\n                newMaskPosX=0\r\n            }else if(demoOHdfn9e.offsetWidth-mask.offsetWidth < newMaskPosX )\r\n            {\r\n                newMaskPosX=demoOHdfn9e.offsetWidth-mask.offsetWidth\r\n            }\r\n            if( newMaskPosY < 0 )\r\n            {\r\n                newMaskPosY= 0\r\n            }\r\n            else if(demoOHdfn9e.offsetHeight-mask.offsetHeight < newMaskPosY)\r\n            {\r\n                newMaskPosY=demoOHdfn9e.offsetHeight-mask.offsetHeight\r\n            }\r\n            mask.style.left=newMaskPosX + \"px\";\r\n            mask.style.top=newMaskPosY + \"px\"\r\n            //根据比例计算大图的宽高\r\n            img.style.width=demoOHdfn9e.offsetWidth * big.offsetWidth / mask.offsetWidth + \"px\"\r\n            img.style.height=demoOHdfn9e.offsetHeight * big.offsetHeight / mask.offsetHeight + \"px\"\r\n            //根据比例移动大图\r\n            img.style.left = - newMaskPosX * img.offsetWidth / demoOHdfn9e.offsetWidth  + \"px\"\r\n            img.style.top = - newMaskPosY * img.offsetHeight / demoOHdfn9e.offsetHeight + \"px\"\r\n        }\r\n    demoOHdfn9e.addEventListener(\"mouseenter\",function(e){\r\n        mask.style.display=\"block\";\r\n        big.style.display=\"block\";\r\n        demoOHdfn9e.addEventListener(\"mousemove\",updataPos);\r\n    })\r\n    demoOHdfn9e.addEventListener(\"mouseleave\",function(){\r\n        mask.style.display=\"none\";\r\n        big.style.display=\"none\";\r\n        demoOHdfn9e.removeEventListener(\"mousemove\",updataPos);\r\n    })\r\n</script>\r\n```\r\n## 元素可视区client系列属性\r\n* client可获得元素的大小（内容+padding），边框的大小\r\n* `element.clientTop` 上边框的大小\r\n* `element.clientLeft` 左边框的大小\r\n* `element.clientWidth` 内容区域+padding的宽\r\n* `element.clientHeight` 内容区域+padding的高\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-05-06-25-04.png)\r\n\r\n\r\n## 元素滚动scroll系列属性\r\n\r\n* element.scrollTop 被卷去的上侧边距 (没有bottom)\r\n* element.scrollLeft 被卷去的左侧边距 （没有right）\r\n* element.scrollWidth 自身实际宽度\r\n* element.scrollHeight 自身实际高度\r\n* 滚动事件`element.onscroll`\r\n\r\n\r\n**草图**\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-05-20-14-21.png)\r\n\r\n\r\n**测试**\r\n\r\n<div id=\"demo1237hf834r9\">\r\n    内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n</div>\r\n<p id=\"demoNDNDURNO\"></p>\r\n<style>\r\n    #demo1237hf834r9{\r\n        width: 200px;\r\n        height: 200px;\r\n        overflow: auto;\r\n        word-break: keep-all;\r\n    }\r\n</style>\r\n<script>\r\n    var demo1237hf834r9 = document.querySelector(\"#demo1237hf834r9\")\r\n    var demoNDNDURNO = document.querySelector(\"#demoNDNDURNO\")\r\n    demo1237hf834r9.addEventListener(\"scroll\",function(){\r\n        demoNDNDURNO.innerHTML=\r\n        \"scrollTop:\" + demo1237hf834r9.scrollTop + \"<br>\" +\r\n        \"scrollLeft:\" + demo1237hf834r9.scrollLeft + \"<br>\" +\r\n        \"scrollWidth:\" + demo1237hf834r9.scrollWidth + \"<br>\" +\r\n        \"scrollHeight:\" + demo1237hf834r9.scrollHeight;\r\n    })\r\n</script>\r\n\r\n\r\n```html\r\n<div id=\"demo1237hf834r9\">\r\n    内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n</div>\r\n<p id=\"demoNDNDURNO\"></p>\r\n<style>\r\n    #demo1237hf834r9{\r\n        width: 200px;\r\n        height: 200px;\r\n        overflow: auto;\r\n        word-break: keep-all;\r\n    }\r\n</style>\r\n<script>\r\n    var demo1237hf834r9 = document.querySelector(\"#demo1237hf834r9\")\r\n    var demoNDNDURNO = document.querySelector(\"#demoNDNDURNO\")\r\n    demo1237hf834r9.addEventListener(\"scroll\",function(){\r\n        demoNDNDURNO.innerHTML=\r\n        \"scrollTop:\" + demo1237hf834r9.scrollTop + \"<br>\" +\r\n        \"scrollLeft:\" + demo1237hf834r9.scrollLeft + \"<br>\" +\r\n        \"scrollWidth:\" + demo1237hf834r9.scrollWidth + \"<br>\" +\r\n        \"scrollHeight:\" + demo1237hf834r9.scrollHeight;\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n## 页面window.scroll\r\n* 页面被卷去的头部：window.pageYoffset\r\n* 页面被卷去的左侧：window.pageXoffset\r\n* ![](./images/jsWebApis学习笔记之DOM/2022-07-05-21-52-44.png)\r\n\r\n\r\n**案例测试**\r\n\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-06-00-26-26.png)\r\n\r\n```html\r\n<body>\r\n<div id=\"demofowefj3490\">\r\n    侧边栏测试 \r\n</div>\r\n<div style=\"margin: 0 auto; width:1000px;height: 2000px; background-color: pink;\">主体内容</div>\r\n<style>\r\n    #demofowefj3490{\r\n        position: absolute;\r\n        bottom: 200px;\r\n        right: 50px;\r\n        width: 50px;\r\n        height: 200px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    var demofowefj3490 = document.querySelector(\"#demofowefj3490\")\r\n    var offsetTop = demofowefj3490.offsetTop \r\n    document.addEventListener(\"scroll\",function()\r\n    {\r\n        if(window.pageYOffset >= offsetTop)\r\n        {\r\n            demofowefj3490.style.position = \"fixed\";\r\n            demofowefj3490.style.top = \"0\";\r\n        }else\r\n        {\r\n            demofowefj3490.style.position = \"absolute\";\r\n            demofowefj3490.style.top = \"\";\r\n        }\r\n    })\r\n</script>\r\n</body>\r\n```\r\n\r\n## offset、client、scroll三系列总结\r\n* offsetWidth 元素的宽度，包含边框\r\n* clientWidth 元素的宽度，content+padding部分的宽度；不包含边框；\r\n* scrollWidth 元素内容的实际宽度，大于等于content的宽度\r\n* offset主要用来获取在页面中的偏移位置\r\n* client主要用来获取元素的宽高\r\n* offset主要用来获取被滚动条卷去的内容部分的宽高\r\n* 获取整个页面在窗口中的滚动距离用window.pageYOffset\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-06-00-35-41.png)\r\n\r\n## dom核心知识点总结\r\n### 创建\r\n* `document.write()`\r\n* `element.innerHTML`  \r\n* `document.createElement()`  \r\n\r\n### 增\r\n* `node.appendChild()`\r\n* `node.insertBefore()`\r\n\r\n### 删\r\n* `node.removeChild(childNode)`\r\n\r\n### 改\r\n修改元素属性\r\n* `element.src`\r\n* `element.href`\r\n* `element.title`\r\n\r\n修改普通元素内容\r\n* `element.innerHTML`\r\n* `element.innerText`\r\n\r\n修改表单元素\r\n* `element.value`\r\n* `element.type`\r\n* `element.disabled`\r\n* 注意： `element.active` 似乎不存在\r\n\r\n修改元素样式\r\n* `element.style`\r\n* `element.className`\r\n\r\n### 查\r\nDOM的API(古老用法不推荐)\r\n* `document.getElementById()`\r\n* `document.getElementsByTagName()`\r\n\r\nH5的新方法(提倡)\r\n* `document.querySelector()`\r\n* `document.querySelectorAll()`\r\n\r\n利用节点关系获取元素\r\n* `node.parentNode`\r\n* `node.children`\r\n* `node.previousElementSibling`\r\n* `node.nextElementSibling`\r\n\r\n### 属性操作\r\n主要针对于自定义属性\r\n* `element.setAttribute(属性名,属性值)`\r\n* `element.getAttribute(属性名)`\r\n* `element.removeAttribute(属性名)`\r\n\r\n### 事件操作\r\n* `element.onclick` 鼠标点击\r\n* `element.onfocus` 获得鼠标焦点\r\n* `element.onblur` 失去鼠标焦点\r\n* `element.onmouseover` 鼠标经过\r\n* `element.onmouseout` 鼠标离开\r\n* `element.onmousemove` 鼠标移动\r\n* `element.onmouseup` 鼠标弹起触发\r\n* `element.onmousedown` 鼠标按下触发\r\n* `element.onkeyup` 键盘弹起 松开按键时会触发一次\r\n* `element.onkeydown` 键盘按下 按下后会一直不断触发\r\n* `element.onkeypress` 键盘按下，按下后会一直不断触发 但不能识别功能键，如ctrl shift\r\n* 按键事件执行顺序为down->press->up\r\n\r\n\r\n## 一些案例\r\n\r\n### 全选框\r\n\r\n<table id=\"tb1\" >\r\n    <thead>\r\n        <tr style=\"background-color: rgb(174, 174, 174);\">\r\n            <td><input type=\"checkbox\">全选</td><td>商品名称</td><td>价钱</td>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<script>\r\n    var tb1InputMaster=document.querySelector(\"#tb1>thead input\")\r\n    var tb1_btOthers=document.querySelectorAll(\"#tb1>tbody input\")\r\n    console.log(tb1InputMaster)\r\n    tb1InputMaster.onclick=function(){\r\n        if(this.checked){\r\n            for(var i = 0;i<tb1_btOthers.length;i++)\r\n            {\r\n                tb1_btOthers[i].checked=true;\r\n            }\r\n        }else{\r\n            for(var i = 0;i<tb1_btOthers.length;i++)\r\n            {\r\n                tb1_btOthers[i].checked=false;\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n```html\r\n<table id=\"tb1\" >\r\n    <thead>\r\n        <tr style=\"background-color: rgb(174, 174, 174);\">\r\n            <td><input type=\"checkbox\">全选</td><td>商品名称</td><td>价钱</td>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<script>\r\n    var tb1InputMaster=document.querySelector(\"#tb1>thead input\")\r\n    var tb1_btOthers=document.querySelectorAll(\"#tb1>tbody input\")\r\n    console.log(tb1InputMaster)\r\n    tb1InputMaster.onclick=function(){\r\n        if(this.checked){\r\n            for(var i = 0;i<tb1_btOthers.length;i++)\r\n            {\r\n                tb1_btOthers[i].checked=true;\r\n            }\r\n        }else{\r\n            for(var i = 0;i<tb1_btOthers.length;i++)\r\n            {\r\n                tb1_btOthers[i].checked=false;\r\n            }\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n### tab栏切换制作 \r\n\r\n![](./images/jsWebApis学习笔记之DOM/2022-06-30-10-37-10.png)\r\n\r\n```html\r\n<style>\r\n    #lableBox{\r\n        margin: 0 auto;\r\n        width: 600px;\r\n        height: 600px;\r\n        background-color: gray;\r\n    }\r\n    #lableBox ul{\r\n        margin: 0;\r\n        padding: 0;\r\n        list-style: none;\r\n    }\r\n    #lableBox .head ul{\r\n        display: flex;\r\n        justify-content: space-evenly;\r\n        align-items: center;\r\n        background-color: green;\r\n    }\r\n    #lableBox .head li{\r\n        flex: 1;\r\n        text-align: center;\r\n        /* background-color: red; */\r\n    }\r\n    .current{\r\n        background-color: red;\r\n    }\r\n    #lableBox .body li{\r\n        display: none;\r\n    }\r\n</style>\r\n<div id=\"lableBox\">\r\n    <div class=\"head\">\r\n        <ul>\r\n            <li class=\"current\" index=\"\">标签1</li>\r\n            <li class=\"\" index=\"\">标签2</li>\r\n            <li class=\"\" index=\"\">标签3</li>\r\n            <li class=\"\" index=\"\">标签4</li>\r\n            <li class=\"\" index=\"\">标签5</li>\r\n        </ul>\r\n    </div>\r\n    <div class=\"body\">\r\n        <ul>\r\n            <li style=\"display: block;\">内容1</li>\r\n            <li>内容2</li>\r\n            <li>内容3</li>\r\n            <li>内容4</li>\r\n            <li>内容5</li>\r\n        </ul>\r\n    </div>\r\n</div>\r\n<script>\r\n    var lables=document.querySelectorAll(\"#lableBox .head li\")\r\n    var items=document.querySelectorAll(\"#lableBox .body li\")\r\n\r\n    for(var i=0;i<lables.length;i++)//给li添加序号\r\n    {\r\n        lables[i].setAttribute(\"index\",i)\r\n    }\r\n\r\n\r\n    for(var i=0;i<lables.length;i++)\r\n    {\r\n        lables[i].onclick=function(){\r\n\r\n            for(var i=0;i<lables.length;i++)//设置所有标签背景色为空\r\n            {\r\n                lables[i].className=\"\"\r\n            }\r\n\r\n            this.className=\"current\"//设置选中的标签背景色为红色\r\n\r\n\r\n            for(var i=0;i<items.length;i++)//设置所有内容为不显示\r\n            {\r\n                items[i].style.display=\"none\"\r\n            }\r\n\r\n            items[this.getAttribute(\"index\")].style.display=\"block\"//根据选中标签索引显示内容\r\n        }\r\n    }\r\n\r\n</script>\r\n```\r\n\r\n\r\n### 新浪下拉菜单\r\n\r\n<style>\r\n    #demoQWRWEFE *,\r\n    #demoQWRWEFE *::after,\r\n    #demoQWRWEFE *::before\r\n    {\r\n        padding: 0;\r\n        margin: 0;\r\n        content: \"\";\r\n        list-style: none;\r\n    }\r\n    #demoQWRWEFE{\r\n        margin: 0 auto;\r\n        width: 500px;\r\n        /* height: 50px; */\r\n        background-color: red;\r\n    }\r\n    #demoQWRWEFE>ul{\r\n        display: flex;\r\n        justify-content: space-evenly;\r\n        align-items: center;\r\n    }\r\n    #demoQWRWEFE>ul>li{\r\n        flex: 1;\r\n        position: relative;\r\n        /* height: 50px; */\r\n        text-align: center;\r\n        background-color: green;\r\n        border: 1px solid gray;\r\n    }\r\n    #demoQWRWEFE>ul>li:hover{\r\n        background-color: rgb(1, 112, 1);\r\n    }\r\n    #demoQWRWEFE>ul>li>ul{\r\n        z-index:10;\r\n        display: none;\r\n        position: absolute;\r\n        top:100%;\r\n        left: 0;\r\n        width: 100px;\r\n        background-color: rgb(222, 222, 222);\r\n    }\r\n    #demoQWRWEFE>ul>li>ul>li:hover{\r\n        background-color: rgb(131, 131, 131);\r\n    }\r\n</style>\r\n<div id=\"demoQWRWEFE\">\r\n    <ul>\r\n        <li>\r\n            <span>标签1</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签2</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签3</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签4</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签5</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签6</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n    </ul>\r\n</div>\r\n\r\n<script>\r\n    var demoQWRWEFE=document.querySelector(\"#demoQWRWEFE\")\r\n    var lis = demoQWRWEFE.children[0].children\r\n    for(var i=0;i<lis.length;i++ )\r\n    {   \r\n        //注意是给li添加事件 而不是给 li>span 和 li>ul 分别添加事件 否则会有bug\r\n        lis[i].onmouseover=function(){\r\n            for(var i=0;i<lis.length;i++ ){\r\n                lis[i].children[1].style.display=\"\"\r\n            }\r\n            this.children[1].style.display=\"block\"\r\n        }\r\n        lis[i].onmouseout=function(){\r\n            for(var i=0;i<lis.length;i++ ){\r\n                lis[i].children[1].style.display=\"\"\r\n            }\r\n        }\r\n    }\r\n    \r\n</script>\r\n\r\n```html\r\n<style>\r\n    #demoQWRWEFE *,\r\n    #demoQWRWEFE *::after,\r\n    #demoQWRWEFE *::before\r\n    {\r\n        padding: 0;\r\n        margin: 0;\r\n        content: \"\";\r\n        list-style: none;\r\n    }\r\n    #demoQWRWEFE{\r\n        margin: 0 auto;\r\n        width: 500px;\r\n        /* height: 50px; */\r\n        background-color: red;\r\n    }\r\n    #demoQWRWEFE>ul{\r\n        display: flex;\r\n        justify-content: space-evenly;\r\n        align-items: center;\r\n    }\r\n    #demoQWRWEFE>ul>li{\r\n        flex: 1;\r\n        position: relative;\r\n        /* height: 50px; */\r\n        text-align: center;\r\n        background-color: green;\r\n        border: 1px solid gray;\r\n    }\r\n    #demoQWRWEFE>ul>li:hover{\r\n        background-color: rgb(1, 112, 1);\r\n    }\r\n    #demoQWRWEFE>ul>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top:100%;\r\n        left: 0;\r\n        width: 100px;\r\n        background-color: rgb(222, 222, 222);\r\n    }\r\n    #demoQWRWEFE>ul>li>ul>li:hover{\r\n        background-color: rgb(131, 131, 131);\r\n    }\r\n</style>\r\n<div id=\"demoQWRWEFE\">\r\n    <ul>\r\n        <li>\r\n            <span>标签1</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签2</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签3</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签4</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签5</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签6</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        \r\n    </ul>\r\n</div>\r\n\r\n<script>\r\n    var demoQWRWEFE=document.querySelector(\"#demoQWRWEFE\")\r\n    var lis = demoQWRWEFE.children[0].children\r\n    for(var i=0;i<lis.length;i++ )\r\n    {   \r\n        //注意是给li添加事件 而不是给 li>span 和 li>ul 分别添加事件 否则会有bug\r\n        lis[i].onmouseover=function(){\r\n            for(var i=0;i<lis.length;i++ ){\r\n                lis[i].children[1].style.display=\"\"\r\n            }\r\n            this.children[1].style.display=\"block\"\r\n        }\r\n        lis[i].onmouseout=function(){\r\n            for(var i=0;i<lis.length;i++ ){\r\n                lis[i].children[1].style.display=\"\"\r\n            }\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n\r\n### 简单留言发布案例实现\r\n<style>\r\n    #demoQweqdqw{\r\n        margin: 0 auto;\r\n        width: 500px;\r\n        height: 500px;\r\n        background-color: gray;\r\n    }\r\n    #demoQweqdqw textarea{\r\n        display: block;\r\n        padding: 0;\r\n        margin: 0;\r\n        border: 1px solid gray;\r\n        outline: none;\r\n        box-sizing: border-box;\r\n        width: 100% !important;\r\n        min-height:100px;\r\n    }\r\n    #demoQweqdqw>button{\r\n        float: right;\r\n        display: block;\r\n        height: 20px;\r\n    }\r\n    #demoQweqdqw ul{\r\n        margin-top: 50px;\r\n        padding: 0;\r\n    }\r\n    #demoQweqdqw li{\r\n        position: relative;\r\n        list-style: none;\r\n        background-color: #fff;\r\n        margin:10px 5px;\r\n        padding-bottom:20px;\r\n        word-break: break-all;\r\n    }\r\n    #demoQweqdqw li>button{\r\n        position: absolute;\r\n        right: 0px;\r\n        bottom: 0;\r\n        float:inline-end;\r\n    }\r\n</style>\r\n<div id=\"demoQweqdqw\">\r\n    <h3>简易评论框</h3>\r\n    发表评论：\r\n    <textarea ></textarea>\r\n    <button>发布评论</button>\r\n    <ul>\r\n    </ul>\r\n</div>\r\n\r\n<script>\r\n    var textarea=document.querySelector(\"#demoQweqdqw>textarea\")\r\n    var button=document.querySelector(\"#demoQweqdqw>button\")\r\n    var ul=document.querySelector(\"#demoQweqdqw>ul\")\r\n\r\n    button.onclick=function(){\r\n        var temp=document.createElement(\"li\")\r\n        console.log(textarea.value);\r\n        if(textarea.value!='')\r\n        {\r\n            temp.innerHTML=textarea.value + \"<button>删除评论</button>\"\r\n            temp.querySelector(\"button\").onclick=function(){\r\n                ul.removeChild(this.parentNode)\r\n            }\r\n            ul.appendChild(temp)\r\n\r\n            textarea.value=\"\"\r\n        }\r\n    }\r\n</script>\r\n\r\n### 动态生成表格\r\n\r\n<style>\r\n    #demoNQEUH123{\r\n        width: 500px;\r\n        margin: 100px auto;\r\n        border-collapse: collapse;\r\n        text-align: center;\r\n    }\r\n    #demoNQEUH123 td,\r\n    #demoNQEUH123 th{\r\n        border: 1px solid #333;\r\n    }\r\n    #demoNQEUH123 thead tr{\r\n        height: 40px;\r\n        background-color: #ccc;\r\n    }\r\n\r\n</style>\r\n<table id=\"demoNQEUH123\">\r\n    <thead>\r\n        <tr>\r\n            <th>姓名</th>\r\n            <th>科目</th>\r\n            <th>成绩</th>\r\n            <th>操作</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <!-- <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr> -->\r\n    </tbody>\r\n</table>\r\n<script>\r\n    var datas=[\r\n        {\r\n            name:\"dyg\",\r\n            class:\"javascript\",\r\n            score:99.9,\r\n        },\r\n        {\r\n            name:\"kkk\",\r\n            class:\"javascript\",\r\n            score:95.9,\r\n        },\r\n        {\r\n            name:\"jjj\",\r\n            class:\"javascript\",\r\n            score:92.9,\r\n        }\r\n    ];\r\n    var tbody=document.querySelector(\"#demoNQEUH123>tbody\")\r\n    for(var i=0;i<datas.length;i++)\r\n    {\r\n        var tempTr=document.createElement(\"tr\")\r\n        for(key in datas[i])\r\n        {\r\n            console.log(key);\r\n            tempTr.innerHTML+=\"<td>\" + datas[i][key] + \"</td>\";\r\n        }\r\n        tempTr.innerHTML+=\"<td>\" + \"<a href='javascript:;'>删除数据</a>\" + \"</td>\";\r\n        tempTr.querySelector(\"a\").onclick=function(){\r\n            this.parentNode.parentNode.parentNode.removeChild(this.parentNode.parentNode)\r\n        }\r\n        tbody.appendChild(tempTr)              \r\n    }\r\n</script>\r\n\r\n```html\r\n<style>\r\n    #demoNQEUH123{\r\n        width: 500px;\r\n        margin: 100px auto;\r\n        border-collapse: collapse;\r\n        text-align: center;\r\n    }\r\n    #demoNQEUH123 td,\r\n    #demoNQEUH123 th{\r\n        border: 1px solid #333;\r\n    }\r\n    #demoNQEUH123 thead tr{\r\n        height: 40px;\r\n        background-color: #ccc;\r\n    }\r\n\r\n</style>\r\n<table id=\"demoNQEUH123\">\r\n    <thead>\r\n        <tr>\r\n            <th>姓名</th>\r\n            <th>科目</th>\r\n            <th>成绩</th>\r\n            <th>操作</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <!-- <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr> -->\r\n    </tbody>\r\n</table>\r\n<script>\r\n    var datas=[\r\n        {\r\n            name:\"dyg\",\r\n            class:\"javascript\",\r\n            score:99.9,\r\n        },\r\n        {\r\n            name:\"kkk\",\r\n            class:\"javascript\",\r\n            score:95.9,\r\n        },\r\n        {\r\n            name:\"jjj\",\r\n            class:\"javascript\",\r\n            score:92.9,\r\n        }\r\n    ];\r\n    var tbody=document.querySelector(\"#demoNQEUH123>tbody\")\r\n    for(var i=0;i<datas.length;i++)\r\n    {\r\n        var tempTr=document.createElement(\"tr\")\r\n        for(key in datas[i])\r\n        {\r\n            console.log(key);\r\n            tempTr.innerHTML+=\"<td>\" + datas[i][key] + \"</td>\";\r\n        }\r\n        tempTr.innerHTML+=\"<td>\" + \"<a href='javascript:;'>删除数据</a>\" + \"</td>\";\r\n        tempTr.querySelector(\"a\").onclick=function(){\r\n            this.parentNode.parentNode.parentNode.removeChild(this.parentNode.parentNode)\r\n        }\r\n        tbody.appendChild(tempTr)              \r\n    }\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n### 实例：防止复制内容\r\n\r\n#### 禁止鼠标右键菜单\r\n```html\r\n<div id=\"demowoejf923fe\">\r\n    这是一段不能直接复制的文字\r\n</div>\r\n<script>\r\n    var div = document.querySelector(\"#demowoejf923fe\");\r\n    div.addEventListener(\"contextmenu\",function(event){\r\n        event.preventDefault()\r\n    });\r\n</script>\r\n```\r\n\r\n\r\n#### 禁止鼠标选中文字\r\n```html\r\n<div id=\"demoGEOJweoir932\">\r\n    这是一段不能直接复制的文字\r\n</div>\r\n<script>\r\n    var div = document.querySelector(\"#demoGEOJweoir932\");\r\n    // div.addEventListener(\"contextmenu\",function(event){\r\n    //     event.preventDefault()\r\n    // });\r\n    div.addEventListener(\"selectstart\",function(event){\r\n        event.preventDefault()\r\n    });\r\n</script>\r\n```\r\n\r\n#### 禁止f12键\r\n```js\r\ndocument.addEventListener(\"keydown\",function(event){\r\n    if(event.keyCode==123)\r\n    {\r\n        event.preventDefault()\r\n    }\r\n})\r\n```\r\n\r\n\r\n\r\n### 实例：阻止链接跳转\r\n```html\r\n//两种方法\r\n<a href=\"javascript:;\"></a>\r\n<a href=\"javascript:void(0);\"></a>\r\n```"},{"shortInfo":{"title":"js动画","date":"2022-07-05T17:07:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["动画","js"],"hideAtIndex":true,"categories":"笔记","id":2165841423,"countWords":2036,"readSeconds":203.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# js动画\r\n\r\n## 动画实现原理\r\n核心原理：通过定时器setinterval()不断移动盒子位置\r\n* 利用offset获取当前位置\r\n* 通过css定位设置新位置\r\n\r\n```html\r\n<div id=\"demoNOUH98u9\"></div>\r\n<style>\r\n    #demoNOUH98u9{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    var demoNOUH98u9 = document.querySelector(\"#demoNOUH98u9\")\r\n    var timer = setInterval(function(){\r\n        if(demoNOUH98u9.offsetLeft>=200)\r\n        {\r\n            clearInterval(timer)\r\n        }\r\n        demoNOUH98u9.style.left = demoNOUH98u9.offsetLeft + 1 + \"px\"\r\n    },50)\r\n</script>\r\n```\r\n\r\n## 封装成函数\r\n### 一般写法\r\n\r\n```html\r\n<div id=\"demoNOUH98123\"></div>\r\n<style>\r\n    #demoNOUH98123{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    var demoNOUH98123 = document.querySelector(\"#demoNOUH98123\")\r\n    function animate(elementObj,target){\r\n        var timer = setInterval(function(){\r\n        if(elementObj.offsetLeft>=target)\r\n        {\r\n            clearInterval(timer)\r\n        }\r\n        elementObj.style.left = elementObj.offsetLeft + 1 + \"px\"\r\n    },50)\r\n    }\r\n    animate(demoNOUH98123,200)\r\n</script>\r\n```\r\n\r\n### 优化写法\r\n\r\n<button id=\"demoNOUHdwee\">测试</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demoNOUH98456\"></div>\r\n</div>\r\n<style>\r\n    #demoNOUH98456{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n(function(){\r\n    var demoNOUH98456 = document.querySelector(\"#demoNOUH98456\")\r\n    var demoNOUHdwee = document.querySelector(\"#demoNOUHdwee\")\r\n    function animate(elementObj,target){\r\n        //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n        clearInterval(elementObj.timer)\r\n        //elementObj.timer可以避免反复申请内存\r\n        elementObj.timer = setInterval(function(){\r\n        if(elementObj.offsetLeft>=target)\r\n        {\r\n            clearInterval(elementObj.timer)\r\n        }\r\n        elementObj.style.left = elementObj.offsetLeft + 1 + \"px\"\r\n    },15)\r\n    }\r\n    demoNOUHdwee.addEventListener(\"click\",function(){\r\n        animate(demoNOUH98456,200)\r\n    })\r\n})();\r\n</script>\r\n\r\n```html\r\n<button id=\"demoNOUHdwee\">测试</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demoNOUH98456\"></div>\r\n</div>\r\n<style>\r\n    #demoNOUH98456{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n(function(){\r\n    var demoNOUH98456 = document.querySelector(\"#demoNOUH98456\")\r\n    var demoNOUHdwee = document.querySelector(\"#demoNOUHdwee\")\r\n    function animate(elementObj,target){\r\n        //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n        clearInterval(elementObj.timer)\r\n        //elementObj.timer可以避免反复申请内存\r\n        elementObj.timer = setInterval(function(){\r\n        if(elementObj.offsetLeft>=target)\r\n        {\r\n            clearInterval(elementObj.timer)\r\n        }\r\n        elementObj.style.left = elementObj.offsetLeft + 1 + \"px\"\r\n    },15)\r\n    }\r\n    demoNOUHdwee.addEventListener(\"click\",function(){\r\n        animate(demoNOUH98456,200)\r\n    })\r\n})();\r\n</script>\r\n```\r\n\r\n## 缓动动画\r\n* 原理：让盒子每次移动的距离慢慢变小，移动速度就会慢下来\r\n* 公式：步长 =（目标值-当前值）/10\r\n* 注意\r\n    * 需要向上或向下取整，否则，根据公式，步长将会无限接近0，这就导致(当前值+步长)永远无法到达目标值\r\n    * 如果步长是负数则应该向下取整，如果步长是正数则应该向上取整。\r\n        * 如果步长是0.1，则应该向上取整，步长应为1\r\n        * 如果步长是-0.1，则应该向下取整，步长应为-1\r\n    * 若只需要单方向移动，判断条件写成这样是没问题的：\r\n        * `elementObj.offsetLeft>=target` 左移\r\n        * `elementObj.offsetLeft<=target` 右移\r\n    * 若需要允许左右方向移动，判断条件应该写成：\r\n        * `elementObj.offsetLeft==target` \r\n        * 需要配合判断步长的正负性对其上下取整\r\n\r\n**公式测试**\r\n\r\n<button id=\"demoNOUHdw123we\">测试</button>\r\n<button id=\"demoNOUHddfwefe\">复位</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demoNOUH9fe12we\"></div>\r\n</div>\r\n<style>\r\n    #demoNOUH9fe12we{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    (function(){\r\n        var demoNOUH9fe12we = document.querySelector(\"#demoNOUH9fe12we\")\r\n        var demoNOUHdw123we = document.querySelector(\"#demoNOUHdw123we\")\r\n        var demoNOUHddfwefe = document.querySelector(\"#demoNOUHddfwefe\")\r\n        function animate(elementObj, target) {\r\n            //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            clearInterval(elementObj.timer)\r\n            //elementObj.timer可以避免反复申请内存\r\n            elementObj.timer = setInterval(function () {\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                }\r\n                //根据公式计算步长\r\n                var step = (target - elementObj.offsetLeft) / 10\r\n                //如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        demoNOUHdw123we.addEventListener(\"click\", function () {\r\n            animate(demoNOUH9fe12we, 200)\r\n        })\r\n        demoNOUHddfwefe.addEventListener(\"click\", function () {\r\n            animate(demoNOUH9fe12we, 0)\r\n        })\r\n    })();\r\n</script>\r\n\r\n```html\r\n<button id=\"demoNOUHdw123we\">测试</button>\r\n<button id=\"demoNOUHddfwefe\">复位</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demoNOUH9fe12we\"></div>\r\n</div>\r\n<style>\r\n    #demoNOUH9fe12we{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    (function(){\r\n        var demoNOUH9fe12we = document.querySelector(\"#demoNOUH9fe12we\")\r\n        var demoNOUHdw123we = document.querySelector(\"#demoNOUHdw123we\")\r\n        var demoNOUHddfwefe = document.querySelector(\"#demoNOUHddfwefe\")\r\n        function animate(elementObj, target) {\r\n            //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            clearInterval(elementObj.timer)\r\n            //elementObj.timer可以避免反复申请内存\r\n            elementObj.timer = setInterval(function () {\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                }\r\n                //根据公式计算步长\r\n                var step = (target - elementObj.offsetLeft) / 10\r\n                //如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        demoNOUHdw123we.addEventListener(\"click\", function () {\r\n            animate(demoNOUH9fe12we, 200)\r\n        })\r\n        demoNOUHddfwefe.addEventListener(\"click\", function () {\r\n            animate(demoNOUH9fe12we, 0)\r\n        })\r\n    })();\r\n</script>\r\n```\r\n\r\n## 缓动动画函数添加回调函数\r\n\r\n\r\n\r\n### 回调函数\r\n```js\r\nfunction fuc(其他形式参数,callback){\r\n    //do sthing...\r\n    //判断是否传入了回调函数\r\n    if(callback)\r\n    {\r\n        callback();\r\n    }\r\n}\r\nfuc(其他实参,function(){\r\n    //do sthing...\r\n})\r\n```\r\n\r\n### 具体实现\r\n\r\n<button id=\"demonvefoijgfwf\">测试</button>\r\n<button id=\"demofjewoifjw12\">复位</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demofweijp090\"></div>\r\n</div>\r\n<style>\r\n    #demofweijp090 {\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    (function () {\r\n        var demofweijp090 = document.querySelector(\"#demofweijp090\")\r\n        var demonvefoijgfwf = document.querySelector(\"#demonvefoijgfwf\")\r\n        var demofjewoifjw12 = document.querySelector(\"#demofjewoifjw12\")\r\n        function animate(elementObj, target, callback) {\r\n            //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            clearInterval(elementObj.timer)\r\n            //elementObj.timer可以避免反复申请内存\r\n            elementObj.timer = setInterval(function () {\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                    if (callback) {\r\n                        callback();\r\n                    }\r\n                }\r\n                //根据公式计算步长\r\n                var step = (target - elementObj.offsetLeft) / 10\r\n                //如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        demonvefoijgfwf.addEventListener(\"click\", function () {\r\n            animate(demofweijp090, 200, function () {\r\n                demofweijp090.style.backgroundColor = \"pink\"\r\n            })\r\n        })\r\n        demofjewoifjw12.addEventListener(\"click\", function () {\r\n            animate(demofweijp090, 0, function () {\r\n                demofweijp090.style.backgroundColor = \"green\"\r\n            })\r\n        })\r\n    })();\r\n</script>\r\n\r\n```html\r\n<button id=\"demonvefoijgfwf\">测试</button>\r\n<button id=\"demofjewoifjw12\">复位</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demofweijp090\"></div>\r\n</div>\r\n<style>\r\n    #demofweijp090 {\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    (function () {\r\n        var demofweijp090 = document.querySelector(\"#demofweijp090\")\r\n        var demonvefoijgfwf = document.querySelector(\"#demonvefoijgfwf\")\r\n        var demofjewoifjw12 = document.querySelector(\"#demofjewoifjw12\")\r\n        function animate(elementObj, target, callback) {\r\n            //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            clearInterval(elementObj.timer)\r\n            //elementObj.timer可以避免反复申请内存\r\n            elementObj.timer = setInterval(function () {\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                    if (callback) {\r\n                        callback();\r\n                    }\r\n                }\r\n                //根据公式计算步长\r\n                var step = (target - elementObj.offsetLeft) / 10\r\n                //如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        demonvefoijgfwf.addEventListener(\"click\", function () {\r\n            animate(demofweijp090, 200, function () {\r\n                demofweijp090.style.backgroundColor = \"pink\"\r\n            })\r\n        })\r\n        demofjewoifjw12.addEventListener(\"click\", function () {\r\n            animate(demofweijp090, 0, function () {\r\n                demofweijp090.style.backgroundColor = \"green\"\r\n            })\r\n        })\r\n    })();\r\n</script>\r\n```\r\n\r\n## 动画核心代码\r\n\r\n**animate.js**\r\n\r\n```js\r\nfunction animate(elementObj, target, callback) {\r\n    clearInterval(elementObj.timer)//clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n    elementObj.timer = setInterval(function () {//elementObj.timer可以避免反复申请内存\r\n        if (elementObj.offsetLeft == target) {\r\n            clearInterval(elementObj.timer)\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        }\r\n        var step = (target - elementObj.offsetLeft) / 10 //根据公式计算步长\r\n        step = step > 0 ? Math.ceil(step) : Math.floor(step)//如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n        elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n    }, 15)\r\n}\r\n```\r\n\r\n\r\n## 动画案例：侧边栏\r\n\r\n<div id=\"demo83492379\">\r\n    <div class=\"more\">→</div>\r\n    <div class=\"more-address\">了解更多</div>\r\n</div>\r\n<style>\r\n    #demo83492379{\r\n        position: relative;\r\n        height: 50px;\r\n        width: 50px;\r\n        background-color: pink;\r\n        overflow: visible;\r\n        word-break: keep-all;\r\n    }\r\n    #demo83492379 .more{\r\n        z-index: 2;\r\n        position: relative;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        font-size: 25px;\r\n        line-height: 50px;\r\n        text-align: center;\r\n    }\r\n    #demo83492379 .more-address{\r\n        position: absolute;\r\n        left: -500px;\r\n        top: 0;\r\n        display: inline-block;\r\n        padding: 0 10px;\r\n        padding-left: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        font-size: 25px;\r\n        line-height: 50px;\r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n(function(){\r\n    var more = document.querySelector(\"#demo83492379 .more\")\r\n    var more_address = document.querySelector(\"#demo83492379 .more-address\")\r\n    more_address.style.left=-more_address.offsetWidth+\"px\"\r\n    more.addEventListener(\"mouseenter\",function(){\r\n        animate(more_address,0,function(){\r\n            more.innerHTML=\"←\"\r\n        })\r\n    })\r\n    more.addEventListener(\"mouseleave\",function(){\r\n        animate(more_address,-more_address.offsetWidth,function(){\r\n            more.innerHTML=\"→\"\r\n        })\r\n    })\r\n    function animate(elementObj, target, callback) {\r\n    clearInterval(elementObj.timer)//clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n    elementObj.timer = setInterval(function () {//elementObj.timer可以避免反复申请内存\r\n        if (elementObj.offsetLeft == target) {\r\n            clearInterval(elementObj.timer)\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        }\r\n        var step = (target - elementObj.offsetLeft) / 10 //根据公式计算步长\r\n        step = step > 0 ? Math.ceil(step) : Math.floor(step)//如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n        elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n    }, 15)\r\n}\r\n})();\r\n</script>\r\n\r\n\r\n```html\r\n<div id=\"demo83492379\">\r\n    <div class=\"more\">→</div>\r\n    <div class=\"more-address\">了解更多</div>\r\n</div>\r\n<style>\r\n    #demo83492379{\r\n        position: relative;\r\n        height: 50px;\r\n        width: 50px;\r\n        background-color: pink;\r\n        overflow: visible;\r\n        word-break: keep-all;\r\n    }\r\n    #demo83492379 .more{\r\n        z-index: 2;\r\n        position: relative;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        font-size: 25px;\r\n        line-height: 50px;\r\n        text-align: center;\r\n    }\r\n    #demo83492379 .more-address{\r\n        position: absolute;\r\n        left: -500px;\r\n        top: 0;\r\n        display: inline-block;\r\n        padding: 0 10px;\r\n        padding-left: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        font-size: 25px;\r\n        line-height: 50px;\r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n(function(){\r\n    var more = document.querySelector(\"#demo83492379 .more\")\r\n    var more_address = document.querySelector(\"#demo83492379 .more-address\")\r\n    more_address.style.left=-more_address.offsetWidth+\"px\"\r\n    more.addEventListener(\"mouseenter\",function(){\r\n        animate(more_address,0,function(){\r\n            more.innerHTML=\"←\"\r\n        })\r\n    })\r\n    more.addEventListener(\"mouseleave\",function(){\r\n        animate(more_address,-more_address.offsetWidth,function(){\r\n            more.innerHTML=\"→\"\r\n        })\r\n    })\r\n    function animate(elementObj, target, callback) {\r\n    clearInterval(elementObj.timer)//clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n    elementObj.timer = setInterval(function () {//elementObj.timer可以避免反复申请内存\r\n        if (elementObj.offsetLeft == target) {\r\n            clearInterval(elementObj.timer)\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        }\r\n        var step = (target - elementObj.offsetLeft) / 10 //根据公式计算步长\r\n        step = step > 0 ? Math.ceil(step) : Math.floor(step)//如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n        elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n    }, 15)\r\n}\r\n})();\r\n</script>\r\n```"},{"shortInfo":{"title":"js返回顶部","date":"2022-07-06T13:33:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["返回顶部","js"],"hideAtIndex":true,"categories":"笔记","id":57489128,"countWords":766,"readSeconds":76.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# js返回顶部\r\n\r\n## 主要思路\r\n* 需要有动态效果\r\n* 需要重新封装animate动画函数\r\n* `window.scroll(x,y)` 函数用于设置页面窗口滚动位置\r\n* `window.pageYOffset` 窗口滚动内容的上边距\r\n\r\n## 结束条件的问题\r\n由于鼠标滚动的原因，`window.pageYOffset`是含小数部分的，且目标位置`target`是整数，计算的步长`step`也是取整数，  \r\n这就导致`window.pageYOffset+step`永远也不会等于target   \r\n所以结束的判断条件只判断整数部分就好了：  \r\n```js\r\nif(parseInt(window.pageYOffset)==parseInt(targetY))\r\n{\r\n\r\n}\r\n```\r\n\r\n## 防止目标值过大的问题\r\n如果body的高度只有1000px，而指定target到2000px，这是不可能实现的，这会导致页面滚动到底部，且无法拖动滚动条，所以需要计算出target的最大值，以对其进行限制\r\n\r\n**相关属性**\r\n* `window.innerHeight`表示窗口内容区域的高度，这是不包括边框、菜单栏的。\r\n* `window.outerHeight`是窗口的整体高度，包括边框、菜单栏等。\r\n* `document.body.offsetHeight` 可以获得页面的高度\r\n\r\n所以，可以计算出当页面滚动条在底部时，pageYOffset的高度为：`document.body.offsetHeight-window.innerHeight`\r\n\r\n## 保持X轴的滚动条位置不变\r\n\r\n只需要把X偏移保持就好了\r\n\r\n```js\r\n\r\nwindow.scroll(window.pageXOffset, x的偏移 )\r\n\r\n```\r\n\r\n\r\n## 效果及源码\r\n\r\n<button id=\"returnTop\">动态返回顶部</button>\r\n<button id=\"returnMiddle\">动态返回中部</button>\r\n<button id=\"returnBottom\">动态返回底部</button>\r\n<script>\r\n    var returnTop = document.querySelector(\"#returnTop\")\r\n    var returnBottom = document.querySelector(\"#returnBottom\")\r\n    var returnMiddle = document.querySelector(\"#returnMiddle\")\r\n    returnTop.addEventListener(\"click\", function () {\r\n        //返回顶部\r\n        animateWinScrollToY(0);\r\n    })\r\n    returnBottom.addEventListener(\"click\", function () {\r\n        //返回底部\r\n        animateWinScrollToY(document.body.offsetHeight - window.innerHeight);\r\n    })\r\n    returnMiddle.addEventListener(\"click\", function () {\r\n        //返回中部\r\n        animateWinScrollToY( (document.body.offsetHeight - window.innerHeight) /2);\r\n    })\r\n    function animateWinScrollToY(targetY, callback) {\r\n        if (document.body.offsetHeight - window.innerHeight >= targetY) {//防止targetY过大导致死循环\r\n            clearInterval(window.returnTopTimer)//防止被反复调用\r\n            window.returnTopTimer = setInterval(function () {\r\n                if (parseInt(window.pageYOffset) == parseInt(targetY))//因为滚动的距离存在小数，所以这里只判断整数部分是否接近就好了\r\n                {\r\n                    clearInterval(window.returnTopTimer);\r\n                    callback && callback();\r\n                    // console.log(\"到达目标位置\");\r\n                }\r\n                else\r\n                {\r\n                    window.step = (targetY - window.pageYOffset) / 10 //根据公式计算步长\r\n                    window.step = window.step <= 0 ? Math.floor(window.step) : Math.ceil(window.step); //上下取整，防止小数\r\n                    window.scroll(window.pageXOffset, window.pageYOffset + window.step);\r\n                }\r\n            }, 15)\r\n        }\r\n    }\r\n</script>\r\n\r\n```html\r\n<button id=\"returnTop\">动态返回顶部</button>\r\n<button id=\"returnMiddle\">动态返回中部</button>\r\n<button id=\"returnBottom\">动态返回底部</button>\r\n<script>\r\n    var returnTop = document.querySelector(\"#returnTop\")\r\n    var returnBottom = document.querySelector(\"#returnBottom\")\r\n    var returnMiddle = document.querySelector(\"#returnMiddle\")\r\n    returnTop.addEventListener(\"click\", function () {\r\n        //返回顶部\r\n        animateWinScrollToY(0);\r\n    })\r\n    returnBottom.addEventListener(\"click\", function () {\r\n        //返回底部\r\n        animateWinScrollToY(document.body.offsetHeight - window.innerHeight);\r\n    })\r\n    returnMiddle.addEventListener(\"click\", function () {\r\n        //返回中部\r\n        animateWinScrollToY( (document.body.offsetHeight - window.innerHeight) /2);\r\n    })\r\n    function animateWinScrollToY(targetY, callback) {\r\n        if (document.body.offsetHeight - window.innerHeight >= targetY) {//防止targetY过大导致死循环\r\n            clearInterval(window.returnTopTimer)//防止被反复调用\r\n            window.returnTopTimer = setInterval(function () {\r\n                if (parseInt(window.pageYOffset) == parseInt(targetY))//因为滚动的距离存在小数，所以这里只判断整数部分是否接近就好了\r\n                {\r\n                    clearInterval(window.returnTopTimer);\r\n                    callback && callback();\r\n                    // console.log(\"到达目标位置\");\r\n                }\r\n                else\r\n                {\r\n                    window.step = (targetY - window.pageYOffset) / 10 //根据公式计算步长\r\n                    window.step = window.step <= 0 ? Math.floor(window.step) : Math.ceil(window.step); //上下取整，防止小数\r\n                    window.scroll(window.pageXOffset, window.pageYOffset + window.step);\r\n                }\r\n            }, 15)\r\n        }\r\n    }\r\n</script>\r\n```"},{"shortInfo":{"title":"js高级学习笔记","date":"2022-08-28T21:04:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["javascript","js","高级"],"hideAtIndex":true,"categories":"笔记","id":3362335617,"countWords":708,"readSeconds":70.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# js高级学习笔记\r\n## 目录\r\n- [js高级学习笔记](#js高级学习笔记)\r\n  - [目录](#目录)\r\n  - [正则表达式](#正则表达式)\r\n    - [基本语法格式](#基本语法格式)\r\n    - [正则在search()和replace()中的使用](#正则在search和replace中的使用)\r\n    - [RegExp 对象](#regexp-对象)\r\n\r\n<!-- ## ES6模块化规范\r\n**早期社区版的模块化解决方案**\r\n* AMD CMD 用于浏览器的模块化规范\r\n* commonJS 用于服务端的模块化规范\r\n\r\n**当前ES6模块化规范**\r\n* 官方的模块化规范\r\n* 前端和后端共同的模块化规范 -->\r\n\r\n\r\n## 正则表达式\r\n### 基本语法格式\r\n`/正则表达式主体/修饰符(可选)`\r\n* 修饰符:\r\n    * i 不区分大小写\r\n    * g 全局匹配\r\n    * m 多行匹配\r\n* 范围查找:\r\n    * `[abc]`\t查找方括号之间的任何字符。\r\n    * `[0-9]`\t查找任何从 0 至 9 的数字。\r\n    * `(x|y)`\t查找任何以 | 分隔的选项。\r\n* 特殊字符:\r\n    * `\\d`\t    查找数字。\r\n    * `\\s`\t    查找空白字符。\r\n    * `\\b`\t    匹配单词边界。\r\n    * `\\uxxxx`\t查找以十六进制数 xxxx 规定的 Unicode 字符。\r\n* 量词:\r\n    * `n+`\t匹配任何包含至少一个 n 的字符串。\r\n    * `n*`\t匹配任何包含零个或多个 n 的字符串。\r\n    * `n?`\t匹配任何包含零个或一个 n 的字符串。\r\n\r\n### 正则在search()和replace()中的使用\r\n* `str.search(字符串或正则表达式)` 返回查找到的第一个子字符串的下标\r\n* `str.replace(字符串A或正则表达式A,字符串B)` 替换A为B\r\n\r\n\r\n### RegExp 对象\r\n在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。\r\n\r\n**创建对象**\r\n```js\r\nvar patt=new RegExp(正则表达式主体,修饰符);\r\nvar rpatte = new RegExp(\"\\\\w+\");\r\n// 或者更简单的方式:\r\nvar patt=/正则表达式主体/修饰符;\r\n```\r\n\r\n**RegExp方法**\r\n* `reg.exec(string)`    检索字符串中的正则表达式的匹配。返回该匹配值，否则返回null。\r\n* `reg.test()`    检测一个字符串是否匹配某个模式。返回 true 或 false。\r\n* `reg.toString()`    返回正则表达式的字符串值\r\n\r\n**RegExp属性**\r\n* `reg.constructor` 返回一个函数，该函数是一个创建 RegExp 对象的原型。\r\n* `reg.global`  判断是否设置了 \"g\" 修饰符\r\n* `reg.ignoreCase`  判断是否设置了 \"i\" 修饰符\r\n* `reg.multiline`   判断是否设置了 \"m\" 修饰符\r\n* `reg.lastIndex`   用于规定下次匹配的起始位置\r\n* `reg.source`  返回正则表达式的匹配模式\r\n\r\n**支持正则表达式的 String 对象的方法**\r\n* `str.search(字符串或正则)`\t检索与正则表达式相匹配的值\r\n* `str.match()`\t找到一个或多个正则表达式的匹配\r\n* `str.replace()`\t替换与正则表达式匹配的子串\r\n* `str.split()`\t把字符串分割为字符串数组\r\n\r\n\r\n```js\r\nvar regOBJ = /正则表达方式/i\r\n```"},{"shortInfo":{"layout":"post","title":"jupyter备忘笔记","date":"2022-01-29T12:09:00.000Z","cover":"\\self_server\\assets\\images\\jupyter.png","tags":["笔记","jupyter"],"hideAtIndex":true,"categories":"笔记","id":3696209003,"countWords":434,"readSeconds":43.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# jupyter备忘笔记\r\n\r\n## c++ jupyter环境的安装\r\n1. 关闭系统代理否则可能无法创建环境\r\n1. 用conda创建环境 `conda create --name cPlusPlus`\r\n1. 查看现有环境 `conda env list`\r\n1. 激活 cPlusPlus 环境`conda activate cPlusPlus`\r\n1. 先安装jupyter(再安装C++解析器)`conda install jupyter`\r\n1. 安装C++ 解析器xeus-cling(现仅支持mac linux)\r\n    `conda install -c conda-forge xeus-cling`\r\n    * 如果在ubuntu20中安装时报错提示缺失zlib（zconf.h zlib.h libz.a zlib.pc）\r\n        * 安装缺失zlib\r\n        `conda install zlib` \r\n    * 如果在jupyter中提示内核无法启动，查询xeus-cling的github文档得知需安装如下依赖\r\n        * xeus-cling的依赖：\r\n            `xeus xtl cling pugixml cxxopts nlohmann_json`\r\n        * 安装当前版本xeus-cling要求依赖的指定版本：\r\n            `conda install cmake \"xeus>=2.0,<3.0\" cling=0.8 clangdev=5.0.0 llvmdev=5 \"nlohmann_json>=3.9.1,<3.10\" \"cppzmq>=4.6.0,<5\" \"xtl>=0.7,<0.8\" pugixml \"cxxopts>=2.1.1,<2.2\" -c conda-forge`\r\n1. 启动jupyter:\r\n    `jupyter notebook`\r\n\r\n## 允许远程访问\r\n1. 生成配置文件 `~/.jupyter/jupyter_notebook_config.py `\r\n    * `jupyter notebook --generate-config`\r\n1. 生成密码hash值\r\n    * 方法1\r\n        * 用命令生成密码hash值`jupyter notebook password`\r\n        * 打开 jupyter_notebook_config.json提取生成的sha1值\r\n    * 方法2\r\n        * 在pythonShell中输入`from notebook.auth import passwd; passwd();`按提示输入两次密码后将返回密码hash值\r\n1. 修改jupyter_notebook_config.py\r\n    * c.NotebookApp.password=由密码生成的sha1值 \r\n    * c.NotebookApp.ip='*'       #在所有的网卡接口上开启服务。同\"0.0.0.0\"\r\n    * c.NotebookApp.port =8888 #可自行指定一个端口, 访问时使用该端口7777\r\n    * c.NotebookApp.allow_remote_access = True  #允许远程\r\n\r\n## jupyter无法导出其他格式的问题\r\n* pip uninstall nbconvert\r\n* pip install nbconvert\r\n\r\n##### tips:\r\n* conda-forge是可以安装软件包的附加渠道\r\n* -c或--channel表示切换频道\r\n* conda install -c some-channel packagename\r\n"},{"shortInfo":{"title":"kaTex使用","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-05-31T19:06:10.820Z","modified":"2022-05-31T19:13:16.456Z","tags":["kaTex"],"hideAtIndex":true,"id":1209644433,"countWords":182,"readSeconds":18.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# kaTex使用\r\n* KaTeX排版系统核心库\r\n```html\r\n<!-- KaTeX requires the use of the HTML5 doctype. Without it, KaTeX may not render properly -->\r\n<link rel=\"stylesheet\" href=\"/libs/katex/v0.15.6/katex.min.css\" >\r\n<!-- The loading of KaTeX is deferred to speed up page rendering -->\r\n<script defer src=\"/libs/katex/v0.15.6/katex.min.js\" ></script>\r\n```\r\n* 用于自动渲染的KaTeX扩展库\r\n```html\r\n<!-- To automatically render math in text elements, include the auto-render extension: -->\r\n<script defer src=\"/libs/katex/v0.15.6/contrib/auto-render.min.js\" ></script>\r\n<script>\r\n    document.addEventListener(\"DOMContentLoaded\", function() {\r\n        renderMathInElement(document.body, {\r\n          // customised options\r\n          delimiters: [\r\n              {left: '$$', right: '$$', display: true},\r\n              {left: '$', right: '$', display: false},\r\n              {left: '\\\\(', right: '\\\\)', display: true},\r\n              {left: '\\\\[', right: '\\\\]', display: false}\r\n          ],\r\n          // • rendering keys, e.g.:\r\n          throwOnError : true\r\n        });\r\n    });\r\n</script>\r\n```\r\n* 允许复制tex公式时复制其源代码的扩展库\r\n```html\r\n<link href=\"/libs/katex/v0.15.6/contrib/copy-tex.css\" rel=\"stylesheet\" type=\"text/css\">\r\n<script src=\"/libs/katex/v0.15.6/contrib/copy-tex.min.js\"></script>\r\n\r\n```\r\n"},{"shortInfo":{"title":"KaTeX数学公式语法官方文档","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-05-31T15:10:17.339Z","modified":"2022-05-31T16:22:18.928Z","tags":["KaTeX"],"hideAtIndex":true,"id":4089583086,"countWords":4879,"readSeconds":487.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# KaTeX数学公式语法官方文档\r\n\r\nThis is a list of TeX functions supported by KaTeX. It is sorted into logical groups.\r\n\r\nThere is a similar [Support Table](support_table.md), sorted alphabetically, that lists both supported and un-supported functions.\r\n\r\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css\" integrity=\"sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs\" crossorigin=\"anonymous\">\r\n<style>\r\np {overflow-wrap: break-word;}\r\ntable tr,\r\ntable td {\r\n    vertical-align: middle;\r\n    overflow-wrap: break-word;\r\n}\r\n</style>\r\n\r\n<div class=\"katex-hopscotch\">\r\n\r\n## Accents\r\n\r\n||||\r\n|:----------------------------|:----------------------------------------------------|:------\r\n|$a'$ `a'`  |$\\tilde{a}$ `\\tilde{a}`|$\\mathring{g}$ `\\mathring{g}`\r\n|$a''$ `a''`|$\\widetilde{ac}$ `\\widetilde{ac}`  |$\\overgroup{AB}$ `\\overgroup{AB}`\r\n|$a^{\\prime}$ `a^{\\prime}` |$\\utilde{AB}$ `\\utilde{AB}`  |$\\undergroup{AB}$ `\\undergroup{AB}`\r\n|$\\acute{a}$ `\\acute{a}`|$\\vec{F}$ `\\vec{F}` |$\\Overrightarrow{AB}$ `\\Overrightarrow{AB}`\r\n|$\\bar{y}$ `\\bar{y}` |$\\overleftarrow{AB}$ `\\overleftarrow{AB}`|$\\overrightarrow{AB}$ `\\overrightarrow{AB}`\r\n|$\\breve{a}$ `\\breve{a}`|$\\underleftarrow{AB}$ `\\underleftarrow{AB}` |$\\underrightarrow{AB}$ `\\underrightarrow{AB}`\r\n|$\\check{a}$ `\\check{a}`|$\\overleftharpoon{ac}$ `\\overleftharpoon{ac}`  |$\\overrightharpoon{ac}$ `\\overrightharpoon{ac}`\r\n|$\\dot{a}$ `\\dot{a}` |$\\overleftrightarrow{AB}$ `\\overleftrightarrow{AB}`  |$\\overbrace{AB}$ `\\overbrace{AB}`\r\n|$\\ddot{a}$ `\\ddot{a}`  |$\\underleftrightarrow{AB}$ `\\underleftrightarrow{AB}`|$\\underbrace{AB}$ `\\underbrace{AB}`\r\n|$\\grave{a}$ `\\grave{a}`|$\\overline{AB}$ `\\overline{AB}` |$\\overlinesegment{AB}$ `\\overlinesegment{AB}`\r\n|$\\hat{\\theta}$ `\\hat{\\theta}`|$\\underline{AB}$ `\\underline{AB}`  |$\\underlinesegment{AB}$ `\\underlinesegment{AB}`\r\n|$\\widehat{ac}$ `\\widehat{ac}`|$\\widecheck{ac}$ `\\widecheck{ac}`  |$\\underbar{X}$ `\\underbar{X}`\r\n\r\n***Accent functions inside \\\\text{…}***\r\n\r\n|||||\r\n|:---------------------|:---------------------|:---------------------|:-----\r\n|$\\text{\\'{a}}$ `\\'{a}`|$\\text{\\~{a}}$ `\\~{a}`|$\\text{\\.{a}}$ `\\.{a}`|$\\text{\\H{a}}$ `\\H{a}`\r\n|$\\text{\\`{a}}$ <code>\\\\`{a}</code>|$\\text{\\={a}}$ `\\={a}`|$\\text{\\\"{a}}$ `\\\"{a}`|$\\text{\\v{a}}$ `\\v{a}`\r\n|$\\text{\\^{a}}$ `\\^{a}`|$\\text{\\u{a}}$ `\\u{a}`|$\\text{\\r{a}}$ `\\r{a}`|\r\n\r\nSee also [letters and unicode](#letters-and-unicode).\r\n\r\n## Delimiters\r\n\r\n||||||\r\n|:-----------------------------------|:---------------------------------------|:----------|:-------------------------------------------------------|:-----\r\n|$(~)$ `( )` |$\\lparen~\\rparen$ `\\lparen`<br>$~~~~$`\\rparen`|$⌈~⌉$ `⌈ ⌉`|$\\lceil~\\rceil$ `\\lceil`<br>$~~~~~$`\\rceil`  |$\\uparrow$ `\\uparrow`\r\n|$[~]$ `[ ]` |$\\lbrack~\\rbrack$ `\\lbrack`<br>$~~~~$`\\rbrack`|$⌊~⌋$ `⌊ ⌋`|$\\lfloor~\\rfloor$ `\\lfloor`<br>$~~~~~$`\\rfloor` |$\\downarrow$ `\\downarrow`\r\n|$\\{ \\}$ `\\{ \\}`|$\\lbrace \\rbrace$ `\\lbrace`<br>$~~~~$`\\rbrace`|$⎰⎱$ `⎰⎱`  |$\\lmoustache \\rmoustache$ `\\lmoustache`<br>$~~~~$`\\rmoustache`|$\\updownarrow$ `\\updownarrow`\r\n|$⟨~⟩$ `⟨ ⟩` |$\\langle~\\rangle$ `\\langle`<br>$~~~~$`\\rangle`|$⟮~⟯$ `⟮ ⟯`|$\\lgroup~\\rgroup$ `\\lgroup`<br>$~~~~~$`\\rgroup` |$\\Uparrow$ `\\Uparrow`\r\n|$\\vert$ <code>&#124;</code> |$\\vert$ `\\vert` |$┌ ┐$ `┌ ┐`|$\\ulcorner \\urcorner$ `\\ulcorner`<br>$~~~~$`\\urcorner`  |$\\Downarrow$ `\\Downarrow`\r\n|$\\Vert$ <code>&#92;&#124;</code> |$\\Vert$ `\\Vert` |$└ ┘$ `└ ┘`|$\\llcorner \\lrcorner$ `\\llcorner`<br>$~~~~$`\\lrcorner`  |$\\Updownarrow$ `\\Updownarrow`\r\n|$\\lvert~\\rvert$ `\\lvert`<br>$~~~~$`\\rvert`|$\\lVert~\\rVert$ `\\lVert`<br>$~~~~~$`\\rVert` |`\\left.`|  `\\right.` |$\\backslash$ `\\backslash`\r\n|$\\lang~\\rang$ `\\lang`<br>$~~~~$`\\rang`|$\\lt~\\gt$ `\\lt \\gt`|$⟦~⟧$ `⟦ ⟧`|$\\llbracket~\\rrbracket$ `\\llbracket`<br>$~~~~$`\\rrbracket`|$\\lBrace~\\rBrace$ `\\lBrace \\rBrace`\r\n\r\n**Delimiter Sizing**\r\n\r\n$\\left(\\LARGE{AB}\\right)$ `\\left(\\LARGE{AB}\\right)`\r\n\r\n$( \\big( \\Big( \\bigg( \\Bigg($ `( \\big( \\Big( \\bigg( \\Bigg(`\r\n\r\n||||||\r\n|:--------|:------|:--------|:-------|:------|\r\n|`\\left`  |`\\big` |`\\bigl`  |`\\bigm` |`\\bigr`\r\n|`\\middle`|`\\Big` |`\\Bigl`  |`\\Bigm` | `\\Bigr`\r\n|`\\right` |`\\bigg`|`\\biggl` |`\\biggm`|`\\biggr`\r\n|         |`\\Bigg`|`\\Biggl` |`\\Biggm`|`\\Biggr`\r\n\r\n</div>\r\n\r\n## Environments\r\n\r\n<div class=\"katex-cards\" id=\"environments\">\r\n\r\n|||||\r\n|:---------------------|:---------------------|:---------------------|:--------\r\n|$\\begin{matrix} a & b \\\\ c & d \\end{matrix}$ | `\\begin{matrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{matrix}` |$\\begin{array}{cc}a & b\\\\c & d\\end{array}$ | `\\begin{array}{cc}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{array}`\r\n|$\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$ |`\\begin{pmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{pmatrix}` |$\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}$ | `\\begin{bmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{bmatrix}`\r\n|$\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}$ |`\\begin{vmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{vmatrix}` |$\\begin{Vmatrix} a & b \\\\ c & d \\end{Vmatrix}$ |`\\begin{Vmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{Vmatrix}`\r\n|$\\begin{Bmatrix} a & b \\\\ c & d \\end{Bmatrix}$ |`\\begin{Bmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{Bmatrix}`|$\\def\\arraystretch{1.5}\\begin{array}{c:c:c} a & b & c \\\\ \\hline d & e & f \\\\ \\hdashline g & h & i \\end{array}$|`\\def\\arraystretch{1.5}`<br>&nbsp;&nbsp;&nbsp;`\\begin{array}{c:c:c}`<br>&nbsp;&nbsp;&nbsp;`a & b & c \\\\ \\hline`<br>&nbsp;&nbsp;&nbsp;`d & e & f \\\\`<br>&nbsp;&nbsp;&nbsp;`\\hdashline`<br>&nbsp;&nbsp;&nbsp;`g & h & i`<br>`\\end{array}`\r\n|$x = \\begin{cases} a &\\text{if } b \\\\ c &\\text{if } d \\end{cases}$ |`x = \\begin{cases}`<br>&nbsp;&nbsp;&nbsp;`a &\\text{if } b  \\\\`<br>&nbsp;&nbsp;&nbsp;`c &\\text{if } d`<br>`\\end{cases}`|$\\begin{rcases} a &\\text{if } b \\\\ c &\\text{if } d \\end{rcases}⇒…$ |`\\begin{rcases}`<br>&nbsp;&nbsp;&nbsp;`a &\\text{if } b  \\\\`<br>&nbsp;&nbsp;&nbsp;`c &\\text{if } d`<br>`\\end{rcases}⇒…`|\r\n|$\\begin{smallmatrix} a & b \\\\ c & d \\end{smallmatrix}$ | `\\begin{smallmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{smallmatrix}` |$$\\sum_{\\begin{subarray}{l} i\\in\\Lambda\\\\  0<j<n\\end{subarray}}$$ | `\\sum_{`<br>`\\begin{subarray}{l}`<br>&nbsp;&nbsp;&nbsp;`i\\in\\Lambda\\\\`<br>&nbsp;&nbsp;&nbsp;`0<j<n`<br>`\\end{subarray}}`|\r\n\r\nThe auto-render extension will render the following environments even if they are not inside math delimiters such as `$$…$$`. They are display-mode only.\r\n\r\n<style>\r\n  #env + table tr td:nth-child(1) { min-width: 11em }\r\n  #env + table tr td:nth-child(3) { min-width: 13em }\r\n</style>\r\n<div id=\"env\"></div>\r\n\r\n|||||\r\n|:---------------------|:---------------------|:---------------------|:--------\r\n|$$\\begin{equation}\\begin{split}a &=b+c\\\\&=e+f\\end{split}\\end{equation}$$ |`\\begin{equation}`<br>`\\begin{split}`&nbsp;&nbsp;&nbsp;`a &=b+c\\\\`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`&=e+f`<br>`\\end{split}`<br>`\\end{equation}` |$$\\begin{align} a&=b+c \\\\ d+e&=f \\end{align}$$ |`\\begin{align}`<br>&nbsp;&nbsp;&nbsp;`a&=b+c \\\\`<br>&nbsp;&nbsp;&nbsp;`d+e&=f`<br>`\\end{align}` |\r\n|$$\\begin{gather} a=b \\\\ e=b+c \\end{gather}$$ |`\\begin{gather}`<br>&nbsp;&nbsp;&nbsp;`a=b \\\\ `<br>&nbsp;&nbsp;&nbsp;`e=b+c`<br>`\\end{gather}`|$$\\begin{alignat}{2}10&x+&3&y=2\\\\3&x+&13&y=4\\end{alignat}$$ | `\\begin{alignat}{2}`<br>&nbsp;&nbsp;&nbsp;`10&x+&3&y=2\\\\`<br>&nbsp;&nbsp;&nbsp;`3&x+&13&y=4`<br>`\\end{alignat}`\r\n|$$\\begin{CD}A @>a>> B \\\\@VbVV @AAcA\\\\C @= D\\end{CD}$$ | `\\begin{CD}`<br>&nbsp;&nbsp;&nbsp;`A  @>a>>  B  \\\\`<br>`@VbVV    @AAcA \\\\`<br>&nbsp;&nbsp;&nbsp;`C  @=   D`<br>`\\end{CD}`\r\n\r\n#### Other KaTeX Environments\r\n\r\n| Environments | How they differ from those shown above |\r\n|:-----------------------------------------------|:------------------|\r\n| `darray`, `dcases`, `drcases`                  | … apply `displaystyle` |\r\n| `matrix*`, `pmatrix*`, `bmatrix*`<br>`Bmatrix*`, `vmatrix*`, `Vmatrix*` | … take an optional argument to set column<br>alignment, as in `\\begin{matrix*}[r]`\r\n| `equation*`, `gather*`<br>`align*`, `alignat*` | … have no automatic numbering. Alternatively, you can use `\\nonumber` or `\\notag` to omit the numbering for a specific row of the equation. |\r\n| `gathered`, `aligned`, `alignedat`             | … do not need to be in display mode.<br> … have no automatic numbering.<br> … must be inside math delimiters in<br>order to be rendered by the auto-render<br>extension. |\r\n\r\n</div>\r\n\r\nAcceptable line separators include: `\\\\`, `\\cr`, `\\\\[distance]`, and `\\cr[distance]`. *Distance* can be written with any of the [KaTeX units](#units).\r\n\r\nThe `{array}` environment supports `|` and `:` vertical separators.\r\n\r\nThe `{array}` environment does not yet support `\\cline` or `\\multicolumn`.\r\n\r\n`\\tag` can be applied to individual rows of top-level environments\r\n(`align`, `align*`, `alignat`, `alignat*`, `gather`, `gather*`).\r\n\r\n<div class=\"katex-hopscotch\">\r\n\r\n## HTML\r\n\r\nThe following \"raw HTML\" features are potentially dangerous for untrusted\r\ninputs, so they are disabled by default, and attempting to use them produces\r\nthe command names in red (which you can configure via the `errorColor`\r\n[option](options.md)).  To fully trust your LaTeX input, you need to pass\r\nan option of `trust: true`; you can also enable just some of the commands\r\nor for just some URLs via the `trust` [option](options.md).\r\n\r\n|||\r\n|:----------------|:-------------------|\r\n| $\\href{https://katex.org/}{\\KaTeX}$ | `\\href{https://katex.org/}{\\KaTeX}` |\r\n| $\\url{https://katex.org/}$ | `\\url{https://katex.org/}` |\r\n| $\\includegraphics[height=0.8em, totalheight=0.9em, width=0.9em, alt=KA logo]{https://katex.org/img/khan-academy.png}$ | `\\includegraphics[height=0.8em, totalheight=0.9em, width=0.9em, alt=KA logo]{https://katex.org/img/khan-academy.png}` |\r\n| $\\htmlId{bar}{x}$ <code>…&lt;span id=\"bar\" class=\"enclosing\"&gt;…x…&lt;/span&gt;…</code> | `\\htmlId{bar}{x}` |\r\n| $\\htmlClass{foo}{x}$ <code>…&lt;span class=\"enclosing foo\"&gt;…x…&lt;/span&gt;…</code> | `\\htmlClass{foo}{x}` |\r\n| $\\htmlStyle{color: red;}{x}$ <code>…&lt;span style=\"color: red;\" class=\"enclosing\"&gt;…x…&lt;/span&gt;…</code> | `\\htmlStyle{color: red;}{x}` |\r\n| $\\htmlData{foo=a, bar=b}{x}$ <code>…&lt;span data-foo=\"a\" data-bar=\"b\" class=\"enclosing\"&gt;…x…&lt;/span&gt;…</code> | `\\htmlData{foo=a, bar=b}{x}` |\r\n\r\n`\\includegraphics` supports `height`, `width`, `totalheight`, and `alt` in its first argument. `height` is required.\r\n\r\nHTML extension (`\\html`-prefixed) commands are non-standard, so loosening `strict` option for `htmlExtension` is required.\r\n\r\n\r\n## Letters and Unicode\r\n\r\n**Greek Letters**\r\n\r\nDirect Input: $Α Β Γ Δ Ε Ζ Η Θ Ι \\allowbreak Κ Λ Μ Ν Ξ Ο Π Ρ Σ Τ Υ Φ Χ Ψ Ω$\r\n$\\allowbreak α β γ δ ϵ ζ η θ ι κ λ μ ν ξ o π \\allowbreak ρ σ τ υ ϕ χ ψ ω ε ϑ ϖ ϱ ς φ ϝ$\r\n\r\n|||||\r\n|---------------|-------------|-------------|---------------|\r\n| $\\Alpha$ `\\Alpha` | $\\Beta$ `\\Beta` | $\\Gamma$ `\\Gamma`| $\\Delta$ `\\Delta`\r\n| $\\Epsilon$ `\\Epsilon` | $\\Zeta$ `\\Zeta` | $\\Eta$ `\\Eta` | $\\Theta$ `\\Theta`\r\n| $\\Iota$ `\\Iota` | $\\Kappa$ `\\Kappa` | $\\Lambda$ `\\Lambda` | $\\Mu$ `\\Mu`\r\n| $\\Nu$ `\\Nu` | $\\Xi$ `\\Xi` | $\\Omicron$ `\\Omicron` | $\\Pi$ `\\Pi`\r\n| $\\Rho$ `\\Rho` | $\\Sigma$ `\\Sigma` | $\\Tau$ `\\Tau` | $\\Upsilon$ `\\Upsilon`\r\n| $\\Phi$ `\\Phi` | $\\Chi$ `\\Chi` | $\\Psi$ `\\Psi` | $\\Omega$ `\\Omega`\r\n| $\\varGamma$ `\\varGamma`| $\\varDelta$ `\\varDelta` | $\\varTheta$ `\\varTheta` | $\\varLambda$ `\\varLambda`  |\r\n| $\\varXi$ `\\varXi`| $\\varPi$ `\\varPi` | $\\varSigma$ `\\varSigma` | $\\varUpsilon$ `\\varUpsilon` |\r\n| $\\varPhi$ `\\varPhi`  | $\\varPsi$ `\\varPsi`| $\\varOmega$ `\\varOmega` ||\r\n| $\\alpha$ `\\alpha`| $\\beta$ `\\beta`  | $\\gamma$ `\\gamma` | $\\delta$ `\\delta`|\r\n| $\\epsilon$ `\\epsilon` | $\\zeta$ `\\zeta`  | $\\eta$ `\\eta`| $\\theta$ `\\theta`|\r\n| $\\iota$ `\\iota` | $\\kappa$ `\\kappa` | $\\lambda$ `\\lambda`| $\\mu$ `\\mu`|\r\n| $\\nu$ `\\nu`| $\\xi$ `\\xi` | $\\omicron$ `\\omicron`  | $\\pi$ `\\pi`|\r\n| $\\rho$ `\\rho`  | $\\sigma$ `\\sigma` | $\\tau$ `\\tau`| $\\upsilon$ `\\upsilon` |\r\n| $\\phi$ `\\phi`  | $\\chi$ `\\chi`| $\\psi$ `\\psi`| $\\omega$ `\\omega`|\r\n| $\\varepsilon$ `\\varepsilon` | $\\varkappa$ `\\varkappa` | $\\vartheta$ `\\vartheta` | $\\thetasym$ `\\thetasym`\r\n| $\\varpi$ `\\varpi`| $\\varrho$ `\\varrho`  | $\\varsigma$ `\\varsigma` | $\\varphi$ `\\varphi`\r\n| $\\digamma $ `\\digamma`\r\n\r\n**Other Letters**\r\n\r\n||||||\r\n|:----------|:----------|:----------|:----------|:----------|\r\n|$\\imath$ `\\imath`|$\\nabla$ `\\nabla`|$\\Im$ `\\Im`|$\\Reals$ `\\Reals`|$\\text{\\OE}$ `\\text{\\OE}`\r\n|$\\jmath$ `\\jmath`|$\\partial$ `\\partial`|$\\image$ `\\image`|$\\wp$ `\\wp`|$\\text{\\o}$ `\\text{\\o}`\r\n|$\\aleph$ `\\aleph`|$\\Game$ `\\Game`|$\\Bbbk$ `\\Bbbk`|$\\weierp$ `\\weierp`|$\\text{\\O}$ `\\text{\\O}`\r\n|$\\alef$ `\\alef`|$\\Finv$ `\\Finv`|$\\N$ `\\N`|$\\Z$ `\\Z`|$\\text{\\ss}$ `\\text{\\ss}`\r\n|$\\alefsym$ `\\alefsym`|$\\cnums$ `\\cnums`|$\\natnums$ `\\natnums`|$\\text{\\aa}$ `\\text{\\aa}`|$\\text{\\i}$ `\\text{\\i}`\r\n|$\\beth$ `\\beth`|$\\Complex$ `\\Complex`|$\\R$ `\\R`|$\\text{\\AA}$ `\\text{\\AA}`|$\\text{\\j}$ `\\text{\\j}`\r\n|$\\gimel$ `\\gimel`|$\\ell$ `\\ell`|$\\Re$ `\\Re`|$\\text{\\ae}$ `\\text{\\ae}`\r\n|$\\daleth$ `\\daleth`|$\\hbar$ `\\hbar`|$\\real$ `\\real`|$\\text{\\AE}$ `\\text{\\AE}`\r\n|$\\eth$ `\\eth`|$\\hslash$ `\\hslash`|$\\reals$ `\\reals`|$\\text{\\oe}$ `\\text{\\oe}`\r\n\r\nDirect Input: $∂ ∇ ℑ Ⅎ ℵ ℶ ℷ ℸ ⅁ ℏ ð − ∗$\r\nÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖÙÚÛÜÝÞßàáâãäåçèéêëìíîïðñòóôöùúûüýþÿ\r\n₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ⁺⁻⁼⁽⁾⁰¹²³⁴⁵⁶⁷⁸⁹ᵃᵇᶜᵈᵉᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘʷˣʸᶻᵛᵝᵞᵟᵠᵡ\r\n\r\nMath-mode Unicode (sub|super)script characters will render as if you had written regular characters in a subscript or superscript. For instance, `A²⁺³` will render the same as `A^{2+3}`.\r\n\r\n</div>\r\n<div class=\"katex-cards\" id=\"math-alpha\">\r\n\r\n**Unicode Mathematical Alphanumeric Symbols**\r\n\r\n| Item        |  Range              |  Item             |  Range  |\r\n|-------------|---------------------|-------------------|---------------|\r\n| Bold        | $\\text{𝐀-𝐙 𝐚-𝐳 𝟎-𝟗}$  | Double-struck     | $\\text{𝔸-}ℤ\\ 𝕜$\r\n| Italic      | $\\text{𝐴-𝑍 𝑎-𝑧}$      | Sans serif        | $\\text{𝖠-𝖹 𝖺-𝗓 𝟢-𝟫}$\r\n| Bold Italic | $\\text{𝑨-𝒁 𝒂-𝒛}$      | Sans serif bold   | $\\text{𝗔-𝗭 𝗮-𝘇 𝟬-𝟵}$\r\n| Script      | $\\text{𝒜-𝒵}$         | Sans serif italic | $\\text{𝘈-𝘡 𝘢-𝘻}$\r\n|  Fractur    | $\\text{𝔄-}ℨ\\text{ 𝔞-𝔷}$| Monospace        | $\\text{𝙰-𝚉 𝚊-𝚣 𝟶-𝟿}$\r\n\r\n</div>\r\n<div class=\"katex-hopscotch\">\r\n\r\n**Unicode**\r\n\r\nThe letters listed above will render properly in any KaTeX rendering mode.\r\n\r\nIn addition, Armenian, Brahmic, Georgian, Chinese, Japanese, and Korean glyphs are always accepted in text mode. However, these glyphs will be rendered from system fonts (not KaTeX-supplied fonts) so their typography may clash.\r\nYou can provide rules for CSS classes `.latin_fallback`, `.cyrillic_fallback`, `.brahmic_fallback`, `.georgian_fallback`, `.cjk_fallback`, and `.hangul_fallback` to provide fallback fonts for these languages.\r\nUse of these glyphs may cause small vertical alignment issues: KaTeX has detailed metrics for listed symbols and most Latin, Greek, and Cyrillic letters, but other accepted glyphs are treated as if they are each as tall as the letter M in the current KaTeX font.\r\n\r\nIf the KaTeX rendering mode is set to `strict: false` or `strict: \"warn\"` (default), then KaTeX will accept all Unicode letters in both text and math mode.\r\nAll unrecognized characters will be treated as if they appeared in text mode, and are subject to the same issues of using system fonts and possibly using incorrect vertical alignment.\r\n\r\nFor Persian composite characters, a user-supplied [plug-in](https://github.com/HosseinAgha/persian-katex-plugin) is under development.\r\n\r\nAny character can be written with the `\\char` function and the Unicode code in hex. For example `\\char\"263a` will render as $\\char\"263a$.\r\n\r\n## Layout\r\n\r\n### Annotation\r\n\r\n|||\r\n|:------------------------------|:-----\r\n|$\\cancel{5}$ `\\cancel{5}`|$\\overbrace{a+b+c}^{\\text{note}}$ `\\overbrace{a+b+c}^{\\text{note}}`\r\n|$\\bcancel{5}$ `\\bcancel{5}` |$\\underbrace{a+b+c}_{\\text{note}}$ `\\underbrace{a+b+c}_{\\text{note}}`\r\n|$\\xcancel{ABC}$ `\\xcancel{ABC}`|$\\not =$ `\\not =`\r\n|$\\sout{abc}$ `\\sout{abc}`|$\\boxed{\\pi=\\frac c d}$ `\\boxed{\\pi=\\frac c d}`\r\n|$a_{\\angl n}$ `$a_{\\angl n}`|$a_\\angln$ `a_\\angln`\r\n|$\\phase{-78^\\circ}$`\\phase{-78^\\circ}` |\r\n\r\n`\\tag{hi} x+y^{2x}`\r\n$$\\tag{hi} x+y^{2x}$$\r\n\r\n`\\tag*{hi} x+y^{2x}`\r\n$$\\tag*{hi} x+y^{2x}$$\r\n\r\n### Line Breaks\r\n\r\nKaTeX 0.10.0+ will insert automatic line breaks in inline math after relations or binary operators such as “=” or “+”. These can be suppressed by `\\nobreak` or by placing math inside a pair of braces, as in `{F=ma}`. `\\allowbreak` will allow automatic line breaks at locations other than relations or operators.\r\n\r\nHard line breaks are `\\\\` and `\\newline`.\r\n\r\nIn display math, KaTeX does not insert automatic line breaks. It ignores display math hard line breaks when rendering option `strict: true`.\r\n\r\n### Vertical Layout\r\n\r\n||||\r\n|:--------------|:----------------------------------------|:-----\r\n|$x_n$ `x_n` |$\\stackrel{!}{=}$ `\\stackrel{!}{=}`| $a \\atop b$ `a \\atop b`\r\n|$e^x$ `e^x` |$\\overset{!}{=}$ `\\overset{!}{=}`  | $a\\raisebox{0.25em}{$b$}c$ `a\\raisebox{0.25em}{$b$}c`\r\n|$_u^o $ `_u^o `| $\\underset{!}{=}$ `\\underset{!}{=}` | $a+\\left(\\vcenter{\\frac{\\frac a b}c}\\right)$ `a+\\left(\\vcenter{\\hbox{$\\frac{\\frac a b}c$}}\\right)`\r\n||| $$\\sum_{\\substack{0<i<m\\\\0<j<n}}$$ `\\sum_{\\substack{0<i<m\\\\0<j<n}}`\r\n\r\n`\\raisebox` and `\\hbox` put their argument into text mode. To raise math, nest `$…$` delimiters inside the argument as shown above. \r\n\r\n`\\vcenter` can be written without an `\\hbox` if the `strict` rendering option is *false*. In that case, omit the nested `$…$` delimiters.\r\n\r\n### Overlap and Spacing\r\n\r\n|||\r\n|:-------|:-------|\r\n|${=}\\mathllap{/\\,}$ `{=}\\mathllap{/\\,}` | $\\left(x^{\\smash{2}}\\right)$ `\\left(x^{\\smash{2}}\\right)`\r\n|$\\mathrlap{\\,/}{=}$ `\\mathrlap{\\,/}{=}` | $\\sqrt{\\smash[b]{y}}$ `\\sqrt{\\smash[b]{y}} `\r\n\r\n$\\displaystyle\\sum_{\\mathclap{1\\le i\\le j\\le n}} x_{ij}$ `\\sum_{\\mathclap{1\\le i\\le j\\le n}} x_{ij}`\r\n\r\nKaTeX also supports `\\llap`, `\\rlap`, and `\\clap`, but they will take only text, not math, as arguments.\r\n\r\n</div>\r\n<div class=\"katex-cards\" id=\"spacing-tbl\">\r\n\r\n**Spacing**\r\n\r\n| Function        | Produces           | Function             | Produces|\r\n|:----------------|:-------------------|:---------------------|:--------------------------------------|\r\n| `\\,`            | ³∕₁₈ em space      | `\\kern{distance}`    | space, width = *distance*\r\n| `\\thinspace`    | ³∕₁₈ em space      | `\\mkern{distance}`   | space, width = *distance*\r\n| `\\>`            | ⁴∕₁₈ em space      | `\\mskip{distance}`   | space, width = *distance*\r\n| `\\:`            | ⁴∕₁₈ em space      | `\\hskip{distance}`   | space, width = *distance*\r\n| `\\medspace`     | ⁴∕₁₈ em space      | `\\hspace{distance}`  | space, width = *distance*\r\n| `\\;`            | ⁵∕₁₈ em space      | `\\hspace*{distance}` | space, width = *distance*\r\n| `\\thickspace`   | ⁵∕₁₈ em space      | `\\phantom{content}`  | space the width and height of content\r\n| `\\enspace`      | ½ em space         | `\\hphantom{content}` | space the width of content\r\n| `\\quad`         | 1 em space         | `\\vphantom{content}` | a strut the height of content\r\n| `\\qquad`        | 2 em space         | `\\!`                 | – ³∕₁₈ em space\r\n| `~`             | non-breaking space | `\\negthinspace`      | – ³∕₁₈ em space\r\n| `\\<space>`      | space              | `\\negmedspace`       | – ⁴∕₁₈ em space\r\n| `\\nobreakspace` | non-breaking space | `\\negthickspace`     | – ⁵∕₁₈ em space\r\n| `\\space`        | space              | `\\mathstrut`         | `\\vphantom{(}`\r\n\r\n</div>\r\n\r\n**Notes:**\r\n\r\n`distance` will accept any of the [KaTeX units](#units).\r\n\r\n`\\kern`, `\\mkern`, `\\mskip`, and `\\hspace` accept unbraced distances, as in: `\\kern1em`.\r\n\r\n`\\mkern` and `\\mskip` will not work in text mode and both will write a console warning for any unit except `mu`.\r\n\r\n<div class=\"katex-hopscotch\">\r\n\r\n## Logic and Set Theory\r\n\r\n|||||\r\n|:--------------------|:--------------------------|:----------------------------|:-----\r\n|$\\forall$ `\\forall`  |$\\complement$ `\\complement`|$\\therefore$ `\\therefore`    |$\\emptyset$ `\\emptyset`\r\n|$\\exists$ `\\exists`  |$\\subset$ `\\subset`  |$\\because$ `\\because`              |$\\empty$ `\\empty`\r\n|$\\exist$ `\\exist`    |$\\supset$ `\\supset`  |$\\mapsto$ `\\mapsto`                |$\\varnothing$ `\\varnothing`\r\n|$\\nexists$ `\\nexists`|$\\mid$ `\\mid`        |$\\to$ `\\to`                        |$\\implies$ `\\implies`\r\n|$\\in$ `\\in`          |$\\land$ `\\land`      |$\\gets$ `\\gets`                    |$\\impliedby$ `\\impliedby`\r\n|$\\isin$ `\\isin`      |$\\lor$ `\\lor`        |$\\leftrightarrow$ `\\leftrightarrow`|$\\iff$ `\\iff`\r\n|$\\notin$ `\\notin`    |$\\ni$ `\\ni`          |$\\notni$ `\\notni`                  |$\\neg$ `\\neg` or `\\lnot`\r\n|   | $\\Set{ x \\| x<\\frac 1 2 }$<br>`\\Set{ x \\| x<\\frac 1 2 }`  | $\\set{x\\|x<5}$<br>`\\set{x\\|x<5}`\r\n\r\nDirect Input: $∀ ∴ ∁ ∵ ∃ ∣ ∈ ∉ ∋ ⊂ ⊃ ∧ ∨ ↦ → ← ↔ ¬$ ℂ ℍ ℕ ℙ ℚ ℝ\r\n\r\n## Macros\r\n\r\n|||\r\n|:-------------------------------------|:------\r\n|$\\def\\foo{x^2} \\foo + \\foo$           | `\\def\\foo{x^2} \\foo + \\foo`\r\n|$\\gdef\\bar#1{#1^2} \\bar{y} + \\bar{y}$ | `\\gdef\\bar#1{#1^2} \\bar{y} + \\bar{y}`\r\n|                                      | `\\edef\\macroname#1#2…{definition to be expanded}`\r\n|                                      | `\\xdef\\macroname#1#2…{definition to be expanded}`\r\n|                                      | `\\let\\foo=\\bar`\r\n|                                      | `\\futurelet\\foo\\bar x`\r\n|                                      | `\\global\\def\\macroname#1#2…{definition}`\r\n|                                      | `\\newcommand\\macroname[numargs]{definition}`\r\n|                                      | `\\renewcommand\\macroname[numargs]{definition}`\r\n|                                      | `\\providecommand\\macroname[numargs]{definition}`\r\n\r\nMacros can also be defined in the KaTeX [rendering options](options.md).\r\n\r\nMacros accept up to nine arguments: #1, #2, etc.\r\n\r\n</div>\r\n\r\n<div id=\"gdef\">\r\n\r\nMacros defined by `\\gdef`, `\\xdef`, `\\global\\def`, `\\global\\edef`, `\\global\\let`, and `\\global\\futurelet` will persist between math expressions. (Exception: macro persistence may be disabled. There are legitimate security reasons for that.)\r\n\r\nKaTeX has no `\\par`, so all macros are long by default and `\\long` will be ignored.\r\n\r\nAvailable functions include:\r\n\r\n`\\char` `\\mathchoice` `\\TextOrMath` `\\@ifstar` `\\@ifnextchar` `\\@firstoftwo` `\\@secondoftwo` `\\relax` `\\expandafter` `\\noexpand`\r\n\r\n@ is a valid character for commands, as if `\\makeatletter` were in effect.\r\n\r\n## Operators\r\n\r\n### Big Operators\r\n\r\n|||||\r\n|------------------|-------------------------|--------------------------|--------------|\r\n| $\\sum$ `\\sum`    | $\\prod$ `\\prod`         | $\\bigotimes$ `\\bigotimes`| $\\bigvee$ `\\bigvee`\r\n| $\\int$ `\\int`    | $\\coprod$ `\\coprod`     | $\\bigoplus$ `\\bigoplus`  | $\\bigwedge$ `\\bigwedge`\r\n| $\\iint$ `\\iint`  | $\\intop$ `\\intop`       | $\\bigodot$ `\\bigodot`    | $\\bigcap$ `\\bigcap`\r\n| $\\iiint$ `\\iiint`| $\\smallint$ `\\smallint` | $\\biguplus$ `\\biguplus`  | $\\bigcup$ `\\bigcup`\r\n| $\\oint$ `\\oint`  | $\\oiint$ `\\oiint`       | $\\oiiint$ `\\oiiint`      | $\\bigsqcup$ `\\bigsqcup`\r\n\r\nDirect Input: $∫ ∬ ∭ ∮ ∏ ∐ ∑ ⋀ ⋁ ⋂ ⋃ ⨀ ⨁ ⨂ ⨄ ⨆$ ∯ ∰\r\n\r\n### Binary Operators\r\n\r\n|||||\r\n|-------------|-------------------|-------------------|--------------------|\r\n| $+$ `+`| $\\cdot$ `\\cdot`  | $\\gtrdot$ `\\gtrdot`| $x \\pmod a$ `x \\pmod a`|\r\n| $-$ `-`| $\\cdotp$ `\\cdotp` | $\\intercal$ `\\intercal` | $x \\pod a$ `x \\pod a` |\r\n| $/$ `/`| $\\centerdot$ `\\centerdot`| $\\land$ `\\land`  | $\\rhd$ `\\rhd` |\r\n| $*$ `*`| $\\circ$ `\\circ`  | $\\leftthreetimes$ `\\leftthreetimes` | $\\rightthreetimes$ `\\rightthreetimes` |\r\n| $\\amalg$ `\\amalg` | $\\circledast$ `\\circledast`  | $\\ldotp$ `\\ldotp` | $\\rtimes$ `\\rtimes` |\r\n| $\\And$ `\\And`| $\\circledcirc$ `\\circledcirc` | $\\lor$ `\\lor`| $\\setminus$ `\\setminus`  |\r\n| $\\ast$ `\\ast`| $\\circleddash$ `\\circleddash` | $\\lessdot$ `\\lessdot`  | $\\smallsetminus$ `\\smallsetminus`|\r\n| $\\barwedge$ `\\barwedge` | $\\Cup$ `\\Cup`| $\\lhd$ `\\lhd`| $\\sqcap$ `\\sqcap`  |\r\n| $\\bigcirc$ `\\bigcirc`  | $\\cup$ `\\cup`| $\\ltimes$ `\\ltimes`| $\\sqcup$ `\\sqcup`  |\r\n| $\\bmod$ `\\bmod`  | $\\curlyvee$ `\\curlyvee` | $x \\mod a$ `x\\mod a`| $\\times$ `\\times`  |\r\n| $\\boxdot$ `\\boxdot`| $\\curlywedge$ `\\curlywedge`  | $\\mp$ `\\mp` | $\\unlhd$ `\\unlhd`  |\r\n| $\\boxminus$ `\\boxminus` | $\\div$ `\\div`| $\\odot$ `\\odot`  | $\\unrhd$ `\\unrhd`  |\r\n| $\\boxplus$ `\\boxplus`  | $\\divideontimes$ `\\divideontimes`  | $\\ominus$ `\\ominus`| $\\uplus$ `\\uplus`  |\r\n| $\\boxtimes$ `\\boxtimes` | $\\dotplus$ `\\dotplus`  | $\\oplus$ `\\oplus` | $\\vee$ `\\vee` |\r\n| $\\bullet$ `\\bullet`| $\\doublebarwedge$ `\\doublebarwedge` | $\\otimes$ `\\otimes`| $\\veebar$ `\\veebar` |\r\n| $\\Cap$ `\\Cap`| $\\doublecap$ `\\doublecap`| $\\oslash$ `\\oslash`| $\\wedge$ `\\wedge`  |\r\n| $\\cap$ `\\cap`| $\\doublecup$ `\\doublecup`| $\\pm$ `\\pm` or `\\plusmn` | $\\wr$ `\\wr`  |\r\n\r\nDirect Input: $+ - / * ⋅ ∘ ∙ ± × ÷ ∓ ∔ ∧ ∨ ∩ ∪ ≀ ⊎ ⊓ ⊔ ⊕ ⊖ ⊗ ⊘ ⊙ ⊚ ⊛ ⊝ ◯ ∖ {}$\r\n\r\n### Fractions and Binomials\r\n\r\n||||\r\n|:--------------------------|:----------------------------|:-----\r\n|$\\frac{a}{b}$ `\\frac{a}{b}`|$\\tfrac{a}{b}$ `\\tfrac{a}{b}`|$\\genfrac ( ] {2pt}{1}a{a+1}$ `\\genfrac ( ] {2pt}{1}a{a+1}`\r\n|${a \\over b}$ `{a \\over b}`|$\\dfrac{a}{b}$ `\\dfrac{a}{b}`|${a \\above{2pt} b+1}$ `{a \\above{2pt} b+1}`\r\n|$a/b$ `a/b`                |  |$\\cfrac{a}{1 + \\cfrac{1}{b}}$ `\\cfrac{a}{1 + \\cfrac{1}{b}}`\r\n\r\n||||\r\n|:------------------------------|:------------------------------|:--------\r\n|$\\binom{n}{k}$ `\\binom{n}{k}`  |$\\dbinom{n}{k}$ `\\dbinom{n}{k}`|${n\\brace k}$ `{n\\brace k}`\r\n|${n \\choose k}$ `{n \\choose k}`|$\\tbinom{n}{k}$ `\\tbinom{n}{k}`|${n\\brack k}$ `{n\\brack k}`\r\n\r\n### Math Operators\r\n\r\n|||||\r\n|:--------------------|:--------------------|:----------------|:--------------|\r\n| $\\arcsin$ `\\arcsin` | $\\cosec$ `\\cosec`   | $\\deg$ `\\deg`   | $\\sec$ `\\sec` |\r\n| $\\arccos$ `\\arccos` | $\\cosh$ `\\cosh`     | $\\dim$ `\\dim`   | $\\sin$ `\\sin` |\r\n| $\\arctan$ `\\arctan` | $\\cot$ `\\cot`       | $\\exp$ `\\exp`   | $\\sinh$ `\\sinh` |\r\n| $\\arctg$ `\\arctg`   | $\\cotg$ `\\cotg`     | $\\hom$ `\\hom`   | $\\sh$ `\\sh` |\r\n| $\\arcctg$ `\\arcctg` | $\\coth$ `\\coth`     | $\\ker$ `\\ker`   | $\\tan$ `\\tan` |\r\n| $\\arg$ `\\arg`       | $\\csc$ `\\csc`       | $\\lg$ `\\lg`     | $\\tanh$ `\\tanh` |\r\n| $\\ch$ `\\ch`         | $\\ctg$ `\\ctg`       | $\\ln$ `\\ln`     | $\\tg$ `\\tg` |\r\n| $\\cos$ `\\cos`       | $\\cth$ `\\cth`       | $\\log$ `\\log`   | $\\th$ `\\th` |\r\n| $\\operatorname{f}$ `\\operatorname{f}`     | |||\r\n| $\\argmax$ `\\argmax` | $\\injlim$ `\\injlim` | $\\min$ `\\min`   | $\\varinjlim$ `\\varinjlim` |\r\n| $\\argmin$ `\\argmin` | $\\lim$ `\\lim`       | $\\plim$ `\\plim` | $\\varliminf$ `\\varliminf` |\r\n| $\\det$ `\\det`       | $\\liminf$ `\\liminf` | $\\Pr$ `\\Pr`     | $\\varlimsup$ `\\varlimsup` |\r\n| $\\gcd$ `\\gcd`       | $\\limsup$ `\\limsup` | $\\projlim$ `\\projlim` | $\\varprojlim$ `\\varprojlim` |\r\n| $\\inf$ `\\inf`       | $\\max$ `\\max`       | $\\sup$ `\\sup`   ||\r\n| $\\operatorname*{f}$ `\\operatorname*{f}` | $\\operatornamewithlimits{f}$ `\\operatornamewithlimits{f}` |||\r\n\r\nFunctions in the bottom six rows of this table can take `\\limits`.\r\n\r\n### \\sqrt\r\n\r\n$\\sqrt{x}$ `\\sqrt{x}`\r\n\r\n$\\sqrt[3]{x}$ `\\sqrt[3]{x}`\r\n\r\n## Relations\r\n\r\n$\\stackrel{!}{=}$ `\\stackrel{!}{=}`\r\n\r\n|||||\r\n|:--------|:------------------------|:----------------------------|:------------------|\r\n| $=$ `=` | $\\doteqdot$ `\\doteqdot` | $\\lessapprox$ `\\lessapprox` | $\\smile$ `\\smile` |\r\n| $<$ `<` | $\\eqcirc$ `\\eqcirc` | $\\lesseqgtr$ `\\lesseqgtr` | $\\sqsubset$ `\\sqsubset` |\r\n| $>$ `>` | $\\eqcolon$ `\\eqcolon` or<br>    `\\minuscolon` | $\\lesseqqgtr$ `\\lesseqqgtr` | $\\sqsubseteq$ `\\sqsubseteq` |\r\n| $:$ `:` | $\\Eqcolon$ `\\Eqcolon` or<br>    `\\minuscoloncolon` | $\\lessgtr$ `\\lessgtr` | $\\sqsupset$ `\\sqsupset` |\r\n| $\\approx$ `\\approx` | $\\eqqcolon$ `\\eqqcolon` or<br>    `\\equalscolon` | $\\lesssim$ `\\lesssim` | $\\sqsupseteq$ `\\sqsupseteq` |\r\n| $\\approxcolon$ `\\approxcolon` | $\\Eqqcolon$ `\\Eqqcolon` or<br>    `\\equalscoloncolon` | $\\ll$ `\\ll` | $\\Subset$ `\\Subset` |\r\n| $\\approxcoloncolon$ `\\approxcoloncolon` | $\\eqsim$ `\\eqsim` | $\\lll$ `\\lll` | $\\subset$ `\\subset` or `\\sub` |\r\n| $\\approxeq$ `\\approxeq` | $\\eqslantgtr$ `\\eqslantgtr` | $\\llless$ `\\llless` | $\\subseteq$ `\\subseteq` or `\\sube` |\r\n| $\\asymp$ `\\asymp` | $\\eqslantless$ `\\eqslantless` | $\\lt$ `\\lt` | $\\subseteqq$ `\\subseteqq` |\r\n| $\\backepsilon$ `\\backepsilon` | $\\equiv$ `\\equiv` | $\\mid$ `\\mid` | $\\succ$ `\\succ` |\r\n| $\\backsim$ `\\backsim` | $\\fallingdotseq$ `\\fallingdotseq` | $\\models$ `\\models` | $\\succapprox$ `\\succapprox` |\r\n| $\\backsimeq$ `\\backsimeq` | $\\frown$ `\\frown` | $\\multimap$ `\\multimap` | $\\succcurlyeq$ `\\succcurlyeq` |\r\n| $\\between$ `\\between` | $\\ge$ `\\ge` | $\\origof$ `\\origof` | $\\succeq$ `\\succeq` |\r\n| $\\bowtie$ `\\bowtie` | $\\geq$ `\\geq` | $\\owns$ `\\owns` | $\\succsim$ `\\succsim` |\r\n| $\\bumpeq$ `\\bumpeq` | $\\geqq$ `\\geqq` | $\\parallel$ `\\parallel` | $\\Supset$ `\\Supset` |\r\n| $\\Bumpeq$ `\\Bumpeq` | $\\geqslant$ `\\geqslant` | $\\perp$ `\\perp` | $\\supset$ `\\supset` |\r\n| $\\circeq$ `\\circeq` | $\\gg$ `\\gg` | $\\pitchfork$ `\\pitchfork` | $\\supseteq$ `\\supseteq` or `\\supe` |\r\n| $\\colonapprox$ `\\colonapprox` | $\\ggg$ `\\ggg` | $\\prec$ `\\prec` | $\\supseteqq$ `\\supseteqq` |\r\n| $\\Colonapprox$ `\\Colonapprox` or<br>    `\\coloncolonapprox` | $\\gggtr$ `\\gggtr` | $\\precapprox$ `\\precapprox` | $\\thickapprox$ `\\thickapprox` |\r\n| $\\coloneq$ `\\coloneq` or<br>    `\\colonminus` | $\\gt$ `\\gt` | $\\preccurlyeq$ `\\preccurlyeq` | $\\thicksim$ `\\thicksim` |\r\n| $\\Coloneq$ `\\Coloneq` or<br>    `\\coloncolonminus` | $\\gtrapprox$ `\\gtrapprox` | $\\preceq$ `\\preceq` | $\\trianglelefteq$ `\\trianglelefteq` |\r\n| $\\coloneqq$ `\\coloneqq` or<br>   `\\colonequals` | $\\gtreqless$ `\\gtreqless` | $\\precsim$ `\\precsim` | $\\triangleq$ `\\triangleq` |\r\n| $\\Coloneqq$ `\\Coloneqq` or<br>    `\\coloncolonequals` | $\\gtreqqless$ `\\gtreqqless` | $\\propto$ `\\propto` | $\\trianglerighteq$ `\\trianglerighteq` |\r\n| $\\colonsim$ `\\colonsim` | $\\gtrless$ `\\gtrless` | $\\risingdotseq$ `\\risingdotseq` | $\\varpropto$ `\\varpropto` |\r\n| $\\Colonsim$ `\\Colonsim` or<br>    `\\coloncolonsim` | $\\gtrsim$ `\\gtrsim` | $\\shortmid$ `\\shortmid` | $\\vartriangle$ `\\vartriangle` |\r\n| $\\cong$ `\\cong` | $\\imageof$ `\\imageof` | $\\shortparallel$ `\\shortparallel` | $\\vartriangleleft$ `\\vartriangleleft` |\r\n| $\\curlyeqprec$ `\\curlyeqprec` | $\\in$ `\\in` or `\\isin` | $\\sim$ `\\sim` | $\\vartriangleright$ `\\vartriangleright` |\r\n| $\\curlyeqsucc$ `\\curlyeqsucc` | $\\Join$ `\\Join` | $\\simcolon$ `\\simcolon` | $\\vcentcolon$ `\\vcentcolon` or<br>   `\\ratio` |\r\n| $\\dashv$ `\\dashv` | $\\le$ `\\le` | $\\simcoloncolon$ `\\simcoloncolon` | $\\vdash$ `\\vdash` |\r\n| $\\dblcolon$ `\\dblcolon` or<br>   `\\coloncolon` | $\\leq$ `\\leq` | $\\simeq$ `\\simeq` | $\\vDash$ `\\vDash` |\r\n| $\\doteq$ `\\doteq` | $\\leqq$ `\\leqq` | $\\smallfrown$ `\\smallfrown` | $\\Vdash$ `\\Vdash` |\r\n| $\\Doteq$ `\\Doteq` | $\\leqslant$ `\\leqslant` | $\\smallsmile$ `\\smallsmile` | $\\Vvdash$ `\\Vvdash` |\r\n\r\nDirect Input: $= < > : ∈ ∋ ∝ ∼ ∽ ≂ ≃ ≅ ≈ ≊ ≍ ≎ ≏ ≐ ≑ ≒ ≓ ≖ ≗ ≜ ≡ ≤ ≥ ≦ ≧ ≫ ≬ ≳ ≷ ≺ ≻ ≼ ≽ ≾ ≿ ⊂ ⊃ ⊆ ⊇ ⊏ ⊐ ⊑ ⊒ ⊢ ⊣ ⊩ ⊪ ⊸ ⋈ ⋍ ⋐ ⋑ ⋔ ⋙ ⋛ ⋞ ⋟ ⌢ ⌣ ⩾ ⪆ ⪌ ⪕ ⪖ ⪯ ⪰ ⪷ ⪸ ⫅ ⫆ ≲ ⩽ ⪅ ≶ ⋚ ⪋ ⟂ ⊨ ⊶ ⊷$ `≔ ≕ ⩴`\r\n\r\n### Negated Relations\r\n\r\n$\\not =$ `\\not =`\r\n\r\n|||||\r\n|--------------|-------------------|---------------------|------------------|\r\n| $\\gnapprox$ `\\gnapprox`  | $\\ngeqslant$ `\\ngeqslant`| $\\nsubseteq$ `\\nsubseteq`  | $\\precneqq$ `\\precneqq`|\r\n| $\\gneq$ `\\gneq`| $\\ngtr$ `\\ngtr`  | $\\nsubseteqq$ `\\nsubseteqq` | $\\precnsim$ `\\precnsim`|\r\n| $\\gneqq$ `\\gneqq`  | $\\nleq$ `\\nleq`  | $\\nsucc$ `\\nsucc`| $\\subsetneq$ `\\subsetneq`  |\r\n| $\\gnsim$ `\\gnsim`  | $\\nleqq$ `\\nleqq` | $\\nsucceq$ `\\nsucceq` | $\\subsetneqq$ `\\subsetneqq` |\r\n| $\\gvertneqq$ `\\gvertneqq` | $\\nleqslant$ `\\nleqslant`| $\\nsupseteq$ `\\nsupseteq`  | $\\succnapprox$ `\\succnapprox`|\r\n| $\\lnapprox$ `\\lnapprox`  | $\\nless$ `\\nless` | $\\nsupseteqq$ `\\nsupseteqq` | $\\succneqq$ `\\succneqq`|\r\n| $\\lneq$ `\\lneq`| $\\nmid$ `\\nmid`  | $\\ntriangleleft$ `\\ntriangleleft` | $\\succnsim$ `\\succnsim`|\r\n| $\\lneqq$ `\\lneqq`  | $\\notin$ `\\notin` | $\\ntrianglelefteq$ `\\ntrianglelefteq`  | $\\supsetneq$ `\\supsetneq`  |\r\n| $\\lnsim$ `\\lnsim`  | $\\notni$ `\\notni` | $\\ntriangleright$ `\\ntriangleright`| $\\supsetneqq$ `\\supsetneqq` |\r\n| $\\lvertneqq$ `\\lvertneqq` | $\\nparallel$ `\\nparallel`| $\\ntrianglerighteq$ `\\ntrianglerighteq` | $\\varsubsetneq$ `\\varsubsetneq`  |\r\n| $\\ncong$ `\\ncong`  | $\\nprec$ `\\nprec` | $\\nvdash$ `\\nvdash`  | $\\varsubsetneqq$ `\\varsubsetneqq` |\r\n| $\\ne$ `\\ne`  | $\\npreceq$ `\\npreceq`  | $\\nvDash$ `\\nvDash`  | $\\varsupsetneq$ `\\varsupsetneq`  |\r\n| $\\neq$ `\\neq` | $\\nshortmid$ `\\nshortmid`| $\\nVDash$ `\\nVDash`  | $\\varsupsetneqq$ `\\varsupsetneqq` |\r\n| $\\ngeq$ `\\ngeq`| $\\nshortparallel$ `\\nshortparallel` | $\\nVdash$ `\\nVdash`  |\r\n| $\\ngeqq$ `\\ngeqq`  | $\\nsim$ `\\nsim`  | $\\precnapprox$ `\\precnapprox`|\r\n\r\nDirect Input: $∉ ∌ ∤ ∦ ≁ ≆ ≠ ≨ ≩ ≮ ≯ ≰ ≱ ⊀ ⊁ ⊈ ⊉ ⊊ ⊋ ⊬ ⊭ ⊮ ⊯ ⋠ ⋡ ⋦ ⋧ ⋨ ⋩ ⋬ ⋭ ⪇ ⪈ ⪉ ⪊ ⪵ ⪶ ⪹ ⪺ ⫋ ⫌$\r\n\r\n### Arrows\r\n\r\n||||\r\n|:----------|:----------|:----------|\r\n|$\\circlearrowleft$ `\\circlearrowleft`|$\\leftharpoonup$ `\\leftharpoonup`|$\\rArr$ `\\rArr`\r\n|$\\circlearrowright$ `\\circlearrowright`|$\\leftleftarrows$ `\\leftleftarrows`|$\\rarr$ `\\rarr`\r\n|$\\curvearrowleft$ `\\curvearrowleft`|$\\leftrightarrow$ `\\leftrightarrow`|$\\restriction$ `\\restriction`\r\n|$\\curvearrowright$ `\\curvearrowright`|$\\Leftrightarrow$ `\\Leftrightarrow`|$\\rightarrow$ `\\rightarrow`\r\n|$\\Darr$ `\\Darr`|$\\leftrightarrows$ `\\leftrightarrows`|$\\Rightarrow$ `\\Rightarrow`\r\n|$\\dArr$ `\\dArr`|$\\leftrightharpoons$ `\\leftrightharpoons`|$\\rightarrowtail$ `\\rightarrowtail`\r\n|$\\darr$ `\\darr`|$\\leftrightsquigarrow$ `\\leftrightsquigarrow`|$\\rightharpoondown$ `\\rightharpoondown`\r\n|$\\dashleftarrow$ `\\dashleftarrow`|$\\Lleftarrow$ `\\Lleftarrow`|$\\rightharpoonup$ `\\rightharpoonup`\r\n|$\\dashrightarrow$ `\\dashrightarrow`|$\\longleftarrow$ `\\longleftarrow`|$\\rightleftarrows$ `\\rightleftarrows`\r\n|$\\downarrow$ `\\downarrow`|$\\Longleftarrow$ `\\Longleftarrow`|$\\rightleftharpoons$ `\\rightleftharpoons`\r\n|$\\Downarrow$ `\\Downarrow`|$\\longleftrightarrow$ `\\longleftrightarrow`|$\\rightrightarrows$ `\\rightrightarrows`\r\n|$\\downdownarrows$ `\\downdownarrows`|$\\Longleftrightarrow$ `\\Longleftrightarrow`|$\\rightsquigarrow$ `\\rightsquigarrow`\r\n|$\\downharpoonleft$ `\\downharpoonleft`|$\\longmapsto$ `\\longmapsto`|$\\Rrightarrow$ `\\Rrightarrow`\r\n|$\\downharpoonright$ `\\downharpoonright`|$\\longrightarrow$ `\\longrightarrow`|$\\Rsh$ `\\Rsh`\r\n|$\\gets$ `\\gets`|$\\Longrightarrow$ `\\Longrightarrow`|$\\searrow$ `\\searrow`\r\n|$\\Harr$ `\\Harr`|$\\looparrowleft$ `\\looparrowleft`|$\\swarrow$ `\\swarrow`\r\n|$\\hArr$ `\\hArr`|$\\looparrowright$ `\\looparrowright`|$\\to$ `\\to`\r\n|$\\harr$ `\\harr`|$\\Lrarr$ `\\Lrarr`|$\\twoheadleftarrow$ `\\twoheadleftarrow`\r\n|$\\hookleftarrow$ `\\hookleftarrow`|$\\lrArr$ `\\lrArr`|$\\twoheadrightarrow$ `\\twoheadrightarrow`\r\n|$\\hookrightarrow$ `\\hookrightarrow`|$\\lrarr$ `\\lrarr`|$\\Uarr$ `\\Uarr`\r\n|$\\iff$ `\\iff`|$\\Lsh$ `\\Lsh`|$\\uArr$ `\\uArr`\r\n|$\\impliedby$ `\\impliedby`|$\\mapsto$ `\\mapsto`|$\\uarr$ `\\uarr`\r\n|$\\implies$ `\\implies`|$\\nearrow$ `\\nearrow`|$\\uparrow$ `\\uparrow`\r\n|$\\Larr$ `\\Larr`|$\\nleftarrow$ `\\nleftarrow`|$\\Uparrow$ `\\Uparrow`\r\n|$\\lArr$ `\\lArr`|$\\nLeftarrow$ `\\nLeftarrow`|$\\updownarrow$ `\\updownarrow`\r\n|$\\larr$ `\\larr`|$\\nleftrightarrow$ `\\nleftrightarrow`|$\\Updownarrow$ `\\Updownarrow`\r\n|$\\leadsto$ `\\leadsto`|$\\nLeftrightarrow$ `\\nLeftrightarrow`|$\\upharpoonleft$ `\\upharpoonleft`\r\n|$\\leftarrow$ `\\leftarrow`|$\\nrightarrow$ `\\nrightarrow`|$\\upharpoonright$ `\\upharpoonright`\r\n|$\\Leftarrow$ `\\Leftarrow`|$\\nRightarrow$ `\\nRightarrow`|$\\upuparrows$ `\\upuparrows`\r\n|$\\leftarrowtail$ `\\leftarrowtail`|$\\nwarrow$ `\\nwarrow`\r\n|$\\leftharpoondown$ `\\leftharpoondown`|$\\Rarr$ `\\Rarr`\r\n\r\nDirect Input: $← ↑ → ↓ ↔ ↕ ↖ ↗ ↘ ↙ ↚ ↛ ↞ ↠ ↢ ↣ ↦ ↩ ↪ ↫ ↬ ↭ ↮ ↰ ↱↶ ↷ ↺ ↻ ↼ ↽ ↾ ↾ ↿ ⇀ ⇁ ⇂ ⇃ ⇄ ⇆ ⇇ ⇈ ⇉ ⇊ ⇋ ⇌⇍ ⇎ ⇏ ⇐ ⇑ ⇒ ⇓ ⇔ ⇕ ⇚ ⇛ ⇝ ⇠ ⇢ ⟵ ⟶ ⟷ ⟸ ⟹ ⟺ ⟼$ ↽\r\n\r\n**Extensible Arrows**\r\n\r\n|||\r\n|:----------------------------------------------------|:-----\r\n|$\\xleftarrow{abc}$ `\\xleftarrow{abc}`                |$\\xrightarrow[under]{over}$ `\\xrightarrow[under]{over}`\r\n|$\\xLeftarrow{abc}$ `\\xLeftarrow{abc}`                |$\\xRightarrow{abc}$ `\\xRightarrow{abc}`\r\n|$\\xleftrightarrow{abc}$ `\\xleftrightarrow{abc}`      |$\\xLeftrightarrow{abc}$ `\\xLeftrightarrow{abc}`\r\n|$\\xhookleftarrow{abc}$ `\\xhookleftarrow{abc}`        |$\\xhookrightarrow{abc}$ `\\xhookrightarrow{abc}`\r\n|$\\xtwoheadleftarrow{abc}$ `\\xtwoheadleftarrow{abc}`  |$\\xtwoheadrightarrow{abc}$ `\\xtwoheadrightarrow{abc}`\r\n|$\\xleftharpoonup{abc}$ `\\xleftharpoonup{abc}`        |$\\xrightharpoonup{abc}$ `\\xrightharpoonup{abc}`\r\n|$\\xleftharpoondown{abc}$ `\\xleftharpoondown{abc}`    |$\\xrightharpoondown{abc}$ `\\xrightharpoondown{abc}`\r\n|$\\xleftrightharpoons{abc}$ `\\xleftrightharpoons{abc}`|$\\xrightleftharpoons{abc}$ `\\xrightleftharpoons{abc}`\r\n|$\\xtofrom{abc}$ `\\xtofrom{abc}`                      |$\\xmapsto{abc}$ `\\xmapsto{abc}`\r\n|$\\xlongequal{abc}$ `\\xlongequal{abc}`\r\n\r\nExtensible arrows all can take an optional argument in the same manner<br>as `\\xrightarrow[under]{over}`.\r\n\r\n## Special Notation\r\n\r\n**Bra-ket Notation**\r\n\r\n||||\r\n|:----------|:----------|:----------|\r\n|$\\bra{\\phi}$ `\\bra{\\phi}` |$\\ket{\\psi}$ `\\ket{\\psi}` |$\\braket{\\phi\\vert\\psi}$ `\\braket{\\phi\\vert\\psi}` |\r\n|$\\Bra{\\phi}$ `\\Bra{\\phi}` |$\\Ket{\\psi}$ `\\Ket{\\psi}` |$\\Braket{ ϕ \\| \\frac{∂^2}{∂ t^2} \\| ψ }$ `\\Braket{ ϕ \\| \\frac{∂^2}{∂ t^2} \\| ψ }`|\r\n\r\n## Style, Color, Size, and Font\r\n\r\n**Class Assignment**\r\n\r\n`\\mathbin` `\\mathclose` `\\mathinner` `\\mathop`<br>\r\n`\\mathopen` `\\mathord` `\\mathpunct` `\\mathrel`\r\n\r\n**Color**\r\n\r\n$\\color{blue} F=ma$  `\\color{blue} F=ma`\r\n\r\nNote that `\\color` acts like a switch. Other color functions expect the content to be a function argument:\r\n\r\n$\\textcolor{blue}{F=ma}$ `\\textcolor{blue}{F=ma}`<br>\r\n$\\textcolor{#228B22}{F=ma}$ `\\textcolor{#228B22}{F=ma}`<br>\r\n$\\colorbox{aqua}{$F=ma$}$ `\\colorbox{aqua}{$F=ma$}`<br>\r\n$\\fcolorbox{red}{aqua}{$F=ma$}$ `\\fcolorbox{red}{aqua}{$F=ma$}`\r\n\r\nNote that, as in LaTeX, `\\colorbox` & `\\fcolorbox` renders its third argument as text, so you may want to switch back to math mode with `$` as in the examples above.\r\n\r\nFor color definition, KaTeX color functions will accept the standard HTML [predefined color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords). They will also accept an RGB argument in CSS hexa­decimal style. The \"#\" is optional before a six-digit specification.\r\n\r\n**Font**\r\n\r\n||||\r\n|:------------------------------|:------------------------------|:-----\r\n|$\\mathrm{Ab0}$ `\\mathrm{Ab0}`  |$\\mathbf{Ab0}$ `\\mathbf{Ab0}`  |$\\mathit{Ab0}$ `\\mathit{Ab0}`\r\n|$\\mathnormal{Ab0}$ `\\mathnormal{Ab0}`|$\\textbf{Ab0}$ `\\textbf{Ab0}`  |$\\textit{Ab0}$ `\\textit{Ab0}`\r\n|$\\textrm{Ab0}$ `\\textrm{Ab0}`  |$\\bf Ab0$ `\\bf Ab0`            |$\\it Ab0$ `\\it Ab0`\r\n|$\\rm Ab0$ `\\rm Ab0`            |$\\bold{Ab0}$ `\\bold{Ab0}`      |$\\textup{Ab0}$ `\\textup{Ab0}`\r\n|$\\textnormal{Ab0}$ `\\textnormal{Ab0}`|$\\boldsymbol{Ab0}$ `\\boldsymbol{Ab}`|$\\Bbb{AB}$ `\\Bbb{AB}`\r\n|$\\text{Ab0}$ `\\text{Ab0}`      |$\\bm{Ab0}$ `\\bm{Ab0}`          |$\\mathbb{AB}$ `\\mathbb{AB}`\r\n|$\\mathsf{Ab0}$ `\\mathsf{Ab0}`  |$\\textmd{Ab0}$ `\\textmd{Ab0}`  |$\\frak{Ab0}$ `\\frak{Ab0}`\r\n|$\\textsf{Ab0}$ `\\textsf{Ab0}`  |$\\mathtt{Ab0}$ `\\mathtt{Ab0}`  |$\\mathfrak{Ab0}$ `\\mathfrak{Ab0}`\r\n|$\\sf Ab0$ `\\sf Ab0`            |$\\texttt{Ab0}$ `\\texttt{Ab0}`  |$\\mathcal{AB0}$ `\\mathcal{AB0}`\r\n|                               |$\\tt Ab0$ `\\tt Ab0`            |$\\cal AB0$ `\\cal AB0`\r\n|                               |                               |$\\mathscr{AB}$ `\\mathscr{AB}`\r\n\r\nOne can stack font family, font weight, and font shape by using the `\\textXX` versions of the font functions. So `\\textsf{\\textbf{H}}` will produce $\\textsf{\\textbf{H}}$. The other versions do not stack, e.g., `\\mathsf{\\mathbf{H}}` will produce $\\mathsf{\\mathbf{H}}$.\r\n\r\nIn cases where KaTeX fonts do not have a bold glyph, `\\pmb` can simulate one. For example, `\\pmb{\\mu}` renders as : $\\pmb{\\mu}$\r\n\r\n**Size**\r\n\r\n|||\r\n|:----------------------|:-----\r\n|$\\Huge AB$ `\\Huge AB`  |$\\normalsize AB$ `\\normalsize AB`\r\n|$\\huge AB$ `\\huge AB`  |$\\small AB$ `\\small AB`\r\n|$\\LARGE AB$ `\\LARGE AB`|$\\footnotesize AB$ `\\footnotesize AB`\r\n|$\\Large AB$ `\\Large AB`|$\\scriptsize AB$ `\\scriptsize AB`\r\n|$\\large AB$ `\\large AB`|$\\tiny AB$ `\\tiny AB`\r\n\r\n\r\n**Style**\r\n\r\n||\r\n|:-------------------------------------------------------|\r\n|$\\displaystyle\\sum_{i=1}^n$ `\\displaystyle\\sum_{i=1}^n`\r\n|$\\textstyle\\sum_{i=1}^n$ `\\textstyle\\sum_{i=1}^n`\r\n|$\\scriptstyle x$ `\\scriptstyle x` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(The size of a first sub/superscript)\r\n|$\\scriptscriptstyle x$ `\\scriptscriptstyle x` (The size of subsequent sub/superscripts)\r\n|$\\lim\\limits_x$ `\\lim\\limits_x`\r\n|$\\lim\\nolimits_x$ `\\lim\\nolimits_x`\r\n|$\\verb!x^2!$ `\\verb!x^2!`\r\n\r\n`\\text{…}` will accept nested `$…$` fragments and render them in math mode.\r\n\r\n## Symbols and Punctuation\r\n\r\n||||\r\n|:----------|:----------|:----------|\r\n|`% comment`|$\\dots$ `\\dots`|$\\KaTeX$ `\\KaTeX`\r\n|$\\%$ `\\%`|$\\cdots$ `\\cdots`|$\\LaTeX$ `\\LaTeX`\r\n|$\\#$ `\\#`|$\\ddots$ `\\ddots`|$\\TeX$ `\\TeX`\r\n|$\\&$ `\\&`|$\\ldots$ `\\ldots`|$\\nabla$ `\\nabla`\r\n|$\\_$ `\\_`|$\\vdots$ `\\vdots`|$\\infty$ `\\infty`\r\n|$\\text{\\textunderscore}$ `\\text{\\textunderscore}`|$\\dotsb$ `\\dotsb`|$\\infin$ `\\infin`\r\n|$\\text{--}$ `\\text{--}`|$\\dotsc$ `\\dotsc`|$\\checkmark$ `\\checkmark`\r\n|$\\text{\\textendash}$ `\\text{\\textendash}`|$\\dotsi$ `\\dotsi`|$\\dag$ `\\dag`\r\n|$\\text{---}$ `\\text{---}`|$\\dotsm$ `\\dotsm`|$\\dagger$ `\\dagger`\r\n|$\\text{\\textemdash}$ `\\text{\\textemdash}`|$\\dotso$ `\\dotso`|$\\text{\\textdagger}$ `\\text{\\textdagger}`\r\n|$\\text{\\textasciitilde}$ `\\text{\\textasciitilde}`|$\\sdot$ `\\sdot`|$\\ddag$ `\\ddag`\r\n|$\\text{\\textasciicircum}$ `\\text{\\textasciicircum}`|$\\mathellipsis$ `\\mathellipsis`|$\\ddagger$ `\\ddagger`\r\n|$`$ <code>`</code>|$\\text{\\textellipsis}$ `\\text{\\textellipsis}`|$\\text{\\textdaggerdbl}$ `\\text{\\textdaggerdbl}`\r\n|$\\text{\\textquoteleft}$ `text{\\textquoteleft}`|$\\Box$ `\\Box`|$\\Dagger$ `\\Dagger`\r\n|$\\lq$ `\\lq`|$\\square$ `\\square`|$\\angle$ `\\angle`\r\n|$\\text{\\textquoteright}$ `\\text{\\textquoteright}`|$\\blacksquare$ `\\blacksquare`|$\\measuredangle$ `\\measuredangle`\r\n|$\\rq$ `\\rq`|$\\triangle$ `\\triangle`|$\\sphericalangle$ `\\sphericalangle`\r\n|$\\text{\\textquotedblleft}$ `\\text{\\textquotedblleft}`|$\\triangledown$ `\\triangledown`|$\\top$ `\\top`\r\n|$\"$ `\"`|$\\triangleleft$ `\\triangleleft`|$\\bot$ `\\bot`\r\n|$\\text{\\textquotedblright}$ `\\text{\\textquotedblright}`|$\\triangleright$ `\\triangleright`|$\\$$ `\\$`\r\n|$\\colon$ `\\colon`|$\\bigtriangledown$ `\\bigtriangledown`|$\\text{\\textdollar}$ `\\text{\\textdollar}`\r\n|$\\backprime$ `\\backprime`|$\\bigtriangleup$ `\\bigtriangleup`|$\\pounds$ `\\pounds`\r\n|$\\prime$ `\\prime`|$\\blacktriangle$ `\\blacktriangle`|$\\mathsterling$ `\\mathsterling`\r\n|$\\text{\\textless}$ `\\text{\\textless}`|$\\blacktriangledown$ `\\blacktriangledown`|$\\text{\\textsterling}$ `\\text{\\textsterling}`\r\n|$\\text{\\textgreater}$ `\\text{\\textgreater}`|$\\blacktriangleleft$ `\\blacktriangleleft`|$\\yen$ `\\yen`\r\n|$\\text{\\textbar}$ `\\text{\\textbar}`|$\\blacktriangleright$ `\\blacktriangleright`|$\\surd$ `\\surd`\r\n|$\\text{\\textbardbl}$ `\\text{\\textbardbl}`|$\\diamond$ `\\diamond`|$\\degree$ `\\degree`\r\n|$\\text{\\textbraceleft}$ `\\text{\\textbraceleft}`|$\\Diamond$ `\\Diamond`|$\\text{\\textdegree}$ `\\text{\\textdegree}`\r\n|$\\text{\\textbraceright}$ `\\text{\\textbraceright}`|$\\lozenge$ `\\lozenge`|$\\mho$ `\\mho`\r\n|$\\text{\\textbackslash}$ `\\text{\\textbackslash}`|$\\blacklozenge$ `\\blacklozenge`|$\\diagdown$ `\\diagdown`\r\n|$\\text{\\P}$ `\\text{\\P}` or `\\P`|$\\star$ `\\star`|$\\diagup$ `\\diagup`\r\n|$\\text{\\S}$ `\\text{\\S}` or `\\S`|$\\bigstar$ `\\bigstar`|$\\flat$ `\\flat`\r\n|$\\text{\\sect}$ `\\text{\\sect}`|$\\clubsuit$ `\\clubsuit`|$\\natural$ `\\natural`\r\n|$\\copyright$ `\\copyright`|$\\clubs$ `\\clubs`|$\\sharp$ `\\sharp`\r\n|$\\circledR$ `\\circledR`|$\\diamondsuit$ `\\diamondsuit`|$\\heartsuit$ `\\heartsuit`\r\n|$\\text{\\textregistered}$ `\\text{\\textregistered}`|$\\diamonds$ `\\diamonds`|$\\hearts$ `\\hearts`\r\n|$\\circledS$ `\\circledS`|$\\spadesuit$ `\\spadesuit`|$\\spades$ `\\spades`\r\n|$\\text{\\textcircled a}$ `\\text{\\textcircled a}`|$\\maltese$ `\\maltese`|$\\minuso$ `\\minuso`|\r\n\r\nDirect Input: § ¶ $ £ ¥ ∇ ∞ · ∠ ∡ ∢ ♠ ♡ ♢ ♣ ♭ ♮ ♯ ✓ …  ⋮  ⋯  ⋱  !$ ‼ ⦵\r\n\r\n## Units\r\n\r\nIn KaTeX, units are proportioned as they are in TeX.<br>\r\nKaTeX units are different than CSS units.\r\n\r\n</div>\r\n<div class=\"katex-cards\" id=\"unit-tbl\">\r\n\r\n|  KaTeX Unit | Value       | KaTeX Unit  | Value  |\r\n|:---|:---------------------|:---|:----------------|\r\n| em | CSS em               | bp | 1/72​ inch × F × G|\r\n| ex | CSS ex               | pc | 12 KaTeX pt|\r\n| mu | 1/18 CSS em          | dd | 1238/1157​ KaTeX pt  |\r\n| pt | 1/72.27 inch × F × G | cc | 14856/1157 KaTeX pt |\r\n| mm | 1 mm × F × G         | nd | 685/642 KaTeX pt |\r\n| cm | 1 cm × F × G         | nc | 1370/107​ KaTeX pt|\r\n| in | 1 inch × F × G       | sp | 1/65536 KaTeX pt |\r\n\r\n</div>\r\n\r\nwhere:\r\n\r\n<div style=\"margin-left: 1.5em;\">\r\n\r\nF = (font size of surrounding HTML text)/(10 pt)\r\n\r\nG = 1.21 by default, because KaTeX font-size is normally 1.21 × the surrounding font size. This value [can be overridden](font.md#font-size-and-lengths) by the CSS of an HTML page.\r\n\r\n</div>\r\n\r\nThe effect of style and size:\r\n\r\n<div class=\"katex-cards\" id=\"unit-blocks\">\r\n\r\n|  Unit  |     textstyle     | scriptscript |  huge  |\r\n|:------:|:-----------------:|:------------:|:------:|\r\n|em or ex|$\\rule{1em}{1em}$  |$\\scriptscriptstyle\\rule{1em}{1em}$  |$\\huge\\rule{1em}{1em}$\r\n| mu     |$\\rule{18mu}{18mu}$|$\\scriptscriptstyle\\rule{18mu}{18mu}$|$\\huge\\rule{18mu}{18mu}$\r\n| others |$\\rule{10pt}{10pt}$|$\\scriptscriptstyle\\rule{10pt}{10pt}$|$\\huge\\rule{10pt}{10pt}$\r\n\r\n</div>\r\n\r\n"},{"shortInfo":{"title":"LESS层叠样式预处理语言","date":"2022-06-21T00:46:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["LESS","CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":3074230429,"countWords":683,"readSeconds":68.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# LESS层叠样式预处理语言\r\n## 目录\r\n- [LESS层叠样式预处理语言](#less层叠样式预处理语言)\r\n  - [目录](#目录)\r\n  - [概述](#概述)\r\n  - [注释](#注释)\r\n  - [运算语法](#运算语法)\r\n  - [选择器嵌套语法](#选择器嵌套语法)\r\n  - [变量](#变量)\r\n  - [导入](#导入)\r\n  - [导出位置修改](#导出位置修改)\r\n    - [修改方法1](#修改方法1)\r\n    - [修改方法2](#修改方法2)\r\n  - [禁止导出](#禁止导出)\r\n\r\n## 概述\r\n* less是一个**css的预处理器**\r\n* less文件后缀是.less\r\n* 优点：\r\n    * 它扩充了 CSS 语言，\r\n    * 增加了诸如变量、混合（mixin）、函数等功能，\r\n    * 让 CSS 更易维护,简化了 CSS 的编写\r\n\r\n* vscode插件EasyLESS\r\n    * 可以在保存的时候自动编译生成同名的.css文件\r\n\r\n## 注释\r\n* 单行注释：`//注释内容`\r\n* 多行注释：`/* 注释内容 */` 多行注释会同步生成到css文件中\r\n\r\n## 运算语法\r\n* 加`+`\r\n* 减`-`\r\n* 乘`*` \r\n* 除法需要添加`(小括号)`或`.`\r\n    * `(1/1)`\r\n    * `1./1`\r\n    ```less\r\n    div{\r\n        // 加\r\n        height:10+10px;\r\n        // 减\r\n        height:10-10px;\r\n        // 乘\r\n        height:10*10px;\r\n        // 除\r\n        height:(10/10px);\r\n        height:10./10px;\r\n    }\r\n    ```\r\n* 注意：less4.0之前可以直接写`1 / 1`\r\n\r\n## 选择器嵌套语法\r\n* css后代选择器的写法比较冗长，但为了保证其选择器的权重又不得不这样写\r\n* less嵌套写法可以快速生成css语法的后代选择器\r\n* 语法格式\r\n    ```less\r\n    父选择器{\r\n        // 父级样式\r\n        子选择器{\r\n            // 子级样式\r\n        }\r\n    }\r\n    ```\r\n* 示例写法\r\n    ```less\r\n    .father{\r\n        width:100px;\r\n        .son{\r\n            width:50px;\r\n        }\r\n    }\r\n    ```\r\n* 生成css代码\r\n    ```css\r\n    .father{\r\n        width:100px;\r\n    }\r\n    .father .son{\r\n            width:50px;\r\n        }\r\n    ```\r\n* 注意： **`&`表示当前选择器，通常配合伪元素或伪类使用**\r\n    ```less\r\n    .father{\r\n        width:100px;\r\n        .son{\r\n            width:50px;\r\n        }\r\n        &:hover{\r\n            width:60px;\r\n        }\r\n    }\r\n    ```\r\n\r\n## 变量\r\n* 定义变量：`@变量名:值;`\r\n* 使用示例：\r\n    ```less\r\n    @bgcolor:#333;\r\n    div{\r\n        background-color:@bgcolor;\r\n    }\r\n    ```\r\n\r\n## 导入\r\n* 语法格式：`@import \"path/to/fileName.less\";`\r\n* 省略后缀：`@import \"path/to/fileName\";`\r\n* 注意: import之后后**一定**要有空格\r\n* 和c语言include含义类似，实际上就是把另一个文件的内容复制到该位置\r\n\r\n## 导出位置修改\r\n* 默认生成的css文件导出在当前文件所在位置\r\n* 一般less可以写在网站根目录的less文件夹\r\n* 导出的文件目录在网站根目录的css文件夹\r\n\r\n### 修改方法1\r\n配置vscode的easyLess插件\r\n\r\n* 注意：\r\n    * `*/css/`表示存放在`css`**文件夹** \r\n    * `*/css`表示存放为一个名为`css`的**文件**\r\n\r\nsetting.json\r\n```json\r\n{\r\n    \"less.compile\":{\r\n        \"out\":\"../css/\"\r\n    }\r\n}\r\n```\r\n\r\n### 修改方法2\r\n控制单个文件的导出路径\r\n\r\n* 语法：\r\n    * **写在第一行:**\r\n    * `//out: ./out/`\r\n\r\n## 禁止导出\r\n* 对于`base.less`、`common.less`等类似的公共样式文件，可以禁止其导出为css文件\r\n* 语法：`//out: false`\r\n* 如要调用这些被禁止导出的样式，可以使用`@import`导入"},{"shortInfo":{"layout":"post","title":"Linux备忘笔记","date":"2022-01-09T12:28:00.000Z","cover":"\\self_server\\assets\\images\\linux2.webp","tags":["笔记","Linux"],"hideAtIndex":true,"categories":"笔记","id":4117620536,"countWords":956,"readSeconds":95.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# linux备忘笔记\r\n\r\n\r\n\r\n## 删除已设置生效的root密码\r\n```bash\r\n# 删除root:x: 中的x密码占位符号\r\nvim /etc/passwd\r\n# 删除root:xxxxxxxxxx: 中的xxxxxxxxxxxxxxxxxx加密后的密码，改为*\r\nvim /etc/shadow\r\n\r\n# 没有权限则重启进入拯救模式\r\n```\r\n\r\n## 用户管理\r\n**usermod**\r\n```bash\r\n# usermod 可选项：\r\n#     -d <登入目录>     修改用户登入时的目录。\r\n#     -g <群组>         修改用户所属的群组。\r\n#     -G <群组>         修改用户所属的附加群组。\r\n#     -l <帐号名称>     修改用户帐号名称(新账号在前，旧账号在后)\r\n#     -L                锁定用户密码，使密码无效。\r\n#     -s <shell>        修改用户登入后所使用的shell。\r\n#     -u <uid>          修改用户ID。\r\n#     -U                解除密码锁定。\r\n```\r\n\r\n\r\n## 权限管理\r\n**查看用户组的成员**\r\n```bash\r\nvi /etc/group\r\n```\r\n\r\n\r\n\r\n\r\n## 常用命令\r\n* 查看所有运行的任务和pid\r\n    + ps aux \r\n    + a 显示现行终端机下的所有程序，包括其他用户的程序。\r\n    + u 以用户为主的格式来显示程序状况。\r\n    + x 显示所有程序，不以终端机来区分。\r\n* 查看端口监听情况\r\n    + 软件包名：net-tools\r\n    + netstat -tunlp\r\n    + -a 全部\r\n    + -c或--continuous：持续列出网络状态；\r\n    + -l或--listening：显示监控中的服务器的Socket；\r\n    + -u或--udp：显示UDP传输协议的连线状况；\r\n    + -t或--tcp：显示TCP传输协议的连线状况；\r\n    + -n或--numeric：直接使用ip地址，而不通过域名服务器；\r\n    + -p或--programs：显示正在使用Socket的程序识别码和程序名称；\r\n\r\n* ctrl + z 将一个正在前台执行的命令放到后台，并且暂停\r\n*  jobs 查看当前有多少在后台运行的命令\r\n    + 无参数 查看当前作业\r\n    + -l 列出进程的PID和作业号\r\n    + -p 只列出作业的PID\r\n    + -s 只列出停止的作业\r\n    + -r 只列出运行的作业\r\n* fg 将后台中的命令调至前台继续运行\r\n* bg 将一个在后台暂停的命令，变成继续执行\r\n* commend & 后台执行一个程序\r\n* linux命令后台运行.两种方式：\r\n    * command & ： 后台运行，你关掉终端会停止运行\r\n    * nohup command & ： 后台运行，你关掉终端也会继续运行\r\n\r\n### 偶尔会忘的操作\r\n* 将普通用户加入wheel组使其获得sudo权限\r\n   * useradd dyg -G wheel 或者\r\n   * usermod dyg -G wheel\r\n* 递归更改文件夹属组\r\n   * chmod -R dyg:dyg 文件名\r\n\r\n\r\n## 软件安装升级\r\n1. 安装c++编译器\r\n    * yum install gcc gcc-c++ \r\n2. 安装make\r\n    * yum install make\r\n3. 安装nodejs \r\n    * yum install nodejs\r\n4. 安装指定版本的nodejs \r\n    1. 官网找到下载链接后\r\n        * wget https://npmmirror.com/mirrors/node/v16.13.1/node-v16.13.1-linux-x64.tar.xz\r\n    2. 解压 【v显示解压过程，x解压，f指定解压文件，z解压后缀为gz的压缩包】\r\n       * tar vxf node-v16.13.1-linux-x64.tar.xz\r\n       * tar vxfz node-v16.13.1-linux-x64.tar.gz  \r\n    3. 创建软连接；【-s表示soft 软】\r\n        * ln -s /home/用户名/node-v16.13.1-linux-x64/bin/node /usr/local/bin/\r\n        * ln -s /home/用户名/node-v16.13.1-linux-x64/bin/npm /usr/local/bin/\r\n5. CentOS8完美升级gcc版本方法\r\n   1. 安装gcc-toolset-10\r\n\t    * dnf install gcc-toolset-10\r\n   2. 激活gcc版本，使其生效\r\n      \t* scl enable gcc-toolset-10 bash 或\r\n      \t* source /opt/rh/gcc-toolset-10/enable\r\n   3. 此时通过gcc --version命令可以看到，gcc版本已经变成10.x.x，\r\n        ```\r\n        值得注意的是这仅仅在当前bash生效，\r\n        如果需要永久生效，可以请自行添加环境变量。\r\n        仅适用于CentOS8、Redhat8版本\r\n        在CentOS8版本中，红帽也提供了开发工具包管理gcc版本，\r\n        install的包名从devtoolset-x变成了gcc-toolset-x，\r\n        通过该方式升级gcc好处就是随时可以切换gcc版本，不破坏原有gcc环境。\r\n        gcc-toolset-9对应gcc9.x.x版本\r\n        gcc-toolset-10对应gcc10.x.x版本\r\n        ```\r\n"},{"shortInfo":{"layout":"post","title":"miniconda备忘笔记","date":"2022-01-29T05:52:00.000Z","cover":"\\self_server\\assets\\images\\conda.png","tags":["笔记","miniconda"],"hideAtIndex":true,"categories":"笔记","id":3867233914,"countWords":323,"readSeconds":32.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# miniconda命令备忘笔记\r\n* miniconda和anaconda中都包含了conda。\r\n* conda是一款软件管理软件，相当于windows里面的应用商店。\r\n* miniconda 安装包大小约为51.4 Mb，包含conda、python\r\n* anaconda 安装包大小约为462 Mb，包含了数据科学和机器学习要用到的很多软件。\r\n\r\n## 安装Miniconda\r\n* win10安装方法\r\n    + 官网下载安装包安装\r\n    + 配置环境\r\n        + 自动配置环境(初始化终端Shell 以便往后可以直接运行conda命令)\r\n            + `/Miniconda3安装目录/Miniconda3/Scripts/conda init [shellName]`\r\n        - gitShell手动配置环境\r\n            + 在git安装目录中的etc/profile 添加如下代码\r\n            + `export PATH=\"$PATH:/Miniconda3安装目录/Miniconda3/Scripts/\"`\r\n        - powerShell手动配置环境\r\n            + 添加系统环境变量\r\n            + PATH:`/Miniconda3安装目录/Miniconda3/Scripts/`\r\n\r\n## 创建并激活环境\r\n* 重启shell\r\n* 创建一个名为d2l的环境 `conda create --name d2l python=3.8 -y`\r\n* 查看现有环境 `conda env list`\r\n* 激活 d2l 环境`conda activate d2l`\r\n## 环境\r\n* 创建环境\r\n    + conda create [--name|-n] 环境名\r\n* 列出环境\r\n    + conda env list\r\n* 删除环境\r\n    + conda env remove --name 环境名\r\n* 激活环境\r\n    + conda activate 环境名\r\n\r\n## 软件\r\n* 安装软件包\r\n    + conda install package_name\r\n* 切换默认channel安装软件包\r\n    + conda install -c channel_name package_name\r\n\r\n## 源\r\n* 恢复默认配置（删除家目录的配置文件）\r\n    + rm ~/.condarc\r\n\r\n"},{"shortInfo":{"title":"mkcert生成自签https证书过程记录","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-08-22T14:45:00.000Z","tags":["mkcert","自签","https","证书"],"hideAtIndex":true,"categories":"笔记","id":254158045,"countWords":1063,"readSeconds":106.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# mkcert生成自签https证书过程记录\r\n## 目录\r\n- ](#mkcert生成自签https证书过程记录)\r\n  - ](#目录)\r\n  - ](#相关概念)\r\n  - ](#安装mkcert)\r\n  - ](#生成用户证书)\r\n  - ](#安装颁发者证书)\r\n    - ](#在pc端安装)\r\n    - ](#在ios端安装)\r\n\r\n## 相关概念\r\n* **数字证书认证机构（CA），**\r\n  * 是负责发放和管理数字证书的权威机构，\r\n  * 负责签发证书、认证证书、管理已颁发证书\r\n  * CA 也拥有用户的证书（内含公钥）和私钥。\r\n  * 任何人都可以得到 CA 的证书（含公钥），用以验证 CA 所签发的证书。\r\n* **用户证书**\r\n  * 用户若欲获取证书，应先向 CA 提出申请，CA 判明申请者的身份后，为之分配一个公钥，并将该公钥与其身份信息绑定，为该整体签名，签名后的整体即为证书，发还给申请者。\r\n* **鉴别用户证书的真伪**\r\n  * 一个用户想鉴别另一个用户的证书的真伪，用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。\r\n\r\n\r\n\r\n## 安装mkcert\r\n**安装mkcert工具**\r\n```bash\r\nsudo apt-get install mkcert\r\n```\r\n\r\n\r\n## 生成用户证书\r\n**生成证书:`cert.crt` 和 私钥:`cert-key.key`**\r\n```bash\r\nmkcert -cert-file ~/.ssl/cert.crt -key-file ~/.ssl/cert-key.key cn-zz-bgp-2.natfrp.cloud 43.249.193.55 localhost 127.0.0.1 ::1\r\n\r\n# 输出结果:\r\n# Created a new local CA 💥\r\n# Note: the local CA is not installed in the system trust store.\r\n# Note: the local CA is not installed in the Firefox and/or Chrome/Chromium trust store.\r\n# Run \"mkcert -install\" for certificates to be trusted automatically ⚠️\r\n# \r\n# Created a new certificate valid for the following names 📜\r\n#  - \"cn-zz-bgp-2.natfrp.cloud\"\r\n#  - \"43.249.193.55\"\r\n#  - \"localhost\"\r\n#  - \"127.0.0.1\"\r\n#  - \"::1\"\r\n# \r\n# The certificate is at \"~/.ssl/cert.crt\" and the key at \"~/.ssl/cert-key.key\" ✅\r\n# \r\n# It will expire on 22 November 2024 🗓\r\n# \r\n# \r\n```\r\n\r\n**配置服务器安装用户证书(以code-server为例)**\r\n```bash\r\n# vi ~/.config/code-server/config.yaml\r\n# code-server的配置文件:\r\nbind-addr: 0.0.0.0:8080\r\nauth: password\r\npassword: ???????????????????????\r\n# cert 为刚刚生成的证书\r\ncert: /home/userName/.ssl/cert.crt\r\n# cert-key 为刚刚生成的私钥\r\ncert-key: /home/userName/.ssl/cert-key.key\r\n```\r\n\r\n**此时访问localhost将依然报错,因为没有为浏览器安装颁发者的证书**\r\n\r\n![](./images/mkcert生成自签https证书过程记录/98e2d9d7e5fd0ced7043c50a28be71243a50b4830341e38753308ed6f96eac4f.png)  \r\n\r\n## 安装颁发者证书\r\n\r\n### 在PC端安装\r\n**方法1:使用命令将颁发者mkcert机构证书添加到系统信任,同时安装到本机的火狐浏览器和谷歌浏览器**\r\n```bash\r\nmkcert -install\r\n\r\n# 输出结果:\r\n# \r\n# The local CA is now installed in the system trust store! \r\n# 翻译:本地证书已经添加到到系统信任仓库\r\n# Warning: \"certutil\" is not available, so the CA can't be automatically installed in Firefox and/or Chrome/Chromium! ⚠️\r\n# 翻译:certutil(证书工具)不可用,所以证书无法自动安装到本机的浏览器\r\n# Install \"certutil\" with \"apt install libnss3-tools\" and re-run \"mkcert -install\" 👈\r\n# 翻译: 执行 \"apt install libnss3-tools\"来安装\"certutil\",然后 重新执行 \"mkcert -install\"\r\n\r\n# 安装libnss3-tools\r\napt install libnss3-tools\r\n# 重新执行 \"mkcert -install\"\r\nmkcert -install\r\n```\r\n\r\n**此时浏览器就能正常访问了**\r\n\r\n![](./images/mkcert生成自签https证书过程记录/ea42bffa2f50e7090b52dced9381273fb9276f334a863d6e8c1cda6b3030a98e.png)  \r\n\r\n\r\n\r\n**方法2:手动将颁发者mkcert机构证书手动添加到客户端的浏览器**\r\n**查看 CA 证书的存放位置**\r\n```bash\r\nmkcert -CAROOT\r\n# 输出结果:\r\n# /root/.local/share/mkcert\r\n\r\ntree $(mkcert -CAROOT)\r\n# 输出结果: \r\n# /home/dyg/.local/share/mkcert\r\n# ├── rootCA-key.pem 颁发者机构的私钥\r\n# └── rootCA.pem 颁发者机构的证书\r\n```\r\n\r\n**然后将上述颁发者mkcert机构证书文件`rootCA.pem`手动添加到pc端的浏览器中**\r\n\r\n![](./images/mkcert生成自签https证书过程记录/d54fd4c159d8f58627c6ec16a28ced8b2f47fd3a1b7d57dedd94031a6c68c6d3.png)  \r\n\r\n\r\n### 在IOS端安装\r\n\r\n**将颁发者mkcert机构证书手动添加到**\r\n\r\n**安装前**\r\n![](./images/mkcert生成自签https证书过程记录/6c7400885884577a2b676133ffe162ed3485dea02996e03b7c9c9ef45c307f7d.png)  \r\n\r\n![](./images/mkcert生成自签https证书过程记录/c0eb4ee022cca679c29669fd4cd0171fb124ccacec29670bb9dcdca59d46176c.png)  \r\n\r\n\r\n**安装中**\r\n![](./images/mkcert生成自签https证书过程记录/273368cf71de2ec25d2f2db736245f692c0a4d209a18a8c7d8f2bb9c64d0c1ec.png)  \r\n![](./images/mkcert生成自签https证书过程记录/816173bb4129ce92bbb68192a9f57d0218df7d1f3fb78ba2f6e0ce90a37f858d.png)  \r\n![](./images/mkcert生成自签https证书过程记录/8146b3f22175a2139a6edd516eabedd020c7d394772057d918fba0c2d00ed3fc.png)  \r\n![](./images/mkcert生成自签https证书过程记录/3a54b606903275febc7a5e9d03f031bab96c4e1aa09b64e986b5b405a5581d48.png)  \r\n![](./images/mkcert生成自签https证书过程记录/379bb20613e6ebf812129a2ce13ca9a14eef295f69cdc41ecb5b40a9f45346bc.png)  \r\n![](./images/mkcert生成自签https证书过程记录/df4be11a914591cdeb1327c453b4d988bca8de2ce1deb45ab89f4015e821527e.png)  \r\n\r\n\r\n\r\n\r\n**安装后**\r\n![](./images/mkcert生成自签https证书过程记录/6e926867c2eb90dbcebe8911a7863ea099f4bc6c2230fafb7a94982fd8d4e4cd.png)  \r\n\r\n![](./images/mkcert生成自签https证书过程记录/b67d7716a9270e7e723ba322faa4293cf706c1e35d8b7969ee5356446923b6e7.png)  \r\n"},{"shortInfo":{"layout":"post","title":"MySql笔记","date":"2022-05-26T20:50:00.000Z","cover":"\\self_server\\assets\\images\\MySql.webp","tags":["笔记","MySql"],"hideAtIndex":true,"categories":"笔记","id":522944827,"countWords":131,"readSeconds":13.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# mySql笔记\r\n\r\n\r\n## mySql8.0\r\n* 列出所有数据库:show databases;\r\n* 清空MySQL——root密码\r\n    1. 停止 MySQL 任务 net stop MySQL\r\n    1. mysqld 命令 mysqld --console --skip-grant-tables --shared-memory\r\n    1. 无密码进入mysql mysql -u root\r\n    1. 清空root 密码 UPDATE user SET authentication_string=\"\" WHERE user='root';\r\n    2. 重新载入授权表。FLUSH PRIVILEGES;\r\n        * 如果你不使用该命令，你就无法使用新创建的用户来连接mysql服务器，除非你重启mysql服务器。\r\n* 修改用户密码\r\n  1. use mysql;\r\n  4. alter user root@localhost identified by '密码';\r\n  5. FLUSH PRIVILEGES;\r\n\r\n"},{"shortInfo":{"layout":"post","title":"nexmoe主题文章底部UTF-8链接转中文","date":"2022-02-23T13:46:00.000Z","cover":"\\self_server\\assets\\images\\nexmoe主题文章底部UTF-8链接转中文.png","tags":["笔记","nexmoe"],"hideAtIndex":true,"categories":"前端","id":927140103,"countWords":191,"readSeconds":19.1,"assetsbaseUrl":"/self_server/assets/"},"content":"## 原代码\r\n```\r\n<% if (page.hide_copyright !== true && theme.copyright || page.copyright) { %>\r\n    <div class=\"nexmoe-post-copyright\">\r\n        <strong><%- __('copyright.author') %>：</strong><%= config.author %><br>\r\n        <strong><%- __('copyright.permalink') %>：</strong>\r\n        <%- link_to(page.permalink, page.permalink, {external: true}) %><br>\r\n        <% if (page.copyright) { %>\r\n            <%- page.copyright %>\r\n        <% } else { %>\r\n            <%- theme.copyright %>\r\n        <% } %>\r\n    </div>\r\n<% } %>\r\n```\r\n\r\n## 修改后\r\n```\r\n<% if (page.hide_copyright !== true && theme.copyright || page.copyright) { %>\r\n    \r\n    <script type=\"text/javascript\">\r\n        var decodePageURI = decodeURI(\"<%- page.permalink %>\")\r\n        timer = null\r\n        timer=setInterval(function(){\r\n            do\r\n            {\r\n                document.getElementById(\"page_address\").href=decodePageURI\r\n                document.getElementById(\"page_address\").title=decodePageURI\r\n                document.getElementById(\"page_address\").innerHTML=decodePageURI\r\n            }while(document.getElementById(\"page_address\").innerHTML!=decodePageURI)\r\n            clearInterval(timer)\r\n        },\r\n        100\r\n        )\r\n    </script>\r\n\r\n    <div class=\"nexmoe-post-copyright\">\r\n        <strong><%- __('copyright.author') %>：</strong><%= config.author %><br>\r\n        <strong><%- __('copyright.permalink') %>：</strong>\r\n        <!-- <%- link_to(page.permalink, page.permalink, {external: true}) %><br> -->\r\n        <a id=\"page_address\" href=\"\" title=\"\" target=\"_blank\" rel=\"noopener\"></a><br>\r\n        <% if (page.copyright) { %>\r\n            <%- page.copyright %>\r\n        <% } else { %>\r\n            <%- theme.copyright %>\r\n        <% } %>\r\n    </div>\r\n<% } %>\r\n```\r\n## 效果\r\n修改后效果为能根据page.permalink内容展示UTF-8解码后的中文URL\r\n{% gallery %}\r\n![修改前](../images/修改前.png)\r\n![修改后](../images/修改后.png)\r\n{% endgallery %}\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n\r\n"},{"shortInfo":{"title":"nginx实现反向代理并启用ssl的最简配置","date":"2022-08-23T09:36:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["nginx","反向代理"],"hideAtIndex":true,"categories":"笔记","id":13752478,"countWords":159,"readSeconds":15.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# nginx实现反向代理并启用ssl的最简配置\r\n\r\n```confg\r\nserver {\r\n    listen       8082; \r\n    server_name  localhost;\r\n\r\n    #启用ssl\r\n    ssl on;\r\n    #ssl证书\r\n    ssl_certificate  /home/dyg/.ssl/cert.crt;\r\n    #ssl证书私钥\r\n    ssl_certificate_key /home/dyg/.ssl/cert-key.key;\r\n\r\n    location / {\r\n        #反向代理\r\n        proxy_pass http://localhost:8081;\r\n        #默认页面\r\n        index  index.html index.htm;\r\n    }\r\n}\r\n```\r\n\r\n# 将http请求转成https\r\n**案例:将http:80请求转成https:443**\r\n**仅适用于默认端口**\r\n```confg\r\nserver {\r\n    listen       443; \r\n    server_name  localhost;\r\n\r\n    #启用ssl\r\n    ssl on;\r\n    #ssl证书\r\n    ssl_certificate  /home/dyg/.ssl/cert.crt;\r\n    #ssl证书私钥\r\n    ssl_certificate_key /home/dyg/.ssl/cert-key.key;\r\n\r\n    location / {\r\n        #反向代理\r\n        proxy_pass http://localhost:8081;\r\n        #默认页面\r\n        index  index.html index.htm;\r\n    }\r\n}\r\nserver {\r\n    listen 80;\r\n    server_name localhost;\r\n    #将http请求转成https\r\n    rewrite ^(.*)$ https://$host$1 permanent;\r\n}\r\n```"},{"shortInfo":{"layout":"post","title":"nodejs-npm备忘笔记","date":"2022-01-09T12:28:00.000Z","cover":"\\self_server\\assets\\images\\nodejs2.webp","tags":["笔记","nodejs","npm"],"hideAtIndex":true,"categories":"笔记","id":1393906809,"countWords":168,"readSeconds":16.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# nodejs-npm备忘笔记\r\n\r\n## npm工具的使用\r\n\r\n### npm 镜像源的设置和删除\r\n1. npm查看源：\r\n    * npm config get registry 或\r\n    * npm config list\r\n\r\n2. 设置成淘宝源:\r\n    * npm config set registry https://registry.npm.taobao.org/\r\n\r\n3. 设置成npm官方源:\r\n    * npm config set registry https://registry.npmjs.org/\r\n\r\n4. npm删除源\r\n   * npm config rm registry\r\n\r\n### npm 安装模块\r\n1. 安装给当前目录的项目：\r\n   * npm install [模块名]\r\n2. 安装到全局：\r\n   * npm install -g [模块名]\r\n3. 查看当前项目已安装的模块\r\n    * npm list\r\n4. 查看全局已安装的模块\r\n    * npm list -g\r\n5. 卸载【uninstall】已安装的模块 更新【update】 搜索【search】 \r\n    * npm uninstall  XXX\r\n    * npm uninstall  XXX -g\r\n6. 运行node\r\n    * npm run test"},{"shortInfo":{"title":"nodejs学习笔记","date":"2022-08-28T13:13:00.000Z","cover":"\\self_server\\assets\\images\\nodejs学习笔记\\2022-12-04-01-24-17.png","tags":["nodejs"],"categories":"后端","id":3751424862,"countWords":3031,"readSeconds":303.1,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/nodejs学习笔记/2022-12-04-01-24-17.png) -->\r\n\r\n\r\n# nodejs学习笔记\r\n## 目录\r\n- [nodejs学习笔记](#nodejs学习笔记)\r\n  - [目录](#目录)\r\n  - [基本概念](#基本概念)\r\n  - [模块](#模块)\r\n    - [概念](#概念)\r\n    - [通过`module.exports`实现模块化](#通过moduleexports实现模块化)\r\n    - [npm包管理工具](#npm包管理工具)\r\n  - [内置模块](#内置模块)\r\n    - [fs模块](#fs模块)\r\n    - [path路径模块](#path路径模块)\r\n    - [http模块](#http模块)\r\n  - [尝试自定义模块](#尝试自定义模块)\r\n  - [第三方模块](#第三方模块)\r\n    - [moment.js 三方模块](#momentjs-三方模块)\r\n    - [i5ting\\_toc 第三方模块](#i5ting_toc-第三方模块)\r\n    - [express模块](#express模块)\r\n\r\n\r\n## 基本概念\r\n* <red>**Nodejs是基于ChromeV8的js解析引擎**</red>\r\n* **js解析引擎**\r\n    * Chrome 浏览器 -> V8 **性能最好**\r\n    * Firefox 浏览器 ->   OdinMonkey 奥丁猴\r\n    * Safri 浏览器 -> JSCore\r\n    * IE 浏览器 -> Chakra查克拉\r\n* **运行环境区别**\r\n    * **Nodejs**是js的**后端**运行环境,能调用**nodejs的内置API**\r\n    * **浏览器**是js的**前端**运行环境,能调用**浏览器的内置API**\r\n    * ![图 3](./images/nodejs学习笔记/afb25ede4b5e464b04d2e39ded97f116b68c751c3bb781cd329d73e78c10ca58.png)  \r\n    * ![图 2](./images/nodejs学习笔记/7aa213781d4b45aa5495200255be62941fb36990715cf6fc70c800ca6d6ee2dd.png)  \r\n* **nodejs用途**\r\n  * 基于 **Express** 框架,可快速构建 **Web应用**\r\n  * 基于 **Express** 框架,可快速构建 **跨平台桌面应用**\r\n  * 基于 **restify** 框架,可快速构建 **API接口项目**\r\n  * 读写和操作数据库;创建实用的命令行辅助前端开发;......\r\n* 学习路径\r\n  * js基础语法\r\n  * nodejs内置API\r\n  * 第三方API:express mysql\r\n\r\n\r\n## 模块\r\n\r\n### 概念\r\n**模块的分类**\r\n* 内置模块\r\n* 第三方模块\r\n* 自定义模块\r\n\r\n**CommonJS模块化规范**\r\n* 一个 `.js` 文件就是一个模块,每个模块内部的 **module变量** 代表 **当前模块**\r\n* `module` 变量是一个 **对象** ,其 exports属性 是 对外的接口\r\n* 使用 `require()` 加载模块时,就是在加载 `module.exports` 属性\r\n\r\n>注意: 现已新增 **exports 变量** ,其默认指向`module.exports`所指向的对象,能够被覆盖,即当:`exports={}`时, `exports`便不再指向`module.exports`所指向的对象.\r\n\r\n**模块的加载机制**\r\n> 注意: 使用`require()`引入模块 `XXX.js` 时,会执行 `XXX.js` 中的代码  \r\n> 但模块在第一次引入后会被缓存,后续再次引入不会执行其中代码\r\n* 引入**内置模块**\r\n    ```js\r\n    const fs = require(fs)\r\n    ```\r\n    > 内置模块的优先级最高,即使`./node_modules/`下有`./fs/` 同名模块文件,也会优先加载内置模块\r\n* 引入**第三方模块**\r\n    ```js\r\n    const app = require(express)\r\n    ```\r\n    > 先到当前目录的`./node_modules/`查找模块,若没有则进入到上一级目录的`../node_modules/`,直到文件系统的根目录`/node_modules/`\r\n* 引入**自定义模块**\r\n    ```js\r\n    // 可以省略.js后缀\r\n    const demo1 = require(./demo/demo1.js)\r\n    const demo/demo1 = require(./demo/demo1)\r\n\r\n    // 若/demo2/目录下有package.json文件 则会从main属性找到模块的入口\r\n    const demo2 = require(./demo/demo2/demo2.js)\r\n    const demo2 = require(./demo/demo2)\r\n    ```\r\n    > 注意:引入**自定义模块**时必须使用`./`或`../`的相对路径,可以省略 `.js` 的文件名,  \r\n    > **require会自动按一下顺序补全后缀名**\r\n    > * 不补全\r\n    > * 补全`.js`\r\n    > * 补全`.json`\r\n    > * 补全`.node`\r\n    > * 任然无法定位文件则报错\r\n* **自定义模块:引入目录**\r\n    ```js\r\n    const demo2 = require(./demo/demo2)\r\n    ```\r\n    > 若引入的是一个目录,则有三种情况\r\n    > * 优先在查找**被引入目录**下的`package.json`的`main`属性所指向的文件\r\n    > * 若失败则查找**被引入目录**下的`index.js`文件\r\n    > * 若仍然无法找到,则报错\r\n\r\n\r\n### 通过`module.exports`实现模块化\r\n**使用示例**\r\n```js\r\n// demo1.js\r\nmodule.exports.name = \"DingYigui\"\r\nmodule.exports.sayHi = function(){\r\n    console.log(\"Hi\")\r\n}\r\n```\r\n```js\r\n// demo2.js\r\nconst demo1 = require(\"./demo1\")\r\ndemo1.sayHi();\r\n```\r\n\r\n\r\n### npm包管理工具\r\n\r\n**包的分类**\r\n* 项目包 存放在`./node_modules/`\r\n* 全局包 只有工具性质的包才有安装到全局的必要,因为其提供了终端命令工具\r\n\r\n**包的规范结构**\r\n* 包必须以单独的目录存在\r\n* 包的根目录下必须包含`package.js`\r\n* `package.js`必须包含 `name` `version` `main` 三个属性,其中main表示包的入口\r\n    > 通过`require(express)`引入包的过程: `./node_modules/express/package.js` -> `main` -> `./express.js` -> `module.exports`\r\n\r\n**使用npm安装第三方包后多出的文件夹和文件**\r\n* `node_modules/` 存放以安装的包, **require** 的搜索路径\r\n* `package-lock.json` 记录 **node_modules** 目录下每一个包的下载信息,包名,版本,下载地址.\r\n> 不要手动修改`node_modules/`和`package-lock.json`中的内容\r\n\r\n\r\n**包管理配置文件package.js**\r\n* 记录项目名称,版本,描述等\r\n* 记录项目中用到的其他包\r\n* 记录仅在开发期间用到的包\r\n* 记录仅在开发和部署期间用到的包\r\n> 该文件可通过`npm init -y` 命令生成  \r\n> 该文件中的 `dependencies` 项 会在执行 `npm install/uninstall packageName` 后更新  \r\n> 若省略包名,即执行 `npm install` 则会安装 `package.js` 中 `dependencies` 节点所记录的**所有包**\r\n\r\n**npm命令**\r\n* `npm init -y` 初始化当前项目\r\n* `npm install/uninstall pkgName` 安装/卸载包名\r\n* `npm install/uninstall pkgName@1.0.0` 安装/卸载包名\r\n  * `-g` 执行全局的操作\r\n  * `-D` `--save-dev` 所安装的包仅开发过程中使用到,记录到 `devDependencise` 节点中\r\n* `npm config set registry=https://registry.npmmirror.com/` 换源\r\n* `npm config get registry` 查看源设置情况\r\n* `npm login` 登陆npm帐号\r\n* `npm publish` 发布当前包\r\n* `npm unpublish  包名 --force` 删除发布的包\r\n  * 只能删除72小时以内发布的包\r\n  * 不能重新发布24小时内删除的包\r\n\r\n\r\n**版本号规范X.X.X**\r\n* 第一位数字 大版本,从底层重构\r\n* 第二位数字 功能版本,添加了新功能\r\n* 第三位数字 Bug修复版本,修复了Bug \r\n> 版本号提升规则: 某一位数字提升,该位之后的所有位归零\r\n\r\n\r\n\r\n**搜索包的官网**<br>\r\n搜索包:[npmjs.com](npmjs.com) <br>\r\n下载包:[registry.npmjs.org](registry.npmjs.org)\r\n\r\n\r\n**nrm工具**\r\n* 安装: `npm install nrm -g`\r\n* 查看可用镜像 nrm ls\r\n* 切换镜像 nrm use taobao\r\n\r\n\r\n\r\n\r\n\r\n## 内置模块\r\n\r\n\r\n### fs模块\r\n* `fs.readFile(path[,options],callback(err,data))` 读取指定文件,options默认为`utf-8`\r\n* `fs.writeFile(path,data[,options],callback(err))` 写入指定文件,options默认为`utf-8`\r\n  * 注意该函数只能创建文件不能创建文件夹\r\n  * 重复调用会覆盖上一次写入文件的内容\r\n\r\n**简单案例**\r\n```js\r\nconst fs = require(\"fs\")\r\n\r\nfs.readFile(\"./1.fs.js\",\"utf-8\",(err,data)=>{\r\n    if (err) {\r\n        console.log(err);\r\n    }else{\r\n        console.log(data);\r\n    }\r\n})\r\n\r\nfs.writeFile(\"./1.readfile.js\",\"这是写入的数据\",err=>{\r\n    if (err) {\r\n        console.log(err);\r\n    }\r\n})\r\n```\r\n\r\n**实际案例:数据格式化**\r\n```js\r\n/*\r\n将原数据:\r\n语文=100 数学=100 英语=100\r\n转换为: \r\n语文:100\r\n数学:100\r\n英语:100\r\n*/\r\n\r\nconst fs = require(\"fs\")\r\n\r\nfs.readFile(\"./src/成绩.txt\",\"utf-8\",(err,data)=>{\r\n    if (err) {\r\n        console.log(\"文件读取错误\" + err.message);\r\n    }else{\r\n        console.log(\"文件读取成功:\" + data);\r\n\r\n        var list = data.split(\" \")\r\n        var newList = []\r\n        var target = \"\"\r\n\r\n        console.log(\"处理数据中......\");\r\n        list.forEach((value,index)=>{\r\n            newList.push(value.replace(\"=\",\":\"))\r\n        })\r\n        target = newList.join(\"\\r\\n\")\r\n\r\n        console.log(\"处理数据完毕:\");\r\n        console.log(target);\r\n\r\n        console.log(\"写入数据中......\");\r\n        fs.writeFile(\"./src/成绩-output.txt\",target,err=>{\r\n            if (err) {\r\n                console.log(err);\r\n            }else{\r\n                console.log(\"写入完毕.\");\r\n            }\r\n        })\r\n    }\r\n})\r\n```\r\n\r\n\r\n**路径拼接的问题**<br>\r\n在使用相对路径读取文件时,`./`表示**当前目录**,在程序中,该**当前目录**默认为node命令执行时所在的目录,而不是程序文件所在的目录\r\n<br>\r\n**解决方案**\r\n* 使用 绝对路径\r\n* 使用字符串拼接 `__dirname` + 相对路径(不能带有 `./` 或 `../`)\r\n  * __dirname表示当前`.js`文件所在目录 \r\n  * 这种方式仍然存在一些问题\r\n\r\n\r\n### path路径模块\r\n* `path.join([...paths])` 用来将多个路径片段拼接成一个完整的路径字符串\r\n* `path.basename(/path/to/fileName.txt)` 用来获取路径中的`文件名.扩展名`\r\n* `path.extname(/path/to/fileName.txt)` 用来获取路径中的`.扩展名`\r\n\r\n**简单案例**\r\n```js\r\nconst path = require(\"path\")\r\n\r\nvar temp1 = path.join(\"/home\",\"/dyg\",\"./\",\"../\",\"/admin\",\"test.txt\")\r\nconsole.log(temp1);\r\n/*\r\n输出:\r\n/home/admin/test.txt\r\n*/\r\n\r\nvar temp2 = path.join(__dirname,\"test.txt\")\r\nconsole.log(temp2);\r\n/*\r\n输出:\r\n/mnt/D/GitProject/YiguiDing.github.ioV2/source/_posts/nodejs学习笔记/demos/test.txt\r\n*/\r\n```\r\n\r\n```js\r\nvar temp3 = path.basename(\"/path/to/fileName.txt\")\r\nconsole.log(temp3);\r\n/*\r\n输出:\r\nfileName.txt\r\n*/\r\n\r\nvar temp4 = path.basename(\"/path/to/fileName.12345\",\"345\")\r\nconsole.log(temp4);\r\n/*\r\n输出:\r\nfileName.12\r\n*/\r\n```\r\n\r\n\r\n```js\r\nvar temp5 = path.extname(\"/path/to/fileName.12345\")\r\nconsole.log(temp5);\r\n/*\r\n输出:\r\n.12345\r\n*/\r\n```\r\n\r\n**综合案例**\r\n```js\r\nconst fs = require(\"fs\")\r\nconst path = require(\"path\")\r\n\r\n\r\nfs.readFile(path.join(__dirname,\"./src/待拆分文件.html\"),\"utf-8\",(err,data)=>{\r\n    if(err){\r\n        console.log(err);\r\n    }else{\r\n        // console.log(data);\r\n        resolveCSS(data);\r\n        resolveJS(data);\r\n        resolveHTML(data);\r\n    }\r\n})\r\n\r\n\r\nfunction resolveCSS(html){\r\n    const reg = /<style>[\\s\\S]*<\\/style>/\r\n    var value = reg.exec(html)[0].replace(/<style>/g,\"\").replace(/<\\/style>/g,\"\")\r\n    // console.log(value);\r\n    fs.writeFile(path.join(__dirname,\"./src/index.css\"),value,err=>{\r\n        if(err)\r\n            console.log(\"resolveCSS failed:\"+err);\r\n        else\r\n            console.log(\"resolveCSS success\");\r\n    })\r\n}\r\n\r\nfunction resolveJS(html){\r\n    const reg = /<script>[\\s\\S]*<\\/script>/\r\n    var value = reg.exec(html)[0].replace(/<script>/g,\"\").replace(/<\\/script>/g,\"\")\r\n    // console.log(value);\r\n    fs.writeFile(path.join(__dirname,\"./src/index.js\"),value,err=>{\r\n        if(err)\r\n            console.log(\"resolveJS failed:\"+err);\r\n        else\r\n            console.log(\"resolveJS success\");\r\n    })\r\n    return value;\r\n}\r\n\r\nfunction resolveHTML(html){\r\n    var value = html\r\n    .replace(/<style>[\\s\\S]*<\\/style>/,\"\")\r\n    .replace(/<script>[\\s\\S]*<\\/script>/,\"\")\r\n    .replace(/<\\/title>/,`</title>\r\n        <link rel=\"stylesheet\" href=\"./index.css\" \\>\r\n        <script src=\"./index.js\"></script>\r\n    `)\r\n    fs.writeFile(path.join(__dirname,\"./src/index.html\"),value,err=>{\r\n        if(err)\r\n        console.log(\"resolveHTML failed:\"+err);\r\n        else\r\n        console.log(\"resolveHTML success:\"+value);\r\n    })\r\n}\r\n```\r\n**./src/待拆分文件.html**\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        #id_1{\r\n            width: 200px;\r\n            height: 100px;\r\n            background-color: skyblue;\r\n            color: red;\r\n        }\r\n    </style>\r\n        <style>\r\n            #id_2{\r\n                width: 200px;\r\n                height: 100px;\r\n                background-color: skyblue;\r\n                color: red;\r\n            }\r\n        </style>\r\n    <script>\r\n        console.log(\"this is js code\")\r\n    </script>\r\n</head>\r\n<body>\r\n    <div id=\"id_1\">\r\n        测试文字\r\n        测试文字\r\n        测试文字\r\n        测试文字\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n### http模块\r\n**request 的属性和方法**\r\n* `request.url` 如:`/`;`/index.html` \r\n* `request.method` 如 `GET` `POST`\r\n\r\n**response 的属性和方法**\r\n* `response.end(string)` 向客户端响应内容\r\n* `response.setHeader(\"key\",\"value\")` 设置响应头\r\n  * 防止中文乱码`response.setHeader(\"Content-Type\",\"text/url;charset=utf-8\")`\r\n\r\n\r\n**简易案例**\r\n```js\r\n//导入http模块\r\nconst http = require(\"http\")\r\n\r\n//创建实例对象\r\nconst server = http.createServer()\r\n\r\n//绑定request事件\r\nserver.on(\"request\",(req,res)=>{\r\n    console.log(\"收到了一个http请求...\");\r\n})\r\n\r\n//启动服务\r\nserver.listen(8000,()=>{\r\n    console.log(\"服务器已启动,正在监听8000端口...\");\r\n})\r\n```\r\n**简易动态响应(路由)的实现**\r\n```js\r\n//导入http模块\r\nconst http = require(\"http\")\r\n\r\n//创建实例对象\r\nconst server = http.createServer()\r\n\r\n//绑定request事件\r\nserver.on(\"request\",(req,res)=>{\r\n    const url = req.url\r\n    let content = `<h1>404</h1>`\r\n    \r\n    if(url===\"/\" || url===\"/index\" || url===\"/index.html\"){\r\n        content = `<h1>index</h1>`\r\n    }else\r\n    if(url===\"/about\" ||  url===\"/about.html\"){\r\n        content = `<h1>about</h1>`\r\n    }\r\n\r\n    res.setHeader(\"Content-Type\",\"text/html;charset=utf-8\")\r\n    res.end(content)\r\n})\r\n\r\n//启动服务\r\nserver.listen(8000,()=>{\r\n    console.log(\"服务器已启动,正在监听8000端口...\");\r\n})\r\n```\r\n\r\n**实现简易Web服务器**\r\n```js\r\n//导入http模块\r\nconst fs = require(\"fs\")\r\nconst path = require(\"path\")\r\nconst http = require(\"http\")\r\n\r\n//创建实例对象\r\nconst server = http.createServer()\r\n\r\n//绑定request事件\r\nserver.on(\"request\",(req,res)=>{\r\n    const rootUrl = \"./src\"\r\n    let url = req.url\r\n    let content = `<h1>404</h1>`\r\n    \r\n    if(url===\"/\" || url===\"/index\" || url===\"/index.html\"){\r\n        url=`/index.html`\r\n    }\r\n\r\n    fs.readFile(path.join(__dirname,rootUrl,url),\"utf-8\",(err,data)=>{\r\n        if(err) {\r\n            // content = err.message\r\n        }\r\n        else {\r\n            content = data\r\n        }\r\n        // res.setHeader(\"Content-Type\",\"text/html;charset=utf-8\") //text/html会导致浏览器无法识别css代码\r\n        res.end(content)\r\n    })\r\n})\r\n\r\n//启动服务\r\nserver.listen(8000,()=>{\r\n    console.log(\"服务器已启动,http://127.0.0.1:8000/\");\r\n})\r\n```\r\n\r\n\r\n\r\n## 尝试自定义模块\r\n**目录结构**\r\n* 自定义模块根目录\r\n  * index.js\r\n  * package.json\r\n  * README.md\r\n* test.js\r\n\r\n\r\n\r\n\r\n**index.js**\r\n```js\r\n// 实现html转义\r\nfunction htmlEncode(content){//编码\r\n    return content.replace(/<|>|\"|&/g,march=>{\r\n        switch(march){\r\n            case '<':\r\n                return '&lt;';\r\n            case '>':\r\n                return '&gt;';\r\n            case '\"':\r\n                return '&quot;';\r\n            case '&':\r\n                return \"&amp;\";\r\n         }\r\n    })\r\n}\r\nfunction htmlDecode(content){//解码\r\n    return content.replace(/&lt;|&gt;|&quot;|&amp;/g,march=>{\r\n        switch(march){\r\n            case '&lt;':\r\n                return '<';\r\n            case '&gt;':\r\n                return '>';\r\n            case '&quot;':\r\n                return '\"';\r\n            case '&amp;':\r\n                return \"&\";\r\n         }\r\n    })\r\n}\r\nmodule.exports.htmlEncode = htmlEncode\r\nmodule.exports.htmlDecode = htmlDecode\r\n```\r\n\r\n**package.json**\r\n```json\r\n{\r\n  \"name\": \"demo-test\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"描述\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\"\r\n}\r\n\r\n```\r\n\r\n**test.js**\r\n```js\r\nconst test = require(\"./6.自定义模块\")\r\n\r\nvar html = `<h1 style=\"color:skyblue\">测试</h1>`\r\nvar encode = test.htmlEncode(html)\r\nvar decode = test.htmlDecode(encode)\r\n\r\nconsole.log(encode);\r\nconsole.log(decode);\r\n```\r\n\r\n\r\n## 第三方模块\r\n\r\n**为什么需要第三方包?**<br>\r\nnodejs内置模块仅提供了底层API,使用内置模块开发效率低,<br>\r\n第三方模块是基于内置模块开发的,提供了更高级更方便的API,提高了开发效率\r\n\r\n\r\n\r\n### moment.js 三方模块\r\n```js\r\nconst moment = require(\"moment\")\r\n\r\nvar tm = moment().format(\"YYYY-MM-DD HH-mm-ss\")\r\nconsole.log(tm);\r\n```\r\n\r\n### i5ting_toc 第三方模块\r\n(用处不大)<br>\r\ni5ting_toc 是md转html的命令行工具,需全局安装<br>\r\n**使用**\r\n```\r\ni5ting_toc -f ./fileName.md -o \r\n```\r\n\r\n\r\n### express模块\r\n<red>详细笔记:[express学习笔记]()</red>  \r\nexpress作用和nodejs的http模块类似,用于创建web服务器<br>\r\nexpress是基于http模块封装的,使用起来比http模块简单,效率更高\r\n\r\n\r\n<style>\r\n    red{\r\n        color:red;\r\n    }\r\n    sky{\r\n        color:skyblue;\r\n    }\r\n    \r\n</style>"},{"shortInfo":{"title":"nodejs的mysql模块学习笔记","date":"2022-08-30T23:25:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["nodejs","mysql"],"hideAtIndex":true,"categories":"后端","id":3830456630,"countWords":888,"readSeconds":88.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# nodejs的mysql模块学习笔记\r\n\r\n\r\n**无法连接数据库的解决**  \r\n`MySQL8` 之前的版本中加密规则是 `mysql_native_password` ,而在之后版本，加密规则是 `caching_sha2_password` ,当前nodejs的mysql模块不支持该加密规则,于是需要修改会旧的加密规则\r\n```bash\r\n# 进入mysql\r\nmysql -u root -p\r\n# 输入:\r\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY \"新密码\";\r\n```\r\n\r\n## 连接数据库\r\n**示例代码**\r\n```js\r\nconst mysql = require(\"mysql\") \r\nconst db = mysql.createConnection({\r\n    host: \"localhost\",\r\n    user: \"root\",\r\n    password: \"root\",\r\n    database: \"my_db_01\",\r\n})\r\n\r\ndb.connect();\r\n\r\n```\r\n\r\n\r\n## 查询数据库\r\n**示例代码**\r\n```js\r\ndb.query(\"SELECT * from users\",(err,result)=>{\r\n    if(err){\r\n        console.log(err);\r\n    }else{\r\n        console.log(message);\r\n    }\r\n})\r\n```\r\n\r\n**输出result结果**  \r\n注意: 执行`select`语句的查询结果为数组\r\n```js\r\n[\r\n  RowDataPacket {\r\n    id: 1,\r\n    username: 'DingYigui',\r\n    password: '123',\r\n    status: 0\r\n  },\r\n  RowDataPacket {\r\n    id: 10,\r\n    username: 'DYG1231',\r\n    password: 'd12yg1232',\r\n    status: 0\r\n  }\r\n]\r\n```\r\n\r\n## 插入数据\r\n**方法1**\r\n```js\r\nvar user = {username:\"newUser\",password:\"newPasswd\"}\r\nvar sqlStr = \"INSERT INTO users (username,password) VALUES (?,?);\" //?为占位符\r\n\r\ndb.query(sqlStr,[user.username,user.password],(err,result)=>{ //第二个参数中的数据将被依次填入占位符\r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"插入成功!,新增\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"插入数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n**输出result结果**  \r\n注意: 执行`INSERT` `UPDATE` `DELETE` 语句的结果均为对象\r\n```js\r\nOkPacket {\r\n  fieldCount: 0,\r\n  affectedRows: 1,\r\n  insertId: 11,\r\n  serverStatus: 2,\r\n  warningCount: 0,\r\n  message: '',\r\n  protocol41: true,\r\n  changedRows: 0\r\n}\r\n```\r\n\r\n**方法2:更高效的方式**\r\n```js\r\nvar user = {username:\"newUser2\",password:\"newPasswd2\"}\r\nvar sqlStr = \"INSERT INTO users set ?;\" //?为占位符\r\n\r\ndb.query(sqlStr,user,(err,result)=>{ //将会自动展开为: UPDATE users SET username = \"newUser2\" , password = \"newPasswd2\" \r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"插入成功!,新增\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"插入数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n## 更新数据\r\n**方法1**\r\n```js\r\nvar user = {username:\"newUser3\",password:\"newPasswd3\",id:2}\r\nvar sqlStr = \"UPDATE users SET username=?,password=? WHERE id=?;\" //?为占位符\r\ndb.query(sqlStr,[user.username,user.password,user.id],(err,result)=>{ //第二个参数中的数据将被依次填入占位符\r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"更新成功!,新增\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"更新数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n**方法2:更高效的方式**\r\n```js\r\nvar user = {username:\"newUser3\",password:\"newPasswd3\",id:2 }\r\nvar sqlStr = \"UPDATE users SET ? WHERE id=?;\" //?为占位符\r\n\r\ndb.query(sqlStr,[user,user.id],(err,result)=>{ //将会自动展开为: UPDATE users SET username=newUser3,password=newPasswd3,id=2 WHERE id=2;\r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"更新成功!,新增\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"更新数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n## 删除数据\r\n```js\r\nvar userID = 5 \r\nvar sqlStr = \"DELETE FROM users WHERE id=?;\" //?为占位符\r\ndb.query(sqlStr,userID,(err,result)=>{ \r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"删除成功!,删除\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"删除数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n## 标记数据为删除\r\n实际中删除一个用户后存在用户想要撤销删除操作的可能,对于这种需求可以采取修改用户状态为已删除的方式来实现\r\n```js\r\nvar userID = 5 \r\nvar sqlStr = \"UPDATE users SET status=? WHERE id=?;\" //?为占位符\r\ndb.query(sqlStr,[1,5],(err,result)=>{ \r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"标记用户为已删除成功!,更新了\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"标记用户为已删除失败!\");\r\n    }\r\n})\r\n```\r\n\r\n\r\n## mysql2基本使用\r\n```js\r\nimport mysql from \"mysql2\"\r\nconst pool = mysql.createPool({\r\n    host: \"localhost\",\r\n    user: \"root\",\r\n    password: \"root\",\r\n    database: \"my_db_01\",\r\n})\r\n\r\nexport default  pool.promise()\r\n\r\n\r\n// --------------------------------------------\r\nimport db from \"./mysql.js\" \r\nexport async function getUserInfo(req,res){\r\n    const sql = \"???????\"\r\n    let result = await db.query(sql)\r\n    res.send({\r\n         status:0,\r\n         message:\"\",\r\n         data:result,\r\n    })\r\n}\r\n```"},{"shortInfo":{"title":"promise学习笔记","date":"2022-07-17T23:38:00.000Z","cover":"\\self_server\\assets\\images\\promise学习笔记\\2022-12-04-01-21-02.png","tags":["promise"],"categories":"笔记","id":2612257976,"countWords":5442,"readSeconds":544.2,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/promise学习笔记/2022-12-04-01-21-02.png) -->\r\n\r\n## 简介\r\n* promise对象是ES6（ECMAscript 6 ）引入的用于**异步编程**的**新**解决方案\r\n  * **旧**方法单纯使用回调函数\r\n  * **新**方法使用promise\r\n* 从语法上来说就是一个构造函数，用来封装异步的任务，并能对结果进行处理\r\n* promise在app、web中应用广泛；\r\n* 前端和后端都会用到；\r\n* 也是面试高频题目，进大厂需要掌握其内部原理\r\n* Promise支持链式操作，能够解决**回调地狱问题**\r\n* promise指定回调函数非常灵活，\r\n  * 旧方法必须在启动异步任务前指定回调函数`setTimeout(()=>{},2000)`\r\n  * promise方法可以在启动异步任务后指定回调函数\r\n\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**常见异步操作**\r\n* 定时器\r\n    ```js\r\n    //旧方法\r\n    setTimeout(()=>{},2000)\r\n    ```\r\n* ajax\r\n    ```js\r\n    //旧方法\r\n    $.get(\"./path/to/file\",(data)=>{})\r\n    ```\r\n* 数据库操作\r\n* fs文件操作\r\n    ```js\r\n    require(\"fs\").readFile(\"./file\",(error,data)=>{})\r\n    ```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**回调地狱问题**\r\n* **旧**方法单纯使用回调函数，需反复嵌套，不支持链式操作\r\n* 不利于阅读\r\n* 不便于错误处理\r\n```js\r\nfunctionA(args,(err,data)=>{\r\n    functionB(args,(err,data)=>{\r\n        functionC(args,(err,data)=>{\r\n            functionE(args,(err,data)=>{\r\n                functionF(args,(err,data)=>{\r\n                })\r\n            })\r\n        })\r\n    })\r\n})\r\n\r\n```\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**箭头函数**\r\n* `()=>{}`\r\n* ES6标准\r\n* 箭头函数中形参若只有一个则可以省略小括号\r\n* 箭头函数中的`this`始终指向该函数的创建环境，而不是其调用者\r\n* 箭头函数不能定义构造函数\r\n* 箭头函数显式定义需要变量关键字`var`、`let`、`const`，由于变量提升的特性，所以必须先定义声明再调用该函数\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**关于let**\r\n* `let`命令是ES6 新增的，用来声明变量。\r\n* `let`声明的变量只在局部作用域内有效，可用在`for`循环中\r\n* 不存在变量提升，必须先声明后使用，否则报错\r\n\r\n\r\n\r\n## promise的状态\r\n* promise状态是promise实例对象中的一个属性\r\n* 属性名为PromiseState\r\n* 该属性是一个内置属性，不能直接对其进行操作\r\n* 属性值有三种状态\r\n    * pending 未定义的初始状态\r\n    * resolved、fullfilled 成功的状态\r\n    * rejected 失败的状态\r\n* 属性的三种状态只有两种变化过程\r\n    * pending -> resolved\r\n    * pending -> rejected\r\n    * 不能由失败、成功变为未定义状态\r\n    * 不能由失败变成功，也不能由成功变失败\r\n* 属性的状态只能改变一次\r\n\r\n## promise的结果\r\n* promise结果是promise实例对象中的一个属性\r\n* 属性名为`PromiseResult`\r\n* 该属性是一个内置属性，不能直接对其进行操作\r\n* 只有函数`resolve(valure)`、`reject(reason)` 能对其值进行修改\r\n* 属性值有三种状态\r\n\r\n## 基本使用\r\n* `new Promise((resolve,reject)=>{})`构造函数的第一个形参是一个函数，该函数又接收了两个参数resolve和reject，这两个参数也是函数\r\n* `resolve()`调用完毕后会将promise对象状态设置为**成功**\r\n* `reject()`调用完毕后会将promise对象状态设置为**失败**\r\n* `promiseObj.then()`函数有两个形式参数，都是函数，\r\n    * 当promise对象状态为成功时执行第一个回调函数，为失败时执行第二个回调函数\r\n    * 第一个函数其形参value为resolve传递过来的参数\r\n    * 第二个函数其形参reason为reject传递过来的参数\r\n\r\n**新旧两种解决方案的对比**\r\n\r\n<div id=\"demo23r023jfr02\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btn = document.querySelector(\"#demo23r023jfr02>button\")\r\n    var p = document.querySelector(\"#demo23r023jfr02>p\")\r\n    btn.addEventListener(\"click\",function(){\r\n        setTimeout(function(){//模拟服务端延迟\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30)// r落在0~30区间的概率为30%if(accurate(30))\r\n                    p.innerHTML+=\"恭喜中奖\"\r\n                else\r\n                    p.innerHTML+=\"再接再厉\"\r\n        },1000)\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demo23r023jfr02\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btn = document.querySelector(\"#demo23r023jfr02>button\")\r\n    var p = document.querySelector(\"#demo23r023jfr02>p\")\r\n    btn.addEventListener(\"click\",function(){\r\n        setTimeout(function(){//模拟服务端延迟\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30)// r落在0~30区间的概率为30%if(accurate(30))\r\n                    p.innerHTML+=\"恭喜中奖\"\r\n                else\r\n                    p.innerHTML+=\"再接再厉\"\r\n        },1000)\r\n    })\r\n</script>\r\n```\r\n\r\n<div id=\"demo12312312qq\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btnn = document.querySelector(\"#demo12312312qq>button\");\r\n    var pp = document.querySelector(\"#demo12312312qq>p\");\r\n    btnn.addEventListener(\"click\",function(){\r\n        //Promise构造函数的第一个形参是一个函数，该函数又接收了两个参数resolve和reject，这两个参数也是函数\r\n        const promise = new Promise((resolve,reject)=>{\r\n            setTimeout(()=>{\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30){ // r落在0~30区间的概率为30%\r\n                    resolve(r) //调用完毕后会将promise对象状态设置为**成功**\r\n                }else{\r\n                    reject(r) //调用完毕后会将promise对象状态设置为**失败**\r\n                }\r\n            },1000);\r\n        })\r\n        //then函数有两个形式参数，都是函数，\r\n        //当promise对象状态为成功时执行第一个回调函数，为失败时执行第二个回调函数\r\n        //第一个函数其形参value为resolve传递过来的参数\r\n        //第二个函数其形参reason为reject传递过来的参数\r\n        promise.then((value)=>{\r\n            pp.innerHTML+=\"恭喜中奖\"+value\r\n        },(reason)=>{\r\n            pp.innerHTML+=\"再接再厉\"+reason\r\n        });\r\n    });\r\n</script>\r\n\r\n```html\r\n<div id=\"demo12312312qq\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btnn = document.querySelector(\"#demo12312312qq>button\");\r\n    var pp = document.querySelector(\"#demo12312312qq>p\");\r\n    btnn.addEventListener(\"click\",function(){\r\n        //Promise构造函数的第一个形参是一个函数，该函数又接收了两个参数resolve和reject，这两个参数也是函数\r\n        const promise = new Promise((resolve,reject)=>{\r\n            setTimeout(()=>{\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30){ // r落在0~30区间的概率为30%\r\n                    resolve(r) //调用完毕后会将promise对象状态设置为**成功**\r\n                }else{\r\n                    reject(r) //调用完毕后会将promise对象状态设置为**失败**\r\n                }\r\n            },1000);\r\n        })\r\n        //then函数有两个形式参数，都是函数，\r\n        //当promise对象状态为成功时执行第一个回调函数，为失败时执行第二个回调函数\r\n        //第一个函数其形参value为resolve传递过来的参数\r\n        //第二个函数其形参reason为reject传递过来的参数\r\n        promise.then((value)=>{\r\n            pp.innerHTML+=\"恭喜中奖\"+value\r\n        },(reason)=>{\r\n            pp.innerHTML+=\"再接再厉\"+reason\r\n        });\r\n    });\r\n</script>\r\n```\r\n\r\n## 用promise封装fs\r\n\r\n**promise封装前**\r\n```js\r\nconst fs = require(\"fs\");\r\nfs.readFile(\"./path/to/fileName\",(err,data)=>{\r\n    if(err) throw err;//异常处理\r\n    console.log(data.toString());//数据处理\r\n})\r\n```\r\n\r\n**promise封装后**\r\n```js\r\nconst fs = require(\"fs\");\r\n\r\nconst p = new Promise((resolve,reject)={\r\n    fs.readFile(\"./path/to/fileName\",(err,data)=>{\r\n        if(err)\r\n            reject(err);\r\n        else\r\n            resolve(data)\r\n    })\r\n})\r\n\r\n// 使用\r\np.then(value=>{// 形式参数只有一个，箭头函数的括号可省略\r\n    console.log(value.toString();//数据处理\r\n},reason=>{\r\n    throw reason;//异常处理\r\n})\r\n```\r\n\r\n**手动用promise将fs封装为一个函数**\r\n```js\r\n\r\nfunction myreadFile(path){\r\n    return new Promise((resolve,reject)={\r\n        require(\"fs\").readFile(path,(err,data)=>{\r\n            if(err)\r\n                reject(err);\r\n            else\r\n                resolve(data)\r\n        })\r\n    })\r\n}\r\n\r\n// 使用\r\nmyreadFile(\"./path/to/file\")\r\n.then(value=>{\r\n    console.log(value.toString());\r\n},reason=>{\r\n    console.log(reason);\r\n})\r\n```\r\n\r\n**通过util.promisify获取已经使用promise封装好的fs函数**\r\n```js\r\nconst util = require(\"util\")\r\nconst fs = require(\"fs\")\r\n\r\nfunction myreadFile = util.promisify(fs.readFile)\r\n\r\n// 使用\r\nmyreadFile(\"./path/to/file\")\r\n.then(value=>{\r\n    console.log(value.toString());\r\n},reason=>{\r\n    console.log(reason);\r\n})\r\n```\r\n\r\n\r\n## 用promise封装ajax\r\n\r\n**promise封装前**\r\n\r\n<div id=\"demofjwif02\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif02>button\").click(function(){\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\",\"https://api.apiopen.top/api/sentences\")\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function(){\r\n            if(xhr.readyState===4){\r\n                // 判断响应状态码\r\n                if(xhr.status>=200&&xhr.status<300){\r\n                    $(\"#demofjwif02>p\").text(xhr.response)\r\n                }else{\r\n                    $(\"#demofjwif02>p\").text(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n\r\n```js\r\n<div id=\"demofjwif02\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif02>button\").click(function(){\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\",\"https://api.apiopen.top/api/sentences\")\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function(){\r\n            if(xhr.readyState===4){\r\n                // 判断响应状态码\r\n                if(xhr.status>=200&&xhr.status<300){\r\n                    $(\"#demofjwif02>p\").text(xhr.response)\r\n                }else{\r\n                    $(\"#demofjwif02>p\").text(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n```\r\n\r\n**promise封装后**\r\n\r\n<div id=\"demofjwif021231\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif021231>button\").click(function(){\r\n        const promise = new Promise((resolve,reject)=>{\r\n            //创建对象\r\n            const xhr = new XMLHttpRequest();\r\n            // 初始化\r\n            xhr.open(\"GET\", \"https://api.apiopen.top/api/sentences\")\r\n            // 发送\r\n            xhr.send();\r\n            // 处理响应结果\r\n            xhr.onreadystatechange = function () {\r\n                if (xhr.readyState === 4) {\r\n                    // 判断响应状态码\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        resolve(xhr.response)\r\n                    } else {\r\n                        reject(xhr.status)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n        promise.then(response=>{\r\n            $(\"#demofjwif021231>p\").text(response)\r\n        },states=>{\r\n            $(\"#demofjwif021231>p\").text(states)\r\n        })\r\n    })\r\n</script>\r\n\r\n```js\r\n<div id=\"demofjwif021231\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif021231>button\").click(function(){\r\n        const promise = new Promise((resolve,reject)=>{\r\n            //创建对象\r\n            const xhr = new XMLHttpRequest();\r\n            // 初始化\r\n            xhr.open(\"GET\", \"https://api.apiopen.top/api/sentences\")\r\n            // 发送\r\n            xhr.send();\r\n            // 处理响应结果\r\n            xhr.onreadystatechange = function () {\r\n                if (xhr.readyState === 4) {\r\n                    // 判断响应状态码\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        resolve(xhr.response)\r\n                    } else {\r\n                        reject(xhr.status)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n        promise.then(response=>{\r\n            $(\"#demofjwif021231>p\").text(response)\r\n        },states=>{\r\n            $(\"#demofjwif021231>p\").text(states)\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n**用promise将ajex封装为一个函数**\r\n\r\n```js\r\nfunction sendAjax(url){\r\n    return new Promise((resolve,reject)=>{\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\", url)\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function () {\r\n            if (xhr.readyState === 4) {\r\n                // 判断响应状态码\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(xhr.response)\r\n                } else {\r\n                    reject(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n// 使用\r\nsendAjax(\"https://api.apiopen.top/api/sentences\")\r\n.then(vaule=>{\r\n    console.log(vaule)\r\n},reason=>{\r\n    console.warm(reason)\r\n})\r\n```\r\n\r\n## APIs\r\n\r\n**`new Promise(executor);`构造函数**\r\n* 形参`executor`是一个函数， 称为**执行器**，写为`(resolve,reject)=>{}`\r\n* 执行器的形参resolve，是一个函数，写在执行器函数中，执行器执行成功时调用\r\n* 执行器的形参reject，是一个函数，写在执行器函数中，执行器执行失败时调用\r\n* 执行器中的语句是随构造函数同步执行的\r\n    ```js\r\n    // 1111 2222 顺序输出\r\n    let p = new Promise((rosolve,reject)=>{\r\n        console.log(\"1111\")\r\n    })\r\n    console.log(\"2222\")\r\n    ```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.prototype.then(onResolved,onRejected);`方法**\r\n* onResolved 成功的回调函数 写为`(value)=>{}`\r\n* onRejected 失败的回调函数 写为`(reason)=>{}`\r\n* 返回值是一个新的Promise对象\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.prototype.cache(onRejected);`方法**\r\n* onRejected 失败的回调函数 写为`(reason)=>{}`\r\n* 该函数内部由then()封装实现\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.resolve(value);`方法**\r\n* 该方法是Promise对象的内置方法，不是实例化后的对象的方法\r\n* 该方法用来快速获取一个Promise实例对象，并且给其封装一个值和状态\r\n* 该方法返回值是一个promise实例对象\r\n* 当value值是一个非promise类型的对象时，返回的结果为成功的promise对象\r\n* 当value值是一个promise类型的对象时，返回的promise对象的结果（result、成功与否）与传入的promise对象的结果一致\r\n```js\r\nvar p = Promise.resolve(123)\r\nconsole.log(p)//p是一个promise对象，其结果为成功，值为123\r\n\r\nvar k = Promise.resolve(new Promise((resolve,reject)=>{\r\n    resolve(\"成功AAA\")\r\n}))\r\n\r\nconsole.log(k) // k是一个promise对象，其结果为成功，值为“成功AAA”\r\n\r\nvar k = Promise.resolve(new Promise((resolve,reject)=>{\r\n    reject(\"失败BBB\")\r\n}))\r\n\r\nconsole.log(k) // k是一个promise对象，其结果为失败，值为“失败BBB”\r\n//且由于k是一个失败的Promise对象，也没有处理失败的回调，所以会报错\r\n//解决：\r\nk.cach(reason=>{//对失败进行处理\r\n    console.log(reason)\r\n})\r\n```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.reject(value);`方法**\r\n* 和resolve基本一致，\r\n* 但是该函数不论传入的promise对象的状态是成功还是失败，其返回的promise对象的状态是失败，值为传入的promise对象\r\n* 也就是说该函数永远返回一个失败的promise，其值为传入的value值，无论传入的是否为一个Promise对象\r\n\r\n```js\r\nvar j = new Promise((resolve,reject)=>{\r\n    resolve(\"成功AAA\")\r\n})\r\nvar k = Promise.resolve(j)\r\n\r\nconsole.log(k) // k是一个promise对象，其结果为失败，其值为j，也就是为传入的成功的promise对象\r\n```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.all(promises);`方法**\r\n* 基本同上；\r\n* 用于返回一个Promise对象，状态由promises决定\r\n* promises是一个数组，包含多个promise对象，\r\n* 若promises中有一个promise对象为失败，则该函数返回的Promise对象的状态为失败，且该对象的结果为数组中的这个Promise对象本身\r\n* 仅当promises都为成功时，该函数返回的Promise对象的状态为成功，且该对象的结果是由数组中每个Promise对象的结果组成的数组\r\n\r\n```js\r\nvar p1 = new Promise((resolve,reject)=>{\r\n    resolve(\"成功结果1\")\r\n})\r\nvar p2 = Promise.resolve(\"成功结果2\")\r\nvar p3 = Promise.resolve(\"成功结果3\")\r\n\r\nvar pk = Promise.all([p1,p2,p3]);\r\nconsole.log(pk)\r\n```\r\n结果：  \r\n![](./images/promise学习笔记/2022-07-18-15-36-38.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve,reject)=>{\r\n    resolve(\"成功结果1\")\r\n})\r\nvar p2 = Promise.reject(\"失败结果2\")\r\nvar p3 = Promise.resolve(\"成功结果3\")\r\n\r\nvar pk = Promise.all([p1,p2,p3]);\r\nconsole.log(pk)\r\n```\r\n结果：  \r\n![](./images/promise学习笔记/2022-07-18-15-41-47.png)\r\n\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.race(promises);`方法**\r\n* 返回的的是promises中第一个改变状态的promsie\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n        resolve(\"成功结果1\")\r\n    }, 1000);\r\n})\r\nvar p2 = Promise.resolve(\"成功结果2\")\r\nvar p3 = Promise.resolve(\"成功结果3\")\r\nvar pk = Promise.race([p1, p2, p3]);\r\nconsole.log(pk)\r\n```\r\n\r\n结果：  \r\n![](./images/promise学习笔记/2022-07-18-15-53-23.png)\r\n\r\n\r\n## 关键问题\r\n\r\n**修改对象的状态的三种方式**\r\n* 在执行器函数中执行`resolve()` pending -> fulfilled/resolved\r\n* 在执行器函数中执行`reject()` pending -> rejected\r\n* 在执行器函数中抛出错误`throw \"字符串或error实例对象\";` pending -> rejected\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"成功结果1\")\r\n    reject(\"失败结果1\")\r\n    throw \"失败结果2\";\r\n})\r\nconsole.log(p1)\r\n```\r\n![](./images/promise学习笔记/2022-07-18-20-44-07.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**指定的多个回调都会执行**\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果\")\r\n})\r\nconsole.log(p1)\r\np1.then(value => {\r\n    console.log(\"执行了成功回调函数1,result为：\" + value)\r\n})\r\np1.then(value => {\r\n    console.log(\"执行了成功回调函数2,result为：\" + value)\r\n})\r\n```\r\n![](./images/promise学习笔记/2022-07-18-20-51-29.png)\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**改变状态和指定回调的then()函数执行顺序的问题**\r\n* 当改变状态的语句在执行器中被**同步**执行时，执行顺序是 改变状态 -> 指定回调函数 -> 执行回调函数\r\n* 当改变状态的语句在执行器中被**异步**执行时，执行顺序是 指定回调函数 -> 改变状态 -> 执行回调函数\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    console.log(\"即将执行改变状态的函数resolve()\");\r\n    resolve(\"这是成功的结果\")\r\n    console.log(\"resolve() 执行完毕\");\r\n})\r\n\r\nconsole.log(\"即将执行指定回调函数的函数then()\");\r\np1.then(value => {\r\n    console.log(\"执行了成功的回调函数，结果为:\"+ value)\r\n})\r\nconsole.log(\"then() 执行完毕\");\r\n```\r\n![](./images/promise学习笔记/2022-07-18-21-31-42.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    console.log(\"即将执行执行器中的代码\");\r\n    setTimeout(() => {\r\n        console.log(\"即将执行改变状态的函数resolve()\");\r\n        resolve(\"这是成功的结果\")\r\n        console.log(\"resolve() 执行完毕\");\r\n    }, 1000);\r\n    console.log(\"执行器中的代码执行完毕\");\r\n})\r\nconsole.log(\"即将执行指定回调函数的函数then()\");\r\np1.then(value => {\r\n    console.log(\"执行了成功的回调函数，结果为:\"+ value)\r\n})\r\nconsole.log(\"then() 执行完毕\");\r\n```\r\n\r\n![](./images/promise学习笔记/2022-07-18-21-40-21.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**then()方法的返回值问题**\r\n* 若回调函数抛出了异常，则then的返回值是一个promise对象，状态为失败，result为抛出的异常\r\n* 若回调函数的返回值是非promise对象，则then的返回值是一个promise对象，状态为成功，result为该返回值\r\n* 若回调函数的返回值是promise对象，则then的返回值是一个promise对象，状态为失败，result为该对象的result值\r\n* 若回调函数没有返回值，则then的返回值是一个promise对象，状态为成功，result为undefined\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果\")\r\n})\r\nvar k = p1.then(value => {\r\n    throw \"抛出异常\"\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-21-31.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果\")\r\n})\r\nvar k = p1.then(value => {\r\n    return 521;\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-16-14.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果1\")\r\n})\r\nvar k = p1.then(value => {\r\n    return new Promise((resolve,reject)=>{\r\n        resolve(\"这是成功的结果2\")\r\n    })\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-23-01.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果1\")\r\n})\r\nvar k = p1.then(value => {\r\n    return new Promise((resolve,reject)=>{\r\n        resolve(\"这是失败的结果1\")\r\n    })\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-24-00.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果1\")\r\n})\r\nvar k = p1.then(value => {\r\n    console.log(\"执行了成功回调函数，且没有返回值\")\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-37-37.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**promise串联多个任务**\r\n* 由于then()的返回值是一个promsie对象，所以可以通过then().then()的方式实现\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是Promise1的成功结果\")\r\n})\r\np1\r\n.then(value => {\r\n    console.log(\"这是Promise1的成功的回调函数 ，获取到的value是：\", value)\r\n    return new Promise((resolve, reject) => {\r\n        resolve(\"这是Promise2的成功结果\")\r\n    })\r\n}).then(value => {\r\n    console.log(\"这是Promise2的成功的回调函数 ，获取到的value是：\", value)\r\n    return new Promise((resolve, reject) => {\r\n        resolve(\"这是Promise3的成功结果\")\r\n    })\r\n}).then(value => {\r\n    console.log(\"这是Promise3的成功的回调函数 ，获取到的value是：\", value)\r\n}).then(value => {\r\n    console.log(\"这是Promise4的成功的回调函数 ，获取到的value是：\", value)\r\n})\r\n```\r\n![](./images/promise学习笔记/2022-07-18-23-16-20.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**异常穿透现象(或者说功能)**\r\n* 可以把异常处理的回调函数写在最后，能够对串联的所有回调函数中的异常进行处理\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是Promise1的成功结果\")\r\n})\r\np1\r\n    .then(value => {\r\n        console.log(\"这是Promise1的成功的回调函数 ，获取到的value是：\", value)\r\n        return new Promise((resolve, reject) => {\r\n            resolve(\"这是Promise2的成功结果\")\r\n        })\r\n    }).then(value => {\r\n        console.log(\"这是Promise2的成功的回调函数 ，获取到的value是：\", value)\r\n        return new Promise((resolve, reject) => {\r\n            // resolve(\"这是Promise3的成功结果\")\r\n            reject(\"这是Promise3的失败结果\")\r\n        })\r\n    }).then(value => {\r\n        console.log(\"这是Promise3的成功的回调函数 ，获取到的value是：\", value)\r\n    }).then(value => {\r\n        console.log(\"这是Promise4的成功的回调函数 ，获取到的value是：\", value)\r\n    }).catch(reason => {\r\n        console.warn(\"这是串联的所有回调函数的异常处理回调函数，获取到的reason为\", reason)\r\n    })\r\n```\r\n\r\n![](./images/promise学习笔记/2022-07-18-23-34-16.png)\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**中断Promise的链式调用**\r\n* 有且只有一种方式，那就是在回调函数中返回一个pending状态的promise实例对象\r\n* 因为then(()=>{})函数中的回调函数无论返回什么都会被封装成一个promise函数，用来交给下一个then来进行处理，若返回的是pending状态的promise对象，那么后续then中的回调函数就不会被触发\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    console.log(\"1111111111111111111\")\r\n    resolve(\"这是Promise1的成功结果\")\r\n})\r\np1\r\n    .then(value => {\r\n        console.log(\"222222222222222222\")\r\n        return new Promise((resolve, reject) => {\r\n            resolve(\"这是Promise2的成功结果\")\r\n        })\r\n    }).then(value => {\r\n        console.log(\"333333333333333333,中断链式调用，返回了一个pending状态的promise\")\r\n        return new Promise((resolve, reject) => {})\r\n    }).then(value => {\r\n        console.log(\"4444444444444444444444\")\r\n    }).then(value => {\r\n        console.log(\"55555555555555555555555\")\r\n    }).catch(reason => {\r\n        console.warn(\"err\")\r\n    })\r\n```\r\n![](./images/promise学习笔记/2022-07-19-00-03-08.png)\r\n\r\n\r\n\r\n\r\n## 手写实现promsie全部功能\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## async 与 await\r\n**async关键字**\r\n* 经async关键字修饰后的函数的返回值是一个promsie对象\r\n* 该promise对象的状态和结果由该函数的return值决定\r\n    * 若该函数抛出错误已,则该函数返回一个状态为失败的promsie，且其结果为抛出的错误值\r\n    * 若该函数return一个非promise对象,则该函数返回一个状态为成功的promsie，且其结果为return的值\r\n    * 若该函数return一个promise对象\r\n        * 若该对象状态为成功 则返回的promise状态也为成功，且结果为返回的promsie对象的结果\r\n        * 若该对象状态为失败 则返回的promise状态也为失败，且结果为返回的promsie对象的结果\r\n        * 若该对象状态为pending 则返回的promise状态也为pending，且结果为undefined\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**await关键字**\r\n* `await`必须写在经`async`修饰后的函数中，但`async`修饰的函数中可以没有await\r\n* 如果`await`获得的`promsie`**失败**，则**抛出异常**，需`try{}cach{}`捕获\r\n* 如果`await`获得的`promise`**成功**，则返回该**promise成功的结果值**result\r\n* 如果`await`获得的是**非promsie对象**，则返回的就是**该非promise对象**\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n**async与await结合的执行顺序问题**\r\n```js\r\nasync function main() {\r\n    var promiseA = new Promise((resolve, reject) => {\r\n        console.log(\"执行器执行\");\r\n        setTimeout(() => {\r\n            console.log(\"执行器中的异步函数执行\");\r\n            resolve(123)\r\n        }, 1000);\r\n    })\r\n    try {\r\n        console.log(\"promiseA状态：\");\r\n        console.log(promiseA);\r\n        console.log(\"await promiseA\");\r\n        var result = await promiseA;\r\n        console.log(\"获取到promiseA的result:\");\r\n        console.log(result);\r\n        console.log(\"执行return\");\r\n        return result;\r\n    } catch (e) {\r\n        return e;\r\n    }\r\n}\r\nconsole.log(\"调用async修饰的函数\");\r\nlet result = main()\r\nconsole.log(\"调用async修饰的函数结束\");\r\nconsole.log(\"async修饰的函数结果为\");\r\nconsole.log(result);\r\n```\r\n![](./images/promise学习笔记/2022-07-19-10-37-38.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n**async于await结合案例之文件操作**\r\n\r\n\r\n回调函数方式文件操作，合并三个文件\r\n```js\r\nconst fs = require(\"fs\")\r\nfs.readFile(\"./path/to/file1\",(err,data1)=>{\r\n    if(err) throw err;\r\n    fs.readFile(\"./path/to/file2\",(err,data2)=>{\r\n        if(err) throw err;\r\n        fs.readFile(\"./path/to/file3\",(err,data3)=>{\r\n            if(err) throw err;\r\n            console.log(data1+data2+data3)\r\n        })\r\n    })\r\n})\r\n\r\n```\r\n\r\nasync于await结合方式合并三个文件\r\n\r\n```js\r\nconst fs = require(\"fs\")\r\nconst util = require(\"util\")\r\nconst myReadFile = util.promisify(fs.readFile);\r\n\r\n(async function{\r\n    try{\r\n      let data1 = await myReadFile(\"./path/to/file1\")\r\n      let data2 = await myReadFile(\"./path/to/file2\")\r\n      let data3 = await myReadFile(\"./path/to/file3\")\r\n      console.log(data1+data2+data3)\r\n    }cache(e){\r\n        console.log(\"文件打开失败\")\r\n    }\r\n})();\r\n\r\n```\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**async与await结合案例之发送AJAX**\r\n\r\n\r\n\r\n需要用到之前写的用Promise封装好的sendAjax函数\r\n```js\r\nfunction sendAjax(url){\r\n    return new Promise((resolve,reject)=>{\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\", url)\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function () {\r\n            if (xhr.readyState === 4) {\r\n                // 判断响应状态码\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(xhr.response)\r\n                } else {\r\n                    reject(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n// 使用\r\nsendAjax(\"https://api.apiopen.top/api/sentences\")\r\n.then(vaule=>{\r\n    console.log(vaule)\r\n},reason=>{\r\n    console.warm(reason)\r\n})\r\n```\r\n\r\n有了这个封装好的函数，再结合async与await，就可以实现下列操作\r\n\r\n\r\n\r\n<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"\r\n    integrity=\"sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=\" crossorigin=\"anonymous\"></script>\r\n<div id=\"demofjwi123131f334\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwi123131f334>button\").click(async function () {\r\n        var result = await sendAjax(\"https://api.apiopen.top/api/sentences\")\r\n        $(\"#demofjwi123131f334>p\").text(result)\r\n    })\r\n    function sendAjax(url) {\r\n        return new Promise((resolve, reject) => {\r\n            //创建对象\r\n            const xhr = new XMLHttpRequest();\r\n            // 初始化\r\n            xhr.open(\"GET\", url)\r\n            // 发送\r\n            xhr.send();\r\n            // 处理响应结果\r\n            xhr.onreadystatechange = function () {\r\n                if (xhr.readyState === 4) {\r\n                    // 判断响应状态码\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        resolve(xhr.response)\r\n                    } else {\r\n                        reject(xhr.status)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n</script>\r\n\r\n```js\r\n<div id=\"demofjwi123131f334\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwi123131f334>button\").click(async function () {  //async修饰\r\n        var result = await sendAjax(\"https://api.apiopen.top/api/sentences\") //await等待\r\n        $(\"#demofjwi123131f334>p\").text(result)\r\n    })\r\n</script>\r\n```"},{"shortInfo":{"title":"SQL学习笔记","date":"2022-08-30T19:29:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["SQL"],"hideAtIndex":true,"categories":"笔记","id":1944554729,"countWords":2251,"readSeconds":225.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# SQL学习笔记\r\n\r\n## 目录\r\n- [SQL学习笔记](#sql学习笔记)\r\n  - [目录](#目录)\r\n  - [概念](#概念)\r\n  - [数据类型和字段特殊标识](#数据类型和字段特殊标识)\r\n  - [SQL语法](#sql语法)\r\n    - [注释](#注释)\r\n    - [数据库相关](#数据库相关)\r\n    - [表相关](#表相关)\r\n    - [SELECT 查询](#select-查询)\r\n    - [INSERT 插入](#insert-插入)\r\n    - [UPDATE 更新](#update-更新)\r\n    - [DELETE 删除](#delete-删除)\r\n    - [WHERE 子句](#where-子句)\r\n    - [WHERE 子句 的 AND 和 OR](#where-子句-的-and-和-or)\r\n    - [ORDER BY 子句 排序](#order-by-子句-排序)\r\n    - [ORDER BY 子句 `多重排序`](#order-by-子句-多重排序)\r\n    - [COUNT(\\*)函数](#count函数)\r\n    - [AS 为列设置列名](#as-为列设置列名)\r\n  - [2022\\_09\\_22课堂笔记](#2022_09_22课堂笔记)\r\n    - [基本概念](#基本概念)\r\n    - [数据模型](#数据模型)\r\n  - [2022\\_10\\_10课堂笔记](#2022_10_10课堂笔记)\r\n    - [SQL](#sql)\r\n    - [定义模式](#定义模式)\r\n    - [创建表](#创建表)\r\n    - [插入数据](#插入数据)\r\n    - [修改表](#修改表)\r\n  - [数据查询](#数据查询)\r\n    - [where子句 between关键字](#where子句-between关键字)\r\n    - [where子句 in关键字](#where子句-in关键字)\r\n    - [where子句 字符串匹配](#where子句-字符串匹配)\r\n    - [where子句 `is null` 空值查询](#where子句-is-null-空值查询)\r\n    - [order by 子句](#order-by-子句)\r\n\r\n## 概念\r\n\r\n**常见数据库**\r\n* `MySQL` 使用最广泛最流行的数据库,开源,分为社区版(免费)和企业版\r\n  * `MySQL WorkBench`为其配套的连接和管理数据库的图像化界面\r\n* `Oracle` 收费\r\n* `SQL Server` 收费(由微软开发)\r\n* `MongoDB` 分为社区版(免费)和企业版\r\n\r\n**区分**\r\n* 关系型数据库,SQL数据库\r\n  * MySQL\r\n  * Oracle\r\n  * SQL Server\r\n* 非关系型数据库,NoSQL数据库\r\n  * MongoDB\r\n\r\n\r\n**关系型数据库组织结构的组成**\r\n* 数据库database : 一般每个项目都有一个单独的数据库\r\n* 数据表table : 不同的数据存入不同的表 如:student表 class表 \r\n* 数据行row : 表中一行就是一条具体的数据\r\n* 字段field : 决定能够存储数据的类型,数据的名称,如id name age\r\n\r\n\r\n## 数据类型和字段特殊标识\r\n\r\n\r\n**数据类型**\r\n* INT 整数\r\n* varchar(len) 长度不超过len的字符串\r\n* TinyInt(1) 布尔值\r\n\r\n**字段特殊标识**\r\n* PK(Primary Key) 主键\r\n* NN(Not NULL) 不允许为空\r\n* UQ(Unique) 唯一\r\n* B(Binary)\r\n* UN(Unsigned) 无符号\r\n* ZF(Zero Fill)\r\n* G(Generated)\r\n* AI(Auto Increment) 值自动增长\r\n* default 默认值\r\n\r\n\r\n![图 4](./images/SQL学习笔记/9f237b06e403823a93e74262adfefaaa789ffffef977a68ea559930c26eaeea7.png) \r\n\r\n\r\n**创建表**\r\n```sql\r\nCREATE TABLE `my_db_01`.`users` (\r\n  `id` INT NOT NULL AUTO_INCREMENT COMMENT '主键',\r\n  `username` VARCHAR(45) NOT NULL COMMENT '用户登陆名',\r\n  `password` VARCHAR(45) NOT NULL COMMENT '用户登陆密码',\r\n  `status` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '0 用户状态正常\\n1 用户被禁用',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE INDEX `id_UNIQUE` (`id` ASC) VISIBLE,\r\n  UNIQUE INDEX `username_UNIQUE` (`username` ASC) VISIBLE);\r\n\r\n```\r\n\r\n**插入数据**\r\n```sql\r\nINSERT INTO `my_db_01`.`users` (`username`, `password`) VALUES ('DingYigui', '123');\r\n```\r\n\r\n\r\n\r\n## SQL语法\r\n### 注释\r\n```sql\r\n-- 这是注释\r\n```\r\n\r\n### 数据库相关\r\n```sql\r\n-- 查看所有的数据\r\nSHOW DATABASES; \r\n\r\n-- 创建数据库\r\nCREATE DATABASE db_01;\r\n\r\n-- 删除数据库\r\nDROP DATABASE db_01;\r\n\r\n-- 使用数据库\r\nUSE db_01;\r\n\r\n```\r\n\r\n\r\n### 表相关\r\n```sql\r\n\r\n-- 查看当前数据库中所有的表\r\nSHOW TABLES;\r\n\r\n-- 创建表\r\nCREATE TABLE 表名称\r\n(\r\n列名称1     数据类型    约束规则,\r\n列名称2     数据类型    约束规则,\r\n列名称3     数据类型    约束规则,\r\n)\r\n--- 创建user表\r\nCREATE TABLE users(\r\n  id INT auto_increment PRIMARY KEY,\r\n  name VARCHAR(255) NOT NULL,\r\n  age INT ,\r\n  gender VARCHAR(4),\r\n  content VARCHAR(255)\r\n);\r\n\r\n-- 删除表\r\nDROP TABLE users;\r\n```\r\n\r\n### SELECT 查询\r\n```sql\r\n-- SELECT语法格式\r\nSELECT 列名 FROM 表名 ;\r\n\r\n-- 选中该表的所有列\r\nSELECT * FROM 表名 ;\r\n\r\n-- 模糊查询 %表示通配 _ 表示单字符\r\nSELECT * from user where name LIKE '丁%'\r\n\r\n-- in语句\r\nSELECT * from user where name in ('DYG', 'dyg')\r\n\r\n-- limit分页\r\nSELECT * from user ORDER BY id desc limit 3\r\nSELECT * from user ORDER BY id desc limit 3,3\r\n\r\n\r\n-- 选中表中的username,password\r\nSELECT username,password FROM users ;\r\n```\r\n\r\n### INSERT 插入\r\n```sql\r\n--- \r\n-- INSERT语法格式\r\nINSERT INTO 表名 (列名1,列名2,...) VALUES (列值1,列值2,...) ;\r\nINSERT INTO 表名 SET 列名1 = 列值1 ,列名2 = 列值2 ,列名3 = 列值3 ;\r\nINSERT INTO 表名 VALUES (列值1, 列值2, 列值3, 列值4, 列值5) --若省略列名则列值位置需一一对应\r\n\r\n-- 插入一条数据\r\nINSERT INTO users (username,password) VALUES (\"DYG\",\"321\") ;\r\n```\r\n\r\n### UPDATE 更新\r\n```sql\r\n--- UPDATE语法格式\r\nUPDATE 表名 SET 列名1 = 新的列值1  WHERE 列名 = 列值 ;\r\nUPDATE 表名 SET 列名1 = 新的列值1 , 列名2 = 新的列值2  WHERE 列名 = 列值 ;\r\n\r\n--- 将id为2的用户密码修改为222\r\nUPDATE users SET password = 222 WHERE id = 2 ;\r\nUPDATE users SET username = \"admin\" , password = \"admin\" WHERE id = 1 ;\r\n\r\n--- 注意: 不加 WHERE 会修改所有用户的密码 \r\n```\r\n\r\n### DELETE 删除\r\n```sql\r\n---DELETE 语法\r\nDELETE FROM 表名 --删除所有用户数据\r\nDELETE FROM 表名 WHERE 列名 = 列值 ; --删除指定数据\r\n\r\n--- 删除id为3的用户\r\nDELETE FROM users WHERE id = 3 ;\r\n\r\n--- 注意: 不加 WHERE 会删除所有用户 \r\n```\r\n\r\n### WHERE 子句\r\n`WHERE` 子句用于**限定选择的标准**  \r\n\r\n`WHERE` 子句在 `SELECT` `UPDATE` `DELETE` 中皆可使用\r\n```sql\r\n--- 查询语句中的WHERE\r\nSELECT 列名 FROM 表名\r\n    WHERE 列名 = 列值 ;\r\n\r\n--- 更新语句中的WHERE\r\nUPDATE 表名 SET 列名 = 新的列值\r\n    WHERE 列名 = 列值 ;\r\n\r\n--- 删除语句中的WHERE\r\nDELETE FROM 表名\r\n    WHERE 列名 = 列值 ;\r\n```\r\n\r\n**WHERE子句的运算符**  \r\n|  操作符  |     描述     |\r\n| :------: | :----------: |\r\n|    =     |     等于     |\r\n| <> 或 != |    不等于    |\r\n|    >     |     大于     |\r\n|    <     |     小于     |\r\n|    >=    |   大于等于   |\r\n|    <=    |   小于等于   |\r\n| BETWEEN  | 在某个范围内 |\r\n|   LIKE   | 搜索某种模式 |\r\n\r\n```sql\r\n--- 删除除admin以外的所有用户\r\nDELETE FROM 表名\r\n    WHERE username != \"admin\" ;\r\n```\r\n\r\n### WHERE 子句 的 AND 和 OR\r\n```sql\r\n--- AND 和 OR 的语法格式\r\nSELECT 列名 FROM 表名\r\n    WHERE 条件1 AND 条件2;\r\n\r\nSELECT 列名 FROM 表名\r\n    WHERE 条件1 OR 条件2;\r\n```\r\n\r\n### ORDER BY 子句 排序\r\n```sql\r\n--- ORDER BY语法格式;默认升序排序\r\nSELECT 列名 FROM 表名\r\n    ORDER BY 列名;\r\n\r\n--- ORDER BY语法格式;ASC为升序排序\r\nSELECT 列名 FROM 表名\r\n    ORDER BY 列名 ASC;\r\n\r\n--- ORDER BY语法格式;DESC为降序排序\r\nSELECT 列名 FROM 表名\r\n    ORDER BY 列名 DESC;\r\n```\r\n\r\n### ORDER BY 子句 `多重排序`\r\n```sql\r\n--- ORDER BY多重排序 语法格式:\r\nSELECT 列名 FROM 表名\r\n    ORDER BY 列名1 ASC,列名2 DESC; ---先按列名1升序排序 再按列名2降序排序\r\n```\r\n\r\n### COUNT(*)函数\r\n返回`SELECT`查询结果的总条数\r\n```sql\r\n--- COUNT(*)语法\r\nSELECT COUNT(*) FROM 表名;\r\n```\r\n**示例**\r\n```sql\r\n--- 示例: 统计users表中status为1的用户数\r\nSELECT COUNT(*) FROM users\r\n    WHERE status=1;\r\n```\r\n![图 6](./images/SQL学习笔记/6f6bc3d73694312746a9cd28e1c1e094104f34e5fdb7cdf19f64a7ce7486009f.png)  \r\n\r\n\r\n### AS 为列设置列名\r\n```sql\r\n--- AS语法\r\nSELECT 旧列名1 AS 新列名1 , 旧列名2 AS 新列名2 FROM 表名;\r\nSELECT COUNT(*) AS total FROM 表名;\r\n```\r\n\r\n**示例1**\r\n```sql\r\n-- 查询user表的id和username字段,并为user字段起别名uname,为id字段起别名uid\r\nSELECT id AS uid , username AS uname FROM users;\r\n```\r\n![图 8](./images/SQL学习笔记/a0abf515a12f083d098b4a8603999dbd34cb0817f6f48701e8316fed84b13337.png)  \r\n\r\n**示例2**\r\n```sql\r\n-- 统计表中所有数据,并为字段取名为total\r\nSELECT COUNT(*) as total FROM users;\r\n```\r\n![图 7](./images/SQL学习笔记/c6b0ce51605b0c75a54c2dcb85b67257027a67f4ce44a0f8a0249d14773e11e0.png)  \r\n\r\n\r\n\r\n\r\n\r\n\r\n## 2022_09_22课堂笔记\r\n\r\n### 基本概念\r\n* **四个概念**: DATA数据 DB数据库 DBS数据库系统 DBMS数据库管理系统 \r\n* **三个阶段**: 人工管理阶段 文件系统阶段 数据库系统届阶段\r\n* **两个独立性**: 物理独立性 逻辑独立性\r\n* **无法解决的问题**: 无法做到零冗余\r\n\r\n### 数据模型\r\n* **两类数据模型**: 概念模型 逻辑物理模型\r\n* **常用概念模型**: 实体-联系模型(E-R模型)\r\n  * E-R模型三要素: 实体(集) 属性 联系:[一对一(1:1) 一对多(1:n) 多对多(m:n)]\r\n* **主要逻辑模型**\r\n  * 层次模型\r\n  * 网状模型\r\n  * **关系模型**\r\n* 面向对象模型\r\n\r\n## 2022_10_10课堂笔记\r\n\r\n### SQL\r\n\r\n* 数据查询 SELECT\r\n* 数据定义 CREATE DROP ALER\r\n* 数据操作 INSERT UPDATE DELEE\r\n* 数据控制 GRANT REVOKE\r\n\r\n### 定义模式\r\n```sql\r\ncreate schema '模式名' authorization 用户名\r\n```\r\n\r\n### 创建表\r\n```sql\r\ncreate table 表名 (\r\n  列名 数据类型 约束条件,\r\n  列名 INT primary key,\r\n  列名 CHAR(20) unique,\r\n  列名 NUMERIC(10,3),\r\n  列名 DECIMAL(5,2)\r\n);\r\n```\r\n\r\n### 插入数据\r\n```sql\r\ninsert into 表名(Sno,Sname,Ssex,Sdep,Sage) \r\n      values('20121521','张三'，'男'，'cs','20');\r\n```\r\n\r\n\r\n### 修改表\r\n**删除列**\r\n```sql\r\nalter table 表名\r\n    drop column 列名\r\n```\r\n\r\n**增加列**\r\n```sql\r\nalter table 表名\r\n    add 列名 类型 数据约束\r\n```\r\n\r\n**修改列的数据类型**\r\n```sql\r\nalter table 表名\r\n    alter 列名 类型 数据约束\r\n```\r\n\r\n**删除表**\r\n```sql\r\ndrop table 表名 restrict;--有限制的删除表\r\ndrop table 表名 cascade;--无限制的删除表\r\n```\r\n\r\n\r\n## 数据查询\r\n```sql\r\nselect [all|distinct] 目标列表达式 -- distinct用于去重\r\nfrom 表名或视图名 \r\nas 别名\r\nwhere 条件表达式_\r\ngroup by 列名_sex having 表达式\r\norder by 列名_age asc｜desc ---desc降序\r\n\r\n```\r\n\r\n### where子句 between关键字\r\n```sql\r\nselect * from student where Sage between 18 and 20; ---相当于 sage >= 18 && sage <= 20\r\n```\r\n\r\n### where子句 in关键字\r\n```sql\r\nselect * from student where Sdep in(\"CS\",\"MA\",\"IS\"); --- 相当于 sdep == CS ｜｜ sdep == MA ｜｜ sdep == IS\r\n```\r\n\r\n### where子句 字符串匹配\r\n```sql\r\nselect * from student where Sname like \"李_浩\"; -- 匹配单个字符\r\nselect * from student where Sname like \"李__\"; --匹配两个单个单字符\r\nselect * from student where Sname like \"李%\"; --匹配0个或多个字符\r\n```\r\n\r\n### where子句 `is null` 空值查询\r\n```sql\r\n;\r\n```\r\n\r\n### order by 子句\r\n* `asc`升序【默认】\r\n* `desc`降序\r\n* 对于空值，排序顺序由系统决定\r\n\r\n```sql\r\nselect * from student order by Sage desc;\r\n```\r\n\r\n  "},{"shortInfo":{"title":"ubuntu22.04配置过程命令记录","date":"2022-08-12T03:54:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["ubuntu22"],"hideAtIndex":true,"categories":"笔记","id":3324624657,"countWords":3539,"readSeconds":353.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# ubuntu22.04配置过程命令记录\r\nwin10关了开机自启的应用 什么程序都没运行 内存竟然吃了近5G CPU吹出来的风热的要死 卸了一堆应用关了一堆系统服务和应用服务内存仍然要吃2.4G 反观最新版的ubuntu22.04 启动至图形界面 只吃了1.5g内存 决定安装使用 在此记录下配置过程 以备不时之需\r\n\r\n\r\n## 目录\r\n- [ubuntu22.04配置过程命令记录](#ubuntu2204配置过程命令记录)\r\n  - [目录](#目录)\r\n  - [安装系统](#安装系统)\r\n    - [空间分配](#空间分配)\r\n  - [换源](#换源)\r\n  - [安装软件](#安装软件)\r\n    - [apt-get常用命令](#apt-get常用命令)\r\n    - [dpkg常用命令](#dpkg常用命令)\r\n  - [配置服务](#配置服务)\r\n  - [防火墙](#防火墙)\r\n  - [权限管理](#权限管理)\r\n    - [sudo命令提示用户不在sudoers中的问题的解决](#sudo命令提示用户不在sudoers中的问题的解决)\r\n  - [挂载NTFS分区](#挂载ntfs分区)\r\n    - [解决不能写入文件系统的问题](#解决不能写入文件系统的问题)\r\n  - [配置sshd](#配置sshd)\r\n  - [配置合上笔记本后不休眠](#配置合上笔记本后不休眠)\r\n  - [使用`./configure`编译文件时依赖报错问题的解决方法](#使用configure编译文件时依赖报错问题的解决方法)\r\n  - [ubuntu安装xfce4并配置xrdp过程记录](#ubuntu安装xfce4并配置xrdp过程记录)\r\n    - [安装及配置](#安装及配置)\r\n    - [在xfce中不能打开终端的解决](#在xfce中不能打开终端的解决)\r\n  - [ubuntu安装gnome并配置xrdp过程记录](#ubuntu安装gnome并配置xrdp过程记录)\r\n    - [安装及配置](#安装及配置-1)\r\n    - [解决“色彩管理设备” 弹窗](#解决色彩管理设备-弹窗)\r\n    - [解决“刷新系统软件源需要认证” / “refresh the system repositories” 弹窗](#解决刷新系统软件源需要认证--refresh-the-system-repositories-弹窗)\r\n    - [XRDP远程桌面连接Ubuntu后没有 Dock、桌面图标 背后的程序们](#xrdp远程桌面连接ubuntu后没有-dock桌面图标-背后的程序们)\r\n    - [使用默认桌面配置](#使用默认桌面配置)\r\n\r\n## 安装系统\r\n### 空间分配\r\n* `/` **根目录** 10-15-20g 足以 此处分配剩余的所有空间\r\n  * `/home` **家目录** 应当分配剩余的所有空间 此处未单独分配\r\n  * `/var` **存放数据库或程序输出日志的目录** 应当视情况而定 此处未单独分配\r\n  * `/boot` **引导分区** 512MB 可有可无 但最好单独分区 否则系统无法引导就只能重装系统了\r\n* `swap` **交换分区** 一倍内存大小足矣\r\n* `efi` **efi系统分区** 512MB\r\n\r\n## 换源\r\n\r\n**备份**\r\n```bash\r\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\r\n```\r\n\r\n**编辑创建新文件**\r\n```bash\r\nsudo gedit /etc/apt/sources.list\r\n```\r\n\r\n**写入文件**\r\n```bash\r\n# 清华源\r\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\r\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse\r\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse\r\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse\r\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse\r\n# 预发布软件源，不建议启用\r\n# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse\r\n```\r\n\r\n**更新软件包列表（Source）**\r\n```bash\r\napt-get update\r\n    # 其他操作：\r\n    # 更新已安装的软件包 (谨慎使用，会导致linux内核升级到最新版本)\r\n    # apt-get upgrade\r\n    # 更新已安装的软件包（识别并处理依赖关系的改变）\r\n    # apt-get dist-upgrade\r\n```\r\n\r\n## 安装软件\r\n**常用软件包名称**\r\n* python3.10 \r\n* python3-pip\r\n\r\n### apt-get常用命令\r\n```bash\r\n# 普通安装\r\napt-get install PackageName\r\n# 安装指定包的指定版本\r\napt-get install PackageName=VersionName\r\n# 重新安装\r\napt-get --reinstall install PackageName\r\n```\r\n\r\n```bash\r\n# 修复依赖关系\r\napt-get -f install\r\n```\r\n\r\n```bash\r\n# 下载软件包的源码\r\napt-get source PackageName\r\n# 安装源码包所需要的编译环境\r\napt-get build-dep PackageName\r\n```\r\n\r\n\r\n```bash\r\n# 删除软件包, 保留配置文件\r\napt-get remove PackageName\r\n# 删除软件包, 同时删除配置文件\r\napt-get --purge remove PackageName\r\n```\r\n\r\n```bash\r\n# 清除 已下载的软件包 和 旧软件包\r\napt-get clean && apt-get autoclean\r\n```\r\n\r\n```bash\r\n# 搜索软件包\r\napt-cache search PackageName\r\n```\r\n\r\n```bash\r\n# 获取软件包的相关信息, 如说明、大小、版本等\r\napt-cache show PackageName\r\n```\r\n\r\n```bash\r\n# 查看该软件包需要哪些依赖包\r\napt-cache depends PackageName\r\n# 查看该软件包被哪些包依赖\r\napt-cache rdepends PackageName\r\n```\r\n\r\n```bash\r\n# 检查是否有损坏的依赖\r\napt-get check PackageName\r\n```\r\n\r\n### dpkg常用命令\r\n* dpkg 是Debian Package的简写，是为Debian 专门开发的套件管理系统，方便软件的安装、更新及移除。\r\n* 所有源自Debian的Linux发行版都使用dpkg，如Ubuntu\r\n\r\n```bash\r\n# 安装本地Debian软件包\r\ndpkg -i <package.deb>\r\n# 列出包内容\r\ndpkg -c <package.deb>\r\n# 提取包裹信息(可以查看包的正式名称，用于卸载)\r\ndpkg -I <package.deb>\r\n```\r\n\r\n```bash\r\n# 列出已安装的所有软件包\r\ndpkg -l\r\n# 列出安装的所有文件清单\r\ndpkg -L <package>\r\n```\r\n\r\n```bash\r\n# 移除一个已安装的包裹 并删掉数据和可执行文件\r\ndpkg -r <package>\r\n# 完全清除一个已安装的包裹 并删掉数据和可执行文件 并删除所有的配置文件\r\ndpkg -P <package>\r\n```\r\n\r\n```bash\r\n# 显示已安装包裹的信息\r\ndpkg -s <package>\r\n# 重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹安装提供了一个统一的配制界面)\r\ndpkg-reconfigure <package>\r\n```\r\n\r\n\r\n## 配置服务\r\n```bash\r\n# 编辑配置为系统服务\r\nvim /usr/lib/systemd/system/XXXX.service\r\n#########################################\r\n[Unit]\r\nDescription=XXXX\r\nAfter=network.target\r\n[Service]\r\nTimeoutStartSec=1\r\nExecStart=/usr/local/bin/XXXX -c /etc/frp/XXXX.ini\r\nExecStop=/bin/kill $MAINPID\r\n[Install]\r\nWantedBy=multi-user.target\r\n###########################################\r\n\r\n# 启动 frp 并设置开机启动\r\nsystemctl enable XXXX\r\nsystemctl start XXXX\r\nsystemctl status XXXX\r\n \r\n# 部分服务器上,可以需要加 .service 后缀来操作,即:\r\nsystemctl enable XXXX.service\r\nsystemctl start XXXX.service\r\nsystemctl status XXXX.service\r\n```\r\n\r\n## 防火墙\r\n```bash\r\n# 查看防火墙状态\r\nsudo ufw status\r\n# 开启防火墙\r\nsudo ufw enable\r\n# 关闭防火墙\r\nsudo ufw disable\r\n```\r\n\r\n## 权限管理 \r\n### sudo命令提示用户不在sudoers中的问题的解决\r\n根据文件`/etc/sudoers`内容可知,只需要将指定用户添加到sudo组,指定的用户就能得到执行sudo命令的权限\r\n```txt\r\n# root 用户拥有所有权限 可在此添加一行给某个用户root权限\r\nroot    ALL=(ALL:ALL) ALL\r\n\r\n# admin 组的成员拥有root权限\r\n%admin ALL=(ALL) ALL\r\n\r\n# sudo 组的成员拥有执行任何命令的权限\r\n%sudo   ALL=(ALL:ALL) ALL\r\n```\r\n\r\n只需要将用户添加到sudo组(添加为附加组)\r\n```bash\r\nusermod 你的用户名 -G sudo\r\n# 修改用户组后可能需重启生效\r\n```\r\n\r\n\r\n## 挂载NTFS分区\r\n**查看所有磁盘分区情况**\r\n```bash\r\nfdisk -l\r\n```\r\n\r\n**查看磁盘分区挂载情况**\r\n```bash\r\ndf -h\r\n```\r\n**查看目标分区的UUID**\r\n```bash\r\nsudo blkid |grep sdb2\r\n```\r\n\r\n**查看ubuntu是否安装了ntfs-3g软件包**\r\n```bash\r\ndpkg -l | grep ntfs\r\n# 没有则安装\r\napt-get install ntfs-3g\r\n```\r\n\r\n**临时挂载磁盘**\r\n```bash\r\nmount -t ntfs-3g -o umask=022 /dev/sdc5 /mnt/E/\r\n```\r\n**卸载挂载的磁盘**\r\n```bash\r\numount /mnt/E/\r\n```\r\n\r\n**配置开机自动挂载磁盘**\r\n```bash\r\nsudo vim /etc/fstab\r\n```\r\n\r\n**配置方法1：**\r\n```bash\r\n# 挂载的分区使用默认的权限，也就是属于用户root 属于root组\r\nUUID=EA06BA3106B9FF1F /mnt/E/ ntfs-3g defaults 0 2\r\n```\r\n\r\n**配置方法2：**\r\n* 使用`UUID`的好处是可以保证在重新分区后仍然能够唯一定位一个分区 若使用`/dev/sdb3`的方式则会在分区数量改变后发生错误\r\n* `rw`表示读写 `dmask` 是目录权限掩码 `fmask` 是文件权限掩码 `uid` 和 `gid` 可分别通过 `id -u` `id -g`获取\r\n* `<dump>` 为0时 `dump` 工具不会对其备份,为 1 时则会\r\n* `<pass>` 为0时 `fsck` 工具不会对其检查,为 1 2 时则会,根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2\r\n```bash\r\n# <file system> <mount point>   <type>  <options>       <dump>  <pass>\r\nUUID=EA06BA3106B9FF1F /mnt/E/ ntfs-3g rw,uid=1000,gid=1000,dmask=022,fmask=111 0 2\r\n```\r\n\r\n**挂载测试：检查fstab有无错误**\r\n```bash\r\nmount -a\r\n```\r\n\r\n**创建软连接到桌面**\r\n```bash\r\nln -s /mnt/D ~/Desktop/D\r\nln -s /mnt/E ~/Desktop/E\r\n```\r\n\r\n\r\n### 解决不能写入文件系统的问题\r\n**问题:** 无法写入文件系统,且umount后,重新执行`mount -a`时,报错 `Could not mount read-write, trying read-only`\r\n\r\n**解决:** 该报错可能是由于文件系统错误导致的,须用ntfsfix命令修复之(ntfsfix包含在ntfs-3g中)\r\n```\r\nsudo ntfsfix /dev/sda4\r\nsudo umount /mnt/D/\r\nsudo umount /mnt/E/\r\n```\r\n\r\n## 配置sshd\r\n**安装**\r\n```\r\napt install openssh-server\r\n```\r\n**配置启动服务**\r\n```\r\n# 一条命令启动ssh和sshd\r\nsystemctl enable ssh\r\n```\r\n\r\n\r\n## 配置合上笔记本后不休眠\r\n**编辑文件/etc/systemd/logind.conf**\r\n```\r\nHandlePowerKey: 按下电源键后的行为，默认poweroff\r\nHandleSleepKey: 按下挂起键后的行为，默认suspend\r\nHandleHibernateKey: 按下休眠键后的行为，默认hibernate\r\nHandleLidSwitch: 合上笔记本盖后的行为，默认suspend（改为ignore即可）\r\n```\r\n**配置完毕后需重启服务**\r\n```\r\n# 如果执行下列代码后黑屏则需重启电脑\r\nsudo service systemd-logind restart\r\n```\r\n\r\n\r\n## 使用`./configure`编译文件时依赖报错问题的解决方法\r\n**故障重现**\r\n```bash\r\n./configure\r\n# 报错信息\r\n# checking for Qt5Svg >= 5.15.2... no\r\n# configure: error: Package requirements (Qt5Svg >= 5.15.2) were not met:\r\n# you may set the environment variables Qt5Svg_CFLAGS\r\n# and Qt5Svg_LIBS to avoid the need to call pkg-config.\r\n```\r\n```\r\n大概意思就是:提示缺少依赖Qt5Svg,并提示应当指定环境变量 Qt5Svg_CFLAGS Qt5Svg_LIBS\r\n```\r\n\r\n**查找相关库所在的包的包名**\r\n```bash\r\nsudo apt-cache search Qt5Svg\r\n# 输出: \r\n# libqt5svg5 - Qt 5 SVG module\r\n# libqt5svg5-dev - Qt 5 SVG module development files\r\n```\r\n**安装包名**\r\n```bash\r\nsudo apt-get install libqt5svg5-dev\r\n```\r\n\r\n**查找包的安装路径**\r\n```bash\r\ndpkg -L libqt5svg5-dev\r\n# 输出信息\r\n# /.\r\n# /usr\r\n# /usr/include\r\n# /usr/include/x86_64-linux-gnu\r\n# /usr/include/x86_64-linux-gnu/qt5\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QGraphicsSvgItem\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QSvgGenerator\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QSvgRenderer\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QSvgWidget\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QtSvg\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QtSvgDepends\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QtSvgVersion\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qgraphicssvgitem.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qsvggenerator.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qsvgrenderer.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qsvgwidget.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qtsvgglobal.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qtsvgversion.h\r\n# /usr/lib\r\n# /usr/lib/x86_64-linux-gnu\r\n# /usr/lib/x86_64-linux-gnu/cmake\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Gui\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Gui/Qt5Gui_QSvgIconPlugin.cmake\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Gui/Qt5Gui_QSvgPlugin.cmake\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Svg\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Svg/Qt5SvgConfig.cmake\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Svg/Qt5SvgConfigVersion.cmake\r\n# /usr/lib/x86_64-linux-gnu/libQt5Svg.prl\r\n# /usr/lib/x86_64-linux-gnu/pkgconfig\r\n# /usr/lib/x86_64-linux-gnu/pkgconfig/Qt5Svg.pc\r\n# /usr/lib/x86_64-linux-gnu/qt5\r\n# /usr/lib/x86_64-linux-gnu/qt5/mkspecs\r\n# /usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules\r\n# /usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_svg.pri\r\n# /usr/share\r\n# /usr/share/doc\r\n# /usr/share/doc/libqt5svg5-dev\r\n# /usr/share/doc/libqt5svg5-dev/copyright\r\n# /usr/lib/x86_64-linux-gnu/libQt5Svg.so \r\n# /usr/share/doc/libqt5svg5-dev/changelog.Debian.gz\r\n```\r\n\r\n\r\n**设定环境变量**\r\n根据上一步的输出可以推测出\r\n  * **头文件所在目录(XXX.h所在目录)** 和\r\n  * **库文件所在目录(XXX.so所在目录)**\r\n```bash\r\nexport Qt5Svg_CFLAGS=/usr/include/x86_64-linux-gnu/qt5/QtSvg\r\nexport Qt5Svg_LIBS=/usr/lib/x86_64-linux-gnu\r\n```\r\n\r\n**重新执行**\r\n```bash\r\n./configure\r\n```\r\n\r\n\r\n\r\n## ubuntu安装xfce4并配置xrdp过程记录\r\n当前ubuntu22.04的图像界面是gnome 而xrdp对gnome支持并不好 所以安装xfce4的图像界面\r\n\r\n### 安装及配置\r\n\r\n**安装xrdp**\r\n```\r\nsudo apt-get install xrdp\r\n```\r\n**安装xfce4**\r\n```\r\nsudo apt-get install xfce4\r\n```\r\n\r\n**配置xrdp开机自启动**\r\n```\r\n# xrdp xrdp的守护进程\r\nsudo service xrdp restart\r\nsudo systemctl enable xrdp\r\n# xrdp-sesman 会话管理的守护进程\r\nsudo service xrdp-sesman restart\r\nsudo systemctl enable xrdp-sesman\r\n```\r\n\r\n**配置 `xrdp` 的 `/etc/xrdp/startwm.sh`**\r\n```\r\n# 注释掉原先配置\r\n# test -x /etc/X11/Xsession && exec /etc/X11/Xsession\r\n# exec /bin/sh /etc/X11/Xsession\r\n\r\n# 添加新配置用于启动xfce4\r\nstartxfce4\r\n```\r\n**由于xrdp远程连接创建后，对登录使用的账户不知道该启动哪个桌面Session会话导致闪退,需手动创建**\r\n```\r\n# vi ~/.xsession\r\n# xfce4桌面\r\necho xfce4-session > ~/.xsession\r\n```\r\n\r\n\r\n### 在xfce中不能打开终端的解决\r\n\r\n**安装xfce4-terminal**\r\n```\r\nsudo apt install xfce4-terminal\r\n```\r\n**修改默认xfce4的默认terminal**  \r\n鼠标右键->`applications`->运行程序->输入：`xfce4-settings-manager`-> 找到:`默认应用程序` -> 工具 -> 修改默认terminal为**xfce终端**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## ubuntu安装gnome并配置xrdp过程记录\r\n\r\n### 安装及配置\r\n\r\n\r\n**重新安装gnome使其自动解决依赖问题自动安装未安装的工具插件**\r\n```\r\nsudo apt-get install gnome\r\n```\r\n\r\n**安装xrdp**\r\n```\r\nsudo apt-get install xrdp\r\n```\r\n\r\n\r\n**配置xrdp开机自启动**\r\n```\r\n# xrdp xrdp的守护进程\r\nsudo service xrdp restart\r\nsudo systemctl enable xrdp\r\n# xrdp-sesman 会话管理的守护进程\r\nsudo service xrdp-sesman restart\r\nsudo systemctl enable xrdp-sesman\r\n```\r\n\r\n**配置 `xrdp` 的 `/etc/xrdp/startwm.sh`**\r\n```\r\n# 维持原先配置\r\ntest -x /etc/X11/Xsession && exec /etc/X11/Xsession\r\nexec /bin/sh /etc/X11/Xsession\r\n\r\n```\r\n\r\n**由于xrdp远程连接创建后，对登录使用的账户不知道该启动哪个桌面Session会话导致闪退,需手动创建**\r\n```\r\n# vi ~/.xsession\r\n# Unity 桌面(老版本)\r\necho unity> ~/.xsession\r\n \r\n# ubuntu-desktop 原始桌面\r\necho gnome-session > ~/.xsession\r\n```\r\n\r\n\r\n### 解决“色彩管理设备” 弹窗\r\n\r\n**创建文件 `/etc/polkit-1/localauthority/50-local.d/45-allow-colord.pkla`**\r\n\r\n**并写入内容：**\r\n```\r\n[Allow Colord all Users]\r\nIdentity=unix-user:*\r\nAction=org.freedesktop.color-manager.create-device;org.freedesktop.color-manager.create-profile;org.freedesktop.color-manager.delete-device;org.freedesktop.color-manager.delete-profile;org.freedesktop.color-manager.modify-device;org.freedesktop.color-manager.modify-profile\r\nResultAny=no\r\nResultInactive=no\r\nResultActive=yes\r\n```\r\n\r\n\r\n### 解决“刷新系统软件源需要认证” / “refresh the system repositories” 弹窗\r\n\r\n**创建文件 `/etc/polkit-1/localauthority/50-local.d/46-allow-packagekit.pkla`**\r\n\r\n**并写入内容：**\r\n```\r\n[Allow Refresh Repository all Users]\r\nIdentity=unix-user:*\r\nAction=org.freedesktop.packagekit.system-sources-refresh\r\nResultAny=no\r\nResultInactive=no\r\nResultActive=yes\r\n```\r\n\r\n\r\n### XRDP远程桌面连接Ubuntu后没有 Dock、桌面图标 背后的程序们\r\n\r\n各个扩展程序可在如下目录中看到\r\ncd /usr/share/gnome-shell/extensions/\r\n\r\n**安装并执行**\r\n```\r\nsudo apt-get install gnome-extensions-app \r\ngnome-extensions-app \r\n# 然后弹出的窗口中开启dock\r\n```\r\n\r\n\r\n### 使用默认桌面配置\r\n**添加配置文件`~/.xsessionrc`**\r\n```bash\r\nexport GNOME_SHELL_SESSION_MODE=ubuntu\r\nexport XDG_CURRENT_DESKTOP=ubuntu:GNOME\r\nexport XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg\r\n```"},{"shortInfo":{"title":"ubuntu下配置xRDP过程记录","date":"2022-08-11T22:55:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["ubuntu","xRDP"],"hideAtIndex":true,"categories":"笔记","id":392422391,"countWords":951,"readSeconds":95.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# ubuntu下配置xRDP过程记录\r\n\r\n## xRDP\r\n* RDP是windows系统下默认的远程桌面协议 默认端口3389\r\n* VNC是linux系统下默认的远程桌面协议 默认端口5900\r\n* **xRDP**是RDP的开源版本 \r\n  * 安装xRDP的linux可以通过windows原生的远程桌面连接程序MSTSC建立远程连接，\r\n  * 于是市面上一系列用于远程登录windows的手机端app和PC端应用程序也可用于登陆linux\r\n\r\n\r\n## 通过命令安装\r\n```shell\r\nsudo apt install  xrdp\r\n```\r\n\r\n## 添加用户到组\r\n```shell\r\n默认情况下，Xrdp 使用 /etc/ssl/private/ssl-cert-snakeoil.key 仅“ssl-cert” 用户组可读\r\nsudo adduser 用户名 ssl-cert\r\n或\r\nsudo usermod 用户名 -G ssl-cert\r\n```\r\n\r\n## 配置服务\r\n**配置文档/etc/xrdp/xrdp.ini**\r\nxrdp.ini 关键部分在globals\r\n```conf\r\n[globals]\r\nbitmap_cache=yes       #位图缓存\r\nbitmap_compression=yes #位图压缩\r\nport=3389              #监听端口\r\ncrypt_level=low        #加密程度（none为不加密 low为40位，默认为high 128位，medium为双40位）\r\nchannel_code=1         #????\r\n```\r\n**配置文档/etc/xrdp/sesman.ini**\r\n```conf\r\n[Globals]\r\nListenAddress=127.0.0.1      #监听ip地址(默认即可)\r\nListenPort=3350              #监听端口(默认即可)\r\nEnableUserWindowManager=1    #1为开启,可让用户自定义自己的启动脚本\r\nUserWindowManager=startwm.sh\r\nDefaultWindowManager=startwm.sh\r\n \r\n[Security]\r\nAllowRootLogin=1              #允许root登陆\r\nMaxLoginRetry=4               #最大重试次数\r\nTerminalServerUsers=tSUSErs   #允许连接的用户组(如果不存在则默认全部用户允许连接)\r\nTerminalServerAdmins=tsadmins #允许连接的超级用户(如果不存在则默认全部用户允许连接)\r\n \r\n[Sessions]\r\nMaxSessions=10           #最大会话数\r\nKillDisconnected=0       #是否立即关闭断开的连接(如果为1,则断开连接后会自动注销)\r\nIdleTimeLimit=0          #空闲会话时间限制(0为没有限制)\r\nDisconnectedTimeLimit=0  #断开连接的存活时间(0为没有限制)\r\n \r\n[Logging]\r\nLogFile=./sesman.log     #登陆日志文件\r\nLogLevel=DEBUG           #登陆日志记录等级(级别分别为,core,error,warn,info,debug)\r\nEnableSyslog=0           #是否开启日志\r\nSyslogLevel=DEBUG        #系统日志记录等级\r\n```\r\n\r\n## 启动服务\r\n```shell\r\nsudo systemctl enable xrdp\r\nsudo service xrdp start\r\n```\r\n\r\n<!-- \r\n\r\n\r\n## 通过源码编译安装安装\r\n```shell\r\n# 在github上下载\r\nwget https://github.com/neutrinolabs/xrdp/releases/download/v0.9.19/xrdp-0.9.19.tar.gz\r\n# 解压\r\ntar -xvf xrdp-0.9.19.tar.gz\r\n# \r\ncd ./xrdp-0.9.19\r\n\r\n\r\n# 略： 刚发现详细安装过程github的wiki上都有\r\n``` \r\n\r\n-->\r\n\r\n\r\n\r\n\r\n## 构建、编译、安装 pulseaudio 模块 实现音频重定向\r\ndata：2022-08-15\r\n**获得的构建文件**\r\n根据官方wiki文章[《Build-on-Debian-or-Ubuntu（在 Debian 或 Ubuntu 上构建）》](https://github.com/neutrinolabs/pulseaudio-module-xrdp/wiki/Build-on-Debian-or-Ubuntu)可知，**获得的文件构建**有**两种方式**，\r\n* 一种是从 pulseaudio 服务器构建中提取内部开发文件，或执行脚本 『暂不使用这种方式』\r\n* 另一方种方式是直接下载已经构建好的文件[pulseaudio-headers-xrdb](https://github.com/lnee94/pulseaudio-headers-xrdb/releases/tag/v1.0)并通过命令安装`pkg -i pulseaudio-headers-xrdb.deb`,将会解压到目录`/opt/pulseaudio-headers-xrdb/`\r\n\r\n```bash\r\ncd ~\r\nwget https://github.com/lnee94/pulseaudio-headers-xrdb/releases/download/v1.0/pulseaudio-headers-xrdb.deb\r\npkg -i pulseaudio-headers-xrdb.deb\r\n```\r\n\r\n**编译 xrdp pulseaudio 模块**\r\n```bash\r\n# 编译构建 pulseaudio 模块本身需要一些构建工具和包开发工具\r\nsudo apt install build-essential dpkg-dev libpulse-dev git autoconf libtool\r\n\r\ncd ~\r\ngit clone https://github.com/neutrinolabs/pulseaudio-module-xrdp.git\r\ncd pulseaudio-module-xrdp\r\n\r\n./bootstrap && ./configure PULSE_DIR=/opt/pulseaudio-headers-xrdb/\r\nmake\r\n```\r\n\r\n**安装 xrdp pulseaudio 模块**\r\n```bash\r\ncd pulseaudio-module-xrdp\r\nsudo make install\r\n\r\n# 该命令执行后，\r\n# 构建的模块将被安装在正确的目录\r\n# 同时：a script load_pa_modules.sh to load the modules when a session is started. On many systems this script is installed by default in /usr/libexec/pulseaudio-module-xrdp/\r\n# 同时：Install a desktop file pulseaudio-xrdp.desktop which will call the load_pa_modules.sh script when a desktop is loaded. On many systems this script is installed by default in /etc/xdg/autostart\r\n```\r\n\r\n\r\n**确认是否安装成功**\r\n```\r\nls $(pkg-config --variable=modlibexecdir libpulse) | grep xrdp\r\n# 输出结果中应当包含\r\n# module-xrdp-sink.so\r\n# module-xrdp-source.so\r\n```\r\n"},{"shortInfo":{"title":"ubuntu配置code-server过程记录","date":"2022-08-09T08:17:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["code-server","ubuntu"],"hideAtIndex":true,"categories":"笔记","id":2757682311,"countWords":265,"readSeconds":26.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# ubuntu配置code-server过程记录\r\n**完整过程**\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n## 或者在pc端下载好了之后通过sftp传输\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64.tar.gz\r\n# 递归创建文件夹\r\nmkdir -p ~/.local/lib ~/.local/bin\r\n# 移动并改名\r\nmv ./code-server-4.5.1-linux-amd64 ~/.local/lib/code-server-4.5.1/\r\n# 建立软连接\r\nln -s ~/.local/lib/code-server-4.5.1/bin/code-server ~/.local/bin/code-server\r\n# 添加到环境变量\r\nPATH=\"~/.local/bin:$PATH\"\r\n# 运行\r\ncode-server \r\n```\r\n\r\n**编辑配置文件修改密码**\r\n```bash\r\ncat > ~/.config/code-server/config.yaml <<EOF\r\nbind-addr: 0.0.0.0:8080\r\nauth: password\r\npassword: *****数字加英文*****\r\ncert: false\r\nEOF\r\n```\r\n\r\n**配置自动添加环境变量**\r\n```bash\r\nvim  .profile\r\nPATH=\"~/.local/bin:$PATH\"\r\n```\r\n\r\n\r\n**配置服务**\r\n**若是通过`dpkg -i code-server-4.5.1-linux-amd64.deb` 这种安装方式安装的,服务配置文件`code-server.service`会被自动配置好,只需要执行:**\r\n```bash\r\n# 启动服务\r\nsystemctl start code-server@用户名.service\r\n# 添加到开机自启动\r\nsystemctl enable code-server@用户名.service\r\n```"},{"shortInfo":{"title":"wite构建工具学习","date":"2022-11-28T12:00:00.000Z","cover":"\\self_server\\assets\\images\\vite构建工具学习\\2022-12-04-01-30-16.png","tags":["笔记"],"categories":"笔记","hideAtIndex":true,"id":4170453952,"countWords":1882,"readSeconds":188.2,"assetsbaseUrl":"/self_server/assets/"},"content":"<!-- ![](./images/vite构建工具学习/2022-12-04-01-30-16.png) -->\r\n\r\n# wite构建工具学习\r\n## 目录\r\n- [wite构建工具学习](#wite构建工具学习)\r\n  - [目录](#目录)\r\n  - [脚手架`create-vite`与构建工具`vite`的区别](#脚手架create-vite与构建工具vite的区别)\r\n  - [配置文件`vite.config.js`](#配置文件viteconfigjs)\r\n    - [指定配置文件](#指定配置文件)\r\n    - [编写配置文件](#编写配置文件)\r\n    - [使配置文件支持语法提示](#使配置文件支持语法提示)\r\n  - [选项式配置vite](#选项式配置vite)\r\n  - [环境变量](#环境变量)\r\n    - [`.env`文件](#env文件)\r\n    - [`mode`模式](#mode模式)\r\n    - [正确的使用](#正确的使用)\r\n    - [`实际的dotenv`与`vite中的dotenv`](#实际的dotenv与vite中的dotenv)\r\n\r\n\r\n## 脚手架`create-vite`与构建工具`vite`的区别\r\n\r\n> 简单来说，脚手架就是一个模板，是一个写好的HelloWorld项目，该项目使用vite构建，有基本的约定俗成目录结构和一些基本的vite配置\r\n\r\n**安装脚手架，并通过脚手架创建项目**\r\n```bash\r\nyarn create vite \r\nnpm create vite\r\n# 帮我们全局安装一个东西: create-vite (vite的脚手架)\r\n# 直接运行这个create-vite bin目录的下的一个执行配置\r\n```\r\n\r\n**安装构建工具**\r\n```bash\r\nnpm install vite -D # 在开发环境安装vite\r\n```\r\n\r\n## 配置文件`vite.config.js`\r\n\r\n### 指定配置文件\r\n```bash\r\n# 通过--config指定vite配置文件的文件名\r\nvite --config custom-config.js\r\n\r\n# 默认配置文件为执行该命令目录下的vite.config.js\r\nvite\r\n```\r\n\r\n### 编写配置文件\r\n```js\r\n// vite.config.js\r\nexport default {\r\n  // 配置选项，直接默认导出一个配置对象即可\r\n}\r\n```\r\n\r\n### 使配置文件支持语法提示\r\n\r\n方法一：通过`jsdoc`注释配合`IDE`完成\r\n\r\n原理：`UserConfig`是用`typeScript`定义的接口类,包含了支持的各个字段的名称和类型信息\r\n```js\r\n/** @type {import('vite').UserConfig} */\r\nexport default {\r\n  // ...\r\n}\r\n```\r\n\r\n方法二：使用 `defineConfig` 工具函数\r\n原理：`defineConfig` 函数接收一个对象并返回这个对象本身，接收的对象类型是`UserConfigExport = UserConfig` 而`UserConfig`是在`ts`中定义的接口对象\r\n```js\r\n\r\nimport { defineConfig } from 'vite'\r\n\r\nexport default defineConfig({\r\n  // ...\r\n})\r\n```\r\n\r\n## 选项式配置vite\r\n> 根据不同的环境配置vite,\r\n> * 如希望在开发环境启用sourceMap,用于方便定位报错所在行数，在生产环境关闭sorceMap\r\n> * 如希望在开发环境开启代理服务器，访问本地服务器，而在生产环境则不用这样的配置\r\n\r\n**三个配置文件（文件名任意）**\r\n* `vite.base.config` 基本环境vite配置\r\n* `vite.dev.config`  开发环境vite配置\r\n* `vite.prod.config` 生产环境vite配置\r\n* `vite.config` 用于根据环境启用上述三个配置文件\r\n\r\n**编写配置文件**  \r\n`vite.base.config.js`  \r\n`vite.dev.config.js`  \r\n`vite.prod.config.js`  \r\n```js\r\nimport { defineConfig } from 'vite'\r\n\r\nexport default defineConfig({\r\n  // ... 正常写的配置文件\r\n})\r\n```\r\n\r\n`vite.config.js`\r\n```js\r\nimport {defineConfig} from \"vite\";\r\nimport viteBaseConfig from \"./vite.base.config\";// 基本环境vite配置\r\nimport viteDevConfig  from \"./vite.dev.config\"; // 开发环境vite配置\r\nimport viteProdConfig from \"./vite.prod.config\";// 生产环境vite配置\r\n\r\n// 策略模式\r\nconst envResolver = {\r\n    \"build\":{ ...viteBaseConfig, ...viteProdConfig }, // 对象式写法,覆盖base中的配置\r\n    \"serve\":{ ...viteBaseConfig, ...viteProdConfig },\r\n    // \"build\": () => {\r\n    //     console.log(\"当前在生产环境\");\r\n    //     return ({ ...viteBaseConfig, ...viteProdConfig }) // 函数式写法，返回对象\r\n    // },\r\n}\r\nexport default defineConfig(({ command, mode }) => {\r\n    // 当执行命名： vite 或 vite dev 或 vite serve 时 command 的值为 serve\r\n    // 当执行命名： vite build 时 command的值为 build\r\n    // 根据源码，command只有两种可能的取值: 'build' | 'serve';\r\n    return envResolver[command];\r\n})\r\n```\r\n\r\n> 为什么可以传递一个函数到defineConfig？   \r\n> 根据下列源码可知， `defineConfig` 可以接收一个函数，该函数会接收三个参数： `command` `mode` `ssrBuild`\r\n```ts\r\nexport declare function defineConfig(config: UserConfigExport): UserConfigExport;\r\nexport declare type UserConfigExport = UserConfig | Promise<UserConfig> | UserConfigFn;\r\nexport declare type UserConfigFn = (env: ConfigEnv) => UserConfig | Promise<UserConfig>;\r\nexport declare interface ConfigEnv {\r\n    command: 'build' | 'serve';\r\n    mode: string;\r\n    ssrBuild?: boolean; // 实验性功能\r\n}\r\n```\r\n\r\n\r\n## 环境变量\r\n这里的`环境`变量是指\r\n1. 开发环境\r\n2. 测试环境\r\n3. 预发布环境\r\n4. 灰度环境\r\n5. 生产环境\r\n\r\n> 不同的`环境`需要用到不同的`变量`,  \r\n> 如在写axios的baseURL时，开发环境填写的地址和生产环境填写的地址是不一样的\r\n\r\n\r\n### `.env`文件\r\n默认情况下，Vite 使用 第三方插件`dotenv` 将项目根目录下的下列文件中定义的环境变量，挂载到`import.meta.env`上\r\n```bash\r\n.env                # 所有情况下都会加载\r\n.env.local          # 所有情况下都会加载，但会被 git 忽略（因为脚手架自带的.gitignore文件中有配置）\r\n.env.[mode]         # 只在指定模式下加载\r\n.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略，存一些敏感信息，如数据库密码\r\n```\r\n\r\n### `mode`模式\r\n```bash\r\n# serve和build的默认模式分别为development和production：\r\nvite serve --mode development\r\nvite build --mode production\r\n```\r\n\r\n### 正确的使用\r\n```js\r\nvar env = import.meta.env // import.meta.env将被替换成一个{key:value}的字面量对象\r\nvar baseUrl = env.baseUrl // 正确使用\r\n\r\n// 错误使用,在生产环境中，这些环境变量会在构建时被静态替换\r\nvar baseUrl = import.meta.env['baseUrl']\r\n```\r\n\r\n### `实际的dotenv`与`vite中的dotenv`\r\n\r\n**`实际的dotenv`的执行过程**\r\n\r\ndotenv会自动读取`.env`文件, 解析这个文件中的对应环境变量，并将其注入到`process`对象下\r\n```js\r\nimport {resolve} from 'path'\r\nvar dotenv = require('dotenv') \r\ndotenv.config()\r\nconsole.log(process.env);\r\n```\r\n\r\n\r\n**`vite中的dotenv`的执行过程**\r\n* 但在vite项目中，`dotenv`解析到的环境变量不会直接注入到`process.env`对象下 \r\n* 因为在网页中根本无法访问到`process`这个变量，\r\n* 所以他实际是注入到`import.meta.env`变量上，在生产环境，该变量会被替换为对象字面量\r\n* 在注入的过程中，vite默认还会做一次拦截，如果你的环境变量不是以`VITE`开头的, 他就不会帮你注入到客户端中去\r\n* vite给我们提供了一些补偿措施:我们可以调用`vite`的`loadEnv`来手动确认`env`文件\r\n\r\n\r\n手动加载`.env`\r\n```js\r\nimport {defineConfig} from \"vite\";\r\nimport viteBaseConfig from \"./vite.base.config\";\r\nimport viteDevConfig  from \"./vite.dev.config\";\r\nimport viteProdConfig from \"./vite.prod.config\";\r\n\r\n// 策略模式\r\nconst envResolver = {\r\n    \"build\":{ ...viteBaseConfig, ...viteProdConfig },\r\n    \"serve\":{ ...viteBaseConfig, ...viteProdConfig },\r\n}\r\nexport default defineConfig(({ command, mode }) => {\r\n    // 手动加载环境变量,\r\n        //参数一用来确定加载哪一个文件\r\n        //参数二相当于配置 envDir \r\n        //参数三相当于配置 envPrefix\r\n  var envs = loadEnv(mode,process.cwd(),\"Public_\");\r\n    return envResolver[command];\r\n})\r\n```\r\n\r\n通过配置`vite`自动加载`.env`\r\n```js\r\n/**\r\n * @type {import 'vite'.UserConfig}\r\n */\r\nexport default defineConfig({\r\n    // 环境变量配置文件所在目录,默认值为'./'\r\n    envDir:\"./\", \r\n    \r\n    // 指定仅当以下划线开头的环境变量才会暴露到客户端 默认为VITE\r\n    envPrefix:\"_\"\r\n  })\r\n```\r\n\r\n\r\n**几个环境变量文件**\r\n* `.env`: 所有环境都需要用到的环境变量\r\n* `.env.development`: 开发环境需要用到的环境变量(默认情况下vite将我们的开发环境取名为development)\r\n* `.env.production`: 生产环境需要用到的环境变量(默认情况下vite将我们的生产环境取名为production)\r\n\r\n**`loadenv`执行过程**\r\n当我们调用`loadenv`的时候, 他会做如下几件事:\r\n1. 直接找到`.env`文件不解释 并解析其中的环境变量 并放进一个对象里\r\n2. 会将传进来的mode这个变量的值进行拼接: ```.env.development```,  并根据我们提供的目录去取对应的配置文件并进行解析, 并放进一个对象\r\n3. 我们可以理解为\r\n   ```js\r\n    const baseEnvConfig = 读取.env的配置\r\n    const modeEnvConfig = 读取env相关配置\r\n    const lastEnvConfig = { ...baseEnvConfig, ...modeEnvConfig }\r\n   ```\r\n\r\n\r\n\r\n\r\n\r\n<style>\r\n    gold{\r\n        color:black;\r\n        background-color:gold;\r\n    }\r\n    green{\r\n        color:white;\r\n        background-color:green;\r\n    }\r\n    warn{\r\n        color:white;\r\n        background-color:red;\r\n    }\r\n</style>"},{"shortInfo":{"layout":"post","title":"vscode操作备忘笔记","date":"2022-01-09T12:28:00.000Z","cover":"\\self_server\\assets\\images\\vscode.webp","tags":["笔记","vscode"],"hideAtIndex":true,"categories":"笔记","id":469689991,"countWords":2261,"readSeconds":226.1,"assetsbaseUrl":"/self_server/assets/"},"content":"## vscode操作备忘笔记\r\n### 面板\r\n1. 命令面板是vscode快捷键的主要交互界面，可以使用f1或者Cmd+Shift+P(win Ctrl+Shift+P)打开。\r\n>在命令面板中你可以输入命令进行搜索(中英文都可以)，然后执行。\r\n命名面板中可以执行各种命令，包括编辑器自带的功能和插件提供的功能。\r\n所以一定要记住它的快捷键Cmd+Shift+P\r\n2. 搜索面板CTRL+E、R、P 打开文件或切换工作目录\r\n\r\n### 注释\r\n* 注释选中行 ctrl+/\r\n* 注释选中代码块 alt + shift + a\r\n\r\n### 代码格式化\r\n* 对选中代码格式化 ？？？？？？？\r\n* 对整个文件格式化 ctrl + shift + f 苹果：Option+Shift+F\r\n\r\n### 代码缩进\r\n* 对个文档进行缩进调节，使用Cmd+Shift+P打开命令面板，输入缩进,然后选择相应的命令\r\n* 对选中代码缩进调节：ctrl+] ctrl+[ 苹果：Cmd+] Cmd+[ \r\n\r\n### 一些小技巧\r\n* 调整选中代码的大小写 选中后在命令面板输入转化为大写或者转化为小写的中文或英文\r\n* 合并代码行，多行代码合并为一行，Cmd+J(win下未绑定\r\n* 对选中的代码行排序 调出命令面板，输入按升序排序或者按降序排序\r\n\r\n### 光标操作\r\n* 基础\r\n    1. 以单词为单位移动光标：windows中：CTRL+左右方向键\r\n    1. 鼠标滚轮效果：windows中：CTRL+上下方向键\r\n    1. 移动到行首 windows中：Home键 苹果中：Cmd+左方向键\r\n    1. 移动到行尾 windows中：end键 苹果中：Cmd+右方向键\r\n    1. 移动到文档的开头和末尾 windows中： Ctrl+Home/End 苹果中：Cmd+上下方向键\r\n* 进阶\r\n    1. 回到上一个光标的位置，win Ctrl+U(mac：Cmd+U) \r\n    1. 在不同的文件之间回到上一个光标的位置 win Ctrl+shift+U\r\n* 文本选择\r\n    1. 在光标移动的时候多按一个shift键就可以选中文本\r\n    1. 选中单词 Cmd+D\r\n* 删除\r\n    1. 选中代码之后再按删除\r\n    1. 删除当前行Ctrl+Shift+K Cmd+Shift+K\r\n* 代码移动 \r\n    1. 剪切移动Alt+上下 苹果：Option+上下方向键\r\n    2. 复制移动Alt+shift+上下 苹果：Option+Shift+上下\r\n\r\n### 多光标特性\r\n使用鼠标：按住Option(win Alt),然后用鼠标点，鼠标点在哪里哪里就会出现一个光标\r\n注意：有的mac电脑上是按住Cmd，然后用鼠标点才可以\r\n\r\n### 选中单词\r\nCmd+D (win Ctrl+D) 第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它。(注：cmd-k cmd-d 跳过当前的选择)\r\n\r\n### 在每行末尾添加光标\r\n首先你要选中多行代码，然后按Alt+Shift+i(苹果：Option+Shift+i),这样做的结果是：每一行后面都会多出来一个光标 Option+Shift+i\r\n\r\n### 撤销多光标\r\n使用Esc 或鼠标点击一下\r\n\r\n### 快速打开文件\r\nCmd+P （win Ctrl+P）输入你要打开的文件名,回车打开\r\n\r\n这里有个小技巧，选中你要打开的文件后，按Cmd+Enter,就会在一个新的编辑器窗口打开\r\n\r\n### 在tab不同的文件间切换，\r\nWindows：？？？ 苹果：cmd+shift+[] \r\n\r\n### 行跳转\r\n假如浏览器报了个错，错误在53行，如何快速跳转到53行\r\nCtrl+g 输入行号\r\n\r\n### 文件行跳转\r\n如果你想跳转到某个文件的某一行，你只需要先按下 “Cmd + P”，输入文件名，然后在这之后加上 “:”和指定行号即可。\r\n\r\n### 符号跳转\r\n符号可以是文件名、函数名，可以是css的类名\r\nCmd+Shift+O(win Ctrl+Shift+o) 输入你要跳转的符号，回车进行跳转\r\n\r\nwin下输入Ctrl+T，可以在不同文件的符号间进行搜索跳转\r\n\r\n\r\n\r\n### 定义(definition)和实现(implementation)处\r\nf12跳到函数的定义处\r\nCmd+f12(win Ctrl+f12)跳转到函数的实现处\r\n\r\n### 引用跳转\r\n很多时候，除了要知道一个函数或者类的定义和实现以外，你可能还希望知道它们被谁引用了，以及在哪里被引用了。这时你只需要将光标移动到函数或者类上面，然后按下 Shift + F12，VS Code 就会打开一个引用列表和一个内嵌的编辑器。在这个引用列表里，你选中某个引用，VS Code 就会把这个引用附近的代码展示在这个内嵌的编辑器里。\r\n\r\n### 代码重构\r\n当我们想修改一个函数或者变量的名字时候，我们只需把光标放到函数或者变量名上，然后按下 F2，这样这个函数或者变量出现的地方就都会被修改。\r\n\r\n### 一些插件\r\n1. 万能语言运行环境 （Code Runner）：\r\n > 如果你需要学习或者接触各种各样的开发语言，那么 Code Runner 插件可以让你不用搭建各种语言的开发环境，直接通过此插件就可以直接运行对应语言的代码，非常适合学习或测试各种开发语言。\r\n支持的语言有：C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script, C# (.NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, 以及一些自定义的命令。\r\n\r\n2. 快速注释（ Document This）：优秀的代码除了优秀的性能、规范的格式，注释也是不可或缺的，而且注释也应该有一套标准的注释方法，特别对于 JavaScript 这种语言。Document This 可以快速地帮你生成注释，如一些函数的注释还能帮你抽取出参数的定义等，是你编写规范代码必备的工具。Document This目前仅支持JavaScript和TypeScript。\r\n\r\n3. CSS 类名智能提示（HTML CSS Support）：它会提示一些类名供你选择。\r\n\r\n4. 代码拼写检查（Code Spell Checker）：此插件安装后就不用管就好了，在你代码中有单词拼写错误时，你就会发现它的好处，因为我们写代码毕竟都是大量的英文单词变量定义，插件还可以给出错误拼写单词的建议。如果单词有错下面就会出现波浪线。\r\n\r\n5. 备忘插件（TODO Highlight）：在很多的其他代码编辑器中都有 TODO 标注功能的，如你写到某一部分的代码时，其中部分的功能需要稍后再来实现，这是就可以在对应的代码处添加一个 TODO 类型的注释，那么后期就可以快速地跳转到这部分继续写，而且当项目很大的时候，TODO 就变得更加有用，因为有时候 TODO 可能有几十个，帮助你标注那些功能需要继续实现或优化。\r\n\r\n6. 自动重命名标签（Auto Rename Tag）：这个插件对你的标签修改起来一个很大的作用，当你修改起始标签的时候，结束标签也会随着起始标签的修改而修改\r\n\r\n7. html模板（HTML Boilerplate）：就是一个很标准html5的模板插件，兼容新老版浏览器。\r\n\r\n8. 代码格式化（Prettier - Code formatter）\r\n\r\n9. 颜色提示（Color Info）\r\n\r\n10. 自动闭合标签（Auto Close Tag）：安装了这个插件后，如果你的起始标签不小心删除的结束标签，只要打 </ 就会自动补全，根据就近原则，一次只能补全一个标签。\r\n\r\n\r\n## 预定义变量列表\r\n- `${workspaceFolder}` -在 VS Code 中打开的文件夹的路径\r\n- `${workspaceFolderBasename}` -在 VS Code 中打开的文件夹名称，不带任何斜杠（/）\r\n- `${file}` -当前打开的文件\r\n- `${relativeFile}` -当前相对于打开的文件 workspaceFolder\r\n- `${relativeFileDirname}` -当前打开文件的目录名，相对于 workspaceFolder\r\n- `${fileBasename}` -当前打开的文件的基本名称\r\n- `${fileBasenameNoExtension}` -当前打开的文件的基本名称，没有文件扩展名\r\n- `${fileDirname}` -当前打开的文件的目录名\r\n- `${fileExtname}` -当前打开的文件的扩展名\r\n- `${cwd}` -启动时任务运行器的当前工作目录\r\n- `${lineNumber}` -活动文件中当前选择的行号\r\n- `${selectedText}` -活动文件中的当前选定文本\r\n- `${execPath}` -正在运行的 VS Code 可执行文件的路径\r\n- `${defaultBuildTask}` -默认构建任务的名称\r\n\r\n## 预定义变量的例子\r\n### vscode 的当前状态\r\n|            描述            |                       路径                       |\r\n| :------------------------: | :----------------------------------------------: |\r\n|   当前打开工作区的路径。   |         /home/your-username/your-project         |\r\n| 当前编辑器打开的文件路径。 | /home/your-username/your-project/folder/file.ext |\r\n\r\n### 预定义变量值列表\r\n| 变量                         | 值                                               |\r\n| :--------------------------- | :----------------------------------------------- |\r\n| `${workspaceFolder}`         | /home/your-username/your-project                 |\r\n| `${workspaceFolderBasename}` | your-project                                     |\r\n| `${file}`                    | /home/your-username/your-project/folder/file.ext |\r\n| `${relativeFile}`            | folder/file.ext                                  |\r\n| `${relativeFileDirname}`     | folder                                           |\r\n| `${fileBasename}`            | file.ext                                         |\r\n| `${fileBasenameNoExtension}` | file                                             |\r\n| `${fileDirname}`             | /home/your-username/your-project/folder          |\r\n| `${fileExtname}`             | .ext                                             |\r\n| `${lineNumber}`              | 光标的行号                                       |\r\n| `${selectedText}`            | 在代码编辑器中选择的文本                         |\r\n| `${execPath}`                | Code.exe 的位置                                  |"},{"shortInfo":{"title":"vue3_blog项目笔记","date":"2022-10-19T11:23:00.000Z","cover":"\\self_server\\assets\\images\\vue3_blog项目笔记\\default_cover2.jpg","tags":["vue3","blog"],"categories":"笔记","imageMin":true,"id":1876821530,"countWords":5013,"readSeconds":501.3,"assetsbaseUrl":"/self_server/assets/"},"content":"## 目录\r\n- [目录](#目录)\r\n- [导航条毛玻璃效果实现](#导航条毛玻璃效果实现)\r\n- [图片背景实现](#图片背景实现)\r\n- [封面文字动态输入效果实现](#封面文字动态输入效果实现)\r\n- [为数字添加单位函数实现](#为数字添加单位函数实现)\r\n- [分页器实现](#分页器实现)\r\n- [滚动事件切换类名animate改变封面高度](#滚动事件切换类名animate改变封面高度)\r\n- [文章页Markdown内容的渲染](#文章页markdown内容的渲染)\r\n- [filter实现文章页封面效果](#filter实现文章页封面效果)\r\n- [vue中hash路由与markdown中锚点链接冲突的解决及链接跳转的实现](#vue中hash路由与markdown中锚点链接冲突的解决及链接跳转的实现)\r\n- [markdown中script标签内代码不执行问题的解决](#markdown中script标签内代码不执行问题的解决)\r\n- [使markdown中script标签支持jQuery(`$`)语法](#使markdown中script标签支持jquery语法)\r\n- [使markdown支持渲染KaTex语法数学公式及复制KaTex源代码](#使markdown支持渲染katex语法数学公式及复制katex源代码)\r\n- [归档页github风格代码贡献统计效果的组件实现](#归档页github风格代码贡献统计效果的组件实现)\r\n- [将文章标题字符串计算HASH作为ID](#将文章标题字符串计算hash作为id)\r\n- [通过front-matter将markdown文章首部的yml格式信息获取](#通过front-matter将markdown文章首部的yml格式信息获取)\r\n- [在ECMAScript标准语法下获取`__filename`及`__dirname`](#在ecmascript标准语法下获取__filename及__dirname)\r\n- [文件枚举函数的实现和使用](#文件枚举函数的实现和使用)\r\n- [imagemin图像压缩](#imagemin图像压缩)\r\n- [通过axios请求拦截器为请求url地址params添加随机数防止浏览器缓存数据](#通过axios请求拦截器为请求url地址params添加随机数防止浏览器缓存数据)\r\n\r\n\r\n## 导航条毛玻璃效果实现\r\n\r\n![](./images/vue3_blog项目笔记/2022-10-19-06-24-02.png)\r\n\r\n```less\r\n//contrast对比度\r\n//saturate饱和度\r\n//blur() 模糊(像素)\r\n@backdrop_Filter:saturate(200%) contrast(80%) blur(20px);\r\n.cssName{\r\n    backdrop-filter: @backdrop_Filter;\r\n    -webkit-backdrop-filter: @backdrop_Filter;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n## 图片背景实现\r\n\r\n![](./images/vue3_blog项目笔记/2022-10-19-06-25-09.png)\r\n\r\n```html\r\n<template>\r\n  <img class=\"bg_img\" src=\"./images/1.jpg\" alt=\"\">\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'BackGround'\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.bg_img {\r\n  z-index: -999;//放到最底层\r\n  position: fixed;//相对浏览器窗口定位\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;//宽为视口宽度的100%\r\n  height: 100vh; //高度为100%视口宽度\r\n  object-fit: cover;//内容以封面方式适应盒子宽高\r\n  object-position: center top;//内容对齐方式，水平方向居中，垂直方向顶部对齐\r\n}\r\n</style>\r\n```\r\n\r\n\r\n## 封面文字动态输入效果实现\r\n\r\n![](./images/vue3_blog项目笔记/2022-10-19-06-25-50.png)\r\n\r\n<span id=\"span\" data-value=\"在绝望中坚持真理,在荒诞中奋起抵抗.\" ></span><span class=\"_\">_</span>\r\n<br>\r\n<button id=\"btn\">点击此处触发效果</button>\r\n<style>\r\n._{\r\n    display: inline-block;\r\n    margin-left: 5px;\r\n    animation: dash_flash 0.7s ease infinite;\r\n}\r\n@keyframes dash_flash {\r\n    /* 定义动画 */\r\n    from{opacity: 0;}\r\n    to{opacity: 1;}\r\n}\r\n#btn{\r\n    padding:5px;\r\n    background-color:white;\r\n    color:black;\r\n}\r\n</style>\r\n<script>\r\nlet span = document.querySelector(\"#span\")\r\nlet btn = document.querySelector(\"#btn\")\r\nbtn.addEventListener('click',async ()=>{\r\n    try{\r\n        await autoTyping(span,'',span.dataset['value'],150)\r\n        await waitMs(2000)\r\n        await autoBackSpacing(span,span.dataset['value'],'',50)\r\n    }catch(e){\r\n        console.log(e);\r\n    }\r\n})\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nasync function autoTyping(DomElement, start_TextString, ended_TextString, interval = 150) {\r\n    return new Promise(async (TypingResolve, TypingReject) => {\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce() {\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nasync function autoBackSpacing(DomElement, start_TextString, ended_TextString = '', interval = 150) {\r\n    return new Promise(async (BackSpaceResolve, BackSpaceReject) => {\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce() {\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText != ended_TextString) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0, DomElement.innerText.length - 1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nfunction waitMs(timeout) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n</script>\r\n\r\n\r\n\r\n```js\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nexport const autoTyping = async function (DomElement, start_TextString, ended_TextString, interval = 150) {\r\n    return new Promise(async (TypingResolve, TypingReject) => {\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce() {\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n\r\n\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nexport const autoBackSpacing = async function (DomElement, start_TextString, ended_TextString = '', interval = 150) {\r\n    return new Promise(async (BackSpaceResolve, BackSpaceReject) => {\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce() {\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText != ended_TextString) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0, DomElement.innerText.length - 1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nexport const waitMs = function (timeout) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n```\r\n\r\n\r\n## 为数字添加单位函数实现\r\n\r\n\r\n![](./images/vue3_blog项目笔记/2022-10-19-06-59-04.png)\r\n\r\n```js\r\n//使用\r\nlet result = getNumberWithUnit(12345,2);\r\nconsole.log(result) // 12.34k\r\n```\r\n\r\n```js\r\n/**\r\n * @param {数字} number 12345\r\n * @param {保留小数位数} Fixed 2\r\n * @returns 12.34k\r\n */\r\nexport function getNumberWithUnit(number, Fixed = 1) {\r\n    number = Number(number); //数值化\r\n    if (number == 0) return '0';//处理0\r\n    let sign = number > 0 ? '' : (number = - number, '-') //处理负数\r\n\r\n    let units = [//单位和进率 关系\r\n        { char: '' , multiple: 1     },\r\n        { char: 'k', multiple: 1000  },\r\n        { char: 'w', multiple: 10000 },\r\n    ];\r\n\r\n    let i = 0 ;\r\n    let unit = units[i];\r\n    for (; i < units.length; i++) {\r\n        if (number / units[i].multiple > 1) {\r\n            unit = units[i]\r\n            continue;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (unit == units[0]) {\r\n        return sign + number\r\n    } else {\r\n        return sign + (number / unit.multiple).toFixed(Fixed) + unit.char\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 分页器实现\r\n\r\n![](./images/vue3_blog项目笔记/2022-10-19-07-07-59.png)\r\n\r\n```html\r\n<!-- 使用 -->\r\n<Pagination :currentPage=\"pageRange_current\" :totalPage=\"pageRange_max\" :subPaginationSize=\"5\" @gotoPage=\"gotoPage\"></Pagination>\r\n<script>\r\nexport default {\r\n    methods: {\r\n        gotoPage(index) {\r\n            this.getHomeArticlesInfo(index);\r\n        }\r\n    },\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n  <div class=\"pagination\">\r\n    <a class=\"left\" @click=\"emitPages(currentPage-1)\">&lt;</a>\r\n    <a class=\"firstPage\" v-if=\"SubPagination.start_SubPagination != 1\" @click=\"emitPages(1)\">1</a>\r\n    <a class=\"dots\" v-if=\"SubPagination.start_SubPagination != 1\">...</a>\r\n    <a class=\"subPagination\" v-for=\"index in SubPagination.yieldRange\" :key=\"index\" :class=\"{'currentPage':index==currentPage}\" @click=\"emitPages(index)\"\r\n    >{{index}}\r\n    </a>\r\n    <a class=\"dots\" v-if=\"SubPagination.ended_SubPagination != totalPage\">...</a>\r\n    <a class=\"lastPage\" v-if=\"SubPagination.ended_SubPagination != totalPage\" @click=\"emitPages(totalPage)\">{{totalPage}}</a>\r\n    <a class=\"right\" @click=\"emitPages(currentPage+1)\">&gt;</a>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    name:'Pagination',\r\n    props:['currentPage','totalPage','subPaginationSize'],\r\n    emits:['gotoPage'],\r\n    methods:{\r\n        yieldRange(start,ended){//生成数组\r\n            let result = [];\r\n            if(start>ended) return result;\r\n            for(let i = start;i<=ended;i++){\r\n                result.push(i)\r\n            }\r\n            return result;\r\n        },\r\n        yieldSubPagination(currentPage){//计算页码\r\n            let start_SubPagination = currentPage - Number.parseInt(this.subPaginationSize/2);\r\n            let ended_SubPagination = currentPage + Number.parseInt(this.subPaginationSize/2);\r\n            if(start_SubPagination<=1) start_SubPagination = 1;\r\n            if(ended_SubPagination>=this.totalPage) ended_SubPagination = this.totalPage;\r\n            return {\r\n                start_SubPagination,\r\n                ended_SubPagination,\r\n                yieldRange:this.yieldRange(start_SubPagination,ended_SubPagination)\r\n            }\r\n        },\r\n        emitPages(newPage){\r\n            console.log(\"newPage:\",newPage);\r\n            console.log(\"totalPage:\",this.totalPage);\r\n            if(newPage>=1 && newPage <= this.totalPage){\r\n                this.$emit('gotoPage',newPage)\r\n            }\r\n        }\r\n    },\r\n    computed:{\r\n        SubPagination(){\r\n            return this.yieldSubPagination(this.currentPage)\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.pagination{\r\n    text-align: center;\r\n    margin: 20px;\r\n    a{\r\n        display: inline-block;\r\n        padding: 5px;\r\n        margin-right:5px;\r\n        margin-bottom:5px;\r\n        min-width: 50px;\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n\r\n## 滚动事件切换类名animate改变封面高度\r\n\r\n![](./images/vue3_blog项目笔记/d32023ri0fj234j003.gif)\r\n\r\n```html\r\n<template>\r\n    <div ref=\"cover\" class=\"cover\" :class=\"{\"small\":coverSmall}\" >\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { throttle } from 'lodash';\r\nexport default {\r\n    name: 'Cover',\r\n    data() {\r\n        return {\r\n            coverSmall:false,\r\n            updataSignThrottle:undefined,\r\n        }\r\n    },\r\n    computed: {\r\n    },\r\n    methods: {\r\n        updataSign_coverSmall(){\r\n            let newVal = window.pageYOffset\r\n            if(newVal>0 && this.coverSmall != true){\r\n                this.coverSmall = true\r\n                window.scroll(0, 0)\r\n            }else if(newVal<=0 && this.coverSmall != false){\r\n                this.coverSmall = false\r\n                window.scroll(0, 0)\r\n            }\r\n        },\r\n    },\r\n    mounted() {\r\n        this.updataSignThrottle = throttle(this.updataSign_coverSmall,50,{leading:true}) //节流,throttle返回一个带有节流功能的事件处理函数\r\n        window.addEventListener('scroll',this.updataSignThrottle)\r\n    },\r\n    beforeUnmount(){\r\n        window.removeEventListener('scroll',this.updataSignThrottle)//移除事件处理函数\r\n        console.log('removeEventListener');\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.cover {\r\n    width: 100%;\r\n    height: 75vh;\r\n    transition: height ease 1s ;\r\n    &.small{\r\n        height: 30vh;//改变高度\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n## 文章页Markdown内容的渲染\r\n*  Markdown的渲染器marked的配置\r\n* hljs代码高亮配置\r\n* Markdown的样式\r\n* hijs代码高亮样式配置\r\n* 资源相对路径修改\r\n\r\n![](./images/vue3_blog项目笔记/2022-10-19-07-50-41.png)\r\n\r\n```js\r\n// Create reference instance\r\nimport { marked } from 'marked';//markdown的渲染脚本\r\n\r\nimport hljs from 'highlight.js';//hijs的脚本\r\nimport './base16_dracula.min.css' //highlight的某个样式文件\r\nimport 'github-markdown-css/github-markdown-dark.css' //github风格的Markdown样式\r\n\r\nconst options = {\r\n  renderer: new marked.Renderer(),\r\n\r\n  langPrefix: 'hljs language-', // highlight.js css expects a top-level 'hljs' class.\r\n  highlight: function (code, lang) {\r\n    // ```lang\r\n    // code\r\n    // code\r\n    // code\r\n    // ```\r\n    const language = hljs.getLanguage(lang) ? lang : 'plaintext';\r\n    return hljs.highlight(code, { language:language }).value;\r\n  },\r\n  // baseUrl: //为所有相对路径添加的前缀\r\n  pedantic: false,// 只解析符合Markdwon定义的，不修正Markdown的错误\r\n  gfm: true,// 启动类似于Github样式的Markdown语法\r\n  breaks: false,\r\n  sanitize: false,//原始输出，忽略HTML标签（关闭后，可直接渲染HTML标签）\r\n  smartypants: false,\r\n  xhtml: false\r\n}\r\n\r\n// Set options\r\nmarked.setOptions(options);\r\n\r\n// export\r\nexport const markdownParser = (rawContent,assetsbaseUrl) => marked.parse(rawContent,{baseUrl:assetsbaseUrl})\r\n// export const markdownParser = (rawContent) => marked.parse(rawContent)\r\n```\r\n\r\n```less\r\n.markdown-body { //自定义样式： .markdown-body 为 github-markdown-css 中定义的类名\r\n    background-color: unset;\r\n\r\n    ul {\r\n        position: relative;\r\n\r\n        li {\r\n            position: relative;\r\n\r\n            &::before,\r\n            &::after {\r\n                content: '';\r\n                display: inline-block;\r\n                position: absolute;\r\n                box-sizing: border-box;\r\n            }\r\n\r\n            &::after {\r\n                left: -1.25em;\r\n                top: 0.75em;\r\n                width: 0.75em;\r\n                height: 0.75em;\r\n                background-color: #58a6ff;\r\n                border: 2px solid white;\r\n                transform: translate(0, -50%);\r\n                border-radius: 50%;\r\n            }\r\n\r\n            &::before {\r\n                left: -1em;\r\n                top: 1em;\r\n                width: 0.25em;\r\n                height: 100%;\r\n                background-color: white;\r\n            }\r\n\r\n            &:last-child::before {\r\n                content: none;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n## filter实现文章页封面效果\r\n\r\n\r\n\r\n![](./images/vue3_blog项目笔记/2022-10-19-09-38-34.png)\r\n\r\n虽呈现效果一般，但已经是一种折中了，封面宽度若和版心宽度一致则会导致封面高度的等比例放大，在pc端浏览效果不佳，封面的高度占用了整个浏览器视口，若用同时指定宽高的方式规定封面的高度则会导致封面的变形或是被封面截取导致封面部分信息丢失。\r\n\r\n```html\r\n<template>\r\n  <div class=\"article_header\">\r\n      <div class=\"cover\" v-if=\"article_Attrs.cover\">\r\n          <img :src=\"article_Attrs.cover\" alt=\"\" class=\"main_Img\">\r\n          <img :src=\"article_Attrs.cover\" alt=\"\" class=\"mask_Img\">\r\n      </div>\r\n  </div>\r\n</template>\r\n<style lang=\"less\">\r\n.article_header {\r\n    text-align: center;\r\n\r\n    .cover {\r\n        width: 100%;\r\n        height: 30vh;\r\n        overflow: hidden;\r\n        position: relative;\r\n\r\n        .main_Img {\r\n            z-index: 1;\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            object-fit: scale-down;\r\n            object-position: center center;\r\n        }\r\n\r\n        .mask_Img {\r\n            z-index: 0;\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            filter: contrast(200%) blur(50px);\r\n            // object-fit:  scale-down;\r\n            // object-position: center center;\r\n        }\r\n    }\r\n  }\r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n## vue中hash路由与markdown中锚点链接冲突的解决及链接跳转的实现\r\n\r\n![](./images/vue3_blog项目笔记/fiwqefj0302.gif)\r\n\r\n```html\r\n<template>\r\n    <div ref=\"markdown_body\" v-html=\"article_HTML\" @click=\"clickHandle\"></div>\r\n</template>\r\n\r\n<script>\r\nimport { mapActions, mapGetters } from 'vuex'\r\nexport default {\r\n    computed: {\r\n      ...mapGetters('article', ['article_HTML']),\r\n    },\r\n    methods: {\r\n        ...mapActions('article', ['getArticleById']),\r\n        clickHandle(event){\r\n            let address = event.target.getAttribute(\"href\")\r\n            if (address) {//有address\r\n                if(address[0] == '#') {//判断是否为锚点\r\n                    this.goToElementById(address);\r\n                }else if(address[0] == '/') {//绝对地址\r\n                    window.location.replace(address)\r\n                }else{//url地址\r\n                    window.location.replace(address)\r\n                }\r\n                event.preventDefault() //有address则禁止默认事件的触发\r\n            } else {\r\n                //不禁止\r\n            }\r\n        },\r\n        goToElementById(id) {//滚动到指定元素\r\n            document.querySelector( decodeURI(id) ).scrollIntoView({\r\n                behavior: \"smooth\", // 定义动画过渡效果， \"auto\"或 \"smooth\" 之一。默认为 \"auto\"\r\n                block: \"center\",// 定义垂直方向的对齐， \"start\", \"center\", \"end\", 或 \"nearest\"之一。默认为 \"start\"\r\n                inline: \"nearest\" // 定义水平方向的对齐， \"start\", \"center\", \"end\", 或 \"nearest\"之一。默认为 \"nearest\"\r\n            })\r\n        },\r\n    },\r\n    watch:{\r\n      \"$route.params\":{//监听路由变化请求文章内容\r\n          deep:true,\r\n          immediate:true,\r\n          handler(){\r\n              this.getArticleById(this.$route.params.id);\r\n          }\r\n      },\r\n    }\r\n}\r\n</script>\r\n```\r\n\r\n\r\n## markdown中script标签内代码不执行问题的解决\r\n\r\n* script只会在DOM第一次加载的时候执行，\r\n* 通过innerHTML方式插入的script标签不会执行，\r\n* 通过createElement(script);appendChild()附加的标签会执行\r\n\r\n\r\n```html\r\n<template>\r\n    <div ref=\"markdown_body\" v-html=\"article_HTML\" @click=\"clickHandle\"></div>\r\n</template>\r\n\r\n<script>\r\nimport { mapActions, mapGetters } from 'vuex'\r\nexport default {\r\n    computed: {\r\n        ...mapGetters('article', ['article_HTML']),\r\n    },\r\n    methods: {\r\n        ...mapActions('article', ['getArticleById']),\r\n    },\r\n    watch:{\r\n        \"$route.params\":{//监听路由变化请求文章内容\r\n            deep:true,\r\n            immediate:true,\r\n            handler(){\r\n                this.getArticleById(this.$route.params.id);\r\n            }\r\n        },\r\n        article_HTML:{//监听article_HTML的更新\r\n            handler(){\r\n                nextTick(()=>{//nextTick是为了等待Dom元素渲染完毕，因为应当等DOM元素渲染完毕后执行script脚本\r\n                    //附加文章中的script脚本\r\n                    //script只会在DOM第一次加载的时候执行，通过innerHTML方式插入的script标签不会执行，通过createElement(script);appendChild()附加的标签会执行\r\n                    this.$refs.markdown_body.querySelectorAll(\"script\").forEach(element => {\r\n                        var script = document.createElement(\"script\")\r\n                        if(element.src)//外链式\r\n                            script.src = element.src\r\n                        if(element.innerHTML)//内联代码\r\n                            script.innerHTML = element.innerHTML\r\n                        this.$refs.markdown_body.appendChild(script)\r\n                    });\r\n                })\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n```\r\n\r\n\r\n## 使markdown中script标签支持jQuery(`$`)语法\r\n\r\n```html\r\n<template>\r\n    <div ref=\"markdown_body\" v-html=\"article_HTML\" @click=\"clickHandle\"></div>\r\n</template>\r\n\r\n<script>\r\nimport jQuery from \"jQuery\" //jQuery\r\nimport { mapActions, mapGetters } from 'vuex'\r\nexport default {\r\n    computed: {\r\n        ...mapGetters('article', ['article_HTML']),\r\n    },\r\n    methods: {\r\n        ...mapActions('article', ['getArticleById']),\r\n    },\r\n    watch:{\r\n        \"$route.params\":{//监听路由变化请求文章内容\r\n            deep:true,\r\n            immediate:true,\r\n            handler(){\r\n                this.getArticleById(this.$route.params.id);\r\n            }\r\n        },\r\n        article_HTML:{//监听article_HTML的更新\r\n            handler(){\r\n                nextTick(()=>{//nextTick是为了等待Dom元素渲染完毕，因为应当等DOM元素渲染完毕后执行script脚本\r\n                    //附加文章中的script脚本\r\n                    //script只会在DOM第一次加载的时候执行，通过innerHTML方式插入的script标签不会执行，通过createElement(script);appendChild()附加的标签会执行\r\n                    this.$refs.markdown_body.querySelectorAll(\"script\").forEach(element => {\r\n                        var script = document.createElement(\"script\")\r\n                        if(element.src)//外链式\r\n                            script.src = element.src\r\n                        if(element.innerHTML)//内联代码\r\n                            script.innerHTML = element.innerHTML\r\n                        this.$refs.markdown_body.appendChild(script)\r\n                    });\r\n                })\r\n            }\r\n        }\r\n    },\r\n    created(){\r\n        window.$ = jQuery  //for jquery \r\n    }\r\n}\r\n</script>\r\n```\r\n\r\n\r\n## 使markdown支持渲染KaTex语法数学公式及复制KaTex源代码\r\n\r\n渲染前后效果\r\n![](./images/vue3_blog项目笔记/2022-10-19-09-35-14.png)\r\n![](./images/vue3_blog项目笔记/2022-10-19-09-34-04.png)\r\n\r\n```html\r\n<template>\r\n    <div ref=\"markdown_body\" v-html=\"article_HTML\" @click=\"clickHandle\"></div>\r\n</template>\r\n\r\n<script>\r\n//katex\r\nimport \"katex/dist/katex.css\" //katex样式\r\nimport \"katex/dist/katex.js\" //katex核心库\r\nimport renderMathInElement from \"katex/contrib/auto-render/auto-render\" //自动渲染扩展库\r\nimport \"katex/contrib/copy-tex\" //copy-tex扩展库 使得复制katex公式将得到katex源代码 $\\log_2{N}$\r\n\r\nimport { mapActions, mapGetters } from 'vuex'\r\nexport default {\r\n    computed: {\r\n        ...mapGetters('article', ['article_HTML']),\r\n    },\r\n    methods: {\r\n        ...mapActions('article', ['getArticleById']),\r\n    },\r\n    watch:{\r\n        \"$route.params\":{//监听路由变化请求文章内容\r\n            deep:true,\r\n            immediate:true,\r\n            handler(){\r\n                this.getArticleById(this.$route.params.id);\r\n            }\r\n        },\r\n        article_HTML:{//监听article_HTML的更新\r\n            handler(){\r\n                nextTick(()=>{//nextTick是为了等待Dom元素渲染完毕\r\n                    //自动渲染katex\r\n                    renderMathInElement(\r\n                        this.$refs.markdown_body,\r\n                        {\r\n                            delimiters: [\r\n                                {left: \"$$\", right: \"$$\", display: true},\r\n                                {left: \"$\", right: \"$\", display: false},\r\n                                {left: \"\\\\begin{equation}\", right: \"\\\\end{equation}\", display: true},\r\n                                {left: \"\\\\begin{align}\", right: \"\\\\end{align}\", display: true},\r\n                                {left: \"\\\\begin{alignat}\", right: \"\\\\end{alignat}\", display: true},\r\n                                {left: \"\\\\begin{gather}\", right: \"\\\\end{gather}\", display: true},\r\n                                {left: \"\\\\(\", right: \"\\\\)\", display: false},\r\n                                {left: \"\\\\[\", right: \"\\\\]\", display: true}\r\n                            ]\r\n                        }\r\n                    );\r\n                })\r\n            }\r\n        }\r\n    },\r\n}\r\n</script>\r\n```\r\n\r\n## 归档页github风格代码贡献统计效果的组件实现\r\n\r\n![](./images/vue3_blog项目笔记/2022-10-19-09-05-47.png)\r\n\r\n\r\n```html\r\n<template>\r\n    <div id=\"GitCalendar_bg\">\r\n        <h2 class=\"title\">博客内容更新及站点维护提交次数统计</h2>\r\n        <div class=\"_container\">\r\n            <div ref=\"GitCalendar\"></div>\r\n        </div>\r\n        <div id=\"tooltip\"></div>\r\n    </div>\r\n</template>\r\n<script>\r\nimport { SVGGraph } from 'calendar-graph/es/index.js';\r\nimport moment from 'moment';\r\nimport { mapActions, mapState } from 'vuex';\r\nexport default {\r\n    name: 'GitCalendar',\r\n    methods: {\r\n        SVGGraph,\r\n        ...mapActions('commit', ['getCommitData']),\r\n        tooltipInit() {\r\n            const tip = document.getElementById('tooltip');\r\n            let elems = document.getElementsByClassName('cg-day');\r\n            const mouseOver = function (e) {\r\n                e = e || window.event;\r\n                const elem = e.target || e.srcElement;\r\n                const rect = elem.getBoundingClientRect();\r\n                const count = elem.getAttribute('data-count');\r\n                const date = elem.getAttribute('data-date');\r\n                tip.style.display = 'block';\r\n                tip.textContent = `${count} contributions on ${date}`;\r\n                const w = tip.getBoundingClientRect().width;\r\n                tip.style.left = `${rect.left - (w / 2) + 6}px`;\r\n                tip.style.top = `${rect.top - 35}px`;\r\n            };\r\n            const mouseOut = function (e) {\r\n                e = e || window.event;\r\n                tip.style.display = 'none';\r\n            };\r\n            for (let i = 0; i < elems.length; i++) {\r\n                if (document.body.addEventListener) {\r\n                    elems[i].addEventListener('mouseover', mouseOver, false);\r\n                    elems[i].addEventListener('mouseout', mouseOut, false);\r\n                } else {\r\n                    elems[i].attachEvent('onmouseover', mouseOver);\r\n                    elems[i].attachEvent('onmouseout', mouseOut);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    computed: {\r\n        ...mapState('commit', ['CommitData'])\r\n    },\r\n    watch: {\r\n        CommitData(newVal, oldVal) {\r\n            // const newVal = [ //数据格式\r\n            //   { date: '2016-01-01', count: 1 },\r\n            //   { date: '2016-01-03', count: 4 },\r\n            //   { date: '2016-01-06', count: 2 },\r\n            //   // ...and so on\r\n            // ];\r\n            let mySVGGraph = new this.SVGGraph(this.$refs.GitCalendar, newVal, {\r\n                startDate: new Date(moment().add(-1, 'years')),//开始日期为去年的今日\r\n                endDate: new Date(moment()),//结束时间为今日\r\n                colorFun: (v) => {\r\n                    let colors = [ // https://colordesigner.io/\r\n                        '#d8f1ce',\r\n                        // '#b1e39e',\r\n                        // '#8ad56d',\r\n                        '#63c73d',\r\n                        '#4b9a2c',\r\n                        '#33691E',\r\n                    ];\r\n                    let count = v.count < colors.length ? v.count : colors.length - 1\r\n                    let result = colors[count]\r\n                    return result;\r\n                },\r\n                onClick: v => {\r\n                    // console.log('12312321');\r\n                },\r\n                size: 12,\r\n                space: 1,\r\n                padX: 20,\r\n                padY: 20,\r\n            })\r\n            this.tooltipInit();\r\n        }\r\n    },\r\n    mounted() {\r\n        this.getCommitData();\r\n    }\r\n}\r\n\r\n</script>\r\n<style lang=\"less\">\r\n#GitCalendar_bg {\r\n    width: 100%;\r\n    text-align: center;\r\n    background-color: white;\r\n    border-radius: 5px;\r\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\r\n    padding-top: 10px;\r\n    .title {\r\n        color: black;\r\n        font-size: medium;\r\n    }\r\n\r\n    ._container {\r\n        overflow: auto;\r\n\r\n        &::-webkit-scrollbar {\r\n            display: none; // 清除滚动条\r\n        }\r\n    }\r\n}\r\n\r\n#tooltip {\r\n    display: none;\r\n    position: fixed;\r\n    left: 0;\r\n    top: 0;\r\n    height: 20px;\r\n    background-color: rgba(0, 0, 0, .8);\r\n    color: #fff;\r\n    padding: 0px 10px;\r\n    border-radius: 3px;\r\n}\r\n\r\n#tooltip:after {\r\n    display: block;\r\n    position: absolute;\r\n    content: '';\r\n    bottom: -6px;\r\n    left: 50%;\r\n    margin-left: -6px;\r\n    width: 0;\r\n    height: 0;\r\n    border-left: 6px solid transparent;\r\n    border-right: 6px solid transparent;\r\n    border-top: 6px solid rgba(0, 0, 0, .8);\r\n}\r\n</style>\r\n```\r\n\r\n\r\n```js\r\n// 数据的生成\r\nconst counts = (arr, value) => arr.reduce((a, v) => v === value ? a + 1 : a + 0, 0)\r\nimport { execSync } from 'child_process'\r\nimport { log } from 'console'\r\nfunction getCommitData(weeks = '55') {\r\n  const _cmd = `git log --all --since=\"${weeks}.weeks\" --date=iso --pretty=format:\"%ad\"`//git log --all --since=\"40.weeks\" --date=iso --pretty=format:\"%ad\"\r\n  const _gitLog = execSync(_cmd).toString()\r\n  const gitlogData = _gitLog.split('\\n').map(e => {\r\n    return e.split(' ')[0]\r\n  })\r\n  // console.log(gitlogData);\r\n  const uniaueDate = [...new Set(gitlogData)]\r\n  const commitData = []\r\n  for (const e of uniaueDate) {\r\n    commitData.push({\r\n      date: e,\r\n      count: counts(gitlogData, e)\r\n    })\r\n  }\r\n  return commitData\r\n}\r\nawait fs.writeFile(path.join(webSiteRootDir, './api/archive_commitData.json'), JSON.stringify(getCommitData())) //写入新文件名\r\n```\r\n\r\n## 将文章标题字符串计算HASH作为ID\r\n\r\n```js\r\nimport stringHash from 'string-hash'\r\nlet id = stringHash(article_title)//给文章生成id\r\n```\r\n\r\n\r\n## 通过front-matter将markdown文章首部的yml格式信息获取\r\n\r\n```js\r\nimport FM from 'front-matter'\r\nlet fm = FM(articleTEXT);\r\n```\r\n\r\n## 在ECMAScript标准语法下获取`__filename`及`__dirname`\r\n```js\r\nimport { fileURLToPath } from 'url';\r\nimport { dirname } from 'path';\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = dirname(__filename);\r\nconsole.log(__filename);\r\nconsole.log(__dirname);\r\n```\r\n\r\n## 文件枚举函数的实现和使用\r\n\r\n```js\r\n// 调用\r\nawait fileEnum(searchRoot, searchDir, relativeDir,async (fileInfo)=>{\r\n    return new Promise((resolve,reject)=>{\r\n        console.log(fileInfo);\r\n        resolve();\r\n    })\r\n})\r\n```\r\n\r\n```js\r\nimport fs from 'fs/promises'\r\nimport path from 'path'\r\n/**\r\n * 文件枚举方法\r\n * @param searchRoot 需要遍历的文件夹的所在路径\r\n * @param searchDir 需要遍历的文件夹名\r\n * @param relativeDir 需要遍历的文件夹名\r\n * @param callback 回调函数,接收一个文件路径\r\n * @return \r\n */\r\nexport const fileEnum = (searchRoot, searchDir, relativeDir, callback) => {\r\n  return new Promise(async (resolve) => {\r\n    let fullDirPath = path.join(searchRoot, searchDir, relativeDir);//拼接路径\r\n    let fileNameList = await fs.readdir(fullDirPath)//根据文件路径读取文件，返回文件列表\r\n    for (let index = 0; index < fileNameList.length; index++) {//遍历读取到的文件名列表\r\n      const filename = fileNameList[index];\r\n      var fullFilePath = path.join(fullDirPath, filename);//拼接路径 //获取当前文件的绝对路径\r\n      try {\r\n        let stats = await fs.stat(fullFilePath)//根据文件路径获取文件信息，返回一个fs.Stats对象\r\n        if (stats.isFile()) {//是文件\r\n          let fileNameWithExt = filename //带后缀的文件名\r\n          let fileNameWithoutExt = path.basename(fullFilePath, path.extname(fullFilePath))//不带后缀文件名\r\n          let extname = path.extname(fullFilePath)//后缀名\r\n          await callback({\r\n            searchRoot,\r\n            searchDir,\r\n            relativeDir,\r\n            fileNameWithExt,\r\n            fileNameWithoutExt,\r\n            extname,\r\n            fullFilePath, //文件的绝对路径 \r\n            fullDirPath, //文件的绝对路径 \r\n            stats //stats 包含创建时间\r\n          })\r\n        } else if (stats.isDirectory()) { //是文件夹\r\n          let newRelativeDir = path.join(relativeDir, filename)//拼接新相对路径\r\n          await fileEnum(\r\n            searchRoot,\r\n            searchDir,\r\n            newRelativeDir,\r\n            callback\r\n          )\r\n        }\r\n      } catch (err) {\r\n        console.warn(err);\r\n      }\r\n    }\r\n    resolve('done')\r\n  })\r\n}\r\n```\r\n\r\n## imagemin图像压缩\r\n\r\n```js\r\n//图像压缩\r\nimport imagemin from 'imagemin';\r\n// import imagemin_mozjpeg from 'imagemin-mozjpeg'; //JPEG有损压缩\r\nimport imagemin_jpegtran from 'imagemin-jpegtran'; //JPEG无损压缩\r\nimport imagemin_pngquant from 'imagemin-pngquant'; //PNG有损压缩\r\n// import imagemin_optipng from 'imagemin-optipng'; //PNG无损压缩\r\n// import imagemin_giflossy from 'imagemin-giflossy'; //GIF有损压缩 @forked from imagemin/imagemin-gifsicle\r\nimport imagemin_gifsicle from 'imagemin-gifsicle'; //GIF无损压缩\r\n\r\n\r\n\r\nasync function markdownAssetsProcesser(//把某个文件夹下的所有文件(除markdown文件) 全部复制到指定目录\r\n  targetDir,//目标文件夹\r\n  excludeFilePath,//不包含的文件\r\n  destinationDirPath,//保存到的目标文件夹\r\n  requireImagemin,//是否需要对图片压缩\r\n) {\r\n  return await fileEnum(targetDir, './', './', async ({\r\n    relativeDir,\r\n    fileNameWithExt,\r\n    extname,//扩展名\r\n    fullDirPath,//文件原所在目录路径\r\n    fullFilePath, //文件的绝对路径 \r\n  }) => {\r\n    if (fullFilePath != excludeFilePath) {//\r\n      let saveTo_DirPath = path.join(destinationDirPath, relativeDir) // 拼接 存储路径 \r\n      await fs.mkdir(saveTo_DirPath, { recursive: true /* 递归 */ }) //递归创建输出目录\r\n\r\n      let saveTo_FilePath = path.join(saveTo_DirPath, fileNameWithExt) // 拼接 文件存储路径\r\n\r\n      //图像压缩\r\n      if(requireImagemin && (extname == \".png\" || extname == \".PNG\" || extname == \".jpg\" || extname == \".JPG\" || extname == \".gif\" || extname == \".GIF\")){\r\n        console.log(`当前压缩文件所在路径:${fullFilePath}`);\r\n        console.log(`压缩完毕后的保存路径：${saveTo_FilePath}`);\r\n        try{\r\n            const files = await imagemin.buffer(\r\n              await fs.readFile(fullFilePath),\r\n              {\r\n                plugins: [\r\n                  //jpg/jpeg无损压缩\r\n                  imagemin_jpegtran(),\r\n\r\n                  //jpg/jpeg有损压缩\r\n                  // imagemin_mozjpeg({quality: 0.8}),\r\n\r\n                  //png有损压缩\r\n                  imagemin_pngquant({speed:5,quality: [0.5,0.8]}),\r\n\r\n                  //GIF无损压缩\r\n                  imagemin_gifsicle(),\r\n                ]\r\n              }\r\n            );\r\n            await fs.writeFile(saveTo_FilePath, files) //写入新文件名\r\n          }catch(error){\r\n            console.log(error);\r\n            console.warn(`压缩图片失败(${fileNameWithExt})`);\r\n            console.log(\"尝试直接复制\");\r\n            await fs.copyFile(fullFilePath, saveTo_FilePath)//复制 目标文件 到 指定文件路径\r\n          }\r\n      }else{\r\n        await fs.copyFile(fullFilePath, saveTo_FilePath)//复制 目标文件 到 指定文件路径\r\n      }\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n## 通过axios请求拦截器为请求url地址params添加随机数防止浏览器缓存数据\r\n\r\n```js\r\nimport Axios from 'axios'\r\nimport nprogress from 'nprogress'//进度条\r\nimport 'nprogress/nprogress.css'//加载的进度条样式\r\nimport moment from 'moment'\r\n\r\nconst axios = Axios.create({\r\n    baseURL:'/self_server/api',\r\n})\r\n//请求拦截器\r\naxios.interceptors.request.use((config) => {\r\n    //进度条开始\r\n    nprogress.start()\r\n    config.params ={\r\n        t:moment().valueOf(),//添加时间戳，防止浏览器缓存数据\r\n        ...config.params\r\n    }\r\n    return config\r\n})\r\n//响应拦截器\r\naxios.interceptors.response.use(\r\n    (response) => {\r\n        //进度条结束\r\n        nprogress.done()\r\n        return response\r\n    },\r\n    (err) => {\r\n        return Promise.reject(new Error('faile'))\r\n    }\r\n)\r\nexport default axios\r\n```"},{"shortInfo":{"title":"vue3学习笔记","date":"2022-09-07T15:37:00.000Z","cover":"\\self_server\\assets\\images\\index\\2022-12-04-01-15-41.png","tags":["vue3","学习笔记"],"categories":"前端","id":4039877874,"countWords":14331,"readSeconds":1433.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# vue3学习笔记\r\n## 目录\r\n- [vue3学习笔记](#vue3学习笔记)\r\n  - [目录](#目录)\r\n  - [简介](#简介)\r\n  - [基本用法](#基本用法)\r\n  - [指令](#指令)\r\n    - [内容渲染指令](#内容渲染指令)\r\n    - [属性绑定指令](#属性绑定指令)\r\n    - [事件绑定指令](#事件绑定指令)\r\n    - [双向绑定指令](#双向绑定指令)\r\n    - [条件渲染指令](#条件渲染指令)\r\n    - [列表渲染指令](#列表渲染指令)\r\n    - [vue2过滤器](#vue2过滤器)\r\n    - [综合案例实现](#综合案例实现)\r\n  - [组件](#组件)\r\n    - [SPA概念](#spa概念)\r\n    - [Vite构建工具](#vite构建工具)\r\n    - [Vite基本使用](#vite基本使用)\r\n    - [注册全局组件](#注册全局组件)\r\n    - [注册局部组件](#注册局部组件)\r\n    - [组件案例](#组件案例)\r\n  - [computed属性](#computed属性)\r\n  - [触发自定义事件](#触发自定义事件)\r\n  - [父子组件间数据传递-props属性](#父子组件间数据传递-props属性)\r\n    - [props基本使用](#props基本使用)\r\n    - [数据合法性验证](#数据合法性验证)\r\n  - [父子组件间数据的双向同步](#父子组件间数据的双向同步)\r\n    - [v-bind:单向绑定数据](#v-bind单向绑定数据)\r\n    - [v-model双向绑定父子组件间数据](#v-model双向绑定父子组件间数据)\r\n  - [`todoList案例实现`](#todolist案例实现)\r\n  - [watch监听器](#watch监听器)\r\n  - [生命周期钩子函数](#生命周期钩子函数)\r\n  - [组件间数据共享](#组件间数据共享)\r\n    - [父子关系组件间数据共享](#父子关系组件间数据共享)\r\n    - [后代关系组件间数据共享](#后代关系组件间数据共享)\r\n    - [兄弟关系组件间数据共享](#兄弟关系组件间数据共享)\r\n    - [VueX全局数据共享](#vuex全局数据共享)\r\n      - [概念](#概念)\r\n      - [vuex原理](#vuex原理)\r\n      - [基本使用](#基本使用)\r\n      - [vueX的模块化](#vuex的模块化)\r\n    - [Pinia](#pinia)\r\n      - [1、简单例子](#1简单例子)\r\n      - [2、购物车案例](#2购物车案例)\r\n    - [总结](#总结)\r\n  - [lodash节流防抖:throttle()](#lodash节流防抖throttle)\r\n  - [axios](#axios)\r\n    - [全局配置axios](#全局配置axios)\r\n    - [axios的拦截器](#axios的拦截器)\r\n    - [axios配置nprogress进度条](#axios配置nprogress进度条)\r\n  - [`购物车案例实现`](#购物车案例实现)\r\n  - [DOM的引用---ref属性](#dom的引用---ref属性)\r\n  - [DOM更新时机及nextTick()](#dom更新时机及nexttick)\r\n  - [动态组件component](#动态组件component)\r\n  - [插槽Slot](#插槽slot)\r\n  - [自定义的指令Directives](#自定义的指令directives)\r\n  - [表格案例实现](#表格案例实现)\r\n  - [路由](#路由)\r\n    - [路由原理](#路由原理)\r\n    - [基本使用:声明式导航](#基本使用声明式导航)\r\n    - [基本使用:编程式导航](#基本使用编程式导航)\r\n    - [导航守卫](#导航守卫)\r\n  - [登陆案例实现](#登陆案例实现)\r\n  - [vue-cli脚手架](#vue-cli脚手架)\r\n  - [vue组件库](#vue组件库)\r\n    - [element UI](#element-ui)\r\n  - [vue-cli的proxy代理服务](#vue-cli的proxy代理服务)\r\n  - [transition动画组件](#transition动画组件)\r\n  - [swiper在vue中的使用](#swiper在vue中的使用)\r\n  - [根据页面滚动位置改变盒子高度(存在兼容性问题)](#根据页面滚动位置改变盒子高度存在兼容性问题)\r\n\r\n\r\n------------------------------------------------------------------------------------------\r\n## 简介\r\nvue是一套用于**构建用户界面**的**前端框架**\r\n\r\n**vue全家桶**\r\n* vue 核心库\r\n* vue-router 路由方案\r\n* vuex 状态管理方案\r\n* vue组件库 快速搭建页面UI效果的方案\r\n\r\n**vue辅助开发工具**\r\n* vue-cli (npm全局包,一键生成工程化vue项目-基于webpack,大而全)\r\n* vite (npm全局包,一键生成工程化vue项目,小而巧)\r\n* vue-devtools 浏览器插件:辅助调试工具\r\n* vetur VScode插件:语法高亮和智能提示\r\n\r\n------------------------------------------------------------------------------------------\r\n\r\n## 基本用法\r\n\r\n\r\n**vue3基本使用**\r\n```js\r\n<script src=\"https://unpkg.com/vue@next\"></script>\r\n<div id=\"demo_1\">{{ test1 }}</div>\r\n<script>\r\n    const test1 = {\r\n        data() {\r\n            return {\r\n                test1 : \"hello world!!!\"\r\n            }\r\n        }\r\n    }\r\n    Vue.createApp(test1).mount('#demo_1')\r\n</script>\r\n```\r\n\r\n**Vue2基本使用**\r\n```js\r\n<script src=\"https://unpkg.com/vue@2.6.14/dist/vue.min.js\"></script>\r\n<div id=\"demo_1\">{{ test1 }}</div>\r\n<script>\r\n    const vm = new Vue({\r\n        el:\"#demo_1\",\r\n        data:{\r\n            test1:\"hello world!!!\",\r\n            count:123\r\n            methods:{\r\n                addAcount(){\r\n                    //this指向vm,可以访问到data中的属性\r\n                    this.count+=1;\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n------------------------------------------------------------------------------------------\r\n\r\n## 指令\r\n**分类**\r\n* 内容渲染指令\r\n* 属性绑定指令\r\n* 事件绑定指令\r\n* 双向绑定指令\r\n* 条件渲染指令\r\n* 列表渲染指令\r\n\r\n\r\n### 内容渲染指令\r\n```html\r\n语法格式: \r\n    {{ 变量名 }}        插值表达式\r\n    v-text=\"变量名\"     内容渲染指令(纯文本)\r\n    v-html=\"变量名\"     内容渲染指令(html)\r\n\r\n示例:\r\n<p >用户名: {{ username }}</p>\r\n<p v-text=\"test1\">原内容将被覆盖</p>\r\n<p v-html=\"test2\">原内容将被覆盖</p>\r\n\r\n\r\n<!-- 支持js表达式 -->\r\n<p>{{ number + 1 }}</p>\r\n<p>{{ ok ? 'YES' : 'NO' }}</p>\r\n<p>{{ message.split('').reverse().join('') }}</p>\r\n<div :id=\"`list-${id}`\"></div>\r\n<p>{{user.name}}</p>\r\n```\r\n\r\n\r\n### 属性绑定指令\r\n```html\r\n语法格式:   v-bind:属性名=\"变量名\"\r\n简写:       :属性名=\"变量名\"\r\n\r\n示例:\r\n    <img v-bind:src=\"imgSrc\" :alt=\"imgText\"  >\r\n```\r\n\r\n\r\n`v-bind:class` 和 `v-bind:style` 的绑定\r\n```html\r\n<template>\r\n  \r\n  <div class=\"defalutClassName\" :class=\"isClssNameA ? 'ClssNameA' : '' \">测试文字</div>\r\n  <div class=\"defalutClassName\" :class=\"[isClssNameA ? 'ClssNameA' : '' ,isClssNameB ? 'ClssNameB' : '' ]\">测试文字</div>\r\n  <div class=\"defalutClassName\" :class=\"classList\">测试文字</div>\r\n\r\n  <div class=\"defalutClassName\" :style=\"'color:' + isActive\">测试文字</div>\r\n  <div class=\"defalutClassName\" :style=\"{color:isActive,fontSize:fSize + 'px','background-color':bgcolor}\">测试文字</div><!-- fontSize和‘font-size‘等效 ‘background-color’和backgroundColor等效 -->\r\n  <div class=\"defalutClassName\" :style=\"styleObj\">测试文字</div>\r\n\r\n</template>\r\n\r\n\r\n\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      isClssNameA: true,\r\n      isClssNameB: true,\r\n      isActive: \"skyblue\",\r\n      fSize: 15,\r\n      bgcolor: \"pink\",\r\n      classList: [\r\n        \"ClssNameA\",\r\n        \"ClssNameB\",\r\n      ],\r\n      styleObj: {\r\n        color: \"red\",\r\n        fontSize: \"15px\",           //fontSize和'font-size'等效\r\n        'background-color': 'pink'\r\n      }\r\n    }\r\n  },\r\n}\r\n</script>\r\n<style>\r\n.defalutClassName {\r\n  color: red;\r\n}\r\n\r\n.ClssNameA {\r\n  font-size: 15px;\r\n}\r\n\r\n.ClssNameB {\r\n  background-color: pink;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n### 事件绑定指令\r\n```html\r\n语法格式:   v-on:事件名称.事件修饰符号=\"事件处理函数名 或 js表达式\"\r\n简写:       @事件名称.事件修饰符号=\"事件处理函数名 或 js表达式\"\r\n\r\n事件修饰符号\r\n    .prevent    阻止默认行为,如阻止点击超链接跳转\r\n    .stop       阻止事件冒泡\r\n    .capture    以捕获方式(从外到内)触发当前事件,浏览器默认以冒泡方式(从内到外)触发事件\r\n    .once       绑定的事件只触发一次\r\n    .self       只在event.target==this时触发\r\n\r\n按键事件修饰符\r\n    .enter      示例: @keyup.enter=\"事件处理函数名\"\r\n    .esc      \r\n\r\n示例:\r\n    <button v-on:click.self=\"addCount\"> +1 </button>\r\n    <button @click.self=\"count += 1\"> +1 </button>\r\n    <button @click.self=\"addCountA()\"> +1 </button> <!-- 事件处理函数的第一个形参默认是事件对象 -->\r\n    <button @click.self=\"addCountB(5,$event)\"> +1 </button> <!-- 若第一个形式参数的位置被占用,可手动传入事件对象$event -->\r\n\r\n\r\n```\r\n\r\n\r\n### 双向绑定指令\r\n```html\r\n语法格式:   v-model.修饰符=\"变量名\"\r\n\r\n修饰符:\r\n    .number     自动将输入表单的数据转换为数字\r\n    .trim       自动过滤输入数据的字符串首尾的空格\r\n    .lazy       仅在\"change\"事件触发时(失去焦点)写入用户输入的数据,而非\"input\"事件触发时\r\n\r\n注意:   双向绑定指令只能配合html的表单元素使用\r\n\r\n示例:\r\n    <input v-model=\"username\">\r\n    <input v-model.number=\"age\">\r\n```\r\n\r\n\r\n### 条件渲染指令\r\n```html\r\n语法格式:\r\n    v-if=\"布尔值 或 变量名\"\r\n        v-else-if=\"布尔值 或 变量名\"\r\n        v-else\r\n    v-show=\"布尔值 或 变量名\"\r\n\r\n区别:\r\n    原理区别\r\n        v-if是动态的添加和删除DOM元素\r\n        v-show是动态的修改DOM元素的CSS的display:none;属性\r\n    性能区别\r\n        在两者都在初始时不渲染,需要频繁切换是否渲染时,\r\n        v-show具有更高初始渲染开销,\r\n        v-if具有更高的切换开销,\r\n\r\n示例:\r\n    <button @click=\"flag=!flag\">change flag</button>\r\n    <div v-if=\"flag\">div1</div>\r\n    <div v-show=\"!flag\">div2</div>\r\n```\r\n\r\n### 列表渲染指令\r\n\r\n```html\r\n语法格式:\r\n    v-for=\"item in items\"\r\n    v-for=\"(item,index) in items\"\r\n\r\n示例:\r\n    <li v-for=\"userName in userNameS\">{{userName}}</li>\r\n    <li v-for=\"(userName,i) in userNameS\">索引号是:{{i}},用户名是:{{userName}}</li>\r\n\r\n注意:\r\n    在vue2中,可以使用  :id=\"字符串 或 数值 的变量名\"   属性防止列表渲染内容紊乱\r\n    <li v-for=\"(userInfo,i) in userInfoS\" :id=\"userInfo.userId\">索引号是:{{i}},用户名是:{{userInfo}}</li>\r\n```\r\n\r\n\r\n### vue2过滤器\r\n过滤器仅在vue1 vue2中支持,vue3中建议使用`计算属性`或`方法`来代替\r\n```html\r\n<script src=\"https://unpkg.com/vue@2.6.14/dist/vue.min.js\"></script>\r\n<div id=\"demo_1\">\r\n    <p>{{text | capitalize | maxLength }}</p>\r\n    <p>{{text | capitalize | maxLength(20) }}</p>\r\n</div>\r\n<script>\r\n//定义全局过滤器(公有过滤器)\r\n    Vue.filter(\"maxLength\", (data, maxLength = 10) => { //第一个默认为接收到的参数,之后的参数为可选参数,可以接收到\r\n        if (data.length <= maxLength) return data\r\n        else return data.slice(0, maxLength) + \"......\"\r\n    })\r\n\r\n    const vm = new Vue({\r\n        el: \"#demo_1\",\r\n        data: {\r\n            text: \"dingyiguidingyiguidingyiguidingyigui\"\r\n        },\r\n//定义局部过滤器(私有过滤器)\r\n        filters: {\r\n            capitalize(data) {\r\n                return data.charAt(0).toUpperCase() + data.slice(1)\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n### 综合案例实现\r\n\r\n**实现效果**\r\n![图 4](./images/vue3学习笔记/f5d86ec4438a1f6a0466d8b303e7b459e32831edc61ba091681e037cedc8c0f3.png)  \r\n\r\n\r\n**源代码**\r\n```html\r\n<!-- <script src=\"./lib/vue@2.6.14.min.js\"></script> -->\r\n<link href=\"https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.css\" rel=\"stylesheet\">\r\n<script src=\"https://unpkg.com/vue@2.6.14/dist/vue.js\"></script>\r\n<div id=\"app\" class=\"container container-fluid\">\r\n    <div class=\"card\">\r\n        <div class=\"card-header\">添加品牌</div>\r\n        <div class=\"card-body row\">\r\n            <div class=\"input-group col\">\r\n                <span class=\"input-group-text\">品牌名称</span>\r\n                <!-- v-model.trim=\"tempBrand.name\" 双向绑定 -->\r\n                <!-- @keyup.esc=\"tempBrand.name=``\"键盘esc弹出事件发生后执行 tempBrand.name=`` -->\r\n                <!-- @keyup.enter=\"addItem\"     键盘enter弹出事件事件发生后调用addItem() -->\r\n                <input type=\"text\" class=\"form-control\" placeholder=\"请输入品牌名称\" v-model.trim=\"tempBrand.name\"\r\n                    @keyup.esc=\"tempBrand.name=``\" @keyup.enter=\"addItem\">\r\n                <!-- @click=\"addItem\"点击事件发生后调用addItem() -->\r\n                <button class=\"btn btn-outline-secondary\" type=\"button\" @click=\"addItem\">添加</button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <table class=\"table table-striped\">\r\n        <thead>\r\n            <tr>\r\n                <th scope=\"col\">#</th>\r\n                <th scope=\"col\">品牌名称</th>\r\n                <th scope=\"col\">状态</th>\r\n                <th scope=\"col\">创建时间</th>\r\n                <th scope=\"col\">操作</th>\r\n            </tr>\r\n        </thead>\r\n        <tbody>\r\n            <!-- :id=\"`item_${item.id}`\" 控制防止vue2中列表顺序渲染紊乱 -->\r\n            <tr v-for=\"item in brandList\" :id=\"`item_${item.id}`\">\r\n                <th scope=\"row\">{{item.id}}</th>\r\n                <th>{{item.name}}</th>\r\n                <th>\r\n                    <div class=\"form-check form-switch\">\r\n                        <!-- v-model控制双向绑定更新数据 -->\r\n                        <input class=\"form-check-input\" :id=\"`item_check_${item.id}`\" type=\"checkbox\" role=\"switch\"\r\n                            v-model=\"item.status\">\r\n                        <!-- v-if=\"item.status\"控制是否显示 -->\r\n                        <!-- :for=\"`item_check_${item.id}`\" 绑定到指定id,表示点击该元素就相当于点击带有#id的元素 -->\r\n                        <label v-if=\"item.status\" class=\"form-check-label\"\r\n                            :for=\"`item_check_${item.id}`\">已启用</label>\r\n                        <label v-else class=\"form-check-label\" :for=\"`item_check_${item.id}`\">已禁用</label>\r\n                    </div>\r\n                </th>\r\n                <th>{{item.time}}</th>\r\n                <!-- removeItemById(item.id)控制删除项目 -->\r\n                <th><a href=\"\" @click.prevent=\"removeItemById(item.id)\">删除</a></th>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</div>\r\n<script>\r\n    const vm = new Vue({\r\n        el: \"#app\",\r\n        data: {\r\n            tempBrand: { name: \"\" },//用于临时存储数据\r\n            nextId: 4,\r\n            brandList: [\r\n                { id: 1, name: \"华为\", status: true, time: new Date() },\r\n                { id: 2, name: \"小米\", status: false, time: new Date() },\r\n                { id: 3, name: \"苹果\", status: true, time: new Date() },\r\n            ]\r\n        },\r\n        methods: {\r\n            removeItemById(targetId) {//根据id删除数据\r\n                this.brandList.splice(this.brandList.findIndex((item) => item.id == targetId), 1)\r\n            },\r\n            addItem() {\r\n                if (!this.tempBrand.name) return alert(\"名称不能为空!!!\")\r\n                this.brandList.push({\r\n                    id: this.nextId,\r\n                    name: this.tempBrand.name,\r\n                    status: true,\r\n                    time: new Date()\r\n                })\r\n                this.tempBrand = { name: \"\" }//清空\r\n                this.nextId++       //自增id\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n--------------------------------------------------------------------\r\n\r\n## 组件\r\n\r\n\r\n\r\n### SPA概念\r\n```markdown\r\n# SPA概念\r\nSPA(single Page Application)单页面应用程序,指一个web网站只有唯一的HTML页面,所有功能与交互仅在一个页面完成.\r\n\r\n# 特点\r\n仅在页面初始化时加载相关资源,加载完毕后单页面应用不会因用户操作而重新加载页面或跳转页面,而是利用js动态改变内容\r\n\r\n# 优缺点\r\n* 交互体验好\r\n* 前后端分离,提升开发效率\r\n* 减轻服务器压力\r\n* 首页加载慢\r\n    * 解决方案: 路由懒加载、\r\n    * 代码压缩、\r\n    * CDN加速、\r\n    * 网络传输压缩、\r\n* 不利于SEO\r\n    * 解决方案: SSR服务器渲染\r\n```\r\n\r\n\r\n-------------------------------------------------------\r\n\r\n### Vite构建工具\r\n\r\n**概念**\r\nVite是Vue官方构建工具之一,用于构建SPA单网页应用\r\n![图 1](./images/vue3学习笔记/8aedff39e3d534c60b06ac2e0020dc798b4de170836de225fc7f9fd5efc7719c.png)  \r\n\r\n**Vite使用**\r\n```bash\r\n# 使用\r\nnpm create vite@latest\r\ncd ???\r\nnpm install\r\nnpm run dev\r\n```\r\n\r\n-------------------------------------------------------\r\n\r\n\r\n**Vite项目目录结构**  \r\n* `public/` 公共静态资源\r\n* `src/`   项目源代码\r\n  * `assets/` 编写的静态资源文件(css fonts)\r\n  * `components/` 编写的自定义组件\r\n  * `App.vue` 项目根组件\r\n  * `index.css` 全局样式表文件\r\n  * `main.js` 整个项目的打包入口\r\n* `index.html` SPA页面\r\n\r\n![图 2](./images/vue3学习笔记/047ffa1d1ac7da857630d9ee4568412ed299a93bec402f00fb35dc3752181b6e.png)  \r\n\r\n-------------------------------------------------------\r\n\r\n**Vite运行流程**  \r\n通过 `main.js` 把 `App.vue` 渲染到 `index.html`\r\n* `App.vue` 写待渲染的模板结构\r\n* `index.html` 需预留el区域\r\n* `main.js` 把 `App.vue` 渲染到 `index.html` 所预留的区域中\r\n\r\n\r\n### Vite基本使用\r\n\r\n**App.vue**\r\n```html\r\n<!-- ./src/App.vue -->\r\n<template>\r\n<h1>vue根组件</h1>\r\n<p>{{count}}</p>\r\n<button @click=\"addCount\">addCount</button>\r\n</template>\r\n\r\n\r\n<script>\r\nexport default{\r\n  name:\"AppIndex\",//组件名称\r\n  data(){\r\n    return{\r\n      count:0\r\n    }\r\n  },\r\n  methods:{\r\n    addCount(){\r\n      this.count++\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n\r\n<style scoped lang=\"less\">\r\n  /* scoped属性 */\r\n        /* scoped属性表示css的作用域为局部,可以防止样式冲突 */\r\n        /* \r\n            原理是自动给所有标签添加随机属性 <h1 data-v-dwed929>vue根组件</h1>\r\n            然后利用css属性选择器:\r\n            h1[data-v-dwed929]{\r\n                color: red;\r\n            }\r\n        */\r\n  /* lang=\"less\"属性 */\r\n        /* slang=\"less\"属性表示使用的css的语言为less,默认为css */\r\n        /* (需要安装 npm install less -d) */\r\n\r\nh1{\r\n  color: red;\r\n}\r\n:deep() h1{\r\n/* h1:deep {vue3写法}  */\r\n  color: red;\r\n/* \r\n    :deep() 称为样式穿透,\r\n    style标签添加了scoped属性后,其样式无法应用于子组件,\r\n    通过样式穿透可以使得样式对子组件生效\r\n    原理是将css选择器修改为\r\n        原 h1[data-v-dwed929]{\r\n                color: red;\r\n            }\r\n        修改后\r\n            [data-v-dwed929] h1{\r\n                color: red;\r\n            }\r\n        也就是自动将交集选择器 修改为子代选择器\r\n*/\r\n}\r\n\r\n</style>\r\n```\r\n\r\n\r\n### 注册全局组件\r\n```js\r\n// ./src/main.js\r\n\r\nimport { createApp } from 'vue'\r\nimport './style.css'\r\nimport App from './App.vue'\r\nconst app = createApp(App)\r\n\r\n//1.导入待注册的组件\r\nimport demo1 from \"./components/demo1.vue\"\r\n\r\n//2.使用app.component()注册为全局组件\r\n// app.component(demo1.name,demo1)//可以直接使用组件的name属性作为注册的组件名称\r\napp.component(\"my-global-comp-demo1\",demo1)\r\n\r\n//3.在 *.vue 中 通过 <my-global-comp-demo1></my-global-comp-demo1> 的方式使用全局组件\r\n\r\n\r\napp.mount('#app')\r\n```\r\n\r\n### 注册局部组件\r\n```html\r\n<template>\r\n......\r\n<my-global-comp-demo1></my-global-comp-demo1>\r\n<!-- 3.使用注册的局部组件 -->\r\n<my-local-comp-demo2></my-local-comp-demo2>\r\n</template>\r\n\r\n\r\n\r\n<script>\r\n//1.导入待注册的组件\r\nimport demo2 from \"./components/demo2.vue\"\r\n\r\nexport default{\r\n//2.使用components属性将其注册为局部组件\r\n    components:{\r\n      \"my-local-comp-demo2\": demo2\r\n    }\r\n}\r\n</script>\r\n```\r\n\r\n**注册组件名称命名格式**\r\n```html\r\npascalCase命名法 帕斯卡命名法 驼峰命名法    \r\n    用驼峰命名法注册的组件在使用时,可以使用两种格式     (适用性强)\r\n        * <pascalCase></pascalCase>\r\n        * <pascal-case></pascal-case>\r\n\r\nkebab-case命名法 短横线命名法\r\n    用短横线命名法注册的组件在使用时,仅可以使用一种格式\r\n        * <pascal-case></pascal-case>\r\n```\r\n\r\n\r\n### 组件案例\r\n**`./src/components/msgBox.vue`**\r\n```html\r\n<template>\r\n    <div class=\"main\" :style=\"{color:color || 'white',backgroundColor:bgcolor || 'skyblue'}\">\r\n        {{msg}}\r\n    </div>\r\n</template>\r\n  \r\n<script>\r\nexport default {\r\n    data() {\r\n        return {\r\n        }\r\n    },\r\n    //props属性概念相当于函数的形式参数列表\r\n    // 此处相当于是组件的形式参数列表\r\n    props: [\"msg\", \"color\", \"bgcolor\"]\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n.main {\r\n    text-align: center;\r\n    font-size: 20px;\r\n    height: 200px;\r\n    width: 400px;\r\n    margin: 0 auto;\r\n    box-shadow: 10px 10px gray;\r\n    padding: 10px;\r\n}\r\n</style>\r\n```\r\n\r\n**`./src/app.vue`**\r\n```html\r\n<template>\r\n<msgBox :msg=\"msg\" :color=\"color\" :bgcolor=\"bgcolor\"></msgBox>\r\n</template>\r\n\r\n<script>\r\nimport msgBox from \"./components/msgBox.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      msg:\"消息XXXXXXXXXXXXX\",\r\n      // color:\"skyblue\",\r\n      // bgcolor:\"pink\"\r\n    }\r\n  },\r\n  components:{\r\n    msgBox\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n</style>\r\n```\r\n\r\n\r\n## computed属性\r\n\r\n优点:\r\n计算属性会缓存结果值,节省了计算开销,只有依赖的数据源数据值发生改变时才会重新计算计算属性的结果,\r\n\r\n```js\r\n<template>\r\n    <p>名:{{firstName}}</p>\r\n    <p>姓:{{secondName}}</p>\r\n    <p>全名:{{fullName}}</p>\r\n</template>\r\n<script>\r\n    export default{\r\n        data(){\r\n            return{\r\n                firstName:\"Yigui\",\r\n                secondName:\"Ding\",\r\n            }\r\n        },\r\n        computed:{\r\n            fullName() {\r\n                return this.firstName + this.secondName\r\n            }\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n## 触发自定义事件\r\n\r\n\r\n```html\r\n<template>\r\n  <p>{{count}}</p>\r\n  <button @click=\"addCount\">count++</button>\r\n</template>\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  //1.注册事件\r\n  emits: [\"countChanged\"],\r\n  methods: {\r\n    addCount() {\r\n      this.count++\r\n      //2.触发事件,可选参数传递值\r\n      this.$emit(\"countChanged\",this.count)\r\n      //3.在组件外部监听该事件\r\n    },\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n    <!-- 3.在组件的根标签上监听事件(经测试,仅能在根标签上监听到) -->\r\n    <testEmits @countChanged=\"callbackA\" ></testEmits>\r\n</template>\r\n<script>\r\nimport testEmits from \"./components/testEmits.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components:{\r\n    testEmits\r\n  },\r\n  methods:{\r\n    callbackA(value){\r\n      alert('自定义事件countChanged事件触发了,接受到数据:' + value )\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n## 父子组件间数据传递-props属性\r\n* props属性概念相当于函数的形式参数列表,调用函数者可以向其中传入参数\r\n*  此处props就是是组件的形式参数列表,调用该组件时可以通过这个传入参数\r\n\r\n### props基本使用\r\n```html\r\n<template>\r\n    <!-- demo3为子组件 通过data1=\"\"属性传递值 -->\r\n    <demo3 :data1=\"title\" :this-is-data=\"context\" ></demo3>\r\n    <!-- \r\n    若thisIsData使用驼峰命名法,则此处属性名可以使用 驼峰命名法 或 短横线命名法\r\n    经测试\r\n        短横线命名法必须全小写\r\n        仅测试驼峰命名法首字母必须小写\r\n        若 props:[\"ThisIsData\"]     则可使用 ThisIsData=\"\" 或 This-Is-Data=\"\"\r\n        若 props:[\"thisIsData\"]     则可使用 this-is-data=\"\" 或 this-Is-Data=\"\"\r\n     -->\r\n</template>\r\n\r\n<script>\r\nimport demo3 from \"./components/demo3.vue\"\r\nexport default{\r\n  data(){\r\n    return{\r\n      title:\"由父组件传给子组件的标题\",\r\n      context:\"由父组件传给子组件的内容\",\r\n    }\r\n  },\r\n  components:{\r\n    demo3\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n    <h2>标题:{{data1}}</h2>\r\n    <p>内容:{{thisIsData}}</p>\r\n</template>\r\n<script>\r\n    export default{\r\n        data(){\r\n            return{\r\n            }\r\n        },\r\n        // props指定要传入的数据\r\n        props:[\"data1\",\"thisIsData\"], //此处可以使用驼峰命名法,不能使用短横线命名法\r\n    }\r\n</script>\r\n```\r\n\r\n### 数据合法性验证\r\n```js\r\n//一般写法\r\nprops:[\"data1\",\"thisIsData\"]\r\n\r\n//类型验证\r\nprops:{\r\n    //props支持8种数据类型\r\n    \"data1\": String,        //指定数据的类型,否则报错\r\n    \"data2\": Number,\r\n    \"data3\": Boolean,\r\n    \"data4\": Array,\r\n    \"data5\": Object,\r\n    \"data6\": Date,\r\n    \"data7\": Function,\r\n    \"data8\": Symbol,\r\n}\r\n\r\n\r\n//多类型验证\r\nprops:{\r\n    \"data1\": [String,Number,Array],\r\n    \"data2\": Number,\r\n}\r\n\r\n\r\n// 必填项校验\r\nprops:{\r\n    \"id\": {\r\n        type:[Number,String],\r\n        required:true                   //id为必填属性\r\n    },\r\n    \"data1\": [String,Number,Array],\r\n}\r\n\r\n//默认值\r\nprops:{\r\n    \"id\": {\r\n        type:[Number,String],\r\n        default:0                   //id默认值为default\r\n    },\r\n    \"data1\": [String,Number,Array],\r\n}\r\n\r\n//用自定义函数验证传入值的合法性\r\nprops:{\r\n    \"msgType\": {\r\n        type:String,\r\n        validator(value){//validator函数用于验证合法性,返回值为布尔值\r\n            return [\"success\",\"warning\",\"danger\"].includes(value)\r\n        }        \r\n    },\r\n    \"data1\": [String,Number,Array],\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 父子组件间数据的双向同步\r\n\r\n### v-bind:单向绑定数据\r\n父子组件数据 --> 子组件数据\r\n```html \r\n<template>\r\n  <div>\r\n    <p>子组件的count:{{count}}</p>\r\n  <button @click=\"addCount\">count++</button>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n    }\r\n  },\r\n  props:[\"count\"],//接受参数\r\n  methods: {\r\n    addCount() {\r\n    //   this.count++ //props只读属性无法修改\r\n    },\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\ndiv{\r\n  border: 1px solid gray;\r\n  padding: 20px;\r\n}\r\n</style>\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <p>父组件的count:{{count}}</p>\r\n    <button @click=\"addCount\">count++</button>\r\n    <hr>\r\n    <!-- v-bind:count=\"count\" 传递参数 -->\r\n    <updateCount v-bind:count=\"count\"></updateCount>\r\n  </div>\r\n</template>\r\n<script>\r\nimport updateCount from \"./components/updateCount.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components: {\r\n    updateCount\r\n  },\r\n  methods: {\r\n    addCount() {\r\n      this.count++\r\n    },\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n  div{\r\n    border: 1px solid gray;\r\n    padding: 20px;\r\n  }\r\n</style>\r\n```\r\n\r\n\r\n### v-model双向绑定父子组件间数据\r\n父子组件数据 `<-->` 子组件数据\r\n```html\r\n<template>\r\n  <div>\r\n    <p>父组件的count:{{count}}</p>\r\n    <button @click=\"addCount\">count++</button>\r\n    <hr>\r\n    <!-- 3.使用 v-model 绑定数据 -->\r\n    <updateCount v-model:count=\"count\"></updateCount>\r\n  </div>\r\n</template>\r\n<script>\r\nimport updateCount from \"./components/updateCount.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components: {\r\n    updateCount\r\n  },\r\n  methods: {\r\n    addCount() {\r\n      this.count++\r\n    },\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n  div{\r\n    border: 1px solid gray;\r\n    padding: 20px;\r\n  }\r\n  </style>\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <p>子组件的count:{{count}}</p>\r\n  <button @click=\"addCount\">count++</button>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n    }\r\n  },\r\n  // 0. props接受参数\r\n  props:[\"count\"],\r\n  //1.注册事件      注意:若props的是一个`v-model:对象`,则传入的是一个`引用`,则可直接修改引用的`对象.属性名`,无需注册事件和触发事件\r\n  emits: [\"update:count\"],\r\n  methods: {\r\n    addCount() {\r\n      // this.count+=1 //无法修改,因为是只读属性\r\n      //2. 触发 update:count 事件 并传递 更新后的值\r\n      this.$emit(\"update:count\",this.count+1)\r\n\r\n\r\n      //3. 如果count是一个数组且watch的deep:false,则更新数据时不能这样写,\r\n            // this.count.push(\"测试数据\")\r\n            // this.$emit(\"update:count\",this.count)\r\n      //4. 如果count是一个数组且watch的deep:false,则更新数据时应该写:\r\n            // this.count.push(\"测试数据\")\r\n            // this.$emit(\"update:count\",[...this.count])\r\n    },\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\ndiv{\r\n  border: 1px solid gray;\r\n  padding: 20px;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n## `todoList案例实现`\r\n\r\n**实现效果**\r\n\r\n![图 1](./images/vue3学习笔记/36385537577cb1b773374304f88394d27b69940b4a5bd239191222889664dab5.png)  \r\n\r\n\r\n\r\n**实现代码**  \r\n`App.vue`\r\n```html\r\n<template>\r\n  <div class=\"todolist_main\">\r\n    <todoListInput @addTask=\"addTask\"></todoListInput>\r\n    <todoListList v-bind:todoListData=\" btnStatus==1?  allTodoListData : btnStatus==2? doneTodoListData : notDoneTodoListData \"></todoListList>\r\n    <toDoListBtns v-model:btnStatus=\"btnStatus\"></toDoListBtns>\r\n  </div>\r\n</template>\r\n<script>\r\nimport todoListInput from \"./components/todoListInput.vue\"\r\nimport todoListList from \"./components/todoListList.vue\"\r\nimport toDoListBtns from \"./components/toDoListBtns.vue\"\r\nexport default {\r\n  components: {//注册子组件\r\n    todoListInput,\r\n    todoListList,\r\n    toDoListBtns\r\n  },\r\n  data() {\r\n    return {//数据\r\n      nextId: 5,//用于创建新任务\r\n      btnStatus: 1, //变化范围:[1,2,3],用于记录按钮状态\r\n      todoList: [\r\n        { id: 0, task: \"测试文字0\", done: true },\r\n        { id: 1, task: \"测试文字1\", done: true },\r\n        { id: 2, task: \"测试文字2\", done: false },\r\n        { id: 3, task: \"测试文字3\", done: true },\r\n        { id: 4, task: \"测试文字4\", done: true },\r\n      ]\r\n    }\r\n  },\r\n  methods: {\r\n    addTask(task) {\r\n      if(!task) return alert(\"任务名称不能为空......\")\r\n      this.todoList.push({\r\n          id: this.nextId++,\r\n          task: task,\r\n          done: false,\r\n      })\r\n    },\r\n  },\r\n  computed: {//计算属性\r\n    allTodoListData() {\r\n      return this.todoList\r\n    },\r\n    doneTodoListData() {\r\n      return this.todoList.filter(item => item.done)\r\n    },\r\n    notDoneTodoListData() {\r\n      return this.todoList.filter(item => !item.done)\r\n    }\r\n  }\r\n\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n.todolist_main {\r\n  margin: 10px auto;\r\n  width: 600px;\r\n}\r\n</style>\r\n```\r\n\r\n`./components/todoListInput.vue`\r\n\r\n```html\r\n<template>\r\n      <div class=\"input-group \">\r\n      <span class=\"input-group-text\" >任务</span>\r\n      <input type=\"text\" class=\"form-control\" placeholder=\"请填写任务信息\" v-model=\"taskName\">\r\n      <button class=\"btn btn-primary\" type=\"button\" @click=\"addTask\">添加新任务</button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  emits:[\"addTask\"],//注册事件\r\n  data(){\r\n    return{\r\n      taskName:\"\"\r\n    }\r\n  },\r\n  methods:{\r\n    addTask(){\r\n      this.$emit(\"addTask\",this.taskName)//触发事件,向外部传递任务名称\r\n      this.taskName=\"\"//清空任务名称\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n`./components/todoListList.vue`\r\n```html\r\n<template>\r\n  <ul class=\"list-group\">\r\n    <li v-for=\"item in todoListData\" :key=\"item.id\"\r\n      class=\"list-group-item d-flex justify-content-between align-items-center\">\r\n      <input class=\"form-check-input tick\" type=\"checkbox\" v-model=\"item.done\">\r\n      <span class=\"context\" :class=\"item.done ? 'ticked':''\" >{{item.task}}</span>\r\n      <span v-if=\"item.done\" class=\"badge bg-success rounded-pill status\">已完成</span>\r\n      <span v-else class=\"badge bg-warning rounded-pill status\">未完成</span>\r\n      <span class=\"badge bg-danger del\" @click=\"del(item.id)\">删除</span>\r\n    </li>\r\n  </ul>\r\n</template>\r\n<script>\r\nexport default {\r\n  props: {\r\n    'todoListData': {//接受待渲染的数据\r\n      type: Array,\r\n      required: true,\r\n      defult: []\r\n    }\r\n  },\r\n  methods: {\r\n    del(id) {//根据id删除数据\r\n      this.todoListData.splice(this.todoListData.filter(item => item.id == id), 1)\r\n    }\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\nul li {\r\n  display: flex;\r\n  justify-content:flex-between;\r\n  .tick {\r\n    margin-right: 10px;\r\n  }\r\n  .context {\r\n    flex:1;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis; /* 省略号 */\r\n    &.ticked{\r\n      text-decoration: line-through green ;\r\n      font-style:italic;/* 倾斜字体 */\r\n      color: gray;\r\n    }\r\n  }\r\n  .status {\r\n    margin-left: 10px;\r\n  }\r\n  .del {\r\n    margin-left: 10px;\r\n    cursor: pointer;\r\n  }\r\n}\r\n</style>\r\n```\r\n\r\n\r\n`./components/toDoListBtns.vue`\r\n```html\r\n<template>\r\n    <div class=\"btn-group btns\" role=\"group\">\r\n        <button type=\"button\" class=\"btn\" :class=\"btnStatus==1? 'btn-primary':'btn-secondary'\" @click=\"changeBtnStatus(1)\">全部</button>\r\n        <button type=\"button\" class=\"btn\" :class=\"btnStatus==2? 'btn-primary':'btn-secondary'\" @click=\"changeBtnStatus(2)\">已完成</button>\r\n        <button type=\"button\" class=\"btn\" :class=\"btnStatus==3? 'btn-primary':'btn-secondary'\" @click=\"changeBtnStatus(3)\">未完成</button>\r\n    </div>\r\n</template>\r\n<script>\r\nexport default {\r\n    emits:[\"update:btnStatus\"],\r\n    props: {\r\n        'btnStatus': {\r\n            type: Number,\r\n            required: true,\r\n            defult: 0\r\n        }\r\n    },\r\n    methods:{\r\n        changeBtnStatus(status){\r\n            this.$emit(\"update:btnStatus\",status)//触发事件,向外传递更新被双向绑定的数据\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n.btns {\r\n    width: 100%;\r\n    display: flex;\r\n    button {\r\n        flex: 1;\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n## watch监听器\r\n\r\n\r\n\r\n**语法格式**\r\n```js\r\n// 基本语法\r\nwatch:{\r\n    变量名(newValue,oldValue){\r\n\r\n    }\r\n}\r\n\r\n// immediate 选项:渲染页面完毕后便执行\r\nwatch:{\r\n    变量名:{\r\n        handler(newValue,oldValue){\r\n            //do something\r\n       },\r\n        immediate:true\r\n}\r\n\r\n// deep选项: 监听对象的属性值的变化\r\nwatch:{\r\n    对象变量名:{\r\n        handler(newValue,oldValue){\r\n            //do something\r\n       },\r\n        immediate:true,\r\n        deep:true\r\n}\r\n\r\n//监听对象中单个属性值的变化\r\nwatch:{\r\n    '对象变量名.属性名':{\r\n        handler(newValue,oldValue){\r\n            //do something\r\n       },\r\n}\r\n```\r\n\r\n**基本使用**\r\n```html\r\n<template>\r\n<input type=\"text\" v-model=\"username\">\r\n<input type=\"text\" v-model=\"email\">\r\n</template>\r\n<script>\r\n  import axios from \"axios\"\r\nexport default{\r\n  data(){\r\n    return{\r\n      username:\"DingYigui\",\r\n      email:\"\"\r\n    }\r\n  },\r\n  watch:{\r\n    async username(newValue,oldValue){//监听username变量值的修改\r\n      console.log(oldValue);\r\n      console.log(newValue);\r\n\r\n      var {data:reqBody} = await axios.get(\"https://www.domain.cn/api/finduser/\" + newValue )\r\n      console.log(reqBody);\r\n    },\r\n    email(newValue,oldValue){\r\n      console.log(newValue);\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n## 生命周期钩子函数\r\n\r\n**组件生命周期**  \r\n**在内存中创建示例对象** ---> **将实例对象渲染到页面** ---> **根据需求销毁示例对象**\r\n\r\n**生命周期函数**  \r\n最常用的是 `mounted` 、 `updated` 和 `unmounted`\r\n![图 3](./images/vue3学习笔记/4caeab7c19b84315bae6af404a5cd296332c01342b32436ff20a582f92b5fd7b.png)  \r\n\r\n**官方文档生命周期图示**\r\n![图 2](./images/vue3学习笔记/a30ce229b7e5e5454aeb56e0f7a7de0cd7a880e1df57020f5ed20bd5a8d5c5d8.png)  \r\n\r\n\r\n## 组件间数据共享\r\n**组件间关系**\r\n* 父子关系\r\n* 后代关系\r\n* 兄弟关系\r\n\r\n### 父子关系组件间数据共享\r\n**`父组件 ---> 子组件 : `**\r\n\r\n父组件通过`v-bind:`向子组件绑定待共享的数据,子组件通过`props属性`接收数据\r\n```html \r\n<template>\r\n  <div>\r\n    <p>子组件的count:{{count}}</p>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  props:[\"count\"],//接受参数\r\n}\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <button @click=\"count++\"></button>\r\n    <!-- v-bind:count=\"count\" 传递参数 -->\r\n    <subComponent v-bind:count=\"count\"></subComponent>\r\n  </div>\r\n</template>\r\n<script>\r\nimport subComponent from \"./components/subComponent.vue\"//导入子组件\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components: {\r\n    subComponent\r\n  },\r\n}\r\n</script>\r\n```\r\n\r\n**`父组件 <--- 子组件 : `**\r\n\r\n子组件通过`emits[\"事件名\"]`注册自定义事件,并通过`this.emit(\"事件名\",传递数据)`触发事件,父组件通过`v-on:事件名=\"处理函数\"`来监听事件,其中处理函数的形式参数为接收到的数据\r\n```html \r\n<template>\r\n  <div>\r\n    <button @click=\"addCount\"></button>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n    data(){\r\n        return{\r\n            count:0\r\n        }\r\n    },\r\n  emits:[\"countUpdate\"],//注册事件\r\n  methods:{\r\n    addCount(){\r\n        this.count++\r\n        this.emit(\"countUpdate\",this.count)//触发事件,向外传递数据\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n      <subComponent @countUpdate=\"getCount\"></subComponent>//监听事件,指定处理函数\r\n        <p>从子组件获取到的gettedCount:{{gettedCount}}</p>\r\n  </div>\r\n</template>\r\n<script>\r\nimport subComponent from \"./components/subComponent.vue\"//导入子组件\r\nexport default {\r\n  data() {\r\n    return {\r\n      gettedCount: 0,\r\n    }\r\n  },\r\n  components: {\r\n    subComponent\r\n  },\r\n  methods:{\r\n    getCount(value){\r\n      this.gettedCount=value\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n**`父组件 <--> 子组件 :`**  \r\n父组件通过`v-model=\"变量名\"`向子组件绑定待共享的数据,子组件通过`emits[\"update:变量名\"]`注册数据更新事件,并通过`this.emit(\"update:变量名\",传递数据)`触发事件,父组件的变量便能自动接收到更新的数据\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <p>父组件的count:{{count}}</p>\r\n    <button @click=\"addCount\">count++</button>\r\n    <hr>\r\n    <!-- 3.使用 v-model 绑定数据 -->\r\n    <subComponent v-model:count=\"count\"></subComponent>\r\n  </div>\r\n</template>\r\n<script>\r\nimport subComponent from \"./components/subComponent.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components: {\r\n    subComponent\r\n  },\r\n  methods: {\r\n    addCount() {\r\n      this.count++\r\n    },\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <p>子组件的count:{{count}}</p>\r\n  <button @click=\"addCount\">addCount</button>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  props:[\"count\"],\r\n  emits: [\"update:count\"],\r\n  methods: {\r\n    addCount() {\r\n      this.$emit(\"update:count\",this.count+1)//触发 update:count 事件 并传递 更新后的值\r\n    },\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n### 后代关系组件间数据共享\r\n**`父组件数据 ---> 子组件数据`**  \r\n```html\r\n<template>\r\n  <p>{{count}}</p>\r\n</template>\r\n\r\n<script>\r\n\r\nexport default {\r\n    inject:[\"count\"]\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n  <p>{{count}}</p>\r\n  <button @click=\"count++\">count++</button>\r\n<subTempVue></subTempVue>\r\n</template>\r\n<script>\r\n  import {computed} from \"vue\"\r\n  import subTempVue from \"./components/subTemp.vue\"\r\nexport default{\r\n  data(){\r\n    return{\r\n      count:0,\r\n    }\r\n  },\r\n  components:{\r\n    subTempVue\r\n  },\r\n  provide(){\r\n    return{\r\n    //   count:this.count,  //这种方式共享的数据 当this.cout数据更新时,子组件接收到的数据将不会更新\r\n      count:computed(()=>this.count), // 这种方式能够更新\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n### 兄弟关系组件间数据共享\r\n**`父组件数据 <---> 子组件数据`**  \r\n\r\nmitt\r\n**安装mitt**\r\n```\r\nnpm i mitt\r\n```\r\n\r\n`mittEventBus.js`\r\n```js\r\nimport mitt from \"mitt\"\r\nconst bus = mitt()\r\nexport default bus\r\n```\r\n\r\n`subTemp.vue 和 subTemp2.vue`\r\n```html\r\n<template>\r\n  <p>{{count}}</p>\r\n  <button @click=\"count++\">count++</button>\r\n</template>\r\n\r\n<script>\r\nimport bus from \"./mittEventBus\"\r\nexport default{\r\n    data(){\r\n        return{\r\n            count:0\r\n        }\r\n    },\r\n    created(){\r\n        bus.on(\"countUpdate\",(value)=>{//监听事件\r\n          this.count = value\r\n        })\r\n    },\r\n    updated(){\r\n        bus.emit(\"countUpdate\",this.count)//触发事件\r\n    },\r\n}\r\n</script>\r\n```\r\n\r\n`App.vue`\r\n```html\r\n<template>\r\n<subTempVue></subTempVue>\r\n<subTemp2Vue></subTemp2Vue>\r\n</template>\r\n<script>\r\n  import subTempVue from \"./components/subTemp.vue\"\r\n  import subTemp2Vue from \"./components/subTemp2.vue\"\r\nexport default{\r\n  components:{\r\n    subTempVue,\r\n    subTemp2Vue\r\n  },\r\n}\r\n</script>\r\n```\r\n\r\n### VueX全局数据共享\r\n\r\n\r\n#### 概念\r\nvueX 可以让组件间数据共享高效清晰易维护\r\n\r\n传统共享数据方式 和 vuex共享数据方式 区别\r\n![图 4](./images/vue3学习笔记/a8fcf1f513f66d1815212170da475dc9e1893ff300ec7584c6e063c249db48ce.png)  \r\n\r\n\r\n#### vuex原理\r\n![图 1](./images/vue3学习笔记/a0d4da5f13a6d0c8aa9d4d1cf30a63caff2acca4d44447c362de4ea0362e1b2a.png)  \r\n\r\n\r\n#### 基本使用\r\n\r\n`store/index.js`\r\n```js\r\nimport { createStore } from 'vuex'\r\n\r\nconst state =function () {//state用于存储数据,在vueX4中是一个函数,在VueX3值中是一个对象\r\n    return {\r\n      count: 0 ;\r\n    }\r\n}\r\nconst actions = {//用于响应组件中的动作\r\n  // add(miniStore,value){ //第一个参数是一个阉割版的store 可认为是miniStore 也可认为是context\r\n  add({dispatch,commit,state},value){ //\r\n    commit('ADD',value)\r\n  }\r\n}\r\nconst mutations = {//用于操作数据\r\n  ADD(state,value){\r\n    state.count += value\r\n  }\r\n}\r\n\r\nconst getters = {//非必要的属性,相当于组件的计算属性\r\n  bigCount(state){\r\n    return state.count * 5.123 \r\n  }\r\n}\r\n\r\n// 创建一个新的 store 实例\r\nconst store = createStore({\r\n  actions,\r\n  mutations,\r\n  state,\r\n  getters\r\n})\r\n\r\n// 将 store 实例作为插件安装\r\nexport default store\r\n```\r\n\r\n`main.js`\r\n```js\r\nimport { createApp } from 'vue'\r\nconst app = createApp(App)\r\n\r\napp.use(store)//注册store\r\n\r\napp.mount('#app')\r\n```\r\n\r\n\r\n**组件中操作store**\r\n`someCompoment.vue`\r\n```js\r\n//修改数据\r\nthis.$store.state.dispatch('add',15)\r\n$store.state.dispatch('add',15)\r\n$store.state.commit('ADD',15)\r\n\r\n//展示数据\r\nthis.$store.state.count\r\n$store.state.count\r\n{{this.$store.state.count}}\r\n$store.getters.bigCount\r\n```\r\n\r\n**利用 `mapState` `mapGatters` 在组件中简洁的使用数据**\r\n```js\r\nimport {mapState,mapGatters} from 'vuex'\r\n\r\ncomputed:{//组件的计算属性\r\n  // 手动写计算属性\r\n  // countA : ()=>{return this.$store.state.count}, //使用: {{countA}}\r\n\r\n  // 利用mapState自动生成计算属性\r\n  ...mapState({'countA':'count', ... }),// 等效于 countA : ()=>{return this.$store.state.count}, //使用: {{countA}}\r\n  ...mapmapState(['count', ... ]), // 等效于 count : ()=>{return this.$store.state.count}         //使用: {{count}}\r\n  \r\n  // 利用mapGatters自动生成计算属性\r\n  ...mapGatters({'bigsum':'sum', ... }),// 等效于 bigsum : ()=>{return this.$store.getters.sum}  //使用: {{bigsum}}\r\n  ...mapGatters(['sum', ... ]),// 等效于 sum : ()=>{return this.$store.getters.sum}             //使用: {{sum}}\r\n}\r\n```\r\n\r\n**利用 `mapMutations` `mapActions` 在组件中简洁的使用数据**\r\n```js\r\nimport {mapActions,mapMutationss} from 'vuex'\r\nmethods:{\r\n  //派发行为 dispatch\r\n  ...mapActions({'addCount': \"add\", ... }), //等效于  addCount(value){ this.$store.dispatch('add',value) }   //使用: @click=\"addCount(value)\"\r\n  ...mapActions([\"add\", ... ]), //等效于  add(value){ this.$store.dispatch('add',value) }                     //使用: @click=\"add(value)\"\r\n\r\n  //Mutation  直接发送commit\r\n  ...mapMutations({'ADDCount':\"ADD\", ... }), //等效于  addCount(value){ this.$store.commit('ADD',value) }    //使用: @click=\"ADDCount(value)\"\r\n  ...mapMutations(['ADD', ... ]), //等效于  ADD(value){ this.$store.commit('ADD',value) }                   //使用: @click=\"ADD(value)\"\r\n}\r\n```\r\n\r\n#### vueX的模块化\r\n\r\n`countAbout.js`子模块\r\n```js\r\nconst state =function () {\r\n    return {\r\n      count: 0 ;\r\n    }\r\n}\r\nconst actions = {\r\n  add({dispatch,commit,state},value){\r\n    commit('ADD',value)\r\n  }\r\n}\r\nconst mutations = {\r\n  ADD(state,value){\r\n    state.count += value\r\n  }\r\n}\r\nconst getters = {\r\n  bigCount(state){\r\n    return state.count * 5.123 \r\n  }\r\n}\r\n\r\nconst countAbout = { //子模块对象\r\n  namespaced:true,//启用命名空间 启用后可以使用这种格式的mapState :    `...mapState('countAbout',['count', ... ])`\r\n  state,\r\n  actions,\r\n  mutations,\r\n  getters,\r\n}\r\n\r\nexport default countAbout //导出vuex子模块\r\n```\r\n\r\n`store.js`\r\n```js\r\nimport countAbout from 'countAbout.js'\r\nimport { createStore } from 'vuex'\r\n\r\n// 创建一个新的 store 实例\r\nconst store = createStore({\r\n  modules:{\r\n    countAbout,\r\n    //其他子模块...\r\n    anotherSubStore,//另一个子store\r\n  }\r\n})\r\n\r\n// 导出store\r\nexport default store\r\n```\r\n\r\n`main.js`入口文件\r\n```js\r\nimport store from 'store.js'\r\napp.use(store)\r\n```\r\n\r\n在组件中使用 `mapState` `mapGatters` `mapMutations` `mapActions`\r\n```js\r\nimport {mapState,mapGatters,mapActions,mapMutations} from 'vuex'\r\n{\r\n  computed:{//组件的计算属性\r\n    //vueX没模块化后没有启用命名空间的原始写法:\r\n    ...mapState({'countAbout':'countAbout', ... }), // 等效于 countAbout : ()=>{return this.$store.state.countAbout}, //使用: {{countAbout.count}}\r\n    ...mapState(['countAbout', ... ]),              // 等效于 countAbout : ()=>{return this.$store.state.countAbout}, //使用: {{countAbout.count}}\r\n    ...mapState({'count':state=>state.countAbout.count, ... }), // 等效于 countAbout : ()=>{return this.$store.state.countAbout}, //使用: {{count}}\r\n\r\n    //模块化后并启用命名空间后写法:\r\n    // 利用mapState自动生成计算属性\r\n    ...mapState('countAbout',{'countA':'count', ... }), // 等效于 countA : ()=>{return this.$store.state.countAbout.count}, //使用: {{countA}}\r\n    ...mapState('countAbout',['count', ... ]),          // 等效于 count : ()=>{return this.$store.state.countAbout.count}   //使用: {{count}}\r\n    // 利用mapGatters自动生成计算属性\r\n    ...mapGatters('countAbout',{'bigsum':'sum', ... }), // 等效于 bigsum : ()=>{return this.$store.getters['countAbout/sum']}  //使用: {{bigsum}}\r\n    ...mapGatters('countAbout',['sum', ... ]),          // 等效于 sum : ()=>{return this.$store.getters['countAbout/sum']}     //使用: {{sum}}\r\n  }\r\n  methods:{\r\n    //派发行为 dispatch\r\n    ...mapActions('countAbout',{'addCount': \"add\", ... }),  //等效于  addCount(value){ this.$store.dispatch('countAbout/add',value) }   //使用: @click=\"addCount(value)\"\r\n    ...mapActions('countAbout',[\"add\", ... ]),              //等效于  add(value){ this.$store.dispatch('countAbout/add',value) }        //使用: @click=\"add(value)\"\r\n    //Mutation  直接发送commit\r\n    ...mapMutations('countAbout',{'ADDCount':\"ADD\", ... }), //等效于  addCount(value){ this.$store.commit('countAbout/ADD',value) }    //使用: @click=\"ADDCount(value)\"\r\n    ...mapMutations('countAbout',['ADD', ... ]),            //等效于  ADD(value){ this.$store.commit('countAbout/ADD',value) }         //使用: @click=\"ADD(value)\"\r\n  }\r\n}\r\n```\r\n\r\n\r\n### Pinia\r\n\r\n\r\n![](./images/index/2022-11-24-15-01-43.png)\r\n\r\npinia 中文文档：https://pinia.web3doc.top/\r\n\r\n#### 1、简单例子\r\n\r\n\r\n**注册Pinia**\r\n```js\r\nimport { createPinia } from 'pinia'\r\napp.use(createPinia())\r\n```\r\n\r\n**定义`Pinia`的`state`、`actions`、`getters`、`Setters`**\r\n```js\r\n// stores/counterStore.js\r\nimport { defineStore } from 'pinia'\r\n\r\n// defineStore 函数返回值本质是一个Hooks\r\nexport const useCounterStore = defineStore('counter', {\r\n  state: () => ({\r\n    count: 0\r\n  }),\r\n\r\n  actions: {\r\n    increment() {\r\n      this.count++\r\n      // console.log(0)\r\n    }\r\n  },\r\n\r\n  getters: {\r\n    doubleCount() {\r\n      return this.count*2\r\n    }\r\n  }\r\n})\r\nexport const counterStore = useCounterStore() // 导出CounterStore实例\r\n```\r\n\r\n```vue\r\n<script setup>\r\n  import { storeToRefs } from 'pinia'\r\n  import { counterStore } from '@/stores/counterStore'\r\n  // const couterStore = useCounterStore()\r\n  \r\n  //从 Store 中提取属性同时保持其响应式，您需要使用storeToRefs()。 \r\n  //它将为任何响应式属性创建 refs。 当您仅使用 store 中的状态但不调用任何操作时，\r\n  const { count, doubleCount } = storeToRefs(counterStore)\r\n</script>\r\n\r\n<template>\r\n  <div>\r\n    {{ count }} \r\n    {{ doubleCount }}\r\n    <button @click=\"couterStore.increment\">+</button>\r\n  </div>\r\n</template>\r\n\r\n<style lang=\"css\">\r\n/* css 代码 */\r\n</style>\r\n ```\r\n\r\n#### 2、购物车案例\r\n\r\n```js\r\n// data/api.js\r\nfunction catchDataApi() {// 模拟服务端发来的数据，用promise实现\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      resolve([\r\n        {\r\n          id: 1,\r\n          name: 'iphone12',\r\n          price: 3000,\r\n          inventory: 3\r\n        },\r\n        {\r\n          id: 2,\r\n          name: 'iphone13',\r\n          price: 8000,\r\n          inventory: 3\r\n        },\r\n        {\r\n          id: 3,\r\n          name: 'iphone14',\r\n          price: 13000,\r\n          inventory: 2\r\n        }\r\n      ])\r\n    }, 1000)\r\n  })\r\n}\r\n\r\nexport default catchDataApi\r\n```\r\n\r\n```js\r\n// store/productStore.js\r\nimport { defineStore } from 'pinia'\r\nimport catchDataApi from '../data/api'\r\n\r\nexport const useProductStore = defineStore({\r\n  id: 'productStore',\r\n\r\n  state: () => ({\r\n    products: []\r\n  }),\r\n\r\n  actions: {\r\n    async loadData() {\r\n      try {\r\n        const data = await catchDataApi()\r\n        this.products = data\r\n      } catch (error) {\r\n\r\n      }\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n```js\r\n// store/cartStore.js\r\nimport { defineStore, storeToRefs } from 'pinia'\r\nimport { useProductStore } from './productStore'\r\nexport const useCartStore = defineStore({\r\n  id: 'cartStore',\r\n\r\n  state: () => ({\r\n    cartList: []\r\n  }),\r\n\r\n  // cartList = [\r\n  //   {\r\n  //     id: 1,\r\n  //     name: 'iphone12',\r\n  //     price: 10000,\r\n  //     quantity: 1\r\n  //   }\r\n  // ]\r\n\r\n  actions: {\r\n    addToCart(product) {\r\n      // 在购物车里查找是否有这个商品\r\n      const p = this.cartList.find((item) => {\r\n        return item.id === product.id\r\n      })\r\n\r\n      // 如果找到了，购物车里的这个商品的数量加 1\r\n      // 如果没有没有找到，添加这个商品到购物车\r\n      if (!!p) {\r\n        p.quantity++\r\n      } else {\r\n        this.cartList.push({\r\n          ...product,\r\n          quantity: 1\r\n        })\r\n      }\r\n\r\n      // 当点击放入购物车，这个商品的库存需要减少一个\r\n      const productStore = useProductStore()\r\n      const { products } = storeToRefs(productStore)\r\n      const p2 = products.value.find((item) => {\r\n        return item.id === product.id\r\n      })\r\n      p2.inventory--\r\n    }\r\n  },\r\n\r\n  getters: {\r\n    totalPrice() {\r\n      return this.cartList.reduce((sum, item) => {\r\n        return sum + item.price * item.quantity\r\n      }, 0)\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n```vue\r\n// views/Product.vue\r\n<script setup>\r\nimport { storeToRefs } from 'pinia'\r\nimport { useProductStore } from '@/stores/productStore'\r\nimport { useCartStore } from '@/stores/cartStore'\r\nconst productStore = useProductStore()\r\nconst cartStore = useCartStore()\r\nconst { products } = storeToRefs(productStore)\r\nconst { addToCart } = cartStore\r\nproductStore.loadData()\r\n</script>\r\n\r\n<template>\r\n  <h1>产品列表</h1>\r\n  <hr>\r\n  <ul>\r\n    <li\r\n      v-for=\"product in products\"\r\n    >\r\n      {{product.name}} - ￥{{product.price}}\r\n      <button \r\n        @click=\"addToCart(product)\"\r\n        :disabled=\"product.inventory <= 0\"\r\n      >放入购物车</button>\r\n    </li>\r\n  </ul>\r\n</template>\r\n\r\n<style lang=\"css\">\r\n/* css 代码 */\r\n</style>\r\n```\r\n\r\n```vue\r\n// views/Cart.vue\r\n<script setup>\r\nimport { storeToRefs } from 'pinia'\r\nimport { useCartStore } from '@/stores/cartStore'\r\nconst cartStore = useCartStore()\r\nconst { cartList, totalPrice } = storeToRefs(cartStore)\r\n</script>\r\n\r\n<template>\r\n  <h1>购物车</h1>\r\n  <hr>\r\n  <ul>\r\n    <li v-for=\"product in cartList\">\r\n      {{product.name}} : {{product.quantity}} x ￥{{product.price}} = ￥{{product.quantity * product.price}}\r\n    </li>\r\n  </ul>\r\n  <div>\r\n    总价：￥{{totalPrice}}\r\n  </div>\r\n</template>\r\n\r\n<style lang=\"css\">\r\n/* css 代码 */\r\n</style>\r\n```\r\n\r\n```vue\r\n// App.vue\r\n<script setup>\r\nimport Product from '@/views/Product.vue'\r\nimport Cart from '@/views/Cart.vue'\r\n</script>\r\n\r\n<template>\r\n  <Product></Product>\r\n  <Cart></Cart>\r\n</template>\r\n\r\n<style lang=\"css\">\r\n/* css 代码 */\r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n### 总结\r\n* 父子关系组件间数据共享\r\n  * 父`--->`子 属性绑定\r\n  * 父`<---`子 事件绑定\r\n  * 父`<-->`子 v-model\r\n* 后代关系组件间数据共享\r\n  * provide & inject    (父--->后代)\r\n* 兄弟关系组件间数据共享\r\n  * mitt (EventBus)\r\n* 全局数据共享\r\n  * vuex\r\n\r\n\r\n## lodash节流防抖:throttle()\r\n```js\r\nimport {throttle} from 'lodash' //节流防抖\r\n    methods: {\r\n        ...mapActions('home',['getCategoryList']),\r\n        changeIndex:throttle(\r\n            function(index){\r\n                this.currentIndex = index;\r\n                console.log(this);\r\n            },\r\n            200,\r\n        ),\r\n        // 错误写法\r\n        // changeIndex(index){\r\n        //     throttle(\r\n        //         function(index){\r\n        //             this.currentIndex = index;\r\n        //             console.log(this);\r\n        //         },\r\n        //         200,\r\n        //     )\r\n        // },\r\n    }\r\n```\r\n\r\n\r\n## axios\r\n### 全局配置axios\r\n`./src/main.js`\r\n```js\r\nimport { createApp } from 'vue'\r\nimport axios from 'axios'\r\n\r\nimport './style.css'\r\nimport App from './App.vue'\r\n\r\n\r\naxios.defaults.baseURL=\"htts://api.com\"     //配置axios,设置baseURL,以后每次发送请求便不必写完整URL,请求只需要写 axios.get(\"/userinfo\") \r\n\r\nconst app = createApp(App)\r\napp.config.globalProperties.$http = axios //将axios挂载为app的全局自定义属性,从此每个组件的this上都可以直接访问到axios\r\n\r\napp.mount('#app')\r\n```\r\n\r\n### axios的拦截器\r\n\r\n**概念**\r\n* 请求拦截器,从axios发出给API接口服务器的请求将经过请求拦截器\r\n* 响应拦截器,从API接口服务器发回axios的响应将经过响应拦截器\r\n\r\n**请求拦截器**\r\n```js\r\n  // ......\r\naxios.interceptors.request.use(成功回调[,失败回调])\r\naxios.interceptors.response.use(成功回调[,失败回调])\r\n\r\n//示例\r\naxios.interceptors.request.use(config => {\r\n  //修改config\r\n  // ......\r\n  \r\n  //返回config\r\n  return config\r\n},error => {\r\n  return Promise.reject(error)\r\n})\r\n```\r\n\r\n\r\n**为请求头添加token认证**\r\naxios.js\r\n```js\r\nimport axios from 'axios'\r\naxios.defaults.baseURL = 'https://hostname.ltd'\r\naxios.interceptors.request.use(config => {\r\n  //修改config\r\n  config.headers.Authorization = 'Bearer XXX'  \r\n  //返回config\r\n  return config\r\n},error => {//\r\n  return Promise.reject(error)\r\n})\r\n\r\nexport default axios\r\n```\r\n\r\n**loading效果**\r\n```js\r\n// 1.按需导入\r\nimport {Loading} from 'element-ui' //vue2\r\n//声明用于存储Loading实例的变量\r\nlet LoadingInstance = null\r\n\r\naxios.interceptors.request.use(config => {\r\n  //修改config\r\n  config.headers.Authorization = 'Bearer XXX'\r\n  //创建Loading实例\r\n  LoadingInstance = Loading.service({fullscreen:true})\r\n  //返回config\r\n  return config\r\n});\r\n\r\naxios.interceptors.response.use(response => {\r\n  //关闭Loading的实例对象\r\n  LoadingInstance.close()\r\n  return response\r\n});\r\nexport default axios\r\n```\r\n\r\n\r\n\r\n\r\n###  axios配置nprogress进度条\r\n```js\r\nimport axios from 'axios'\r\n\r\nimport nprogress from 'nprogress'//进度条\r\nimport 'nprogress/nprogress.css'//加载的进度条样式\r\n\r\n// axios.defaults.baseURL = ''\r\nlet http = axios.create({\r\n    baseURL: ' http://????/api',\r\n    timeout: 5000,//5s为超时\r\n    //配置 ... \r\n})\r\n\r\n//请求拦截器\r\nhttp.interceptors.request.use((config) => {\r\n    // config.headers\r\n    //进度条开始\r\n    nprogress.start()\r\n\r\n    return config\r\n})\r\n//响应拦截器\r\nhttp.interceptors.response.use(\r\n    (response) => {\r\n        //进度条结束\r\n        nprogress.done()\r\n        return response\r\n    },\r\n    (err) => {\r\n        return Promise.reject(new Error('faile'))\r\n    }\r\n)\r\n\r\nexport default http\r\n```\r\n\r\n\r\n## `购物车案例实现`\r\n实现效果\r\n![图 5](./images/vue3学习笔记/2fbb08b7c47acdb960512432c3bdf516796121e7cb6e05b61525a1239647624b.png)  \r\n\r\n\r\n代码\r\n\r\n`main.js`\r\n```js\r\nimport { createApp } from 'vue'\r\nimport axios from 'axios'\r\nimport 'bootstrap'\r\nimport './style.css'\r\nimport App from './App.vue'\r\n\r\naxios.defaults.baseURL='https://escook.cn' //配置axios\r\nlet app = createApp(App)\r\napp.config.globalProperties.$http=axios //在this上全局挂载axios\r\n\r\napp.mount('#app')\r\n```\r\n\r\n`App.vue`\r\n```html\r\n<template>\r\n\r\n  <esHeaderVue \r\n  headerName=\"购物车\" \r\n  :height=\"40+'px'\"\r\n  ></esHeaderVue>\r\n\r\n  <esOrderListVue\r\n  :orderList=\"orderList\" \r\n  :paddingTop=\"40+'px'\" \r\n  :paddingBottom=\"60+'px'\"\r\n  ></esOrderListVue>\r\n\r\n  <esFooterVue \r\n  :height=\"60+'px'\" \r\n  @checkboxChanged=\"changeAllBeSelecttedStatus\"\r\n  :allIsSelectted=\"allIsSelectted\"\r\n  :totalPrice=\"totalPrice\" \r\n  :countSelectted=\"countSelectted\"\r\n  ></esFooterVue>\r\n\r\n</template>\r\n<script>\r\nimport esHeaderVue from './components/esHeader.vue';\r\nimport esOrderListVue from './components/esOrderList.vue';\r\nimport esFooterVue from './components/esFooter.vue'\r\nexport default\r\n  {\r\n    components:\r\n    {\r\n      esHeaderVue,\r\n      esOrderListVue,\r\n      esFooterVue\r\n    },\r\n    data() {\r\n      return {\r\n        orderList: \r\n        [\r\n          //测试数据\r\n          { \"id\": 1, \"goods_name\": \"班俏BANQIAO超火ins潮卫衣女士2020秋季新款韩版宽松慵懒风薄款外套带帽上衣\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/1.png\", \"goods_price\": 108, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 2, \"goods_name\": \"嘉叶希连帽卫衣女春秋薄款2020新款宽松bf韩版字母印花中长款外套ins潮\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/2.png\", \"goods_price\": 129, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 3, \"goods_name\": \"思蜜怡2020休闲运动套装女春秋季新款时尚大码宽松长袖卫衣两件套\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/3.png\", \"goods_price\": 198, \"goods_count\": 1, \"goods_state\": false },\r\n          { \"id\": 4, \"goods_name\": \"思蜜怡卫衣女加绒加厚2020秋冬装新款韩版宽松上衣连帽中长款外套\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/4.png\", \"goods_price\": 99, \"goods_count\": 1, \"goods_state\": false },\r\n          { \"id\": 5, \"goods_name\": \"幂凝早秋季卫衣女春秋装韩版宽松中长款假两件上衣薄款ins盐系外套潮\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/5.png\", \"goods_price\": 156, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 6, \"goods_name\": \"ME&CITY女装冬季新款针织抽绳休闲连帽卫衣女\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/6.png\", \"goods_price\": 142.8, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 7, \"goods_name\": \"幂凝假两件女士卫衣秋冬女装2020年新款韩版宽松春秋季薄款ins潮外套\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/7.png\", \"goods_price\": 219, \"goods_count\": 2, \"goods_state\": true },\r\n          { \"id\": 8, \"goods_name\": \"依魅人2020休闲运动衣套装女秋季新款秋季韩版宽松卫衣 时尚两件套\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/8.png\", \"goods_price\": 178, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 9, \"goods_name\": \"芷臻(zhizhen)加厚卫衣2020春秋季女长袖韩版宽松短款加绒春秋装连帽开衫外套冬\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/9.png\", \"goods_price\": 128, \"goods_count\": 1, \"goods_state\": false },\r\n          { \"id\": 10, \"goods_name\": \"Semir森马卫衣女冬装2019新款可爱甜美大撞色小清新连帽薄绒女士套头衫\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/10.png\", \"goods_price\": 153, \"goods_count\": 1, \"goods_state\": false }\r\n        ]\r\n      }\r\n    },\r\n    created() {//created生命周期函数,创建完毕后便调用\r\n      this.getOrderList()\r\n    },\r\n    computed: {\r\n        selectted(){//筛选出选中的项\r\n            return this.orderList.filter(item => item.goods_state)\r\n        },\r\n        totalPrice() {//计算总价\r\n            let totalPrice = 0\r\n            this.selectted.forEach(element => {\r\n                totalPrice += element.goods_price * element.goods_count\r\n            });\r\n            return totalPrice.toFixed(2);//保留两位小数\r\n        },\r\n        countSelectted(){//选中商品数\r\n            return this.selectted.length\r\n        },\r\n        allIsSelectted(){//计算是否全部被选中\r\n            for (let index = 0; index < this.orderList.length; index++) {\r\n                const element = this.orderList[index];\r\n                if(!element.goods_state)\r\n                    return false\r\n                else\r\n                    continue\r\n            }\r\n            return true\r\n        },\r\n    },\r\n    methods:{\r\n      async getOrderList() {//获取订单列表\r\n        let { data: reqBody } = await this.$http.get(\"/api/cart\")\r\n        // this.orderList = reqBody.list\r\n      },\r\n        changeAllBeSelecttedStatus(){//选中全部 或 全部取消选中\r\n            let nowStates = this.allIsSelectted\r\n            this.orderList.forEach(element=>{\r\n                element.goods_state= !nowStates\r\n            })\r\n        }\r\n    }\r\n  }\r\n</script>\r\n<style scoped>\r\n\r\n</style>\r\n```\r\n\r\n`esHeader.vue`\r\n```html\r\n<template>\r\n  <div class=\"esHeaderBox\" :style=\"{'color':color,'background-color': bgcolor,'height':height}\">\r\n  {{headerName}}\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    props:{\r\n        'headerName':{\r\n            type:String,\r\n            required:true,\r\n            default:\"默认标题\",\r\n        },\r\n        'color':{\r\n            type:String,\r\n            default:\"white\",\r\n        },\r\n        'bgcolor':{\r\n            type:String,\r\n            default:\"#0d6efd\",\r\n        },\r\n        'height':{\r\n            type:String,\r\n            default:\"40px\"\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n    .esHeaderBox{\r\n        height: 40px;\r\n        width: 100%;\r\n        display: flex;\r\n        justify-content: center;/*左右居中*/\r\n        align-items: center;/*上下居中*/\r\n        position: fixed;\r\n        top: 0;\r\n        left: 0;\r\n        z-index: 9999;\r\n    }\r\n</style>\r\n```\r\n\r\n`esOrderList.vue`\r\n```html\r\n<template>\r\n    <div class=\"orderListBox\" :style=\"{'padding-top': paddingTop,'padding-bottom': paddingBottom}\">\r\n        <ul>\r\n            <li v-for=\"item in orderList\" :key=\"item.id\">\r\n                <div class=\"form-check checkbox\">\r\n                    <input class=\"form-check-input\" type=\"checkbox\" v-model=\"item.goods_state\">\r\n                </div>\r\n                <img :src=\"item.goods_img\" alt=\"\">\r\n                <div class=\"orderInfo\">\r\n                    <div class=\"goods_name\">{{item.goods_name}}</div>\r\n                    <div class=\"goods_price_info\">\r\n                        <span class=\"goods_price\">¥{{item.goods_price}}</span>\r\n                        <esCounterVue v-model:count=\"item.goods_count\" :min=\"1\"></esCounterVue>\r\n                    </div>\r\n                </div>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport esCounterVue from './esCounter.vue';\r\nexport default {\r\n    props: {\r\n        orderList: {\r\n            type: Array,\r\n            require: true,\r\n        },\r\n        paddingTop:{\r\n            type:String,\r\n            default:\"40px\"\r\n        },\r\n        paddingBottom:{\r\n            type:String,\r\n            default:\"40px\"\r\n        },\r\n    },\r\n    components: {\r\n        esCounterVue\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.orderListBox {\r\n    ul,\r\n    li {\r\n        list-style: none;\r\n        padding: 0;\r\n        margin: 0;\r\n    }\r\n\r\n    li {\r\n        display: flex;\r\n        padding: 10px;\r\n        border-bottom: 1px solid rgb(240, 240, 240);\r\n\r\n        .checkbox {\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            /*左右居中*/\r\n            width: 40px;\r\n\r\n            input {\r\n                border-radius: 50%;\r\n            }\r\n        }\r\n\r\n        img {\r\n            height: 100px;\r\n            width: 100px;\r\n        }\r\n\r\n        .orderInfo {\r\n            flex: 1;\r\n            display: flex;\r\n            flex-direction: column;\r\n            justify-content: space-between;\r\n            margin-left: 10px;\r\n\r\n            .goods_price_info {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                /*上下居中*/\r\n                align-items: center;\r\n                .goods_price {\r\n                    color: red;\r\n                    font-weight: bold;\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n</style>\r\n```\r\n\r\n\r\n`esCounter.vue`\r\n```html\r\n<template>\r\n    <div class=\"counterBox\">\r\n        <button class=\"btn\" @click=\"myCount--\">-</button>\r\n        <!-- @keyup.enter=\"event=>event.target.value=myCount\"表示当enter键抬起事件发生后重新更新input的value,否则当在结合[ v-model.lazy]使用时不会自动更新,显示错误值 -->\r\n        <!-- <input class=\"\" type=\"text\" v-model.lazy=\"myCount\" @keyup.enter=\"event=>event.target.value=myCount\"> -->\r\n        <!-- 下面一行代码完美解决了上述问题 -->\r\n        <input class=\"\" type=\"text\" :value=\"myCount\" @focusout=\"myCount = $event.target.value\">\r\n        <button class=\"btn\" @click=\"myCount++\">+</button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    props: {\r\n        count:{\r\n            type:Number,\r\n            require: true\r\n        },\r\n        min:{\r\n            type:Number,\r\n            default: NaN //默认值表示不进行最小值检查\r\n        }\r\n    },\r\n    emits: [\"update:count\"],\r\n    data(){\r\n        return{\r\n            //本地数据 myCount\r\n            myCount:this.count\r\n        }\r\n    },\r\n    methods: {\r\n        setCount(newValue){//设置外部数据 count\r\n            this.$emit(\"update:count\",newValue)\r\n        }\r\n    },\r\n    watch:{\r\n        // 监听 外部数据 count 的改变 和本地数据 myCount 的改变 \r\n        // 使得 myCount ----> `myCount++ 或 myCount-- 或 从input标签输入myCount` ---->  数据合法性检测 ----> count\r\n        // 使得 myCount <------------------------------------------------------------------------------ count\r\n        \r\n        count(newVal){//监听 外部数据 count 的改变,然使其更新到myCount\r\n            this.myCount = newVal\r\n        },\r\n        myCount(newVal,oldVal){//监听 本地数据 myCount 的改变,然使其更新到 外部数据 count\r\n            newVal = parseInt(newVal)\r\n            oldVal = parseInt(oldVal)\r\n            if(typeof newVal == 'number' &&  (this.min == NaN ||  newVal >= this.min) )//判断是否合法\r\n            {\r\n                this.setCount(newVal) //数据合法,则向外部更新新值\r\n            }\r\n            else{\r\n                this.myCount=oldVal //保持原值\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.counterBox {\r\n    display: flex;\r\n    // 水平\r\n    justify-content: space-between;\r\n    // 垂直居中\r\n    align-items: center;\r\n    button{\r\n        // height: 1em;\r\n        padding-top: 0;\r\n        padding-bottom: 0;\r\n    }\r\n    input,p{\r\n        max-width: 3em;\r\n        text-align: center;\r\n        padding: 0 10px;\r\n        border: 1px solid rgb(220, 220, 220);\r\n        border-radius: 5px;\r\n        font-size: smaller;\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n`esFooter.vue`\r\n```html\r\n<template>\r\n    <div class=\"esFooterBox\" :style=\"{'height':height}\">\r\n        <div class=\"form-check\">\r\n            <input class=\"form-check-input\" type=\"checkbox\" :checked=\"allIsSelectted\" @change=\"checkboxChanged\" id=\"esFooterBox_selecttedAll\">\r\n            <label class=\"form-check-label\" for=\"esFooterBox_selecttedAll\">全选</label>\r\n        </div>\r\n        <div class=\"totalPrice\">\r\n            合计: <span>¥{{totalPrice}}</span> \r\n        </div>\r\n        <button class=\"btn btn-primary checkOut\">\r\n            结算:({{countSelectted}})\r\n        </button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    emits: [\"checkboxChanged\"],\r\n    props: {\r\n        'height': {\r\n            type: String,\r\n            default: \"60px\"\r\n        },\r\n        'allIsSelectted':{\r\n            type:Boolean,\r\n            require:true\r\n        },\r\n        'totalPrice':{\r\n            type:[Number,String],\r\n            require:true\r\n        },\r\n        'countSelectted':{\r\n            type:Number,\r\n            require:true\r\n        }\r\n    },\r\n    methods:{\r\n        checkboxChanged(){\r\n            this.$emit('checkboxChanged')\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.esFooterBox {\r\n    display: flex;\r\n    justify-content:space-between;/*左右居中*/\r\n    align-items: center;/*上下居中*/\r\n    position: fixed;\r\n    bottom: 0;\r\n    left: 0;\r\n    z-index: 9999;\r\n    width: 100%;\r\n    padding:0 10px;\r\n    background-color: white;\r\n    .totalPrice{\r\n        span{\r\n            color: red;\r\n        }\r\n    }\r\n    .checkOut{\r\n        padding: 10px 20px;\r\n        border-radius:99999px;\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n## DOM的引用---ref属性\r\n\r\n```html\r\n<template>\r\n  <!-- 使用ref为 `html元素` 的DOM设置引用名称 -->\r\n  <p ref=\"refName1\">test</p>\r\n\r\n  <!-- 使用ref为 `组件` 的DOM设置引用名称 -->\r\n  <myComponents ref=\"refName2\"></myComponents>\r\n</template>\r\n\r\n<script>\r\n  export default{\r\n\r\n    mounted(){\r\n      //根据 `ref引用名称` 输出 `html元素` 的DOM实例\r\n      console.log(this.$refs.refName1);\r\n\r\n      //根据 `ref引用名称` 输出 `组件` 的DOM实例\r\n      console.log(this.$refs.refName2);\r\n\r\n      //根据 `ref引用名称` 访问 `组件` 上的数据和方法\r\n      console.log(this.$refs.refName2.数据或方法名);\r\n    },\r\n  }\r\n</script>\r\n```\r\n\r\n## DOM更新时机及nextTick()\r\n`DOM 的更新并不是同步的  更改响应式状态时 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。`\r\n```html\r\n<template>\r\n  <input v-if=\"inputVisible\" type=\"text\" ref=\"inputRef\" >\r\n  <button @click=\"changeInputVisible\">显示/隐藏输入框</button>\r\n</template>\r\n\r\n<script>\r\n  export default{\r\n    data(){\r\n      return{\r\n        inputVisible:false\r\n      }\r\n    },\r\n    methods:{\r\n      changeInputVisible(){\r\n        this.inputVisible=!this.inputVisible //切换输入框可见性\r\n        if(this.inputVisible){  //如果切换为可见\r\n          //当切换输入框可见性后,输入框还未更新DOM,所以 `<input>` 元素并不存在,所以以下代码将因无法获取到DOM对象而报错\r\n          this.$refs.inputRef.focus()  //获取输入框焦点\r\n        }\r\n      }\r\n    }\r\n  }\r\n</script>\r\n```\r\n\r\n`nextTick()`\r\n```html\r\n<template>\r\n  <input v-if=\"inputVisible\" type=\"text\" ref=\"inputRef\" >\r\n  <button @click=\"changeInputVisible\">显示/隐藏输入框</button>\r\n</template>\r\n\r\n<script>\r\nimport { nextTick } from '@vue/runtime-core'\r\n  export default{\r\n    data(){\r\n      return{\r\n        inputVisible:false\r\n      }\r\n    },\r\n    methods:{\r\n      changeInputVisible(){\r\n        this.inputVisible=!this.inputVisible //切换输入框可见性\r\n        if(this.inputVisible){  //如果切换为可见\r\n          //等待一个状态改变后的 DOM 更新完成\r\n          nextTick(()=>{\r\n            this.$refs.inputRef.focus()  //获取输入框焦点\r\n          })\r\n        }\r\n      }\r\n    }\r\n  }\r\n</script>\r\n```\r\n\r\n## 动态组件component\r\n**动态组件**\r\n* 动态组件用于动态切换组件的显示和隐藏\r\n* `<component>`是组件占位符\r\n* 通过`is`属性动态指定要渲染的组件名称`<component is=\"组件名称\"></component>`\r\n* `<keep-alive>`标签作用是切换动态组件时保持组件的状态,使得其内容变量不会被销毁\r\n\r\n**基本使用**\r\n```html\r\n<template>\r\n  <!-- component绑定字符串变量`comNameVal` -->\r\n  <component :is=\"comNameVal\"></component>\r\n  <!-- button切换遍历`comNameVal`的值 -->\r\n  <button @click=\"comNameVal='ComponentA'\">显示ComponentA</button>\r\n  <button @click=\"comNameVal='ComponentB'\">显示ComponentB</button>\r\n</template>\r\n\r\n<script>\r\n  //导入子组件\r\n  import ComponentA from './components/componentA.vue'\r\n  import ComponentB from './components/componentB.vue'\r\n  export default{\r\n    components:{\r\n      //注册子组件\r\n      ComponentA,\r\n      ComponentB\r\n    },\r\n    data(){\r\n      return{\r\n        //定义变量数据\r\n        comNameVal:'ComponentA'\r\n      }\r\n    },\r\n    methods:{\r\n    }\r\n  }\r\n</script>\r\n```\r\n\r\n`<keep-alive>`标签作用是切换动态组件时保持组件的状态,使得其内容变量不会被销毁\r\n```html\r\n  <keep-alive>\r\n    <component :is=\"comNameVal\"></component>\r\n  </keep-alive>\r\n```\r\n\r\n## 插槽Slot\r\n**基本写法:插入到默认插槽**\r\n```html\r\n<!-- 子组件 -->\r\n<template>\r\n  <p>组件的第一个标签</p>\r\n  <!-- slot预留占位标签 -->\r\n  <slot>\r\n    这里是后备(默认)内容(可以不填后备内容),当父组件未提供任何内容则显示后备内容\r\n  </slot>\r\n  <p>组件的最后一个标签</p>\r\n</template>\r\n\r\n\r\n<!-- -------------------------------------------------------- -->\r\n<!-- 父组件 -->\r\n<template>\r\n  <!-- 引入子组件 -->\r\n  <subComponent>\r\n    <p>该标签会插入到子组件subComponent的slot标签处</p>\r\n  </subComponent>\r\n</template>\r\n```\r\n\r\n**具名插槽:分别插入到不同的插槽**\r\n```html\r\n<!-- 子组件 -->\r\n<template>\r\n  <header>\r\n    <slot name='header'></slot>\r\n  </header>\r\n  <main>\r\n    <!-- \r\n      <slot name='default'></slot>\r\n      name='default'可以省略\r\n    -->\r\n    <slot></slot>\r\n  </main>\r\n  \r\n  <footer>\r\n      <slot name='footer'></slot>\r\n  </footer>\r\n</template>\r\n\r\n\r\n<!-- -------------------------------------------------------- -->\r\n<!-- 父组件 -->\r\n<template>\r\n  <!-- 引入子组件 -->\r\n  <subComponent>\r\n    <template v-slot:header>\r\n      <h1>滕王阁序</h1>\r\n    </template>\r\n    <template v-slot:default><!-- 该标签内容将插入到默认插槽 所以该标签 可省略 -->\r\n      <p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</p>\r\n      <p>画栋朝飞南浦云，珠帘暮卷西山雨。</p>\r\n      <p>闲云潭影日悠悠，物换星移几度秋。</p>\r\n      <p>阁中帝子今何在？槛外长江空自流。</p>\r\n    </template>\r\n    <template v-slot:footer><!-- #footer为v-slot:footer的简写 -->\r\n      <p>落款：王勃</p>\r\n    </template>\r\n  </subComponent>\r\n</template>\r\n```\r\n\r\n**作用域插槽**\r\n```html\r\n<!-- 子组件 -->\r\n<template>\r\n  <h2>这是一个子组件</h2>\r\n  <slot :msgA='msg1' :msgB='msg2' >\r\n  //作用：以何种方式渲染数据，交给父组件处理，所以通过插槽的方式向外部提供一个插入位置和数据\r\n  </slot>\r\n</template>\r\n<script>\r\n  export default{\r\n    data(){\r\n      return{\r\n        msg1:\"内容1\"\r\n        msg2:\"内容2\"\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n\r\n<!-- -------------------------------------------------------- -->\r\n<!-- 父组件 -->\r\n<template>\r\n  <h1>这是一个父组件</h1>\r\n  <subComponent v-slot:default=\"gettedData\"><!-- gettedData是变量名，可以任意 -->\r\n    <p>这是接收到的子组件绑定给插槽的数据msgA: {{gettedData.msgA}}</p>\r\n    <p>这是接收到的子组件绑定给插槽的数据msgB: {{gettedData.msgB}}</p>\r\n  </subComponent>\r\n\r\n  <subComponent v-slot:default=\"{msgA:msgA,msgB:msgB}\"><!-- 由于获取到的数据是一个对象，所以可以解构赋值为{msgA:msgA,msgB:msgB} 或 {msgA,msgB} -->\r\n    <p>这是接收到的子组件绑定给插槽的数据msgA: {{msgA}}</p>\r\n    <p>这是接收到的子组件绑定给插槽的数据msgB: {{msgB}}</p>\r\n  </subComponent>\r\n</template>\r\n```\r\n\r\n## 自定义的指令Directives\r\n\r\n**局部自定义指令**\r\n```html\r\n<template>\r\n<input v-focus />\r\n</template>\r\n\r\n<script>\r\n  const focus = {\r\n    \r\n}\r\n\r\nexport default {\r\n  directives: {\r\n    // 在模板中启用 v-focus\r\n    focus:{\r\n      mounted: (el) => el.focus(),//vue2中函数名为bind\r\n      updated: (el) => el.focus()//vue2中函数名为update\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n**全局自定义指令**\r\n`main.js`\r\n```js\r\nconst app = createApp({})\r\n\r\n// 使 v-focus 在所有组件中都可用\r\napp.directive('focus', {\r\n    mounted: (el) => el.focus(),//vue2中函数名为bind\r\n    updated: (el) => el.focus()//vue2中函数名为update\r\n}\r\n\r\n\r\n)\r\n\r\n// 上述mounted updated 函数内容一致 可以简写为\r\napp.directive('focus',(element)=>{\r\n      el.focus()\r\n}\r\n\r\n\r\n```\r\n\r\n**值令钩子**\r\n```js\r\nexport default {\r\n  directives: {\r\n    // 在模板中启用 v-focus\r\n    focus:{\r\n        // 在绑定元素的 attribute 前 或 事件监听器应用前调用\r\n        created(element, binding, vnode, prevVnode) {},\r\n        // 在元素被插入到 DOM 前调用\r\n        beforeMount(el, binding, vnode, prevVnode) {},\r\n        // 在绑定元素的父组件\r\n        // 及他自己的所有子节点都挂载完成后调用\r\n        mounted(el, binding, vnode, prevVnode) {},\r\n        // 绑定元素的父组件更新前调用\r\n        beforeUpdate(el, binding, vnode, prevVnode) {},\r\n        // 在绑定元素的父组件\r\n        // 及他自己的所有子节点都更新后调用\r\n        updated(el, binding, vnode, prevVnode) {},\r\n        // 绑定元素的父组件卸载前调用\r\n        beforeUnmount(el, binding, vnode, prevVnode) {},\r\n        // 绑定元素的父组件卸载后调用\r\n        unmounted(el, binding, vnode, prevVnode) {}\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n**值令钩子形式参数**\r\n```js\r\ncreated(element, binding, vnode, prevVnode) {\r\n  // element :DOM元素\r\n  // binding :\r\n              // 若:\r\n              // let 变量名valueName = 123\r\n              // v-focus.修饰符AAA=\"变量名valueName\"\r\n              // 或:\r\n              // v-focus.修饰符AAA:变量名valueName=\"123\"\r\n              //\r\n              // 则:\r\n              // binding的值为:{\r\n              //      arg: '变量名valueName',\r\n              //      value: 变量名valueName的值 123,\r\n              //      oldValue: 上一次`变量名valueName`的值\r\n              //      modifiers: { 修饰符AAA: true },\r\n              // }\r\n}\r\n```\r\n\r\n\r\n## 表格案例实现\r\n\r\n**效果**\r\n\r\n![图 1](./images/vue3学习笔记/5696dd27a68603dec0e7b9ae8e216706db68895d151ddb8f35556d54f1d6796c.png)  \r\n\r\n**代码**\r\n`main.js`\r\n```js\r\nimport { createApp } from 'vue'\r\nimport './style.css'\r\n\r\nimport './assets/bootstrap5.css'\r\n\r\nimport App from './App.vue'\r\ncreateApp(App).mount('#app')\r\n```\r\n\r\n`App.vue`\r\n```html\r\n<template>\r\n  <myTable :data=\"goodsList\">\r\n    <template v-slot:header>\r\n      <td>序号</td>\r\n      <td>商品名称</td>\r\n      <td>价格</td>\r\n      <td>标签</td>\r\n      <td>操作</td>\r\n    </template>\r\n    <template v-slot:item=\"{row}\">\r\n      <td>{{row.id}}</td>\r\n      <td>{{row.name}}</td>\r\n      <td>{{row.price}}</td>\r\n      <td>\r\n        <span\r\n        v-for=\"tag in row.tags\" :key=\"tag\" \r\n        class=\"badge bg-warning text-dark\" \r\n        style=\"margin:0 5px;cursor: pointer;\"\r\n        @click=\"row.tags.splice(row.tags.findIndex(item => item == tag),1)\"\r\n        >{{tag}}</span>\r\n\r\n        <input\r\n        type=\"text\" \r\n        class=\"form-control\"\r\n        style=\"display: inline;width: 100px; float: right;\"\r\n        v-if=\"row.inputVisible\" \r\n        v-model.trim=\"row.inputValue\" \r\n        @blur=\"addTag(row),row.inputValue=''\"\r\n        @keyup.enter=\"addTag(row),row.inputValue=''\"\r\n        @keyup.esc=\"row.inputValue=''\"\r\n        v-focus\r\n        >\r\n\r\n        <button \r\n        v-if=\"!row.inputVisible\" \r\n        type=\"button\"\r\n        class=\"btn btn-primary\" \r\n        style=\"padding:2px auto;float: right;\" \r\n        @click=\"row.inputVisible = true\"\r\n        >+Tag\r\n      </button>\r\n\r\n      </td>\r\n      <td>\r\n        <button type=\"button\"  class=\"btn btn-danger\">删除</button>\r\n      </td>\r\n    </template>\r\n  </myTable>\r\n</template>\r\n\r\n\r\n<script>\r\n  import myTable from './components/myTable.vue'\r\n  export default {\r\n    components: {\r\n      myTable\r\n    },\r\n    data() {\r\n      return {\r\n        goodsList: [\r\n          { id: 1, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 2, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 3, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 4, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 5, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 6, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n        ]\r\n      }\r\n    },\r\n    methods:{\r\n      addTag(row){\r\n        let value =  row.inputValue//获取文本框内容\r\n        row.inputVisible = false//隐藏文本框\r\n        if(value || !row.tags.includes(value)){//判断是否为空 是否已经存在标签\r\n          row.tags.push(value)//添加标签\r\n        }\r\n      },\r\n\r\n    },\r\n    directives:{\r\n        focus:{\r\n          mounted(el){\r\n            console.log(el);\r\n            el.focus()\r\n          }\r\n        }\r\n      }\r\n  }\r\n</script>\r\n<style scoped>\r\n\r\n</style>\r\n```\r\n\r\n`myTable.vue`\r\n```html\r\n<template>\r\n  <table class=\"table table-striped table-bordered\">\r\n    <thead>\r\n        <tr>\r\n            <slot name=\"header\">\r\n            </slot>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr v-for=\"item in data\" :key=\"item.id\">\r\n                <slot name=\"item\" :row=\"item\">\r\n                </slot>\r\n        </tr>\r\n    </tbody>\r\n  </table>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    props:{\r\n        data:{\r\n            type:Array,\r\n            require:true,\r\n            default:[]\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style>\r\n\r\n</style>\r\n```\r\n\r\n\r\n## 路由\r\n\r\n### 路由原理\r\n```html\r\n<template>\r\n  <a href=\"#/home\"></a>\r\n  <a href=\"#/about\"></a>\r\n  <component :is=\"comNameVal\"></component>\r\n</template>\r\n<script>\r\n  import homeVue from \"./component/home.vue\"\r\n  import aboutVue from \"./component/about.vue\"\r\n  export default{\r\n    components:{\r\n      homeVue,\r\n      aboutVue,\r\n    },\r\n    data(){\r\n      return{\r\n        comNameVal:'homeVue'\r\n      }\r\n    },\r\n    created(){\r\n      //监听url中hash改变的事件 \r\n      window.onhashchange = ()=>{//回调函数\r\n        switch(window.location.hash){\r\n          case `#/home`:\r\n            this.comNameVal = 'homeVue'\r\n            break;\r\n          case `#/about`:\r\n            this.comNameVal = 'aboutVue'\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n```\r\n\r\n### 基本使用:声明式导航\r\n**声明式导航概念**\r\n* 点击`<a>`标签\r\n* 点击`<<router-link>`标签\r\n\r\n`安装`\r\n```bash\r\n# 安装\r\n# vue2 只能使用vue-router 3\r\n# vue3 只能使用vue-router 4\r\nnpm install vue-router@4 \r\n```\r\n\r\n`router.js`\r\n```js\r\nimport homeVue from \"./component/home.vue\"\r\nimport movieVue from \"./component/movie.vue\"\r\nimport aboutVue from \"./component/about.vue\"\r\nimport {createRouter,createWebHashHistory} from 'vue-router'\r\nconst router = createRouter({//创建路由实例\r\n    history:createWebHashHistory(),//指定路由工作模式\r\n    linkActiveClass:'actived_by_Router',//指定被点击后的链接会被添加上类名,默认为`router-link-active`\r\n    routes:[//指定路由规则\r\n        {path:'/',redirect:'/home'},//重定向路由\r\n        {path:'/home',component:homeVue},\r\n        {\r\n          path: '/search/:someSearchKeywords?',//?表示someSearchKeywords可以传递也可不传递,当不加?且不传递someSearchKeywords参数时,url中的`/search/`路径会没有,这会导致路由错误\r\n          name:'search',  // this.$router.push({ name:'search',query:{categoryid,categoryleve,categoryname}})\r\n          component: Search,\r\n          meta:{showFooter:true}//如此组件中便可以使用该变量: `<Footer v-if=\"$route.meta.showFooter\"></Footer>`\r\n        },\r\n        {\r\n            path:'/movie/:movieId',//`:movieId`是动态路由,使得组件中能通过`{{$route.params.movieId}}`访问属性值\r\n            component:() => import '\"./component/movie.vue\"' , //路由懒加载\r\n            name:'mov',//可以给路由命名,但不能重复\r\n            props:true,//使得组件中可以通过:`props:[movieId]` `{{movieId}}` 获取属性值\r\n        },\r\n        {path:'/about',component:aboutVue,redirect:'/about/tab1',children:[//嵌套路由\r\n            {path:'tab1',component:tab1Vue},\r\n            {path:'tab2',component:tab2Vue},\r\n        ]},\r\n    ]\r\n})\r\nexport default router//导出实例对象\r\n```\r\n\r\n`main.js`\r\n```js\r\nimport App from './App.vue'\r\nconst app = createApp(App)\r\nimport router from \"./router.js\";\r\napp.use(router)\r\napp.mount('#app')\r\n```\r\n\r\n`App.vue`\r\n```html\r\n<template>\r\n  <router-link to='/home' >主页<router-link>\r\n  <router-link to='/movie' >电影<router-link>\r\n  <router-link to='/movie/123' >电影<router-link>\r\n  <router-link :to=\"{name:'mov',params:{id:123}}\" >电影<router-link>\r\n  <router-link to='/about' >关于<router-link>\r\n\r\n  <router-view></router-view>\r\n</template>\r\n\r\n<script>\r\n  export default{\r\n  }\r\n</script>\r\n```\r\n\r\n### 基本使用:编程式导航\r\n**编程式导航概念**\r\n* 修改`window.location.herf`使之跳转页面\r\n* 调用vueAPI\r\n\r\n```html\r\n<button @click=\"$router.push('/home')\">首页</button>\r\n<button @click=\"$router.push({name:'mov',params:{id:123}})\">首页</button>\r\n<button @click=\"$router.go(-1)\">返回</button>\r\n```\r\n\r\n\r\n### 导航守卫\r\n```js\r\nimport homeVue from \"./component/home.vue\"\r\nimport movieVue from \"./component/movie.vue\"\r\nimport aboutVue from \"./component/about.vue\"\r\nimport {createRouter,createWebHashHistory} from 'vue-router'\r\nconst router = createRouter({\r\n  // 略......\r\n    routes:[\r\n        // 略......\r\n        {\r\n          path: '/search/:someSearchKeywords?',//作用: `?`表示`someSearchKeywords`可以传递也可不传递,当不加?且不传递`someSearchKeywords`参数时,`url`中的`/search/`路径会没有,这会导致路由错误\r\n          name:'search',  // 作用:  this.$router.push({ name:'search',params:{key:value,...},query:{categoryid,categoryleve,categoryname}})\r\n          component: Search,\r\n          meta:{showFooter:true}//作用: 如此编写组件中便可以使用该变量: `<Footer v-if=\"$route.meta.showFooter\"></Footer>`\r\n        }\r\n    ]\r\n})\r\n\r\n//全局导航守卫\r\nrouter.beforeEach((to,from,next)=>{\r\n  //to 目标路由对象\r\n  //from 来源路由对象\r\n  //next() 调用后将放行路由 若不接收该参数则自动放行;\r\n    // next('/path') 跳转到指定路径\r\n    // next(false) 强制停留在当前页面\r\n\r\n  if(to.path == '/user' && ! localStorage.getItem('token'))//访问user页面,但没有登陆,则跳转到登陆页面\r\n  {\r\n    next('/login')//路由到登陆页面\r\n  }else{\r\n    next() //放行\r\n  }\r\n\r\n})\r\nexport default router//导出实例对象\r\n```\r\n\r\n\r\n## 登陆案例实现\r\n\r\nmain.js\r\n```js\r\nimport { createApp } from 'vue'\r\nimport './style.css'\r\nimport App from './App.vue'\r\nimport router from './router'\r\nconst app = createApp(App)\r\napp.use(router)\r\napp.mount('#app')\r\n```\r\n\r\nrouter.js\r\n```js\r\nimport {createRouter,createWebHashHistory} from 'vue-router'\r\nimport loginVue from './components/login.vue'\r\nimport userVue from './components/user.vue'\r\nimport userInfoVue from './components/userInfo.vue'\r\nimport userRightVue from './components/userRight.vue'\r\nimport userDetailVue from './components/userDetail.vue'\r\nconst router = createRouter({\r\n    history:createWebHashHistory(),\r\n    linkActiveClass:'actived_by_router',\r\n    routes:[\r\n        {path:'/',redirect:'/login'},\r\n        {path:'/login',component:loginVue},\r\n        {path:'/user',redirect:'/user/info',component:userVue ,children:[\r\n            {path:'info',component:userInfoVue},\r\n            {path:'right',component:userRightVue},\r\n            {path:'detail/:userId',component:userDetailVue,props:true},\r\n        ]},\r\n    ]\r\n})\r\n\r\nrouter.beforeEach((to,before,next)=>{\r\n    if(to.path != '/login' && !localStorage.getItem(\"token\"))//若不是访问/login 且没有登陆token 则重定向到/login\r\n    {\r\n        next('/login')\r\n    }else{\r\n        next()//其他页面则允许访问(其实应当需要更复杂的判断)\r\n    }\r\n})\r\nexport default router\r\n```\r\n\r\nApp.vue\r\n```html\r\n<template>\r\n    <router-view></router-view>\r\n</template>\r\n```\r\n\r\n\r\nlogin.vue\r\n```html\r\n<template>\r\n    <div class=\"loginBox\">\r\n        username:<input type=\"text\" v-model=\"username\"><br>\r\n        password:<input type=\"password\" v-model=\"password\"><br>\r\n        <button @click=\"login\">submit</button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport {} from \"vue-router\"\r\nexport default {\r\n    data(){\r\n        return{\r\n            username:'',\r\n            password:''\r\n        }\r\n    },\r\n    methods:{\r\n        login(){\r\n            localStorage.setItem(\"token\",\"\")\r\n            if(this.username=='admin' && this.password=='admin')//模拟判断是否登陆成功\r\n            {\r\n                this.$router.push('/user')\r\n                localStorage.setItem(\"token\",\"XXXXXXXX\")//模拟存储token\r\n            }else{\r\n                alert('用户名或密码错误')\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style>\r\n.loginBox{\r\n    width: 400px;\r\n    height: 400px;\r\n    background-color: #fff;\r\n}\r\n</style>\r\n```\r\n\r\nuser.vue\r\n```html\r\n<template>\r\n  <div class=\"userInfoBox\">\r\n    <div class=\"left\">\r\n      <button @click=\"logout\">登出</button><br>\r\n      <router-link to=\"/user/info\">用户信息</router-link><br>\r\n      <router-link to=\"/user/right\">用户权利</router-link>\r\n    </div>\r\n    <div class=\"right\">\r\n      <router-view></router-view>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  methods:{\r\n    logout(){\r\n      localStorage.setItem(\"token\",'')\r\n      this.$router.push('/')\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\">\r\n.userInfoBox{\r\n  display: flex;\r\n  .left{\r\n    width: 200px;\r\n    background-color: skyblue;\r\n  }\r\n  .right{\r\n    flex: 1;\r\n    background-color: pink;\r\n  }\r\n}\r\n.actived_by_router{\r\n  background-color: red;\r\n}\r\n</style>\r\n```\r\n\r\nuserInfo.vue\r\n```html\r\n<template>\r\n  <p>用户信息..................................</p>\r\n  <p>用户1:<router-link :to=\"'/user/detail/'+1\">张三</router-link> <button @click=\"$router.push('/user/detail/'+1)\">张三</button></p>\r\n  <p>用户2:<router-link :to=\"'/user/detail/'+2\">张四</router-link> <button @click=\"$router.push('/user/detail/'+2)\">张四</button></p>\r\n</template>\r\n```\r\n\r\n\r\nuserRight.vue\r\n```html\r\n<template>\r\n  <p>用户权限..................................</p>\r\n</template>\r\n```\r\n\r\nuserDetail.vue\r\n```html\r\n<template>\r\n  <div class=\"userDetailBox\">\r\n    <button @click=\"$router.go(-1)\">返回上一级</button>\r\n    <h2>用户详细信息</h2>\r\n    <p>userId:{{userId}}</p>\r\n    <p>$route.params.userId:{{$route.params.userId}}</p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    props:['userId']\r\n}\r\n</script>\r\n```\r\n\r\n## vue-cli脚手架\r\n\r\n**安装**\r\n\r\n```bash\r\nnpm install -g @vue/cli\r\nvue --version\r\n```\r\n\r\n**创建项目**\r\n```bash\r\n# 命令行方式创建\r\nnpm create project-Name\r\n# 图形界面创建\r\nvue ui\r\n```\r\n\r\n**建议手动勾选配置的功能**\r\n* [*] 使用设置档案`.babelrc`\r\n* [*] babel\r\n* [*] css预处理器(less Sass stylus)\r\n\r\n## vue组件库\r\n\r\n**PC端组件库**\r\n* Element-UI 饿了吗团队开发的组件库\r\n* View UI\r\n\r\n**移动端组件库**\r\n* mintUI\r\n* Vant\r\n\r\n\r\n### element UI\r\n* Element-UI --> **vue2**\r\n* Element Plus --> **vue3**\r\n\r\n**安装**\r\n```bash\r\nnpm i element-ui -S\r\n```\r\n\r\n**完整引入Element-UI**\r\n```js\r\n// 完整引入\r\nimport Vue from 'vue';\r\nimport ElementUI from 'element-ui'\r\nimport 'element-ui/lib/theme-chalk/index.css'\r\nVue.use(ElementUI)\r\n\r\n\r\n```\r\n**按需引入Element-UI:可减小项目体积**\r\n```js\r\n// 1.安装   npm install babel-plugin-component -D\r\n// 2.修改   .babelrc \r\n\"plugins\": [\r\n    [\r\n      \"component\",\r\n      {\r\n        \"libraryName\": \"element-ui\",\r\n        \"styleLibraryName\": \"theme-chalk\"\r\n      }\r\n    ]\r\n  ]\r\n\r\n// 3.修改main.js\r\nimport Vue from 'vue';\r\nimport { Button, Select } from 'element-ui';\r\nimport App from './App.vue';\r\n\r\nVue.component(Button.name, Button);\r\nVue.component(Select.name, Select);\r\n/*\r\n * 或写为\r\n * Vue.use(Button)\r\n * Vue.use(Select)\r\n*/\r\n```\r\n\r\n\r\n## vue-cli的proxy代理服务\r\n\r\n用于处理跨域的问题\r\n\r\n**示例**\r\n```js\r\n// 1.配置axios\r\naxios.defaults.baseURL = 'https://localhost:8080'\r\n// 2.在vue.config.js中配置proxy代理\r\nmodule.exports = {\r\n  devServer:{\r\n    proxy:'http://www.???.???',\r\n    open:true,//自动打开浏览器\r\n    // port:80\r\n  }\r\n}\r\n\r\n// 3.发送请求\r\nthis.$http.get('/api/users')\r\n// 4.vue发现接口不存在,于是将请求转交给proxy代理\r\n\r\n// 5.proxy代理把请求地址的baseURL替换为devServer.proxy的值,并发起真正的请求\r\n\r\n// 6.proxy代理把请求到的数据转发给axios\r\n\r\n```\r\n\r\n\r\n\r\n## transition动画组件\r\n**基本使用**\r\n```vue\r\n<button @click=\"shouldShow = !shouldShow\">切换组件显示</button>\r\n<transition name=\"transitionName\">\r\n    <div v-if=\"shouldShow\">     1. v-if   </div>\r\n    <div v-show=\"shouldShow\">   2. v-show   </div>\r\n    <component is=\"组件名称\">    3. 动态组件    </component>\r\n</transition>\r\n\r\n<style>\r\n        /* // 进入前 */\r\n        .transitionName-enter-from {\r\n            height: 0;\r\n        }\r\n        /* // 进入中 */\r\n        .transitionName-enter-active {\r\n            transition: all 0.2s linear;\r\n        }\r\n        /* // 进入后 */\r\n        .transitionName-enter-to {\r\n            height: 461px;\r\n        }\r\n        /* // 离开前 */\r\n        .transitionName-leave-from {\r\n            height: 461px;\r\n        }\r\n        /* // 离开中 */\r\n        .transitionName-leave-active {\r\n            transition: all 0.2s linear;\r\n        }\r\n        /* // 离开后 */\r\n        .transitionName-leave-to {\r\n            height: 0;\r\n        }\r\n</style>\r\n```\r\n\r\n## swiper在vue中的使用\r\n\r\n**安装**\r\n```bash\r\nnpm i swiper\r\n```\r\n\r\n**引入**\r\n\r\n根据 `swiper` 的`package.json`的 `exports` 属性可知应当引入 `./bundle` `./css/bundle`\r\n```js\r\n//package.json \r\n\"exports\": {\r\n    \".\": \"./swiper.esm.js\",\r\n    \"./core\": \"./swiper.esm.js\",\r\n    \"./bundle\": \"./swiper-bundle.esm.js\",\r\n    \"./css\": \"./swiper.min.css\",\r\n    \"./css/bundle\": \"./swiper-bundle.min.css\",\r\n    \"./css/a11y\": \"./modules/a11y/a11y.min.css\",\r\n    \"./css/autoplay\": \"./modules/autoplay/autoplay.min.css\",\r\n    \"./css/controller\": \"./modules/controller/controller.min.css\",\r\n    \"./css/effect-coverflow\": \"./modules/effect-coverflow/effect-coverflow.min.css\",\r\n    \"./css/effect-cube\": \"./modules/effect-cube/effect-cube.min.css\",\r\n    \"./css/effect-fade\": \"./modules/effect-fade/effect-fade.min.css\",\r\n    \"./css/effect-flip\": \"./modules/effect-flip/effect-flip.min.css\",\r\n}\r\n```\r\n\r\n\r\n```js\r\nimport 'swiper/css/bundle'\r\nimport Swiper from 'swiper/bundle'\r\n\r\n   import { mapState } from 'vuex';\r\n    import { nextTick } from 'vue'\r\n\r\nexport default {\r\n    mounted(){\r\n      this.$store.dispatch('home/getBannerList')//向服务端发送请求获取数据\r\n      nextTick(()=>{\r\n        // 不应在此处执行 new Swiper 因为此时的nextTick并不是由于`bannerList`更新导致的页面更新 且其不能处理数据后续更新导致的页面更新\r\n      })\r\n    },\r\n    computed:{\r\n      ...mapState('home',['bannerList'])//映射bannerList\r\n    },\r\n    watch:{//监听器\r\n        bannerList:{//bannerList监听器\r\n            immediate:true,\r\n            deep:true,\r\n            handler(newValue,oldValue){\r\n                nextTick(()=>{//监听到数据改变后,等待页面的` v-for=\"item in bannerList\" `渲染完毕后再执行回调,否则swiper功能异常\r\n                    var swiper = new Swiper(\r\n                      // \"#swiper_banner\", //css选择器或DOM对象\r\n                      this.$refs.swiper_banner,//vue的ref引用\r\n                      {\r\n                        autoplay:true,\r\n                        loop:true,\r\n                        navigation: {\r\n                          nextEl: \".swiper-button-next\" ,\r\n                          prevEl: \".swiper-button-prev\" ,\r\n                        },\r\n                        pagination: {\r\n                            el: \".swiper-pagination\" ,\r\n                            clickable: true\r\n                        },\r\n                    });\r\n                    console.log('nextTick执行完毕');\r\n                })\r\n                console.log('watch的回调执行完毕');\r\n            },\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```vue\r\n<!--banner轮播-->\r\n<!-- swiper-container是旧版类名 swiper是新版类名 实际上只需要写一个,携带了一些样式,并用于保证其子代的类名能够应用相关css属性 -->\r\n<div class=\"swiper swiper-container\" id=\"swiper_banner\" ref=\"swiper_banner\">\r\n    <div class=\"swiper-wrapper\">\r\n        <div class=\"swiper-slide\" v-for=\"item in bannerList\" :key=\"item.id\">\r\n            <img :src=\"item.imgUrl\" />\r\n        </div>\r\n    </div>\r\n    <!-- 如果需要分页器 -->\r\n    <div class=\"swiper-pagination Pagi_banner\"></div>\r\n    <!-- 如果需要导航按钮 -->\r\n    <div class=\"swiper-button-prev btnPrev_banner\"></div>\r\n    <div class=\"swiper-button-next btnNext_banner\"></div>\r\n</div>\r\n```\r\n\r\n## 根据页面滚动位置改变盒子高度(存在兼容性问题)\r\n```vue\r\n<template>\r\n    <div ref=\"cover\" class=\"cover\">\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    data() {\r\n        return {\r\n        }\r\n    },\r\n    mounted() {\r\n        document.addEventListener('scroll', () => {//根据页面滚动改变div高度\r\n            /* css\r\n                min-height: 20vh;\r\n                height: 80vh;\r\n                max-height: 80vh;\r\n            */\r\n            let px_100vh = window.innerHeight; //px单位的100vh\r\n            let px_scrolled_height = window.pageYOffset; //px单位的滚动内容的高度\r\n            let vh_scrolled_height = px_scrolled_height / px_100vh * 100; //vh单位的滚动内容的高度\r\n\r\n            let vh_min_height = 20;\r\n            let vh_max_height = 80;\r\n            let px_current_height = this.$refs.cover.clientHeight;\r\n            let vh_current_height = px_current_height / px_100vh * 100;\r\n\r\n            let new_vh_current_height = vh_current_height - vh_scrolled_height\r\n            console.log(new_vh_current_height);\r\n            if (vh_min_height <= new_vh_current_height && new_vh_current_height <= vh_max_height) {\r\n                this.$refs.cover.style.height = new_vh_current_height + 'vh';\r\n                window.scroll(0, 0)\r\n            }\r\n        })\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.cover {\r\n    width: 100%;\r\n    min-height: 20vh;\r\n    height: 80vh;\r\n    max-height: 80vh;\r\n    background-color:red;\r\n}\r\n</style>\r\n```"},{"shortInfo":{"title":"关于博主","date":"2022-02-24T03:00:00.000Z","layout":"post","cover":"\\self_server\\assets\\images\\面对大河我无限惭愧.png","type":"Nav","id":"about","hideAtIndex":true,"categories":"日志","tags":["日志","关于博主","Nav"],"countWords":120,"readSeconds":12,"assetsbaseUrl":"/self_server/assets/"},"content":"## 关于博主\n\n就让他们都去吧，随着风远远去吧.....\n\n\n\n<!-- ## 纯度为100%的铁废物 -->\n<!-- \n啥也不会 啥也不是  \n没有大起大落  \n间歇性踌躇满志  \n持续性混吃等死  \n积极废人  \n缺点一堆  \n啥也不想说了  \n铁废物一个......  \n-->\n\n<!-- ![](./images/about/2022-11-30-22-26-51.png) -->\n\n\n\n<!-- ### 在某种程度上还算努力的铁废物 -->\n<!--  -->\n<!-- ![](./images/about/1.jpg) -->\n<!-- ![](./images/about/2.jpg) -->\n<!-- ![](./images/about/3.jpg) -->\n<!-- ![](./images/about/4.jpg) -->\n<!-- ![](./images/about/5.jpg) -->\n<!-- ![](./images/about/6.jpg) -->"},{"shortInfo":{"title":"2022年待办事项","date":"2022-02-24T05:34:00.000Z","cover":"\\self_server\\assets\\images\\我要向前走.png","type":"Nav","id":"schedule","hideAtIndex":true,"categories":"日志","tags":["日志","Nav"],"countWords":1104,"readSeconds":110.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 2022年\r\n## 一月 flags 🚩\r\n+ ✅ 尝试用js写俄罗斯方块\r\n+ ✅《概率论与数理统计(宋浩)》学习 \r\n\r\n## 二月 flags 🚩\r\n2月25日-5月22日:\r\n+ ✅ 免试保送政策取消 复习备考 \r\n\r\n## 五月 flags 🚩\r\n5月23日:\r\n<!-- + ⬜ 《数据结构与算法分析》学习 -->\r\n+ ✅ 重学Git补全笔记缺失知识点\r\n\r\n## 六月 flags 🚩\r\n+ ✅ 《七天学会NodeJS》教程学习 \r\n+ ✅ 重学HTML5并做笔记\r\n+ ✅ 重学CSS3并做笔记\r\n+ ✅ CSS3+HTML5项目实战\r\n+ ✅ LESS层叠样式预处理语言学习\r\n+ ✅ 移动web开发学习 \r\n    + ✅ CSS3进阶\r\n    + ✅ 移动端布局及Flex布局模型\r\n    + ✅ Flex布局模型项目实战\r\n    + ✅ 移动适配\r\n    + ✅ 移动适配项目实战\r\n    + ✅ 响应式\r\n    + ✅ 响应式BootStrap框架\r\n    + ✅ 响应式网页项目实战\r\n+ ✅ JavaScript基础知识复习\r\n\r\n\r\n## 七月 flags 🚩\r\n+ ✅ jsAPI:DOM学习\r\n+ ✅ jsAPI:BOM学习\r\n+ ✅ jQuery学习\r\n+ ✅ indexedDB学习笔记\r\n+ ✅ promise学习\r\n+ ✅ 手写实现Promise\r\n\r\n## 八月 flags 🚩\r\n+ ✅ Ajax学习;\r\n+ ✅ nodejs学习\r\n+ ✅ js高级语法学习\r\n+ ✅ express学习\r\n  + ✅ session认证机制\r\n  + ✅ jwt认证机制\r\n+ ✅ express项目练习\r\n+ ✅ SQL语法学习\r\n+ ✅ nodejs的mysql模块学习\r\n\r\n## 九月 flags 🚩\r\n+ ✅ ES6-ES11新特性学习\r\n+ ✅ vue3学习\r\n+ ✅ Vue3项目实战练习: 尚品汇\r\n+ ✅ Vue3项目练习: 用Vue重写博客网站\r\n\r\n## 十月 flags 🚩\r\n+ ✅ 整理Vue尚品汇项目中遇到的问题及解决方法\r\n+ ✅ 整理博客网站项目中的遇到的问题及解决方法\r\n+ ✅ java学习\r\n\r\n  <!-- + `10月22日` 概述 环境搭建 执行原理 注释 字面量 变量 数据类型 关键字 标识符 自动及强制类型转换 运算符 键盘录入 顺序分支循环 数组 方法 方法内存原理 方法值传递机制 方法重载 案例\r\n  + `10月23日` 面向对象 面向对象内存机制 构造器 this ArrayList String常量与变量 ArrayList遍历 ATM系统项目实现 修饰符 工具类 代码块 static 单例模式\r\n  + `10月24日` 继承 包 权限修饰符 final 常量 枚举 抽象类 接口 多态 内部类 匿名内部类 \r\n  + `10月25日` Objets工具类 StringBuilder Math System BigDecimal Date SimpleDateFormate Calendar JDK8新增日期API\r\n  + `10月26日` 正则表达式 Arrays 选择排序 二分查找 Lambda表达式 集合Collection 集合遍历\r\n  + `10月27日` List 泛型 自定义泛型 泛型通配符 泛型上下限 Set集合 可变参数 集合操作工具类Collections\r\n  + `10月28日` 洗牌发牌系统案例 Map集合 MapAPI Map遍历 Map其他实现类 集合嵌套 不可变集合 Stream流 异常分类 异常处理机制 自定义异常  \r\n  + `10月29日` Logback日志框架 电影商城项目\r\n  + `10月30日` 文件 方法递归 文件搜索 IO流 文件字节输入流 \r\n  + `10月31日` 文件字节输出流 缓冲流 字节缓冲流 \r\n  + `11月1日`  对象序列化 反序列化 打印流 Properties commons-io 线程三种创建方式 线程方法 线程安全问题 线程同步 同步代码块 同步方法 同步锁 线程通信 线程池  \r\n  + `11月2日`  线程池处理Runnable任务 线程池处理Callable任务 Executors工具类构建线程池对象 定时器 线程并发 并行 线程生命周期6种状态 网络通信 UDP单播广播组播 TCP通信结合线程池 TCP即时通讯案例 BS架构模拟\r\n  + `11月3日` Junit框架单元测试 反射获取类对象 反射获取类属性 反射获取类方法 反射获取类构造器 反射修改类属性 反射调用类方法 反射执行类构造器\r\n  + `11月4日` 注解 自定义注解 元注解 注解解析 使用注解和反射实现junit框架 动态代理 XML XML文档约束 Dom4J XPath 工厂设计模式 装饰设计模式  -->\r\n\r\n## 十一月 flags 🚩\r\n+ ✅ Electron 学习\r\n+ ✅ Vite 深入学习\r\n+ ✅ JavaWeb 学习\r\n  + ✅ mysql 学习\r\n  + ✅ SQL 学习\r\n  + ✅ JDBC 学习\r\n  + ✅ Maven 学习\r\n  + ✅ myBatis 学习\r\n  + ✅ Tomcat 学习\r\n  + ✅ Servlet 学习\r\n  + ✅ Cookie、Session 学习\r\n  + ✅ FastJson 学习\r\n  + ✅ JSP 学习\r\n  + ✅ Filter 学习\r\n  + ✅ Listener 学习\r\n  + ✅ MVC模式与三层架构 学习\r\n\r\n## 十二月 flags 🚩 \r\n+ ⬜ 数据结构期末备考复习(重学)\r\n+ ⬜ 计算机网络期末备考复习(重学)\r\n+ ⬜ 计算机组成原理期末备考复习(重学)\r\n+ ⬜ 23种设计模式 学习\r\n\r\n\r\n\r\n    \r\n<!-- \r\n✅\r\n⬜\r\n📔 Notebook with Decorative Cover\r\n📕 Closed Book\r\n📖 Open Book\r\n📗 Green Book\r\n📘 Blue Book\r\n📙 Orange Book\r\n📚 Books\r\n📓 Notebook\r\n📒 Ledger\r\n📃 Page with Curl\r\n📜 Scroll\r\n📄 Page Facing Up\r\n📰 Newspaper\r\n🗞️ Rolled-Up Newspaper\r\n📑 Bookmark Tabs\r\n🔖 Bookmark\r\n🏷️ Label\r\n💰 Money Bag\r\n\r\n -->"},{"shortInfo":{"title":"WEB开发模式和身份认证的概念","date":"2022-08-30T00:00:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["身份认证"],"hideAtIndex":true,"categories":"后端","id":489091078,"countWords":1411,"readSeconds":141.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# WEB开发模式和身份认证的概念\r\n\r\n## 目录\r\n- [WEB开发模式和身份认证的概念](#web开发模式和身份认证的概念)\r\n  - [目录](#目录)\r\n  - [WEB开发模式](#web开发模式)\r\n    - [服务端渲染开发模式](#服务端渲染开发模式)\r\n    - [前后端分离开发模式](#前后端分离开发模式)\r\n    - [WEB开发模式的选择](#web开发模式的选择)\r\n  - [身份认证](#身份认证)\r\n    - [session认证机制](#session认证机制)\r\n    - [JWT认证机制](#jwt认证机制)\r\n\r\n## WEB开发模式\r\n\r\n### 服务端渲染开发模式\r\n**页面由服务端拼接动态生成后发送给客户端**\r\n* 缺点\r\n    * 开发效率低\r\n    * 耗费服务端资源\r\n* 优点\r\n    * 有利于SEO\r\n    * 节省客户端资源\r\n\r\n\r\n### 前后端分离开发模式\r\n**前端用AJAX调接口,后端负责提供接口**\r\n* 优点\r\n    * 开发效率高,\r\n      * 前端专注于UI界面,\r\n      * 后端专注于API开发,\r\n      * 前端开发时有多种选择,Jquery+模板引擎 或 Vue 或 React 等的框架\r\n    * 用户体验好,容易实现局部刷新\r\n    * 减轻了服务器渲染压力\r\n* 缺点\r\n    * 不利于SEO,\r\n      * 完整的页面内容是通过AJAX获取API接口得到的,\r\n      * 该问题可用VUE React前端框架的SSR(server Side render)解决\r\n\r\n### WEB开发模式的选择\r\n**WEB开发模式的选择需要考虑业务场景**\r\n* 企业网站,主要为展示产品,**没有复杂的交互**,**需要良好的SEO**,则一般使用**服务端渲染**的开发模式\r\n* 后台管理网站,**交互性强**,**不需要考虑SEO**,则一般使用**前后端分离**的开发模式\r\n* 若需**同时考虑首页渲染速度**和**开发效率**,则采用**首页服务器渲染** **其他页面采用前后端分离**的开发模式\r\n\r\n\r\n\r\n## 身份认证\r\n身份认证(Authentication),身份验证,鉴权;指**通过一定手段完成对用户身份的确认**  \r\n身份认证的目的是为了**确认当前所声称为某身份的用户,确实是所声称的用户**\r\n* 手机验证码登陆\r\n* 邮箱验证登陆\r\n* 二维码登陆\r\n* 密码登陆\r\n\r\n不同WEB开发模式采用不同的身份认证机制\r\n* **服务端渲染**的开发模式一般使用**session认证机制**\r\n* **前后端分离**的开发模式一般使用**JWT认证机制**\r\n\r\nSession认证机制需要配合Cookie才能实现,由于Cookie默认不支持跨域,所以但涉及到前端跨域访问后端接口时,需要做很多额外的配置,才能实现跨域Session认证\r\n* 前端不存在跨域访问后端接口,应使用**Session认证机制**\r\n* 前端跨域访问后端接口时应该使用**JWT认证机制**\r\n\r\n\r\n### session认证机制\r\n**HTTP协议的无状态性**  \r\n无状态性是指客户端**每次发送的http请求都是独立的**,多个请求之间没有直接的关系,**服务端也不会保留每次http的请求状态**. 解决该问题需使用`Cookie`,用于确认前后两个请求是同一个用户\r\n\r\n**Cookie**  \r\n* **4KB限制** 是存储在浏览器中一段**不超过4kB的字符串**\r\n* **由键值对组成**,有名称Name,值Value和其他几个可选属性组成(有效期,安全性,使用范围)\r\n* **会过期**\r\n* **按域名独立** **不同域名下的cookie各自独立**\r\n* **自动发送** 客户端发送请求时,**会自动把该域名下所有未过期的cookie发送给服务端**\r\n* **容易被伪造** 浏览器提供了读写cookie的API\r\n* **本身不具有安全性** 不建议存放隐私数据,\r\n![图 1](./images/WEB开发模式和身份认证的概念/40f0452c90f5994d012e9f073038ff3fbc45665c6da45c88587115bbcc12eb4e.png)  \r\n\r\n\r\n**获取;存储;发送cookie过程**\r\n* 客户端第一次向服务端发送请求时,服务端会通过响应头向客户端发送一个cookie  \r\n* 客户端收到该cookie后会**自动保存**到浏览器中  \r\n* 客户端后续的请求头将会**自动携带cookie**\r\n![图 3](./images/WEB开发模式和身份认证的概念/afa9ca9e3772872db3bb9bae6040575703ebddf7d568c9716d1d29a5d1e90d0c.png)  \r\n\r\n\r\n**session认证原理**  \r\nsession认证使用**cookie+身份认证**的方式实现;提高了cookie本身的安全性\r\n![图 4](./images/WEB开发模式和身份认证的概念/b11f8a54b6f620cf5ebc2e775472341c20fe816eda06727d1196139c5cf1d9e0.png)  \r\n\r\n\r\n\r\n**express中的session认证**\r\nexpress中可使用`express-session`的**第三方中间件**来实现  \r\n<red>详细笔记:[express学习笔记]()</red>  \r\n\r\n\r\n\r\n### JWT认证机制\r\n**概念**  \r\n* **JWT(Json Web Token)**,是目前最流行的跨域认证解决方案\r\n* JWT组成: `header头部.Payload有效载荷.Signature签名`\r\n  * `Payload有效载荷` 是用户信息经过加密后的字符串\r\n  * `header头部` 和 `Signature签名` 是安全性相关的内容\r\n\r\n**工作原理**\r\n* 客户端发送登陆请求,提交用户名和密码\r\n* 服务端验证用户名和密码的真实性,将用户信息加密生成`token`发送给客户端\r\n* 客户端收到token后手动保存到`LocalStorage`或`SessionStorage`中\r\n* 客户端后续发送请求时,需携带名为`Authorization`的请求头,格式为`Authorization: Bearer Token字符串;`\r\n* 服务端收到请求后从请求头中提取出`Token`字段,并**解密出用户信息**,身份认证成功后,再根据客户端的请求的内容响应给客户端相应的数据\r\n![图 5](./images/WEB开发模式和身份认证的概念/fdfbe7930227813d1039709dc80d7fb73364fbc99947afa2be37eaa1b3449bff.png)  \r\n\r\n\r\n\r\n**express中的sJWT认证机制机制**\r\n<red>详细笔记:[express学习笔记]()</red>  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<style>\r\n    red{\r\n        color:red;\r\n    }\r\n    sky{\r\n        color:skyblue;\r\n    }\r\n</style>"},{"shortInfo":{"title":"win10将exe配置成服务过程记录","date":"2022-08-04T13:13:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["win10","服务"],"hideAtIndex":true,"categories":"笔记","id":1572443132,"countWords":352,"readSeconds":35.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# win10将exe配置成服务过程记录\r\n\r\n**instsrv 和 srvany**\r\n* instsrv(install service)是用来安装服务\r\n* srvany(service anything)包装任何服务的外壳\r\n* [下载instsrv](/uploads/instsrv.exe) \r\n* [下载srvany](/uploads/srvany.exe)\r\n\r\n## 一、主要步骤\r\n**1.安装服务**\r\n```bash\r\n# cmd\r\ninstsrv.exe  XXXXXX（服务名）  d:\\path\\to\\srvany.exe（必须是完整的绝对路径）\r\n```\r\n\r\n**2.编辑注册表**\r\n1. win+r 输入：regedit\r\n2. 找到[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\XXXXXX(服务名)]\r\n3. 选择“新建”下的“项”，将其命名为Parameters。\r\n4. 单击选定Parameters，\r\n    * 新建名为 `Application` 的字符串值 将其数值数据设置为 XXXXXX（服务名）服务对应的应用程序的绝对路径，比如:E:\\temp\\clean_day\\nginx-1.4.7\\nginx.exe；\r\n    * 新建名为 `AppDirectory` 的字符串值 将其数值数据设置为指定程序所在的目录,如：E:\\temp\\clean_day\\nginx-1.4.7\r\n    * 新建名为 `AppParameters` 的字符串值 AppParameters指明程序运行的参数，如果没有可以不用设值；\r\n\r\n**3.启动服务**\r\n完毕你就可以用`net`命令启动/停止，或者sc命令配置服务了。\r\n```bash\r\nnet start XXXXXX（服务名）\r\nnet stop XXXXXX（服务名）\r\n```\r\n\r\n## 二、其他\r\n\r\n### 删除服务\r\n可以使用instsrv的remove选项来删除服务，当然也可以用sc命令\r\n\r\n### 配置服务\r\nwin+R 输入 `msconfig` 配置服务的开机启动启动或关闭\r\n\r\nwin+R 输入 `services.msc` 配置服务的临时启动和关闭"},{"shortInfo":{"title":"使用原生js实现轮播图","date":"2022-07-05T21:55:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["轮播图","js"],"categories":"笔记","id":2268634328,"countWords":4936,"readSeconds":493.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 使用原生js实现轮播图\r\n\r\n## [-->最终效果<--](./demos/index.html)\r\n\r\n## 实现的功能\r\n* **自动切换** ，当切换到最后一张时，切换方式将由 从前往后 切换自动改为 从后往前 切换\r\n* **自动暂停** ，当鼠标移动到banner图上时，暂停自动播放，鼠标离开时，恢复自动播放\r\n* **手动切换** ，\r\n    * 点击按钮`》`，实现切换到下一张，当切换到最后一张时，停止切换\r\n    * 点击按钮`《`，实现切换到上一张，当切换到第前一张时，停止切换\r\n    * 节流处理：频繁点击切换按钮时，仅允许切换一张，切换完毕后才允许切换下一张\r\n* **任意切换** ，点击底部圆点时，切换到相对应的图片\r\n* **PC端鼠标拖动切换**\r\n    * 鼠标左右拖动图片，移动到一定的阈值后松开鼠标，\r\n        * 允许鼠标移动到图片之外（通过嵌套，给document添加事件监听器和移除事件监听器实现）\r\n        * 允许鼠标松开时在图片之外（通过嵌套，给document添加事件监听器和移除事件监听器实现）\r\n    * 如达到指定阈值，且移动的方向有另一张图片，则切换到该图片\r\n    * 如未达到指定阈值，或移动的方向没有图片，则恢复原位\r\n* **移动端手指拖动切换**\r\n    * 功能及判断逻辑如上\r\n\r\n## 碰到的问题总结\r\n### 问题1：`ul>li`一行排列的问题\r\n* 在`.box>ul>li`的结构中，若想设置：\r\n    * `.box`有宽高\r\n    * `li`有宽高，一行排列\r\n* 有两种解决方案\r\n    1. 给`ul`设置一个很大的宽度，给li设置左浮动\r\n        * 优点是`li`之间没有任何间距\r\n        * 缺点是要设置宽度,如果设置的不好或`li`过多会造成`li`的换行排列\r\n    1. 给ul设置`white-space:nowrap;`，给li设置行内块，\r\n        * 优点是不用设置`ul`宽度\r\n        * 缺点是`li`之间会有由源代码中换行符造成的间隔\r\n\r\n### 问题2：确定下一个li的问题\r\n* 在ul>li的结构中，需要确定下一次需要展示的li是谁，\r\n* 同时需要考虑当展示最后一个li是，下一个待展示的li是谁\r\n\r\n**我的解决方案**  \r\n写一个函数，循环获取下一个子元素，  \r\n如：若一个元素中有子元素1，2，3，4；  \r\n则该函数每次调用将分别获取的元素为:1->2->3->4->3->2->1->2->3->4->3->2->1->2\r\n\r\n\r\n```js\r\n//循环获取下一个子元素\r\nfunction getNextActivedElement(elementObj){//如有子元素1，2，3，4 则该该函数返回的是 1->2->3->4->3->2->1->2->3->4->3->2->1....\r\n    if(!elementObj.activedLiIndex)//若activedLiIndex属性不存在则对其初始化\r\n    {\r\n        elementObj.activedLiIndex=0;//初始化索引为第一个元素\r\n    }\r\n    if(!elementObj.moveguide)//若moveguide属性不存在则对其初始化\r\n    {\r\n        elementObj.moveguide=\"forward\";//初始化移动方向为向右\r\n    }\r\n    if(elementObj.moveguide==\"forward\")//移动方向是向前\r\n    {\r\n        if(elementObj.children[elementObj.activedLiIndex].nextElementSibling)//如果能够找到下一个元素\r\n        {\r\n            elementObj.activedLiIndex+=1;//索引定位到下一个\r\n        }else{//如果找不到下一个元素\r\n            elementObj.moveguide=\"backward\";//设置移动方向为往前\r\n            elementObj.activedLiIndex-=1;//索引定位到前一个\r\n        }\r\n    }else{//移动方向是向后\r\n        if(elementObj.children[elementObj.activedLiIndex].previousElementSibling)//如果能够找到前一个元素\r\n        {\r\n            elementObj.activedLiIndex-=1;//索引定位到前一个\r\n        }else{\r\n            elementObj.moveguide=\"forward\";//设置移动方向为往后\r\n            elementObj.activedLiIndex+=1;//索引定位到下一个\r\n        }\r\n    }\r\n    return elementObj.children[elementObj.activedLiIndex];\r\n}\r\n```\r\n\r\n### 问题3：移动距离\r\n在`.banner>ul>li`的结构中，移动的是`ul`，移动距离应该是`-li[index].offsetLeft`\r\n\r\n### 问题4：无缝滚动的问题\r\n* 当前由于实现思路的问题暂时没有做无缝滚动的效果\r\n* 若要做无缝滚动效果，需要在最后一个li之后添加第一个li的拷贝，\r\n* 如图，当做完动画3->1的切换后，直接设置ul的偏移为0，使得显示第一张图片\r\n\r\n![](./images/js轮播图/2022-07-06-20-09-37.png)\r\n\r\n\r\n### 问题4：节流阀\r\n节流阀用于防止事件触发的过快，导致上一个事件还未处理完又去处理下一个事件\r\n```\r\nrightBtn.addEventListener(\"click\",function(){\r\n    if(!rightBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        rightBtn.flag=true;//打开节流阀\r\n        if(!bannerUl.activedLiIndex)\r\n        {   //第一次调用则初始化新属性\r\n            bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n        }\r\n        if(bannerUl.children[bannerUl.activedLiIndex].nextElementSibling)//如果该元素存在后一个兄弟元素\r\n        {\r\n            bannerUl.activedLiIndex+=1;//索引+1\r\n            //根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                rightBtn.flag=false;//关闭节流阀\r\n            })\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n### 问题5：鼠标移入banner效果\r\n* 鼠标移入banner则暂停自动播放  \r\n* 鼠标离开banner则启动自动播放\r\n\r\n**实现代码**\r\n```js\r\n//自动播放\r\nvar autoSwitch = null;\r\n//开启自动播放\r\nfunction startAutoSwitch(){\r\n    stopAutoSwitch();//先清除定时器\r\n    autoSwitch = setInterval(function(){\r\n        //循环获取下一个li\r\n        var nextLi = getNextActivedElement(bannerUl)\r\n        //将ul移动，偏移量为li的负offset\r\n        animate(bannerUl,-nextLi.offsetLeft)\r\n        //更新底部Ul状态\r\n        updataBottomUl(nextLi.dataset[\"index\"])\r\n    },5000);\r\n}\r\n//关闭自动播放\r\nfunction stopAutoSwitch(){\r\n    clearInterval(autoSwitch)\r\n}\r\n//运行自动播放\r\nstartAutoSwitch();\r\n//鼠标移入banner则暂停自动播放\r\nbanner.addEventListener(\"mouseenter\",function(){\r\n    stopAutoSwitch();\r\n})\r\n//鼠标离开banner则启动自动播放\r\nbanner.addEventListener(\"mouseleave\",function(){\r\n    startAutoSwitch();\r\n})\r\n```\r\n\r\n### 问题6：对前后切换轮播图功能的进一步封装\r\n\r\n该部分功能在切换轮播图的按钮功能及拖动轮播图的功能中都有使用，所以对其进行了封装\r\n\r\n**原代码**\r\n```js\r\n//鼠标点击事件\r\nleftBtn.addEventListener(\"click\",function(){\r\n    if(!leftBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        leftBtn.flag=true;//打开节流阀\r\n        if(!bannerUl.activedLiIndex)\r\n        {   //第一次调用则初始化新属性\r\n            bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n        }\r\n        if(bannerUl.children[bannerUl.activedLiIndex].previousElementSibling)//如果该元素存在前一个兄弟元素\r\n        {\r\n            bannerUl.activedLiIndex-=1;//索引-1\r\n            //根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                leftBtn.flag=false;//关闭节流阀\r\n            })\r\n        }\r\n    }\r\n})\r\nrightBtn.addEventListener(\"click\",function(){\r\n    if(!rightBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        rightBtn.flag=true;//打开节流阀\r\n        if(!bannerUl.activedLiIndex)\r\n        {   //第一次调用则初始化新属性\r\n            bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n        }\r\n        if(bannerUl.children[bannerUl.activedLiIndex].nextElementSibling)//如果该元素存在后一个兄弟元素\r\n        {\r\n            bannerUl.activedLiIndex+=1;//索引+1\r\n            //根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                rightBtn.flag=false;//关闭节流阀\r\n            })\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n\r\n**封装后**\r\n```js\r\n//鼠标点击事件\r\nleftBtn.addEventListener(\"click\",function(){\r\n    if(!leftBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        moveToPrevious(function(){\r\n            // 根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //播放动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                rightBtn.flag=false;//关闭节流阀\r\n            })\r\n        });\r\n    }\r\n})\r\nrightBtn.addEventListener(\"click\",function(){\r\n    if(!rightBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        rightBtn.flag=true;//打开节流阀\r\n        moveToNext(function(){\r\n            // 根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //播放动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                rightBtn.flag=false;//关闭节流阀\r\n            })\r\n        });\r\n    }\r\n});\r\nfunction moveToNext(callback){//如果能获取到下一个兄弟元素则修改Index否则保持不变\r\n    if(!bannerUl.activedLiIndex)\r\n    {   //第一次调用则初始化新属性\r\n        bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n    }\r\n    if(bannerUl.children[bannerUl.activedLiIndex].nextElementSibling)//如果该元素存在后一个兄弟元素\r\n    {\r\n        bannerUl.activedLiIndex+=1;//索引+1\r\n    }\r\n    callback && callback();\r\n}\r\nfunction moveToPrevious(callback){//如果能获取到上一个兄弟元素则修改Index否则保持不变\r\n    if(!bannerUl.activedLiIndex)\r\n    {   //第一次调用则初始化新属性\r\n        bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n    }\r\n    if(bannerUl.children[bannerUl.activedLiIndex].previousElementSibling)//如果该元素存在后一个兄弟元素\r\n    {\r\n        bannerUl.activedLiIndex-=1;//索引-1\r\n    }\r\n    callback && callback();\r\n}\r\n```\r\n\r\n\r\n\r\n### 问题7：鼠标拖动翻页功能实现\r\n实现思路：\r\n* 在鼠标点击时记录鼠标坐标`A`，同时记录轮播图在x轴的偏移offsetLeft(`C`)，\r\n* 在鼠标移动时再记录坐标B，  \r\n* 两个坐标差`(B-A)`就是轮播图需要在x轴上相对于原先位置C的偏移的距离，\r\n* 于是`轮播图.Left = C + (B-A) + \"px\"`\r\n* 鼠标弹起时，根据鼠标移动距离是否超过某阈值，最终决定是否移动\r\n\r\n注意点：\r\n* 鼠标按下时，记录相关坐标，同时添加下述两个监听器\r\n* 鼠标移动，应当允许鼠标离开轮播图界面，所以该监听器应当添加给document\r\n* 鼠标弹起，应当允许鼠标离开轮播图界面，所以该监听器应当添加给document\r\n    * 鼠标弹起后，移除这两个监听器\r\n* 上述两个添加给document的监听器应当在整个完整的效果结束时移除，否则在点击网页其他部分时，鼠标弹起是任然会触发该事件\r\n\r\n**核心代码**\r\n\r\n```js\r\n// Pc端鼠标拖动banner>ul效果\r\nbannerUl.addEventListener(\"mousedown\",function(e){\r\n    stopAutoSwitch();//暂停自动播放\r\n    bannerUl.mosedownStartPos = e.clientX ;//鼠标按下时的坐标\r\n    bannerUl.mosedownoffsetLeft = bannerUl.offsetLeft;//鼠标按下时，bannerUl的offsetleft\r\n    document.addEventListener(\"mousemove\",bannerUlMoveWithMouse)//添加事件监听鼠标移动，实现拖动效果\r\n    document.addEventListener(\"mouseup\",bannerUlMoveWithMouseToCorrectPos)//添加事件监听鼠标弹起，实现拖动归位效果\r\n    function bannerUlMoveWithMouse(e){\r\n        //鼠标移动的距离\r\n        bannerUl.mosedownMoveGap = e.clientX  - bannerUl.mosedownStartPos; \r\n        // 新偏移 = 原偏移 + 鼠标移动距离\r\n        bannerUl.style.left = bannerUl.mosedownoffsetLeft + bannerUl.mosedownMoveGap + \"px\"\r\n    }\r\n    function bannerUlMoveWithMouseToCorrectPos (e){//将ul移动到正确的位置上\r\n        if(bannerUl.mosedownMoveGap>50)//当鼠标移动距离超过一个阈值\r\n        {\r\n            moveToPrevious(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                // 根据Index值更新底部li\r\n                updataBottomUl(bannerUl.activedLiIndex)\r\n                //播放动画\r\n                animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n            });\r\n        }\r\n        else if(bannerUl.mosedownMoveGap<-50)//当鼠标移动距离超过一个阈值\r\n        {\r\n            moveToNext(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                // 根据Index值更新底部li\r\n                updataBottomUl(bannerUl.activedLiIndex)\r\n                //播放动画\r\n                animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n            });\r\n        }else//鼠标移动没有超过设定阈值\r\n        {   //归位\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n        }\r\n        document.removeEventListener(\"mousemove\",bannerUlMoveWithMouse);//移除document的mousemove\r\n        document.removeEventListener(\"mouseup\",bannerUlMoveWithMouseToCorrectPos);//移除document的mouseup\r\n        startAutoSwitch();//恢复自动播放\r\n    }\r\n})\r\n\r\n\r\n```\r\n\r\n### 移动端手指拖动bannerul效果 \r\n**相关事件**\r\n* `touchstart` 手指按下\r\n* `touchmove` 手指移动\r\n* `touchend` 手指离开\r\n\r\n**坐标获取**\r\n* `event.targetTouches[0].pageX` 第一个手指的坐标\r\n\r\n```js\r\n// 移动端手指拖动bannerul效果\r\nbannerUl.addEventListener(\"touchstart\",function(e){\r\n    stopAutoSwitch();//暂停自动播放\r\n    bannerUl.fingerDownStartPos = e.targetTouches[0].pageX ;//手指按下时的坐标\r\n    bannerUl.fingerDownoffsetLeft = bannerUl.offsetLeft;//手指按下时，bannerUl的offsetleft\r\n    document.addEventListener(\"touchmove\",bannerUlMoveWithFinger)//添加事件监听手指移动，实现拖动效果\r\n    document.addEventListener(\"touchend\",bannerUlMoveWithFingerToCorrectPos)//添加事件监听手指离开，实现拖动归位效果\r\n    function bannerUlMoveWithFinger(e){\r\n        //手指移动的距离\r\n        bannerUl.fingerDownMoveGap = e.targetTouches[0].pageX  - bannerUl.fingerDownStartPos; \r\n        // 新偏移 = 原偏移 + 手指移动距离\r\n        bannerUl.style.left = bannerUl.fingerDownoffsetLeft + bannerUl.fingerDownMoveGap + \"px\"\r\n    }\r\n    function bannerUlMoveWithFingerToCorrectPos(e){\r\n        bannerUl.removeEventListener(\"touchmove\",bannerUlMoveWithFinger);\r\n        if(bannerUl.fingerDownMoveGap>50)//当手指移动距离超过一个阈值\r\n        {\r\n            moveToPrevious(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                // 根据Index值更新底部li\r\n                updataBottomUl(bannerUl.activedLiIndex)\r\n                //播放动画\r\n                animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n            });\r\n        }\r\n        if(bannerUl.fingerDownMoveGap<-50)//当手指移动距离超过一个阈值\r\n        {\r\n            moveToNext(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                // 根据Index值更新底部li\r\n                updataBottomUl(bannerUl.activedLiIndex)\r\n                //播放动画\r\n                animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n            });\r\n        }else//手指移动没有超过设定阈值\r\n        {   //归位\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n        }\r\n        document.removeEventListener(\"touchmove\",bannerUlMoveWithFinger);//移除document的mousemove\r\n        document.removeEventListener(\"touchend\",bannerUlMoveWithFingerToCorrectPos);//移除document的mouseup\r\n        startAutoSwitch();//恢复自动播放\r\n    }\r\n})\r\n```\r\n\r\n\r\n## 完整代码\r\n\r\n\r\n```html\r\n<div class=\"banner\">\r\n    <ul>\r\n        <li data-active=\"true\" style=\"background-color: skyblue;\">轮播图1<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n        <li style=\"background-color: pink;\">轮播图2<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n        <li style=\"background-color: green;\">轮播图3<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n        <li style=\"background-color: yellowgreen;\">轮播图4<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n        <li style=\"background-color: gold;\">轮播图5<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n    </ul>\r\n    <span class=\"left\">《</span>\r\n    <span class=\"right\">》</span>\r\n    <div class=\"bottom\">\r\n        <ul>\r\n            <!--\r\n            <li class=\"active\"></li>\r\n            <li></li>\r\n            <li></li>\r\n            <li></li>\r\n            <li></li>\r\n            -->\r\n        </ul>\r\n    </div>\r\n</div>\r\n<style>\r\n    .banner *{\r\n        margin: 0;\r\n        padding: 0;\r\n    }\r\n    .banner *::before,\r\n    .banner *::after{\r\n        content: none !important;\r\n    }\r\n    .banner{\r\n        position: relative;\r\n        margin: 0 auto;\r\n        width: 100%;\r\n        height: 300px;\r\n        background-color: gray;\r\n        overflow: hidden;\r\n    }\r\n    .banner>ul{\r\n        position: relative;\r\n        top: 0;\r\n        /* 去除ul默认的左40px的内边距padding */\r\n        padding: 0;\r\n        /* 去除ul默认的上下外边距16px */\r\n        margin: 0;\r\n        height: 100%;\r\n        list-style: none;\r\n        white-space:nowrap;\r\n    }\r\n    .banner>ul>li{\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;\r\n        width: 100%;\r\n        background-color: pink;\r\n        vertical-align: top;\r\n        color: black;\r\n    }\r\n    .banner>.left,\r\n    .banner>.right\r\n    {\r\n        position: absolute;\r\n        display: inline-block;\r\n        width: 25px;\r\n        height: 25px;\r\n        /* background-color: gainsboro; */\r\n        cursor: pointer;\r\n        text-align: center;\r\n        vertical-align: middle;\r\n        font-size: 15px;\r\n        line-height: 25px;\r\n        color: white;\r\n    }\r\n    .banner>.left{\r\n        left: 0;\r\n        top: 50%;\r\n        transform: translate(0,-50%);\r\n    }\r\n    .banner>.right{\r\n        right: 0;\r\n        top: 50%;\r\n        transform: translate(0,-50%);\r\n    }\r\n    .banner>.bottom{\r\n        position: absolute;\r\n        bottom: 0;\r\n        left: 0;\r\n        transform: translate(0,-100%);\r\n        width: 100%;\r\n        height: 10px;\r\n        /* background-color: white; */\r\n        text-align: center;\r\n    }\r\n    .banner>.bottom>ul{\r\n        display: inline-block;\r\n        height: 10px;\r\n        /* 去除ul默认的padding,margin */\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        /* background-color: green; */\r\n        /* 防止li按文字的baseline对齐 */\r\n        vertical-align: top;\r\n    }\r\n    .banner>.bottom>ul>li{\r\n        float: left;\r\n        margin: 0 5px;\r\n        height: 10px;\r\n        width: 10px;\r\n        background-color: rgb(195, 195, 195);\r\n        border-radius: 50%;\r\n        cursor: pointer;\r\n    }\r\n    .banner>.bottom>ul>li.active{\r\n        background-color: white;\r\n    }\r\n</style>\r\n<script>\r\n    (function(){\r\n        var banner = document.querySelector(\".banner\") \r\n        var bannerUl = document.querySelector(\".banner>ul\") \r\n        var bottomUl = document.querySelector(\".banner>.bottom>ul\") \r\n        var leftBtn = document.querySelector(\".banner>.left\") \r\n        var rightBtn = document.querySelector(\".banner>.right\") \r\n        //为bannerUl添加index属性\r\n        for(var i=0;i<bannerUl.childElementCount;i++)\r\n        {\r\n            bannerUl.children[i].dataset[\"index\"]=i;\r\n        }\r\n        // 为bottom>UL创建li\r\n        for(var i=0;i<bannerUl.childElementCount;i++)\r\n        {\r\n            bottomUl.appendChild(document.createElement(\"li\"))\r\n        }\r\n        // 为bottomU>li[0]添加active类名\r\n        bottomUl.children[0].classList.add(\"active\")\r\n        // 为bottomU>li添加index属性\r\n        for(var i=0;i<bottomUl.childElementCount;i++)\r\n        {\r\n            bottomUl.children[i].dataset[\"index\"]=i;\r\n        }\r\n        //自动播放\r\n        var autoSwitch = null;\r\n        //开启自动播放\r\n        function startAutoSwitch(){\r\n            stopAutoSwitch();//先清除定时器\r\n            autoSwitch = setInterval(function(){\r\n                //循环获取下一个li\r\n                var nextLi = getNextActivedElement(bannerUl)\r\n                //将ul移动，偏移量为li的负offset\r\n                animate(bannerUl,-nextLi.offsetLeft)\r\n                //更新底部Ul状态\r\n                updataBottomUl(nextLi.dataset[\"index\"])\r\n            },5000);\r\n        }\r\n        //关闭自动播放\r\n        function stopAutoSwitch(){\r\n            clearInterval(autoSwitch)\r\n        }\r\n        //运行自动播放\r\n        startAutoSwitch();\r\n        //鼠标移入banner则暂停自动播放\r\n        banner.addEventListener(\"mouseenter\",function(){\r\n            stopAutoSwitch();\r\n        })\r\n        //鼠标离开banner则启动自动播放\r\n        banner.addEventListener(\"mouseleave\",function(){\r\n            startAutoSwitch();\r\n        })\r\n        // Pc端鼠标拖动banner>ul效果\r\n        bannerUl.addEventListener(\"mousedown\",function(e){\r\n            stopAutoSwitch();//暂停自动播放\r\n            bannerUl.mosedownStartPos = e.clientX ;//鼠标按下时的坐标\r\n            bannerUl.mosedownoffsetLeft = bannerUl.offsetLeft;//鼠标按下时，bannerUl的offsetleft\r\n            document.addEventListener(\"mousemove\",bannerUlMoveWithMouse)//添加事件监听鼠标移动，实现拖动效果\r\n            document.addEventListener(\"mouseup\",bannerUlMoveWithMouseToCorrectPos)//添加事件监听鼠标弹起，实现拖动归位效果\r\n            function bannerUlMoveWithMouse(e){\r\n                //鼠标移动的距离\r\n                bannerUl.mosedownMoveGap = e.clientX  - bannerUl.mosedownStartPos; \r\n                // 新偏移 = 原偏移 + 鼠标移动距离\r\n                bannerUl.style.left = bannerUl.mosedownoffsetLeft + bannerUl.mosedownMoveGap + \"px\"\r\n            }\r\n            function bannerUlMoveWithMouseToCorrectPos (e){//将ul移动到正确的位置上\r\n                if(bannerUl.mosedownMoveGap>50)//当鼠标移动距离超过一个阈值\r\n                {\r\n                    moveToPrevious(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                        // 根据Index值更新底部li\r\n                        updataBottomUl(bannerUl.activedLiIndex)\r\n                        //播放动画\r\n                        animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                    });\r\n                }\r\n                else if(bannerUl.mosedownMoveGap<-50)//当鼠标移动距离超过一个阈值\r\n                {\r\n                    moveToNext(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                        // 根据Index值更新底部li\r\n                        updataBottomUl(bannerUl.activedLiIndex)\r\n                        //播放动画\r\n                        animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                    });\r\n                }else//鼠标移动没有超过设定阈值\r\n                {   //归位\r\n                    animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                }\r\n                document.removeEventListener(\"mousemove\",bannerUlMoveWithMouse);//移除document的mousemove\r\n                document.removeEventListener(\"mouseup\",bannerUlMoveWithMouseToCorrectPos);//移除document的mouseup\r\n                startAutoSwitch();//恢复自动播放\r\n            }\r\n        })\r\n        // 移动端手指拖动bannerul效果\r\n        bannerUl.addEventListener(\"touchstart\",function(e){\r\n            stopAutoSwitch();//暂停自动播放\r\n            bannerUl.fingerDownStartPos = e.targetTouches[0].pageX ;//手指按下时的坐标\r\n            bannerUl.fingerDownoffsetLeft = bannerUl.offsetLeft;//手指按下时，bannerUl的offsetleft\r\n            document.addEventListener(\"touchmove\",bannerUlMoveWithFinger)//添加事件监听手指移动，实现拖动效果\r\n            document.addEventListener(\"touchend\",bannerUlMoveWithFingerToCorrectPos)//添加事件监听手指离开，实现拖动归位效果\r\n            function bannerUlMoveWithFinger(e){\r\n                //手指移动的距离\r\n                bannerUl.fingerDownMoveGap = e.targetTouches[0].pageX  - bannerUl.fingerDownStartPos; \r\n                // 新偏移 = 原偏移 + 手指移动距离\r\n                bannerUl.style.left = bannerUl.fingerDownoffsetLeft + bannerUl.fingerDownMoveGap + \"px\"\r\n            }\r\n            function bannerUlMoveWithFingerToCorrectPos(e){\r\n                bannerUl.removeEventListener(\"touchmove\",bannerUlMoveWithFinger);\r\n                if(bannerUl.fingerDownMoveGap>50)//当手指移动距离超过一个阈值\r\n                {\r\n                    moveToPrevious(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                        // 根据Index值更新底部li\r\n                        updataBottomUl(bannerUl.activedLiIndex)\r\n                        //播放动画\r\n                        animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                    });\r\n                }\r\n                if(bannerUl.fingerDownMoveGap<-50)//当手指移动距离超过一个阈值\r\n                {\r\n                    moveToNext(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                        // 根据Index值更新底部li\r\n                        updataBottomUl(bannerUl.activedLiIndex)\r\n                        //播放动画\r\n                        animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                    });\r\n                }else//手指移动没有超过设定阈值\r\n                {   //归位\r\n                    animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                }\r\n                document.removeEventListener(\"touchmove\",bannerUlMoveWithFinger);//移除document的mousemove\r\n                document.removeEventListener(\"touchend\",bannerUlMoveWithFingerToCorrectPos);//移除document的mouseup\r\n                startAutoSwitch();//恢复自动播放\r\n            }\r\n        })\r\n        //手指点击事件\r\n        leftBtn.addEventListener(\"click\",function(){\r\n            if(!leftBtn.flag)//节流阀：防止频繁触发事件\r\n            {\r\n                leftBtn.flag=true;//打开节流阀\r\n                moveToPrevious(function(){\r\n                    // 根据Index值更新底部li\r\n                    updataBottomUl(bannerUl.activedLiIndex)\r\n                    //播放动画\r\n                    animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                        //回调函数：\r\n                        rightBtn.flag=false;//关闭节流阀\r\n                    })\r\n                });\r\n            }\r\n        })\r\n        rightBtn.addEventListener(\"click\",function(){\r\n            if(!rightBtn.flag)//节流阀：防止频繁触发事件\r\n            {\r\n                rightBtn.flag=true;//打开节流阀\r\n                moveToNext(function(){\r\n                    // 根据Index值更新底部li\r\n                    updataBottomUl(bannerUl.activedLiIndex)\r\n                    //播放动画\r\n                    animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                        //回调函数：\r\n                        rightBtn.flag=false;//关闭节流阀\r\n                    })\r\n                });\r\n            }\r\n        });\r\n        function moveToNext(callback){//如果能获取到下一个兄弟元素则修改Index否则保持不变\r\n            if(!bannerUl.activedLiIndex)\r\n            {   //第一次调用则初始化新属性\r\n                bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n            }\r\n            if(bannerUl.children[bannerUl.activedLiIndex].nextElementSibling)//如果该元素存在后一个兄弟元素\r\n            {\r\n                bannerUl.activedLiIndex+=1;//索引+1\r\n            }\r\n            callback && callback();\r\n        }\r\n        function moveToPrevious(callback){//如果能获取到上一个兄弟元素则修改Index否则保持不变\r\n            if(!bannerUl.activedLiIndex)\r\n            {   //第一次调用则初始化新属性\r\n                bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n            }\r\n            if(bannerUl.children[bannerUl.activedLiIndex].previousElementSibling)//如果该元素存在后一个兄弟元素\r\n            {\r\n                bannerUl.activedLiIndex-=1;//索引-1\r\n            }\r\n            callback && callback();\r\n        }\r\n        bottomUl.addEventListener(\"click\",function(event){\r\n            // 获取被点击li的index\r\n            var index = event.target.dataset[\"index\"]\r\n            //修改索引\r\n            bannerUl.activedLiIndex = parseInt(index)//此处需要注意数据类型\r\n            console.log(bannerUl.activedLiIndex);\r\n            //过渡动画\r\n            animate(bannerUl,-bannerUl.children[index].offsetLeft)//动画\r\n            //更新底部li\r\n            updataBottomUl(index)\r\n        })\r\n        function updataBottomUl(index){//更新底部ul状态\r\n            for(var i=0;i<bottomUl.childElementCount;i++)\r\n            {\r\n                bottomUl.children[i].classList.remove(\"active\")\r\n            }\r\n            bottomUl.children[index].classList.add(\"active\")\r\n        }\r\n        //动画函数\r\n        function animate(elementObj, target, callback) {\r\n            clearInterval(elementObj.timer)//clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            elementObj.timer = setInterval(function () {//elementObj.timer可以避免反复申请内存\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                    if (callback) {\r\n                        callback();\r\n                    }\r\n                }\r\n                var step = (target - elementObj.offsetLeft) / 10 //根据公式计算步长\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)//如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        //循环获取下一个子元素\r\n        function getNextActivedElement(elementObj){//如有子元素1，2，3，4 则该该函数返回的是 1->2->3->4->3->2->1->2->3->4->3->2->1....\r\n            if(!elementObj.activedLiIndex)//若activedLiIndex属性不存在则对其初始化\r\n            {\r\n                elementObj.activedLiIndex=0;//初始化索引为第一个元素\r\n            }\r\n            if(!elementObj.moveguide)//若moveguide属性不存在则对其初始化\r\n            {\r\n                elementObj.moveguide=\"forward\";//初始化移动方向为向右\r\n            }\r\n            if(elementObj.moveguide==\"forward\")//移动方向是向前\r\n            {   \r\n                if(elementObj.children[elementObj.activedLiIndex].nextElementSibling)//如果能够找到下一个元素\r\n                {\r\n                    elementObj.activedLiIndex+=1;//索引定位到下一个\r\n                }else{//如果找不到下一个元素\r\n                    elementObj.moveguide=\"backward\";//设置移动方向为往前\r\n                    elementObj.activedLiIndex-=1;//索引定位到前一个\r\n                }\r\n            }else{//移动方向是向后\r\n                if(elementObj.children[elementObj.activedLiIndex].previousElementSibling)//如果能够找到前一个元素\r\n                {\r\n                    elementObj.activedLiIndex-=1;//索引定位到前一个\r\n                }else{\r\n                    elementObj.moveguide=\"forward\";//设置移动方向为往后\r\n                    elementObj.activedLiIndex+=1;//索引定位到下一个\r\n                }\r\n            }\r\n            return elementObj.children[elementObj.activedLiIndex];\r\n        }\r\n    })();\r\n</script>\r\n```\r\n"},{"shortInfo":{"layout":"post","title":"修改Hexo的hightlight.js语法高亮默认样式","date":"2022-02-23T17:06:00.000Z","cover":"\\self_server\\assets\\images\\hightlightjs2.png","tags":["笔记","Hexo","hightlight.js"],"hideAtIndex":true,"categories":"前端","id":3506658773,"countWords":545,"readSeconds":54.5,"assetsbaseUrl":"/self_server/assets/"},"content":"### hightlight.js特性说明\r\n1. hightlight.js一般的使用流程\r\n```html\r\n# 导入css主题（导入的css决定配色方案）\r\n<link rel=\"stylesheet\" href=\"https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/a11y-dark.min.css\">\r\n# 导入js文件\r\n<script src=\"https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js\"></script>\r\n# 调用函数\r\n<script>hljs.highlightAll();</script>\r\n# 指定为html，也可不指定\r\n<pre>\r\n    <code class=\"language-html\">\r\n        需要高亮的代码\r\n    </code>\r\n</pre>\r\n```\r\n\r\n### hexo代码高亮特性说明\r\n1. **hexo**支持代码高亮，代码封装在**hexo-util**插件中，使用的是**hightlight.js**库\r\n    * 但是**hightlight.js**本身是没有实现行号支持的，**hexo**对**hightlight.js**封装后使其支持了行号显示。\r\n1. Hexo的_config.yml配置文件中关于代码高亮的配置说明:\r\n```yml\r\n# _config.yml\r\nhighlight:              # hightlight.js语法高亮\r\n  enable: true          # true为在服务端渲染，false为在客户端渲染\r\n  hljs: true            # 为代码的class 添加 hljs- 前缀 使其能够代码高亮\r\n  auto_detect: true     # 自动检测代码块的语言\r\n  line_number: true     # 行号显示\r\n  wrap: true            # 须和和line_number一致\r\n  tab_replace: '  '     # /t制表符替换成什么\r\n# prismjs:                # 另一个语法高亮插件,主要是面向浏览器的。两语法高亮插件只需启用一个\r\n#   enable: false         # 启用 PrimeJS 前应设置 highlight.enable 为 false\r\n#   preprocess: true      # preprocess 与 line_number 均设为 true，需要引入 prism-line-numbers.css 即可启用行号显示。均设为 false，需将prism-line-numbers.css 和 prism-line-numbers.js 都引入\r\n#   line_number: true    # 是否显示行号\r\n#   tab_replace: '  '     # /t制表符替换成什么\r\n```\r\n\r\n\r\n### 修改后\r\n1. 在hexo主题的源文件中找到博客文章页面的布局文件，添加hightlight.js的css链接。\r\n    * ```<link href=\"/css/base16_dracula.min.css\" rel=\"stylesheet\">```\r\n    * ```<link href=\"https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/base16/dracula.min.css\" rel=\"stylesheet\">```\r\n1. _config.yml中配置为：\r\n```\r\nhighlight:              # hightlight.js语法高亮\r\n  enable: true          # true为在服务端渲染，false为在客户端渲染\r\n  hljs: true            # 为代码的class 添加 hljs- 前缀 使其能够代码高亮\r\n  auto_detect: true     # 自动检测代码块的语言\r\n  line_number: false    # 行号显示\r\n  wrap: false           # 须和和line_number一致\r\n  tab_replace: '  '     # /t制表符替换成什么\r\n```\r\n1. 效果预览\r\n风格名: base16/dracula\r\n![](../images/hightlightjs2.png)"},{"shortInfo":{"title":"前端实现简易待办任务管理工具","date":"2022-07-19T17:40:00.000Z","cover":"\\self_server\\assets\\images\\前端实现简易待办任务管理工具\\2022-07-20-14-20-53.png","tags":["前端","toDoList"],"categories":"前端","id":2225743598,"countWords":446,"readSeconds":44.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 记录前端实现的简易待办任务管理工具\r\n**简记**\r\n* 使用js在客户端动态渲染页面\r\n* 为了实现数据的大容量持久存储，使用IndexedDB数据库，数据存储在客户端\r\n* 实现了在客户端对本地数据库的增删改查\r\n* 响应式；对移动端，pc端，ipad做了兼容性适配\r\n* 使用到的技术: indexedDB JQuery bootstrap promsie LESS\r\n* 代码量：总共约2000行代码\r\n\r\n## [-->测试<--](./demos/tools/demo/index.html)\r\n\r\n## 当前实现效果\r\n\r\n### 移动端效果\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-45-18.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-45-29.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-45-50.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-45-57.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-46-03.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-48-44.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-48-51.png)\r\n\r\n### PC端效果\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-20-14.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-23-18.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-21-38.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-20-53.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-37-47.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-38-30.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-41-26.png)\r\n\r\n"},{"shortInfo":{"title":"前端常用插件及框架","date":"2022-07-06T21:27:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["前端常用插件及框架"],"hideAtIndex":true,"categories":"笔记","id":834804841,"countWords":116,"readSeconds":11.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 前端常用插件及框架\r\n* 插件一般是为解决某一问题而存在的，功能单一\r\n* 框架提供了完整的解决方案，框架的控制权在框架本身，使用者需按照框架的规范开发，既能开发移动端也能开发pc端\r\n\r\n## 前端常用插件\r\n* 轮播图插件网站：[swiper](https://www.swiper.com.cn/)\r\n* superslide\r\n* iscroll\r\n* zy.media.js 视频插件\r\n\r\n## 前端常用框架\r\n* bootstrap\r\n* Vue\r\n* Angular\r\n* React"},{"shortInfo":{"title":"前端本地存储","date":"2022-07-06T22:03:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["前端本地存储"],"hideAtIndex":true,"categories":"笔记","id":3788007787,"countWords":501,"readSeconds":50.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# 前端本地存储\r\n\r\n## 特性\r\n* 数据存储在用户浏览器中\r\n* 设置、读取方便，关闭浏览器不丢失数据\r\n* 容量大，\r\n    * `window.sessionStorage` 越5M\r\n    * `window.localStorage` 越20M\r\n* 只能存储字符串，可将对象通过json编码后存储`JSON.stringify(obj)`\r\n\r\n## window.sessionStorage\r\n* 生命周期为关闭浏览器窗口\r\n* 在单个窗口的多页面中，数据可共享\r\n* 以键值对的形式存储使用\r\n\r\n**存储数据**\r\n```js\r\nsessionStorage.setItem(key,value)\r\n```\r\n\r\n**获取数据**\r\n```js\r\nsessionStorage.getItem(key)\r\n```\r\n\r\n**移除数据**\r\n```js\r\nsessionStorage.removeItem(key)\r\n```\r\n\r\n**清除所有数据**\r\n```js\r\nsessionStorage.clear()\r\n```\r\n\r\n## window.localStorage\r\n* 生命周期永久，除非手动删除\r\n* 可多窗口共享数据\r\n* 以键值对存储\r\n\r\n**存储数据**\r\n```js\r\nlocalStorage.setItem(key,value)\r\n```\r\n\r\n**获取数据**\r\n```js\r\nlocalStorage.getItem(key)\r\n```\r\n\r\n**移除数据**\r\n```js\r\nlocalStorage.removeItem(key)\r\n```\r\n\r\n**清除所有数据**\r\n```js\r\nlocalStorage.clear()\r\n```\r\n\r\n## 记住用户名案例\r\n\r\n<div id=\"demoiwfow\">\r\n    <input id=\"username\" type=\"text\"><input type=\"checkbox\" name=\"\" id=\"rember\" ><span>记住用户名，下次自动填写</span>\r\n</div>\r\n<style>\r\n    #demoiwfow *{\r\n        display: inline-block;\r\n        padding: 0;\r\n        margin: 0;\r\n        height: 25px;\r\n        line-height: 25px;\r\n        vertical-align: middle;\r\n    }\r\n</style>\r\n<script>\r\n    var username = document.querySelector(\"#username\")\r\n    var rember = document.querySelector(\"#rember\")\r\n    username.value = localStorage.getItem('username')\r\n    username.addEventListener(\"keyup\",function(){\r\n        if(rember.checked)\r\n        {\r\n            localStorage.setItem(\"username\",username.value)\r\n        }else{\r\n            localStorage.removeItem(\"username\")\r\n        }\r\n    })\r\n    rember.addEventListener(\"change\",function(){\r\n        if(rember.checked)\r\n        {\r\n            localStorage.setItem(\"username\",username.value)\r\n        }else{\r\n            localStorage.removeItem(\"username\")\r\n        }\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demoiwfow\">\r\n    <input id=\"username\" type=\"text\"><input type=\"checkbox\" name=\"\" id=\"rember\" ><span>记住用户名，下次自动填写</span>\r\n</div>\r\n<style>\r\n    #demoiwfow *{\r\n        display: inline-block;\r\n        padding: 0;\r\n        margin: 0;\r\n        height: 25px;\r\n        line-height: 25px;\r\n        vertical-align: middle;\r\n    }\r\n</style>\r\n<script>\r\n    var username = document.querySelector(\"#username\")\r\n    var rember = document.querySelector(\"#rember\")\r\n    username.value = localStorage.getItem('username')\r\n    username.addEventListener(\"keyup\",function(){\r\n        if(rember.checked)\r\n        {\r\n            localStorage.setItem(\"username\",username.value)\r\n        }else{\r\n            localStorage.removeItem(\"username\")\r\n        }\r\n    })\r\n    rember.addEventListener(\"change\",function(){\r\n        if(rember.checked)\r\n        {\r\n            localStorage.setItem(\"username\",username.value)\r\n        }else{\r\n            localStorage.removeItem(\"username\")\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n## JSON\r\n\r\n* 本地存储只能存储字符串类型的数据\r\n* 要存储js对象类型的数据，需利用`JSON.stringify()`来做转换\r\n* 获取本地存储的js对象时，由于存储的是字符串，所以须用`JSON.parse()`来做转换\r\n\r\n```js\r\nvar listObj = [{\r\n    title:\"???\",\r\n    data:\"20220714\"\r\n    content:\"???????????\"\r\n}]\r\n//存储数据\r\nlocalStorage.setItem(\"文章列表\",JSON.stringify(listObj))\r\n//获取数据\r\nvar temp = localStorage.getItem(\"文章列表\")\r\n```"},{"shortInfo":{"title":"前端项目笔记","cover":"\\self_server\\assets\\images\\CSS3重学笔记\\cover.png","coverWidth":1920,"coverHeight":1080,"date":"2022-06-09T08:00:00.000Z","date_end":"2022-06-09T08:00:00.000Z","tags":["HTML","CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":2692699572,"countWords":2452,"readSeconds":245.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# 前端项目笔记\r\n## 更新日志\r\n* `2022.06.09`：v1.0\r\n* `2022.06.11`: 原生进度条，自定义进度条实现 \r\n* `2022.06.12`: 精灵图、一般的网站项目目录结构\r\n* `2022.06.16`: logo图的SEO、惯用类名、网页部分内容名称\r\n* `2022.06.19`: html的默认高度\r\n\r\n## 目录\r\n- [前端项目笔记](#前端项目笔记)\r\n  - [更新日志](#更新日志)\r\n  - [目录](#目录)\r\n  - [版心居中](#版心居中)\r\n  - [网页logo结构](#网页logo结构)\r\n  - [记得设置宽高](#记得设置宽高)\r\n  - [清除浏览器默认样式](#清除浏览器默认样式)\r\n    - [清除超链接下划线](#清除超链接下划线)\r\n    - [清除列表的标号](#清除列表的标号)\r\n    - [去除浮动元素对父元素的影响](#去除浮动元素对父元素的影响)\r\n  - [html5原生进度条](#html5原生进度条)\r\n    - [meter](#meter)\r\n    - [progress](#progress)\r\n  - [自定义进度条](#自定义进度条)\r\n  - [css单标签进度条动态效果](#css单标签进度条动态效果)\r\n  - [非阻塞的指定时间后执行代码](#非阻塞的指定时间后执行代码)\r\n  - [精灵图](#精灵图)\r\n  - [logo图SEO搜索引擎优化写法](#logo图seo搜索引擎优化写法)\r\n  - [一些惯用类名](#一些惯用类名)\r\n  - [一些名词](#一些名词)\r\n  - [一般的项目结构](#一般的项目结构)\r\n    - [base.css代码示例](#basecss代码示例)\r\n  - [html的默认高度](#html的默认高度)\r\n  - [移动端主体部分的下边距问题](#移动端主体部分的下边距问题)\r\n  - [设计图中的虚线框](#设计图中的虚线框)\r\n  - [flex布局滚动条](#flex布局滚动条)\r\n    - [清除滚动条样式](#清除滚动条样式)\r\n  - [文字溢出省略](#文字溢出省略)\r\n\r\n## 版心居中\r\n* 版心居中效果实际工作中一般写在一个名为`.wrapper{};`的css类选择器中\r\n* 有元素需要版心居中效果，就给这个元素**附加**这个类名\r\n* 版心常见的宽度值为960px、980px、1000px、1200px等\r\n```html\r\n<style>\r\n    /* 版心居中 */\r\n    .wrapper{\r\n        width: 1200px;\r\n        margin: 0 auto;\r\n    }\r\n</style>\r\n<div class=\"otherClassName wrapper\">导航条</div>\r\n```\r\n\r\n## 网页logo结构\r\n* 网页logo应该使用的标签结构 h1>a>img\r\n\r\n## 记得设置宽高\r\n* `box-sizing:border-box;`属性生效必须设置宽或高\r\n\r\n## 清除浏览器默认样式\r\n\r\n### 清除超链接下划线\r\n```css\r\na{\r\n    text-decoration:none;\r\n}\r\n```\r\n### 清除列表的标号\r\n```css\r\nli{\r\n    list-style:none;\r\n}\r\n```\r\n\r\n### 去除浮动元素对父元素的影响\r\n```css\r\n.clearfix:before,\r\n.clearfix:after{\r\n    content:'';\r\n    display:table;\r\n}\r\n.clearfix:after{\r\n    clear:both;\r\n}\r\n```\r\n## html5原生进度条\r\n* 无法有效的修改标签的样式,背景色，进度前景色等。\r\n* 浏览器默认样式的表现在不同浏览器之间并不一致\r\n* 无法添加动画效果、交互效果\r\n* 生产环境，几乎是不会看到 `<meter>` 和 `<progress>` 标签\r\n\r\n### meter\r\n\r\n```html\r\n<!-- min、max、value 分别表示最大值，最小值与当前值。 -->\r\n<meter min=\"0\" max=\"500\" value=\"350\">350 degrees</meter> \r\n<style>\r\nmeter { \r\n    width: 200px; \r\n} \r\n</style>\r\n```\r\n效果：\r\n<meter min=\"0\" max=\"500\" value=\"350\">350 degrees</meter>\r\n<style>\r\nmeter { \r\n    width: 200px; \r\n} \r\n</style>\r\n\r\n### progress\r\n```html\r\n<!-- max 属性描述这个 progress 元素所表示的任务一共需要完成多少工作量，value 属性用来指定该进度条已完成的工作量。 -->\r\n<progress max=\"100\" value=\"70\"> 70% </progress> \r\n<style>\r\nprogress { \r\n    width: 200px; \r\n} \r\n</style>\r\n\r\n```\r\n效果：\r\n<progress max=\"100\" value=\"70\"> 70% </progress> \r\n<style>\r\nprogress { \r\n    width: 200px; \r\n} \r\n</style>\r\n\r\n## 自定义进度条\r\n```html\r\n<div class=\"progress-container\"><div class=\"process\" style=\"width:80%;\"></div></div>\r\n<style>\r\n.progress-container{\r\n    /* position:absolute;\r\n    right: 0px;\r\n    z-index: 1; */\r\n    display: inline-block;\r\n    width: 200px;\r\n    height: 1em;\r\n    background-color: #fff;\r\n    border-radius: 0.5em;\r\n    vertical-align: middle;\r\n}\r\n.process{\r\n    height: 1em;\r\n    /* background-color: #0f0; */\r\n    background: linear-gradient(90deg, #0f0, #0ff);\r\n    border-radius: 0.5em;\r\n}\r\n</style>\r\n```\r\n效果：\r\n\r\n<div class=\"progress-container\"><div class=\"process\" style=\"width:80%;\"></div></div>\r\n<style>\r\n.progress-container{\r\n    /* position:absolute;\r\n    right: 0px;\r\n    z-index: 1; */\r\n    display: inline-block;\r\n    width: 200px;\r\n    height: 1em;\r\n    background-color: #fff;\r\n    border-radius: 0.5em;\r\n    vertical-align: middle;\r\n}\r\n.process{\r\n    height: 1em;\r\n    /* background-color: #0f0; */\r\n    background: linear-gradient(90deg, #0f0, #0ff);\r\n    border-radius: 0.5em;\r\n}\r\n</style>\r\n\r\n\r\n## css单标签进度条动态效果\r\n* 动态是指在修改`--progress: 20%`属性值时会有动态效果\r\n\r\n```html\r\n<div class=\"g-progress\" style=\"--progress: 70%\"></div> \r\n<style>\r\n@property --progress { \r\n  syntax: '<percentage>'; \r\n  inherits: false; \r\n  initial-value: 0%; \r\n} \r\n.g-progress { \r\n    margin: auto; \r\n    width: 240px; \r\n    height: 25px; \r\n    border-radius: 25px; \r\n    background: linear-gradient(90deg, #0f0, #0ff var(--progress), transparent 0); \r\n    border: 1px solid #eee; \r\n    transition: .3s --progress; \r\n} \r\n</style>\r\n\r\n```\r\n效果：\r\n<div class=\"g-progress\" style=\"--progress: 20%\"></div>\r\n<style>\r\n@property --progress { \r\n  syntax: '<percentage>'; \r\n  inherits: false; \r\n  initial-value: 0%; \r\n} \r\n.g-progress { \r\n    margin: auto; \r\n    width: 240px; \r\n    height: 25px; \r\n    border-radius: 25px; \r\n    background: linear-gradient(90deg, #0f0, #0ff var(--progress), transparent 0); \r\n    border: 1px solid #eee; \r\n    transition: .3s --progress; \r\n} \r\n</style>\r\n\r\n\r\n## 非阻塞的指定时间后执行代码\r\n\r\n```js\r\n    <script >\r\n        setTimeout(\"func()\",0 );  \r\n        function func(){  \r\n            do\r\n            {\r\n                执行语句;\r\n            }while(结束条件)\r\n        }  \r\n    </script>\r\n```\r\n\r\n## 精灵图\r\n* 将项目中多个小图合并成一张大图，这张大图称为精灵图\r\n* 优点，减少服务器发送图片次数，减轻服务器压力，提高页面加载速度\r\n* 步骤\r\n    * 设置盒子的**宽高**为**小图的宽高**\r\n    * 设置盒子的**背景**为**大图的url()**\r\n    * 设置背景图的**起始绘制位置**为所需**小图左上角的坐标**\r\n* 注意\r\n    * 精灵图一般使用行内/行内块标签\r\n    * 属性名：`background-position:水平方向位置 垂直方向位置;`\r\n        * 水平方向正数表示背景图右移，负数表示左移\r\n        * 水平方向正数表示背景图下移，负数表示上移\r\n    * 具体位置偏移量要用像素大厨软件测量，然后取负数\r\n\r\n* 实例![](./images/前端项目笔记/2022-06-12-14-33-17.png)\r\n\r\n## logo图SEO搜索引擎优化写法\r\n1. 标签结构`<h1><a href=\"#\">网站名</a></h1>`\r\n2. 将网站logo设置为a的背景图\r\n3. 设置`background-size:contain;`\r\n4. 将文字大小设置为0，`font-size:0;`\r\n\r\n\r\n## 一些惯用类名\r\n![](./images/前端项目笔记/2022-06-16-02-03-54.png)\r\n\r\n\r\n## 一些名词\r\n* 快捷菜单和主导航![](./images/前端项目笔记/2022-06-15-21-00-23.png)\r\n\r\n## 一般的项目结构\r\n* 项目文件夹不建议包含中文\r\n* favicon.ico一般放项目根目录\r\n* 根目录的images文件夹放网站固定使用的图片素材，如logo，样式修饰图\r\n* 根目录的uploads文件夹存放网站非固定使用的图片，如商品图片，宣传图片\r\n* 根目录的lib文件夹存放网站所引用的一些库文件、框架文件的文件夹\r\n* index.html放根目录\r\n* 根目录下css文件夹保存网页样式\r\n    * base.css 基础公共样式，如默认样式的清除，列表符号清除 超链接下划线清除\r\n    * common.css 网页中多个网页相同模板的重复样式，如头部，底部\r\n    * index.css 首页样式\r\n    * 注意三个文件的引入顺序，后引入的覆盖先引入的\r\n![](./images/前端项目笔记/2022-06-12-21-36-00.png)\r\n\r\n### base.css代码示例\r\n```css\r\n/* 清除默认样式的代码 */\r\n/* 去除常见标签默认的 margin 和 padding */\r\nbody,\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\nh5,\r\nh6,\r\np,\r\nul,\r\nol,\r\nli,\r\ndl,\r\ndt,\r\ndd,\r\ninput {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\n/* 內减模式 */\r\n* {\r\n    box-sizing: border-box;\r\n}\r\n\r\n/* 设置网页统一的字体大小、行高、字体系列相关属性 */\r\nbody {\r\n  font: 16px/1.5 \"Helvetica Neue\", Helvetica, Arial, \"Microsoft Yahei\",\r\n    \"Hiragino Sans GB\", \"Heiti SC\", \"WenQuanYi Micro Hei\", sans-serif;\r\n  color: #333;\r\n}\r\n\r\n/* 去除列表默认样式 */\r\nul,\r\nol {\r\n  list-style: none;\r\n}\r\n\r\n/* 去除默认的倾斜效果 */\r\nem,\r\ni {\r\n  font-style: normal;\r\n}\r\n\r\n/* 去除a标签默认下划线，并设置默认文字颜色 */\r\na {\r\n  text-decoration: none;\r\n  color: #333;\r\n}\r\n\r\n/* 设置img的垂直对齐方式为居中对齐，去除img默认下间隙 */\r\nimg {\r\n  vertical-align: middle;\r\n}\r\n\r\n/* 去除input默认样式 */\r\ninput {\r\n  border: none;\r\n  outline: none;\r\n  color: #333;\r\n}\r\n\r\n/* 左浮动 */\r\n.fl {\r\n  float: left;\r\n}\r\n\r\n/* 右浮动 */\r\n.fr {\r\n  float: right;\r\n}\r\n\r\n/* 双伪元素清除法 */\r\n.clearfix::before,\r\n.clearfix::after {\r\n  content: \"\";\r\n  display: table;\r\n}\r\n.clearfix::after {\r\n  clear: both;\r\n}\r\n\r\n```\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n\r\n## html的默认高度\r\n当要给body标签添加背景图时可能会遇到图片不显示的问题，原因是因为body的高度默认靠内容撑开，其高度为0，但当设置body高度为100%会发现仍然不解决问题，原因是body标签的父级标签html的高度是0，所以还应该设置html高度为100%\r\n\r\n```css\r\nhtml{\r\n  height:100%\r\n}\r\nbody{\r\n  height:100%\r\n  background-image:url();\r\n}\r\n\r\n```\r\n\r\n## 移动端主体部分的下边距问题\r\n由于最底部的导航条是固定定位，会脱离标准流，如果主体部分的内容的底部没有外边距或内边距，版权信息就会被遮挡，正确的做法是应该添加一个边距\r\n\r\n![](./images/前端项目笔记/2022-06-20-01-10-33.png)\r\n\r\n## 设计图中的虚线框\r\n* 意思是这些地方是能点击的\r\n* 整个虚线框都是点击范围\r\n* 这个范围的宽高一般多为44这样的偶数\r\n![](./images/前端项目笔记/2022-06-20-02-28-34.png)\r\n\r\n## flex布局滚动条\r\n当手机端排版时，如果 ul 中 li 过多，一行装不下时，希望显示水平滚动条，而不是折行。\r\n\r\nflex 实现：\r\n\r\nul\r\n```css\r\ndisplay: flex;\r\noverflow-x: auto;\r\n```\r\nli\r\n```css\r\nflex: none;\r\n```\r\n\r\n![](./images/前端项目笔记/2022-06-22-08-54-37.png)\r\n![](./images/前端项目笔记/2022-06-22-08-51-18.png)\r\n\r\n![](./images/前端项目笔记/2022-06-22-08-51-48.png)\r\n\r\n### 清除滚动条样式\r\n仅在支持WebKit的浏览器 (例如, 谷歌Chrome, 苹果Safari)可以使用.\r\n\r\n\r\n滚动条相关伪元素名\r\n* ::-webkit-scrollbar — 整个滚动条.\r\n* ::-webkit-scrollbar-button — 滚动条上的按钮 (上下箭头).\r\n* ::-webkit-scrollbar-thumb — 滚动条上的滚动滑块.\r\n* ::-webkit-scrollbar-track — 滚动条轨道.\r\n* ::-webkit-scrollbar-track-piece — 滚动条没有滑块的轨道部分.\r\n* ::-webkit-scrollbar-corner — 当同时有垂直滚动条和水平滚动条时交汇的部分.\r\n* ::-webkit-resizer — 某些元素的corner部分的部分样式(例:textarea的可拖动按钮).\r\n\r\n示例\r\n```less\r\n&::-webkit-scrollbar{\r\n    // 清除滚动条\r\n    display: none;\r\n}\r\n```\r\n\r\n## 文字溢出省略\r\n```css\r\n/* 溢出隐藏 */\r\noverflow: hidden;\r\n/* 文字溢出显示省略号 */\r\ntext-overflow: ellipsis;\r\n/* 强制在同一行内显示所有文本，直到文本结束或者遭遇 br 对象 */\r\nwhite-space: nowrap;\r\n```"},{"shortInfo":{"title":"同源策略和跨域","date":"2022-08-26T15:43:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["前端"],"hideAtIndex":true,"categories":"笔记","id":2327725585,"countWords":586,"readSeconds":58.6,"assetsbaseUrl":"/self_server/assets/"},"content":"## 同源策略和跨域\r\n同源策略(Same-Origin Policy)最早由Netscape公司提出,是**浏览器**的一种安全策略\r\n* **同源**: 协议 域名 端口号 均一致\r\n* **跨域**: 违背同源策略就是跨域,\r\n* **具体表现**: 如果在`a.com`的页面中向`b.com`的服务器的发送**请求报文**,则其**响应报文**会被浏览器**拦截**.\r\n\r\n## CROS跨域(源)资源共享\r\n**CROS**(Cross-Origin Resource Sharing)跨域(源)资源共享,解决跨域资源共享的解决方案.\r\n\r\n**特点**: 不需要在客户端做特殊操作,解决跨域的步骤完全在服务器中进行.\r\n\r\n**工作原理**: 通过设置一个**响应头**来告诉浏览器该请求允许跨域\r\n```\r\nAccess-Control-Allow-Origin: *\r\n```\r\n\r\n\r\n## 完整访问控制请求头\r\n* `Access-Control-Allow-Origin: URL或*` 指定了允许访问该资源的外域\r\n* `Access-Control-Expose-Headers: 自定义响应头名1, 自定义响应头名2` 使得客户端能够获取到自定义的响应头\r\n* `Access-Control-Max-Age: <delta-seconds>` 指定了 preflight 请求的结果能够被缓存多久\r\n* `Access-Control-Allow-Credentials: true` 指定跨域请求时候能够携带验证信息,如cookie\r\n* `Access-Control-Allow-Methods: <method>[, <method>]*` 设置请求允许的方法,默认仅支持 GET POST HEAD\r\n* `Access-Control-Allow-Headers: <field-name>[, <field-name>]*` 设置允许的请求头的头名,默认仅支持9个请求头\r\n\r\n\r\n## CORS请求分类\r\n* 简单请求 : \r\n  * 请求方式必须为: `GET` `POST` `HEAD`\r\n  * 请求头必须: **不能包含自定义请求** ,仅能包含默认支持9个请求头\r\n  * 简单请求仅会在客户端和服务端之间发送一次请求,\r\n* 预检请求 : \r\n  * 请求方式: 除去`GET` `POST` `HEAD`之外的请求\r\n  * 请求头为: 请求头中**包含自定义的头部** 或包含 `application/json`\r\n  * 预检请求会在客户端和服务端之间发送两次请求,第一次会发送OPTIONS类型的请求进行预检,之后才会发送真正的请求\r\n\r\n**预检请求**  \r\n在浏览器和服务器通信前,浏览器会先发送OPTIONS类型的请求进行预检,以获知服务器是否允许该实际请求,  \r\n**服务器响应OPTIONS类型的请求后浏览器才会发送真正的请求并携带真实的数据**"},{"shortInfo":{"title":"响应式学习笔记","date":"2022-06-20T22:35:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["响应式","媒体查询","前端"],"hideAtIndex":true,"categories":"笔记","id":1933091409,"countWords":511,"readSeconds":51.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# 响应式学习笔记\r\n## 概述\r\n* 能更具设备的视口宽度自适应的调整网页的布局方式\r\n* 对于企业站等类似内容比较少的网站可以做成响应式，电商站不适合做响应式，一般单独开发成pc端页面和移动端页面的两个独立的页面\r\n![](./images/响应式/2022-06-23-00-04-33.png)\r\n\r\n* 解决方案\r\n    * 媒体查询\r\n    * bootstrap\r\n\r\n\r\n## 媒体查询\r\n* 根据设备宽度的变化，设置差异化样式\r\n* 常用写法\r\n    * **max-width:XXXpx** **>=XXXpx** 对最大不超过该数的宽度生效\r\n    * **min-width:XXXpx** **<=XXXpx** 对最小不低于该数的宽度生效\r\n* 关键词\r\n    * `and`\r\n    * `only`\r\n    * `not`\r\n* 媒体类型\r\n    ![](./images/响应式/2022-06-23-00-45-58.png)\r\n* 媒体特征\r\n    ![](./images/响应式/2022-06-23-00-46-43.png)\r\n\r\n* 语法格式\r\n```html\r\n<style>\r\n/* 完整写法 */\r\n    @media 关键词 媒体类型 and (媒体特性){\r\n        选择器{\r\n            样式\r\n        }\r\n    }\r\n/* 省略写法 */\r\n    @media (媒体特性){\r\n        选择器{\r\n            样式\r\n        }\r\n    }\r\n</style>\r\n\r\n<!-- 外链式写法 -->\r\n    <!-- 完整写法 -->\r\n        <link rel=\"stylesheet\" media=\"逻辑符 媒体类型 and (媒体特征)\" href=\"style.css\">\r\n    <!-- 完整写法 -->\r\n        <link rel=\"stylesheet\" media=\"(媒体特征)\" href=\"style.css\">\r\n\r\n```\r\n\r\n**示例代码1**\r\n```css\r\n/* 视口宽度小于768px：背景显示粉色 */\r\n@media (max-width:768px){\r\n    body{\r\n        background-color:pink;\r\n    }\r\n}\r\n/* 视口宽度大于768px：背景显示绿色 */\r\n@media (min-width:768px){\r\n    body{\r\n        background-color:green ;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**示例代码2**\r\n```less\r\n// bootstrap的间断点\r\n// ExtraSmall <576px\r\n// Small ≥576px\r\n// Medium ≥768px\r\n// Large ≥992px\r\n// X-Large ≥1200px\r\n// XX-Large ≥1400px\r\n\r\nbody{\r\n    //对于视口宽度在 1400px-无穷 的设备生效\r\n    @media(min-width:1400px){\r\n        background-color:black ;\r\n    }\r\n    //对于视口宽度在 0-1400px 的设备生效\r\n    @media(max-width:1400px){\r\n        background-color:red ;\r\n    }\r\n    //对于视口宽度在 0-1200px 的设备生效\r\n    @media(max-width:1200px){\r\n        background-color:blue ;\r\n    }\r\n    //对于视口宽度在 0-992px 的设备生效\r\n    @media(max-width:992px){\r\n        background-color:gold ;\r\n    }\r\n    //对于视口宽度在 0-768px 的设备生效\r\n    @media(max-width:768px){\r\n        background-color:green ;\r\n    }\r\n    //对于视口宽度在 0-576px 的设备生效\r\n    @media(max-width:576px){\r\n        background-color:skyblue ;\r\n    }\r\n    //根据层叠性和叠加性,\r\n}\r\n```\r\n\r\n## bootstrap\r\n* 内容较独立，单独做笔记"},{"shortInfo":{"layout":"post","cover":"\\self_server\\assets\\images\\default_cover2.jpg","title":"响应式网页项目实战","date":"2022-06-23T09:21:00.000Z","tags":["响应式","BootStrap","demo"],"hideAtIndex":true,"categories":"前端","id":2988337862,"countWords":94,"readSeconds":9.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 响应式网页项目实战\r\n\r\n## Demos\r\n* [-->AlloyTeam官网仿写<--](./demos/响应式网页项目实战AlloyTeam/AlloyTeam/index.html)\r\n    * 基本上对网站的所有动态效果做了完整实现\r\n    * 响应式功能能够适配手机平板电脑\r\n    * 底部版权信息部分没有实现\r\n    * [原网站](http://www.alloyteam.com/)\r\n    * ![](./images/2022-10-18-14-41-37.png)\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"layout":"post","title":"完蛋还剩不到六十天","date":"2022-02-24T17:12:00.000Z","cover":"\\self_server\\assets\\images\\加倍努力.jfif","tags":["日志"],"categories":"日志","id":2538352011,"countWords":65,"readSeconds":6.5,"assetsbaseUrl":"/self_server/assets/"},"content":"## 完蛋还剩不到六十天\r\n\r\n**保送政策取消了，考试还剩不到六十天，这来得及吗，这来不及了，这能放弃吗，这不能放弃！！！**\r\n\r\n![](./images/233.gif)\r\n<!-- <img src=\"./images/233.gif\" style=\"display:block;margin:0 auto;height:200px;\"> -->\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"title":"手写实现Promise","date":"2022-07-24T17:32:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["Promise"],"hideAtIndex":true,"categories":"笔记","id":333572838,"countWords":13544,"readSeconds":1354.4,"assetsbaseUrl":"/self_server/assets/"},"content":"## 基本结构搭建\r\n\r\n```js\r\n//1. 声明构造函数\r\n    function Promise(executor){\r\n\r\n    }\r\n//2. 添加then方法\r\n    Promise.prototype.then = function(onResolved,onRejected){\r\n\r\n    }\r\n    // let p = new Promise((resolve,reject)=>{\r\n    //     resolve(\"OK\")\r\n    // })\r\n    // p.then((value)=>{\r\n    //     console.log(value)\r\n    // })\r\n```\r\n\r\n\r\n## resolve与reject函数的结构搭建\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n\r\n//1. 执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n//2. 执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    executor(resolve,reject);\r\n\r\n\r\n//3. resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n\r\n    }\r\n//4. reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n\r\n    }\r\n\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n\r\n## resolve函数与reject函数的实现\r\n\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n//0. 添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n//1. 保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    executor(resolve,reject);\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n//2. 修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n//3. 修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n//4. reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// console.log(p)\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n## 实现异常处理\r\n执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n// 0. 异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// console.log(p)\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n## 实现状态只能修改一次\r\n执行器中的代码应该只能在第一次调用`resolve()`或`reject()`时修改**状态**和**结果**值，实现该功能只需在修改 **状态** 前判断其是否为初始值\r\n\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n    //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //0. 实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n//1. 实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\nlet p = new Promise((resolve,reject)=>{\r\n    resolve(\"OK\")\r\n})\r\nconsole.log(p)\r\np.then((value)=>{\r\n    console.log(value)\r\n})\r\n```\r\n\r\n## then()执行回调函数的实现\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n    //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n//0. 根据promise状态执行回调函数\r\n    if(this.PromsieState == \"fulfilled\")\r\n    {\r\n//2. 传递value\r\n        onResolved(this.PromsieResult);\r\n    }\r\n//1. 根据promise状态执行回调函数\r\n    if(this.PromsieState == \"rejected\")\r\n    {\r\n//3. 传递reason\r\n        onRejected(this.PromsieResult);\r\n    }\r\n    \r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// console.log(p)\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n## then处理异步执行的实现\r\n执行器中的代码存在异步语句时，then方法中需要处理该种情形\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n// 1. 声明属性用于保存回调函数\r\n    this.callBack = {}\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n    //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n// 3. 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n        if(self.callBack.onResolved)\r\n        {\r\n//4. 执行保存的回调函数\r\n            self.callBack.onResolved(data)\r\n        }\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n\r\n// 5. 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n        if(self.callBack.onRejected)\r\n        {\r\n//6. 执行保存的回调函数\r\n            self.callBack.onRejected(data)\r\n        }\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n    //根据promise状态执行回调函数\r\n    if(this.PromsieState == \"fulfilled\")\r\n    {\r\n        //传递value\r\n        onResolved(this.PromsieResult);\r\n    }\r\n    //根据promise状态执行回调函数\r\n    if(this.PromsieState == \"rejected\")\r\n    {\r\n        //传递reason\r\n        onRejected(this.PromsieResult);\r\n    }\r\n//0. 处理当执行器中存在异步语句的情形\r\n    if(this.PromsieState == \"pending\")\r\n    {\r\n// 2. 保存回调函数\r\n        this.callBack = {\r\n            onResolved:onResolved,\r\n            onRejected:onRejected\r\n        }\r\n    }\r\n    \r\n\r\n}\r\nlet p = new Promise((resolve,reject)=>{\r\n    resolve(\"OK\")\r\n})\r\nconsole.log(p)\r\np.then((value)=>{\r\n    console.log(value)\r\n})\r\n```\r\n\r\n## then处理异步执行的多个回调函数的实现\r\n\r\n```js\r\n    //声明构造函数\r\n    function Promise(executor){\r\n        //添加属性\r\n        this.PromsieState = 'pending';\r\n        this.PromsieResult = null ;\r\n        // 声明属性用于保存回调函数\r\n        // this.callBack = {}\r\n//0. 修改为保存数组\r\n        this.callBacks = []\r\n\r\n        //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n        const self = this;//self _this that\r\n\r\n        //执行器函数executor在构造函数中是同步调用的:\r\n        // executor();\r\n\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        // executor(resolve,reject);\r\n\r\n        //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n        try{\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            executor(resolve,reject);\r\n        }catch(error){\r\n            reject(error)\r\n        }\r\n\r\n\r\n        //resolve()是一个函数，应当有一个形式参数\r\n        function resolve(data){\r\n            //实现状态只能修改一次：判断状态是否为初始状态\r\n            if (self.PromsieState !==\"pending\") return;\r\n            \r\n            //修改实例化对象的状态值(属性名：promiseState)\r\n            self.PromsieState = \"fulfilled\"\r\n            //修改实例化对象的结果值(属性名：promiseResult)\r\n            self.PromsieResult = data;\r\n            // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n            // if(self.callBack.onResolved)\r\n            // {\r\n            //     //执行保存的回调函数\r\n            //     self.callBack.onResolved(data)\r\n            // }\r\n//2. 执行所有成功的回调函数\r\n            self.callBacks.forEach(item=>{\r\n                item.onResolved(data)\r\n            })\r\n        }\r\n        //reject()是一个函数，应当有一个形式参数\r\n        function reject(data){\r\n            //实现状态只能修改一次：判断状态是否为初始状态\r\n            if (self.PromsieState !==\"pending\") return;\r\n            \r\n            //reject()函数同resolve一样\r\n            self.PromsieState = \"rejected\"\r\n            self.PromsieResult = data;\r\n\r\n            // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n            // if(self.callBack.onRejected)\r\n            // {\r\n            //     //执行保存的回调函数\r\n            //     self.callBack.onRejected(data)\r\n            // }\r\n//3. 执行所有失败的回调函数\r\n            self.callBacks.forEach(item=>{\r\n                item.onRejected(data)\r\n            })\r\n        }\r\n    }\r\n    //添加then方法\r\n    Promise.prototype.then = function(onResolved,onRejected){\r\n        //根据promise状态执行回调函数\r\n        if(this.PromsieState == \"fulfilled\")\r\n        {\r\n            //传递value\r\n            onResolved(this.PromsieResult);\r\n        }\r\n        //根据promise状态执行回调函数\r\n        if(this.PromsieState == \"rejected\")\r\n        {\r\n            //传递reason\r\n            onRejected(this.PromsieResult);\r\n        }\r\n        //处理当执行器中存在异步语句的情形\r\n        if(this.PromsieState == \"pending\")\r\n        {\r\n            // 保存回调函数\r\n            // this.callBack = {\r\n            //     onResolved:onResolved,\r\n            //     onRejected:onRejected\r\n            // }\r\n//1. 保存所有回调函数\r\n            this.callBacks.push({\r\n                onResolved:onResolved,\r\n                onRejected:onRejected\r\n            })\r\n        }\r\n        \r\n\r\n    }\r\n    let p = new Promise((resolve,reject)=>{\r\n        resolve(\"OK\")\r\n    })\r\n    console.log(p)\r\n    p.then((value)=>{\r\n        console.log(value)\r\n    })\r\n```\r\n\r\n## 处理执行器中同步执行状态下then的返回值\r\nthen的返回值由其中的回调函数决定\r\n* 若回调函数的返回值是一个promise对象，则then返回的promise的状态和值与该对象一致\r\n* 若回调函数的返回值是一个非promise对象，则then返回的是状态为成功的promise对象，且其值为该返回值\r\n* 若回调函数中出现异常，则返回失败promise 且其值为抛出的异常\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n//0. then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n\r\n//5. 处理抛出异常的情况\r\n                    try{\r\n//1. 获取返回值\r\n                        let result = onResolved(this.PromsieResult);\r\n//2. 判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n//3. 分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n//4. 处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n//6. 处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n\r\n\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n//7. rejected处理过程类似\r\n//处理抛出异常的情况\r\n                    try{\r\n//获取返回值\r\n                        let result = onRejected(this.PromsieResult);\r\n//判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n//分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n//处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n//处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        onResolved:onResolved,\r\n                        onRejected:onRejected\r\n                    })\r\n                }\r\n            })\r\n\r\n            \r\n\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            resolve(\"OK\")\r\n        })\r\n        console.log(p)\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n```\r\n\r\n\r\n## 处理执行器中异步执行状态下then的返回值\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n\r\n                    //处理抛出异常的情况\r\n                    try{\r\n                        //获取返回值\r\n                        let result = onResolved(this.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n\r\n\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //处理抛出异常的情况\r\n                    try{\r\n                    //获取返回值\r\n                        let result = onRejected(this.PromsieResult);\r\n                    //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n//1. 处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //处理抛出异常的情况\r\n                            try{\r\n                                //获取返回值\r\n                                let result = onResolved(data);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        },\r\n                        onRejected:function(data){\r\n                            //处理抛出异常的情况\r\n                            try{\r\n                                //获取返回值\r\n                                let result = onRejected(data);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n            \r\n\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                resolve(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n```\r\n\r\n\r\n## then方法优化\r\n对重复执行的代码块进行封装\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n//1. 声明变量\r\n                let self = this\r\n// 2. 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n//3. 调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n//4. 调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n//5. 调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n//6. 调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n            \r\n\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                resolve(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n```\r\n\r\n## catch方法及异常穿透的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n//2. 处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n//3. 处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n        }\r\n//1. 添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n        .then(value=>{\r\n            console.log(value);\r\n        })\r\n        .catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n```\r\n\r\n## resolve方法的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n//1. 添加resolve方法\r\n        Promise.resolve = function(value){\r\n//2. 返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n        .then(value=>{\r\n            console.log(value);\r\n        })\r\n        .catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n//3. 使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n```\r\n\r\n## reject方法的实现\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n//1. 添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n        .then(value=>{\r\n            console.log(value);\r\n        })\r\n        .catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n//2. 使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## all方法的实现\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n            \r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        //添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n//1. 添加all方法\r\n        Promise.all = function(Promises=[]){\r\n            return new Promise((resolve,reject)=>{\r\n//2. 声明计数器\r\n                let count = 0\r\n//3. 成功结果数字\r\n                let results = []\r\n                for(let i =0 ; i<Promises.length;i++)\r\n                Promises[i].then(value=>{\r\n//4. 自增计数器\r\n                    count++;\r\n//5. 存入结果值\r\n                    results[i]=value\r\n//6. 判断是否所有都成功\r\n                    if(count == Promises.length){\r\n//7. 返回结果\r\n                        resolve(results)\r\n                    }\r\n                },reason=>{\r\n//8. 若有任何一个结果为失败，则all返回的也是失败\r\n                    reject(reason);\r\n                })\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## race方法的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n            \r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        //添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n        //添加all方法\r\n        Promise.all = function(Promises=[]){\r\n            return new Promise((resolve,reject)=>{\r\n        //声明计数器\r\n                let count = 0\r\n        //成功结果数字\r\n                let results = []\r\n                for(let i =0 ; i<Promises.length;i++)\r\n                Promises[i].then(value=>{\r\n        //自增计数器\r\n                    count++;\r\n        //存入结果值\r\n                    results[i]=value\r\n        //判断是否所有都成功\r\n                    if(count == Promises.length){\r\n        //返回结果\r\n                        resolve(results)\r\n                    }\r\n                },reason=>{\r\n        //若有任何一个结果为失败，则all返回的也是失败\r\n                    reject(reason);\r\n                })\r\n            })\r\n        }\r\n//1. 添加race方法\r\n        Promise.race = function(Promises=[]){\r\n//2. 返回\r\n            return new Promise((resolve,reject)=>{\r\n//3. 遍历\r\n                for(let i=0 ; i<Promises.length;i++){\r\n//4. 谁先改变状态，谁就能决定返回值的状态\r\n                    Promises[i].then(value=>{\r\n                        resolve(value)\r\n                    },reason=>{\r\n                        reject(reason)\r\n                    })\r\n                }\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## then方法中的回调函数异步执行的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n//0. 使得回调函数异步执行\r\n                    setTimeout(() => {\r\n                        try{\r\n                            //获取返回值\r\n                            let result = type(self.PromsieResult);\r\n                            //判断是否为promise对象\r\n                            if(result instanceof Promise){\r\n                                //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                result.then(v=>{\r\n                                    resolve(v)\r\n                                },r=>{\r\n                                    reject(r)\r\n                                })\r\n                            }else{\r\n                                //处理非promise对象的情况\r\n                                resolve(result)\r\n                            }\r\n                        }catch(error){\r\n                            //处理抛出的异常\r\n                            reject(error)\r\n                        }\r\n                    }, 0);\r\n\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n            \r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        //添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n        //添加all方法\r\n        Promise.all = function(Promises=[]){\r\n            return new Promise((resolve,reject)=>{\r\n        //声明计数器\r\n                let count = 0\r\n        //成功结果数字\r\n                let results = []\r\n                for(let i =0 ; i<Promises.length;i++)\r\n                Promises[i].then(value=>{\r\n        //自增计数器\r\n                    count++;\r\n        //存入结果值\r\n                    results[i]=value\r\n        //判断是否所有都成功\r\n                    if(count == Promises.length){\r\n        //返回结果\r\n                        resolve(results)\r\n                    }\r\n                },reason=>{\r\n        //若有任何一个结果为失败，则all返回的也是失败\r\n                    reject(reason);\r\n                })\r\n            })\r\n        }\r\n        // 添加race方法\r\n        Promise.race = function(Promises=[]){\r\n        // 返回\r\n            return new Promise((resolve,reject)=>{\r\n        // 遍历\r\n                for(let i=0 ; i<Promises.length;i++){\r\n        // 谁先改变状态，谁就能决定返回值的状态\r\n                    Promises[i].then(value=>{\r\n                        resolve(value)\r\n                    },reason=>{\r\n                        reject(reason)\r\n                    })\r\n                }\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## 封装成类\r\n```js\r\n//1. 类名\r\n        class Promise{\r\n//2. 构造函数\r\n            constructor(executor){\r\n                //添加属性\r\n                this.PromsieState = 'pending';\r\n                this.PromsieResult = null ;\r\n                // 声明属性用于保存回调函数\r\n                // this.callBack = {}\r\n                //修改为保存数组\r\n                this.callBacks = []\r\n\r\n                //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n                const self = this;//self _this that\r\n\r\n                //执行器函数executor在构造函数中是同步调用的:\r\n                // executor();\r\n\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                // executor(resolve,reject);\r\n\r\n                //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n                try{\r\n                    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                    executor(resolve,reject);\r\n                }catch(error){\r\n                    reject(error)\r\n                }\r\n\r\n\r\n                //resolve()是一个函数，应当有一个形式参数\r\n                function resolve(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //修改实例化对象的状态值(属性名：promiseState)\r\n                    self.PromsieState = \"fulfilled\"\r\n                    //修改实例化对象的结果值(属性名：promiseResult)\r\n                    self.PromsieResult = data;\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onResolved)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onResolved(data)\r\n                    // }\r\n                    //执行所有成功的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onResolved(data)\r\n                    })\r\n                }\r\n                //reject()是一个函数，应当有一个形式参数\r\n                function reject(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //reject()函数同resolve一样\r\n                    self.PromsieState = \"rejected\"\r\n                    self.PromsieResult = data;\r\n\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onRejected)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onRejected(data)\r\n                    // }\r\n                    //执行所有失败的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onRejected(data)\r\n                    })\r\n                }\r\n        }\r\n//3. then方法\r\n            then(onResolved,onRejected){\r\n                //then的返回值是一个promise\r\n                return new Promise((resolve,reject)=>{\r\n                    //声明变量\r\n                    let self = this\r\n                    //处理失败回调函数为undefined的情况（省略没有写）\r\n                    if(onRejected !== \"function\"){\r\n                        onRejected = (reason)=>{\r\n                            throw reason;\r\n                        }\r\n                    }\r\n                    //处理成功回调函数为undefined的情况（省略没有写）\r\n                    if(onResolved !== \"function\"){\r\n                        onResolved = value=>value\r\n                    }\r\n                    // 定义函数\r\n                    function callback(type){\r\n                        //使得回调函数异步执行\r\n                        setTimeout(() => {\r\n                            try{\r\n                                //获取返回值\r\n                                let result = type(self.PromsieResult);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        }, 0);\r\n\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"fulfilled\")\r\n                    {\r\n                        //传递value\r\n                        // onResolved(this.PromsieResult);\r\n                        //调用函数\r\n                        callback(onResolved)\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"rejected\")\r\n                    {\r\n                        //传递reason\r\n                        // onRejected(this.PromsieResult);\r\n                        //rejected处理过程类似\r\n                        //调用函数\r\n                        callback(onRejected)\r\n                    }\r\n                    //处理当执行器中存在异步语句的情形\r\n                    if(this.PromsieState == \"pending\")\r\n                    {\r\n                        // 保存回调函数\r\n                        // this.callBack = {\r\n                        //     onResolved:onResolved,\r\n                        //     onRejected:onRejected\r\n                        // }\r\n                        //保存所有回调函数\r\n                        this.callBacks.push({\r\n                            //处理执行器中异步执行时回调\r\n                            onResolved:function(data){\r\n                                //调用函数\r\n                                callback(onResolved)\r\n                            },\r\n                            onRejected:function(data){\r\n                                //调用函数\r\n                                callback(onRejected)\r\n                            }\r\n                        })\r\n                    }\r\n                })\r\n                \r\n            }\r\n//4. catch方法\r\n            catch(onRejected){\r\n                return this.then(undefined,onRejected);\r\n            }\r\n//5. resolve方法\r\n            static resolve(value){\r\n            //返回promise对象\r\n                return new Promise((resolve,reject)=>{\r\n                    if(value instanceof Promise){\r\n                        value.then(v=>{\r\n                            resolve(v);\r\n                        },r=>{\r\n                            reject(r);\r\n                        });\r\n                    }else{\r\n                        resolve(value);\r\n                    }\r\n                })\r\n            }\r\n//6. reject方法\r\n            static reject(reason){\r\n                return new Promise((resolve,reject)=>{\r\n                    reject(reason)\r\n                })\r\n            }\r\n// 7. all方法\r\n            static all(Promises=[]){\r\n                return new Promise((resolve,reject)=>{\r\n            //声明计数器\r\n                    let count = 0\r\n            //成功结果数字\r\n                    let results = []\r\n                    for(let i =0 ; i<Promises.length;i++)\r\n                    Promises[i].then(value=>{\r\n            //自增计数器\r\n                        count++;\r\n            //存入结果值\r\n                        results[i]=value\r\n            //判断是否所有都成功\r\n                        if(count == Promises.length){\r\n            //返回结果\r\n                            resolve(results)\r\n                        }\r\n                    },reason=>{\r\n            //若有任何一个结果为失败，则all返回的也是失败\r\n                        reject(reason);\r\n                    })\r\n                })\r\n            }\r\n// 8. race方法\r\n            static race(Promises=[]){\r\n            // 返回\r\n                return new Promise((resolve,reject)=>{\r\n            // 遍历\r\n                    for(let i=0 ; i<Promises.length;i++){\r\n            // 谁先改变状态，谁就能决定返回值的状态\r\n                        Promises[i].then(value=>{\r\n                            resolve(value)\r\n                        },reason=>{\r\n                            reject(reason)\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n       let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## 封装成类\r\n```js\r\n//1. 类名\r\n        class Promise{\r\n//2. 构造函数\r\n            constructor(executor){\r\n                //添加属性\r\n                this.PromsieState = 'pending';\r\n                this.PromsieResult = null ;\r\n                // 声明属性用于保存回调函数\r\n                // this.callBack = {}\r\n                //修改为保存数组\r\n                this.callBacks = []\r\n\r\n                //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n                const self = this;//self _this that\r\n\r\n                //执行器函数executor在构造函数中是同步调用的:\r\n                // executor();\r\n\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                // executor(resolve,reject);\r\n\r\n                //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n                try{\r\n                    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                    executor(resolve,reject);\r\n                }catch(error){\r\n                    reject(error)\r\n                }\r\n\r\n\r\n                //resolve()是一个函数，应当有一个形式参数\r\n                function resolve(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //修改实例化对象的状态值(属性名：promiseState)\r\n                    self.PromsieState = \"fulfilled\"\r\n                    //修改实例化对象的结果值(属性名：promiseResult)\r\n                    self.PromsieResult = data;\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onResolved)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onResolved(data)\r\n                    // }\r\n                    //执行所有成功的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onResolved(data)\r\n                    })\r\n                }\r\n                //reject()是一个函数，应当有一个形式参数\r\n                function reject(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //reject()函数同resolve一样\r\n                    self.PromsieState = \"rejected\"\r\n                    self.PromsieResult = data;\r\n\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onRejected)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onRejected(data)\r\n                    // }\r\n                    //执行所有失败的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onRejected(data)\r\n                    })\r\n                }\r\n        }\r\n//3. then方法\r\n            then(onResolved,onRejected){\r\n                //then的返回值是一个promise\r\n                return new Promise((resolve,reject)=>{\r\n                    //声明变量\r\n                    let self = this\r\n                    //处理失败回调函数为undefined的情况（省略没有写）\r\n                    if(onRejected !== \"function\"){\r\n                        onRejected = (reason)=>{\r\n                            throw reason;\r\n                        }\r\n                    }\r\n                    //处理成功回调函数为undefined的情况（省略没有写）\r\n                    if(onResolved !== \"function\"){\r\n                        onResolved = value=>value\r\n                    }\r\n                    // 定义函数\r\n                    function callback(type){\r\n                        //使得回调函数异步执行\r\n                        setTimeout(() => {\r\n                            try{\r\n                                //获取返回值\r\n                                let result = type(self.PromsieResult);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        }, 0);\r\n\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"fulfilled\")\r\n                    {\r\n                        //传递value\r\n                        // onResolved(this.PromsieResult);\r\n                        //调用函数\r\n                        callback(onResolved)\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"rejected\")\r\n                    {\r\n                        //传递reason\r\n                        // onRejected(this.PromsieResult);\r\n                        //rejected处理过程类似\r\n                        //调用函数\r\n                        callback(onRejected)\r\n                    }\r\n                    //处理当执行器中存在异步语句的情形\r\n                    if(this.PromsieState == \"pending\")\r\n                    {\r\n                        // 保存回调函数\r\n                        // this.callBack = {\r\n                        //     onResolved:onResolved,\r\n                        //     onRejected:onRejected\r\n                        // }\r\n                        //保存所有回调函数\r\n                        this.callBacks.push({\r\n                            //处理执行器中异步执行时回调\r\n                            onResolved:function(data){\r\n                                //调用函数\r\n                                callback(onResolved)\r\n                            },\r\n                            onRejected:function(data){\r\n                                //调用函数\r\n                                callback(onRejected)\r\n                            }\r\n                        })\r\n                    }\r\n                })\r\n                \r\n            }\r\n//4. catch方法\r\n            catch(onRejected){\r\n                return this.then(undefined,onRejected);\r\n            }\r\n//5. resolve方法\r\n            static resolve(value){\r\n            //返回promise对象\r\n                return new Promise((resolve,reject)=>{\r\n                    if(value instanceof Promise){\r\n                        value.then(v=>{\r\n                            resolve(v);\r\n                        },r=>{\r\n                            reject(r);\r\n                        });\r\n                    }else{\r\n                        resolve(value);\r\n                    }\r\n                })\r\n            }\r\n//6. reject方法\r\n            static reject(reason){\r\n                return new Promise((resolve,reject)=>{\r\n                    reject(reason)\r\n                })\r\n            }\r\n// 7. all方法\r\n            static all(Promises=[]){\r\n                return new Promise((resolve,reject)=>{\r\n            //声明计数器\r\n                    let count = 0\r\n            //成功结果数字\r\n                    let results = []\r\n                    for(let i =0 ; i<Promises.length;i++)\r\n                    Promises[i].then(value=>{\r\n            //自增计数器\r\n                        count++;\r\n            //存入结果值\r\n                        results[i]=value\r\n            //判断是否所有都成功\r\n                        if(count == Promises.length){\r\n            //返回结果\r\n                            resolve(results)\r\n                        }\r\n                    },reason=>{\r\n            //若有任何一个结果为失败，则all返回的也是失败\r\n                        reject(reason);\r\n                    })\r\n                })\r\n            }\r\n// 8. race方法\r\n            static race(Promises=[]){\r\n            // 返回\r\n                return new Promise((resolve,reject)=>{\r\n            // 遍历\r\n                    for(let i=0 ; i<Promises.length;i++){\r\n            // 谁先改变状态，谁就能决定返回值的状态\r\n                        Promises[i].then(value=>{\r\n                            resolve(value)\r\n                        },reason=>{\r\n                            reject(reason)\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n       let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```"},{"shortInfo":{"layout":"post","title":"本科上岸了","date":"2022-06-28T11:12:00.000Z","coverWidth":700,"coverHeight":394,"cover":"\\self_server\\assets\\images\\本科上岸了\\2022-07-01-22-32-19.png","tags":["日志"],"categories":"日志","id":3183533132,"countWords":59,"readSeconds":5.9,"assetsbaseUrl":"/self_server/assets/"},"content":"## 上岸了\r\n\r\n**上岸了，录取了，至少不是大专了**![](./images/本科上岸了/2022-07-01-22-18-42.png)\r\n    \r\n\r\n![](./images/本科上岸了/2022-07-01-22-17-12.png)\r\n\r\n\r\n<!-- ![](./images/本科上岸了/2022-07-01-22-35-33.png) -->\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"layout":"post","title":"欢迎来到我的博客站点(旧版)","date":"2021-12-28T11:32:00.000Z","cover":"\\self_server\\assets\\images\\home1.jpg","tags":["欢迎","日志"],"hideAtIndex":true,"categories":"日志","id":3254528127,"countWords":55,"readSeconds":5.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# 欢迎\r\n这是一个搭建在GitHub Pages的个人博客站点\r\n<br>网站使用HTML语言和Liquid编写 最终使用jekyllrb生成\r\n```\r\n#include<stdio.h>\r\nint main()\r\n{\r\n    printf(\"欢迎来到我的博客站点\");\r\n    return 0;\r\n}\r\n```\r\n"},{"shortInfo":{"title":"滚动条动态居中","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-06-02T06:58:57.000Z","tags":["html","js"],"hideAtIndex":true,"categories":"前端","id":4066116951,"countWords":112,"readSeconds":11.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动端滚动条动态水平居中\r\n* **关键代码**\r\n\r\n```js\r\n//滚动条位置居中,使得标题能在移动端被居中\r\n    function middleScroll(step,totalTime){\r\n      let f = document.getElementById(\"BOX_outside\")\r\n      let s = document.getElementById(\"BOX_inside\")\r\n      let delayTime= totalTime / ((s.clientWidth - f.clientWidth) / 2 / step)\r\n\r\n      let scrollTimer = setInterval(\r\n        () => {\r\n          if (f.scrollLeft <= (s.clientWidth - f.clientWidth) / 2 )\r\n          {\r\n            f.scrollLeft+=step;\r\n          }else\r\n          {\r\n            clearInterval(scrollTimer);\r\n          }\r\n      }, delayTime);\r\n  }\r\n  window.addEventListener('loaded',middleScroll(2,500)) //移动端动态局居中效果，每次移动2px 在500ms内使标题居中\r\n```\r\n\r\n* **效果**\r\n![](../images/gif/2022_06_02_15_07_08_663.gif)\r\n"},{"shortInfo":{"layout":"post","title":"用js写了个网页版俄罗斯方块","date":"2022-01-09T13:39:00.000Z","cover":"\\self_server\\assets\\images\\俄罗斯方块.png","tags":["网站","游戏"],"categories":"前端","id":1185660991,"countWords":28,"readSeconds":2.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# [-->点击试玩V1.01<--](./demos/html-js_russia_client/index.html)\r\n# [-->点击试玩V1.00<--](./demos/games/html_jsRussia_client/index.html)\r\n\r\n<style>\r\nh1{\r\n    text-align: center;\r\n}\r\n</style>"},{"shortInfo":{"layout":"post","title":"用WordPress搭建的新博客站点","date":"2022-05-24T17:12:00.000Z","cover":"\\self_server\\assets\\images\\新站点.png","tags":["前端"],"hideAtIndex":true,"categories":"前端","id":2404225599,"countWords":26,"readSeconds":2.6,"assetsbaseUrl":"/self_server/assets/"},"content":"#### 用WordPress搭建的新博客站点:\r\n\r\n\r\n<a href=\"http://120.27.243.59:22222/\"><h1>新博客站点</h1></a>"},{"shortInfo":{"title":"电路原理核心知识点笔记","cover":"\\self_server\\assets\\images\\电路原理\\cover.jpg","coverWidth":480,"coverHeight":307,"date":"2022-06-19T00:08:00.000Z","tags":["电路"],"hideAtIndex":true,"categories":"笔记","id":1083726435,"countWords":1256,"readSeconds":125.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 电路原理核心知识点笔记\r\n\r\n## 目录\r\n- [电路原理核心知识点笔记](#电路原理核心知识点笔记)\r\n  - [目录](#目录)\r\n  - [支路量](#支路量)\r\n    - [电流](#电流)\r\n    - [电压](#电压)\r\n    - [电位](#电位)\r\n    - [电动势](#电动势)\r\n    - [变量的大小写](#变量的大小写)\r\n  - [参考方向](#参考方向)\r\n    - [电流参考方向的两种表示方式](#电流参考方向的两种表示方式)\r\n    - [电压参考方向的三种表示方式](#电压参考方向的三种表示方式)\r\n    - [电动势参考方向的三种表示方式](#电动势参考方向的三种表示方式)\r\n    - [关联参考方向](#关联参考方向)\r\n    - [非关联参考方向](#非关联参考方向)\r\n  - [功率](#功率)\r\n    - [功率的发出和吸收的判断](#功率的发出和吸收的判断)\r\n      - [一种记忆理解方式](#一种记忆理解方式)\r\n      - [另一种记忆理解方式](#另一种记忆理解方式)\r\n  - [端口](#端口)\r\n\r\n## 支路量\r\n\r\n### 电流\r\n* 定义：电荷随时间的变化率\r\n* 表达式：![](./images/电路原理/2022-06-19-08-09-16.png)\r\n* 计算的电流：正电荷在单位时间内流过导体的数量\r\n* 单位：$A$安培\r\n\r\n### 电压\r\n* 定义： **电场力**将单位的正电荷移动所做的功\r\n* 表达式：![](./images/电路原理/2022-06-19-08-14-40.png)\r\n* 单位：$V$伏特\r\n\r\n### 电位\r\n* 定义： 从某一点到参考点的电压\r\n* 参考点：\r\n    * 参考点的电位值人为定义为0\r\n    * 符号$φ$或$U$\r\n    * 单位V伏特\r\n    * 一个电路只能有一个参考点(0电位点)\r\n* 两点之间的电压等于两点之间电位差$U_{ab}=φ_a-φ_b$\r\n* 两点之间电位差可以称为电位降，电位降就是电压，所以也称电压为电压降\r\n* 两点之间的电压和参考点是谁无关\r\n\r\n### 电动势\r\n* 定义： **非电场力**将单位正电荷移动所做的功\r\n* 表达式： ![](./images/电路原理/2022-06-19-08-36-05.png)\r\n* 对比电场力和非电场力\r\n    * $e_{BA}$表征的是非电场力使得单位正电荷从B点到A点移动，使得电位升高，意味着能量的增加 $e_{BA}=φ_a-φ_b$\r\n    * $u_{AB}$表征的是电场力使得单位正电荷从A点到B点移动，使得电位降低，意味着能量的消耗 $u_{BA}=φ_a-φ_b$\r\n\r\n### 变量的大小写\r\n* 常量用大写$U$ $I$\r\n* 可能发生改变用小写$u(t)$ $i(t)$\r\n\r\n## 参考方向\r\n### 电流参考方向的两种表示方式\r\n* 箭头：箭头指向电流的流向方向\r\n* 下标：$i_{AB}$表示电流方向从A流向B，如果$i_{AB}>0$ 则电流的实际方向和参考方向一致\r\n<!-- ![](./images/电路原理/2022-06-19-09-05-49.png) -->\r\n### 电压参考方向的三种表示方式\r\n* 箭头\r\n* 正负号\r\n* 双下标：$U_{AB}$ 表示电压从A到B的电位降\r\n![](./images/电路原理/2022-06-19-09-04-27.png)\r\n\r\n### 电动势参考方向的三种表示方式\r\n* 箭头\r\n* 正负号\r\n* 双下标：$e_{AB}$ 表示电动势从B到A的电位升\r\n![](./images/电路原理/2022-06-19-09-05-19.png)\r\n\r\n### 关联参考方向\r\n* 电流从电压的正端流入 负端流出\r\n![](./images/电路原理/2022-06-19-09-08-45.png)\r\n\r\n### 非关联参考方向\r\n* 电流从电压的负端流入 正端流出\r\n![](./images/电路原理/2022-06-19-09-08-55.png)\r\n\r\n## 功率\r\n* 定义：电场力在单位时间内所做的功\r\n* 定义式：\r\n    * ![](./images/电路原理/2022-06-19-09-13-01.png)\r\n    * ![](./images/电路原理/2022-06-19-09-13-42.png)\r\n* 功率的单位是瓦\r\n* 能量的单位是焦耳\r\n* 功率守恒：一个电路所发出的总功率等于这个电路所吸收的总功率\r\n\r\n### 功率的发出和吸收的判断\r\n![](./images/电路原理/2022-06-19-09-26-44.png)\r\n#### 一种记忆理解方式\r\n* **认为在关联参考方向下，计算的是元件吸收的功率$P_a=ui$，功率为正，实际为吸收**\r\n* **认为在关联参考方向下，计算的是元件吸收的功率$P_a=ui$，功率为负，实际为发出**\r\n* 认为在非关联参考方向下，计算的是元件发出的功率$P_d=ui$，功率为正，实际为发出\r\n* 认为在非关联参考方向下，计算的是元件发出的功率$P_d=ui$，功率为负，实际为吸收\r\n\r\n#### 另一种记忆理解方式\r\n* 认为在关联参考方向下，计算的是元件**吸收**的功率$P_a=ui$，功率为正，实际为吸收\r\n* 认为在关联参考方向下，计算的是元件**吸收**的功率$P_a=ui$，功率为负，实际为发出\r\n* 认为在非关联参考方向下，计算的是元件**吸收**的功率$P_a=-ui$，功率为正，实际为吸收\r\n* 认为在非关联参考方向下，计算的是元件**吸收**的功率$P_a=-ui$，功率为负，实际为发出\r\n\r\n## 端口"},{"shortInfo":{"title":"移动端click事件问题","date":"2022-07-06T19:50:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["移动端","click事件"],"hideAtIndex":true,"categories":"笔记","id":1325515324,"countWords":3544,"readSeconds":354.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动端click事件问题\r\n移动端click事件会有300ms的延迟，因为最初移动端需要用两只手指来放大页面，然后通过双击页面来恢复页面大小（double tap to zoom），300ms的延迟就是用来判断是否双击屏幕的，若两次点击屏幕的间隔小于300ms则判断是双击屏幕，大于300ms则被判断为click事件\r\n\r\n## 解决方案:禁用缩放\r\n禁用缩放后也就不存在双击屏幕恢复页面默认大小的功能，于是300ms的延迟就不存在了\r\n```html\r\n<meta name=\"viewport\" content=\"user-scalable=no\">\r\n```\r\n\r\n## 解决方案:利用touch事件自己封装函数\r\n* 手指触摸时记录触摸时间\r\n* 手指离开时记录离开时间\r\n* 手指移动时记录是否移动\r\n* 当手指触摸和离开时间间隔小于150ms 且手指没有滑动屏幕，则判断为点击\r\n\r\n```js\r\nfunction tap(obj,callback){\r\n    obj.isMove = false;\r\n    obj.touchStart = 0;\r\n    obj.touchEnd = 0;\r\n    obj.addEventListener(\"touchstart\",function(){\r\n        obj.touchStart = +new Date();//记录触摸时间\r\n    });\r\n    obj.addEventListener(\"touchmove\",function(){\r\n        obj.isMove = true;//记录是否移动\r\n    });\r\n    obj.addEventListener(\"touchend\",function(){\r\n        obj.touchEnd = +new Date();//记录离开时间\r\n        if(obj.touchEnd -  obj.touchStart > 150  && !obj.isMove)\r\n        {\r\n            callback && callback();\r\n        }\r\n        obj.isMove = false;\r\n        obj.touchStart = 0;\r\n        obj.touchEnd = 0;\r\n    });\r\n}\r\n//使用\r\ntap(div,function(){\r\n    //do something\r\n})\r\n```\r\n\r\n## 解决方案:使用fastclick.js插件\r\n\r\n\r\n\r\ngithub仓库：[fastclick.js](https://github.com/ftlabs/fastclick)  \r\n\r\n使用：****\r\n```html\r\n<script type='application/javascript' src='/path/to/fastclick.js'></script>\r\n<script>\r\n    // 原生js使用：\r\n    if ('addEventListener' in document) {\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n\t\t    FastClick.attach(document.body);\r\n\t    }, false);\r\n    }\r\n    //jQuery使用：\r\n    $(function() {\r\n        FastClick.attach(document.body);\r\n    });\r\n</script>\r\n```\r\n\r\n**注意**\r\n\r\nNote: As of late 2015 most mobile browsers - notably Chrome and Safari - no longer have a 300ms touch delay, so fastclick offers no benefit on newer browsers, and risks introducing bugs into your application. Consider carefully whether you really need to use it.\r\n\r\n截止到2015年，Chrome and Safari已经不再有300毫秒的触摸延迟了\r\n\r\n\r\n**完整源代码**\r\n```js\r\n;(function () {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.\r\n\t *\r\n\t * @codingstandard ftlabs-jsv2\r\n\t * @copyright The Financial Times Limited [All Rights Reserved]\r\n\t * @license MIT License (see LICENSE.txt)\r\n\t */\r\n\r\n\t/*jslint browser:true, node:true*/\r\n\t/*global define, Event, Node*/\r\n\r\n\r\n\t/**\r\n\t * Instantiate fast-clicking listeners on the specified layer.\r\n\t *\r\n\t * @constructor\r\n\t * @param {Element} layer The layer to listen on\r\n\t * @param {Object} [options={}] The options to override the defaults\r\n\t */\r\n\tfunction FastClick(layer, options) {\r\n\t\tvar oldOnClick;\r\n\r\n\t\toptions = options || {};\r\n\r\n\t\t/**\r\n\t\t * Whether a click is currently being tracked.\r\n\t\t *\r\n\t\t * @type boolean\r\n\t\t */\r\n\t\tthis.trackingClick = false;\r\n\r\n\r\n\t\t/**\r\n\t\t * Timestamp for when click tracking started.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.trackingClickStart = 0;\r\n\r\n\r\n\t\t/**\r\n\t\t * The element being tracked for a click.\r\n\t\t *\r\n\t\t * @type EventTarget\r\n\t\t */\r\n\t\tthis.targetElement = null;\r\n\r\n\r\n\t\t/**\r\n\t\t * X-coordinate of touch start event.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.touchStartX = 0;\r\n\r\n\r\n\t\t/**\r\n\t\t * Y-coordinate of touch start event.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.touchStartY = 0;\r\n\r\n\r\n\t\t/**\r\n\t\t * ID of the last touch, retrieved from Touch.identifier.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.lastTouchIdentifier = 0;\r\n\r\n\r\n\t\t/**\r\n\t\t * Touchmove boundary, beyond which a click will be cancelled.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.touchBoundary = options.touchBoundary || 10;\r\n\r\n\r\n\t\t/**\r\n\t\t * The FastClick layer.\r\n\t\t *\r\n\t\t * @type Element\r\n\t\t */\r\n\t\tthis.layer = layer;\r\n\r\n\t\t/**\r\n\t\t * The minimum time between tap(touchstart and touchend) events\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.tapDelay = options.tapDelay || 200;\r\n\r\n\t\t/**\r\n\t\t * The maximum time for a tap\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.tapTimeout = options.tapTimeout || 700;\r\n\r\n\t\tif (FastClick.notNeeded(layer)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Some old versions of Android don't have Function.prototype.bind\r\n\t\tfunction bind(method, context) {\r\n\t\t\treturn function() { return method.apply(context, arguments); };\r\n\t\t}\r\n\r\n\r\n\t\tvar methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];\r\n\t\tvar context = this;\r\n\t\tfor (var i = 0, l = methods.length; i < l; i++) {\r\n\t\t\tcontext[methods[i]] = bind(context[methods[i]], context);\r\n\t\t}\r\n\r\n\t\t// Set up event handlers as required\r\n\t\tif (deviceIsAndroid) {\r\n\t\t\tlayer.addEventListener('mouseover', this.onMouse, true);\r\n\t\t\tlayer.addEventListener('mousedown', this.onMouse, true);\r\n\t\t\tlayer.addEventListener('mouseup', this.onMouse, true);\r\n\t\t}\r\n\r\n\t\tlayer.addEventListener('click', this.onClick, true);\r\n\t\tlayer.addEventListener('touchstart', this.onTouchStart, false);\r\n\t\tlayer.addEventListener('touchmove', this.onTouchMove, false);\r\n\t\tlayer.addEventListener('touchend', this.onTouchEnd, false);\r\n\t\tlayer.addEventListener('touchcancel', this.onTouchCancel, false);\r\n\r\n\t\t// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\r\n\t\t// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick\r\n\t\t// layer when they are cancelled.\r\n\t\tif (!Event.prototype.stopImmediatePropagation) {\r\n\t\t\tlayer.removeEventListener = function(type, callback, capture) {\r\n\t\t\t\tvar rmv = Node.prototype.removeEventListener;\r\n\t\t\t\tif (type === 'click') {\r\n\t\t\t\t\trmv.call(layer, type, callback.hijacked || callback, capture);\r\n\t\t\t\t} else {\r\n\t\t\t\t\trmv.call(layer, type, callback, capture);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlayer.addEventListener = function(type, callback, capture) {\r\n\t\t\t\tvar adv = Node.prototype.addEventListener;\r\n\t\t\t\tif (type === 'click') {\r\n\t\t\t\t\tadv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {\r\n\t\t\t\t\t\tif (!event.propagationStopped) {\r\n\t\t\t\t\t\t\tcallback(event);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}), capture);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadv.call(layer, type, callback, capture);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// If a handler is already declared in the element's onclick attribute, it will be fired before\r\n\t\t// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and\r\n\t\t// adding it as listener.\r\n\t\tif (typeof layer.onclick === 'function') {\r\n\r\n\t\t\t// Android browser on at least 3.2 requires a new reference to the function in layer.onclick\r\n\t\t\t// - the old one won't work if passed to addEventListener directly.\r\n\t\t\toldOnClick = layer.onclick;\r\n\t\t\tlayer.addEventListener('click', function(event) {\r\n\t\t\t\toldOnClick(event);\r\n\t\t\t}, false);\r\n\t\t\tlayer.onclick = null;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.\r\n\t*\r\n\t* @type boolean\r\n\t*/\r\n\tvar deviceIsWindowsPhone = navigator.userAgent.indexOf(\"Windows Phone\") >= 0;\r\n\r\n\t/**\r\n\t * Android requires exceptions.\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;\r\n\r\n\r\n\t/**\r\n\t * iOS requires exceptions.\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;\r\n\r\n\r\n\t/**\r\n\t * iOS 4 requires an exception for select elements.\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsIOS4 = deviceIsIOS && (/OS 4_\\d(_\\d)?/).test(navigator.userAgent);\r\n\r\n\r\n\t/**\r\n\t * iOS 6.0-7.* requires the target element to be manually derived\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\\d/).test(navigator.userAgent);\r\n\r\n\t/**\r\n\t * BlackBerry requires exceptions.\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;\r\n\r\n\t/**\r\n\t * Determine whether a given element requires a native click.\r\n\t *\r\n\t * @param {EventTarget|Element} target Target DOM element\r\n\t * @returns {boolean} Returns true if the element needs a native click\r\n\t */\r\n\tFastClick.prototype.needsClick = function(target) {\r\n\t\tswitch (target.nodeName.toLowerCase()) {\r\n\r\n\t\t// Don't send a synthetic click to disabled inputs (issue #62)\r\n\t\tcase 'button':\r\n\t\tcase 'select':\r\n\t\tcase 'textarea':\r\n\t\t\tif (target.disabled) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase 'input':\r\n\r\n\t\t\t// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)\r\n\t\t\tif ((deviceIsIOS && target.type === 'file') || target.disabled) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase 'label':\r\n\t\tcase 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames\r\n\t\tcase 'video':\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn (/\\bneedsclick\\b/).test(target.className);\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Determine whether a given element requires a call to focus to simulate click into element.\r\n\t *\r\n\t * @param {EventTarget|Element} target Target DOM element\r\n\t * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.\r\n\t */\r\n\tFastClick.prototype.needsFocus = function(target) {\r\n\t\tswitch (target.nodeName.toLowerCase()) {\r\n\t\tcase 'textarea':\r\n\t\t\treturn true;\r\n\t\tcase 'select':\r\n\t\t\treturn !deviceIsAndroid;\r\n\t\tcase 'input':\r\n\t\t\tswitch (target.type) {\r\n\t\t\tcase 'button':\r\n\t\t\tcase 'checkbox':\r\n\t\t\tcase 'file':\r\n\t\t\tcase 'image':\r\n\t\t\tcase 'radio':\r\n\t\t\tcase 'submit':\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// No point in attempting to focus disabled inputs\r\n\t\t\treturn !target.disabled && !target.readOnly;\r\n\t\tdefault:\r\n\t\t\treturn (/\\bneedsfocus\\b/).test(target.className);\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Send a click event to the specified element.\r\n\t *\r\n\t * @param {EventTarget|Element} targetElement\r\n\t * @param {Event} event\r\n\t */\r\n\tFastClick.prototype.sendClick = function(targetElement, event) {\r\n\t\tvar clickEvent, touch;\r\n\r\n\t\t// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)\r\n\t\tif (document.activeElement && document.activeElement !== targetElement) {\r\n\t\t\tdocument.activeElement.blur();\r\n\t\t}\r\n\r\n\t\ttouch = event.changedTouches[0];\r\n\r\n\t\t// Synthesise a click event, with an extra attribute so it can be tracked\r\n\t\tclickEvent = document.createEvent('MouseEvents');\r\n\t\tclickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\r\n\t\tclickEvent.forwardedTouchEvent = true;\r\n\t\ttargetElement.dispatchEvent(clickEvent);\r\n\t};\r\n\r\n\tFastClick.prototype.determineEventType = function(targetElement) {\r\n\r\n\t\t//Issue #159: Android Chrome Select Box does not open with a synthetic click event\r\n\t\tif (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {\r\n\t\t\treturn 'mousedown';\r\n\t\t}\r\n\r\n\t\treturn 'click';\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * @param {EventTarget|Element} targetElement\r\n\t */\r\n\tFastClick.prototype.focus = function(targetElement) {\r\n\t\tvar length;\r\n\r\n\t\t// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.\r\n\t\tif (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month' && targetElement.type !== 'email') {\r\n\t\t\tlength = targetElement.value.length;\r\n\t\t\ttargetElement.setSelectionRange(length, length);\r\n\t\t} else {\r\n\t\t\ttargetElement.focus();\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.\r\n\t *\r\n\t * @param {EventTarget|Element} targetElement\r\n\t */\r\n\tFastClick.prototype.updateScrollParent = function(targetElement) {\r\n\t\tvar scrollParent, parentElement;\r\n\r\n\t\tscrollParent = targetElement.fastClickScrollParent;\r\n\r\n\t\t// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the\r\n\t\t// target element was moved to another parent.\r\n\t\tif (!scrollParent || !scrollParent.contains(targetElement)) {\r\n\t\t\tparentElement = targetElement;\r\n\t\t\tdo {\r\n\t\t\t\tif (parentElement.scrollHeight > parentElement.offsetHeight) {\r\n\t\t\t\t\tscrollParent = parentElement;\r\n\t\t\t\t\ttargetElement.fastClickScrollParent = parentElement;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparentElement = parentElement.parentElement;\r\n\t\t\t} while (parentElement);\r\n\t\t}\r\n\r\n\t\t// Always update the scroll top tracker if possible.\r\n\t\tif (scrollParent) {\r\n\t\t\tscrollParent.fastClickLastScrollTop = scrollParent.scrollTop;\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * @param {EventTarget} targetElement\r\n\t * @returns {Element|EventTarget}\r\n\t */\r\n\tFastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {\r\n\r\n\t\t// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.\r\n\t\tif (eventTarget.nodeType === Node.TEXT_NODE) {\r\n\t\t\treturn eventTarget.parentNode;\r\n\t\t}\r\n\r\n\t\treturn eventTarget;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * On touch start, record the position and scroll offset.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onTouchStart = function(event) {\r\n\t\tvar targetElement, touch, selection;\r\n\r\n\t\t// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).\r\n\t\tif (event.targetTouches.length > 1) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\ttargetElement = this.getTargetElementFromEventTarget(event.target);\r\n\t\ttouch = event.targetTouches[0];\r\n\r\n\t\tif (deviceIsIOS) {\r\n\r\n\t\t\t// Only trusted events will deselect text on iOS (issue #49)\r\n\t\t\tselection = window.getSelection();\r\n\t\t\tif (selection.rangeCount && !selection.isCollapsed) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tif (!deviceIsIOS4) {\r\n\r\n\t\t\t\t// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):\r\n\t\t\t\t// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched\r\n\t\t\t\t// with the same identifier as the touch event that previously triggered the click that triggered the alert.\r\n\t\t\t\t// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an\r\n\t\t\t\t// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.\r\n\t\t\t\t// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,\r\n\t\t\t\t// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,\r\n\t\t\t\t// random integers, it's safe to to continue if the identifier is 0 here.\r\n\t\t\t\tif (touch.identifier && touch.identifier === this.lastTouchIdentifier) {\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.lastTouchIdentifier = touch.identifier;\r\n\r\n\t\t\t\t// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:\r\n\t\t\t\t// 1) the user does a fling scroll on the scrollable layer\r\n\t\t\t\t// 2) the user stops the fling scroll with another tap\r\n\t\t\t\t// then the event.target of the last 'touchend' event will be the element that was under the user's finger\r\n\t\t\t\t// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check\r\n\t\t\t\t// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).\r\n\t\t\t\tthis.updateScrollParent(targetElement);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.trackingClick = true;\r\n\t\tthis.trackingClickStart = event.timeStamp;\r\n\t\tthis.targetElement = targetElement;\r\n\r\n\t\tthis.touchStartX = touch.pageX;\r\n\t\tthis.touchStartY = touch.pageY;\r\n\r\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\r\n\t\tif ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\r\n\t\t\tevent.preventDefault();\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.touchHasMoved = function(event) {\r\n\t\tvar touch = event.changedTouches[0], boundary = this.touchBoundary;\r\n\r\n\t\tif (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Update the last position.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onTouchMove = function(event) {\r\n\t\tif (!this.trackingClick) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// If the touch has moved, cancel the click tracking\r\n\t\tif (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {\r\n\t\t\tthis.trackingClick = false;\r\n\t\t\tthis.targetElement = null;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Attempt to find the labelled control for the given label element.\r\n\t *\r\n\t * @param {EventTarget|HTMLLabelElement} labelElement\r\n\t * @returns {Element|null}\r\n\t */\r\n\tFastClick.prototype.findControl = function(labelElement) {\r\n\r\n\t\t// Fast path for newer browsers supporting the HTML5 control attribute\r\n\t\tif (labelElement.control !== undefined) {\r\n\t\t\treturn labelElement.control;\r\n\t\t}\r\n\r\n\t\t// All browsers under test that support touch events also support the HTML5 htmlFor attribute\r\n\t\tif (labelElement.htmlFor) {\r\n\t\t\treturn document.getElementById(labelElement.htmlFor);\r\n\t\t}\r\n\r\n\t\t// If no for attribute exists, attempt to retrieve the first labellable descendant element\r\n\t\t// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label\r\n\t\treturn labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * On touch end, determine whether to send a click event at once.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onTouchEnd = function(event) {\r\n\t\tvar forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;\r\n\r\n\t\tif (!this.trackingClick) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\r\n\t\tif ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\r\n\t\t\tthis.cancelNextClick = true;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Reset to prevent wrong click cancel on input (issue #156).\r\n\t\tthis.cancelNextClick = false;\r\n\r\n\t\tthis.lastClickTime = event.timeStamp;\r\n\r\n\t\ttrackingClickStart = this.trackingClickStart;\r\n\t\tthis.trackingClick = false;\r\n\t\tthis.trackingClickStart = 0;\r\n\r\n\t\t// On some iOS devices, the targetElement supplied with the event is invalid if the layer\r\n\t\t// is performing a transition or scroll, and has to be re-detected manually. Note that\r\n\t\t// for this to function correctly, it must be called *after* the event target is checked!\r\n\t\t// See issue #57; also filed as rdar://13048589 .\r\n\t\tif (deviceIsIOSWithBadTarget) {\r\n\t\t\ttouch = event.changedTouches[0];\r\n\r\n\t\t\t// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null\r\n\t\t\ttargetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;\r\n\t\t\ttargetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;\r\n\t\t}\r\n\r\n\t\ttargetTagName = targetElement.tagName.toLowerCase();\r\n\t\tif (targetTagName === 'label') {\r\n\t\t\tforElement = this.findControl(targetElement);\r\n\t\t\tif (forElement) {\r\n\t\t\t\tthis.focus(targetElement);\r\n\t\t\t\tif (deviceIsAndroid) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetElement = forElement;\r\n\t\t\t}\r\n\t\t} else if (this.needsFocus(targetElement)) {\r\n\r\n\t\t\t// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.\r\n\t\t\t// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).\r\n\t\t\tif ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {\r\n\t\t\t\tthis.targetElement = null;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tthis.focus(targetElement);\r\n\t\t\tthis.sendClick(targetElement, event);\r\n\r\n\t\t\t// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.\r\n\t\t\t// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)\r\n\t\t\tif (!deviceIsIOS || targetTagName !== 'select') {\r\n\t\t\t\tthis.targetElement = null;\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (deviceIsIOS && !deviceIsIOS4) {\r\n\r\n\t\t\t// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled\r\n\t\t\t// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).\r\n\t\t\tscrollParent = targetElement.fastClickScrollParent;\r\n\t\t\tif (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Prevent the actual click from going though - unless the target node is marked as requiring\r\n\t\t// real clicks or if it is in the allowlist in which case only non-programmatic clicks are permitted.\r\n\t\tif (!this.needsClick(targetElement)) {\r\n\t\t\tevent.preventDefault();\r\n\t\t\tthis.sendClick(targetElement, event);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * On touch cancel, stop tracking the click.\r\n\t *\r\n\t * @returns {void}\r\n\t */\r\n\tFastClick.prototype.onTouchCancel = function() {\r\n\t\tthis.trackingClick = false;\r\n\t\tthis.targetElement = null;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Determine mouse events which should be permitted.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onMouse = function(event) {\r\n\r\n\t\t// If a target element was never set (because a touch event was never fired) allow the event\r\n\t\tif (!this.targetElement) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (event.forwardedTouchEvent) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Programmatically generated events targeting a specific element should be permitted\r\n\t\tif (!event.cancelable) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Derive and check the target element to see whether the mouse event needs to be permitted;\r\n\t\t// unless explicitly enabled, prevent non-touch click events from triggering actions,\r\n\t\t// to prevent ghost/doubleclicks.\r\n\t\tif (!this.needsClick(this.targetElement) || this.cancelNextClick) {\r\n\r\n\t\t\t// Prevent any user-added listeners declared on FastClick element from being fired.\r\n\t\t\tif (event.stopImmediatePropagation) {\r\n\t\t\t\tevent.stopImmediatePropagation();\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\r\n\t\t\t\tevent.propagationStopped = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Cancel the event\r\n\t\t\tevent.stopPropagation();\r\n\t\t\tevent.preventDefault();\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// If the mouse event is permitted, return true for the action to go through.\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * On actual clicks, determine whether this is a touch-generated click, a click action occurring\r\n\t * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or\r\n\t * an actual click which should be permitted.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onClick = function(event) {\r\n\t\tvar permitted;\r\n\r\n\t\t// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.\r\n\t\tif (this.trackingClick) {\r\n\t\t\tthis.targetElement = null;\r\n\t\t\tthis.trackingClick = false;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.\r\n\t\tif (event.target.type === 'submit' && event.detail === 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tpermitted = this.onMouse(event);\r\n\r\n\t\t// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.\r\n\t\tif (!permitted) {\r\n\t\t\tthis.targetElement = null;\r\n\t\t}\r\n\r\n\t\t// If clicks are permitted, return true for the action to go through.\r\n\t\treturn permitted;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Remove all FastClick's event listeners.\r\n\t *\r\n\t * @returns {void}\r\n\t */\r\n\tFastClick.prototype.destroy = function() {\r\n\t\tvar layer = this.layer;\r\n\r\n\t\tif (deviceIsAndroid) {\r\n\t\t\tlayer.removeEventListener('mouseover', this.onMouse, true);\r\n\t\t\tlayer.removeEventListener('mousedown', this.onMouse, true);\r\n\t\t\tlayer.removeEventListener('mouseup', this.onMouse, true);\r\n\t\t}\r\n\r\n\t\tlayer.removeEventListener('click', this.onClick, true);\r\n\t\tlayer.removeEventListener('touchstart', this.onTouchStart, false);\r\n\t\tlayer.removeEventListener('touchmove', this.onTouchMove, false);\r\n\t\tlayer.removeEventListener('touchend', this.onTouchEnd, false);\r\n\t\tlayer.removeEventListener('touchcancel', this.onTouchCancel, false);\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Check whether FastClick is needed.\r\n\t *\r\n\t * @param {Element} layer The layer to listen on\r\n\t */\r\n\tFastClick.notNeeded = function(layer) {\r\n\t\tvar metaViewport;\r\n\t\tvar chromeVersion;\r\n\t\tvar blackberryVersion;\r\n\t\tvar firefoxVersion;\r\n\r\n\t\t// Devices that don't support touch don't need FastClick\r\n\t\tif (typeof window.ontouchstart === 'undefined') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Chrome version - zero for other browsers\r\n\t\tchromeVersion = +(/Chrome\\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];\r\n\r\n\t\tif (chromeVersion) {\r\n\r\n\t\t\tif (deviceIsAndroid) {\r\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\r\n\r\n\t\t\t\tif (metaViewport) {\r\n\t\t\t\t\t// Chrome on Android with user-scalable=\"no\" doesn't need FastClick (issue #89)\r\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Chrome 32 and above with width=device-width or less don't need FastClick\r\n\t\t\t\t\tif (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t// Chrome desktop doesn't need FastClick (issue #15)\r\n\t\t\t} else {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (deviceIsBlackBerry10) {\r\n\t\t\tblackberryVersion = navigator.userAgent.match(/Version\\/([0-9]*)\\.([0-9]*)/);\r\n\r\n\t\t\t// BlackBerry 10.3+ does not require Fastclick library.\r\n\t\t\t// https://github.com/ftlabs/fastclick/issues/251\r\n\t\t\tif (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {\r\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\r\n\r\n\t\t\t\tif (metaViewport) {\r\n\t\t\t\t\t// user-scalable=no eliminates click delay.\r\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// width=device-width (or less than device-width) eliminates click delay.\r\n\t\t\t\t\tif (document.documentElement.scrollWidth <= window.outerWidth) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)\r\n\t\tif (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Firefox version - zero for other browsers\r\n\t\tfirefoxVersion = +(/Firefox\\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];\r\n\r\n\t\tif (firefoxVersion >= 27) {\r\n\t\t\t// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896\r\n\r\n\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\r\n\t\t\tif (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version\r\n\t\t// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx\r\n\t\tif (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Factory method for creating a FastClick object\r\n\t *\r\n\t * @param {Element} layer The layer to listen on\r\n\t * @param {Object} [options={}] The options to override the defaults\r\n\t */\r\n\tFastClick.attach = function(layer, options) {\r\n\t\treturn new FastClick(layer, options);\r\n\t};\r\n\r\n\r\n\tif (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\r\n\r\n\t\t// AMD. Register as an anonymous module.\r\n\t\tdefine(function() {\r\n\t\t\treturn FastClick;\r\n\t\t});\r\n\t} else if (typeof module !== 'undefined' && module.exports) {\r\n\t\tmodule.exports = FastClick.attach;\r\n\t\tmodule.exports.FastClick = FastClick;\r\n\t} else {\r\n\t\twindow.FastClick = FastClick;\r\n\t}\r\n}());\r\n```"},{"shortInfo":{"title":"移动端布局及Flex布局模型","date":"2022-06-18T16:23:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["Flex","移动端","前端"],"hideAtIndex":true,"categories":"笔记","id":327922926,"countWords":3387,"readSeconds":338.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动端布局及Flex布局模型\r\n## 目录\r\n- [移动端布局及Flex布局模型](#移动端布局及flex布局模型)\r\n  - [目录](#目录)\r\n  - [pc端和移动端分辨率](#pc端和移动端分辨率)\r\n    - [pc端分辨率物理分辨率和逻辑分辨率](#pc端分辨率物理分辨率和逻辑分辨率)\r\n    - [手机端物理分辨率和逻辑分辨率](#手机端物理分辨率和逻辑分辨率)\r\n  - [视口](#视口)\r\n  - [二倍图](#二倍图)\r\n  - [百分比布局](#百分比布局)\r\n  - [flex布局](#flex布局)\r\n    - [flex布局的构成](#flex布局的构成)\r\n    - [主轴对齐方式](#主轴对齐方式)\r\n      - [主轴对齐方式测试](#主轴对齐方式测试)\r\n    - [侧轴对齐方式](#侧轴对齐方式)\r\n      - [侧轴对齐方式测试](#侧轴对齐方式测试)\r\n      - [控制单个盒子的侧轴对齐方式](#控制单个盒子的侧轴对齐方式)\r\n    - [flex伸缩比](#flex伸缩比)\r\n    - [修改主轴方向](#修改主轴方向)\r\n      - [修改主轴方向后修改主轴的对齐方式](#修改主轴方向后修改主轴的对齐方式)\r\n      - [使用示例](#使用示例)\r\n    - [弹性盒子的换行](#弹性盒子的换行)\r\n    - [弹性盒子的侧轴对齐方式](#弹性盒子的侧轴对齐方式)\r\n      - [效果测试](#效果测试)\r\n      - [问题](#问题)\r\n\r\n\r\n\r\n## pc端和移动端分辨率\r\n\r\n### pc端分辨率物理分辨率和逻辑分辨率\r\n* pc端常见分辨率-**物理分辨率**\r\n    * 1920x1080\r\n    * 1366x760\r\n* pc端设置按比例缩放后的分辨率-**逻辑分辨率**\r\n    * 缩放150%后的分辨率：(1920/150%)x(1080/150%)\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-00-53-45.png)\r\n\r\n* 写html时应该参考**逻辑**分辨率\r\n\r\n\r\n### 手机端物理分辨率和逻辑分辨率\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-01-46-41.png)\r\n\r\n## 视口\r\n* 一些概念\r\n    ```\r\n    1.什么是视口?\r\n        视口简单理解就是可视区域大小我们称之为视口\r\n        在PC端，视口大小就是浏览器窗口可视区域的大小\r\n        在移动端, 视口大小并不等于窗口大小, 移动端视口宽度被人为定义为了980\r\n\r\n    2.为什么是980而不是其他的值?\r\n        **因为过去网页的版心都是980**\r\n        乔老爷子为了能够让网页在移动端完美的展示, 所以将iOS手机视口的大小定义为了980\r\n        后来谷歌也觉得这是一个非常牛X的方案, 所以Android手机的视口也定义为了980\r\n\r\n    3.移动端自动将视口宽度设置为980带来的问题\r\n        虽然移动端自动将视口宽度设置为980之后让我们可以很完美的看到整个网页\r\n        但是由于移动端的物理尺寸(设备宽度)是远远小于视口宽度的\r\n        所以为了能够在较小的范围内看到视口中所有的内容, 那么就必须将内容缩小\r\n        (和前面讲解Canvas时讲解的viewbox一样, 近大远小原理)\r\n\r\n    4.如何保证在移动端不自动缩放网页的尺寸?\r\n        通过meta设置视口大小\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n        width=device-width 设置视口宽度等于设备的宽度\r\n        initial-scale=1.0 初始缩放比例, 1不缩放\r\n        maximum-scale：允许用户缩放到的最大比例\r\n        minimum-scale：允许用户缩放到的最小比例\r\n        user-scalable：用户是否可以手动缩放\r\n    ```\r\n* **移动端**网页视口默认的宽是**980px**\r\n* **PC端**网页视口默认的宽和**电脑逻辑分辨率的宽度**一致\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-01-51-53.png)\r\n\r\n* 使用`meta`标签设置**视口**，可以使**网页宽度**和设备的**逻辑宽度**一致\r\n    ```html\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    ```\r\n    ![](./images/移动端布局及Flex布局模型/2022-06-19-01-56-49.png)\r\n\r\n\r\n## 二倍图\r\n* 当前移动端网页一般参考iPhone6、7、8出设计稿，然后再想办法适配其他机型\r\n* 但由于分辨率的原因，设计稿将会按照物理分辨率设计，因为如果按照逻辑分辨率设计，一张低分辨率的图到了高分辨率的屏幕将会变得模糊不清，所以往往是设计稿用高分辨率的图，但用低分辨率的尺寸，这样经过移动端浏览器的放大，图片的尺寸被放大后依然是清晰的，又由于其物理分辨率和逻辑分辨率**往往是**二倍的关系，所以这样的设计稿的图称为**二倍图**\r\n* 所以结论就是当设计稿中页面宽度为750px时,其实际尺寸应该写375px\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-01-46-41.png)\r\n* 需要注意的是，pc端的设计图也存在二倍图，如果设计图标识网页宽度为3840px，则其实际宽度很可能是1920px\r\n\r\n\r\n## 百分比布局\r\n* 过去普遍使用的一种布局\r\n* 百分比布局也叫流式布局\r\n* 具体就是盒子的宽度取百分比，高度取固定值\r\n* 效果：宽度自适应，高度固定\r\n\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-02-58-50.png)\r\n\r\n\r\n## flex布局\r\n* flex布局也叫弹性布局\r\n* 是一种**浏览器提倡**的**布局模型**\r\n* 非常适合结构化的布局模型\r\n* 布局网页更简单、灵活\r\n* 能够避免浮动脱标的问题\r\n* flex是专门用来布局的模型\r\n* 而浮动一开始只是为了文字环绕效果而开发的，并不是专门用来做布局的\r\n* 对于ie浏览器不兼容\r\n* 查看是否兼容[caniuse.com](https://caniuse.com)\r\n\r\n\r\n### flex布局的构成\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-03-39-43.png)\r\n* 设置方式：父元素添加`display:flex`\r\n* 作用：设置后子元素可以自动的挤压或拉伸\r\n* 各组成部分的名称\r\n    * **弹性容器** ：显示模式为flex的父元素\r\n    * **弹性盒子** ：子元素\r\n    * **主轴** ： **默认** 在水平方向\r\n    * **侧轴/交叉轴** ： **默认** 在垂直方向\r\n\r\n### 主轴对齐方式\r\n* 在flex布局模型中，调节主轴或侧轴的对齐方式可以设置盒子之间的间距\r\n* 属性名：`justify-content`\r\n* 属性值：![](./images/移动端布局及Flex布局模型/2022-06-19-03-57-53.png)\r\n* **当主轴方向为默认方向时，`justify-content`控制水平方向对齐方式**\r\n\r\n#### 主轴对齐方式测试\r\n* 主轴对齐方式justify-content:flex-start 左对齐\r\n<div id=\"textFlex1\">\r\n    <div>flex-start</div>\r\n    <div>flex-start</div>\r\n    <div>flex-start</div>\r\n    <div>flex-start</div>\r\n</div>\r\n<style>\r\n    #textFlex1{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content: flex-start;\r\n    }\r\n    #textFlex1 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 主轴对齐方式justify-content:flex-end 右对齐\r\n<div id=\"textFlex2\">\r\n    <div>flex-end</div>\r\n    <div>flex-end</div>\r\n    <div>flex-end</div>\r\n    <div>flex-end</div>\r\n</div>\r\n<style>\r\n    #textFlex2{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:flex-end;\r\n    }\r\n    #textFlex2 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n* 主轴对齐方式justify-content:flex-center 弹性盒子居中 两边留白\r\n<div id=\"textFlex3\">\r\n    <div>center</div>\r\n    <div>center</div>\r\n    <div>center</div>\r\n    <div>center</div>\r\n</div>\r\n<style>\r\n    #textFlex3{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:center;\r\n    }\r\n    #textFlex3 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 主轴对齐方式justify-content:flex-around 弹性盒子的周围留白\r\n<div id=\"textFlex4\">\r\n    <div>space-around</div>\r\n    <div>space-around</div>\r\n    <div>space-around</div>\r\n    <div>space-around</div>\r\n</div>\r\n<style>\r\n    #textFlex4{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-around;\r\n    }\r\n    #textFlex4 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 主轴对齐方式justify-content:flex-between 弹性盒子的之间留白\r\n<div id=\"textFlex5\">\r\n    <div>space-between</div>\r\n    <div>space-between</div>\r\n    <div>space-between</div>\r\n    <div>space-between</div>\r\n</div>\r\n<style>\r\n    #textFlex5{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-between;\r\n    }\r\n    #textFlex5 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 主轴对齐方式justify-content:flex-evenly 弹性盒子的之间和两边留相同宽度的白\r\n<div id=\"textFlex6\">\r\n    <div>space-evenly</div>\r\n    <div>space-evenly</div>\r\n    <div>space-evenly</div>\r\n    <div>space-evenly</div>\r\n</div>\r\n<style>\r\n    #textFlex6{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n    }\r\n    #textFlex6 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n### 侧轴对齐方式\r\n* 属性名align-items **添加给弹性容器**，控制**所有**盒子的侧轴对齐方式\r\n* 属性名align-self **添加给弹性盒子**,控制**单个**盒子的侧轴对齐方式\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-04-31-31.png)\r\n* **当主轴方向为默认方向时，`align-self`控制垂直方向对齐方式**\r\n\r\n#### 侧轴对齐方式测试\r\n* 侧轴对齐方式`align-items:flex-start` 弹性盒子的顶对齐\r\n<div id=\"textFlex7\">\r\n    <div>space-start</div>\r\n    <div>space-start</div>\r\n    <div>space-start</div>\r\n    <div>space-start</div>\r\n</div>\r\n<style>\r\n    #textFlex7{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items: flex-start;\r\n        height: 150px;\r\n    }\r\n    #textFlex7 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n* 侧轴对齐方式 `align-items:flex-end` 弹性盒子的底对齐\r\n<div id=\"textFlex8\">\r\n    <div>space-end</div>\r\n    <div>space-end</div>\r\n    <div>space-end</div>\r\n    <div>space-end</div>\r\n</div>\r\n<style>\r\n    #textFlex8{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items: flex-end;\r\n        height: 150px;\r\n    }\r\n    #textFlex8 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 侧轴对齐方式`align-items:center` 弹性盒子垂直居中对齐\r\n<div id=\"textFlex9\">\r\n    <div>space-center</div>\r\n    <div>space-center</div>\r\n    <div>space-center</div>\r\n    <div>space-center</div>\r\n</div>\r\n<style>\r\n    #textFlex9{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items:center;\r\n        height: 150px;\r\n    }\r\n    #textFlex9 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 侧轴对齐方式`align-items:stretch` 弹性盒子**没有高度时**，将被拉长至铺满高度\r\n<div id=\"textFlex10\">\r\n    <div>space-stretch</div>\r\n    <div>space-stretch</div>\r\n    <div>space-stretch</div>\r\n    <div>space-stretch</div>\r\n</div>\r\n<style>\r\n    #textFlex10{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items:stretch;\r\n        height: 150px;\r\n    }\r\n    #textFlex10 div{\r\n        width: 100px;\r\n        /* height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n#### 控制单个盒子的侧轴对齐方式\r\n<div id=\"textFlex11\">\r\n    <div>space-center</div>\r\n    <div style=\"align-self:flex-end;\">flex-end</div>\r\n    <div>space-center</div>\r\n    <div>space-center</div>\r\n</div>\r\n<style>\r\n    #textFlex11{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items:center;\r\n        height: 150px;\r\n    }\r\n    #textFlex11 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n\r\n### flex伸缩比\r\n* 语法格式: `flex:数值;`\r\n* 表示占用父盒子的剩余尺寸的份数\r\n<div id=\"textFlex12\">\r\n    <div>宽50px</div>\r\n    <div>不指定宽，靠内容撑开</div>\r\n    <div>flex: 2;剩余部分的2份</div>\r\n    <div>flex: 4;剩余部分的4份</div>\r\n</div>\r\n<style>\r\n    #textFlex12{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items:center;\r\n        height: 150px;\r\n    }\r\n    #textFlex12 div{\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n    #textFlex12 div:nth-child(1){\r\n        width: 80px;\r\n    }\r\n    #textFlex12 div:nth-child(2){\r\n        /* 不指定宽 */\r\n    }\r\n    #textFlex12 div:nth-child(3){\r\n        flex: 2;\r\n    }\r\n    #textFlex12 div:nth-child(4){\r\n        flex: 4;\r\n    }\r\n</style>\r\n\r\n### 修改主轴方向\r\n* 作用：修改主轴方向，实现子元素垂直排列\r\n* 属性名：`flex-direction`\r\n* 属性值：\r\n    ![](./images/移动端布局及Flex布局模型/2022-06-20-06-54-01.png)\r\n* 主轴修改为垂直方向后，水平方向的轴就是侧轴\r\n\r\n#### 修改主轴方向后修改主轴的对齐方式\r\n* 主轴修改为垂直方向后，想要控制主轴（垂直方向）的对齐方式依然使用`justify-content`属性\r\n* 主轴修改为垂直方向后，想要控制侧轴（水平方向）的对齐方式依然使用`align-items`属性\r\n\r\n#### 使用示例\r\n<div id=\"textFlex13\">\r\n    <div>justify-content:flex-start</div>\r\n    <div>justify-content:flex-start</div>\r\n    <div>justify-content:flex-start</div>\r\n</div>\r\n<style>\r\n    #textFlex13{\r\n        display: flex;\r\n        flex-direction: column;\r\n        height: 300px;\r\n        background-color:gray;\r\n        justify-content: flex-start;\r\n    }\r\n    #textFlex13 div{\r\n        /* width: 300px; */\r\n        height: 50px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n<br>\r\n<div id=\"textFlex14\">\r\n    <div>justify-content:space-around; align-items:center;</div>\r\n    <div>justify-content:space-around; align-items:center;</div>\r\n    <div>justify-content:space-around; align-items:center;</div>\r\n</div>\r\n<style>\r\n    #textFlex14{\r\n        display: flex;\r\n        flex-direction: column;\r\n        height: 300px;\r\n        background-color:gray;\r\n        justify-content:space-around;\r\n        align-items:center;\r\n    }\r\n    #textFlex14 div{\r\n        /* width: 300px; */\r\n        height: 50px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n### 弹性盒子的换行\r\n* 默认情况下，当**弹性容器**的一行之内不能容纳下所有**弹性盒子**时，弹性盒子的**宽**会**缩小**\r\n* 使用`flex-wrap`属性可以实现弹性盒子的换行排列效果\r\n* 取值：\r\n    * `no-wrap` 默认值\r\n        * 弹性盒子会受到挤压，设定的宽度会失效\r\n        * ![](./images/移动端布局及Flex布局模型/2022-06-20-08-10-02.png)\r\n    * `wrap` 换行 \r\n        * 弹性盒子的尺寸不会受到挤压，会在弹性容器容纳不下时换行\r\n        * ![](./images/移动端布局及Flex布局模型/2022-06-20-08-09-01.png)\r\n            * 水平方向末尾留下了多余空间因为justify-content（主轴方向对齐方式）默认值是justify-content:flex-start）\r\n            * 垂直方向行间留下了多余空间 这是因为align-content(侧轴方向对齐方式)默认值的影响）\r\n\r\n\r\n### 弹性盒子的侧轴对齐方式\r\n* 属性名`align-content`\r\n* 属性值：和主轴对齐方式`justify-content`的取值几乎一致（没有`space-evenly`）\r\n* 默认情况下，弹性盒子是不换行的，所以设置侧轴对齐方式会看不到效果，要先设置`flex-wrap:wrap;`属性后才能看到效果\r\n\r\n#### 效果测试\r\n<div id=\"textFlex15\">\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n</div>\r\n<style>\r\n    #textFlex15{\r\n        display: flex;\r\n        flex-wrap:wrap;\r\n        justify-content:center;\r\n        align-content:center;\r\n        /* justify-items: center; */\r\n        /* align-items: center; */\r\n        /* height: 300px; */\r\n        /* width: 300px; */\r\n        background-color:gray;\r\n        align-items:center;\r\n    }\r\n    #textFlex15 div{\r\n        width: 50px;\r\n        height: 50px;\r\n        margin:5px;\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n#### 问题\r\n* 如何处理最后一行不能左对齐的问题？\r\n![](./images/移动端布局及Flex布局模型/2022-06-20-08-58-31.png)\r\n\r\n\r\n"},{"shortInfo":{"title":"移动适配","date":"2022-06-20T22:35:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["移动适配","CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":724366393,"countWords":908,"readSeconds":90.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动适配\r\n\r\n## 目录\r\n- [移动适配](#移动适配)\r\n  - [目录](#目录)\r\n  - [概述](#概述)\r\n  - [rem](#rem)\r\n    - [媒体查询](#媒体查询)\r\n    - [根标签字号的取值](#根标签字号的取值)\r\n    - [元素宽高取值的确定](#元素宽高取值的确定)\r\n    - [使用步骤](#使用步骤)\r\n    - [flexiblejs适配所有移动端视口宽度的解决方案](#flexiblejs适配所有移动端视口宽度的解决方案)\r\n  - [vwvh](#vwvh)\r\n    - [计算示例](#计算示例)\r\n    - [元素宽高取值的确定](#元素宽高取值的确定-1)\r\n\r\n\r\n## 概述\r\n传统的像素单位和百分比布局都存在一定的问题，像素单位会把元素的尺寸写死，在pc端多少像素，移动端也是多少像素，百分比布局虽然可以根据设备屏幕的宽度实现宽度的自适应，但是其高度仍然必须指定一个像素，不能做到同时自适应改变宽和高以适配不同机型的屏幕  \r\n\r\n**移动适配就是让网页根据不同机型的屏幕宽度，自适应的改变网页中元素的宽高、边距、字号大小**\r\n\r\n![](./images/移动适配/2022-06-21-06-42-08.png)\r\n\r\n* 两种解决方案\r\n    * `rem`:目前多数企业(小米)在使用的解决方法\r\n    * `vw/vh`:未来的解决方案,大厂(bilibili、天猫)已经开始使用\r\n\r\n## rem\r\n* rem是一个相对单位\r\n* rem是相对于根标签(HTML标签)的字号计算的\r\n* 1rem=1HTML字号大小\r\n\r\n\r\n\r\n### 媒体查询\r\n* 媒体查询能够检测视口的宽度，然后编写差异化的css样式\r\n* 写法\r\n    ```css\r\n    @media (媒体特征){\r\n        选择器{\r\n            css属性;\r\n        }\r\n    }\r\n    ```\r\n\r\n### 根标签字号的取值\r\n实现移动适配的关键在于如何给根标签的字号取一个合适的值,要实现这一点需要用到的技术就是**媒体查询**\r\n目前rem布局方案中，根标签的字号一般取视口宽度的$\\frac{1}{10}$\r\n* 示例\r\n    ```css\r\n    @media (width:414px){\r\n        html{\r\n            font-size:41.4px;\r\n        }\r\n    }\r\n    @media (width:375px){\r\n        html{\r\n            font-size:37.5px;\r\n        }\r\n    }\r\n    ```\r\n\r\n### 元素宽高取值的确定\r\n假设设计稿是根据iPhone6/7/8的视口宽度365px设计的，第一步应该是计算并设置根标签的字号大小`html{font-size:36.5px;}`,然后假设测量某元素的宽高是63px，42px，那么其宽就应该是$\\frac{63}{36.5}=1.726rem$;高就应该是$\\frac{42}{36.5}=1.150rem$;\r\n\r\n* 宽高的自动计算可以使用less插件\r\n\r\n### 使用步骤\r\n* 先给html标签设置字号\r\n    ```css\r\n    @media (width:375px){\r\n        html{\r\n            font-size:37.5px;\r\n        }\r\n    }\r\n    @media (width:414px){\r\n        html{\r\n            font-size:41.4px;\r\n        }\r\n    }\r\n    @media (width:375px){\r\n        html{\r\n            font-size:37.5px;\r\n        }\r\n    }\r\n    ```\r\n* 盒子宽高使用为rem单位\r\n    ```css\r\n    .box{\r\n        width:5rem;\r\n        height:5rem;\r\n        background-color:green;\r\n    }\r\n    ```\r\n\r\n### flexiblejs适配所有移动端视口宽度的解决方案\r\n* **flexible.js**是手机淘宝开发出的解决方案\r\n* 原理就是根据不同的视口宽度自动修改根标签字号大小\r\n* 一般把这个js放在body的结束标签位置之前\r\n\r\n\r\n\r\n## vwvh\r\n* vw/vh是一个相对单位\r\n* 相对视口的尺寸计算\r\n* **vw(viewport width)** **1vw=$\\frac{1}{100}$视口宽度**\r\n* **vh(viewport height)** **1vh=$\\frac{1}{100}$视口高度**\r\n* 一般对一个盒子，指定其宽高时，不同时使用vm vh单位，否则根据竖屏设计的网页，到了宽屏就会比例失调\r\n  \r\n### 计算示例\r\n### 元素宽高取值的确定\r\n假设设计稿是根据iPhone6/7/8的视口宽度365px设计的，假设测量某元素的宽高是63px，42px，那么其宽就应该是`63/3.65vw` 高就应该是`42/3.65vw`"},{"shortInfo":{"layout":"post","cover":"\\self_server\\assets\\images\\default_cover2.jpg","title":"移动适配项目实战","date":"2022-06-21T15:57:00.000Z","tags":["网站","demo"],"hideAtIndex":true,"categories":"前端","id":1517921192,"countWords":66,"readSeconds":6.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动适配项目实战\r\n\r\n## Demos\r\n* [-->rem单位的使用(移动端游乐园网页实例)<--](./demos/移动适配项目实战/youleyuan/)\r\n* [-->vw单位的使用(移动端bilibili网页仿照实现)<--](./demos/移动适配项目实战/m-bilibili/)\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"layout":"post","title":"记录本网站的搭建过程(旧版)","subtitle":"第一篇技术博客","date":"2021-12-27T13:45:00.000Z","cover":"\\self_server\\assets\\images\\timePencil.jpg","tags":["技术博客","网站搭建"],"hideAtIndex":true,"categories":"笔记","id":2003849237,"countWords":446,"readSeconds":44.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 本网站搭建\r\n### 一、创建github仓库\r\n1. 仓库名前缀要和GitHub用户名同名，不区分大小写。\r\n    >用户名如为:YiguiDing,仓库名则为：YiguiDing.github.io\r\n2. 该仓库需为公开仓库。\r\n\r\n### 二、本地仓库的初始化和提交到远程仓库\r\n0. 下载安装git。`略`\r\n   + git配置过程省略\r\n1. 使用git命令初始化本地仓库`git init`\r\n2. 或使用克隆命令直接克隆本网站`git clone https://github.com/YiguiDing/YiguiDing.github.io.git`\r\n3. 为远程仓库添加别名 `git remote add origin https://github.com/你的用户名/你的仓库名.git`\r\n4. 将本地仓库提交到你的GitHub `git push origin master`\r\n\r\n### 三、本地测试环境的搭建与测试\r\n* 在win10中安装`Ubuntu20.04 LTS`子系统\r\n    + 若干步骤省略\r\n* 安装ruby2.7和ruby2.7-dev\r\n    + `apt search ruby2.7`\r\n    + `apt install ruby2.7 ruby2.7-dev`\r\n    + 这里用2.7是为了和github保持一致,详情查看[GitHub PagesDependency versions](https://pages.github.com/versions/)\r\n* 用ruby的gem安装bundler\r\n\t+ `gem install bundler`\r\n* 创建Gemfile文件安装jekyll3.9\r\n    + \r\n        ```shell\r\n        cat >Gemfile<<\"EOF\"\r\n        source \"https://rubygems.org\"\r\n        gem \"jekyll\", \"~> 3.9.0\"\r\n        EOF\r\n        ```\r\n    + `apt install make gcc` //没有这一步下一步会报错\r\n    + `bundler install`\r\n* 安装网站所需运行环境 即/YiguiDing.github.io/Gemfile中所描述依赖\r\n    + `cd YiguiDing.github.io`\r\n    + `apt install g++`     //下一步的编译安装过程中需要用到g++\r\n    + `bundler install`\r\n* 本机访问\r\n  * `bundle exec jekyll serve -w --host=127.0.0.1 --livereload --port=80`\r\n  * 其中\r\n    * `--livereload`表示动态加载页面，即当页面文件改动后，静态页面将会重新生成\r\n    * `--host=127.0.0.1`表示指定ip地址，此时为仅本机访问，若要局域网内部访问，则指定为`--host=0.0.0.0`或`--host=本机局域网Ip`\r\n    * `--port=80`表示指定端口，默认为4000"},{"shortInfo":{"title":"记录用Vue3写的新博客站点","date":"2022-10-17T17:24:00.000Z","cover":"\\self_server\\assets\\images\\记录用vue3写的新博客站点\\IMG_5251.PNG","tags":["vue3","blog","demo"],"categories":"笔记","imageMin":true,"id":3132888776,"countWords":202,"readSeconds":20.2,"assetsbaseUrl":"/self_server/assets/"},"content":"## 实现效果记录\r\n\r\n![](./images/记录用vue3写的新博客站点/IMG_5250.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5251.PNG)\r\n\r\n\r\n![](./images/记录用vue3写的新博客站点/IMG_5242.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5243.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5244.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5245.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5246.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5247.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5248.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5249.PNG)\r\n\r\n![](./images/记录用vue3写的新博客站点/IMG_5252.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5253.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5254.PNG)\r\n![](./images/记录用vue3写的新博客站点/IMG_5255.PNG)"}]