[{"shortInfo":{"title":"Ajax学习笔记","date":"2022-08-26T15:42:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["Ajax","前端"],"categories":"笔记","hideAtIndex":true,"id":4042505685,"countWords":3752,"readSeconds":375.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# Ajax学习笔记\r\n\r\n## 目录\r\n- [Ajax学习笔记](#ajax学习笔记)\r\n  - [目录](#目录)\r\n  - [尝试封装AJAX](#尝试封装ajax)\r\n  - [HTTP协议](#http协议)\r\n    - [请求报文格式](#请求报文格式)\r\n    - [响应报文格式](#响应报文格式)\r\n  - [AJAX](#ajax)\r\n    - [XMLHttpRequest对象](#xmlhttprequest对象)\r\n    - [核心API](#核心api)\r\n  - [通过express框架启动一个后端服务](#通过express框架启动一个后端服务)\r\n  - [ajax请求基本流程_demo1](#ajax请求基本流程_demo1)\r\n  - [GET请求中通过URL传递参数_demo2](#get请求中通过url传递参数_demo2)\r\n    - [方法1](#方法1)\r\n    - [方法2](#方法2)\r\n  - [POST请求中通过传递参数_demo3](#post请求中通过传递参数_demo3)\r\n    - [解析发送的文本](#解析发送的文本)\r\n    - [解析url格式数据(a=123&b=321)](#解析url格式数据a123b321)\r\n  - [ajax设置请求头](#ajax设置请求头)\r\n  - [ajax设置响应体数据类型](#ajax设置响应体数据类型)\r\n  - [nodemon](#nodemon)\r\n  - [ie缓存问题的解决](#ie缓存问题的解决)\r\n  - [处理超时和网络异常](#处理超时和网络异常)\r\n  - [中途手动取消请求](#中途手动取消请求)\r\n  - [防止用户多次点击导致频繁发送相同请求](#防止用户多次点击导致频繁发送相同请求)\r\n  - [jquery中的ajax](#jquery中的ajax)\r\n  - [ajax工具库:axios](#ajax工具库axios)\r\n  - [window.fetch()原生ajax接口](#windowfetch原生ajax接口)\r\n\r\n\r\n## 尝试封装AJAX\r\n```js\r\nfunction Ajax(method,url,headers,data,callBack){\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open(method,url,true);\r\n    for(keyName in headers){\r\n        xhr.response.setRequestHeader(keyName,headers[keyName]);\r\n    }\r\n    xhr.send(data);\r\n    xhr.onreadystatechange = function(){\r\n        if(xhr.readyState==4){\r\n            if(xhr.status>=200 && xhr.status<300){\r\n                callBack(xhr.response);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nAjax(\"GET\",\"http://127.0.0.1:8000/demo1\",null,null,result=>{\r\n    console.log(\"接受到的响应体内容为：\"+result);\r\n})\r\n```\r\n**测试**\r\n\r\n![图 13](./images/Ajax学习笔记/945373296dffc7f9789eeb8c525ad63633da961a5eab5363d36541742d684a7c.png)  \r\n\r\n\r\n## HTTP协议\r\nHTTP(**H**yper **T**ext **T**ransport **P**rotocol),超文本传输协议,请求-响应协议,通常运行在TCP上\r\n\r\n### 请求报文格式\r\n\r\n1. 请求行\r\n   * **请求方法**+**空格**+**URL**+**空格**+**协议版本**+**回车换行(CRLF)**\r\n   * 示例:\r\n      ```\r\n      GET /index.html HTTP/1.1\\r\\n\r\n      ```\r\n2. 请求头\r\n   * **键名**+**冒号**+**空格**+**键值**+**回车换行**\r\n   * 示例:\r\n      ```\r\n      host:baidu.com\\r\\n\r\n      user-Agent:chrome\\r\\n\r\n      ```\r\n\r\n3. 空行(CRLF)\r\n   * `CR`: `Carriage Return`,回车符号,`0x0d`,`\\r`\r\n   * `LF`: `Line Feed`,换行符,`0x0a`,`\\n`\r\n   * 示例:\r\n        ```\r\n        \\r\\n\r\n        ```\r\n4. 报文主体\r\n   * 数据部分\r\n   * 示例:\r\n        ```\r\n        hello world!\r\n        ```\r\n\r\n**完整示例**\r\n```\r\nGET /index.html HTTP/1.1\r\nhost: baidu.com\r\nuser-Agent: chrome\r\n\r\nhello world!\r\n```\r\n\r\n![图 7](./images/Ajax学习笔记/9e9779c97ad0448a3deae16470deb3e75aa96fdc763ec4e298b1f12ae3e6667f.png)  \r\n\r\n\r\n\r\n### 响应报文格式\r\n1. 响应行\r\n   * **协议版本**+空格+**状态码**+空格+**状态字符串**+回车换行(CRLF)\r\n   * 示例:\r\n        ```\r\n        HTTP/1.1 200 OK\\r\\n\r\n        ```\r\n2. 响应头\r\n   * **键名**+**冒号**+**空格**+**键值**+回车换行\r\n   * 示例:\r\n        ```\r\n        host:baidu.com\\r\\n\r\n        user-Agent:chrome\\r\\n\r\n        ```\r\n\r\n3. 空行(CRLF)\r\n   * `CR`: `Carriage Return`,回车符号,`0x0d`,`\\r`\r\n   * `LF`: `Line Feed`,换行符,`0x0a`,`\\n`\r\n   * 示例:\r\n        ```\r\n        \\r\\n\r\n        ```\r\n4. 报文主体\r\n   * 数据部分\r\n   * 示例:\r\n        ```\r\n        hello world!\r\n        ```\r\n\r\n\r\n**完整示例**\r\n```\r\nHTTP/1.1 200 OK\r\nhost: baidu.com\r\nuser-Agent: chrome\r\n\r\n<html>\r\n   <head>\r\n   </head>\r\n   <body>\r\n        hello world!\r\n   </body>\r\n</html>\r\n```\r\n\r\n![图 6](./images/Ajax学习笔记/7e6ba87309410398b0889fc2d15a82345d154c6abc5d202f6c986440b20aafb2.png)  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## AJAX\r\n**Ajax**即`Asynchronous Javascript And XML`（异步JavaScript和XML）\r\n\r\n### XMLHttpRequest对象\r\n\r\n使用 JavaScript 向服务器提出请求并处理响应而不阻塞用户核心对象是**XMLHttpRequest**。\r\n通过这个对象， JavaScript 可在不重载页面的情况与 Web 服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。\r\n\r\n\r\n[完整API: https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)\r\n\r\n### 核心API\r\n* `xhr=new XMLHttpRequest();` 创建 XMLHttpRequest 对象\r\n* `xhr.open(method,url,async)`  规定请求的类型、URL 以及是否异步处理请求。\r\n    * **method** ： 请求的类型；GET 或 POST\r\n    * **url** ： 文件在服务器上的位置\r\n    * **async** ： true（用于**异步**的**AJAX**）或 false（同步）\r\n* `setRequestHeader(header,value)` 向请求添加 HTTP 头。\r\n    * **header** : 规定头的名称\r\n    * **value** : 规定头的值\r\n* `xhr.send(string)` 将请求发送到服务器。\r\n  * **string** ： 仅用于 POST 请求\r\n* `xhr.readyState` 存有 **XMLHttpRequest** 的状态。从 0 到 4 发生变化。\r\n    * **0**: 请求未初始化\r\n    * **1**: 服务器连接已建立\r\n    * **2**: 请求已接收\r\n    * **3**: 请求处理中\r\n    * **4**: 请求已完成，且响应已就绪\r\n* `xhr.status` 响应报文的状态码\r\n  * **2XX**: 成功\r\n  * **4XX**: 失败\r\n* `xhr.onreadystatechange=function(){}`  每当 readyState 属性改变时，就会调用该函数。\r\n  *  onreadystatechange 事件被触发 4 次（0 - 4）, 分别是： 0-1、1-2、2-3、3-4，对应着 readyState 的每个变化。\r\n\r\n## 通过express框架启动一个后端服务\r\n\r\n**安装node,npm express**\r\n```\r\n# 安装nodejs npm\r\napt-get install nodejs npm\r\n# 初始化\r\nnpm init --yes\r\n# 安装express\r\nnpm install express\r\n# 编辑testExpress.js\r\n# 执行testExpress.js\r\nnode testExpress.js\r\n```\r\n\r\n\r\n**testExpress.js**\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.get(\"/\",(request,response)=>{\r\n    //设置响应\r\n    response.send(\"Hello Express!!\");\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n## ajax请求基本流程_demo1\r\n**效果**\r\n![图 8](./images/Ajax学习笔记/c80dd76911ec613aedcb083ac3297b459df84dfdfa67fd602aa2a5b614906e01.png)  \r\n\r\n**前端代码**\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        #result1{\r\n            width: 200px;\r\n            height: 100px;\r\n            border: 1px solid black;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <button id=\"btn1\">点击发送请求</button>\r\n    <div id=\"result1\"></div>\r\n    <script>\r\n        var btn1 = document.getElementById(\"btn1\")\r\n        var result1 = document.getElementById(\"result1\")\r\n        btn1.onclick=function(){\r\n            //ajax部分\r\n            //1. 创建xhr对象\r\n            const xhr = new XMLHttpRequest();\r\n            //2. 初始化:设置请求方法和url\r\n            xhr.open(\"GET\",\"http://127.0.0.1:8000/demo1\")\r\n            //3. 发送\r\n            xhr.send();\r\n            //4. 事件绑定:绑定处理返回结果的函数\r\n            xhr.onreadystatechange = function(){\r\n                // 4.1 判断readyState状态\r\n                if(xhr.readyState==4){\r\n                    //onreadystatechange事件会在readyState值改变后触发\r\n                    //xhr.readyState\r\n                        // 0 初始值 \r\n                        // 1 open方法调用完毕 \r\n                        // 2 send方法调用完毕 \r\n                        // 3 接收到服务端返回的部分结果 \r\n                        // 4 接收到服务端返回的所有结果\r\n\r\n                        //4.2 判断响应报文头状态码\r\n                        if(xhr.status>=200 && xhr.status<300){\r\n                            //xhr.status\r\n                                // 2xx 成功\r\n                                // 4xx 失败\r\n                                // 5xx\r\n                            //获取响应头的数据\r\n                            console.log(xhr.status);//状态码 \r\n                            console.log(xhr.statusText);//状态字符串 \r\n                            console.log(xhr.getAllResponseHeaders());//所有响应头\r\n                            console.log(xhr.response);//响应体 \r\n                            //将响应体内容写入页面\r\n                            result1.innerHTML=xhr.response;\r\n                        }\r\n                }\r\n            }\r\n        }\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n**后端代码**\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.get(\"/demo1\",(request,response)=>{\r\n    //设置响应头\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");//允许跨域,若没有,则当以文件方式打开前端页面或访问前端页面的域名或端口与服务端不一致时,响应报文会被浏览器拦截\r\n    //设置响应体\r\n    response.send(\"Hello Express!!\");\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n## GET请求中通过URL传递参数_demo2\r\n\r\n### 方法1\r\n**效果**\r\n![图 10](./images/Ajax学习笔记/5799fdd3638eeafab6bd0e8e64bb485e8591fa5169403576c7667c0355e92552.png)  \r\n\r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"GET\",\"http://127.0.0.1:8000/demo2?a=1&b=2&c=3\")\r\n```\r\n\r\n**后端关键代码**\r\n```js\r\napp.get(\"/demo2\",(request,response)=>{\r\n    response.send(request.query);//request.query 中存放着传递过来的键值对\r\n})\r\n```\r\n\r\n### 方法2\r\n**效果**\r\n![图 9](./images/Ajax学习笔记/a46234cd8cc372a024311518512f464cf9f55890f682bf289fd65fd6ceae0bc7.png)  \r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"GET\",\"http://127.0.0.1:8000/demo2/1/2/3\")\r\n```\r\n\r\n**后端关键代码**\r\n```js\r\napp.get(\"/demo2/:a/:b/:c\",(request,response)=>{\r\n    response.send(request.params);//request.params 中存放着传递过来的键值对\r\n})\r\n```\r\n\r\n\r\n## POST请求中通过传递参数_demo3\r\n\r\n### 解析发送的文本\r\n![图 12](./images/Ajax学习笔记/a8a5ba527782e970517f95f4fdac198f1bf20d571463bf6e923ce8732e8fabd6.png)  \r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"POST\",\"http://127.0.0.1:8000/demo3\")\r\nxhr.send(\"hello server\")\r\n```\r\n\r\n**后端关键代码**\r\n```js\r\n//引入中间件,用于获取request.body内容\r\nconst bodyParser = require('body-parser');\r\n// 解析 text\r\napp.use(bodyParser.text());\r\n\r\n//创建路由\r\napp.post(\"/demo3\",(request,response)=>{\r\n    //设置响应头\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");\r\n    //设置响应体\r\n    response.send(\"你发送的数据是:\" + request.body);\r\n})\r\n```\r\n\r\n### 解析url格式数据(a=123&b=321)\r\n![图 11](./images/Ajax学习笔记/ec47983f998ddd778f3a164385b3509c609b73a02e5a34b4dfd32228a35bd5ad.png)  \r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"POST\",\"http://127.0.0.1:8000/demo3\")\r\n//设置请求头\r\nxhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\")\r\nxhr.send(\"a=123&b=321\")\r\n```\r\n**后端关键代码**\r\n```js\r\n//引入中间件,用于获取request.body内容\r\nconst bodyParser = require('body-parser');\r\n// 解析 application/x-www-form-urlencoded //也就是解析a=1&b=2 这种url格式的数据\r\napp.use(bodyParser.urlencoded({ extended: false })) \r\n        // extended: false 方法内部使用querystring模块处理请求参数的格式\r\n        // extended: true 方法内部使用第三方模块qs模块请求参数的格式\r\n\r\n//创建路由\r\napp.post(\"/demo3\",(request,response)=>{\r\n    //设置响应头\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");//允许跨域\r\n    //设置响应体\r\n    response.send(\"你发送的数据是:\" + JSON.stringify(request.body));\r\n})\r\n```\r\n\r\n\r\n## ajax设置请求头\r\n* `xhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\")`// for A=123&B=321\r\n* `xhr.setRequestHeader(\"Name\",\"dyg\")`// **自定义请求头**\r\n    * `response.setHeader(\"Access-Control-Allow-Headers\",\"*\")` 发送带有自定义请求头的请求需要在服务端设置响应头为允许自定义响应头 \r\n    * 发送带有自定义请求头的请求报文时,会先发送一个`OPTIONS`类型的请求验证自定义请求头是否可用,服务器需要\r\n需要处理该`OPTIONS`类型的请求\r\n\r\n\r\n## ajax设置响应体数据类型\r\n\r\n**手动数据类型转换**\r\n* `jsOBJ = JSON.parse(xhr.response) ` 实现手动数据类型转换 `string->obj`\r\n\r\n**自动数据类型转换**\r\n* `xhr.responseType = \"json\"` 实现自动数据类型转换 一般写在`xhr`对象创建之后\r\n\r\n\r\n## nodemon\r\n**用于实现服务端代码改变后自动重启**\r\n\r\n```bash\r\nnpm i nodemon -g\r\n```\r\n\r\n## ie缓存问题的解决\r\nie浏览器会将相同地址的服务端响应报文存入缓存,在第二次客户端发送同样的请求时,ie浏览器会将缓存中的数据作为第二次的响应报文,带来的问题是不能获取服务端相同地址上的最新数据.\r\n\r\n**前端关键代码**\r\n```js\r\nxhr.open(\"POST\",\"http://127.0.0.1:8000/demo3&date=\"+Date.now() )\r\n```\r\n\r\n\r\n## 处理超时和网络异常\r\n```js\r\nconst xhr = new XMLHttpRequest();\r\n//当请求超时后,会将请求的status状态由pending改为canceled\r\nxhr.timeout =  2000;\r\n// 设置超时的回调函数\r\nxhr.ontimeout = function(){\r\n    alert(\"网络超时,请稍后重试\")\r\n}\r\nxhr.onterror = function(){//网络异常时status状态为failed\r\n    alert(\"网络异常,请稍后重试\")\r\n}\r\nxhr.open(\"GET\",\"http://127.0.0.1:8000/demo1\")\r\n\r\n```\r\n\r\n\r\n## 中途手动取消请求\r\n\r\n**取消请求**\r\n```js\r\nxhr.abort   ();\r\n```\r\n\r\n\r\n**客户端**\r\n```html\r\n  <button id=\"btn4_1\">点击发送请求</button>\r\n  <button id=\"btn4_2\">点击取消请求</button>\r\n  <script>\r\n      var btn4_1 = document.getElementById(\"btn4_1\")\r\n      var btn4_2 = document.getElementById(\"btn4_2\")\r\n      let xhr = null;\r\n      btn4_1.onclick=function(){\r\n          xhr = new XMLHttpRequest();\r\n          xhr.open(\"POST\",\"http://127.0.0.1:8000/demo4\")\r\n          xhr.send(\"hello server\");\r\n      }\r\n      btn4_2.onclick = function(){\r\n          xhr.abort();\r\n      }\r\n  </script>\r\n```\r\n\r\n**服务端**\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.post(\"/demo4\",(request,response)=>{\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");\r\n    setTimeout(()=>{\r\n        response.send(\"你发送的数据是:\" + request.body);\r\n    },3000)\r\n\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n## 防止用户多次点击导致频繁发送相同请求\r\n\r\n\r\n![图 1](./images/Ajax学习笔记/faa475ec71e77bd72eb7aa7ee2390631b37b70329f1a081519f6aed8e3f9b3e4.png)  \r\n\r\n**客户端**\r\n```html\r\n  <button id=\"btn5\">点击发送请求</button>\r\n  <script>\r\n      var btn5 = document.getElementById(\"btn5\")\r\n      btn5.onclick=function(){\r\n          var self = this\r\n          if(self.isSending == true)//判断是否正在发送请求\r\n          {\r\n              self.xhr.abort();//取消正在发送的请求\r\n          }\r\n          self.xhr = new XMLHttpRequest();\r\n          self.isSending = true;//创建标志为,记录为正在发送请求\r\n          self.xhr.open(\"POST\",\"http://127.0.0.1:8000/demo5\")\r\n          self.xhr.send(\"hello server\");\r\n          self.xhr.onreadystatechange = function(){\r\n              if(self.xhr.readyState==4){\r\n                  self.isSending = false;//改变标志位\r\n              }\r\n          }\r\n      }\r\n  </script>\r\n```\r\n\r\n**服务端**\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.post(\"/demo5\",(request,response)=>{\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");//允许跨域,若没有,则当以文件方式打开前端页面或访问前端页面的域名或端口与服务端不一致时,响应报文会被浏览器拦截\r\n    setTimeout(()=>{\r\n        response.send(\"你发送的数据是:\" + request.body);\r\n    },3000)\r\n\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n## jquery中的ajax\r\n* `$.get(url,{a:1,b:2},function(data){},\"json\")`\r\n* `$.post(url,{a:1,b:2},function(data){},\"json\")`\r\n\r\n```html\r\n    <!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n    <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n    <button id=\"btn6-1\">点击发送GET请求</button>\r\n    <button id=\"btn6-2\">点击发送POST请求</button>\r\n    <button id=\"btn6-3\">通用方法</button>\r\n    <script>\r\n        $(\"#btn6-1\").click(function(){\r\n            // $.get(url,data,function(data){\r\n            $.get(\"http://127.0.0.1:8000/demo6\",{a:1,b:2},function(data){\r\n                console.log(data)\r\n            })\r\n        })\r\n        $(\"#btn6-2\").click(function(){\r\n            $.post(\"http://127.0.0.1:8000/demo6\",{a:1,b:2},function(data){\r\n                console.log(data)\r\n            })\r\n        })\r\n        $(\"#btn6-3\").click(function(){\r\n            $.ajax({\r\n                type: \"GET\",\r\n                url: \"http://127.0.0.1:8000/demo6\",\r\n                headers: {\r\n                    a:100,\r\n                    b:200,\r\n                },\r\n                data: {a:1,b:2},\r\n                dataType: \"json\",//可将字符串类型的data自动转换为json\r\n                success: function(data){ console.log(data) },\r\n                timeout: 2000,\r\n                error: function(){ console.log(\"出错了\") },//超时或网络异常的错误回调函数\r\n            })\r\n        })\r\n```\r\n\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.all(\"/demo6\",(request,response)=>{\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");\r\n    response.setHeader(\"access-control-allow-headers\",\"*\");\r\n    response.send(\"hello client\");\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n## ajax工具库:axios\r\n**get**\r\n```js\r\naxios.get('http://127.0.0.1:8000/demo7',{\r\n    params: {\r\n        name:\"DingYigui\",\r\n        id:123\r\n    },\r\n    headers:{\r\n        test:321\r\n    }\r\n})\r\n.then(function (response) {\r\n    console.log(response);\r\n})\r\n.catch(function (error) {\r\n    console.log(error);\r\n})\r\n.then(function () {\r\n    // always executed\r\n});\r\n```\r\n\r\n**post**\r\n```html\r\n<!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n<script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n<!-- axios 库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n<script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n<button id=\"btn7-1\">点击使用axios(config)发送请求</button>\r\n<button id=\"btn7-2\">点击使用axios.get(url[, config])发送请求</button>\r\n<button id=\"btn7-3\">点击使用axios.post(url[, data[, config]])发送请求</button>\r\n<script>\r\n    $(\"#btn7-1\").click(function(){\r\n        //axios(config)\r\n        axios({\r\n            method: 'get',\r\n            url:\"http://127.0.0.1:8000/demo7\",\r\n            params: {//url格式数据\r\n                name:\"DingYigui\",\r\n                id:123\r\n            },\r\n            headers:{//报头\r\n                test:321\r\n            },\r\n            data:{\r\n                a:123,\r\n                b:321\r\n            }\r\n        })\r\n        .then(function (response) {\r\n            console.log(response);\r\n        })\r\n        .catch(function (error) {\r\n            console.log(error);\r\n        })\r\n        .then(function () {\r\n            // always executed\r\n        });\r\n    })\r\n    $(\"#btn7-2\").click(function(){\r\n        // axios.get(url[, config])\r\n        axios.get('http://127.0.0.1:8000/demo7',{\r\n            params: {\r\n                name:\"DingYigui\",\r\n                id:123\r\n            },\r\n            headers:{\r\n                test:321\r\n            }\r\n        })\r\n        .then(function (response) {\r\n            console.log(response);\r\n        })\r\n        .catch(function (error) {\r\n            console.log(error);\r\n        })\r\n        .then(function () {\r\n            // always executed\r\n        });\r\n    })\r\n    $(\"#btn7-3\").click(function(){\r\n        // axios.post(url[, data[, config]])\r\n        axios.post('http://127.0.0.1:8000/demo7',{a:123,b:321},{\r\n            params: {//url格式数据\r\n                name:\"DingYigui\",\r\n                id:123\r\n            },\r\n            headers:{//报头\r\n                test:321\r\n            }\r\n        })\r\n        .then(function (response) {\r\n            console.log(response);\r\n        })\r\n        .catch(function (error) {\r\n            console.log(error);\r\n        })\r\n        .then(function () {\r\n            // always executed\r\n        });\r\n    })\r\n</script>\r\n```\r\n\r\n## window.fetch()原生ajax接口\r\n\r\n\r\n```html\r\n  <!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n  <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n  <!-- axios 库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n  <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n  <button id=\"btn8\">点击使用fetch(url,config)发送请求</button>\r\n  <script>\r\n      $(\"#btn8\").click(function(){\r\n          url = \"http://127.0.0.1:8000/demo8\"\r\n          config = {\r\n              method:\"POST\",\r\n              headers: {\r\n                  name: \"DYG\"\r\n              },\r\n              body: \"username=admin&passwd=admin\"\r\n          }\r\n          fetch(url,config)\r\n          .then(response=>{\r\n              console.log(response)\r\n            //   return response.json() //可以解析为json对象\r\n              return response.text()\r\n          })\r\n          .then(body=>{\r\n              console.log(body)\r\n          })\r\n      })\r\n```\r\n\r\n\r\n```js\r\n//引入express\r\nconst express = require('express');\r\n\r\n//创建应用对象\r\nconst app = express();\r\n\r\n//创建路由\r\napp.post(\"/demo4\",(request,response)=>{\r\n    response.setHeader(\"access-control-allow-origin\",\"*\");//允许跨域,若没有,则当以文件方式打开前端页面或访问前端页面的域名或端口与服务端不一致时,响应报文会被浏览器拦截\r\n    setTimeout(()=>{\r\n        response.send(\"你发送的数据是:\" + request.body);\r\n    },3000)\r\n\r\n})\r\n\r\n//监听端口\r\napp.listen(8000,()=>{\r\n    console.log(\"服务已启动,8000端口监听中...\")\r\n})\r\n```\r\n\r\n\r\n"},{"shortInfo":{"title":"Alpine Linux(iSH and UTM)配置过程记录","date":"2022-08-04T09:59:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["iSH","Alpine","Linux"],"categories":"笔记","hideAtIndex":true,"id":1,"countWords":2331,"readSeconds":233.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# Alpine Linux(iSH and UTM)配置过程记录\r\n## 目录\r\n- [Alpine Linux(iSH and UTM)配置过程记录](#alpine-linuxish-and-utm配置过程记录)\r\n  - [目录](#目录)\r\n  - [一、换源配置](#一换源配置)\r\n  - [二、安装软件](#二安装软件)\r\n  - [三、配置服务管理openrc](#三配置服务管理openrc)\r\n  - [配置开启ssh服务](#配置开启ssh服务)\r\n  - [实现ish后台运行配置](#实现ish后台运行配置)\r\n  - [尝试安装vsCode网页版](#尝试安装vscode网页版)\r\n    - [尝试1：在iSH中尝试通过npm安装（配置失败）](#尝试1在ish中尝试通过npm安装配置失败)\r\n    - [尝试2：在iSH中尝试通过docker安装（配置失败）](#尝试2在ish中尝试通过docker安装配置失败)\r\n    - [尝试3：在UTM中安装Alpine3.16.1再尝试使用npm安装（配置失败）](#尝试3在utm中安装alpine3161再尝试使用npm安装配置失败)\r\n    - [尝试4：在UTM中安装Alpine3.16.1再尝试使用yarn安装（配置失败）](#尝试4在utm中安装alpine3161再尝试使用yarn安装配置失败)\r\n    - [尝试5：在UTM中安装Alpine3.16.1再尝试使用release版本安装（配置失败）](#尝试5在utm中安装alpine3161再尝试使用release版本安装配置失败)\r\n    - [尝试6：在UTM中安装Alpine3.16.1并开启JIT再尝试使用release版本安装（成功）](#尝试6在utm中安装alpine3161并开启jit再尝试使用release版本安装成功)\r\n\r\n\r\n## 一、换源配置\r\n\r\n**1.编辑文件**\r\n```bash\r\nvi /etc/apk/repositories\r\n```\r\n\r\n**2.添加内容 注意版本号要和原来的一致**\r\n```bash\r\n# 任选一组\r\n# 阿里云源 实测可以使用\r\nhttp://mirrors.aliyun.com/alpine/v3.12/main\r\nhttp://mirrors.aliyun.com/alpine/v3.12/community\r\n# 中科大源 实测可以使用\r\nhttp://mirrors.ustc.edu.cn/alpine/v3.12/main\r\nhttp://mirrors.ustc.edu.cn/alpine/v3.12/community\r\n# 清华源 实测可以使用\r\nhttp://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/main\r\nhttp://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/community\r\n```\r\n**3.更新**\r\n```bash\r\napk update\r\n```\r\n\r\n**4.另一种一步到位的方法**\r\n```bash\r\n# 配置\r\ncat >> .profile << EOF\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.14/main' > /etc/apk/repositories\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.14/community' >> /etc/apk/repositories\r\nEOF\r\n# 执行\r\nsource .profile\r\n# 应用修改\r\napk update\r\n```\r\n\r\n\r\n\r\n## 二、安装软件\r\n\r\n```bash\r\napk add openrc\r\napk add curl\r\napk add npm\r\napk add git\r\napk add nss #for https\r\napk add openssh\r\n```\r\n\r\n\r\n\r\n## 三、配置服务管理openrc\r\n**1.安装openrc**\r\n```bash\r\napk add openrc\r\n# 注意 要先安装openrc 再安装要启动的服务比如docker 否则提示服务不存在\r\n```\r\n\r\n**2.编辑/etc/inittab 将`::sysinit:/sbin/openrc sysinit`中的`sysinit`删除**\r\n```bash\r\nvi /etc/inittab\r\n```\r\n\r\n**3.重启ish**\r\n\r\n**4.添加服务**\r\n```bash\r\nrc-update add sshd\r\n```\r\n\r\n**5.删除服务**\r\n```bash\r\nrc-update del sshd\r\n```\r\n\r\n**6.启动服务**\r\n```bash\r\nrc-service sshd start\r\n```\r\n\r\n**7.暂停服务**\r\n```bash\r\nrc-service sshd stop\r\n```\r\n\r\n**8.查询服务状态**\r\n```bash\r\nrc-status -a\r\n```\r\n\r\n\r\n\r\n\r\n## 配置开启ssh服务\r\n**1. 安装ssh**\r\n```bash\r\napk add openssh\r\n```\r\n\r\n**2.为本机生成SSH主机秘钥**\r\n```bash\r\nssh-keygen -A\r\n```\r\n\r\n**3.临时启动守护进程**\r\n```bash\r\n/usr/sbin/sshd\r\n```\r\n\r\n**4.将守护进程添加到开机启动**\r\n```bash\r\nrc-update add sshd\r\n# 移除开机自启服务：rc-update del sshd\r\n```\r\n**5.启动服务**\r\n```bash\r\nrc-service sshd start\r\n# 暂停服务：rc-service sshd stop\r\n```\r\n\r\n**6.配置sshd**\r\n```bash\r\ncat >> /etc/ssh/sshd_config  << EOF\r\n# 允许root登录 禁止密码登录\r\n# PermitRootLogin prohibit-password\r\n# 允许root登录\r\nPermitRootLogin yes\r\n# 允许公钥登录\r\nPubkeyAuthentication yes\r\n# 允许密码登录\r\nPasswordAuthentication yes                                       \r\n# 不允许空密码\r\nPermitEmptyPasswords no\r\nEOF\r\n```\r\n\r\n\r\n## 实现ish后台运行配置\r\n\r\n**1.关键代码**\r\n```bash\r\n# 说明：ish是ios系统上的应用程序，为使iSH进程能够支持长期后台运行而不被杀死，需要不断获取手机位置信息\r\ncat /dev/location > /dev/null &\r\n```\r\n\r\n**2.配置**\r\n```bash\r\necho 'cat /dev/location > /dev/null &' >> .profile\r\ncat .profile # 检查配置是否成功\r\n```\r\n\r\n## 尝试安装vsCode网页版\r\n\r\n### 尝试1：在iSH中尝试通过npm安装（配置失败）\r\n\r\n**先要安装`npm`和`nodejs`**\r\n但由于npm软件最新版使用了一些ish没有实现的指令 导致运行npm会提示非法指令 所以只能安装低版本\r\n\r\n**1.修改 /etc/apk/repositories 将版本改为3.12版本**\r\n```bash\r\n# 修改\r\ncat >> .profile << EOF\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/main' > /etc/apk/repositories\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/community' >> /etc/apk/repositories\r\nEOF\r\n# 更新\r\napk update\r\n```\r\n\r\n**2.安装**\r\n```bash\r\napk add nodejs=12.22.12-r0 npm=12.22.12-r0\r\n```\r\n\r\n**3.npm换为国内源**\r\n```bash\r\nnpm config set registry https://registry.npmmirror.com\r\n# 或者安装yarn: npm install -g yarn\r\n```\r\n\r\n**4.然后安装code-server**\r\n```bash\r\nnpm install -g code-server --unsafe-perm\r\n# 然后在这一步卡死了\r\n# ish1.2.3（build298） 卡在了yarn\r\n```\r\n\r\n### 尝试2：在iSH中尝试通过docker安装（配置失败）\r\n\r\n**1.安装docker和compose**\r\n```bash\r\napk add docker\r\napk add docker-compose\r\n# compose可以根据yml文件中的配置来启动docker\r\n```\r\n\r\n**2.下载coder**\r\n```bash\r\ngit clone https://github.com/coder/coder.git --depth=1\r\n```\r\n\r\n**3.临时启动守护进程测试**\r\n```bash\r\nrc-service docker start\r\n# 报错并卡死：\r\n# 原因：ish没有实现filesystems文件\r\n# 报错提示：grep: /proc/filesystems: No such file\r\n# 如果直接执行： rc-update add sshd 会导致卡死\r\n```\r\n\r\n**4.启动**\r\n```bash\r\nCODER_ACCESS_URL=http://localhost:7080\r\ndocker-compose up\r\n```\r\n\r\n\r\n\r\n### 尝试3：在UTM中安装Alpine3.16.1再尝试使用npm安装（配置失败）\r\n安装UTM 在UTM中安装Alpine3.16.1\r\n\r\n```bash\r\n# 安装时最好设置好密码\r\n# 并且在提示：# PermitRootLogin prohibit-password ？\r\n# 输入yes\r\n```\r\n\r\n安装nodejs npm\r\n```bash\r\n# 安装过程依赖python\r\napk add python3\r\n# code-server要求node16 ： code-server@4.5.1: wanted: {\"node\":\"16\"} (current: {\"node\":\"12.22.12\",\"npm\":\"6.14.16\"})\r\napk add nodejs=16.16.0-r0 npm\r\nnpm install -g code-server --unsafe-perm\r\n# 依旧报错 ：  gyp: Undefined variable module_name in binding.gyp while trying to load binding.gyp\r\n# 还是argon2的问题\r\n```\r\n尝试1、3出错原因和这个类似：[#5184](https://github.com/coder/code-server/issues/5184)\r\n\r\n\r\n### 尝试4：在UTM中安装Alpine3.16.1再尝试使用yarn安装（配置失败）\r\n\r\n该方法根据自issue：[#5174](https://github.com/coder/code-server/issues/5174)\r\n\r\n```bash\r\nnpm install -g yarn\r\nsudo yarn global add code-server\r\n```\r\n\r\n**绷不住了！！！ 报错超时，好像是虚拟机的问题！！！**\r\n\r\n```txt\r\nipad:~# npm install yarn -g\r\nadded 1 package in 1m\r\nipad:~# sudo yarn global add code-server\r\n-ash: sudo: not found\r\nipad:~# yarn global add code-server\r\nyarn global v1.22.19\r\n[1/4] Resolving packages...\r\n[2/4] Fetching packages...\r\n[3/4] Linking dependencies...\r\nwarning \"code-server > @coder/logger@1.1.16\" has unmet peer dependency \"@google-cloud/logging@^4.5.2\".\r\n[4/4] Building fresh packages...\r\nsuccess Installed \"code-server@4.5.1\" with binaries:\r\n      - code-server\r\nDone in 893.96s.\r\nipad:~# code-server \r\n[2022-08-06T18:56:50.068Z] info  Wrote default config file to ~/.config/code-server/config.yaml\r\n[2022-08-06T18:57:00.929Z] error timed out\r\n```\r\n\r\n### 尝试5：在UTM中安装Alpine3.16.1再尝试使用release版本安装（配置失败）\r\n既然在UTM安装的是64bit版本的系统 为什么不直接使用release版本？？？\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64\r\n\r\ncd ./code-server-4.5.1-linux-amd64\r\n# 执行，报错：./lib/node not fond\r\n./code-server\r\n# 安装node\r\napk add node \r\n# 查看安装目录\r\nwhich node\r\n# 建立软连接\r\nln -s /usr/bin/node ./lib/node\r\n\r\n# 再次执行\r\n./code-server\r\n# 依旧报错\r\n# [2022-08-06T18:57:00.929Z] error timed out\r\n\r\n# 查文档得知要求：glibc >= 2.17 and glibcxx >= v3.4.18\r\n# 而\r\n#alpine linux追求系统小，默认使用了uclibc，但用glibc编译的程序无法直接在上面运行了。\r\n#需要自行安装第三方的alpine glibc，然后就可以无障碍运行其他机器编译的依赖glibc的程序了。\r\n\r\n\r\n# 查了issue #1706 发现code-server 对于glibc glibcxx已经静态编译了 不需要系统自带静态链接库了\r\n\r\n\r\n```\r\n\r\n\r\n### 尝试6：在UTM中安装Alpine3.16.1并开启JIT再尝试使用release版本安装（成功）\r\n方法同上，UTM使用JIT（jitterbug）启动，终于可以了！！！原来是运行速度的问题\r\n\r\n\r\n完整过程：\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64\r\n# 递归创建文件夹\r\nmkdir -p ~/.local/lib ~/.local/bin\r\n# 移动并改名\r\nmv ./code-server-4.5.1-linux-amd64 ~/.local/lib/code-server-4.5.1/\r\n# 建立软连接\r\nln -s ~/.local/lib/code-server-4.5.1/bin/code-server ~/.local/bin/code-server\r\n# 添加到环境变量\r\nPATH=\"/root/.local/bin:$PATH\"\r\n# 运行\r\ncode-server \r\n\r\n\r\n\r\n# 如果提示-ash: node: not found 则为node添加软连接\r\nln -s /usr/bin/node ~/.local/lib/code-server-4.5.1/lib/node\r\n# 原因：\r\n# 使用命令：ldd ~/.local/lib/code-server-4.5.1/lib/node\r\n# 可以发现缺少一些动态链接库，因为alpine是阉割版的linux\r\n# 所以直接apk add nodejs\r\n# 然后删除原文件\r\n# rm ~/.local/lib/code-server-4.5.1/lib/node\r\n# which node 查看刚安装的node的所在目录\r\n# 然后添加软连接\r\nln -s /usr/bin/node ~/.local/lib/code-server-4.5.1/lib/node\r\n```\r\n\r\n**编辑配置文件修改密码**\r\n```bash\r\ncat > ~/.config/code-server/config.yaml <<EOF\r\nbind-addr: 0.0.0.0:80\r\nauth: password\r\npassword: *****数字加英文*****\r\ncert: false\r\nEOF\r\n```\r\n\r\n**配置自动添加环境变量**\r\n```\r\nvi .profile\r\nPATH=\"/root/.local/bin:$PATH\"\r\n```\r\n\r\n**配置开机自启服务（暂时没有解决输出重定向的问题）**\r\n```bash\r\nvim /etc/init.d/vscode\r\n```\r\n\r\n```bash\r\n#!/sbin/openrc-run\r\nname=\"vscode\"\r\ncommand=\"/root/.local/bin/code-server > /dev/null & \"\r\n#command_background=\"yes\"\r\ndepend() {\r\n        need net\r\n        after sshd\r\n}\r\n```\r\n\r\n```bash\r\n# 修改权限 否则提示* rc-service: Permission denied\r\nchmod 755 /etc/init.d/vscode\r\n```\r\n\r\n```bash\r\n管理服务\r\n列出所有可用服务\r\nrc-service --list | grep vscode\r\n\r\n启动/停止/重启 已有服务\r\nrc-service 服务名 start/stop/restart\r\n或\r\n/etc/init.d/服务名 start/stop/restart\r\n\r\n添加到开机自启动\r\nrc-update add vscode\r\n```"},{"shortInfo":{"title":"alpine安装code-server过程记录","date":"2022-08-07T16:12:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["code-server","alpine"],"hideAtIndex":true,"categories":"笔记","id":2,"countWords":1413,"readSeconds":141.3,"assetsbaseUrl":"/self_server/assets/"},"content":"## alpine安装code-server过程记录\r\n\r\n## 尝试1：在iSH中尝试通过npm安装（配置失败）\r\n\r\n**先要安装`npm`和`nodejs`**\r\n但由于npm软件最新版使用了一些ish没有实现的指令 导致运行npm会提示非法指令 所以只能安装低版本\r\n\r\n**1.修改 /etc/apk/repositories 将版本改为3.12版本**\r\n```bash\r\n# 修改\r\ncat >> .profile << EOF\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/main' > /etc/apk/repositories\r\necho 'http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/community' >> /etc/apk/repositories\r\nEOF\r\n# 更新\r\napk update\r\n```\r\n\r\n**2.安装**\r\n```bash\r\napk add nodejs=12.22.12-r0 npm=12.22.12-r0\r\n```\r\n\r\n**3.npm换为国内源**\r\n```bash\r\nnpm config set registry https://registry.npmmirror.com\r\n# 或者安装yarn: npm install -g yarn\r\n```\r\n\r\n**4.然后安装code-server**\r\n```bash\r\nnpm install -g code-server --unsafe-perm\r\n# 然后在这一步卡死了\r\n# ish1.2.3（build298） 卡在了yarn\r\n```\r\n\r\n## 尝试2：在iSH中尝试通过docker安装（配置失败）\r\n\r\n**1.安装docker和compose**\r\n```bash\r\napk add docker\r\napk add docker-compose\r\n# compose可以根据yml文件中的配置来启动docker\r\n```\r\n\r\n**2.下载coder**\r\n```bash\r\ngit clone https://github.com/coder/coder.git --depth=1\r\n```\r\n\r\n**3.临时启动守护进程测试**\r\n```bash\r\nrc-service docker start\r\n# 报错并卡死：\r\n# 原因：ish没有实现filesystems文件\r\n# 报错提示：grep: /proc/filesystems: No such file\r\n# 如果直接执行： rc-update add sshd 会导致卡死\r\n```\r\n\r\n**4.启动**\r\n```bash\r\nCODER_ACCESS_URL=http://localhost:7080\r\ndocker-compose up\r\n```\r\n\r\n\r\n\r\n## 尝试3：在UTM中安装Alpine3.16.1再尝试使用npm安装（配置失败）\r\n安装UTM 在UTM中安装Alpine3.16.1\r\n\r\n```bash\r\n# 安装时最好设置好密码\r\n# 并且在提示：# PermitRootLogin prohibit-password ？\r\n# 输入yes\r\n```\r\n\r\n安装nodejs npm\r\n```bash\r\n# 安装过程依赖python\r\napk add python3\r\n# code-server要求node16 ： code-server@4.5.1: wanted: {\"node\":\"16\"} (current: {\"node\":\"12.22.12\",\"npm\":\"6.14.16\"})\r\napk add nodejs=16.16.0-r0 npm\r\nnpm install -g code-server --unsafe-perm\r\n# 依旧报错 ：  gyp: Undefined variable module_name in binding.gyp while trying to load binding.gyp\r\n# 还是argon2的问题\r\n```\r\n尝试1、3出错原因和这个类似：[#5184](https://github.com/coder/code-server/issues/5184)\r\n\r\n\r\n## 尝试4：在UTM中安装Alpine3.16.1再尝试使用yarn安装（配置失败）\r\n\r\n该方法根据自issue：[#5174](https://github.com/coder/code-server/issues/5174)\r\n\r\n```bash\r\nnpm install -g yarn\r\nsudo yarn global add code-server\r\n```\r\n\r\n**绷不住了！！！ 报错超时，好像是虚拟机的问题！！！**\r\n\r\n```txt\r\nipad:~# npm install yarn -g\r\nadded 1 package in 1m\r\nipad:~# sudo yarn global add code-server\r\n-ash: sudo: not found\r\nipad:~# yarn global add code-server\r\nyarn global v1.22.19\r\n[1/4] Resolving packages...\r\n[2/4] Fetching packages...\r\n[3/4] Linking dependencies...\r\nwarning \"code-server > @coder/logger@1.1.16\" has unmet peer dependency \"@google-cloud/logging@^4.5.2\".\r\n[4/4] Building fresh packages...\r\nsuccess Installed \"code-server@4.5.1\" with binaries:\r\n      - code-server\r\nDone in 893.96s.\r\nipad:~# code-server \r\n[2022-08-06T18:56:50.068Z] info  Wrote default config file to ~/.config/code-server/config.yaml\r\n[2022-08-06T18:57:00.929Z] error timed out\r\n```\r\n\r\n## 尝试5：在UTM中安装Alpine3.16.1再尝试使用release版本安装（配置失败）\r\n既然在UTM安装的是64bit版本的系统 为什么不直接使用release版本？？？\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64\r\n\r\ncd ./code-server-4.5.1-linux-amd64\r\n# 执行，报错：./lib/node not fond\r\n./code-server\r\n# 安装node\r\napk add node \r\n# 查看安装目录\r\nwhich node\r\n# 建立软连接\r\nln -s /usr/bin/node ./lib/node\r\n\r\n# 再次执行\r\n./code-server\r\n# 依旧报错\r\n# [2022-08-06T18:57:00.929Z] error timed out\r\n\r\n# 查文档得知要求：glibc >= 2.17 and glibcxx >= v3.4.18\r\n# 而\r\n#alpine linux追求系统小，默认使用了uclibc，但用glibc编译的程序无法直接在上面运行了。\r\n#需要自行安装第三方的alpine glibc，然后就可以无障碍运行其他机器编译的依赖glibc的程序了。\r\n\r\n\r\n# 查了issue #1706 发现code-server 对于glibc glibcxx已经静态编译了 不需要系统自带静态链接库了\r\n\r\n\r\n```\r\n\r\n\r\n## 尝试6：在UTM中安装Alpine3.16.1并开启JIT再尝试使用release版本安装（成功）\r\n方法同上，UTM使用JIT（jitterbug）启动，终于可以了！！！原来是运行速度的问题\r\n\r\n\r\n完整过程：\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n## 或者在pc端下载好了之后通过sftp传输\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64.tar.gz\r\n# 递归创建文件夹\r\nmkdir -p ~/.local/lib ~/.local/bin\r\n# 移动并改名\r\nmv ./code-server-4.5.1-linux-amd64 ~/.local/lib/code-server-4.5.1/\r\n# 建立软连接\r\nln -s ~/.local/lib/code-server-4.5.1/bin/code-server ~/.local/bin/code-server\r\n# 添加到环境变量\r\nPATH=\"/root/.local/bin:$PATH\"\r\n# 运行\r\ncode-server \r\n\r\n\r\n\r\n# 如果提示-ash: node: not found 则为node添加软连接\r\n# ln -s /usr/bin/node ~/.local/lib/code-server-4.5.1/lib/node\r\n# 原因：\r\n# 使用命令：ldd ~/.local/lib/code-server-4.5.1/lib/node\r\n# 可以发现缺少一些动态链接库，因为alpine是阉割版的linux\r\n# 所以直接\r\napk add nodejs\r\n# 然后删除原文件\r\nrm ~/.local/lib/code-server-4.5.1/lib/node\r\n# which node 查看刚安装的node的所在目录\r\n# 然后添加软连接\r\nln -s /usr/bin/node ~/.local/lib/code-server-4.5.1/lib/node\r\n```\r\n\r\n**编辑配置文件修改密码**\r\n```bash\r\ncat > ~/.config/code-server/config.yaml <<EOF\r\nbind-addr: 0.0.0.0:80\r\nauth: password\r\npassword: *****数字加英文*****\r\ncert: false\r\nEOF\r\n```\r\n\r\n**配置自动添加环境变量**\r\n```\r\nvi .profile\r\nPATH=\"/root/.local/bin:$PATH\"\r\n```\r\n\r\n**配置开机自启服务（暂时没有解决输出重定向的问题）**\r\n```bash\r\nvim /etc/init.d/vscode\r\n```\r\n\r\n```bash\r\n#!/sbin/openrc-run\r\nname=\"vscode\"\r\ncommand=\"/root/.local/bin/code-server > /dev/null & \"\r\n#command_background=\"yes\"\r\ndepend() {\r\n        need net\r\n        after sshd\r\n}\r\n```\r\n\r\n```bash\r\n# 修改权限 否则提示* rc-service: Permission denied\r\nchmod 755 /etc/init.d/vscode\r\n```\r\n\r\n```bash\r\n管理服务\r\n列出所有可用服务\r\nrc-service --list | grep vscode\r\n\r\n启动/停止/重启 已有服务\r\nrc-service 服务名 start/stop/restart\r\n或\r\n/etc/init.d/服务名 start/stop/restart\r\n\r\n添加到开机自启动\r\nrc-update add vscode\r\n```"},{"shortInfo":{"title":"自动写入文字动态效果函数的实现","date":"2022-10-03T12:26:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["vue"],"hideAtIndex":true,"categories":"前端","id":123,"countWords":1166,"readSeconds":116.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 自动写入文字动态效果函数的实现\r\n\r\n**代码**\r\n```js\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nexport const autoTyping = async function(DomElement, start_TextString ,ended_TextString,interval=150) {\r\n    return new Promise(async(TypingResolve,TypingReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce(){\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n\r\n\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nexport const autoBackSpacing = async function(DomElement, start_TextString ,ended_TextString='',interval=150) {\r\n    return new Promise(async(BackSpaceResolve,BackSpaceReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce(){\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText!=ended_TextString ) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0,DomElement.innerText.length-1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nexport const waitMs = function(timeout){\r\n    return new Promise((resolve)=>{\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n```\r\n\r\n**测试代码**\r\n\r\n<span id=\"span\" data-value=\"在绝望中坚持真理,在荒诞中奋起抵抗.\" ></span><span class=\"_\">_</span>\r\n<br>\r\n<button id=\"btn\">点击测试效果</button>\r\n<script>\r\nlet span = document.querySelector(\"#span\")\r\nlet btn = document.querySelector(\"#btn\")\r\nbtn.addEventListener('click',async ()=>{\r\n    try{\r\n        await autoTyping(span,'',span.dataset['value'],150)\r\n        await waitMs(2000)\r\n        await autoBackSpacing(span,span.dataset['value'],'',50)\r\n    }catch(e){\r\n        console.log(e);\r\n    }\r\n})\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\n    async function autoTyping(DomElement, start_TextString ,ended_TextString,interval=150) {\r\n    return new Promise(async(TypingResolve,TypingReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce(){\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nasync function autoBackSpacing(DomElement, start_TextString ,ended_TextString='',interval=150) {\r\n    return new Promise(async(BackSpaceResolve,BackSpaceReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce(){\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText!=ended_TextString ) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0,DomElement.innerText.length-1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nfunction waitMs(timeout){\r\n    return new Promise((resolve)=>{\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n</script>\r\n\r\n<style>\r\n._{\r\n    display: inline-block;\r\n    margin-left: 5px;\r\n    animation: dash_flash 0.7s ease infinite;\r\n}\r\n@keyframes dash_flash {\r\n    /* 定义动画 */\r\n    from{opacity: 0;}\r\n    to{opacity: 1;}\r\n}\r\n</style>\r\n\r\n\r\n```html\r\n<span id=\"span\" data-value=\"在绝望中坚持真理,在荒诞中奋起抵抗.\" ></span><span class=\"_\">_</span>\r\n<br>\r\n<button id=\"btn\">点击测试</button>\r\n<script>\r\nlet span = document.querySelector(\"#span\")\r\nlet btn = document.querySelector(\"#btn\")\r\nbtn.addEventListener('click',async ()=>{\r\n    try{\r\n        await autoTyping(span,'',span.dataset['value'])\r\n        await waitMs(2000)\r\n        await autoBackSpacing(span,span.dataset['value'],'')\r\n    }catch(e){\r\n        console.log(e);\r\n    }\r\n})\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\n    async function autoTyping(DomElement, start_TextString ,ended_TextString,interval=150) {\r\n    return new Promise(async(TypingResolve,TypingReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce(){\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nasync function autoBackSpacing(DomElement, start_TextString ,ended_TextString='',interval=150) {\r\n    return new Promise(async(BackSpaceResolve,BackSpaceReject)=>{\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce(){\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText!=ended_TextString ) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0,DomElement.innerText.length-1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nfunction waitMs(timeout){\r\n    return new Promise((resolve)=>{\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n</script>\r\n\r\n<style>\r\n._{\r\n    display: inline-block;\r\n    margin-left: 5px;\r\n    animation: dash_flash 0.7s ease infinite;\r\n}\r\n@keyframes dash_flash {\r\n    /* 定义动画 */\r\n    from{opacity: 0;}\r\n    to{opacity: 1;}\r\n}\r\n</style>\r\n```\r\n"},{"shortInfo":{"title":"bootstrap笔记","date":"2022-06-22T23:22:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["bootstrap","前端"],"categories":"笔记","hideAtIndex":true,"id":3,"countWords":741,"readSeconds":74.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# bootstrap笔记\r\n\r\n## 目录\r\n- [bootstrap笔记](#bootstrap笔记)\r\n  - [目录](#目录)\r\n  - [简介](#简介)\r\n  - [dist](#dist)\r\n  - [基本使用步骤](#基本使用步骤)\r\n  - [栅格系统](#栅格系统)\r\n    - [栅格化](#栅格化)\r\n    - [代码书写方式](#代码书写方式)\r\n    - [使用测试](#使用测试)\r\n  - [一些类名](#一些类名)\r\n    - [container](#container)\r\n  - [官方文档](#官方文档)\r\n    - [全局样式](#全局样式)\r\n    - [组件](#组件)\r\n    - [JavaScript插件](#javascript插件)\r\n\r\n\r\n\r\n\r\n\r\n## 简介\r\n用于开发**响应式**布局、**移动设备优先**的 WEB 项目。\r\n\r\n## dist\r\n* `bootstrap-3.4.1` 源码\r\n* `bootstrap-3.4.1-dist` 用于生产环境的\r\n* `-min`格式化到同一行的，一定程度上压缩了体积的代码\r\n\r\n## 基本使用步骤\r\n1. 引用booststrap的css代码\r\n    ```html\r\n    <link rel=\"stylesheet\" href=\"./lib/bootstrap-3.4.1-dist/css/bootstrap.css\">\r\n    <link rel=\"stylesheet\" href=\"./lib/bootstrap-3.4.1-dist/css/bootstrap.min.css\">\r\n    ```\r\n2. 调用类\r\n\r\n\r\n## 栅格系统\r\n### 栅格化\r\n栅格化是指将整个网页的宽度分成诺干份  \r\nbootstrap3中默认将网页分成12等份\r\n![](./images/bootstrap笔记/2022-06-23-04-35-08.png)\r\n如有一个盒子要一行容纳四个子盒子，那么每个子盒子就要占父盒子宽度的三份\r\n\r\n### 代码书写方式\r\nbootstrap3把所有屏幕分成4类\r\n![](./images/bootstrap笔记/2022-06-23-04-41-42.png)\r\n* 语义解释\r\n    * .col-xs- 超小屏幕 手机 (<=768px) (iPhone6、7、8 375px) (iPhone12Pro 390px)\r\n    * .col-sm- 小屏幕 平板 (≥768px)\r\n    * .col-md- 中等屏幕 桌面显示器 (≥992px)\r\n    * .col-lg- 大屏幕 大桌面显示器 (≥1200px)\r\n    * col-列；colum\r\n    * xs-maxsmall，超小；sm-small，小；md-medium，中等；lg-large，大；\r\n    * -*表示占列，即占自动每行row分12列栅格系统比；\r\n\r\n### 使用测试\r\n大屏一行排列4个；中屏一行排列2个\r\n```html\r\n<link rel=\"stylesheet\" href=\"./lib/bootstrap-3.4.1-dist/css/bootstrap.css\">\r\n<style>\r\n    .container div{\r\n        height: 50px;\r\n        background-color: skyblue;\r\n        text-align: center;\r\n    }\r\n</style>\r\n<div class=\"container\">\r\n    <div class=\"col-lg-3 col-md-6\">1</div>\r\n    <div class=\"col-lg-3 col-md-6\">2</div>\r\n    <div class=\"col-lg-3 col-md-6\">3</div>\r\n    <div class=\"col-lg-3 col-md-6\">4</div>\r\n</div>\r\n```\r\n\r\n## 一些类名\r\n### container\r\n* `container` 响应式布局版心,自带15px左右内边距\r\n* `row` 自带-15px的左右外边距，用于抵消container的15px **用法**是:`container>row`\r\n    ```html\r\n    <div class=\"container\">\r\n        <div class=\"row\">\r\n            <div></div>\r\n            <div></div>\r\n            <div></div>\r\n        </div>\r\n    </div>\r\n    ```\r\n* `container-fluid` 宽度为100%的容器，自带15px左右内边距\r\n\r\n\r\n## 官方文档\r\n一般直接查[官方文档](https://v3.bootcss.com/)\r\n* **全局样式** 可以直接调用的类名\r\n* **组件** 封装好的功能组件，下拉菜单，导航等\r\n* **JavaScript插件** 一些现成的封装好的交互效果\r\n\r\n* **定制** 根据需求修改框架原有的功能\r\n![](./images/bootstrap笔记/2022-06-23-05-50-57.png)\r\n\r\n### 全局样式\r\n一般直接查[官方文档](https://v3.bootcss.com/)\r\n### 组件\r\n一般直接查[官方文档](https://v3.bootcss.com/)\r\n### JavaScript插件\r\n一般直接查[官方文档](https://v3.bootcss.com/)\r\n\r\nJavaScript插件\r\n* 需要先引入jquery\r\n* 再引入bootstrap.js\r\n* 位置一般写在body结束标签之前\r\n\r\nCarousel是轮播图"},{"shortInfo":{"title":"C++实现元胞自动机模拟器","date":"2021-01-12T16:00:00.000Z","cover":"\\self_server\\assets\\images\\C++实现元胞自动机模拟器\\cover.gif","tags":["c++","元胞自动机","demo"],"categories":"笔记","hideAtIndex":true,"id":1806477147,"countWords":19,"readSeconds":1.9,"assetsbaseUrl":"/self_server/assets/"},"content":"## [-->下载<--](./uploads/live_game.zip)\r\n\r\n\r\n![](./images/C++实现元胞自动机模拟器/cover.gif)"},{"shortInfo":{"title":"C++实现贪吃蛇小游戏","date":"2021-02-16T16:00:00.000Z","cover":"\\self_server\\assets\\images\\C++实现贪吃蛇小游戏\\cover1.gif","tags":["C++","贪吃蛇","demo"],"categories":"笔记","hideAtIndex":true,"id":3162786206,"countWords":16,"readSeconds":1.6,"assetsbaseUrl":"/self_server/assets/"},"content":"## [-->自动吃食版<--](./uploads/autoEat.exe)\r\n\r\n## [-->玩家操作版<--](./uploads/userPlay.exe)"},{"shortInfo":{"title":"C++实现连连看小游戏及寻路算法演示","date":"2021-04-02T22:03:00.000Z","cover":"\\self_server\\assets\\images\\C++实现连连看小游戏及寻路算法演示\\cover.gif","tags":["连连看","C++","demo"],"categories":"笔记","hideAtIndex":true,"id":4150131817,"countWords":217,"readSeconds":21.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# [-->下载<--](./uploads/连连看/Linkup.exe)\r\n\r\n\r\n## 映射彩虹色\r\n\r\n**原理**\r\n![](./images/C++实现连连看小游戏及寻路算法演示/2022-10-18-16-56-24.png)\r\n\r\n**代码**\r\n```c++\r\n    int preocess_color(double rate)//[0.0 ~ 1.0]  -> struct rgb[char red,char green,char blue]\r\n    {\r\n        int R=0;\r\n        int G=0;\r\n        int B=0;\r\n        if(rate<=1/6.0)\r\n        {\r\n            R=255;\r\n            G=152/(1/6.0)*rate;\r\n            B=0;\r\n        }\r\n        else\r\n        if(rate<=2/6.0)\r\n        {\r\n            R=255;\r\n            G=255/(2/6.0)*rate;\r\n            B=0;\r\n        }\r\n        else\r\n        if(rate<=3/6.0)\r\n        {\r\n            R=255/(0-(1/6.0))*(rate-2/6.0)+255;\r\n            G=255;\r\n            B=0;\r\n        }\r\n        else\r\n        if(rate<=4/6.0)\r\n        {\r\n            R=0;\r\n            G=255;\r\n            B=255/(1/6.0)*(rate-3/6.0);\r\n        }\r\n        else\r\n        if(rate<=5/6.0)\r\n        {\r\n            R=0;\r\n            G=255/(0-(1/6.0))*(rate-4/6.0)+255;\r\n            B=255;\r\n        }\r\n        else\r\n        //if(rate<=1)\r\n        {\r\n            R=150/(1/6.0)*(rate-5/6.0);\r\n            G=0;\r\n            B=255;\r\n        }\r\n        return EGERGB(R,G,B);\r\n\r\n    }\r\n```\r\n\r\n\r\n## 计算互补色\r\n```c++\r\n    //计算互补色180°\r\n    int process_another_color(int in_color)\r\n    {\r\n\r\n        int B=GetRValue(in_color);\r\n        int G=GetGValue(in_color);\r\n        int R=GetBValue(in_color);\r\n\r\n\r\n        return EGERGB(255-R,255-G,255-B);\r\n    }\r\n```"},{"shortInfo":{"layout":"post","title":"CSS3+HTML5项目实战","date":"2022-06-16T13:51:00.000Z","tags":["网站","demo"],"hideAtIndex":true,"categories":"前端","cover":"\\self_server\\assets\\images\\default_cover2.jpg","id":4,"countWords":42,"readSeconds":4.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# CSS3+HTML5项目实战\r\n\r\n## Demos\r\n### [-->学成在线<--](./demos/CSS3+HTML5项目实战/学成在线/)\r\n### [-->小兔仙<--](./demos/CSS3+HTML5项目实战/小兔仙/xtx-pc-client/)\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"title":"CSS3进阶笔记","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-06-16T17:51:00.000Z","tags":["CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":5,"countWords":5918,"readSeconds":591.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# CSS3进阶笔记\r\n\r\n## 目录\r\n- [CSS3进阶笔记](#css3进阶笔记)\r\n  - [目录](#目录)\r\n  - [字体图标](#字体图标)\r\n  - [阿里巴巴矢量字体库iconfont使用步骤](#阿里巴巴矢量字体库iconfont使用步骤)\r\n  - [平面转换](#平面转换)\r\n    - [平面位移](#平面位移)\r\n    - [平面旋转](#平面旋转)\r\n    - [位移旋转缩放的中心点更改](#位移旋转缩放的中心点更改)\r\n    - [多重转换](#多重转换)\r\n    - [平面缩放](#平面缩放)\r\n    - [使用transform的居中和缩放](#使用transform的居中和缩放)\r\n  - [空间转换](#空间转换)\r\n    - [透视](#透视)\r\n    - [空间位移](#空间位移)\r\n    - [空间旋转](#空间旋转)\r\n      - [几种空间旋转效果测试](#几种空间旋转效果测试)\r\n    - [立体呈现](#立体呈现)\r\n      - [尝试实现立方体-正交](#尝试实现立方体-正交)\r\n      - [3d导航条实现](#3d导航条实现)\r\n    - [空间缩放](#空间缩放)\r\n      - [对3d立方体盒子的空间缩放测试](#对3d立方体盒子的空间缩放测试)\r\n  - [动画](#动画)\r\n    - [animation动画属性](#animation动画属性)\r\n    - [立方体动画测试](#立方体动画测试)\r\n    - [制作精灵动画](#制作精灵动画)\r\n    - [无缝走马灯动画](#无缝走马灯动画)\r\n  - [渐变背景](#渐变背景)\r\n    - [使用示例1](#使用示例1)\r\n    - [使用示例2-综合案例实现](#使用示例2-综合案例实现)\r\n  - [绘制三角形](#绘制三角形)\r\n  - [毛玻璃效果](#毛玻璃效果)\r\n  - [背景图片的实现方式](#背景图片的实现方式)\r\n\r\n## 字体图标\r\n* 字体图标展示的是图标，实际特性却像是字，可以通过color属性改变颜色\r\n* 字体图标用于处理颜色单一的简单小图（复杂图用精灵图）\r\n* ![](./images/CSS3进阶笔记/2022-06-17-01-55-16.png)\r\n* 优点：\r\n    * 灵活，尺寸颜色可用css属性修改\r\n    * 轻量，体积小渲染快降低服务器请求次数\r\n    * 兼容，几乎兼容所有主流浏览器\r\n    * 方便，\r\n        * 下载字体包\r\n        * 使用字体图标\r\n  \r\n## 阿里巴巴矢量字体库iconfont使用步骤\r\n1. `iconfont.cn`下载字体图标\r\n2. 引入的css文件名为iconfont.css ![](./images/CSS3进阶笔记/2022-06-17-02-23-42.png)\r\n    ```html\r\n    <link rel=\"stylesheet\" href=\"./iconfont/iconfont.css\">\r\n    ```\r\n\r\n3. 调用图标对应的类名，**必须**调用两个类名\r\n    1. `iconfont`类,基本样式，包含字体图标的默认大小和颜色\r\n    2. `icon-xxx`类,图标对应的类名![](./images/CSS3进阶笔记/2022-06-17-02-26-00.png)\r\n    ```html\r\n    <span class=\"iconfont icon-XXX\"></span>\r\n    ```\r\n* iconfont具体实现原理\r\n    * `.iconfont`类\r\n    * ![](./images/CSS3进阶笔记/2022-06-17-02-50-20.png)\r\n    * `.icon-XXX`类\r\n    ![](./images/CSS3进阶笔记/2022-06-17-02-57-28.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 平面转换\r\n* 作用：改变盒子在**平面(2D)**的形态(**位移** ， 旋转 ， **缩放** )\r\n* 属性名: **transform**\r\n* 语法格式:\r\n    * `transform: translate(水平向右移动距离,垂直向下移动距离);`\r\n    * `transform: translate(自身宽度的百分比,自身高度的百分比);`\r\n    * `transform: translate(只写一个参数表示X轴移动距离);`\r\n    * `transform: translateX(一个参数);`\r\n    * `transform: translateY(一个参数);`\r\n    * \r\n![](./images/CSS3进阶笔记/2022-06-17-04-31-22.png)\r\n\r\n### 平面位移\r\n* `transform: translate(像素,或自身的百分比);`\r\n* 水平和垂直居中\r\n\r\n<div class=\"father\">\r\n    <div class=\"box\">transform: translate(-50%,-50%);</div>\r\n</div>\r\n<style>\r\n    .father{\r\n        position: relative;\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n    }\r\n    .father .box{\r\n        position:absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        transform: translate(-50%,-50%);\r\n        width: 200px;\r\n        height: 100px;\r\n        background-color: green;\r\n        line-height: 100px;\r\n    }\r\n</style>\r\n\r\n```html\r\n<div class=\"father\">\r\n    <div class=\"box\">transform: translate(-50%,-50%);</div>\r\n</div>\r\n<style>\r\n    .father{\r\n        position: relative;\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n    }\r\n    .father .box{\r\n        position:absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        transform: translate(-50%,-50%);\r\n        width: 200px;\r\n        height: 100px;\r\n        background-color: green;\r\n        line-height: 100px;\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n* 天猫\r\n\r\n<div class=\"tianmao-bgi\"></div>\r\n<style>\r\n    .tianmao-bgi{\r\n        width: 683px;\r\n        height: 300px;\r\n        background-image: url(./images/CSS3进阶笔记/bg.jpg);\r\n        background-size: contain;\r\n        /* 溢出部分隐藏 */\r\n        overflow: hidden;\r\n    }\r\n    .tianmao-bgi::before,\r\n    .tianmao-bgi::after{\r\n        display: inline-block;\r\n        content: \"\";\r\n        width: 341px;\r\n        height: 300px;\r\n        background-image: url(./images/CSS3进阶笔记/fm.jpg);\r\n        background-size:cover;\r\n        transition: all 0.5s;\r\n    }\r\n    .tianmao-bgi::after{\r\n        background-position:right 0;\r\n    }\r\n    .tianmao-bgi:hover::before{\r\n        transform: translate(-100%);\r\n    }\r\n    .tianmao-bgi:hover::after{\r\n        transform: translate(+100%);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div class=\"tianmao-bgi\"></div>\r\n<style>\r\n    .tianmao-bgi{\r\n        width: 683px;\r\n        height: 300px;\r\n        background-image: url(./images/CSS3进阶笔记/bg.jpg);\r\n        background-size: contain;\r\n        /* 溢出部分隐藏 */\r\n        overflow: hidden;\r\n    }\r\n    .tianmao-bgi::before,\r\n    .tianmao-bgi::after{\r\n        display: inline-block;\r\n        content: \"\";\r\n        width: 341px;\r\n        height: 300px;\r\n        background-image: url(./images/CSS3进阶笔记/fm.jpg);\r\n        background-size:cover;\r\n        transition: all 0.5s;\r\n    }\r\n    .tianmao-bgi::after{\r\n        background-position:right 0;\r\n    }\r\n    .tianmao-bgi:hover::before{\r\n        transform: translate(-100%);\r\n    }\r\n    .tianmao-bgi:hover::after{\r\n        transform: translate(+100%);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n### 平面旋转\r\n* 语法 `transform:rotate(角度deg);`\r\n* 角度单位deg\r\n* 旋转一圈为360deg\r\n* 取正为顺时针旋转，取负则相反\r\n* 一定要配合**过渡**属性才能看到动态的效果\r\n\r\n<div class=\"rotate-test\" >旋转测试</div>\r\n<style>\r\n    .rotate-test{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        text-align: center;\r\n        line-height: 100px;\r\n        /* 一定要配合过渡属性才能看到动态的效果 */\r\n        transition: all 1s;\r\n    }\r\n    .rotate-test:hover{\r\n        transform:rotate(360deg);\r\n    }\r\n</style>\r\n\r\n### 位移旋转缩放的中心点更改\r\n* 默认原点是盒子的中心点\r\n* 语法: `transform-origin: 水平位置 垂直位置;`\r\n* 取值：**方位名词**、像素、百分比（相对于盒子自身尺寸计算）\r\n* 示例\r\n<div class=\"origin-test\" >旋转测试</div>\r\n<style>\r\n    .origin-test{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        text-align: center;\r\n        line-height: 100px;\r\n        transition: all 1s;\r\n        transform-origin: right bottom;\r\n    }\r\n    .origin-test:hover{\r\n        transform:rotate(360deg);\r\n    }\r\n</style>\r\n\r\n\r\n### 多重转换\r\n* 语法格式,将其当做复合属性：`transform: translate() rotate();`\r\n* 注意\r\n    * 因为旋转会改变坐标轴方向，所以如果要实现平移+旋转效果，需要注意该属性的两个参数的顺序\r\n    * 不能拆成`transform: translate();transform: rotate();`两个写，否则后一个将会覆盖前一个。\r\n\r\n<div class=\"multip\" >\r\n    <div>多重转换</div>\r\n</div>\r\n<style>\r\n    .multip{\r\n        width: 313px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n    }\r\n    .multip div{\r\n        position: relative;\r\n        left: -50px;\r\n        height: 100px;\r\n        width: 100px;\r\n        background: green;\r\n        transition: all 2s;\r\n        border-radius: 50%;\r\n        text-align: center;\r\n        line-height: 100px;\r\n    }\r\n    .multip:hover div{\r\n        transform: translate(313px,0) rotate(360deg);\r\n    }\r\n</style>\r\n\r\n\r\n```html\r\n<div class=\"multip\" >\r\n    <div>多重转换</div>\r\n</div>\r\n<style>\r\n    .multip{\r\n        width: 313px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n    }\r\n    .multip div{\r\n        position: relative;\r\n        left: -50px;\r\n        height: 100px;\r\n        width: 100px;\r\n        background: green;\r\n        transition: all 2s;\r\n        border-radius: 50%;\r\n        text-align: center;\r\n        line-height: 100px;\r\n    }\r\n    .multip:hover div{\r\n        transform: translate(313px,0) rotate(360deg);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n### 平面缩放\r\n* 语法：\r\n    * transform:scale(X轴缩放倍数,Y轴缩放倍数);\r\n    * transform:scale(XY等比例缩放倍数);\r\n* 倍数没有单位\r\n\r\n<div class=\"father-scale\">\r\n    <div class=\"box\">transform:scale(缩放倍数);</div>\r\n</div>\r\n<style>\r\n    .father-scale{\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n        overflow: hidden;\r\n    }\r\n    .father-scale .box{\r\n        width: 100%;\r\n        height: 100%;\r\n        background-color: green;\r\n        transition: transform 1s;\r\n        line-height: 300px;\r\n        text-align: center;\r\n    }\r\n    .father-scale:hover .box{\r\n        transform: scale(1.5);\r\n    }\r\n</style>\r\n\r\n### 使用transform的居中和缩放\r\n* 需要把居中和缩放写到一个transform中\r\n* `transform:translate(-50%,-50%) scale(0.5);`\r\n\r\n<div class=\"father-scaleAndMiddle\">\r\n    <div class=\"box\">transform:translate(-50%,-50%) scale(0.5);</div>\r\n</div>\r\n<style>\r\n    .father-scaleAndMiddle{\r\n        position: relative;\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n        overflow: hidden;\r\n    }\r\n    .father-scaleAndMiddle .box{\r\n        position: absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        width: 50%;\r\n        height: 50%;\r\n        background-color: green;\r\n        transition: all 1s;\r\n        line-height: 150px;\r\n        font-size: 0.5em;\r\n        text-align: center;\r\n        transform: translate(-50%,-50%) scale(1);\r\n    }\r\n    .father-scaleAndMiddle:hover .box{\r\n        transform: translate(-50%,-50%) scale(1.5);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div class=\"father-scaleAndMiddle\">\r\n    <div class=\"box\">transform:translate(-50%,-50%) scale(0.5);</div>\r\n</div>\r\n<style>\r\n    .father-scaleAndMiddle{\r\n        position: relative;\r\n        width: 500px;\r\n        height: 300px;\r\n        background: skyblue;\r\n        overflow: hidden;\r\n    }\r\n    .father-scaleAndMiddle .box{\r\n        position: absolute;\r\n        top: 50%;\r\n        left: 50%;\r\n        width: 50%;\r\n        height: 50%;\r\n        background-color: green;\r\n        transition: transform 1s;\r\n        line-height: 150px;\r\n        text-align: center;\r\n        transform: translate(-50%,-50%) scale(1);\r\n    }\r\n    .father-scaleAndMiddle:hover .box{\r\n        transform: translate(-50%,-50%) scale(1.5);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 空间转换\r\n* 使用transform属性实现元素在**空间(3D)**内的**位移**，**旋转**，**缩放**等效果\r\n* z轴的正轴方向为从屏幕指向自己\r\n![](./images/CSS3进阶笔记/2022-06-18-03-10-06.png)\r\n\r\n### 透视\r\n浏览器默认应该是正交透视，没有近大远小的透视效果\r\n* 属性名：perspective\r\n* 语法：perspective:透视距离;\r\n* 建议的取值：**800-1200px**\r\n* 使用：添加给盒子的父级，透视中心为父级盒子的中心\r\n* 注意：记得给盒子添加宽高，否则会找到一个错误的中心点\r\n* 透视距离，也称视距，指人眼到屏幕的距离\r\n![](./images/CSS3进阶笔记/2022-06-18-03-43-26.png)\r\n\r\n\r\n### 空间位移\r\n* 语法：\r\n    * `transform:translate3d(x,y,z);`\r\n    * `transform:translateX(x);`\r\n    * `transform:translateY(y);`\r\n    * `transform:translateZ(z);`\r\n* 取值：像素，百分比(以自身长宽高为基准)\r\n* **注意**：默认为正交透视，所以在Z轴的位移将看不出近大远小的透视效果\r\n\r\n\r\n<div class=\"transZtest1\">\r\n    <div></div>\r\n</div>\r\n<style>\r\n    .transZtest1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        /* 透视 盒子中心成为透视中心 */\r\n        perspective: 1200px;\r\n    }\r\n    .transZtest1 div\r\n    {\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n    }\r\n    .transZtest1:hover div{\r\n        transform: translateZ(-1000px);\r\n    }\r\n</style>\r\n\r\n\r\n### 空间旋转\r\n* 语法：\r\n    * `rotateX()` 绕X轴旋转\r\n    * `rotateY()` 绕Y轴旋转\r\n    * `rotateZ()` 绕Z轴旋转\r\n    * `rotate3d(x,y,z,角度度数)`\r\n        * **指定一个旋转轴，旋转指定的角度**\r\n        * **x,y,z取值为0-1的数字**\r\n* **注意**：默认为正交透视，所以在各轴的位移默认将看不出近大远小的透视效果\r\n\r\n\r\n#### 几种空间旋转效果测试\r\n<div class=\"rotateXtestBox1\">\r\n    <div class=\"rotateXtest\">rotateX()</div>\r\n</div>\r\n<style>\r\n    .rotateXtestBox1 {\r\n        margin:10px;\r\n        width: 100px;\r\n        height: 100px;\r\n        perspective: 1200px;\r\n    }\r\n    .rotateXtestBox1 .rotateXtest{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        transition: all 2s;\r\n    }\r\n    .rotateXtestBox1 .rotateXtest:hover{\r\n        transform: rotateX(60deg);\r\n    }\r\n</style>\r\n\r\n<div class=\"rotateXtestBox2\">\r\n    <div class=\"rotateXtest\">rotateY()</div>\r\n</div>\r\n<style>\r\n    .rotateXtestBox2 {\r\n        margin:10px;\r\n        perspective: 1200px;\r\n    }\r\n    .rotateXtestBox2 .rotateXtest{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        transition: all 2s;\r\n    }\r\n    .rotateXtestBox2 .rotateXtest:hover{\r\n        transform: rotateY(60deg);\r\n    }\r\n</style>\r\n\r\n<div class=\"rotateXtestBox3\">\r\n    <div class=\"rotateXtest\">rotateZ()</div>\r\n</div>\r\n<style>\r\n    .rotateXtestBox3 {\r\n        margin:10px;\r\n        perspective: 1200px;\r\n    }\r\n    .rotateXtestBox3 .rotateXtest{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: #fff;\r\n        transition: all 2s;\r\n    }\r\n    .rotateXtestBox3 .rotateXtest:hover{\r\n        transform: rotateZ(60deg);\r\n    }\r\n</style>\r\n\r\n### 立体呈现\r\n* 用法：`transform-style:preserve-3d`\r\n    * 默认值：`flat`，表示处于平面空间\r\n* 作用：使子元素处于3d空间\r\n\r\n\r\n#### 尝试实现立方体-正交\r\n* 结合transform-style、transition、rotate等属性的综合案例\r\n\r\n<div class=\"threedbox\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    .threedbox{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        /* perspective: 1500px; */\r\n        transform-style: preserve-3d;\r\n        transition: all 5s;\r\n    }\r\n    .threedbox .font,\r\n    .threedbox .back,\r\n    .threedbox .left,\r\n    .threedbox .right,\r\n    .threedbox .top,\r\n    .threedbox .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    .threedbox .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    .threedbox .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    .threedbox .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    .threedbox .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    .threedbox .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    .threedbox .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    .threedbox:hover{\r\n        /* transform: rotateY(365deg); */\r\n        transform: rotate3d(1,1,1,360deg);\r\n    }\r\n</style>\r\n\r\n代码：\r\n```html\r\n<div class=\"threedbox\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n\r\n<style>\r\n    .threedbox{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        /* perspective: 1200px; */\r\n        transform-style: preserve-3d;\r\n        transition: all 5s;\r\n    }\r\n    .threedbox .font,\r\n    .threedbox .back,\r\n    .threedbox .left,\r\n    .threedbox .right,\r\n    .threedbox .top,\r\n    .threedbox .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    .threedbox .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    .threedbox .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    .threedbox .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    .threedbox .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    .threedbox .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    .threedbox .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    \r\n    .threedbox:hover{\r\n        /* transform: rotateY(365deg); */\r\n        transform: rotate3d(1,1,1,360deg);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n#### 3d导航条实现\r\n<div class=\"nav-demo clearall\">\r\n    <ul>\r\n        <li><a class=\"clearfix\" href=\"#\"><span>首页</span><span>index</span></a></li>\r\n        <li><a class=\"clearfix\" href=\"#\"><span>中文</span><span>Chinese</span></a></li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    .clearfix::after{\r\n        content:'';\r\n        display:block;\r\n        clear:both;\r\n    }\r\n    .nav-demo ul{\r\n        list-style: none;\r\n        height: 30px;\r\n    }\r\n    .nav-demo ul li{\r\n        float: left;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        /* background-color: #fff; */\r\n    }\r\n    .nav-demo ul li a{\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 30px;\r\n        width: 80px;\r\n        line-height: 30px;\r\n        perspective: 1200px;\r\n        transform-style: preserve-3d;\r\n        text-align: center;\r\n        transition: all 1s;\r\n        color: white;\r\n    }\r\n    .nav-demo ul li a span{\r\n        position:absolute;\r\n        left: 0px;\r\n        top: 0px;\r\n        display: inline-block;\r\n        height: 30px;\r\n        width: 100%;\r\n        background-color: green;\r\n    }\r\n    .nav-demo ul li span:nth-child(1){\r\n        transform: translateZ(15px);\r\n    }\r\n    .nav-demo ul li span:nth-child(2){\r\n        background-color: orange;\r\n        transform: translateY(-15px) rotateX(90deg) ;\r\n    }\r\n    .nav-demo ul li:hover a{\r\n        /* transform: rotate3d(1,1,1,90deg); */\r\n        transform: rotate3d(1,0,0,-90deg);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div class=\"nav-demo\">\r\n    <ul>\r\n        <li><a class=\"clearfix\" href=\"#\"><span>首页</span><span>index</span></a></li>\r\n        <li><a class=\"clearfix\" href=\"#\"><span>中文</span><span>Chinese</span></a></li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    .clearfix::after{\r\n        content:'';\r\n        display:block;\r\n        clear:both;\r\n    }\r\n    .nav-demo ul{\r\n        list-style: none;\r\n        height: 30px;\r\n    }\r\n    .nav-demo ul li{\r\n        float: left;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        /* background-color: #fff; */\r\n    }\r\n    .nav-demo ul li a{\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 30px;\r\n        width: 80px;\r\n        line-height: 30px;\r\n        perspective: 1200px;\r\n        transform-style: preserve-3d;\r\n        text-align: center;\r\n        transition: all 1s;\r\n        color: white;\r\n    }\r\n    .nav-demo ul li a span{\r\n        position:absolute;\r\n        left: 0px;\r\n        top: 0px;\r\n        display: inline-block;\r\n        height: 30px;\r\n        width: 100%;\r\n        background-color: green;\r\n    }\r\n    .nav-demo ul li span:nth-child(1){\r\n        transform: translateZ(15px);\r\n    }\r\n    .nav-demo ul li span:nth-child(2){\r\n        background-color: orange;\r\n        transform: translateY(-15px) rotateX(90deg) ;\r\n    }\r\n    .nav-demo ul li:hover a{\r\n        /* transform: rotate3d(1,1,1,90deg); */\r\n        transform: rotate3d(1,0,0,-90deg);\r\n    }\r\n</style>\r\n```\r\n\r\n### 空间缩放\r\n* 语法：\r\n    * `transform:scaleX(倍数);` 将模型拉宽，效果参考平面缩放\r\n    * `transform:scaleY(倍数);` 将模型拉高，效果参考平面缩放\r\n    * `transform:scaleZ(倍数);` 将模型拉长，效果相当于模型有了厚度\r\n    * `transform:scale3d(倍数,倍数,倍数);`\r\n* 注意书写书写，一般应该先位移，后旋转，再缩放\r\n\r\n#### 对3d立方体盒子的空间缩放测试\r\n\r\n<div id=\"threedbox-2\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    #threedbox-2{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        perspective: 1500px;\r\n        transform-style: preserve-3d;\r\n        transition: all 3s;\r\n        transform:  rotate3d(1,1,1,30deg) ;\r\n    }\r\n    #threedbox-2 .font,\r\n    #threedbox-2 .back,\r\n    #threedbox-2 .left,\r\n    #threedbox-2 .right,\r\n    #threedbox-2 .top,\r\n    #threedbox-2 .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    #threedbox-2 .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    #threedbox-2 .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    #threedbox-2 .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    #threedbox-2 .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    #threedbox-2 .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    #threedbox-2 .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    #threedbox-2:hover{\r\n        /* scale3d测试 */\r\n        transform:  rotate3d(1,1,1,30deg) scale3d(0.5,1.5,2);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div id=\"threedbox-2\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    #threedbox-2{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        perspective: 1500px;\r\n        transform-style: preserve-3d;\r\n        transition: all 3s;\r\n        transform:  rotate3d(1,1,1,30deg) ;\r\n    }\r\n    #threedbox-2 .font,\r\n    #threedbox-2 .back,\r\n    #threedbox-2 .left,\r\n    #threedbox-2 .right,\r\n    #threedbox-2 .top,\r\n    #threedbox-2 .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    #threedbox-2 .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    #threedbox-2 .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    #threedbox-2 .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    #threedbox-2 .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    #threedbox-2 .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    #threedbox-2 .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    #threedbox-2:hover{\r\n        /* scale3d测试 */\r\n        transform:  rotate3d(1,1,1,30deg) scale3d(0.5,1.5,2);\r\n    }\r\n    \r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n## 动画\r\n* 构成动画的最小单位是帧或动画帧\r\n* 动画和过渡的区别：\r\n    * 过渡是两个状态间的变化过程\r\n    * 动画是多个状态间的变化过程\r\n\r\n* 实现步骤\r\n    1. 定义动画\r\n        * 方法1 两个状态间的动画\r\n            ```css\r\n            @keyframes 动画名称{\r\n                from{}\r\n                to{}\r\n            }\r\n            ```\r\n        * 方法2 多个状态间的动画\r\n            ```css\r\n            @keyframes 动画名称{\r\n                <!-- 百分比指的是占用时间的百分比 -->\r\n                0%{}\r\n                10%{}\r\n                20%{}\r\n                50%{}\r\n                100%{}\r\n            }\r\n            ```\r\n    2. 使用动画\r\n        ```css\r\n            animation:动画名称 动画花费时长;\r\n        ```\r\n\r\n* 测试\r\n<div id=\"testframe1\">\r\n    动画将在刷新浏览器后立即播放\r\n</div>\r\n<style>\r\n    #testframe1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        animation: changeWidth 10s;\r\n    }\r\n    @keyframes changeWidth {\r\n        from{\r\n            width: 100px;\r\n        }\r\n        to{\r\n            width: 200px;\r\n        }\r\n    }\r\n</style>\r\n<br>\r\n<div id=\"testframe2\">\r\n    动画将在刷新浏览器后立即播放\r\n</div>\r\n<style>\r\n    #testframe2{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        /* 总共10秒 */\r\n        animation: changeWidth2 10s;\r\n    }\r\n    @keyframes changeWidth2 {\r\n        0%{width: 0px;}\r\n        /* 0-200px用了1秒钟 */\r\n        10%{width: 200px;}\r\n        50%{width: 300px;}\r\n        /* 300-1000px用了最后五秒钟 */\r\n        100%{width: 1000px;}\r\n    }\r\n</style>\r\n\r\n```html\r\n<div id=\"testframe1\">\r\n    动画将在刷新浏览器后立即播放\r\n</div>\r\n<style>\r\n    #testframe1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        animation: changeWidth 10s;\r\n    }\r\n    @keyframes changeWidth {\r\n        from{\r\n            width: 100px;\r\n        }\r\n        to{\r\n            width: 200px;\r\n        }\r\n    }\r\n</style>\r\n<br>\r\n<div id=\"testframe2\">\r\n    动画将在刷新浏览器后立即播放\r\n</div>\r\n<style>\r\n    #testframe2{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        /* 总共10秒 */\r\n        animation: changeWidth2 10s;\r\n    }\r\n    @keyframes changeWidth2 {\r\n        0%{width: 0px;}\r\n        /* 0-200px用了1秒钟 */\r\n        10%{width: 200px;}\r\n        50%{width: 300px;}\r\n        /* 300-1000px用了最后五秒钟 */\r\n        100%{width: 1000px;}\r\n    }\r\n</style>\r\n```\r\n\r\n### animation动画属性\r\n* 完整语法格式: `animation: name1 duration1,name2 duration2;`\r\n* 完整语法格式: `animation: name duration timing-function delay iteration-count direction fill-mode;`\r\n* 完整语法格式: `animation: 动画名称 动画时长 速度曲线 延迟时间 重复次数 动画方向 执行完毕时状态;`\r\n* 注意：\r\n    * **动画名称和时长为必填值**\r\n    * **取值不分先后顺序**\r\n    * 如有两个数值，第一个表示动画时长，第二个表示延迟时间\r\n\r\n* **速度曲线**取值: 默认为补间动画，流畅\r\n    * `liner` 线性\r\n    * `steps(x)` 逐帧动画，分成x等份播放的动画\r\n\r\n* **延迟时间** ：单位s 延迟多少秒播放动画\r\n* \r\n* **重复次数** ： 默认只播放一次，设置后将播放指定次数\r\n    * **取纯数字** 指定播放次数\r\n    * **取关键字** \r\n        * `infinite` 无限次\r\n        * 等...\r\n\r\n* **动画方向**：默认按关键帧的顺序播放\r\n    * `alternative` 按关键帧的顺序播放后再反着倒放动画\r\n    * 等...\r\n\r\n* **执行完毕时状态**:\r\n    * `backwards` 默认值 动画停留在初始状态 \r\n    * `forwards` 动画停留在最终状态\r\n    * 注意:该属性值会和 `infinite` 、`alternative` 冲突\r\n\r\n\r\n* 拆分写法\r\n![](./images/CSS3进阶笔记/2022-06-18-21-29-52.png)\r\n\r\n\r\n### 立方体动画测试\r\n\r\n<div id=\"threedbox-animation1\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    #threedbox-animation1{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        /* perspective: 1200px; */\r\n        transform-style: preserve-3d;\r\n        transform: rotate3d(1,1,1,45deg);\r\n        /* 无限播放的动画 */\r\n        animation: threedboxFrames1 3s infinite;\r\n    }\r\n    #threedbox-animation1 .font,\r\n    #threedbox-animation1 .back,\r\n    #threedbox-animation1 .left,\r\n    #threedbox-animation1 .right,\r\n    #threedbox-animation1 .top,\r\n    #threedbox-animation1 .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    #threedbox-animation1 .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    #threedbox-animation1 .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    #threedbox-animation1 .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    #threedbox-animation1 .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    #threedbox-animation1 .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    #threedbox-animation1 .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    /* 定义动画 */\r\n    @keyframes threedboxFrames1 {\r\n        from{transform: rotate3d(1,1,1,45deg) rotate3d(0,1,0,0deg);}\r\n        to{transform:  rotate3d(1,1,1,45deg) rotate3d(0,1,0,360deg);}\r\n    }\r\n    #threedbox-animation1:hover{\r\n        /* 鼠标控制暂停的效果     */\r\n       animation-play-state: paused;\r\n    }\r\n</style>\r\n\r\n```html\r\n<div id=\"threedbox-animation1\">\r\n    <div class=\"font\"></div>\r\n    <div class=\"back\"></div>\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\"></div>\r\n    <div class=\"top\"></div>\r\n    <div class=\"bottom\"></div>\r\n</div>\r\n<style>\r\n    #threedbox-animation1{\r\n        position: relative;\r\n        width: 200px;\r\n        height: 200px;\r\n        /* background-color: #fff; */\r\n        /* perspective: 1200px; */\r\n        transform-style: preserve-3d;\r\n        transform: rotate3d(1,1,1,45deg);\r\n        /* 无限播放的动画 */\r\n        animation: threedboxFrames1 3s infinite;\r\n    }\r\n    #threedbox-animation1 .font,\r\n    #threedbox-animation1 .back,\r\n    #threedbox-animation1 .left,\r\n    #threedbox-animation1 .right,\r\n    #threedbox-animation1 .top,\r\n    #threedbox-animation1 .bottom\r\n    {\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 200px;\r\n        height: 200px;\r\n    }\r\n    #threedbox-animation1 .font{\r\n        background-color: rgba(0, 255, 0, 0.5);\r\n        transform: translateZ(-100px);\r\n    }\r\n    #threedbox-animation1 .back{\r\n        background-color: rgba(255, 0, 0, 0.5);\r\n        transform: translateZ(+100px);\r\n    }\r\n    #threedbox-animation1 .left{\r\n        background-color: rgba(0, 0, 255, 0.5);\r\n        transform: translateX(-100px) rotateY(90deg);\r\n    }\r\n    #threedbox-animation1 .right{\r\n        background-color: rgba(0, 255, 255, 0.5);\r\n        transform: translateX(+100px) rotateY(90deg);\r\n    }\r\n    #threedbox-animation1 .top{\r\n        background-color: rgba(255, 255, 0, 0.5);\r\n        transform: translateY(+100px) rotateX(90deg);\r\n    }\r\n    #threedbox-animation1 .bottom{\r\n        background-color: rgba(255, 0, 255, 0.5);\r\n        transform: translateY(-100px) rotateX(90deg);\r\n    }\r\n    /* 定义动画 */\r\n    @keyframes threedboxFrames1 {\r\n        from{transform: rotate3d(1,1,1,45deg) rotate3d(0,1,0,0deg);}\r\n        to{transform:  rotate3d(1,1,1,45deg) rotate3d(0,1,0,360deg);}\r\n    }\r\n    #threedbox-animation1:hover{\r\n        /* 鼠标控制暂停的效果     */\r\n       animation-play-state: paused;\r\n    }\r\n</style>\r\n\r\n```\r\n\r\n### 制作精灵动画\r\n* 步骤\r\n    * 准备显示区域 尺寸为精灵图小图尺寸\r\n    * 定义动画 改变图片位置 \r\n    * 使用动画\r\n        * 添加速度曲线`steps(N)` N为小图数，\r\n        * 添加无限重复效果 `infinite`\r\n* 精灵图：\r\n![](./images/CSS3进阶笔记/bg2.png)\r\n\r\n<div id=\"spbox1\"></div>\r\n<style>\r\n    #spbox1{\r\n        width: 140px;\r\n        height: 140px;\r\n        /* background-color: #fff; */\r\n        border: 1px solid #fff;\r\n        background-image: url(./images/CSS3进阶笔记/bg2.png);\r\n        animation: \r\n            run1 1s infinite steps(12),\r\n            move1 10s infinite forwards;\r\n    }\r\n    @keyframes run1 {\r\n        /* from、0% 的初值是0 则这句可以省略 */\r\n        /* 0%{background-position: 0 0;} */\r\n        /*  */\r\n        /* 从第一张到第12张移动了-11*140px */\r\n        /* 从第一张到第一张移动了-12*140px */\r\n        /* 所以取值-1680px就好 */\r\n        100%{background-position: -1680px 0;}\r\n    }\r\n    @keyframes move1 {\r\n        /* from{transform:translateX(0px)} */\r\n        to{transform:translateX(300px)}\r\n        \r\n    }\r\n</style>\r\n\r\n\r\n### 无缝走马灯动画\r\n* 实现无缝的关键在于，要把最开头几张图复制到最后\r\n![](./images/CSS3进阶笔记/2022-06-18-23-47-35.png)\r\n\r\n\r\n\r\n\r\n\r\n## 渐变背景\r\n* 语法 \r\n    * `  linear-gradient(颜色1,颜色2);`\r\n    * `background-image: linear-gradient(transparent,颜色2);`\r\n    * `background-image: linear-gradient(颜色1,颜色2,颜色3);`\r\n* 图片遮罩：可以一个盒子背景为某张图片，嵌套一个类名为mask的相同大小的渐变背景图，定位在父级上\r\n\r\n### 使用示例1\r\n\r\n<div id=\"linear-1\"></div>\r\n<style>\r\n    #linear-1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-image: linear-gradient(red,green);\r\n    }\r\n</style>\r\n\r\n```html\r\n<div id=\"linear-1\"></div>\r\n<style>\r\n    #linear-1{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-image: linear-gradient(red,green);\r\n    }\r\n</style>\r\n```\r\n\r\n\r\n### 使用示例2-综合案例实现\r\n\r\n<div id=\"linearTest2Box\">\r\n    <img src=\"/images/CSS3进阶笔记/product.jpeg\" alt=\"\">\r\n    <div class=\"mask\"></div>\r\n    <div class=\"text\">\r\n        <h2>产品说明标题</h2>\r\n        <p>任意字数产品说明文字任意字数产品说明文字任意字数产品说明文字任意字数产品说明文字</p>\r\n    </div>\r\n</div>\r\n<style>\r\n    #linearTest2Box{\r\n        position: relative;\r\n        width: 384px;\r\n        height: 271px;\r\n        overflow: hidden;\r\n    }\r\n    #linearTest2Box img{\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 384px;\r\n        height: 271px;\r\n        transition: all 0.5s;\r\n        z-index: 1;\r\n    }\r\n    #linearTest2Box .mask{\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 384px;\r\n        height: 271px;\r\n        background-image: linear-gradient(transparent,rgba(0,0,0,0.5));\r\n        opacity: 0;\r\n        transition: all 0.5s;\r\n        z-index: 2;\r\n    }\r\n    #linearTest2Box .text {\r\n        position: absolute;\r\n        left: 0px;\r\n        bottom: 0px;\r\n        padding: 0 10px;\r\n        z-index: 3;\r\n        /* h2的行高为50px */\r\n        transform: translate(0,100%) translate(0,-50px);\r\n        transition: all 0.5s;\r\n    }\r\n    #linearTest2Box .text h2{\r\n        height: 50px;\r\n        font-size: 2em;\r\n        color: #fff;\r\n    }\r\n    #linearTest2Box .text p{\r\n        font-size: 1em;\r\n        color: #fff;\r\n        overflow: hidden;\r\n    }\r\n    #linearTest2Box:hover img{\r\n        transform: scale(1.05);\r\n    }\r\n    #linearTest2Box:hover .mask{\r\n        opacity: 1;\r\n    }\r\n    #linearTest2Box:hover .text{\r\n        transform: translate(0,0);\r\n    }\r\n</style>\r\n\r\n\r\n代码：\r\n```html\r\n<div id=\"linearTest2Box\">\r\n    <img src=\"/images/CSS3进阶笔记/product.jpeg\" alt=\"\">\r\n    <div class=\"mask\"></div>\r\n    <div class=\"text\">\r\n        <h2>产品说明标题</h2>\r\n        <p>任意字数产品说明文字任意字数产品说明文字任意字数产品说明文字任意字数产品说明文字</p>\r\n    </div>\r\n</div>\r\n<style>\r\n    #linearTest2Box{\r\n        position: relative;\r\n        width: 384px;\r\n        height: 271px;\r\n        overflow: hidden;\r\n    }\r\n    #linearTest2Box img{\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 384px;\r\n        height: 271px;\r\n        transition: all 0.5s;\r\n        z-index: 1;\r\n    }\r\n    #linearTest2Box .mask{\r\n        position: absolute;\r\n        left: 0;\r\n        top: 0;\r\n        width: 384px;\r\n        height: 271px;\r\n        background-image: linear-gradient(transparent,rgba(0,0,0,0.5));\r\n        opacity: 0;\r\n        transition: all 0.5s;\r\n        z-index: 2;\r\n    }\r\n    #linearTest2Box .text {\r\n        position: absolute;\r\n        left: 0px;\r\n        bottom: 0px;\r\n        padding: 0 10px;\r\n        z-index: 3;\r\n        /* h2的行高为50px */\r\n        transform: translate(0,100%) translate(0,-50px);\r\n        transition: all 0.5s;\r\n    }\r\n    #linearTest2Box .text h2{\r\n        height: 50px;\r\n        font-size: 2em;\r\n        color: #fff;\r\n    }\r\n    #linearTest2Box .text p{\r\n        font-size: 1em;\r\n        color: #fff;\r\n        overflow: hidden;\r\n    }\r\n    #linearTest2Box:hover img{\r\n        transform: scale(1.05);\r\n    }\r\n    #linearTest2Box:hover .mask{\r\n        opacity: 1;\r\n    }\r\n    #linearTest2Box:hover .text{\r\n        transform: translate(0,0);\r\n    }\r\n</style>\r\n```\r\n\r\n## 绘制三角形\r\n\r\n**利用边框拐角处的45度角绘制三角形**\r\n\r\n\r\n<div id=\"demoNOH895\">利用边框拐角处的45度角绘制三角形</div>\r\n<style>\r\n    #demoNOH895{\r\n    box-sizing: border-box;\r\n    width: 200px;\r\n    height: 200px;\r\n    border-top: 50px solid black;\r\n    border-right: 50px solid red;\r\n    border-bottom: 50px solid green;\r\n    border-left: 50px solid blue;\r\n}\r\n</style>\r\n\r\n```html\r\n<div id=\"demoNOH895\">利用边框拐角处的45度角绘制三角形</div>\r\n<style>\r\n    #demoNOH895{\r\n    box-sizing: border-box;\r\n    width: 200px;\r\n    height: 200px;\r\n    border-top: 50px solid black;\r\n    border-right: 50px solid red;\r\n    border-bottom: 50px solid green;\r\n    border-left: 50px solid blue;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n**宽高不定，各边框50px，效果：**\r\n\r\n<div id=\"demojowej09\"></div>\r\n<style>\r\n    #demojowej09{\r\n    box-sizing: border-box;\r\n    width: 0px;\r\n    height: 0px;\r\n    border-top: 50px solid black;\r\n    border-right: 50px solid red;\r\n    border-bottom: 50px solid green;\r\n    border-left: 50px solid blue;\r\n}\r\n</style>\r\n\r\n```html\r\n<div id=\"demojowej09\"></div>\r\n<style>\r\n    #demojowej09{\r\n    box-sizing: border-box;\r\n    width: 0px;\r\n    height: 0px;\r\n    border-top: 50px solid black;\r\n    border-right: 50px solid red;\r\n    border-bottom: 50px solid green;\r\n    border-left: 50px solid blue;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n**宽高不定，上边框50px，其他边框透明，效果：**\r\n\r\n<div id=\"demojowewdeio\"></div>\r\n<style>\r\n    #demojowewdeio{\r\n    box-sizing: border-box;\r\n    width: 0px;\r\n    height: 0px;\r\n    border-top: 50px solid green;\r\n    border-right: 50px solid transparent;\r\n    border-bottom: 50px solid transparent;\r\n    border-left: 50px solid transparent;\r\n}\r\n</style>\r\n\r\n```html\r\n<div id=\"demojowewdeio\"></div>\r\n<style>\r\n    #demojowewdeio{\r\n    box-sizing: border-box;\r\n    width: 0px;\r\n    height: 0px;\r\n    border-top: 50px solid green;\r\n    border-right: 50px solid transparent;\r\n    border-bottom: 50px solid transparent;\r\n    border-left: 50px solid transparent;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n可以实现的其他效果：\r\n![](./images/CSS3进阶笔记/2022-07-03-14-51-07.png)\r\n\r\n\r\n## 毛玻璃效果\r\n\r\n* 语法: `背景幕布-过滤器 : 模糊(像素)`\r\n* 案例: `backdrop-filter: blur(8px);`\r\n* 和filter的区别:\r\n  * filter ：模糊内容 作用于当前元素本身，并且它的后代元素也会继承这个属性\r\n  * backdrop-filter : 作用于当前元素背后的所有元素\r\n\r\n* 饱和度: `saturate(150%) <100%变暗，>100%变亮` 防止透过遮罩层内容过暗\r\n* 对比度: `contrast(50%) 100%为原图，0%为全灰色图像` 防止透过遮罩层内容色彩过杂\r\n\r\n示例\r\n```css\r\ndiv{\r\n\r\n    /* chrome浏览器 */\r\n    backdrop-filter:saturate(150%) contrast(50%) blur(8px);\r\n\r\n    /* ios浏览器 */\r\n    -webkit-backdrop-filter:saturate(150%) contrast(50%) blur(8px);\r\n}\r\n```\r\n\r\n## 背景图片的实现方式\r\n```html\r\n<div class=\"bg_img\" style=\"background-image: url(/src/components/BackGround/images/2.png);\"></div>\r\n\r\n<style>\r\n.bg_img{\r\n  z-index: -1;//保证其在最低层\r\n  position: fixed;//相对于视口布局\r\n  top: 0;\r\n  left: 0;\r\n  width: 100vh;//宽度为100%视口宽度\r\n  height: 100vh;//高度为100%视口宽度\r\n  background-size: cover;//关键属性\r\n  background-color: white; //默认背景白色\r\n  background-position: bottom center;//背景图片 水平 和 垂直 方向的对齐方式\r\n  filter:\r\n}\r\n</style>\r\n```"},{"shortInfo":{"title":"CSS3重学笔记","cover":"\\self_server\\assets\\images\\CSS3重学笔记\\cover.png","coverWidth":1920,"coverHeight":1080,"date":"2022-06-04T22:00:00.000Z","date_end":"2022-06-08T14:47:00.000Z","tags":["CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":6,"countWords":13820,"readSeconds":1382,"assetsbaseUrl":"/self_server/assets/"},"content":"# css3重学笔记\r\n\r\n## 更新日志\r\n* **2022-06-05**: 因为感觉原先学CSS的时候没有学透彻，一直想重新系统性的学一遍，查缺补漏。最近几天有时间就开始学了，顺便记个笔记，加深印象、方便复习和查阅。\r\n* **2022.06.11**：终于把基础部分的知识点归纳总结完了，崩溃了，为什么这么多......\r\n* **2022.06.12**: 【增添】`background-size`、`text-shadow`、`box-shadow` `transition`属性笔记\r\n\r\n## 目录\r\n- [css3重学笔记](#css3重学笔记)\r\n  - [更新日志](#更新日志)\r\n  - [目录](#目录)\r\n  - [css简介](#css简介)\r\n  - [引入方式](#引入方式)\r\n    - [内嵌式](#内嵌式)\r\n    - [外联式](#外联式)\r\n    - [行内式](#行内式)\r\n  - [选择器](#选择器)\r\n    - [标签选择器](#标签选择器)\r\n    - [类选择器](#类选择器)\r\n    - [id选择器](#id选择器)\r\n    - [通配符选择器](#通配符选择器)\r\n    - [后代选择器](#后代选择器)\r\n    - [子代选择器](#子代选择器)\r\n    - [并集选择器](#并集选择器)\r\n    - [交集选择器](#交集选择器)\r\n    - [伪类选择器](#伪类选择器)\r\n    - [结构伪类选择器](#结构伪类选择器)\r\n    - [伪html元素选择器](#伪html元素选择器)\r\n  - [字体样式](#字体样式)\r\n    - [字体的大小属性](#字体的大小属性)\r\n    - [字体的粗细属性](#字体的粗细属性)\r\n    - [字体的倾斜属性](#字体的倾斜属性)\r\n    - [字体的family字体属性](#字体的family字体属性)\r\n    - [字体的复合属性](#字体的复合属性)\r\n  - [文本样式](#文本样式)\r\n    - [文本缩进属性](#文本缩进属性)\r\n    - [文本水平对齐方式属性](#文本水平对齐方式属性)\r\n    - [文本修饰线属性](#文本修饰线属性)\r\n    - [文本行高属性](#文本行高属性)\r\n    - [文字阴影属性](#文字阴影属性)\r\n    - [文字外边框](#文字外边框)\r\n  - [盒子模型](#盒子模型)\r\n    - [简介](#简介)\r\n    - [盒子模型各组成部分的设置](#盒子模型各组成部分的设置)\r\n      - [内容区域content](#内容区域content)\r\n      - [内边距区域padding](#内边距区域padding)\r\n      - [边框区域border](#边框区域border)\r\n      - [外边距区域margin](#外边距区域margin)\r\n    - [盒子模型的外边距margin的合并问题](#盒子模型的外边距margin的合并问题)\r\n    - [盒子模型的外边距margin的塌陷问题](#盒子模型的外边距margin的塌陷问题)\r\n    - [盒子模型行内元素的padding和margin问题](#盒子模型行内元素的padding和margin问题)\r\n    - [盒子模型实现指定尺寸的方法](#盒子模型实现指定尺寸的方法)\r\n    - [清除默认内外边距](#清除默认内外边距)\r\n    - [margin和text-align实现水平居中的区别](#margin和text-align实现水平居中的区别)\r\n    - [案例实现](#案例实现)\r\n      - [新浪首页导航条实例编写](#新浪首页导航条实例编写)\r\n      - [新闻列表案例实现](#新闻列表案例实现)\r\n  - [盒子阴影属性](#盒子阴影属性)\r\n  - [背景](#背景)\r\n    - [颜色的几种表示方式](#颜色的几种表示方式)\r\n    - [背景颜色属性](#背景颜色属性)\r\n    - [背景图片](#背景图片)\r\n    - [背景图片重复方式](#背景图片重复方式)\r\n    - [背景图片位置](#背景图片位置)\r\n    - [背景复合属性](#背景复合属性)\r\n    - [背景图大小](#背景图大小)\r\n    - [img标签和背景图片区别](#img标签和背景图片区别)\r\n  - [元素(html标签)显示模式](#元素html标签显示模式)\r\n    - [块级元素](#块级元素)\r\n    - [行内元素](#行内元素)\r\n    - [行内块元素](#行内块元素)\r\n    - [css元素属性控制显示模式的相互转换](#css元素属性控制显示模式的相互转换)\r\n  - [css三大特性](#css三大特性)\r\n    - [继承性](#继承性)\r\n    - [层叠性](#层叠性)\r\n    - [优先级](#优先级)\r\n      - [多个基本选择器之间的的优先级](#多个基本选择器之间的的优先级)\r\n      - [多个复合选择器之间的优先级的权重的计算](#多个复合选择器之间的优先级的权重的计算)\r\n  - [标准流](#标准流)\r\n    - [标准流的概念](#标准流的概念)\r\n    - [标准流的局限性](#标准流的局限性)\r\n  - [浮动](#浮动)\r\n    - [浮动的作用](#浮动的作用)\r\n    - [浮动的特点](#浮动的特点)\r\n    - [浮动布局案例1实现](#浮动布局案例1实现)\r\n    - [浮动布局案例2实现(小米产品页)](#浮动布局案例2实现小米产品页)\r\n    - [浮动布局案例3实现(网页导航条)](#浮动布局案例3实现网页导航条)\r\n    - [清除浮动](#清除浮动)\r\n      - [设置行高法](#设置行高法)\r\n      - [添加额外标签清除法；](#添加额外标签清除法)\r\n      - [单伪元素清除法](#单伪元素清除法)\r\n      - [双伪元素清除法](#双伪元素清除法)\r\n      - [overflow属性清除](#overflow属性清除)\r\n  - [去除列表默认符号](#去除列表默认符号)\r\n  - [定位](#定位)\r\n    - [网页常见布局方式](#网页常见布局方式)\r\n    - [定位的使用步骤](#定位的使用步骤)\r\n    - [相对定位](#相对定位)\r\n    - [绝对定位](#绝对定位)\r\n      - [绝对定位的居中](#绝对定位的居中)\r\n    - [绝对定位fixed](#绝对定位fixed)\r\n    - [修改定位元素的层级关系](#修改定位元素的层级关系)\r\n      - [元素的层级关系](#元素的层级关系)\r\n      - [z-index](#z-index)\r\n  - [文字的垂直对齐](#文字的垂直对齐)\r\n    - [概念](#概念)\r\n    - [行内块元素的基线、底线、顶线、中线的概念](#行内块元素的基线底线顶线中线的概念)\r\n    - [实测效果](#实测效果)\r\n    - [文本框和按钮的中线对齐](#文本框和按钮的中线对齐)\r\n    - [图片和按钮框的中线对齐](#图片和按钮框的中线对齐)\r\n    - [嵌套关系的div和文本框的顶对齐](#嵌套关系的div和文本框的顶对齐)\r\n    - [嵌套关系的div和img的中线对齐](#嵌套关系的div和img的中线对齐)\r\n      - [情形1](#情形1)\r\n      - [情形2](#情形2)\r\n    - [该属性的其他属性值](#该属性的其他属性值)\r\n  - [鼠标光标类型](#鼠标光标类型)\r\n  - [圆角边框](#圆角边框)\r\n  - [溢出内容显示效果](#溢出内容显示效果)\r\n  - [元素的隐藏](#元素的隐藏)\r\n  - [透明属性](#透明属性)\r\n  - [过渡](#过渡)\r\n  - [去除鼠标选中input-text后显示的默认边框](#去除鼠标选中input-text后显示的默认边框)\r\n  - [css3的书写顺序](#css3的书写顺序)\r\n    - [编写思路](#编写思路)\r\n    - [使浏览器加载更快的书写顺序](#使浏览器加载更快的书写顺序)\r\n    - [正确书写顺序使浏览器加载更快的原因](#正确书写顺序使浏览器加载更快的原因)\r\n  - [html嵌套原则](#html嵌套原则)\r\n  - [vscode的emment插件语法（自带插件）](#vscode的emment插件语法自带插件)\r\n  - [pxcook像素大厨的基本使用](#pxcook像素大厨的基本使用)\r\n\r\n\r\n## css简介\r\n* CSS: **Cascading Style sheets 层叠样式表**\r\n* 注释格式: `/* css的唯一注释格式 */`\r\n* 语法格式: `选择器{属性:属性值;}`\r\n\r\n## 引入方式\r\n- [内嵌式](#内嵌式)\r\n- [外联式](#外联式)\r\n- [行内式](#行内式)\r\n\r\n### 内嵌式\r\n* 写在style标签中\r\n* 虽然style标签可以写在任意位置，但**一般约定style标签写在head标签中的title标签下**\r\n    ```html\r\n    <head>\r\n        <title>Document</title>\r\n        <style>\r\n            p{  \r\n                color: red;\r\n                background-color: green;\r\n                font-size: 30px;\r\n                width: 500px;\r\n                height: 500px;\r\n            }\r\n        </style>\r\n        <link rel=\"stylesheet\" href=\"path/to/file.css\">\r\n    </head>\r\n    ```\r\n* 使用场景：小案例\r\n* 作用范围：**当前页面**\r\n    \r\n### 外联式\r\n* 写在一个单独的.css文件中\r\n* 需要用link标签引入\r\n    ```html\r\n    <!-- rel=>relation关系 stylesheet指定是css-->\r\n    <!-- href=>路径 -->\r\n        <link rel=\"stylesheet\" href=\"path/to/file.css\">\r\n    ```\r\n* 使用场景：大项目\r\n* 作用范围：**多个页面**\r\n    \r\n### 行内式\r\n* 直接写到标签的style属性中\r\n    ```html\r\n        <p style=\"color: white;\">qqq</p>\r\n    ```\r\n* 使用场景：一般配合js使用\r\n* 作用范围：**仅单个标签**\r\n\r\n## 选择器\r\n- [标签选择器](#标签选择器)\r\n- [类选择器](#类选择器)\r\n- [id选择器](#id选择器)\r\n- [通配符选择器](#通配符选择器)\r\n- [后代选择器](#后代选择器)\r\n- [子代选择器](#子代选择器)\r\n- [并集选择器](#并集选择器)\r\n- [交集选择器](#交集选择器)\r\n- [伪类选择器](#伪类选择器)\r\n- [结构伪类选择器](#结构伪类选择器)\r\n- [伪html元素选择器](#伪html元素选择器)\r\n\r\n\r\n### 标签选择器\r\n* 语法：`标签名{css属性名:属性值;}`\r\n* 特点：匹配到所有标签，无论嵌套关系多深\r\n\r\n\r\n### 类选择器\r\n* 语法：`.类名值{css属性名:属性值;}`\r\n* 特点：只作用于标签属性中`class=\"指定类名\"`的所有标签\r\n* 注意：\r\n    * 所有标签都可以有class属性\r\n    * **类名只能以数字字母下划线中划线组成且不能以数字或中划线开头。**\r\n    * 一个标签可有有多个类名`<div class=\"c1 c2\"></div>`\r\n    * 一个类选择器也可以选中多个类`.类名1 .类名2{css属性名:属性值;}`\r\n\r\n\r\n### id选择器\r\n* 语法：`#id属性值{css属性名:属性值;}`\r\n* 特点：只唯一作用于id属性为指定值的标签\r\n* 注意：\r\n    * 所有HTML标签都可以有id属性\r\n    * **id属性值只能以数字字母下划线中划线组成且不能以数字或中划线开头。**\r\n    * 按规定id属性值在单个页面中是唯一的\r\n    * 一个标签只能有一个id属性值\r\n    * 一个id选择器只能选中一个标签\r\n    * id选择器一般配合js使用\r\n\r\n\r\n### 通配符选择器\r\n* 语法：`*{css属性名:属性值;}`\r\n* 特点：作用于所有标签\r\n* 用法：清除标签的默认样式\r\n    * margin外边距 如h1标签就有默认外边距\r\n    * padding内边距\r\n    ```css\r\n    *{\r\n        margin:0;\r\n        padding:0;\r\n    }\r\n    ```\r\n\r\n### 后代选择器\r\n* 语法: `选择器1 选择器2{css属性名:属性值;}`\r\n* 特点：选择器之间用**空格**隔开\r\n* 注意：\r\n    * **后代包括 子代 孙代 重孙代**\r\n    * 单个选择器可以是上面四种基本选择器\r\n    * 可以跨代选择\r\n\r\n### 子代选择器\r\n* 语法：`选择器1>选择器2{css属性名:属性值;}`\r\n* 特点：选择器之间用 **>** 隔开\r\n* 注意：\r\n    * **子代选择器只能选择子代 不能选择孙代**\r\n\r\n### 并集选择器\r\n* 语法：`选择器1,选择器2{css属性名:属性值;}`\r\n* 特点：选择器之间用**逗号**隔开\r\n* 注意：\r\n    * **并集选择器中的单个选择器可以是上面两种复合选择器**\r\n    * **单个选择器可以一行写一个提高代码可读性**\r\n\r\n### 交集选择器\r\n* 语法 `选择器1选择器2{}`\r\n* 特点：交集选择器选择的是满足要求的一类标签 交集可能是空 可能有一个 可能有多个\r\n* 4种基本选择器两两排列组合的示例：\r\n    * 标签和类名的交集：`p.class1{}`\r\n    * 标签和id的交集`p#id1{}`\r\n    * 标签和通配符的交集：`p*{}` `*p{} `\r\n        * 似乎没有什么应用场景 *和p的交集就是p\r\n    * 类名和id的交集： `.class1#id1{}` `#id1.class1{}`\r\n    * 类和通配符的交集：`.class1*{}` `*.class1{}`\r\n        * 似乎没有什么应用场景 *和class1的交集就是class1\r\n    * id和通配符的交集：`#id1*{}` `*#id1{}`\r\n        * 同上；*和#id1的交集就是#id1\r\n* 注意：\r\n    * **交集选择器能且只能交两个基本选择器**\r\n    * 交集选择器的两个选择器一定是对两个不同HTML的标签选择器做交集 所以不要问h1和p的交集怎么写 不要问`h1p{}`这种写法浏览器能不能识别（你说你没问？好吧我问的...），这两个标签不可能有交集 但是类和类可以有交集`.class1.class2{}`这种写法浏览器能识别 `#id1#id2{}`这种写法浏览器也能识别\r\n    * 因为统配符选择器和任何选择器的交集都是这个选择器本身，所以实际中应该用不到\r\n\r\n### 伪类选择器\r\n* hover\r\n    * 语法：`选择器:hover{}`\r\n    * 作用：设置鼠标悬停在标签上时显示的样式\r\n    * 注意：任何标签都有伪类hover\r\n\r\n### 结构伪类选择器\r\n* 作用：根据HTML的元素结构关系查找元素\r\n* 优势：减少对HTML中类的依赖，利于代码整洁\r\n* 场景：常用于查找某父级选择器中的子元素\r\n* 语法：\r\n    * `选择器:first-child{}` 第一个元素\r\n    * `选择器:last-child{}` 最后一个元素\r\n    * `选择器:nth-child(n){}` 第n个的元素\r\n    * `选择器:nth-last-child(n){}` 最后第n个元素\r\n    * n的取值\r\n        * 数字：0、1、2、3.... (0会选不中任何元素)\r\n        * 公式：\r\n            * 偶数 `2n`  `even`\r\n            * 奇数 `2n+1` `2n-1` `odd`\r\n            * 前3个 `3-n`\r\n                * （n取0时得3 取1时得2 取2时得1 取3时的0 取4时得-1 以此类推 感觉可理解为是在一个for循环中n从0开始取值，公式就是元素下标要填写的内容）\r\n            * 后3个 `3+n`\r\n* 注意：\r\n    * 对于左浮动，要用last-child选中最后(右)一个元素\r\n    * 对于右浮动，要用first-child选中最后(左)一个元素\r\n```html\r\n<style>\r\n    li:first-child{\r\n        background-color: gold;\r\n    }\r\n    li:nth-child(2){\r\n        background-color: darkgrey;\r\n    }\r\n    .li-example:nth-child(3){\r\n        background-color: chocolate;\r\n    }\r\n</style>\r\n<ul>\r\n    <li class=\"li-example\">这是第1个li</li>\r\n    <li class=\"li-example\">这是第2个li</li>\r\n    <li class=\"li-example\">这是第3个li</li>\r\n    <li class=\"li-example\">这是第4个li</li>\r\n    <li class=\"li-example\">这是第5个li</li>\r\n</ul>\r\n\r\n```\r\n效果：![](./images/CSS3重学笔记/2022-06-08-10-37-10.png)\r\n\r\n\r\n### 伪html元素选择器\r\n* 伪元素是`CSS3`模拟出的HTML标签效果\r\n* 伪元素的`CSS`样式必须要有`content`属性,属性值可以为空(`content:\"\";`)\r\n* 伪元素默认是**行内元素(inline-block)**\r\n* 语法：\r\n    * `选择器::before{}` 在选中元素的内容的最开头添加的伪元素\r\n    * `选择器::after{}` 在选中元素的内容的最后添加的伪元素\r\n\r\n\r\n\r\n## 字体样式\r\n- [字体样式](#字体样式)\r\n    - [字体的大小属性](#字体的大小属性)\r\n    - [字体的粗细属性](#字体的粗细属性)\r\n    - [字体的倾斜属性](#字体的倾斜属性)\r\n    - [字体的family字体属性](#字体的family字体属性)\r\n    - [字体的复合属性](#字体的复合属性)\r\n    - [文字阴影属性](#文字阴影属性)\r\n\r\n### 字体的大小属性\r\n* 属性名：`font-size`\r\n* 取值：`数字+px`\r\n* 注意：\r\n    * 谷歌浏览器默认文字大小16px\r\n    * 必须加单位否则没有效果\r\n\r\n### 字体的粗细属性\r\n* 属性名：`font-weight`\r\n* 取值：\r\n    * 取关键字：\r\n        * `normal` 正常不加粗（默认）\r\n        * `bold`  加粗\r\n    * 取数字：\r\n        * 取`100~900`的整百数 *共九种取值*\r\n        * `400` 效果对应 `normal`\r\n        * `700` 效果对应 `bold`\r\n    * 注意：\r\n        * 并不是所有`字体`都有九种粗细\r\n        * 实际开发中主要用 `正常` 和 `加粗` 两种取值\r\n\r\n### 字体的倾斜属性\r\n* 属性名：font-style\r\n* 取值：\r\n    * normal 正常不倾斜（默认）\r\n    * italic 倾斜\r\n        * italic作形容词时译为“斜体的；仿意大利古书写体的”，作名词时译为“斜体字”\r\n* 所以可以用该属性把斜体标签变不倾斜`<em style=\"font-style:normal\">ggg</em>`\r\n\r\n### 字体的family字体属性\r\n* 属性名：`font-family`\r\n* 取值格式：`font-family:字体名1,字体名2,字体名3,字体系列名;`\r\n* 取值：\r\n    * `微软雅黑` windows默认\r\n    * `苹方` macOS默认\r\n    * 等...\r\n* 扩展：网页中一般采用**无衬线字体(sans-serif)**\r\n    * ![](./images/CSS3重学笔记/2022-06-05-08-41-07.png)\r\n* 示例：\r\n    ```css\r\n    div{\r\n        /* 按优先级选择可用的字体，如果没有两种字体都没有则使用任意一种无衬线字体(sans-serif) */ \r\n        font-family:微软雅黑,黑体,sans-serif;\r\n    }\r\n    ```\r\n\r\n### 字体的复合属性\r\n* 属性名：`font`\r\n* 取值格式：font:style weight size family;\r\n    * 示例：`font: italic bold 16px 微软雅黑;`\r\n* 这个属性只能省略前两个值，省略表示设置为默认值\r\n* 这种一个属性后有多个值的称为复合属性\r\n\r\n## 文本样式\r\n- [文本样式](#文本样式)\r\n    - [文本缩进属性](#文本缩进属性)\r\n    - [文本水平对齐方式属性](#文本水平对齐方式属性)\r\n    - [文本修饰线属性](#文本修饰线属性)\r\n    - [文本行高属性](#文本行高属性)\r\n    - [文字阴影属性](#文字阴影属性)\r\n\r\n### 文本缩进属性\r\n* 属性名`text-indent`\r\n* 取值：\r\n    * `数字+px`\r\n    * `数字+em` (推荐)\r\n        * `1em`=当前标签的`font-size`大小\r\n\r\n### 文本水平对齐方式属性\r\n* 属性名`text-align`\r\n* 取值\r\n    * `left`\r\n    * `center`\r\n    * `right`\r\n* 注意\r\n    * 可以作用于该标签的内容 不光是作用于文字\r\n    * 要让`img`这种单标签居中 需要设置其父元素的`text-indent`属性\r\n\r\n### 文本修饰线属性\r\n* 属性名：`text-decoration`\r\n* 取值：\r\n    * `underline` 下划线\r\n    * `line-through` 删除线\r\n    * `overline` 上划线\r\n    * `none` 无装饰线\r\n* 注意：\r\n    * 开发中会用`text-decoration:none`清除超链接的下划线\r\n\r\n\r\n### 文本行高属性\r\n* 属性名：`line-height`\r\n* 取值：\r\n    * 数字+px\r\n    * 倍数可以是小数 （当前标签的font-size的倍数）\r\n* 可以写到font中\r\n    * 格式：`font: [style weight] size[/line-height] family;`\r\n    * 示例：`font: italic 700 66px/2 微软雅黑;`\r\n* 行高![](./images/CSS3重学笔记/2022-06-05-12-38-53.png)\r\n\r\n### 文字阴影属性\r\n* 属性名：`text-shadow`\r\n* 语法 `text-shadow: 水平偏移px 垂直偏移px 模糊程度px 颜色;`\r\n* 取值：\r\n    * 水平偏移h-shadow 必须\r\n    * 垂直偏移x-shadow 必须\r\n    * 模糊程度blur 模糊的程度 可选\r\n    * 颜色color 阴影颜色 可选\r\n* 示例效果：\r\n    * ![](./images/CSS3重学笔记/2022-06-12-15-25-18.png)\r\n    * ![](./images/CSS3重学笔记/2022-06-12-15-38-06.png)\r\n    * ![](./images/CSS3重学笔记/2022-06-12-15-38-14.png)\r\n* js语法:`object.style.textShadow=\"2px 2px #ff0000\"`\r\n\r\n\r\n### 文字外边框\r\n语法: `text-stroke：[ text-stroke-width ] || [ text-stroke-color ]`\r\n\r\n## 盒子模型\r\n- [简介](#简介)\r\n- [盒子模型各组成部分的设置](#盒子模型各组成部分的设置)\r\n    - [内容区域content](#内容区域content)\r\n    - [内边距区域padding](#内边距区域padding)\r\n    - [边框区域border](#边框区域border)\r\n    - [外边距区域margin](#外边距区域margin)\r\n- [盒子模型的外边距margin的合并问题](#盒子模型的外边距margin的合并问题)\r\n- [盒子模型的外边距margin的塌陷问题](#盒子模型的外边距margin的塌陷问题)\r\n- [盒子模型行内元素的padding和margin问题](#盒子模型行内元素的padding和margin问题)\r\n- [盒子模型实现指定尺寸的方法](#盒子模型实现指定尺寸的方法)\r\n- [清除默认内外边距](#清除默认内外边距)\r\n- [margin和text-align实现水平居中的区别](#margin和text-align实现水平居中的区别)\r\n- [案例实现](#案例实现)\r\n    - [新浪首页导航条实例编写](#新浪首页导航条实例编写)\r\n    - [新闻列表案例实现](#新闻列表案例实现)\r\n\r\n### 简介\r\n* css中规定每个盒子分别由\r\n    * **内容区域content**，\r\n    * **内边距区域padding**，\r\n    * **边框区域border**，\r\n    * **外边距区域margin**构成 这就是**盒子模型**\r\n* 页面中每一个标签都可看作是一个盒子，方便布局\r\n* 浏览器渲染时将网页中元素看成矩形区域，我们形象的称为盒子\r\n![](./images/CSS3重学笔记/2022-06-07-12-11-21.png)\r\n![](./images/CSS3重学笔记/2022-06-07-13-30-00.png)\r\n![](./images/CSS3重学笔记/2022-06-07-13-39-11.png)\r\n\r\n### 盒子模型各组成部分的设置\r\n#### 内容区域content\r\n* 通过width height属性控制，单位px\r\n\r\n#### 内边距区域padding\r\n* 通过padding属性控制\r\n* 语法格式：\r\n    * `padding: 上 右 下 左;`\r\n    * `padding: 上 左右 下;`\r\n    * `padding: 上下 左右;`\r\n    * `padding: 上下左右边距;`\r\n    * 上述四种写法的规律就是，从上开始顺时针依次赋值，没有赋到值的就看其对面的值\r\n\r\n#### 边框区域border\r\n* 通过border属性控制\r\n    * 这是一个复合属性\r\n    * 属性值**不分先后顺序**，**任意一个都不能省略**\r\n    * 语法1：`border:宽度 线条种类 颜色;`\r\n        * 宽度：数字+px\r\n        * 线条种类 solid实线 dashed虚线 dotted点线\r\n    * 语法2：`border-方位名词:宽度 线条种类 颜色;`\r\n        * 方位名词： \r\n            * `top`\r\n            * `bottom` \r\n            * `left` \r\n            * `right`\r\n    * 语法3(不常用)：\r\n        * `border-width:宽度;` \r\n        * `border-style:线条种类;` \r\n        * `border-color:颜色;`\r\n    * 语法4(不常用)：\r\n        * `border-width:上宽度 右宽度 下宽度 左宽度;` \r\n        * `border-style:上线条种类 右线条种类 下线条种类 左线条种类;`\r\n        *  `border-color:上颜色 右颜色 下颜色 左颜色;`\r\n\r\n#### 外边距区域margin\r\n* 通过`margin`属性控制\r\n* 语法格式同padding\r\n*版心居中：`margin:0 auto; `\r\n    版心：网页中的有效内容\r\n\r\n### 盒子模型的外边距margin的合并问题\r\n* **垂直布局**和**块级元素**，上盒子的下外边距会和下盒子的上外边距外边距同时设置，浏览器会自动取最大值。\r\n![](./images/CSS3重学笔记/2022-06-08-09-28-53.png)\r\n* 解决方法：只设置其中一个\r\n\r\n### 盒子模型的外边距margin的塌陷问题\r\n* **嵌套**的**块级元素**，子元素的margin-top会作用在父元素上\r\n![](./images/CSS3重学笔记/2022-06-08-09-56-12.png)\r\n* 解决方法\r\n    * 给父元素设置`border-top` 或 `padding-top` 可以达到预期效果\r\n    * 给父元素设置`overflow:hidden;` (应该是最优解)\r\n    * 转换成行内块元素`inline-block`\r\n    * 设置浮动\r\n    * 等...\r\n\r\n### 盒子模型行内元素的padding和margin问题\r\n* 对行内元素应用margin属性时，只有设置的左右外边距会起作用\r\n* 对行内元素应用padding属性时，只有设置的左右内边距会起作用\r\n* 解决方法：使用`line-height`属性设置\r\n* 总结：行内元素无法设置上下外边距和内边距，可以通过`line-height`设置\r\n\r\n\r\n### 盒子模型实现指定尺寸的方法\r\n* 一般情况下盒子整体尺寸会因border、padding的设置而被撑大，如设置width500px;border10px;padding10px;则整个盒子的宽度会从500px变成540px。\r\n* 解决方法1手动计算content的宽高\r\n    * 如果想要设置整体宽度width500px，border10px，padding10px，则应该设置width为500-10\\*2-10\\*2=460px\r\n* 解决方法2自动计算content的宽高\r\n    * 给盒子设置`box-sizing:border-box;`(**内减模式**)\r\n    * 浏览器会自动计算多出的大小，自动从content的width，height属性中减去\r\n\r\n\r\n### 清除默认内外边距\r\n* body标签默认有margin8px\r\n* p标签默认有上下margin\r\n* ul标签默认有margin和padding-left\r\n```css\r\n*{\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\n```\r\n\r\n### margin和text-align实现水平居中的区别\r\n* `text-align` 指当前元素中内容的对其方式。\r\n    * 写法：`text-align:center;`\r\n    * 应用于**块级元素**\r\n* `margin` 是指当前元素的外边距 而当指定其上下外边距为0 左右外边距为自动时 表现为相对于父标签居中，**不会影响自身的内容**\r\n    * 写法：`margin:0px auto;`\r\n    * 应用于**块级元素**\r\n    * * 当元素设置为浮动时，左右`margin`设置为`auto`来居中元素的方式会失效\r\n\r\n### 案例实现\r\n#### 新浪首页导航条实例编写\r\n```html\r\n<style>\r\n    .nav{\r\n        width: 100%;\r\n        height: 40px;\r\n        border-top: 3px solid #ff8500;\r\n        border-bottom: 1px solid #edeef0;\r\n        background-color: white;\r\n    }\r\n    .nav-item{\r\n        width:auto;\r\n        height: 40px;\r\n        background-color: white;\r\n        display: inline-block;\r\n        text-decoration: none;\r\n        text-align: center;\r\n        color: #4c4c4c;\r\n        font-size: 12px;\r\n        line-height: 40px;\r\n        padding: 0 5px 0 5px;\r\n    }\r\n    .nav-item:hover{\r\n        background-color: #edeef0;\r\n        color: #ff8400;\r\n    }\r\n</style>\r\n<div class=\"nav\">\r\n    <a href=\"#\" class=\"nav-item\">首页</a>\r\n    <a href=\"#\" class=\"nav-item\">文字个数不应影响效果</a>\r\n    <a href=\"#\" class=\"nav-item\">新浪导航</a>\r\n    <a href=\"#\" class=\"nav-item\">新浪导航</a>\r\n</div>\r\n```\r\n**效果：**\r\n![](./images/CSS3重学笔记/2022-06-08-18-46-27.png)\r\n\r\n\r\n#### 新闻列表案例实现\r\n```html\r\n<style>\r\n    .news-Box *{\r\n        margin: 0;\r\n        padding: 0;\r\n        /* 所有标签自动内减内边距和border */\r\n        box-sizing: border-box;\r\n    }\r\n    .news-Box{\r\n        width: 500px;\r\n        height: 400px;\r\n        background-color: white;\r\n        border:1px solid #ccc;\r\n        padding: 20px 30px 0px;\r\n        margin: 50px auto;\r\n    }\r\n    .news-title{\r\n        border-bottom: 1px solid #ccc;\r\n        font-size: 30px;\r\n        line-height: 1;/*1倍字的大小，这样可以去除字的上下边距*/\r\n        padding: 10px 0;\r\n        color: black;\r\n    }\r\n    .news-items{\r\n        list-style: none;\r\n    }\r\n    .news-item{\r\n        height: 50px;\r\n        border-bottom: 1px dashed #ccc;\r\n        font-size: 20px;\r\n        line-height: 50px;\r\n        padding: 0 25px;\r\n    }\r\n    .news-item-link{\r\n        text-decoration: none;\r\n        color: #666;\r\n    }\r\n</style>\r\n<body>\r\n    <div class=\"news-Box\">\r\n        <h2 class=\"news-title\">最新文章/News</h2>\r\n        <ul class=\"news-items\">\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n            <li class=\"news-item\"><a class=\"news-item-link\" href=\"#\">北京招聘网页设计，平面设计，php开发</a></li>\r\n        </ul>\r\n    </div>\r\n</body>\r\n\r\n```\r\n效果：\r\n![](./images/CSS3重学笔记/2022-06-08-18-46-54.png)\r\n\r\n## 盒子阴影属性\r\n* 语法格式：`box-shadow:水平偏移px 垂直偏移px 模糊度px 阴影尺寸px inset(内阴影); `\r\n![](./images/CSS3重学笔记/2022-06-12-16-03-13.png)\r\n\r\n## 背景\r\n- [背景](#背景)\r\n    - [颜色的几种表示方式](#颜色的几种表示方式)\r\n    - [背景颜色属性](#背景颜色属性)\r\n    - [背景图片](#背景图片)\r\n    - [背景图片重复方式](#背景图片重复方式)\r\n    - [背景图片位置](#背景图片位置)\r\n    - [背景复合属性](#背景复合属性)\r\n    - [背景图大小](#背景图大小)\r\n    - [img标签和背景图片区别](#img标签和背景图片区别)\r\n\r\n\r\n### 颜色的几种表示方式\r\n* **关键字** `red` `green` `blue` `yellow` ...\r\n* **rgb表示法**\r\n    * 示例`rgb(255,255,255)`\r\n* **rgba表示法**\r\n    * `rgb`的取值范围0~255 \r\n    * a表示透明度;取值范围0~1 小数表示法 可以省略整数部分0.5写.5\r\n    * 示例`rgba(255,255,255,0.5)`\r\n* **十六进制表示法**\r\n    * `#ffffff`\r\n    * `#fff` 简写\r\n        * 注意是两位一组 其中一组中数字相同的才能简写 于是`#ff0066`可以写成`#f06`\r\n\r\n\r\n\r\n### 背景颜色属性\r\n* 属性名：`background-color`\r\n* 取值：`颜色名关键字` 、 `rgb` `rgba` `#十六进制`\r\n* 注意\r\n    * 背景色默认为透明\r\n        * `transparent`\r\n        * `rgba(XX,XX,XX,0)`\r\n    * 开发时可以设置背景色 辅助观察和理解元素间的尺寸和层叠关系\r\n\r\n### 背景图片\r\n* 属性名：`background-image`\r\n* 取值：`url(\"\")`\r\n* 示例：`background-image:url(\"./path/to/your/file.img\")`\r\n* 注意：\r\n    * `url`中可以用单引号 双引号 也可以都不用\r\n    * 图片为默认重复方式为水平和垂直方向重复（由如下属性控制）\r\n\r\n### 背景图片重复方式\r\n* 属性名：`background-repeat`\r\n* 取值：\r\n    * `repeat`  水平和垂直方向重复 （默认）\r\n    * `no-repeat` 不重复\r\n    * `repeat-x` 仅沿x轴重复\r\n    * `repeat-y` 仅沿y轴重复\r\n\r\n### 背景图片位置\r\n* 属性名：`background-position`\r\n* 使用格式：`background-position:水平方向 垂直方向;`\r\n* 取值：\r\n    * 取方位名词关键字 \r\n        * 水平： `right` `center` `left`\r\n        * 垂直： `top` `center` `bottom`\r\n    * 取坐标：\r\n        * 左上角为原点\r\n        * 水平方向坐标轴的增长方向为朝右\r\n        * 垂直方向坐标轴的增长方向为朝下\r\n        * 取具体数值+px 可以取负数表示反方向\r\n* 注意：\r\n    * 两种取值方式 可以混合使用\r\n    * `background-position:center center;`可以简写成`background-position:center;`\r\n\r\n### 背景复合属性\r\n* 属性名： `background`\r\n* 标准书写格式：`background:color image repeat position`\r\n* 注意：\r\n    * 四个取值不分先后顺序、随意省略\r\n    * 最后一个取值`position`其实由两个值组成，分为水平方向和垂直方向，当取关键字时可以颠倒顺序，当取数值时不能颠倒顺序\r\n    * 所以当盒子大小和背景图片一致时可直接简写为`background: url();`\r\n\r\n### 背景图大小\r\n* 语法: `background-size:宽度 高度;`\r\n* 取值：\r\n    * 像素，数字+px\r\n    * 百分比，相对于当前盒子的宽高\r\n    * 包含 `contain` ，将背景图**等比例缩放**，直到某条边或框和盒子一致\r\n    * 覆盖 `cover` 将图片**等比例缩放**，直到刚好填满整个盒子\r\n* 可以连写到`background`属性中，语法为`background:color image repeat position/size;`\r\n* 效果示例\r\n    * ![](./images/CSS3重学笔记/2022-06-12-14-45-00.png)\r\n    * ![](./images/CSS3重学笔记/2022-06-12-14-45-55.png)\r\n\r\n\r\n### img标签和背景图片区别\r\n* `img`是一个HTML标签。不设置宽高以原尺寸显示；设置单个宽高图片以等比例缩放显示；同时设置宽高图片以不等比例缩放显示。\r\n* `background-img`是CSS样式。可以设置给div标签，但div必须设置宽高，如果不设置什么都不显示\r\n* 选用原则：**重要的用img 不重要的装饰性的用背景图**\r\n\r\n\r\n\r\n## 元素(html标签)显示模式\r\n- [块级元素](#块级元素)\r\n- [行内元素](#行内元素)\r\n- [行内块元素](#行内块元素)\r\n- [css元素属性控制显示模式的相互转换](#css元素属性控制显示模式的相互转换)\r\n\r\n### 块级元素\r\n* 特点\r\n    * **独占一行**\r\n    * **可以**设置宽高\r\n    * 宽度默认继承自父级元素\r\n* 代表元素： **div** **h系列** **p**  ul li dl dt dd form header nav footer\r\n\r\n### 行内元素\r\n* 特点\r\n    * **一行显示多个**\r\n    * **不可以**设置宽高(不生效)\r\n    * 宽度和高度默认由内容撑开\r\n* 代表元素\r\n    * **span** **a** b u i s strong ins em del\r\n\r\n### 行内块元素\r\n* 特点\r\n    * **一行可以显示多个**\r\n    * **可以**设置宽高\r\n* 代表标签\r\n    * **img** **input** textarea button select ...\r\n* 注意 img标签有行内块特点 但在Chrome调试工具中显示是inline\r\n\r\n### css元素属性控制显示模式的相互转换\r\n* 属性名：display\r\n* 可选值：\r\n    * **block** 块级元素 块元素**可以设置宽高** 使用频率**多**\r\n    * **inline** 行内元素 行内元素不可以设置宽高 使用频率少\r\n    * **inline-block** 行内块元素 行内块**可以设置宽高** 使用频率**多**\r\n\r\n## css三大特性\r\n- [继承性](#继承性)\r\n- [层叠性](#层叠性)\r\n- [优先级](#优先级)\r\n    - [多个基本选择器之间的的优先级](#多个基本选择器之间的的优先级)\r\n    - [多个复合选择器之间的优先级的权重的计算](#多个复合选择器之间的优先级的权重的计算)\r\n\r\n### 继承性\r\n* 子元素默认继承父元素\r\n* 自己有相关属性的不再从父元素继承\r\n    * a标签的文字颜色和下划线是浏览器给的默认颜色，不再从父元素继承。\r\n    * h标签的大小是默认属性，不再从父元素继承。\r\n* **只有文字控制属性才存在继承**\r\n* 如：\r\n    * color文字颜色 \r\n    * font系列（font-style font-weight font-size font-family）\r\n    * text系列（text-indent text-align）\r\n    * line-height行高\r\n    * 等\r\n\r\n### 层叠性\r\n* 给标签设置不同的属性，样式会**叠加**\r\n    * 样式叠加：`div{color:red;font-size:10px;}`\r\n* 给标签设置相同的属性，样式会**覆盖**，覆盖的原则为先写的被后写的覆盖\r\n    * 最终为绿色：`div{color:red;color:green;}`\r\n* 样式冲突时，只有当选择器**优先级相同**时才能通过层叠性判断结果\r\n    * 大概解释成，单个选择器内的样式冲突时，可以根据层叠性判断，多个选择器之间样式冲突时，必须要优先级相同才能根据层叠性判断。\r\n\r\n### 优先级\r\n#### 多个基本选择器之间的的优先级\r\n* 不同的选择器有不同的优先级\r\n* 优先级高的选择器样式**覆盖**优先级低的选择器样式\r\n* 优先级关系\r\n    * `继承<标签选择器<通配符选择器<类选择器<id选择器<行内样式<!important`\r\n    * 作用范围广的选择器优先级低\r\n    * 作用范围精确的选择器优先级高\r\n* 注意：\r\n    * `!important`写在属性值之后分号之前\r\n    * `!important`无法被继承\r\n    * 实际开发中不建议使用`!important`\r\n* 示例：最终颜色为pink![](./images/CSS3重学笔记/2022-06-07-10-52-21.png)\r\n\r\n#### 多个复合选择器之间的优先级的权重的计算\r\n* 如果使用复合选择器，需通过叠加计算方法，判断最终哪个选择器的优先级最高,优先级高的覆盖优先级低的。\r\n* 叠加公式：![](./images/CSS3重学笔记/2022-06-07-08-17-55.png)\r\n* 先比较各复合选择器优先级的第一级，值最大的选择器的优先级最高，如果无法得出最大值\r\n* 再比较各复合选择器优先级的第二级，值最大的选择器的优先级最高，如果无法得出最大值，以此类推\r\n* **如果都比较不出来，再根据层叠性确定**\r\n* **!inportant**优先级依然是最高\r\n+ 计算权重优先复合选择器的优先级的权重计算**示例**：\r\n    + 最终字的颜色为red![](./images/CSS3重学笔记/2022-06-07-10-25-40.png)\r\n    + 最终显示为天蓝色skyblue![](./images/CSS3重学笔记/2022-06-07-10-26-52.png)\r\n    + 最终为blue蓝色 ![](./images/CSS3重学笔记/2022-06-07-11-15-01.png)![](./images/CSS3重学笔记/2022-06-07-11-13-20.png)\r\n    + 最终为天蓝色![](./images/CSS3重学笔记/2022-06-07-11-11-50.png)\r\n    + 最终为pink![](./images/CSS3重学笔记/2022-06-07-11-17-43.png)![](./images/CSS3重学笔记/2022-06-07-11-18-07.png)\r\n    + 最终为黄色![](./images/CSS3重学笔记/2022-06-07-11-28-54.png)\r\n    + 最终为红色![](./images/CSS3重学笔记/2022-06-07-11-30-41.png)\r\n\r\n\r\n\r\n## 标准流\r\n- [标准流的概念](#标准流的概念)\r\n- [标准流的局限性](#标准流的局限性)\r\n\r\n### 标准流的概念\r\n* **标准流**也称**文档流**，是浏览器**渲染排版**网页的**默认规则**，规定了元素的**排列方式**\r\n* 常见**标准**排版规则\r\n    * `块级block` \r\n        * 独占一行，从上往下，**垂直布局**\r\n    * `行内inline`或`行内块inline-block` \r\n        * 空间不够换行，从左往右，**水平布局**\r\n\r\n### 标准流的局限性\r\n* 无法让多个块级元素显示在一行，\r\n* 无法让行内块元素完美显示在一行（会因为代码的换行而导致显示效果中产生间距）\r\n```html\r\n<style>\r\n    div{\r\n        display: inline-block;\r\n        width: 100px;\r\n        height: 100px;\r\n    }\r\n    .one{\r\n        background-color: pink;\r\n    }\r\n    .two{\r\n        background-color: green;\r\n    }\r\n</style>\r\n<body>\r\n    <div class=\"one\">div1</div>\r\n    <div class=\"two\">div2</div>\r\n</body>\r\n```\r\n* 显示效果：\r\n* ![](./images/CSS3重学笔记/2022-06-08-14-04-59.png)\r\n\r\n## 浮动\r\n- [浮动的作用](#浮动的作用)\r\n- [浮动的特点](#浮动的特点)\r\n- [浮动布局案例1实现](#浮动布局案例1实现)\r\n- [浮动布局案例2实现(小米产品页)](#浮动布局案例2实现小米产品页)\r\n- [浮动布局案例3实现(网页导航条)](#浮动布局案例3实现网页导航条)\r\n- [清除浮动](#清除浮动)\r\n    - [设置行高法](#设置行高法)\r\n    - [添加额外标签清除法；](#添加额外标签清除法)\r\n    - [单伪元素清除法](#单伪元素清除法)\r\n    - [双伪元素清除法](#双伪元素清除法)\r\n    - [overflow属性清除](#overflow属性清除)\r\n\r\n### 浮动的作用\r\n* **早期**用来做图文环绕\r\n    * 在文字中插入图片，然后给图片设置浮动属性\r\n* **现在**用来做网页布局\r\n    * 让多个标准流的块级元素渲染在一行\r\n        ```html\r\n        <style>\r\n            div{\r\n                display: inline-block;\r\n                width: 100px;\r\n                height: 100px;\r\n                float: left;\r\n            }\r\n            .one{\r\n                background-color: pink;\r\n            }\r\n            .two{\r\n                background-color: green;\r\n            }\r\n        </style>\r\n        <body>\r\n            <div class=\"one\">div1</div>\r\n            <div class=\"two\">div2</div>\r\n        </body>\r\n        ```\r\n    * 效果：![](./images/CSS3重学笔记/2022-06-08-14-22-31.png) \r\n\r\n### 浮动的特点\r\n* 浮动元素会**脱离标准流的控制**，简称脱标，在标准流中**不占位置**，其他非浮动元素会占领空出的位置\r\n* 浮动元素比标准流高半个等级，会覆盖标签不会覆盖内容\r\n    ![](./images/CSS3重学笔记/2022-06-08-14-55-38.png)\r\n* 浮动会顶对齐\r\n* 浮动找浮动，下一个浮动元素会在上一个浮动元素左右排列\r\n    ![](./images/CSS3重学笔记/2022-06-08-14-58-44.png)\r\n* 可以用margin控制布局\r\n  ![](./images/CSS3重学笔记/2022-06-08-15-09-04.png)\r\n\r\n\r\n* 浮动后的元素可以设置宽高，能在一行显示，具备行内块特点\r\n\r\n* 浮动后的元素不能通过margin:0 auto;方式居中，\r\n    * 可能是因为这种方式居中的原理是设置上下外边距为0，然后让浏览器根据当前标签的父标签的宽来自动auto计算当前标签的左右外边距实现居中，而当设置为浮动后，元素脱离了标准流，相当于没有父标签了，就没办法自动计算左右外边距了\r\n\r\n\r\n### 浮动布局案例1实现\r\n* 要求使用浮动\r\n    ![](./images/CSS3重学笔记/2022-06-08-15-41-03.png)\r\n* 写bug记录......\r\n    * 设置一个div版心居中时，记住要先给他加宽度，否则默认占父元素宽度的100%\r\n```html\r\n<style>\r\n    .nav{\r\n        height: 40px;\r\n        background-color: #333;\r\n    }\r\n    .head,\r\n    .content{\r\n        margin: 0 auto;\r\n    }\r\n    .head{\r\n        height: 100px;\r\n        width: 1226px;\r\n        background-color: #ffc0cd;\r\n    }\r\n    .content{\r\n        width: 1226px;\r\n        height: 460px;\r\n        background-color: red;\r\n    }\r\n    .left{\r\n        width: 234px;\r\n        height: 460px;\r\n        background-color: #ffa500;\r\n        float: left;\r\n    }\r\n    .right{\r\n        width: 992px;\r\n        height: 460px;\r\n        background-color: #87ceeb;\r\n        float: left;\r\n    }\r\n</style>\r\n<body>\r\n    <div class=\"nav\"></div>\r\n    <div class=\"head\"></div>\r\n    <div class=\"content\">\r\n        <div class=\"left\"></div>\r\n        <div class=\"right\"></div>\r\n    </div>\r\n</body>\r\n```\r\n效果：\r\n![](./images/CSS3重学笔记/2022-06-08-15-40-06.png)\r\n\r\n### 浮动布局案例2实现(小米产品页)\r\n![](./images/CSS3重学笔记/2022-06-08-16-51-05.png)\r\n```html\r\n<style>\r\n    *{\r\n        margin: 0;\r\n        padding: 0;\r\n    }\r\n    .box{\r\n        margin: 0 auto;\r\n        width: 1226px;\r\n        height: 614px;\r\n        background-color: red;\r\n    }\r\n    .left{\r\n        float: left;\r\n        width: 234px;\r\n        height: 614px;\r\n        background-color: #800080;\r\n    }\r\n    .right{\r\n        float: left;\r\n        width: 992px;\r\n        height: 614px;\r\n        background-color: white;\r\n    }\r\n    .item{\r\n        float: left;\r\n        margin: 0 0 14px 14px;\r\n        width: 234px;\r\n        height: 300px;\r\n        background-color: #87ceeb;\r\n    }\r\n    ul{\r\n        list-style: none;\r\n    }\r\n</style>\r\n<div class=\"box\">\r\n    <div class=\"left\"></div>\r\n    <div class=\"right\">\r\n        <ul>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n            <li class=\"item\"></li>\r\n        </ul>\r\n    </div>\r\n</div>\r\n```\r\n效果：\r\n![](./images/CSS3重学笔记/2022-06-08-16-51-39.png)\r\n\r\n\r\n### 浮动布局案例3实现(网页导航条)\r\n![](./images/CSS3重学笔记/2022-06-08-19-37-18.png)\r\n```html\r\n<style>\r\n    *{\r\n        margin: 0;\r\n        padding: 0;\r\n    }\r\n    .nav{\r\n        width: 640px;\r\n        height: 50px;\r\n        background-color: #ffc0cb;\r\n    }\r\n    .nav li{\r\n        /* 网站的导航条应该用li */\r\n        /* 根据li独占一行的特性判断其为block元素 */\r\n        float: left;\r\n    }\r\n    .nav .item{\r\n        display: block;\r\n        width: 80px;\r\n        height: 50px;\r\n        text-align: center;\r\n        font-size: 16px;\r\n        line-height: 50px;\r\n        color: white;\r\n        text-decoration: none;\r\n    }\r\n    .nav li:hover{\r\n        background-color: #008000;\r\n    }\r\n    ul{\r\n        list-style: none;\r\n    }\r\n</style>\r\n<div class=\"nav\">\r\n    <ul>\r\n        <li><a href=\"#\" class=\"item\">新闻1</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻2</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻3</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻4</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻5</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻6</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻7</a></li>\r\n        <li><a href=\"#\" class=\"item\">新闻8</a></li>\r\n    </ul>\r\n</div>\r\n```\r\n效果:\r\n![](./images/CSS3重学笔记/2022-06-08-20-14-11.png)\r\n\r\n### 清除浮动\r\n* 含义：清除浮动属性给其他标签带来的影响；\r\n* 当子元素浮动，子元素就不在标准流中，于是就不能撑开标准流的块级父元素，**如果父元素没有设置高度，子元素浮动后父元素的高度为0**，因为子元素浮动后不占位置；\r\n\r\n#### 设置行高法\r\n* 如果内容允许给父元素设置固定的高 就设置固定的高\r\n\r\n####  添加额外标签清除法；\r\n* 在父元素内容**最后**添加**块级元素**(一般类名为`clearfix`的div)，给添加的元素设置`clear:both;`\r\n* `clear属性`：专为解决此问题打造，取值为`left`时清除左浮动影响，取值为`right`时清除右浮动影响，取值为`both`时清除全部的影响。\r\n* 缺点：额外添加了标签，复杂化了HTML结构\r\n    ```html\r\n    <style>\r\n        .clearfix{\r\n            clear:both;\r\n        }\r\n    </style>\r\n    <div>\r\n        <div>浮动1</div>\r\n        <div>浮动2</div>\r\n        <div class=\"clearfix\"></div>\r\n    </div>\r\n    ```\r\n\r\n#### 单伪元素清除法\r\n* 先给父标签附加类名(clearfix),然后利用after伪元素\r\n* 优点；\r\n* 基本写法\r\n    ```css\r\n        .clearfix::after{\r\n            content:'';\r\n            display:block;\r\n            clear:both;\r\n        }\r\n    ```\r\n* 补充写法\r\n    ```css\r\n        .clearfix::after{\r\n            content:'';\r\n            display:block;\r\n            clear:both;\r\n            /* 多出的两行是为了解决低版本浏览器兼容性问题，某些浏览器(ie6、7、8)会认为伪元素有高度 */\r\n            height:0;\r\n            visibility:hidden;\r\n        }\r\n    ```\r\n\r\n#### 双伪元素清除法\r\n```css\r\n/* .clearfix::before,出现的目的在于解决外边距塌陷问题 */\r\n/* 塌陷问题的产生的情形是，嵌套的块级元素，这里把两个伪元素转换成table元素，就避免了这个问题 */\r\n.clearfix::before,\r\n.clearfix::after{\r\n    content:\"\";\r\n    display:table;\r\n}\r\n.clearfix::after{\r\n    clear:both;\r\n}\r\n```\r\n\r\n#### overflow属性清除\r\n* 直接给父元素设置属性`overflow:hidden;`\r\n* 优点：方便\r\n\r\n## 去除列表默认符号\r\n```css\r\nul{\r\n    list-style: none;\r\n}\r\n```\r\n效果对比：![](./images/CSS3重学笔记/2022-06-08-08-51-33.png)\r\n\r\n\r\n## 定位\r\n- [定位](#定位)\r\n    - [网页常见布局方式](#网页常见布局方式)\r\n    - [定位的使用步骤](#定位的使用步骤)\r\n    - [相对定位](#相对定位)\r\n    - [绝对定位](#绝对定位)\r\n        - [绝对定位的居中](#绝对定位的居中)\r\n    - [绝对定位fixed](#绝对定位fixed)\r\n    - [修改定位元素的层级关系](#修改定位元素的层级关系)\r\n        - [元素的层级关系](#元素的层级关系)\r\n        - [z-index](#z-index)\r\n    \r\n\r\n### 网页常见布局方式\r\n* 标准流： 块级元素垂直布局；行内/行内块元素水平布局\r\n* 浮动： 让块级元素水平布局\r\n* 定位\r\n    * 可以自由的让元素摆放在网页中任意位置\r\n    * 应用于盒子的层叠情况\r\n\r\n### 定位的使用步骤\r\n1. 设置定位方式\r\n    * 属性名 `position`\r\n    * 属性值 \r\n        * `static` 静态定位(默认，不定位)\r\n        * `relative` 相对定位\r\n        * `absolute` 绝对定位\r\n        * `fixed` 固定定位\r\n2. 设置偏移量\r\n    * 属性名 `top` `bottom` `left` `right` 水平和垂直方向各选其一\r\n    * 属性值 **像素** **百分比**\r\n\r\n### 相对定位\r\n* 相对于 **自己** 原先的位置移动\r\n* 不会改变元素显示模式\r\n* 仍然占有原先的位置(没有脱标)，空出的位置不会被其他元素占用\r\n* 不写偏移属性不改变位置\r\n* 同时写 left right 只有 left 会生效，无论顺序\r\n* 同时写 top bottom 只有 top 会生效，无论顺序\r\n```css\r\n.box{\r\n    /* 相对于自己原先位置移动10px */\r\n    position: relative;\r\n    top:10px;\r\n    left:10px;\r\n}\r\n```\r\n\r\n### 绝对定位\r\n* 相对于 **非静态定位** 的第一个 **父(祖宗)元素** 进行定位\r\n    * 如果其父元素有定位就相对于**父元素**定位\r\n    * 如果其父元素没有定位则相对浏览器窗口定位\r\n    * 父级可以是相对定位也可以是绝对定位，一般用相对定位;(**子绝父相**)\r\n* 会改变元素的显示模式，块元素会变行内元素\r\n* 不再占有原先位置(脱标),其他元素会填充该元素原先所在的位置![](./images/CSS3重学笔记/2022-06-10-17-19-54.png)\r\n* 当设置 `position: absolute;` 却不指定偏移时，元素保持原先位置(无论其父元素是不是静态定位)\r\n\r\n#### 绝对定位的居中\r\n* 设置绝对定位后不能使用`margin 0 auto;`方式居中\r\n* 解决办法1(手动计算)\r\n```css\r\n.box{\r\n    /* 绝对定位到父元素50%的位置，然后反方向移动宽高的一半 */\r\n    position: absolute;\r\n    left:50%;\r\n    top:50%;\r\n    margin-left: -250px;\r\n    margin-top: -150px;\r\n    width: 500px;\r\n    height: 300px;\r\n}\r\n```\r\n* 解决办法2(自动计算)\r\n```css\r\n.box{\r\n    /* 使用transform属性移动自身宽高的一半 */\r\n    position: absolute;\r\n    left:50%;\r\n    top:50%;\r\n    transform: translate(-50%,-50%);\r\n    width: 500px;\r\n    height: 300px;\r\n}\r\n```\r\n\r\n### 绝对定位fixed\r\n* 相对于**浏览器窗口**定位，不随滚动而位移\r\n* 会改变元素的显示模式，块元素变为行内块元素\r\n* 不再占有原先位置(脱标),其他元素会填充该元素原先所在的位置\r\n\r\n\r\n### 修改定位元素的层级关系\r\n\r\n#### 元素的层级关系\r\n* 不同**布局方式**元素的层级关系\r\n    + `标准流 < 浮动 < 定位`\r\n+ 不同**定位**之间的层级关系\r\n    + 相对、绝对、固定默认层级**相同**，会根据html标签代码的书写顺序（而不是css代码的书写顺序）来渲染，先渲染的会被后渲染的覆盖\r\n\r\n#### z-index\r\n+ 对于有定位属性的元素，想要要修改其渲染后的覆盖顺序，只需要调整html标签的顺序\r\n+ 如果不想修改html标签的顺序，可以使用`z-index:整数;`属性来控制，相当于指定其在第几图层。\r\n+ z-index只对有定位属性的元素生效\r\n+ 定位的默认层级是0\r\n\r\n\r\n\r\n## 文字的垂直对齐\r\n- [文字的垂直对齐](#文字的垂直对齐)\r\n    - [概念](#概念)\r\n    - [行内块元素的基线、底线、顶线、中线的概念](#行内块元素的基线底线顶线中线的概念)\r\n    - [实测效果](#实测效果)\r\n    - [文本框和按钮的中线对齐](#文本框和按钮的中线对齐)\r\n    - [图片和按钮框的中线对齐](#图片和按钮框的中线对齐)\r\n    - [嵌套关系的div和文本框的顶对齐](#嵌套关系的div和文本框的顶对齐)\r\n    - [嵌套关系的div和img的中线对齐](#嵌套关系的div和img的中线对齐)\r\n        - [情形1](#情形1)\r\n        - [情形2](#情形2)\r\n    - [该属性的其他属性值](#该属性的其他属性值)\r\n\r\n### 概念\r\n* 浏览器会将`行内元素`和`行内块元素`当成文字处理，默认的对齐方式是`基线对齐`\r\n* `块元素不会被当成文字处理。`\r\n\r\n### 行内块元素的基线、底线、顶线、中线的概念\r\n1. 顶线：**中文汉字**的的上端沿\r\n2. 中线：顶线和底线的中间线\r\n3. 基线:（base line）英文字母“x”的下端沿；\r\n4. 底线：**中文汉字**的下端沿\r\n![](./images/CSS3重学笔记/2022-06-11-17-24-43.png)\r\n\r\n### 实测效果\r\n* 没有文字时，按钮默认基线为下边缘，文本框的基线为文字输入区域下边缘\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-18-05.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-19-08.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-19-39.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-20-27.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-21-43.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-26-25.png)\r\n* 基线对齐不能实现完美对齐\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-28-18.png)\r\n\r\n### 文本框和按钮的中线对齐\r\n* `vertical-align: middle;`\r\n    ![](./images/CSS3重学笔记/2022-06-11-16-51-09.png)\r\n\r\n\r\n### 图片和按钮框的中线对齐\r\n* 默认基线对齐\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-39-33.png)\r\n\r\n* 修改后\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-40-16.png)\r\n\r\n### 嵌套关系的div和文本框的顶对齐\r\n* 修改前\r\n![](./images/CSS3重学笔记/2022-06-11-17-41-16.png)\r\n* 修改为顶对齐后\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-43-01.png)\r\n\r\n### 嵌套关系的div和img的中线对齐\r\n\r\n#### 情形1\r\n* 修改前:div高度为默认，img高度设置为400px,但由于浏览器默认是基线对齐，底部会被撑开一条线\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-56-38.png)\r\n* 解决办法\r\n    * 修改为中线对齐 \r\n    * **另一种解决方法是把img转换成块元素**\r\n* 效果：\r\n    ![](./images/CSS3重学笔记/2022-06-11-17-57-10.png)\r\n\r\n#### 情形2\r\n* 修改前：div拥有固定行高\r\n    ![](./images/CSS3重学笔记/2022-06-11-18-17-48.png)\r\n\r\n* 修改图片为中线对齐，同时在div中设置文字行高`line-height`为自身的高度，便可实现居中\r\n    ![](./images/CSS3重学笔记/2022-06-11-18-23-53.png)\r\n    ![](./images/CSS3重学笔记/2022-06-12-23-02-58.png)\r\n\r\n* 更进一步的，因为图片是行内块，所以要使图片水平方向居中，只需给父级元素添加text-aline:center\r\n    ![](./images/CSS3重学笔记/2022-06-11-18-25-34.png)\r\n    ![](./images/CSS3重学笔记/2022-06-11-18-25-45.png)\r\n\r\n### 该属性的其他属性值\r\n1. 基线对齐（vertical-align : baseline）使元素的基线同基准元素（取行高最高的作为基准）的基线对齐\r\n2. 顶端对齐（vertical-align : top）是将元素的行内框的顶端与行框的顶端对齐\r\n3. 底端对齐（vertical-align : bottom）与顶端对齐（vertical-align : top）相反\r\n4. 中间对齐（vertical-align : middle）通常使用在图片上，将图片的垂直方向的中线与文本行的中线（文字元素的行内框中线）对齐。\r\n5. 文本顶端对齐（vertical-align : text-top）是将元素行内框的顶端同行框的顶线对齐\r\n6. 文本底端对齐（vertical-align : text-bottom）是将元素行内框的底端同行框的底线对齐\r\n7. 上标（vertical-align:super）使元素的基线相对于基准元素的基线升高；\r\n8. 下标（vertical-align:sub）使元素的基线降低，移动的幅度CSS规范中没有规定，由浏览器来决定。\r\n\r\n\r\n## 鼠标光标类型\r\n* 属性名cursor\r\n* 属性值\r\n    * default 默认鼠标箭头\r\n    * pointer 小手\r\n    * text 工字形光标\r\n    * move 十字光标\r\n\r\n## 圆角边框\r\n* 属性名 border-radius\r\n* 属性值\r\n    * 数字+px\r\n    * 百分比\r\n* 书写格式 \r\n    * `border-radius: 左上 右上 右下 左下;` ;\r\n    * 可以像padding一样的格式省略为只写一个值、两个值、三个值或写全四个值；\r\n* 取值含义\r\n    * ![](./images/CSS3重学笔记/2022-06-11-20-25-46.png)\r\n* 画正圆\r\n    * 对正方形设置该属性\r\n    * `border-radius:50%;` \r\n    * 该属性的值最大取50%\r\n    * 应用：头像![](./images/CSS3重学笔记/2022-06-11-20-43-03.png)\r\n* 画胶囊\r\n    * 对长方形设置该属性\r\n    * `border-radius:高度的一半;`\r\n    * 应用 ![](./images/CSS3重学笔记/2022-06-11-20-42-30.png)\r\n\r\n## 溢出内容显示效果\r\n* 属性名：overflow\r\n* 属性值：\r\n    * visible 溢出部分可见（默认）\r\n    * hidden 溢出部分隐藏\r\n    * scroll 无论是否溢出，显示滚动条\r\n    * auto 自动根据内容是否溢出而显示滚动条\r\n* 测试效果\r\n    * visible ![](./images/CSS3重学笔记/2022-06-11-20-55-39.png)\r\n    * hidden ![](./images/CSS3重学笔记/2022-06-11-20-56-48.png)\r\n    * scroll ![](./images/CSS3重学笔记/2022-06-11-20-57-48.png)\r\n    * auto ![](./images/CSS3重学笔记/2022-06-11-20-58-44.png)\r\n\r\n## 元素的隐藏\r\n* `visibility:hidden;`\r\n    * 不常用，\r\n    * 只是单纯隐藏，仍然**占用标准流**\r\n* `display:none;`\r\n    * 常用\r\n    * 隐藏后**不占**用标准流\r\n* 应用：子菜单：![](./images/CSS3重学笔记/2022-06-11-21-05-06.png)\r\n* 案例：\r\n    * 先设置其默认情况隐藏![](./images/CSS3重学笔记/2022-06-11-21-21-57.png)\r\n    * 再设置其鼠标悬停时的显示模式为块![](./images/CSS3重学笔记/2022-06-11-21-21-15.png)\r\n    * 效果![](./images/CSS3重学笔记/2022-06-11-21-22-18.png)\r\n\r\n## 透明属性\r\n属性名：opacity\r\n取值：0~1之间的数字；0表示完全透明，1表示完全不透明\r\n作用：控制元素的整体透明度（包括其文字、图片的内容）\r\n\r\n## 过渡\r\n* 让元素的样式慢慢变化，常配合hover使用\r\n* 语法:\r\n    * `transition: 属性名 时间s;`\r\n    * `transition: 属性名 时间s,属性名 时间s,属性名 时间s,属性名 时间s;`\r\n    * `transition: all 时间s;`\r\n* 注意点\r\n    *  默认状态 和 `hover` 状态**样式不同**，才能有过渡效果 \r\n    * `transition`属性给需要过渡的**元素本身**加 \r\n    * `transition`属性设置在不同状态中，效果不同的\r\n        1. 给默认状态设置，鼠标**移入移出都有过渡效果**\r\n        2.  给hover状态设置，鼠标**移入有过渡效果，移出没有过渡效果**\r\n* 示例\r\n```html\r\n    <style>\r\n    .test{\r\n            width: 100px;\r\n            height: 100px;\r\n            background-color: green;\r\n            /* transition: width 1s; */\r\n            /* transition: width 1s,background-color 1s; */\r\n            transition: all 1s;\r\n        }\r\n        .test:hover{\r\n            width: 200px;\r\n            background-color: red;\r\n        }\r\n    </style>\r\n    <div class=\"test\"></div>\r\n```\r\n效果：\r\n<style>\r\n.test{\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        /* transition: width 1s; */\r\n        /* transition: width 1s,background-color 1s; */\r\n        font-size:10px;\r\n        transition: all 1s;\r\n    }\r\n    .test:hover{\r\n        width: 200px;\r\n        background-color: red;\r\n        font-size:50px;\r\n    }\r\n</style>\r\n<div class=\"test\">文字</div>\r\n\r\n## 去除鼠标选中input-text后显示的默认边框\r\n* 设置属性：`outline:none;`\r\n* 去除前\r\n![](./images/CSS3重学笔记/2022-06-13-02-06-27.png)\r\n* 取出后\r\n![](./images/CSS3重学笔记/2022-06-13-02-05-32.png)\r\n\r\n## css3的书写顺序\r\n可以先按编写思略写，再按能使浏览器加载更快的书写顺序修改\r\n\r\n### 编写思路\r\n* 从外到内\r\n* 先宽高背景色\r\n* 再调节内容位置\r\n* 最后控制文字细节\r\n\r\n### 使浏览器加载更快的书写顺序\r\n1. （定位）\r\n2. 浮动 或 display\r\n3. 盒子模型相关属性\r\n    * width height \r\n    * background-color\r\n    * margin border padding \r\n4. 文字样式 font系列\r\n\r\n### 正确书写顺序使浏览器加载更快的原因\r\n* 该部分复制自CSDN\r\n* 正确的书写顺序\r\n    1. 定位属性：position display float left top right bottom overflow clear z-index\r\n    2. 自身属性：width height padding border margin background\r\n    3. 文字样式：font-family font-size font-style font-weight font-varient color\r\n    4. 文本属性：text-align vertical-align text-wrap text-transform text-indent text-decoration letter-spacing word-spacing white-space text-overflow\r\n    5. css3中新增属性：content box-shadow border-radius transform……\r\n\r\n* 目的：减少浏览器reflow（回流），提升浏览器渲染dom的性能\r\n\r\n* 原理：浏览器的渲染流程为——\r\n    1. 解析html构建dom树，解析css构建css树：将html解析成树形的数据结构，将css解析成树形的数据结构\r\n    2. 构建render树：DOM树和CSS树合并之后形成的render树。\r\n    3. 布局render树：有了render树，浏览器已经知道那些网页中有哪些节点，各个节点的css定义和以及它们的从属关系，从而计算出每个节点在屏幕中的位置。\r\n    4. 绘制render树：按照计算出来的规则，通过显卡把内容画在屏幕上。\r\n    * css样式解析到显示至浏览器屏幕上就发生在②③④步骤，可见浏览器并不是一获取到css样式就立马开始解析而是根据css样式的书写顺序将之按照dom树的结构分布render样式，完成第②步，然后开始遍历每个树结点的css样式进行解析，此时的css样式的遍历顺序完全是按照之前的书写顺序。在解析过程中，**一旦浏览器发现某个元素的定位变化影响布局，则需要倒回去重新渲染**，正如按照这样的书写书序：\r\n        ```css\r\n            width: 100px;\r\n            height: 100px;\r\n            background-color: red;\r\n            position: absolute;\r\n        ```\r\n    * 当浏览器解析到position的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染，解除该元素在文档中所占位置，然而由于该元素的占位发生变化，其他元素也可能会受到它回流的影响而重新排位。最终导致③步骤花费的时间太久而影响到④步骤的显示，影响了用户体验。\r\n    * 所以规范的的css书写顺序对于文档渲染来说一定是事半功倍的！ \r\n\r\n\r\n\r\n## html嵌套原则\r\n* ![](./images/CSS3重学笔记/2022-06-06-09-32-35.png)\r\n* 块级元素一般作为大容器，\r\n    * 可以嵌套：\r\n        * 块级元素\r\n        * 行内元素 行内块元素 （这两个只能嵌套行内和行内块元素）\r\n    * **但p标签禁止嵌套div p h等标签**\r\n    * **h和p禁止互相嵌套**\r\n* a标签可以嵌套任意标签\r\n    * 但不要a标签嵌套a标签\r\n\r\n\r\n\r\n## vscode的emment插件语法（自带插件）\r\n![](./images/CSS3重学笔记/2022-06-05-17-40-04.png)\r\n* div+类名 div.class1\r\n* p+id p#id\r\n* a+id+类名 a.id1#class1\r\n* 同级标签 a+p\r\n* 嵌套标签 ul>li\r\n* 多个 ul*3>li*3\r\n* 内容 ul*3>li{$}*3\r\n* css\r\n    * css提示规律\r\n        * 按首字母提示\r\n    w300+h200+bgc\r\n\r\n## pxcook像素大厨的基本使用\r\n* 写网页的测量工具\r\n"},{"shortInfo":{"title":"C语言实现简易辅助复习单词小程序","date":"2022-04-22T16:14:32.000Z","cover":"\\self_server\\assets\\images\\C语言实现简易辅助复习单词小程序\\default_cover2.jpg","tags":["C","背单词","demo"],"categories":"笔记","hideAtIndex":true,"id":1836521732,"countWords":47,"readSeconds":4.7,"assetsbaseUrl":"/self_server/assets/"},"content":"## 使用演示\r\n![使用演示](./images/C语言实现简易辅助复习单词小程序/录制_2022_04_23_00_14_32_683.gif)\r\n\r\n## 主程序\r\n[主程序](./uploads/main.exe)\r\n\r\n## 源代码\r\n[源代码](./uploads/main.c)\r\n"},{"shortInfo":{"title":"ES6-ES11新特性学习笔记","date":"2022-09-04T04:00:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["ES6","javaScript"],"hideAtIndex":true,"categories":"笔记","id":7,"countWords":7032,"readSeconds":703.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# ES6-ES11新特性学习笔记\r\n## 目录\r\n- [ES6-ES11新特性学习笔记](#es6-es11新特性学习笔记)\r\n  - [目录](#目录)\r\n  - [概念](#概念)\r\n  - [ES6-let](#es6-let)\r\n  - [ES6-const](#es6-const)\r\n  - [ES6-解构赋值](#es6-解构赋值)\r\n  - [ES6-模板字符串](#es6-模板字符串)\r\n  - [ES6-简化对象写法](#es6-简化对象写法)\r\n  - [ES6-箭头函数](#es6-箭头函数)\r\n  - [ES6-函数形式参数初值](#es6-函数形式参数初值)\r\n  - [ES6-函数的rest剩余参数(...)](#es6-函数的rest剩余参数)\r\n  - [ES6-spread扩展运算符(...)](#es6-spread扩展运算符)\r\n  - [ES6-Symbol](#es6-symbol)\r\n  - [ES6-迭代器(Iterator)](#es6-迭代器iterator)\r\n  - [ES6-生成器](#es6-生成器)\r\n  - [ES6-Promise](#es6-promise)\r\n  - [ES6-Set集合](#es6-set集合)\r\n  - [ES6-Map](#es6-map)\r\n  - [ES6-Class](#es6-class)\r\n  - [ES6-新的数值方法](#es6-新的数值方法)\r\n  - [ES6-新的对象方法](#es6-新的对象方法)\r\n  - [ES6-模块化](#es6-模块化)\r\n  - [ES7-新运算符`**`](#es7-新运算符)\r\n  - [ES7-数组对象新方法`listA.includes()`](#es7-数组对象新方法listaincludes)\r\n  - [ES8-`async`/`await`](#es8-asyncawait)\r\n  - [ES8-`Obj.eys()`/`values()`/`entries()`](#es8-objeysvaluesentries)\r\n  - [ES9-针对于对象的`...`扩展运算符](#es9-针对于对象的扩展运算符)\r\n  - [ES9-正则-提取内容新方法](#es9-正则-提取内容新方法)\r\n  - [ES9-正则-反向断言](#es9-正则-反向断言)\r\n  - [ES9-正则-dotAll模式](#es9-正则-dotall模式)\r\n  - [ES10-二维数组或Map转对象](#es10-二维数组或map转对象)\r\n  - [ES10-trimStart,trimEnd](#es10-trimstarttrimend)\r\n  - [ES10-flat,flatMap](#es10-flatflatmap)\r\n  - [ES10-`Symbol.prototype.description`](#es10-symbolprototypedescription)\r\n  - [ES11-类的私有属性](#es11-类的私有属性)\r\n  - [ES11-Promise.allSettled()](#es11-promiseallsettled)\r\n  - [ES11-`String.prototype.matchAll()`](#es11-stringprototypematchall)\r\n  - [ES11-`?.`可选链操作符](#es11-可选链操作符)\r\n  - [ES11-动态`import()`](#es11-动态import)\r\n  - [ES11-BigInt大整型](#es11-bigint大整型)\r\n  - [ES11-globalThis](#es11-globalthis)\r\n\r\n\r\n## 概念\r\n**用处**\r\n* 语法简洁 功能丰富\r\n* `vue` `react` 框架开发中大量使用ES6语法\r\n* 岗位要求\r\n\r\n\r\n## ES6-let\r\n**声明格式**\r\n```js\r\nlet a;\r\nlet a,b,c;\r\nlet a=1,b=2,c=3;\r\n```\r\n**特性:**\r\n**1.块级作用域**\r\n```js\r\nvar a=1\r\n{//for if\r\n    let a=2;\r\n}\r\nconsole.log(a);// 输出1\r\n```\r\n\r\n**2. 不存在变量提升**\r\n```js\r\n//var\r\nconsole.log(a) //a为undefine\r\nvar a=123\r\n\r\n//let\r\nconsole.log(a) //报错:声明错误\r\nlet a=123\r\n```\r\n\r\n**3. 不影响作用域链**\r\n```js\r\n{\r\n    let a=1;\r\n    function(){\r\n        console.log(a) //能正常访问a\r\n    }\r\n}\r\n```\r\n\r\n**4. 不能重复声明**\r\n```js\r\nlet a=1;\r\nlet b=2;\r\n```\r\n\r\n**案例**\r\n```js\r\nfor(var i=0;i<10;i++)\r\n{\r\n    items[i].onclick = function(){\r\n        console.log(i)//i的值始终为10\r\n    }\r\n}\r\n\r\nfor(let i=0;i<10;i++)\r\n{\r\n    items[i].onclick = function(){\r\n        console.log(i)//i的值为其所在循环的值\r\n    }\r\n}\r\n```\r\n\r\n\r\n## ES6-const\r\n**声明格式**\r\n```js\r\nconst TEST = \"123\"\r\n```\r\n\r\n**注意事项**\r\n1. 必须赋初值\r\n2. 一般常量名大写\r\n3. 常量值不能修改,但能对数组的元素或对象的属性值修改,因为常量指向的地址没有发生改变\r\n4. 是块级作用于 \r\n\r\n\r\n## ES6-解构赋值\r\n**数组的解构赋值**\r\n```js\r\nvar test = [1,2,3,4]\r\nvar [a,b,c,d] = test\r\nconsole.log(a)\r\nconsole.log(b)\r\nconsole.log(c)\r\nconsole.log(d)\r\n```\r\n\r\n**对象的解构赋值**\r\n```js\r\nvar test = {a:1,b:2,c:3}\r\nvar {a,b,c} = test\r\n\r\nconsole.log(a)\r\nconsole.log(b)\r\nconsole.log(c)\r\n```\r\n\r\n\r\n## ES6-模板字符串\r\n**语法**\r\n```js\r\nvar test =`这是一个用反引号包裹的字符串`\r\n```\r\n\r\n**特性**\r\n1. 内容中可直接换行\r\n2. 内容中可直接拼接变量\r\n    ```js\r\n    var str = \"hhhhhhhhhhhhh\"\r\n    var test =`\r\n    <ul>\r\n        <li>12313123</li>\r\n        <li>12313123</li>\r\n        <li>12313123</li>\r\n        <li>${str}</li>\r\n    </ul>\r\n    `\r\n    ```\r\n\r\n## ES6-简化对象写法\r\n**语法**\r\n```js\r\nvar test1=1,test2=2,test3=3;\r\n\r\nvar obj1={\r\n    test1:test1,\r\n    test2:test2,\r\n    test3:test3,\r\n    test4:function(){\r\n        console.log(\"hhh\")\r\n    }\r\n}\r\n\r\nvar obj2 ={//obj1 和 obj2 写法等效\r\n    test1,\r\n    test2,\r\n    test3,\r\n    test4(){\r\n        console.log(\"hhh\")\r\n    }\r\n}\r\n```\r\n\r\n## ES6-箭头函数\r\n**语法**\r\n```js\r\nvar test1 = function(){\r\n    console.log(\"123\")\r\n}\r\n\r\nvar test2 = ()=>{ //test1 和 test2 等效\r\n    console.log(\"123\")\r\n}\r\n\r\n```\r\n\r\n\r\n**特性**\r\n1. this是静态的，始终指向函数声明时所在作用域的this的值\r\n2. 不能作为构造函数来示例化对象\r\n3. 箭头函数内不能使用arguments变量\r\n4. 当形式参数只有一个时可以省略小括号\r\n5. 当代码体只有一条语句时可省略大括号，函数的返回值为语句v的返回值，且return也必须省略。\r\n   ```js\r\n   let pow = x => x*x\r\n   console.log(pow(2)) //4\r\n   ```\r\n\r\n**案例1**\r\n```js\r\nad.addEventListener(\"click\",function(){\r\n    //由于this指向window，将报错\r\n    // setTimeout(function(){\r\n    //     this.style.background = \"pink\" \r\n    // },1000)\r\n\r\n    setTimeout(()=>{\r\n        this.style.background = \"pink\" //this指向ad 不报错\r\n    },1000)\r\n})\r\n```\r\n\r\n**案例2:筛选偶数**\r\n```js\r\n//不使用箭头函数\r\nconst arr =[1,2,3,4,5,6,7]\r\nconst result = arr.filter(function(item){\r\n    if(item%2==0) return true\r\n    else return false;\r\n})\r\nconsole.log(result)\r\n\r\n\r\n\r\n//使用箭头函数\r\nconst arr =[1,2,3,4,5,6,7]\r\nconst result = arr.filter(item => item%2==0 )\r\nconsole.log(result)\r\n```\r\n\r\n**总结**\r\n箭头函数适合与this无关的回调：定时器，数组的方法回调\r\n箭头函数不适合与this有关的回调：事件回调，对象方法\r\n\r\n\r\n## ES6-函数形式参数初值\r\n**语法**\r\n```js\r\nfunction add(a=0,b=0,c=0){\r\n    return a+b+c\r\n}\r\n```\r\n\r\n**特性**\r\n1. 有默认值的形式参数位置靠后\r\n2. 可以和结构赋值结合使用\r\n\r\n```js\r\nfunction connect({host=\"1270.0.0.1\",username=\"root\",password=\"root\",port=3394}){\r\n    console.log(host)\r\n    console.log(username)\r\n    console.log(password)\r\n    console.log(port)\r\n}\r\n\r\nconnect({\r\n    host: \"localhost\",\r\n    username: \"root\",\r\n    password: \"root\",\r\n    port: \"3394\",\r\n})\r\n```\r\n\r\n\r\n## ES6-函数的rest剩余参数(...)\r\n\r\n```js\r\nfunction f1(a,b,c){\r\n    console.log(arguments) //arguments是伪数组,存有所有参数\r\n}\r\nf1(1,2,3,4,5,6)\r\n\r\n\r\nvar f2 = (a,b,c,...rest)=>{//(rest可以是其他变量名)\r\n    console.log(rest) //rest 是真的数组，存有剩余的参数\r\n}\r\nf2(1,2,3,4,5,6)\r\n```\r\n\r\n\r\n## ES6-spread扩展运算符(...)\r\n扩展运算符(...)会调用默认的 `Iterator` 接口\r\n\r\n**基本使用**\r\n```js\r\nvar list = [\"123\",\"321\",\"456\"]\r\n\r\nfun1(list) //等效于 fun1([\"123\",\"321\",\"456\"])\r\n\r\nfun2(...list) //等效于 fun2(\"123\",\"321\",\"456\")\r\n```\r\n\r\n**应用**\r\n1. 数组合并\r\n   ```js\r\n   const a=[1,2,3]\r\n   const b=[4,5,6]\r\n   const c=[...a,...b] //c:[1,2,3,4,5,6]\r\n   ```\r\n2. 数组拷贝\r\n   ```js\r\n   const a=[\"A\",\"B\",\"C\"]\r\n   const b=[...a]           //浅拷贝\r\n   ```\r\n\r\n3. 伪数组转换真数组\r\n   ```js\r\n   const divs = document.querrySelectorAll(\"div\")\r\n   const divArr = [...divs]\r\n   ```\r\n\r\n\r\n## ES6-Symbol\r\n**概念**\r\n* Symbol是ES6引入的新的数据类型,不能用 new 命令，因为其不是对象。\r\n* 表示独一无二的值,最大的用法是用来定义对象的唯一属性名\r\n* ES6 数据类型\r\n  * Number  \r\n  * String  \r\n  * Boolean  \r\n  * Object \r\n  * null \r\n  * undefined \r\n  * **Symbol**\r\n\r\n**特点**\r\n* 值唯一,用于解决命名冲突的问题\r\n* 不能与其他数据类型运算\r\n* 不能使用for in 遍历,但可以使用Reflect.ownkeys获取对象的所有键名\r\n\r\n**一些内置属性(共11个)**\r\n* Symbol.match\r\n* Symbol.isConcatSpreadable\r\n\r\n```js\r\nlet s1 = Symbol();\r\nlet s2 = Symbol(\"标志名称\");\r\nlet s3 = Symbol(\"标志名称\");        // s2 !=  s3\r\n\r\nlet s4 = Symbol.for(\"标志名称2\")    // 由.for()这种函数创建的symbol称为函数对象\r\nlet s5 = Symbol.for(\"标志名称2\")    // s4 == s5\r\n```\r\n\r\n\r\n**案例1**\r\n```js\r\nconst game = {\r\n    up : function(){ console.log(\"up\") },\r\n    down : function(){ console.log(\"down\") }\r\n}\r\nconst myMethods = {\r\n    up:Symbol(\"myUp\"),\r\n    down:Symbol(\"myDown\")\r\n}\r\n\r\n\r\ngame[myMethods.up] = function(){ console.log(\"myUp\") }\r\ngame[myMethods.down] = function(){ console.log(\"myDown\") }\r\n\r\nconsole.log(game)\r\n// 输出:\r\n// {\r\n//   up: [Function: up],\r\n//   down: [Function: down],\r\n//   [Symbol(myUp)]: [Function],\r\n//   [Symbol(myDown)]: [Function]\r\n// }\r\n```\r\n\r\n**案例2**\r\n```js\r\nconst game = {\r\n    up : function(){ console.log(\"up\") },\r\n    down : function(){ console.log(\"down\") },\r\n    [Symbol(\"myUp\")]:function(){ console.log(\"myUp\") }, //这样定义后似乎无法调用\r\n    [Symbol(\"myDown\")]:function(){ console.log(\"myDown\") },\r\n}\r\nconsole.log(game)\r\n\r\n// > console.log(game)\r\n// 输出:\r\n// {\r\n//   up: [Function: up],\r\n//   down: [Function: down],\r\n//   [Symbol(myUp)]: [Function: [myUp]],\r\n//   [Symbol(myDown)]: [Function: [myDown]]\r\n// }\r\n```\r\n\r\n## ES6-迭代器(Iterator)\r\n**主要用于遍历元素,实现原理和python中的yield类似**\r\n* 可自定义遍历数据\r\n* 迭代器提供的接口可供 `for [item] of [obj]` 使用\r\n* 原生具备迭代器接口的数据类型\r\n  * Arrary\r\n  * Arguments\r\n  * Set\r\n  * Map\r\n  * String\r\n  * TypedArray\r\n  * NodeList\r\n\r\n```js\r\nvar listA = [\"111\",\"222\",\"333\"]\r\n\r\n\r\n// let iterator = listA[Symbol.iterator]();\r\n// console.log(iterator.next())// next第一次指向第一个元素,第二次调用指向第二个元素...\r\n\r\n\r\nfor(let item of listA){\r\n    console.log(item) \r\n    //输出结果为\r\n    // \"111\"\r\n    // \"222\"\r\n    // \"333\"\r\n}\r\n\r\nfor(let key of listA){\r\n    console.log(key) \r\n    //输出结果为\r\n    // 0\r\n    // 1\r\n    // 2\r\n}\r\n```\r\n\r\n**自定义遍历数据**\r\n```js\r\nvar classA = {\r\n    name: \"1234班\",\r\n    students: [\r\n        \"小明\",\r\n        \"小红\",\r\n        \"小黄\",\r\n        \"小蓝\",\r\n        \"小绿\",\r\n        \"小白\",\r\n    ],\r\n    [Symbol.iterator]: function () {//不能使用剪头函数,否则this指向window\r\n        let index = 0;\r\n        return {\r\n            next: () => {\r\n                if (index < this.students.length) {\r\n                    return { value: this.students[index++], done: false }\r\n                } else {\r\n                    return { value: undefined, done: true }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfor (item of classA) {\r\n    console.log(item)\r\n}\r\n```\r\n\r\n\r\n## ES6-生成器\r\n**主要用于异步编程**\r\n\r\n**特性演示**\r\n```js\r\nfunction * test1(){\r\n    for (let index = 0; index < 100; index++) {\r\n        if(index%2==1)\r\n            yield index;\r\n    }\r\n}\r\n// const iterator = test1()\r\n    //test1()返回值是一个生成器对象\r\n\r\n// console.log(iterator.next());\r\n    // 输出:\r\n    // {value:1,done:false}\r\n\r\n// console.log(iterator.next().value);\r\n    // 输出:\r\n    // 1\r\n\r\nfor (item of test1()) {\r\n    console.log(item) \r\n    //输出:\r\n    // 1\r\n    // 3\r\n    // 5\r\n    // ... ...\r\n}\r\n```\r\n\r\n\r\n**参数传递**\r\n```js\r\nfunction * test2(arg1){\r\n    console.log(arg1)\r\n\r\n    var result = yield \"1111\"; \r\n    console.log(result)\r\n    \r\n    var result = yield \"2222\";\r\n    console.log(result)\r\n\r\n    var result = yield \"3333\";\r\n    console.log(result)\r\n}\r\n\r\nconst iterator = test2(\"AAA\")\r\n\r\nconsole.log(iterator.next(\"BBB\").value); // \"BBB\"将不会输出\r\nconsole.log(iterator.next(\"CCC\").value); //next的形式参数会作为前一个yield语句的返回值\r\nconsole.log(iterator.next(\"DDD\").value); //\"DDD\"将会作为 yield \"1111\" 的返回值\r\n```\r\n\r\n\r\n**异步编程案例**\r\n```js\r\nfunction A(){\r\n    setTimeout(() => {\r\n        console.log(\"111\");\r\n        iterator.next()\r\n    }, 1000);\r\n}\r\nfunction B(){\r\n    setTimeout(() => {\r\n        console.log(\"222\");\r\n        iterator.next()\r\n    }, 1000);\r\n}\r\nfunction C(){\r\n    setTimeout(() => {\r\n        console.log(\"333\");\r\n        iterator.next()\r\n    }, 1000);\r\n}\r\nfunction * test3(){\r\n    yield A()\r\n    yield B()\r\n    yield C()\r\n}\r\n\r\nconst iterator = test3()\r\n\r\niterator.next()\r\n//输出:\r\n// 111\r\n// 222\r\n// 333\r\n```\r\n\r\n\r\n**实际案例模拟**\r\n```js\r\nfunction getUserInfo(){\r\n    setTimeout(() => {\r\n        let UserInfo = \"用户信息\"\r\n        console.log(\"成功获取: \"+UserInfo);\r\n        iterator.next(UserInfo)\r\n    }, 1000);\r\n}\r\nfunction getOrders(){\r\n    setTimeout(() => {\r\n        let ordersInfo = \"用户订单\"\r\n        console.log(\"成功获取: \"+ordersInfo);\r\n        iterator.next(ordersInfo)\r\n    }, 1000);\r\n}\r\nfunction getGoods(){\r\n    setTimeout(() => {\r\n        let goodsInfo = \"订单商品\"\r\n        console.log(\"成功获取: \"+goodsInfo);\r\n        iterator.next(goodsInfo)\r\n    }, 1000);\r\n}\r\nfunction * test4(){\r\n    let UserInfo = yield getUserInfo() //获取用户信息\r\n    let ordersInfo = yield getOrders(UserInfo) //根据用户信息获取订单信息\r\n    let goodsInfo = yield getGoods(ordersInfo) //根据订单信息获取商品信息\r\n}\r\n\r\nconst iterator = test4()\r\niterator.next()\r\n    // 输出结果:\r\n    // 成功获取: 用户信息\r\n    // 成功获取: 用户订单\r\n    // 成功获取: 订单商品\r\n```\r\n\r\n\r\n## ES6-Promise\r\n**详细笔记见《Promise学习笔记》**\r\n\r\n**基本使用**\r\n```js\r\nconst a = new Promise((resolve,reject)=>{\r\n    setTimeout(()=>{\r\n        var data = \"从服务器获取数据\" \r\n        resolve(data)\r\n    },1000)\r\n}) \r\n\r\na.then(value=>{\r\n    console.log(value)\r\n},reason=>{\r\n    console.log(reason)\r\n})\r\n```\r\n\r\n## ES6-Set集合\r\nSet类型类似于数组,但其成员的值是唯一的,不会有重复的属性值  \r\nSet类型支持扩展运算符`...`  \r\nSet类型实现了 `iterator` 接口,可以通过 `for(A of B){}` 遍历\r\n**内置方法和属性**\r\n* size\r\n* add()\r\n* delete()\r\n* has()\r\n* clear()\r\n\r\n```js\r\nlet setA = new Set()\r\nconsole.log(setA) //Set(0){}\r\n\r\n\r\n// let setB = new Set(可迭代的数据)\r\nlet setB = new Set([1,2,3,4,5,6,7,7,7,7,7,\"8\"])\r\nconsole.log(setB) //Set(8){1,2,3,4,5,6,7,\"8\"}\r\n\r\n\r\nconsole.log(setB.size) //集合元素个数\r\nsetB.add(\"9\") //新增元素\r\nsetB.delete(\"9\") //删除元素\r\nsetB.has(1) //检测元素\r\n// setB.clear() //清空集合元素\r\n\r\nfor(item of setB){\r\n    console.log(item)\r\n}\r\n```\r\n\r\n\r\n**实用案例**\r\n```js\r\n// 数组去重\r\nvar listA = [1,2,3,4,5,6,7,8,1,1,1,2,2,2,3,3,3,4,4,4,5]\r\nvar result1 = [...new Set(listA)]\r\nconsole.log(result1);\r\n\r\n\r\n//交集运算\r\nvar ListB = [1,2,3,4,5,6,6,6,6,6]\r\nvar ListC = [4,5,6,7,8,9,9,9,9,9]\r\nvar result2 = [...new Set(ListB)].filter(item => ( new Set(ListC) ).has(item))\r\nconsole.log(result2)\r\n\r\n\r\n//并集运算\r\nvar ListD = [1,2,3,4,5,6,6,6,6,6]\r\nvar ListE = [4,5,6,7,8,9,9,9,9,9]\r\nvar result3 = [...new Set([...ListD,...ListE])]\r\nconsole.log(result3)\r\n\r\n\r\n//差集 \r\nvar ListF = [1,2,3,4,5,6,6,6,6,6]\r\nvar ListE = [4,5,6,7,8,9,9,9,9,9]\r\nvar result4 = [...new Set(ListF)].filter(item => !( new Set(ListE) ).has(item)) //F和E的差集\r\nvar result5 = [...new Set(ListE)].filter(item => !( new Set(ListF) ).has(item)) //E和F的差集\r\nconsole.log(result4)\r\nconsole.log(result5)\r\n```\r\n\r\n\r\n## ES6-Map\r\nMap类型类似于对象,是键值对的集合,但其\"键\"不只是字符串,各种数据类型甚至是对象都能作为\"键\"  \r\nMap类型支持扩展运算符`...`   \r\nMap类型实现了 `iterator` 接口,可以通过 `for(A of B){}` 遍历\r\n**内置方法和属性**\r\n* size\r\n* set(key,value)\r\n* get(key)\r\n* delete(key)\r\n* has(key)\r\n* clear()\r\n* ......\r\n\r\n\r\n```js\r\n// let MapA = new Map([[A,B],[C,D],[E,F]])\r\nlet MapA = new Map()\r\nconsole.log(MapA.set(\"123\",321))\r\nconsole.log(MapA.get(\"123\"))\r\nconsole.log(MapA.has(\"123\"))\r\nconsole.log(MapA.delete(\"123\"))\r\nconsole.log(MapA.clear())\r\n```\r\n\r\n\r\n## ES6-Class\r\n\r\n通过ES6的class关键字可以定义对象,但其绝大部分功能都可通过ES5的语法实现(构造函数,this关键字),新写法只是让其看起来更像面向对象编程\r\n\r\n**基本用法**\r\n```js\r\nclass Cat {\r\n    constructor(name, sex) {\r\n        this.name = name\r\n        this.sex = sex\r\n    }\r\n    bark() {\r\n        console.log(\"喵喵喵\")\r\n    }\r\n}\r\n\r\nnew Cat(\"小黄猫\", \"公猫\").bark() //输出: 喵喵喵\r\nconsole.log(new Cat(\"小黄猫\", \"公猫\").sex) //输出5\r\n```\r\n\r\n\r\n**static静态属性和成员**\r\n```js\r\n// **ES5原版写法**\r\n\r\n//构造函数\r\nfunction Dog(name, sex) {\r\n    this.name = name\r\n    this.sex = sex\r\n}\r\n//为构造函数对象添加方法/属性(静态属性)\r\nDog.age = 1\r\nDog.bark = function () {\r\n    console.log(\"汪汪汪~~~\")\r\n}\r\n//为实例对象添加方法/属性\r\nDog.prototype.age = 5\r\nDog.prototype.bark = function () {\r\n    console.log(\"汪汪汪\")\r\n}\r\n\r\nnew Dog(\"小白狗\", \"公狗\").bark() //输出: 汪汪汪\r\nDog.bark() //输出: 汪汪汪~~~\r\nconsole.log(new Dog(\"小白狗\", \"公狗\").age) //输出5\r\nconsole.log(Dog.age)// 输出1\r\n```\r\n\r\n\r\n```js\r\n// **ES6新版写法写法**\r\nclass Cat {\r\n    static age = 1;\r\n    static bark = function () {\r\n        console.log(\"喵喵喵~~~\")\r\n    }\r\n    constructor(name, sex) {\r\n        this.name = name\r\n        this.sex = sex\r\n        this.age = 5;\r\n    }\r\n    bark() {\r\n        console.log(\"喵喵喵\")\r\n    }\r\n}\r\n\r\nnew Cat(\"小黄猫\", \"公猫\").bark() //输出: 喵喵喵\r\nconsole.log(new Cat(\"小黄猫\", \"公猫\").age) //输出5\r\nCat.bark() //输出: 喵喵喵~~~\r\nconsole.log(Cat.age) //输出1\r\n```\r\n\r\n\r\n**继承**\r\n\r\n```js\r\n// ES5特性的继承\r\nfunction Phone(brand, prise) {\r\n    this.brand = brand\r\n    this.prise = prise\r\n}\r\nPhone.prototype.tele = function () {//为实例化后的对象添加方法\r\n    console.log(\"call......\");\r\n}\r\n\r\n\r\nfunction SmartPhone(brand, prise, size, color) {\r\n    Phone.call(this, brand, prise) // 初始化父级对象\r\n    this.size = size\r\n    this.color = color\r\n}\r\n\r\n// 设置子级构造函数原型\r\nSmartPhone.prototype = new Phone //使得SmartPhone的实例对象拥有Phone实例对象上的属性和方法\r\nSmartPhone.prototype.constructor = SmartPhone //使得SmartPhone的实例对象的构造函数是SmartPhone() 而不是Phone()\r\n\r\nSmartPhone.prototype.playGame = function () {//为实例化后的对象添加方法\r\n    console.log(\"playGame......\")\r\n}\r\n\r\nvar huawei = new SmartPhone(\"华为\", 4799, \"12-inch\", \"黑色\")\r\nhuawei.tele()\r\nhuawei.playGame()\r\n```\r\n\r\n```js\r\n// ES6特性的继承\r\nclass Phone {\r\n    constructor(brand, prise) {\r\n        this.brand = brand\r\n        this.prise = prise\r\n    }\r\n    call() {\r\n        console.log(\"call......\");\r\n    }\r\n}\r\nclass SmartPhone extends Phone {\r\n    constructor(brand, prise, size, color) {\r\n        super(brand, prise)\r\n        this.size = size\r\n        this.color = color\r\n    }\r\n    playGame() {\r\n        console.log(\"playGame......\")\r\n    }\r\n}\r\n\r\n\r\nvar huawei = new SmartPhone(\"花为\", 4799, \"12-inch\", \"黑色\")\r\nhuawei.call()\r\nhuawei.playGame()\r\n```\r\n\r\n**重写父类方法**\r\n```js\r\n// ES6特性的继承\r\nclass Phone {\r\n    constructor(brand, prise) {\r\n        this.brand = brand\r\n        this.prise = prise\r\n    }\r\n    call() {\r\n        console.log(\"call......\");\r\n    }\r\n}\r\nclass SmartPhone extends Phone {\r\n    constructor(brand, prise, size, color) {\r\n        super(brand, prise)\r\n        this.size = size\r\n        this.color = color\r\n    }\r\n    playGame() {\r\n        console.log(\"playGame......\")\r\n    }\r\n    call() {\r\n        console.log(\"call2......\");//重写父类的方法\r\n    }\r\n}\r\n\r\nvar huawei = new SmartPhone(\"花为\", 4799, \"12-inch\", \"黑色\")\r\nhuawei.call()\r\nhuawei.playGame()\r\n```\r\n\r\n**get与set**\r\n```js\r\nclass Phone {\r\n    constructor(brand, prise) {\r\n        this.brand = brand\r\n        this.prise = prise\r\n    }\r\n    get value(){\r\n        console.log(\"获取了价格\")\r\n        return this.prise\r\n    }\r\n    set value(value){\r\n        console.log(\"设置了价格\")\r\n        this.prise = value\r\n    }\r\n}\r\n\r\nvar xiaomi = new Phone(\"xiaomi\",999)\r\nconsole.log(xiaomi.value);\r\nconsole.log(xiaomi.value=0.01);\r\n```\r\n\r\n\r\n## ES6-新的数值方法\r\n\r\n**`Number.EPSILON`浮点数最小精度**\r\n```js\r\nconsole.log(Number.EPSILON); //2.220446049250313e-16   2.22*10^(-16) 是js浮点数的最小精度单位 ,用于比较浮点数是否相等\r\n\r\nfunction equal(a,b){\r\n    return Math.abs(a-b) < Number.EPSILON\r\n}\r\n\r\nconsole.log(0.1+0.2); // 输出 0.30000000000000004\r\nconsole.log(0.1+0.2 == 0.3); // 输出 false\r\nconsole.log(equal(0.1+0.2 , 0.3)); // 输出 true\r\n```\r\n\r\n**二进制,八进制,十六进制**\r\n```js\r\nvar b = 0b1111\r\nvar o = 0o7777\r\nvar d = 999999\r\nvar x = 0xffff\r\n\r\nconsole.log(b); //输出: 15\r\nconsole.log(o); //输出: 4095\r\nconsole.log(d); //输出: 999999\r\nconsole.log(x); //输出: 65535\r\n```\r\n\r\n**判断有限数**\r\n```js\r\nconsole.log(Number.isFinite(1));        //输出: true\r\nconsole.log(Number.isFinite(1/0));      //输出: false\r\nconsole.log(Number.isFinite(Infinity)); //输出: false\r\n```\r\n\r\n**判断非数**\r\n```js\r\n//在es5中isNaN()是一个单独的函数,在ES6中将其作为了Number对象的方法\r\nconsole.log(Number.isNaN(123)); //输出: false\r\nconsole.log(Number.isNaN(NaN)); //输出: true\r\n```\r\n\r\n**判断整数**\r\n```js\r\nconsole.log(Number.isInteger(123)); //输出: true\r\nconsole.log(Number.isInteger(123.123)); //输出: false\r\n```\r\n\r\n**字符串转数字**\r\n```js\r\n//在ES6中将其作为了Number对象的方法,之前是一个单独的函数\r\nconsole.log(Number.parseFloat(\"3.1415元\")); //输出: 3.1415\r\nconsole.log(Number.parseInt(\"3.1415元\")); //输出: 3\r\n```\r\n\r\n**抹掉小数部分**\r\n```js\r\nconsole.log(Math.trunc(3.1415)); //输出: 3\r\n```\r\n\r\n\r\n**sign()函数**\r\n```js\r\nconsole.log(Math.sign(100));    //输出: 1\r\nconsole.log(Math.sign(0));      //输出: 0\r\nconsole.log(Math.sign(-100));   //输出: -1\r\n```\r\n\r\n## ES6-新的对象方法\r\n\r\n**`Object.is()`判断两个值是否完全相等**\r\n```js\r\n        console.log(Object.is(123,123));        //输出: true\r\n        console.log(Object.is(\"123\",\"123\"));    //输出: true\r\n        console.log(Object.is(NaN,NaN));        //输出: true\r\n        console.log(123 === 123);               //输出: true\r\n        console.log(\"123\" === \"123\");           //输出: true\r\n        console.log(NaN === NaN);               //输出: false\r\n```\r\n\r\n**`Object.assign(a,b)`合并对象**\r\n```js\r\nconst defaultConfg = {\r\n    host:\"localhost\",\r\n    port:80,\r\n    username:\"admin\",\r\n    password:\"admin\"\r\n}\r\nconst customConfg = {\r\n    port:8080,\r\n    username:\"dyg\",\r\n    password:\"123456\"\r\n}\r\n\r\nconst resultConfg = Object.assign(defaultConfg,customConfg)\r\nconsole.log(resultConfg);\r\n//输出:\r\n//{\r\n//     host:\"localhost\",\r\n//     port:8080,\r\n//     username:\"dyg\",\r\n//     password:\"123456\"\r\n// }\r\n```\r\n\r\n\r\n**获取/设置原型对象**\r\n```js\r\nconst objA = [\"123\",\"321\"]\r\nconst objB = [123,321]\r\nObject.setPrototypeOf(objA,objB) //也就是使得objA.__prpto___ 指向objB\r\nconsole.log(objA);\r\nconsole.log(Object.getPrototypeOf(objA));\r\n```\r\n\r\n\r\n\r\n## ES6-模块化\r\n**原先的社区版模块化规范**\r\n* commonJs规范标准 服务端标准 现实实现: nodejs Browserify \r\n* AMD规范标准 浏览器端标准 现实实现: requirejs \r\n* CMD规范标准 浏览器端标准 现实实现: seaJS \r\n\r\n**ES6模块化规范语法**\r\n* `export{XXX,XXX,XXX}` 导出模块接口\r\n* `import{XXX,XXX,XXX} from \"url\"` 导入模块接口,顺序无妨,名称需一致\r\n* `import{XXX as XXX} from \"url\"`   \r\n* `export default{XXX,XXX,XXX}` 向外暴露的成员，可以使用任意变量来接收,不需要`{}`。\r\n* `import AAA from \"url with default export\"` 导入\r\n\r\n**特点**\r\n* ES6 的模块**自动开启严格模式**，不管你有没有在模块头部加上 use strict;。\r\n* 模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。\r\n\r\n**注意**\r\n要在nodejs中使用ES6模块化规范,要求在package.json中添加type:module\r\n\r\n**基本使用:导出**\r\n```js\r\n//第一种 按需导出\r\nexport var a = 123;\r\nexport function funA(){\r\n    console.log(\"111111111111111111111111\")\r\n}\r\n\r\n//第二种\r\nvar a = 123;\r\nfunction funA(){\r\n    console.log(\"111111111111111111111111\")\r\n}\r\nexport{a,funA}\r\n//或\r\nexport{abc:a,cde:funA}\r\n\r\n\r\n\r\n//第三种\r\nvar a = 123;\r\nfunction funA(){\r\n    console.log(\"111111111111111111111111\")\r\n}\r\nexport default{a,funA}\r\n```\r\n\r\n**基本使用:导入**\r\n```js\r\n//第一种 : 通用方式\r\nimport * as test1 from \"./_demo.js\" \r\n\r\n\r\n//第二种\r\nimport {a,funA} from \"./_demo.js\"  //名称需一致顺序无妨\r\nimport {a as a2,funA} from \"./_demo.js\"  //防止变量名冲突,使用as\r\n\r\n//第三种 : 导入默认赋值\r\nimport {default as temp1} from \"./_demo.js\"\r\n\r\n//第四种 : 导入默认赋值\r\nimport temp2 from \"./_demo.js\"\r\n\r\n//第五种 : 多种相结合\r\nimport temp2,{a as a2,funA} from \"./_demo.js\"\r\n```\r\n\r\n**注意**\r\n在script标签中写js代码，或者使用src引入js文件时，默认不能使用module形式，即不能使用import导入文件，\r\n需要再script标签上加上 `type=\"module\"`\r\n```html\r\n<script type=\"module\" src=\"./??\">\r\n</script>\r\n```\r\n\r\n\r\n## ES7-新运算符`**`\r\n```js\r\nconsole.log(2**10) //1024\r\n```\r\n\r\n## ES7-数组对象新方法`listA.includes()`\r\n```js\r\nvar listA = [\"AAA\",\"BBB\",\"CCC\"]\r\nconsole.log(listA.includes(\"CCC\"))  // true\r\n\r\n//旧版的判断元素是否存在\r\nvar listA = [\"AAA\",\"BBB\",\"CCC\"]\r\nconsole.log(listA.indexOf(\"CCC\"))  // 返回下标,若不存在则返回 -1 \r\n```\r\n\r\n## ES8-`async`/`await`\r\n* `async`修饰的函数的返回值为**promise对象**,promise对象的结果为函数`return`的值\r\n* `await`修饰一个promsie对象,\r\n\r\n\r\n\r\n\r\n**`async`修饰的函数**\r\n* 返回的是一个promise的对象\r\n* promise对象的值和状态\r\n  * 若函数直接return XXX; 则函数返回的promise对象的值为XXX,状态为成功 \r\n  * 若函数直接抛出错误; 则函数返回的promise对象的值为抛出的错误对象,状态为失败 \r\n  * 若函数return new Promise(???); 则函数返回的的promise对象的值和状态与return的promise状态一致\r\n```js\r\nasync function test() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            console.log(\"hhhhhhh\");\r\n            resolve(\"hhhhhhh\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nconsole.log(test());\r\n```\r\n\r\n**`await`修饰的语句**\r\n* `await` 必须写在 `async` 修饰的函数中,但 `async` 中不一定要包含 `await`\r\n* `await` 一般用于修饰一个promise对象 即 `await new Promise(略) `\r\n* `await`修饰的promise对象的状态为成功, 则表达式的值为promise对象的value值\r\n* `await`修饰的promise对象的状态为失败, 则表达式抛出错误,需 `try{}catch(err){}` 捕获\r\n\r\n\r\n```js\r\nasync function test1() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(\"111111\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function test2() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(\"222222\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function test3() {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            resolve(\"333333\")\r\n            // reject(\"err\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function main() {\r\n    let a = await test1()\r\n    let b = await test2()\r\n    let c = await test3()\r\n    console.log(a+b+c); \r\n}\r\nmain()\r\n```\r\n\r\n**结合 `axios` `async` `awite`**\r\n```html\r\n<script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n<script>\r\n    async function main() {\r\n        let sentences = await axios.get(\"https://api.apiopen.top/api/sentences\")\r\n        console.log(sentences.data.result);\r\n    }\r\n    main()\r\n</script>\r\n```\r\n\r\n\r\n**执行顺序的问题**\r\n在async修饰的函数中,语句是在主线程中执行的,当遇到第一个await语句并执行完后,函数中的剩余语句将交给异步执行栈,而后函数将直接返回一个promsie对象,\r\n\r\n```js\r\nasync function test4() {\r\n    return new Promise((resolve, reject) => {\r\n        console.log(\"2222222222222222222222\");\r\n        setTimeout(() => {                          //该行代码将交由异步执行栈执行\r\n            console.log(\"4444444444444444444444\");\r\n            resolve(\"5555555555555555555555\")\r\n        }, 1000)\r\n    })\r\n}\r\nasync function main() {\r\n    console.log(\"1111111111111111111111\");\r\n    let d = await test4()                   //执行该行之后,后续代码交给异步执行栈执行,函数main直接return\r\n    console.log(d);\r\n}\r\n\r\nconsole.log(\"0000000000000000000000\");\r\nmain()\r\nconsole.log(\"3333333333333333333333\"); \r\n\r\n//输出结果\r\n//  0000000000000000000000\r\n//  1111111111111111111111\r\n//  2222222222222222222222\r\n//  3333333333333333333333\r\n//  4444444444444444444444\r\n//  5555555555555555555555\r\n```\r\n\r\n\r\n\r\n## ES8-`Obj.eys()`/`values()`/`entries()`\r\n* `Object.keys(testObj)` 获取所有键\r\n* `Object.values(testObj)` 获取所以值\r\n* `Object.entries(testObj)` 获取所有键值组成的列表\r\n* `Object.getOwnPropertyDescriptors(testObj)` 获取对象属性的描述对象\r\n```js\r\nlet testObj = {\r\n    key1: \"value1\",\r\n    key2: \"value2\",\r\n    key3: \"value3\",\r\n    key4: [1, 2, 3, 4, 5],\r\n}\r\n\r\nconsole.log(Object.keys(testObj));\r\n//输出: [key1,key2,key3,key4]\r\nconsole.log(Object.values(testObj));\r\n//输出: [value1,value2,value3,value4]\r\nconsole.log(Object.entries(testObj));\r\n/*\r\n    输出: \r\n    [\r\n        [\"key1\",\"value1\"],\r\n        [\"key2\",\"value2\"],\r\n        [\"key3\",\"value3\"],\r\n        [\"key4\",[1,2,3,4,5]]\r\n    ]\r\n*/\r\nconsole.log(Object.getOwnPropertyDescriptors(testObj));\r\n// 输出:\r\n// {\r\n//     \"key1\": {\r\n//         \"value\": \"value1\",\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     },\r\n//     \"key2\": {\r\n//         \"value\": \"value2\",\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     },\r\n//     \"key3\": {\r\n//         \"value\": \"value3\",\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     },\r\n//     \"key4\": {\r\n//         \"value\": [\r\n//             1,\r\n//             2,\r\n//             3,\r\n//             4,\r\n//             5\r\n//         ],\r\n//         \"writable\": true,\r\n//         \"enumerable\": true,\r\n//         \"configurable\": true\r\n//     }\r\n// }\r\n```\r\n\r\n**结合map的应用**\r\n```js\r\nlet map = new Map(Object.entries(testObj))\r\nconsole.log(map);\r\n//  输出: Map(4) {'key1' => 'value1', 'key2' => 'value2', 'key3' => 'value3', 'key4' => Array(5)}\r\n```\r\n\r\n## ES9-针对于对象的`...`扩展运算符\r\nES6中的的扩展运算符是针对于数组的,ES9的新扩展运算是针对于对象的\r\n\r\n**用法**\r\n```js\r\n//用法1\r\nlet obj1 = {\r\n    key1: \"value1\",\r\n    key2: \"value2\",\r\n    key3: \"value3\",\r\n    key4: [1, 2, 3, 4, 5],\r\n}\r\nlet obj2 ={...obj1}\r\nconsole.log(obj2);\r\n\r\n\r\n```\r\n\r\n```js\r\n//用法2\r\nfunction test({host,port,...user}){\r\n    console.log(host);\r\n    console.log(port);\r\n    console.log(user);//剩余的属性都会成为user对象的属性\r\n    console.log(user.username);\r\n    console.log(user.password);\r\n}\r\ntest({\r\n    host:\"localhost\",\r\n    port:3306,\r\n    username:\"dyg\",\r\n    password:\"123456\",\r\n})\r\n```\r\n\r\n## ES9-正则-提取内容新方法\r\n**利用旧版标准提取字符串**\r\n```js\r\nlet str = `<a href=\"http://baidu.com\">百度</a>\"`\r\nconst reg = /<a href=\"(.*)\">(.*)<\\/a>/\r\nlet result = reg.exec(str)\r\nconsole.log(result);\r\n    //输出 :  ['<a href=\"http://baidu.com\">百度</a>', 'http://baidu.com', '百度']\r\nconsole.log(result[1]);\r\n    //输出 :  'http://baidu.com'\r\nconsole.log(result[2]);\r\n    //输出 :  '百度'\r\n```\r\n\r\n**利用新版标准提取字符串**\r\n```js\r\nlet str2 = `<a href=\"http://baidu.com\">百度</a>\"`\r\nconst reg2 = /<a href=\"(?<url>.*)\">(?<text>.*)<\\/a>/\r\nlet result2 = reg2.exec(str2)\r\nconsole.log(result2);\r\n    //输出 :  ['<a href=\"http://baidu.com\">百度</a>', 'http://baidu.com', '百度']\r\nconsole.log(result2.groups.url);\r\n    //输出 :  'http://baidu.com'\r\nconsole.log(result2.groups.text);\r\n    //输出 :  '百度'\r\n```\r\n\r\n## ES9-正则-反向断言\r\n```js\r\nlet str = `目标年新: 20W ¥`\r\n// 正向断言\r\nconst reg = /(?<salary>\\d+[a-zA-Z])(?= ¥)/   //提取出:[多个数字+单个字母+' ¥']中的[多个数字+单个字母]\r\nconst result = reg.exec(str)\r\nconsole.log(result.groups.salary); //输出20W\r\n\r\n\r\n//反向断言\r\nconst reg2 = /(?<=: )(?<salary>\\d+[a-zA-Z])/   //提取出:[': '+多个数字+单个字母]中的[多个数字+单个字母]\r\nconst result2 = reg2.exec(str)\r\nconsole.log(result2.groups  .salary); //输出20W\r\n```\r\n\r\n## ES9-正则-dotAll模式\r\n```js\r\n//dot . 元字符 除换行符以外的任意单个字符\r\n//在dotAll 模式 . 将能匹配任意字符包括换行符\r\n\r\n//目标提取出a和p标签的内容\r\nlet str = `\r\n    <ul>\r\n        <li>\r\n            <a>肖申克的救赎</a>\r\n            <p>上映时间:1994-09-10</p>\r\n        </li>\r\n        <li>\r\n            <a>阿甘正传</a>\r\n            <p>上映时间:1994-07-06</p>\r\n        </li>\r\n    </ul>\r\n`\r\n\r\nvar reg_old = /<a>([\\S\\s]*?)<\\/a>[\\S\\s]*?<p>([\\S\\s]*?)<\\/p>/g      // 旧版: `.`仅能匹配任意字符,不包括换行符号\r\nvar data_old = ''\r\nvar result_old = []\r\nwhile (data_old = reg_old.exec(str)) {\r\n    result_old.push([data_old[1], data_old[2],])\r\n}\r\nconsole.log(result_old);\r\n\r\nvar reg_new = /<a>(.*?)<\\/a>.*?<p>(.*?)<\\/p>/gs                    // 新版: `/s`表示是模式修正使得`.`能匹配任意字符,包括换行符号\r\nvar data_new = ''\r\nvar result_new = []\r\nwhile (data_new = reg_new.exec(str)) {\r\n    result_new.push([data_new[1], data_new[2],])\r\n}\r\nconsole.log(result_new);\r\n```\r\n**输出结果**\r\n![图 1](./images/ES6-ES11新特性学习笔记/48142215ed63936854349dcedf19d963bdd31d5ae2e161afac79037e51b07bd8.png)  \r\n\r\n## ES10-二维数组或Map转对象\r\n`Object.fromEntries()`二维数组或Map转对象,实际上是ES8中`Object.entries(testObj)`的**逆运算**\r\n```js\r\nvar result1 = Object.fromEntries([\r\n    [\"Name\", \"DYG\"],\r\n    [\"Age\", \"21\"],\r\n])\r\nconsole.log(result1);\r\n// 输出:\r\n// {Name: 'DYG', Age: '21'}\r\n\r\n\r\n\r\nvar result2 = Object.fromEntries(new Map([\r\n    [\"Name\", \"DYG\"],\r\n    [\"Age\", \"21\"],\r\n]))\r\nconsole.log(result2);\r\n    // 输出:\r\n    // {Name: 'DYG', Age: '21'}\r\n```\r\n\r\n\r\n## ES10-trimStart,trimEnd\r\n* `str.trimStart()` 清除字符串开头处空白\r\n* `str.trimEnd()` 清除字符串结束处空白\r\n```js\r\n        var str = \"   测试文字   \"\r\n        console.log(str.trim())         //ES5 中的方法,输出结果为 : \"测试文字\"\r\n        console.log(str.trimStart())    //ES10中的方法,输出结果为 : \"   测试文字\"\r\n        console.log(str.trimEnd())      //ES10中的方法,输出结果为 : \"测试文字   \"\r\n```\r\n\r\n## ES10-flat,flatMap\r\n\r\n**`flat()`**\r\n```js\r\nvar test1 = [1, 2, 3, 4, 5, [6, 7]]\r\nconsole.log(test1.flat());          //二维数组转一维\r\n//输出 [1,2,3,4,5,6,7]\r\n\r\nvar test2 = [1, 2, 3, 4, 5, [6, 7, [8, 9]]]\r\nconsole.log(test2.flat());          //三维数组转二维\r\n//输出 [1,2,3,4,5,6,7,[8,9]]\r\nconsole.log(test2.flat(2));         //三维数组转一维(指定深度为2)\r\n//输出 [1,2,3,4,5,6,7,8,9]\r\n```\r\n\r\n**`flatMap()`**\r\n```js\r\nvar test3 = [\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n    [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]],\r\n]\r\nconsole.log(test3.map(item => item[5]))\r\n/* 输出: \r\n[\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n    [5,5]\r\n]\r\n*/\r\nconsole.log(test3.flatMap(item => item[5]))\r\n// 输出 [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\r\n```\r\n\r\n\r\n## ES10-`Symbol.prototype.description`\r\n```js\r\nvar temp = Symbol(\"这是描述字符串\")\r\nconsole.log(temp.description); //输出: 这是描述字符串\r\n```\r\n\r\n\r\n## ES11-类的私有属性\r\n```js\r\nclass Person{\r\n    name;\r\n    #age;\r\n    constructor(name,age){\r\n        this.name=name\r\n        this.#age=age\r\n    }\r\n}\r\n\r\nvar girl = new Person(\"小红\",18)\r\nconsole.log(girl.name);\r\n// console.log(girl.#age); //无法访问\r\n```\r\n\r\n## ES11-Promise.allSettled()\r\n* `Promise.allSettled([p1,p2])` 始终返回成功的promise对象, 类似于`||`\r\n  * 原先版本中有`Promise.all([p1,p2])`,其返回值成功失败由传入的参数决定,类似于`&&`\r\n```js\r\nvar p1 = new Promise((resolve,reject)=>{\r\n    setTimeout(()=>{\r\n        resolve(\"哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\")\r\n    },1000)\r\n})\r\nvar p2 = new Promise((resolve,reject)=>{\r\n    setTimeout(()=>{\r\n        reject(\"嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻嘻\")\r\n    },1000)\r\n})\r\n\r\nconsole.log(Promise.allSettled([p1,p2]));\r\n```\r\n\r\n![图 3](./images/ES6-ES11新特性学习笔记/073d3d06eb89d441a759837d652fdeb6b5906e913fe25087ecb18b0b96184c74.png)  \r\n\r\n\r\n## ES11-`String.prototype.matchAll()`\r\n\r\n```js\r\nlet str = `\r\n<ul>\r\n    <li>\r\n        <a>肖申克的救赎</a>\r\n        <p>上映时间:1994-09-10</p>\r\n    </li>\r\n    <li>\r\n        <a>阿甘正传</a>\r\n        <p>上映时间:1994-07-06</p>\r\n    </li>\r\n</ul>\r\n`\r\n\r\nvar reg = /<a>(.*?)<\\/a>.*?<p>(.*?)<\\/p>/gs\r\n\r\nvar result1 = str.matchAll(reg)     //返回的是一个可迭代对象\r\nconsole.log([...result1]);          //所以可以使用扩展运算符 获取所有结果\r\n\r\nvar result2 = str.matchAll(reg)     //返回的是一个可迭代对象\r\nfor (let item of result2) {           //所以可以使用of 遍历对象 获取所有结果\r\n    console.log(item);\r\n    console.log({ \"name\": item[1], \"time\": item[2] });\r\n}\r\n```\r\n\r\n\r\n## ES11-`?.`可选链操作符\r\n```js\r\nfunction test(config) {\r\n    // 1\r\n    var dbHost = config.db.host\r\n    // var cacheHost = config.cache.host // 将报错,因为没有 config.cache\r\n    console.log(dbHost);\r\n    console.log(cacheHost);\r\n\r\n    // \r\n    var dbHost = config && config.db && config.db.host              //手动层层判断该对象是否有该属性,不会报错\r\n    var cacheHost = config && config.cache && config.cache.host     //手动层层判断该对象是否有该属性,不会报错\r\n    console.log(dbHost);\r\n    console.log(cacheHost);\r\n\r\n    var dbHost = config?.db?.host           //自动判断问号前的属性是否存在,不会报错\r\n    var cacheHost = config?.cache?.host     //自动判断问号前的属性是否存在,不会报错\r\n    console.log(dbHost);\r\n    console.log(cacheHost);\r\n}\r\n\r\ntest({\r\n    db: {\r\n        host: \"localhost\",\r\n        port: 1234,\r\n        username: \"root\",\r\n        password: \"root\",\r\n    },\r\n    // cache: {                     //不写cache\r\n    //     // host:\"localhost\",\r\n    //     port:4321,\r\n    //     username:\"root\",\r\n    //     password:\"root\",\r\n    // },\r\n})\r\n```\r\n\r\n\r\n## ES11-动态`import()`\r\n* 原先的import是静态的,需要在文件开头把所需模块一次性import导入\r\n* 动态import就是**按需导入**,**懒加载**\r\n\r\n**基本用法**\r\n```html\r\n<button id=\"btn\">点击测试</button>\r\n<script type=\"module\">\r\n    var btn = document.querySelector(\"#btn\")\r\n    btn.addEventListener(\"click\",async function(){\r\n        let hello = await import(\"./_hello.js\")     //import返回promise对象,使用await接受value\r\n        hello.myFun()\r\n    })\r\n</script>\r\n```\r\n\r\n```js\r\n//./_hello.js\r\nexport function myFun(){\r\n    alert(\"hello\")\r\n}\r\n```\r\n\r\n\r\n## ES11-BigInt大整型\r\n**BigInt**\r\n* BigInt常量: `123n`\r\n* BigInt()只能传入整数,不能传入浮点数\r\n* BigInt类型的数只能和BigInt类型数做运算\r\n\r\n**基本使用**\r\n```js\r\n        let test1 = 12345n;\r\n        console.log(test1);          //输出: 12345n\r\n        console.log(typeof test1); //输出: bigint\r\n\r\n        let test2 = BigInt(12345);\r\n        console.log(test2);          //输出: 12345n\r\n        console.log(typeof test2); //输出: bigint\r\n```\r\n\r\n**用处**\r\n```js\r\nlet maxInteger = Number.MAX_SAFE_INTEGER\r\nconsole.log(maxInteger+0);  //输出:     9007199254740991\r\nconsole.log(maxInteger+1);  //输出:     9007199254740992\r\nconsole.log(maxInteger+2);  //输出:     9007199254740992        //无法再加\r\n\r\nconsole.log(BigInt(maxInteger)+BigInt(0))//输出:     9007199254740991n\r\nconsole.log(BigInt(maxInteger)+BigInt(1))//输出:     9007199254740992n\r\nconsole.log(BigInt(maxInteger)+BigInt(2))//输出:     9007199254740993n        //可以再加\r\n```\r\n\r\n\r\n## ES11-globalThis\r\n\r\n```js\r\nconsole.log(globalThis) //在浏览器中指向 window\r\n// Window {window: Window, self: Window, document: document, name: '', location: Location, …}\r\n\r\nconsole.log(globalThis) //在nodejs中指向 global\r\n/*\r\nObject [global] {\r\n    global: [Circular],\r\n    clearInterval: [Function: clearInterval],\r\n    clearTimeout: [Function: clearTimeout],\r\n    setInterval: [Function: setInterval],\r\n    setTimeout: [Function: setTimeout] {\r\n        [Symbol(nodejs.util.promisify.custom)]: [Function]\r\n    },\r\n    queueMicrotask: [Function: queueMicrotask],\r\n    clearImmediate: [Function: clearImmediate],\r\n    setImmediate: [Function: setImmediate] {\r\n        [Symbol(nodejs.util.promisify.custom)]: [Function]\r\n    }\r\n}\r\n*/\r\n```"},{"shortInfo":{"title":"express学习笔记","date":"2022-08-30T00:05:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["express"],"hideAtIndex":true,"categories":"后端","id":8,"countWords":3778,"readSeconds":377.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# express学习笔记\r\n\r\n## 目录\r\n- [express学习笔记](#express学习笔记)\r\n  - [目录](#目录)\r\n  - [概念](#概念)\r\n  - [实现API接口服务器](#实现api接口服务器)\r\n    - [**基本示例:post get all listen**](#基本示例post-get-all-listen)\r\n    - [**获取URL中的<red>查询参数</red>**](#获取url中的red查询参数red)\r\n    - [**获取URL中的<red>动态参数</red>**](#获取url中的red动态参数red)\r\n  - [静态web服务器](#静态web服务器)\r\n    - [**基本使用示例**](#基本使用示例)\r\n    - [**托管多个静态网页**](#托管多个静态网页)\r\n    - [**挂载路径前缀**](#挂载路径前缀)\r\n  - [路由](#路由)\r\n    - [概念](#概念-1)\r\n    - [**<sky>最简用法</sky>:直接挂载到app上**](#sky最简用法sky直接挂载到app上)\r\n    - [**<sky>高级用法</sky>:将路由抽离为单独模块**](#sky高级用法sky将路由抽离为单独模块)\r\n    - [为路由添加访问前缀](#为路由添加访问前缀)\r\n  - [中间件](#中间件)\r\n    - [概念](#概念-2)\r\n    - [示例](#示例)\r\n    - [**中间件的分类**](#中间件的分类)\r\n    - [**应用级别中间件**](#应用级别中间件)\r\n    - [**路由级别中间件**](#路由级别中间件)\r\n    - [**错误级别中间件**](#错误级别中间件)\r\n    - [**内置中间件**](#内置中间件)\r\n    - [**第三方中间件**](#第三方中间件)\r\n    - [**自定义中间件:尝试实现urlencoded模块**](#自定义中间件尝试实现urlencoded模块)\r\n  - [常用中间件的使用](#常用中间件的使用)\r\n    - [CORS跨源访问限制](#cors跨源访问限制)\r\n    - [express-session身份认证](#express-session身份认证)\r\n    - [JWT认证机制机制](#jwt认证机制机制)\r\n\r\n\r\n------------------------------------------------------------------\r\n\r\n## 概念\r\nexpress作用和nodejs的http模块类似,用于创建web服务器<br>\r\nexpress是基于http模块封装的,使用起来比http模块简单,效率更高\r\n\r\n**express用处**\r\n* web服务器\r\n* API接口服务器\r\n\r\n------------------------------------------------------------------\r\n\r\n## 实现API接口服务器\r\n### **基本示例:post get all listen**\r\n```js\r\nconst express = require(\"express\")\r\n\r\nconst app = express();\r\n\r\napp.get(\"/test_01\",(request,response)=>{\r\n    response.send(\"hello world!!\")\r\n})\r\n\r\napp.post(\"/test_02\",(request,response)=>{\r\n    response.send({hello:\"world\"})\r\n})\r\n\r\napp.all(\"/test_03\",(request,response)=>{\r\n    response.send({hello:\"world\"})\r\n})\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"express server is running at http://127.0.0.1:8000\")\r\n})\r\n```\r\n------------------------------------------------------------------\r\n\r\n\r\n### **获取URL中的<red>查询参数</red>**\r\n```js\r\napp.get(\"/test_04\",(request,response)=>{\r\n    // request.query默认是空对象\r\n    // 客户端使用 ?name=DingYigui&age=20 这种查询字符串形式的URL时\r\n    // request.query=={\"name\"=\"DingYigui\",\"age\"=20}\r\n\r\n    console.log(request.query)\r\n    \r\n    response.send(request.query)\r\n})\r\n```\r\n------------------------------------------------------------------\r\n\r\n### **获取URL中的<red>动态参数</red>**\r\n```js\r\napp.get(\"/test_05/:name/:age\",(request,response)=>{\r\n    // request.params 默认是空对象 是动态匹配到的URL参数\r\n    // 客户端使用 /test_05/DingYigui/20 形式的URL时\r\n    // request.params=={\"name\"=\"DingYigui\",\"age\"=20}\r\n    console.log(request.params)\r\n    response.send(request.params)\r\n})\r\n```\r\n------------------------------------------------------------------\r\n\r\n## 静态web服务器\r\n\r\n### **基本使用示例**\r\n```js\r\nconst express = require(\"express\")\r\n\r\nconst app = express();\r\n\r\napp.use(express.static(\"./site0\"))\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"express server is running at http://127.0.0.1:8000\")\r\n})\r\n```\r\n\r\n> 要访问 `/site0/index` 只需访问 `/index`\r\n\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n### **托管多个静态网页**\r\n```js\r\napp.use(express.static(\"./site1\"))\r\napp.use(express.static(\"./site2\"))\r\n```\r\n> 注意: 若访问的index.html在两个文件目录中均存在,则优先访问第一个文件夹\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n### **挂载路径前缀**\r\n```js\r\napp.use(\"/subSite\",express.static(\"./site1\"))\r\n```\r\n> 要访问 `/site1/index` 则需访问 `/subSite/index`\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n## 路由\r\n### 概念\r\n路由就是**映射关系**,在express中就是指**客户端请求**和**服务端处理函数**的**映射关系**\r\n\r\nexpress路由的**组成**: `app.METHOD(PATH,HANDLER)`\r\n* `METHOD` 请求的方法\r\n* `PATH` 请求的URL地址\r\n* `HANDLER` 处理函数\r\n\r\nexpress路由的**匹配规则**\r\n* 将按照定义的**先后顺序**进行匹配\r\n* **请求类型**和**请求URL**需**同时匹配**才会调用对应的**处理函数**\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n### **<sky>最简用法</sky>:直接挂载到app上**  \r\n<red>express不建议将路由直接挂载到app上,这样会导致代码量越来越多,不便管理</red>\r\n\r\n```js\r\napp.get(\"/test_01\",(request,response)=>{\r\n    response.send(\"hello world!!\")\r\n})\r\n\r\napp.post(\"/test_02\",(request,response)=>{\r\n    response.send({hello:\"world\"})\r\n})\r\n\r\napp.all(\"/test_03\",(request,response)=>{\r\n    response.send({hello:\"world\"})\r\n})\r\n```\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n### **<sky>高级用法</sky>:将路由抽离为单独模块**  \r\n\r\n<gre>express官方推荐用法</gre>  \r\n\r\n```js\r\n// ./src/user.js\r\nconst express = require(\"express\")\r\nconst routerApp = express.Router()     //创建路由对象\r\n\r\nrouterApp.get(\"/user/list\",(req,res)=>{ //挂载路由\r\n    res.send(\"getted user list\")\r\n})\r\nrouterApp.post(\"/user/add\",(req,res)=>{ //挂载路由\r\n    res.send(\"added user\")\r\n})\r\n\r\nmodule.exports = routerApp //导出路由对象\r\n```\r\n\r\n```js\r\n// ./index.js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\nconst userRouter = require(\"./src/user.js\") //导入user路由模块\r\napp.use(\"/api\",userRouter) //注册路由\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n>`app.use()`用于注册全局**中间件**\r\n\r\n\r\n------------------------------------------------------------------\r\n\r\n### 为路由添加访问前缀\r\n```js\r\napp.use(\"/api\",userRouter) //添加访问前缀\r\n```\r\n\r\n------------------------------------------------------------------\r\n\r\n\r\n## 中间件\r\n\r\n### 概念\r\n中间件(Middleware),特指业务流程的中间处理环节\r\n\r\n但一个请求到达express服务器后,可连续调用多个中间件对请求进行**预处理**\r\n![图 1](./images/express学习笔记/94e6281102dfa399e3de1d15a143647e4bdec8256d7ce39ebff2d5eb91fcee3f.png)  \r\n\r\n\r\n**中间件本质为函数**\r\n```js\r\nconst mw = function (request,response,next){\r\n    console.log(\"这是一个中间件函数\")\r\n    next()\r\n}\r\n```\r\n**next()函数**  \r\nnext()函数实现多个中间件之间的**连续调用**,表示把**流转关系**转交给**下一个中间件**或**路由**\r\n\r\n![图 2](./images/express学习笔记/05ed400ef4edde4dad65a33e9bf0c8354e53ddb3f963aabae9c53f4a1c7dd4aa.png)  \r\n\r\n\r\n\r\n### 示例\r\n**案例1:全局生效的中间件**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\n//定义中间件1\r\nconst mw1 = function(req,res,next){\r\n    req.startTime = Date.now()\r\n    console.log(\"执行了第1个中间件\")\r\n    next()\r\n}\r\n//定义中间件2\r\nconst mw2 = function(req,res,next){\r\n    console.log(\"执行了第2个中间件\")\r\n    next()\r\n}\r\n\r\n//注册中间件1:先注册的先执行,后注册的后执行\r\napp.use(mw1)\r\n//注册中间件2\r\napp.use(mw2)\r\n\r\n\r\napp.get(\"/testRW\",(req,res)=>{ //挂载路由\r\n    var now = Date.now()\r\n    var gap = now-req.startTime\r\n    res.send(\"处理该请求耗时:\"+ gap + \"ms\")\r\n})\r\n\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n> **注意**:对于全局生效的中间件,一定要在路由之前注册中间件\r\n\r\n\r\n\r\n**案例2:局部生效的中间件**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\n//定义中间件1\r\nconst mw1 = function(req,res,next){\r\n    req.startTime = Date.now()\r\n    console.log(\"执行了第1个中间件\")\r\n    next()\r\n}\r\n//定义中间件2\r\nconst mw2 = function(req,res,next){\r\n    console.log(\"执行了第2个中间件\")\r\n    next()\r\n}\r\n\r\n\r\n//以下三种方式均可\r\napp.get(\"/testRW_2_1\",mw1,(req,res)=>{ //挂载路由\r\n    var now = Date.now()\r\n    var gap = now-req.startTime\r\n    res.send(\"处理该请求耗时:\"+ gap + \"ms\")\r\n})\r\n\r\n// 以下两种方式等效\r\napp.get(\"/testRW_2_2\",mw1,mw2,(req,res)=>{ //挂载路由\r\n    var now = Date.now()\r\n    var gap = now-req.startTime\r\n    res.send(\"处理该请求耗时:\"+ gap + \"ms\")\r\n})\r\n\r\napp.get(\"/testRW_2_3\",[mw1,mw2],(req,res)=>{ //挂载路由\r\n    var now = Date.now()\r\n    var gap = now-req.startTime\r\n    res.send(\"处理该请求耗时:\"+ gap + \"ms\")\r\n})\r\n\r\napp.listen(8000,()=>{\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n\r\n\r\n### **中间件的分类**\r\n* **应用**级别中间件\r\n* **路由**级别中间件\r\n* **错误**级别中间件\r\n* Express**内置**中间件\r\n* **第三方**中间件\r\n\r\n\r\n### **应用级别中间件**\r\n通过`app.use()` `app.post()` `app.get()`绑定到**app实例**上的中间件都称为**应用级别中间件**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\napp.use((req,res,next)=>{\r\n    console.log(\"这是一个应用级别中间件,同时也是全局中间件\")\r\n    next();\r\n})\r\n\r\napp.get(\"/api/test\",\r\n    (req,res,next)=>{\r\n        console.log(\"这是一个应用级别中间件,同时也是局部中间件\")\r\n        next();\r\n    },\r\n    (req,res)=>{\r\n        res.send(\"hello world\")\r\n    }\r\n)\r\n```\r\n\r\n### **路由级别中间件**\r\n绑定到`express.Router()`的**实例**上的中间件都称为**路由级别中间件**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\nconst router = app.Router()\r\n\r\nrouter.use((req,res,next)=>{\r\n    console.log(\"这是一个路由级别中间件\")\r\n    next();\r\n})\r\n\r\nrouter.get(\"/test\",\r\n    (req,res,next)=>{\r\n        console.log(\"这是一个路由级别中间件\")\r\n        next();\r\n    },\r\n    (req,res)=>{\r\n        res.send(\"hello world\")\r\n    }\r\n)\r\n\r\napp.use(\"/api\",router)\r\n```\r\n\r\n\r\n### **错误级别中间件**  \r\n用于捕获整个项目中发生异常错误的中间件,**防止项目异常崩溃的问题**  \r\n**格式:**`function(err,req,res,next){}`  \r\n**注意:** <red>错误级别中间件需放在路由之后<red>\r\n```js\r\n//创建路由\r\napp.get(\"/test\",(req,res)=>{\r\n    throw new Error(\"服务器发生了内部错误!!!\") //手动抛出一个错误\r\n    res.send(\"hello world\")                 //此处便不会执行\r\n})\r\n\r\n//注册错误级别中间件\r\napp.use((err,req,res,next)=>{\r\n    console.log(err.message)                //输出错误信息\r\n    res.send(err.message)                   //向客户端响应\r\n})\r\n```\r\n\r\n### **内置中间件**\r\n自`express@4.16.0`起内置了三个常用中间件\r\n* `express.static` \r\n  * 用于托管指定目录下的静态网页\r\n  * (该中间件可兼任旧版本)\r\n* `express.json()`\r\n  * 用于解析<red>**请求体中**</red>的**JSON格式**的数据,解析完毕后将被挂载到`req.body`上  \r\n  * (该中间件不可兼任旧版本的express)\r\n* `express.urlencoded()`\r\n  * 用于解析<red>**请求体中**</red>中的**URL-encoded格式**的数据,解析完毕后将被挂载到`req.body`上\r\n  * (该中间件不可兼任旧版本的express)\r\n\r\n```js\r\n// 解析 application/json 格式的数据\r\napp.use(express.json())\r\n// 解析 application/x-www-form-urlencoded 格式的数据\r\napp.use(express.urlencoded({extented:false}))\r\n\r\napp.post(\"/\",(req,res)=>{ //此时便能够解析并获取到请求体中的json格式和urlencoded格式的数据了\r\n    console.log(req.body)\r\n    res.send(req.body)\r\n})\r\n```\r\n\r\n\r\n### **第三方中间件**\r\n在`express@4.16.0`内置`express.urlencoded`模块之前,常使用的一个叫<red>body-parser</red>的模块  \r\n实际上该模块就是`express.urlencoded`的前身\r\n```js\r\nconst parser = require(\"body-parser\")\r\napp.use(parser.urlencoded({extented:false}))\r\n```\r\n\r\n### **自定义中间件:尝试实现urlencoded模块**\r\n实现将请求体中的`a=123&b=321`格式的数据解析为`{a:123,b:321}`格式的json对象\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\nconst qs = require(\"querystring\")\r\nfunction BodyUrlDataDecoded(req,res,next){//定义中间件\r\n    req.bodyUrlData = []\r\n    req.on(\"data\",(chunk)=>{ //监听req的data\r\n        req.bodyUrlData.push(chunk) //收集数据片段\r\n    })\r\n    req.on(\"end\",()=>{//监听req的end事件\r\n        var temp = req.bodyUrlData.toString() //将收集的数据片段转换为字符串\r\n        req.body = qs.parse(temp) // 将字符串通过nodejs内置的querystring模块解析为json对象\r\n        next()\r\n    })\r\n}\r\napp.use(BodyUrlDataDecoded) //注册中间件\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\napp.all(\"/\",(req,res)=>{\r\n    res.setHeader(\"Access-Control-Allow-Origin\",\"*\")\r\n    res.setHeader(\"Access-Control-Allow-Headers\",\"*\")\r\n    console.log(req.body);\r\n    res.send(req.body)\r\n})\r\napp.listen(8000,()=>{\r\n    console.log(\"express server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n\r\n## 常用中间件的使用\r\n\r\n### CORS跨源访问限制\r\n**方法1:添加请求头**\r\n```js\r\nres.setHeader(\"Access-Control-Allow-Origin\",\"*\")\r\nres.setHeader(\"Access-Control-Allow-Headers\",\"*\")\r\n```\r\n\r\n方法2: 通过第三方中间件cors\r\n```js\r\nconst cors = require(\"cors\")\r\napp.use(cors)\r\n```\r\n\r\n\r\n### express-session身份认证\r\n\r\n**基本使用**\r\n```js\r\nconst session = require(\"express-session\")\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\napp.use(session({\r\n    secret: \"keyboard cat\",\r\n    resave: false,\r\n    saveUninitialized: true,\r\n}))\r\n\r\n\r\napp.post(\"/api/login\", (req, res) => {\r\n\r\n    console.log(req.session);\r\n\r\n    //判断用户名和密码是否正确\r\n    if (req.body.username != \"admin\" && req.body.password != \"admin\") {\r\n        res.send({ status: 1, msg: \"登陆失败\" })\r\n        return;\r\n    }\r\n\r\n    //保存此次会话的用户信息\r\n    req.session.userinfo = req.body\r\n    req.session.islogin = true\r\n    res.send({ status: 0, msg: \"登陆成功\" })\r\n    return;\r\n})\r\n```\r\n\r\n**`console.log(req.session);`输出的数据格式**\r\n```js\r\n// 登陆前\r\nSession {\r\n  cookie: { path: '/', _expires: null, originalMaxAge: null, httpOnly: true }\r\n}\r\n\r\n//登陆后\r\nSession {\r\n  cookie: { path: '/', _expires: null, originalMaxAge: null, httpOnly: true },\r\n  userinfo: { username: 'admin', password: 'admin' },\r\n  islogin: true\r\n}\r\n```\r\n\r\n\r\n**实现 `登陆` `登出` 的案例**\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\nconst session = require(\"express-session\")\r\n\r\napp.use(express.static(\"./webRoot\"))\r\n\r\napp.use(session({\r\n    secret: \"keyboard cat\",     //任意字符串,用于加密cookie\r\n    resave: false,              //固定写法\r\n    saveUninitialized: true,    //固定写法\r\n}))\r\n\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\napp.post(\"/api/login\", (req, res) => {\r\n\r\n    console.log(req.session);\r\n\r\n    //判断用户名和密码是否正确\r\n    if (req.body.username != \"admin\" && req.body.password != \"admin\") {\r\n        res.send({ \r\n            status: 1, \r\n            msg: \"登陆失败\" \r\n        })\r\n        return;\r\n    }\r\n\r\n    //保存此次会话的用户信息\r\n    req.session.userinfo = req.body\r\n    req.session.islogin = true\r\n    res.send({ \r\n        status: 0, \r\n        msg: \"登陆成功\" \r\n    })\r\n    return;\r\n})\r\n\r\napp.get(\"/api/logout\", (req, res) => {\r\n\r\n    //判断该请求的是否已经登陆\r\n    if (!req.session.islogin) {\r\n        res.send({ \r\n            status: 1, \r\n            msg: \"logout失败\" \r\n        })\r\n        return;\r\n    }\r\n\r\n    //销毁该会话\r\n    req.session.destroy()\r\n    res.send({ status: 0, msg: \"logout成功\" })\r\n    return;\r\n})\r\n\r\napp.get(\"/api/get-username\", (req, res) => {\r\n    //判断该请求的是否已经登陆\r\n    if (!req.session.islogin) {\r\n        res.send({ \r\n            status: 1, \r\n            msg: \"get-username失败\" \r\n        })\r\n        return;\r\n    }\r\n    res.send({ \r\n        status: 0, \r\n        msg: \"get-username成功\", \r\n        username: req.session.userinfo.username \r\n    })\r\n    return;\r\n})\r\n\r\n\r\napp.listen(8000, () => {\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n\r\n\r\n```html\r\n    <h1>登陆</h1>\r\n    <form action=\"/api/login\" method=\"post\">\r\n        <input type=\"text\" name=\"username\"><br>\r\n        <input type=\"password\" name=\"password\"><br>\r\n        <input type=\"submit\" value=\"登陆\"><br>\r\n    </form>\r\n\r\n    <h1>登出</h1>\r\n    <form action=\"/api/logout\" method=\"get\">\r\n        <input type=\"submit\" value=\"登出\"><br>\r\n    </form>\r\n\r\n    <h1>获取当前用户的用户名</h1>\r\n    <form action=\"/api/get-username\" method=\"get\">\r\n        <input type=\"submit\" value=\"获取当前用户的用户名\"><br>\r\n    </form>\r\n```\r\n\r\n\r\n\r\n### JWT认证机制机制\r\n**安装相关包**\r\n* `jsonwebtoken` 用于将用户信息**加密**为JWT字符串\r\n* `express-jwt` 用于将从客户端收到的JWT字符串**解密**为用户信息\r\n\r\n```bash\r\nnpm install jsonwebtoken express-jwt\r\n```\r\n\r\n**实现JWT认证登陆的完整示例**\r\n\r\n![图 6](./images/express学习笔记/a6285567a812d97f3fe90506e6993ed9f7e77ca9e06f3b5bcedbca35616fe252.png)  \r\n\r\n\r\n```js\r\nconst express = require(\"express\")\r\nconst app = express()\r\n\r\n//jwt身份认证\r\nconst jwtEncode = require(\"jsonwebtoken\") //加密\r\n// const jwtDecode = require(\"express-jwt\")  //解密\r\nvar { expressjwt: jwtDecode } = require(\"express-jwt\");\r\nconst secretKey = \"dfwofwiefjw0wfej02fj023j0r2\" //随便写一段密钥用于加密token\r\n\r\n//用于支持跨源\r\nconst cors = require(\"cors\")\r\napp.use(cors())\r\n\r\n// 静态资源\r\napp.use(express.static(\"./webRoot\"))\r\n\r\n//解密请求头中的 jwtToken 解析还原为json对象 并把解析出来的信息挂载到 req.auth 上\r\n//同时配置了访问权限 没有Token则不能访问任何接口 \r\n//unless指定某些页面不需要Token 这里指定 /api/login 不需要身份认证便能访问\r\napp.use(\r\n    jwtDecode({\r\n        secret: secretKey,\r\n        algorithms: [\"HS256\"] //防止潜在的降级攻击所必需的\r\n    })\r\n        .unless({ path: [/^\\/api\\/login/] }) //指定 /api/login 不需要身份认证便能访问\r\n)\r\n\r\n//用于req.body\r\napp.use(express.json())\r\napp.use(express.urlencoded({ extended: false }))\r\n\r\n//登陆api\r\napp.post(\"/api/login\", (req, res) => {\r\n\r\n    //判断用户名和密码是否正确\r\n    if (req.body.username != \"admin\" && req.body.password != \"admin\") {\r\n        res.send({\r\n            status: 1,\r\n            msg: \"登陆失败\"\r\n        })\r\n        return;\r\n    }\r\n\r\n    //生成token\r\n    //sign方法:sign(参数1,参数2,参数3)\r\n    // 参数1 待加密的数据\r\n    // 参数2 加密密钥\r\n    // 参数3 配置项,可配置有效期\r\n    var token = jwtEncode.sign({ username: req.body.username }, secretKey, { expiresIn: \"30s\" })\r\n    //发送token\r\n    res.send({\r\n        status: 0,\r\n        msg: \"登陆成功\",\r\n        token: token\r\n    })\r\n})\r\n\r\n// app.get(\"/api/logout\", (req, res) => {\r\n// logout不需要服务端执行任何操作了 只需要客户端删除token就好了\r\n//     res.send({ \r\n//         status: 0, \r\n//         msg: \"logout成功\" \r\n//     })\r\n//     return;\r\n// })\r\n\r\napp.get(\"/api/get-userinfo\", (req, res) => {\r\n    res.send({\r\n        status: 0,\r\n        msg: \"获取用户的信息成功\",\r\n        userinfo: req.auth\r\n    })\r\n    return;\r\n})\r\n\r\napp.use((err, res, req, next) => { //处理错误\r\n    if (err.name == \"UnauthorizedError\") {\r\n        req.send({\r\n            status: 401,\r\n            msg: \"未登陆或登陆状态已过期,请重新登陆\",\r\n            err: err\r\n        })\r\n    } else {\r\n        req.send({\r\n            status: 500,\r\n            msg: \"服务器未知错误\",\r\n            err: err\r\n        })\r\n    }\r\n}\r\n)\r\n\r\n\r\n\r\n\r\napp.listen(8000, () => {\r\n    console.log(\"server is running at http://127.0.0.1:8000\");\r\n})\r\n```\r\n\r\n**前端代码**\r\n```html\r\n    <!-- jquery库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n    <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\r\n    <!-- axios 库 ,crossorigin=\"anonymous\"表示不携带当前页面的cookie -->\r\n    <script crossorigin=\"anonymous\" src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.27.2/axios.min.js\"></script>\r\n\r\n\r\n    <h1>登陆</h1>\r\n    用户:<input type=\"text\" id=\"username\"><br>\r\n    密码:<input type=\"password\" id=\"password\"><br>\r\n    <button id=\"btn-login\">登陆</button>\r\n    <div id=\"login-result\"></div>\r\n    <script>\r\n        $(\"#btn-login\").click(function () {\r\n            console.log(\"123\");\r\n            //axios(config)\r\n            axios({\r\n                method: 'post',\r\n                url: \"/api/login\",\r\n                data: {\r\n                    username: $(\"#username\").val(),\r\n                    password: $(\"#password\").val(),\r\n                }\r\n            })\r\n                .then((response) => {\r\n                    console.log(response);\r\n                    $(\"#login-result\").text(JSON.stringify(response.data))\r\n                    sessionStorage.setItem(\"token\", response.data.token) //保存token\r\n                })\r\n        })\r\n    </script>\r\n\r\n\r\n\r\n\r\n\r\n    <h1>获取用户的信息</h1>\r\n    <button id=\"btn-get-userinfo\">获取</button>\r\n    <div id=\"get-userinfo-result\"></div>\r\n    <script>\r\n        $(\"#btn-get-userinfo\").click(function () {\r\n            //axios(config)\r\n            axios({\r\n                method: 'get',\r\n                url: \"/api/get-userinfo\",\r\n                headers: {//报头\r\n                    Authorization: \"Bearer \" + sessionStorage.getItem(\"token\") //获取token\r\n                }\r\n            })\r\n                .then((response) => {\r\n                    console.log(response);\r\n                    $(\"#get-userinfo-result\").text(JSON.stringify(response.data))\r\n                })\r\n        })\r\n    </script>\r\n\r\n\r\n    <h1>登出</h1>\r\n    <button id=\"btn-logout\">登出</button>\r\n    <div id=\"logout-result\"></div>\r\n    <script>\r\n        $(\"#btn-logout\").click(function () {\r\n            sessionStorage.setItem(\"token\", \"\") //清除token\r\n            $(\"#logout-result\").text(\"登出完毕\")\r\n\r\n        })\r\n    </script>\r\n```\r\n\r\n\r\n<style>\r\n    red{\r\n        color:red;\r\n    }\r\n    gre{\r\n        color:green;\r\n    }\r\n    sky{\r\n        color:skyblue;\r\n    }\r\n</style>"},{"shortInfo":{"title":"flexible.js源码分析","date":"2022-07-05T02:52:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["js","源码分析","前端"],"hideAtIndex":true,"categories":"笔记","id":9,"countWords":854,"readSeconds":85.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# flexible.js源码分析\r\n\r\nflexible.js是手淘开发出的一个用来适配移动端的js框架。手淘框架的核心原理就是根据不同的视口宽度给html根标签设置不同的font-size，然后所有的px都用rem来代替，这样就实现了不同大小的屏幕都适应相同的样式了。\r\n\r\n\r\n## 最外层\r\n* 最外层是一个立即执行函数，\r\n* 接收的实参为window和document对象\r\n* 其中所有变量都是局部变量，不会造成变量名冲突\r\n\r\n```js\r\n(function flexible (window, document) {\r\n    //立即执行函数\r\n}(window, document))\r\n```\r\n\r\n\r\n## 变量\r\n```js\r\n//documentElement是html根标签\r\n  var docEl = document.documentElement\r\n//devicePixelRatio是物理像素比，一般pc端是1 手机端是2\r\n  var dpr = window.devicePixelRatio || 1\r\n```\r\n\r\n\r\n## 设置body字体大小\r\n```js\r\n  // adjust body font size\r\n  function setBodyFontSize () {\r\n    if (document.body) {//判断是否有body元素\r\n      document.body.style.fontSize = (12 * dpr) + 'px' //设置body的Font-size:(12*dpr)px\r\n    }\r\n    else {\r\n        //如果页面没有body，则添加DOMContentLoaded事件监听器，待DOM加载完毕后再来执行该函数\r\n      document.addEventListener('DOMContentLoaded', setBodyFontSize)\r\n    }\r\n  }\r\n  setBodyFontSize();\r\n```\r\n\r\n\r\n## 设置html文字大小\r\n* pageshow是页面显示时触发的事件，无论页面是否来自缓存；\r\n* 该事件会在load事件触发之后触发；\r\n* 该事件对象中persisted属性可以用来判断是否是缓存中的页面触发的pageshow事件\r\n* 该事件添加给window\r\n* 此处不能用load事件来代替的原因是：\r\n    * load事件虽可以在点击超链接、f5刷新、强制刷新、前进后退后触发\r\n    * 但在火狐浏览器中，存在“往返缓存”机制，后退页面时，整个DOM和js的状态都被存储在了内存中，此时再点击前进按钮回到页面，整个页面不会重新加载，不会触发load事件\r\n\r\n```js\r\n  \r\n  function setRemUnit () {\r\n    var rem = docEl.clientWidth / 10 // 设置 1rem = 视口宽度 / 10\r\n    docEl.style.fontSize = rem + 'px' // 为HTML根标签设置字体大小\r\n  }\r\n\r\n  setRemUnit() // 调用\r\n\r\n  // 添加监听事件，当窗口改变大小后重新根据视口宽度计算1rem大小\r\n  window.addEventListener('resize', setRemUnit)\r\n  //页面显示时触发的事件\r\n  window.addEventListener('pageshow', function (e) {\r\n    if (e.persisted) {//如果页面是从缓存中取出的\r\n      setRemUnit()\r\n    }\r\n  })\r\n```\r\n\r\n\r\n## 使移动端支持0.5px\r\n```js\r\n//移动端检测是否支持0.5px，若支持则添加类名使其向下兼容\r\n  if (dpr >= 2) {//检测是否是移动端\r\n   //创建一个假body元素\r\n    var fakeBody = document.createElement('body')\r\n     //创建一个测试元素\r\n    var testElement = document.createElement('div')\r\n     //给测试元素添加0.5px的边框\r\n    testElement.style.border = '.5px solid transparent'\r\n    //将测试元素附加给假body元素\r\n    fakeBody.appendChild(testElement)\r\n    //将假body元素附加给html根标签\r\n    docEl.appendChild(fakeBody)\r\n    // 检测测试元素的高度是否为1，若是则说明支持0.5px的写法\r\n    if (testElement.offsetHeight === 1) {\r\n        //为根标签添加样式类名 通过添加类名hairlines来向下兼容\r\n      docEl.classList.add('hairlines')\r\n    }\r\n    //移除假body元素\r\n    docEl.removeChild(fakeBody)\r\n  }\r\n```\r\n\r\n\r\n## 完整源码\r\n```js\r\n(function flexible (window, document) {\r\n  var docEl = document.documentElement\r\n  var dpr = window.devicePixelRatio || 1\r\n\r\n  // adjust body font size\r\n  function setBodyFontSize () {\r\n    if (document.body) {\r\n      document.body.style.fontSize = (12 * dpr) + 'px'\r\n    }\r\n    else {\r\n      document.addEventListener('DOMContentLoaded', setBodyFontSize)\r\n    }\r\n  }\r\n  setBodyFontSize();\r\n\r\n  // set 1rem = viewWidth / 10\r\n  function setRemUnit () {\r\n    var rem = docEl.clientWidth / 10\r\n    docEl.style.fontSize = rem + 'px'\r\n  }\r\n\r\n  setRemUnit()\r\n\r\n  // reset rem unit on page resize\r\n  window.addEventListener('resize', setRemUnit)\r\n  window.addEventListener('pageshow', function (e) {\r\n    if (e.persisted) {\r\n      setRemUnit()\r\n    }\r\n  })\r\n\r\n  // detect 0.5px supports\r\n  if (dpr >= 2) {\r\n    var fakeBody = document.createElement('body')\r\n    var testElement = document.createElement('div')\r\n    testElement.style.border = '.5px solid transparent'\r\n    fakeBody.appendChild(testElement)\r\n    docEl.appendChild(fakeBody)\r\n    if (testElement.offsetHeight === 1) {\r\n      docEl.classList.add('hairlines')\r\n    }\r\n    docEl.removeChild(fakeBody)\r\n  }\r\n}(window, document))\r\n```\r\n\r\n"},{"shortInfo":{"layout":"post","title":"Flex布局模型项目实战","date":"2022-06-19T22:39:00.000Z","tags":["网站","demo"],"hideAtIndex":true,"categories":"前端","cover":"\\self_server\\assets\\images\\default_cover2.jpg","id":12,"countWords":59,"readSeconds":5.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# Flex布局模型项目实战\r\n\r\n## Demos\r\n* [-->移动端小兔仙儿下单页<--](./demos/Flex布局模型项目实战/xiaotuxianOrders/order)\r\n* [-->PC端小兔仙儿个人中心页<--](./demos/Flex布局模型项目实战/xiaotuxianCenter/center)\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"layout":"post","title":"font-class图标使用","date":"2022-02-23T02:31:00.000Z","cover":"\\self_server\\assets\\images\\font_class图标使用.png","tags":["font-class","笔记","前端"],"hideAtIndex":true,"categories":"前端","reprint":true,"id":10,"countWords":123,"readSeconds":12.3,"assetsbaseUrl":"/self_server/assets/"},"content":"## 阿里巴巴矢量图标库\r\nhttps://www.iconfont.cn/\r\n\r\n## font-class 引用\r\nfont-class使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。\r\n\r\n使用步骤如下：\r\n\r\n第一步：引入项目下面生成的 fontclass 代码：\r\n```\r\n<link rel=\"stylesheet\" href=\"./iconfont.css\">\r\n```\r\n\r\n第二步：挑选相应图标并获取类名，应用于页面：\r\n```\r\n<span class=\"iconfont icon-xxx\"></span>\r\n```\r\n\" iconfont\" 是你项目下的 font-family。可以通过编辑项目查看，默认是 \"iconfont\"。\r\n\r\n"},{"shortInfo":{"title":"frp配置过程记录(ipad远程登录电脑)","date":"2022-08-04T12:26:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["frp","linux","ipad"],"hideAtIndex":true,"categories":"笔记","id":11,"countWords":608,"readSeconds":60.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# frp配置过程记录(ipad远程登录电脑)\r\n\r\n\r\n## 服务端配置过程\r\n\r\n**准备工作**\r\n```bash\r\n# 从github下载frp的releases版本\r\nwget -O https://github.com/fatedier/frp/releases/download/v0.44.0/frp_0.44.0_linux_amd64.tar.gz\r\n# 解压\r\ntar -xvf ./frp_0.44.0_linux_amd64.tar.gz\r\n# 进入目录\r\ncd ./frp_0.44.0_linux_amd64\r\n# 创建文件夹\r\nmkdir ~/frps/\r\n# 移动\r\nmv ./frps ~/frps/\r\n# 添加执行权限\r\nchmod +x ~/frps/frps\r\n```\r\n\r\n\r\n**编写配置文件**\r\n```bash\r\ncat > ~/frps/frps.ini  << EOF\r\n# frps.ini\r\n[common]\r\n# 这里是基本配置部分\r\nbind_port = 7000\r\nbind_udp_port = 7000\r\n\r\n# 这里设置鉴权方式为:token\r\nauthentication_method = token\r\n# 随便写一段英文+数字 服务端和客户端需一致\r\ntoken = swhm3elmbxnbnuqvoh5i5wlitjyymv22\r\nEOF\r\n```\r\n\r\n**临时启动服务测试是否配置成功**\r\n```bash\r\n~/frps/frps -c ~/frps/frps.ini\r\n```\r\n\r\n\r\n**配置开机自启:创建并编辑 frps.service 文件**\r\n\r\n```bash\r\n# su用于提权 否则无法使用cat\r\nsu\r\ncat > /etc/systemd/system/frps.service  << EOF\r\n# for redhat8\r\n[Unit]\r\n# 服务名称，可自定义\r\nDescription = frp server\r\nAfter = network.target syslog.target\r\nWants = network.target\r\n\r\n[Service]\r\nType = simple\r\n# 启动frps的命令，需修改为您的frps的安装路径\r\n# /home/userName/ 为路径\r\nExecStart = /home/dyg/frps/frps -c /home/dyg/frps/frps.ini\r\n\r\n[Install]\r\nWantedBy = multi-user.target\r\nEOF\r\n```\r\n\r\n**配置开机自启:使用 systemd 命令，管理 frps**\r\n```bash\r\n# 启动frp\r\nsystemctl start frps\r\n# 停止frp\r\nsystemctl stop frps\r\n# 重启frp\r\nsystemctl restart frps\r\n# 查看frp状态\r\nsystemctl status frps\r\n# 配置 frps 开机自启\r\nsystemctl enable frps\r\n# 取消配置 frps 开机自启\r\nsystemctl disable frps\r\n```\r\n\r\n\r\n\r\n## 客户端配置（win10电脑）\r\n**frpc.ini文件**\r\n```txt\r\n[common]\r\nprotocol = tcp\r\n# xx.xx.xx.xx 为服务端ip地址或域名\r\nserver_addr = xx.xx.xx.xx\r\nserver_port = 7000\r\nauthentication_method = token\r\n# 随便写一段英文+数字 服务端和客户端需一致\r\ntoken = swhm3elmbxnbnuqvoh5i5wlitjyymv22\r\n\r\n# win10远程桌面TCP配置\r\n[mstsc_TCP]\r\ntype = tcp\r\nlocal_ip = 127.0.0.1\r\nlocal_port = 3389\r\nremote_port = 11111\r\n\r\n# win10远程桌面UDP配置\r\n[mstsc_UDP]\r\ntype = udp\r\nlocal_ip = 127.0.0.1\r\nlocal_port = 3389\r\nremote_port = 11111\r\n```\r\n\r\n**启动服务**\r\n将frpc.exe和frpc.ini放置到相同目录,然后执行\r\n```bash\r\n./frpc.exe\r\n```\r\n\r\n\r\n\r\n## 客户端配置2（ubuntu20.04）\r\n适用于ubuntu centos\r\n```bash\r\n# 切换目录\r\ncd frp_0.44.0_linux_amd64/\r\n# frpc拷贝到/usr/local/bin/\r\nsudo cp frpc /usr/local/bin/frpc\r\n# frpc.ini拷贝到/etc/frp/\r\nsudo mkdir /etc/frp/\r\nsudo cp frpc.ini /etc/frp/\r\n# 编辑配置为系统服务\r\nvim /usr/lib/systemd/system/frpc.service\r\n#########################################\r\n[Unit]\r\nDescription=frpc\r\nAfter=network.target\r\n[Service]\r\nTimeoutStartSec=1\r\nExecStart=/usr/local/bin/frpc -c /etc/frp/frpc.ini\r\nExecStop=/bin/kill $MAINPID\r\n[Install]\r\nWantedBy=multi-user.target\r\n###########################################\r\n\r\n# 启动 frp 并设置开机启动\r\nsystemctl enable frpc\r\nsystemctl start frpc\r\nsystemctl status frpc\r\n \r\n# 部分服务器上,可以需要加 .service 后缀来操作,即:\r\nsystemctl enable frpc.service\r\nsystemctl start frpc.service\r\nsystemctl status frpc.service\r\n```"},{"shortInfo":{"title":"gitalk使用问题和解决方案及相关知识点简记","date":"2022-06-02T18:40:47.000Z","tags":["gitalk"],"hideAtIndex":true,"catalagues":"笔记","cover":"\\self_server\\assets\\images\\default_cover2.jpg","id":13,"countWords":2001,"readSeconds":200.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# gitalk使用问题和解决方案及相关知识点简记\r\n* 遇到的问题是管理员突然无法初始化文章底部的评论区\r\n* 了解其工作原理和造成该问题的原因后发现没有简单的解决方法\r\n* 在此简要记录一下造成的原因和其中一些原先不懂的知识点\r\n\r\n## 问题及原因\r\n1. 管理者初始化某篇文章下的评论区实际上就是登陆`github`并用其账号创建一个`issue`的过程，完成这个操作前需要：用户授权code + `clientID`+`clientSecret` 向`https://github.com/login/oauth/access_token`发送`POST`请求以获取`access_token`\r\n1. 但由于当前的站点页面是`username.github.io`,需要另外请求资源的地址是`github.com`,这属于`跨域访问`，需要发送`跨域访问请求`，而此时 `https://github.com/login/oauth/access_token` ，**不支持跨域访问请求**，所以无法获取 `access_token`\r\n1. 于是就要通过允许跨域访问的公用代理服务器`https://cors-anywhere.herokuapp.com/`，告诉他你要访问什么地址，需要发送什么数据，让它来做代理，替你获取`access_token`\r\n1. `gitalk`原先`默认`使用的是`https://cors-anywhere.azm.workers.dev`，其服务器在国外，现已经被墙\r\n1. 而`https://cors-anywhere.herokuapp.com/`是`cors-anywhere`项目的示例服务器，由于使用的人太多，现在已经被限制使用\r\n1. 并且使用上述两个公用的代理服务器是不安全的，因为获取`access_token`需要把`秘钥clientSecret`发送给他们\r\n\r\n## 注意\r\n* 这里的clientID是OAuth应用程序的ID\r\n* 这里的clientSecret是OAuth应用程序用于授权登录的秘钥\r\n* GitHub授权登录过程\r\n    1. 首先授权账号的 OAuth 服务。\r\n    1. **Get**   `https://github.com/login/oauth/authorize?client_id=?&redirect_uri=?`\r\n        + 携带的必须参数的是`client_id`和`redirect_uri`(和设置OAuth时的地址相同)\r\n        + 用户登录github账号并且点击授权登录之后\r\n        + Github会返回一个`code`\r\n        + 并重定向到`redirect_uri`\r\n    1. **Post**  `https://github.com/login/oauth/access_token`\r\n        + 携带的必须参数为 `client_id`    `client_secret`      `code`      `redirect_uri`\r\n        + 然后Github会返回一个`access_token`\r\n        + 并重定向到我们的`redirect_uri`\r\n    1. **Get**  `https://api.github.com/user`\r\n        + 携带的参数格式为 Header:   \"Authorization\" : \"token access_token \"\r\n    1. Github返回我们的user信息，授权登录完成。\r\n\r\n\r\n## 解决方案\r\n* 可以用`cors-anywhere`项目的解决方案\r\n* 也可以只在本地架设代理服务器\r\n    * 好处是不会暴露秘钥\r\n    * 坏处是只能在本地初始化评论区\r\n* 本地用python架设代理服务器：\r\n    * flask不适用于生产环境\r\n    * 有空打算写一个nodejs版的\r\n```python\r\nimport requests\r\nimport flask\r\nfrom flask_cors import CORS\r\n\r\nserver = flask.Flask(__name__)\r\n\r\n# 跨域访问问题\r\nCORS(server, resources=r'/*')\r\n\r\n# github auth\r\nclient_id = \"你自己的\"\r\nclient_secret = \"你自己的\"\r\n\r\n\r\n# 接口返回格式 {\"access_token\":\"gho_COSr3lUITUX9b2J7krsKjNlnlNSOBw2g0oZ1\",\"token_type\":\"bearer\",\"scope\":\"public_repo\"}\r\n@server.post('/get_access_token')\r\ndef get_access_token():\r\n    url = 'https://github.com/login/oauth/access_token'\r\n    params = {\r\n        'client_id': client_id,\r\n        'client_secret': client_secret,\r\n        'code': flask.request.json['code']\r\n    }\r\n    headers = {\r\n        'accept': 'application/json'\r\n    }\r\n    result = requests.post(url=url, params=params, headers=headers, verify=False)\r\n    # 存储access_token\r\n    # ..暂时不需要\r\n    return result.json()\r\n\r\n\r\nif __name__ == '__main__':\r\n    server.run(host='0.0.0.0', port=8011, debug=False)\r\n\r\n\r\n## copy from \"https://apidocs.cn/blog/front/js/修改Gitalk代理地址，解决无法登录问题.html\"\r\n```\r\n* 然后Gitalk的代码也需要更改：\r\n```js\r\nnew Gitalk({\r\n    // '''\r\n    proxy: 'https://IP:PORT/get_access_token'\r\n    //clientSecret: '', 此行配置可以去除了\r\n    // '''\r\n})\r\n```\r\n\r\n## 关于跨域请求\r\n* 跨域资源共享(CORS)是一种机制\r\n* 它允许浏览器向跨源服务器，发出XMLHttpRequest或Fetch请求。并且整个CORS通信过程都是浏览器自动完成的，不需要用户参与。\r\n* 过程\r\n    - 浏览器先根据同源策略对前端页面和后台交互地址做匹配，若同源，则直接发送数据请求；若不同源，则发送跨域请求。\r\n    - 服务器收到浏览器跨域请求后，根据自身配置返回对应文件头。若未配置过任何允许跨域，则文件头里不包含 Access-Control-Allow-origin 字段，若配置过域名，则返回 Access-Control-Allow-origin + 对应配置规则里的域名的方式。\r\n    - 浏览器根据接受到的 响应头里的 Access-Control-Allow-origin 字段做匹配，若无该字段，说明不允许跨域，从而抛出一个错误；若有该字段，则对字段内容和当前域名做比对，如果同源，则说明可以跨域，浏览器接受该响应；若不同源，则说明该域名不可跨域，浏览器不接受该响应，并抛出一个错误。\r\n* 举例来说\r\n    * 浏览器访问a.com时 页面中有一个资源来自b.com\r\n    * 浏览器获取来自a.com的资源时,发送普通请求；浏览器获取来自b.com的资源时，发送的是跨域请求.\r\n    * b.com的服务器如果不允许跨域，收到跨域请求后,发送响应，响应头中不包含Access-Control-Allow-origin 字段\r\n    * b.com的服务器如果允许跨域，收到跨域请求后,发送响应，响应头中包含Access-Control-Allow-origin + 允许的跨域规则（比如说www.*.com）\r\n    * 浏览器收到之后会看Access-Control-Allow-origin字段，没有这个字段就抛出错误\r\n    * 有这个字段还得看内容是不是包含a.com，不包含就抛出错误，包含就接受这个响应\r\n\r\n\r\n\r\n## CSDN上看到的相关知识点的总结\r\n```text\r\nCORS的哪些是简单请求？\r\n简单请求不会触发CORS的预检请求，若请求满足所有下述条件，则该请求可视为“简单请求”：\r\n\r\n简洁版：\r\n只能使用GET、HEAD、POST方法。使用POST方法向服务器发送数据时，Content-Type只能使用application/x-www-form-urlencoded、multipart/form-data\r\n或 text/plain 编码格式。\r\n请求时不能使用自定义的HTTP Headers\r\n\r\n完整版：\r\n\r\n(一) 使用下列方法之一\r\n\r\nGET HEAD POST\r\n\r\n(二) 只能设置以下集合中的请求头\r\n\r\nAccept Accept-Language Content-Language Content-Type(但是有限制) DPR\r\nDownlink Save-Data Viewport-Width Width\r\n\r\n(三) Content-Type的值仅限于下面的三者之一\r\n\r\ntext/plain multipart/form-data application/x-www-form-urlencoded\r\n\r\n请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。\r\n\r\n请求中没有使用 ReadableStream 对象。\r\n\r\n除了上面这些请求外，都是非简单请求。\r\n\r\nCORS的预检请求具体是怎样的？\r\n若是跨域的非简单请求的话，浏览器会首先向服务器发送一个预检请求，以获知服务器是否允许该实际请求。\r\n\r\n整个过程大概是：\r\n\r\n浏览器给服务器发送一个OPTIONS方法的请求，该请求会携带下面两个首部字段：\r\nAccess-Control-Request-Method: 实际请求要用到的方法\r\nAccess-Control-Request-Headers: 实际请求会携带哪些首部字段\r\n若是服务器接受后续请求，则这次预请求的响应体中会携带下面的一些字段：\r\nAccess-Control-Allow-Methods: 服务器允许使用的方法\r\nAccess-Control-Allow-Origin: 服务器允许访问的域名\r\nAccess-Control-Allow-Headers: 服务器允许的首部字段\r\nAccess-Control-Max-Age: 该响应的有效时间(s),在有效时间内浏览器无需再为同一个请求发送预检请求\r\n预检请求完毕之后，再发送实际请求\r\n这里有两点要注意（注意，注意，注意）：\r\n关于Access-Control-Max-Age，浏览器自身也有维护一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效，而是以最大有效时间为主。\r\n当你勾选了浏览器的 Disable cache选项时，会导致浏览器每次非简单请求都会发送预检请求\r\n————————————————\r\n版权声明：本文为CSDN博主「Henry_楠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/haonan_z/article/details/122105620\r\n\r\n```"},{"shortInfo":{"layout":"post","title":"gittalk的使用示例","date":"2022-02-23T12:38:00.000Z","cover":"\\self_server\\assets\\images\\gittalk.png","coverWidth":1430,"coverHeight":577,"tags":["笔记","gitalk"],"hideAtIndex":true,"categories":"前端","id":16,"countWords":187,"readSeconds":18.7,"assetsbaseUrl":"/self_server/assets/"},"content":"## GitTalk 提示错误Error: Validation Failed. \r\n* 原因：提交的id过长（超出50）\r\n* 解决办法：使用id: decodeURI(location.href)\r\n\r\n## GitHub issue内容出现UTF-8编码的中文的解决\r\n* body: decodeURI(window.location.pathname)\r\n\r\n## 获取页面内容的简短描述（不好用）\r\n* document.getElementsByTagName(\"meta\")[\"description\"].content\r\n\r\n## 示例代码\r\n```\r\n//存放gitalk的div\r\n<div id=\"gitalk\"></div>\r\n\r\n//实例化\r\n<script type=\"text/javascript\">\r\n    var gitalk = new Gitalk({\r\n        clientID: \"必填\",\r\n        clientSecret: \"必填\",\r\n        repo: \"必填\",\r\n        owner: \"必填\",\r\n        admin: \"必填\",\r\n        \r\n        id: decodeURI(location.href),//页面的唯一标识。长度必须小于50。location.href是不包含域名的URL\r\n        title: document.title,//GitHub issue标题。\r\n        body: decodeURI(window.location.pathname),//GitHub issue内容 = 文章完整URL地址\r\n\r\n        pagerDirection: ,//评论排序方式\r\n        createIssueManually: ,//admin用户手动创建issue\r\n    })\r\n    gitalk.render('gitalk') //渲染到指定的id中\r\n</script>\r\n```"},{"shortInfo":{"layout":"post","title":"git命令备忘笔记","date":"2022-01-09T12:28:00.000Z","cover":"\\self_server\\assets\\images\\git.jpg","coverWidth":1915,"coverHeight":895,"tags":["笔记","git"],"categories":"笔记","id":15,"countWords":2715,"readSeconds":271.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# git命令备忘笔记\r\n\r\n## 目录\r\n- [git命令备忘笔记](#git命令备忘笔记)\r\n  - [目录](#目录)\r\n  - [git用户配置](#git用户配置)\r\n  - [编辑git配置文件:](#编辑git配置文件)\r\n  - [查看配置信息](#查看配置信息)\r\n  - [git默认编辑器配置](#git默认编辑器配置)\r\n  - [git默认差异分析工具配置](#git默认差异分析工具配置)\r\n  - [基本操作](#基本操作)\r\n  - [有关创建与提交你的项目的快照的命令：](#有关创建与提交你的项目的快照的命令)\r\n  - [git-查看提交历史](#git-查看提交历史)\r\n  - [远程操作](#远程操作)\r\n  - [git分支管理](#git分支管理)\r\n  - [git 标签](#git-标签)\r\n  - [ssh加密通信配置](#ssh加密通信配置)\r\n  - [windows-git工具打开后自动测试](#windows-git工具打开后自动测试)\r\n  - [将已经提交到远程仓库的版本撤销](#将已经提交到远程仓库的版本撤销)\r\n  - [子仓库](#子仓库)\r\n    - [包含子仓库](#包含子仓库)\r\n    - [从远端克隆父仓库后子仓库为默认为空，需执行以下操作来下载子仓库](#从远端克隆父仓库后子仓库为默认为空需执行以下操作来下载子仓库)\r\n    - [删除误添加到暂存区的子仓库](#删除误添加到暂存区的子仓库)\r\n  - [提交信息为当前日期](#提交信息为当前日期)\r\n\r\n## git用户配置\r\n* `git config --global user.name \"YiguiDing\"`\r\n* `git config --global user.email 2449695354@qq.com`\r\n* `--global` 意味着配置文件写入进当前用户的家目录的全局配置文件\r\n* 去掉该选项意味着配置文件写入当前项目的`.git/config`文件文件\r\n\r\n## 编辑git配置文件:\r\n* `git config -e         `    # 针对当前仓库 \r\n* `git config -e --global ` # 针对系统上所有仓库\r\n\r\n## 查看配置信息\r\n* `git config --list`\r\n* 输出信息中重复的变量名代表来自不同的文件如\r\n  * 系统配置文件 `/etc/gitconfig `\r\n  * 全局配置文件 `~/.config `\r\n  * 项目配置文件 `./.git/config`\r\n* 查询单个配置变量 `git config user.name`\r\n\r\n## git默认编辑器配置\r\n* `git config --global core.editor vim`\r\n* 一般为vi vim 或特殊配置为Emacs\r\n\r\n## git默认差异分析工具配置\r\n* `git config --global merge.tool vimdiff`\r\n* Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。\r\n\r\n\r\n  \r\n## 基本操作\r\n* 将当前所在目录初始化为git仓库: `git init `\r\n* 将XXX目录初始化为git仓库: `git init XXX `\r\n* 告诉Git开始对这些文件进行跟踪: `git add 文件名`\r\n* 提交：`git commit -m \"提交消息\"`\r\n  * linux系统中提交用单引号，win用双引号\r\n* 推送到远程仓库：`git push origin master`\r\n* 克隆远程仓库 `git clone 仓库地址 [指定目录]`\r\n\r\n## 有关创建与提交你的项目的快照的命令：\r\n* `git add\t`    添加文件到暂存区\r\n  * `git add 文件名1 文件名2 文件名3`\r\n  * `git add 文件夹名`\r\n  * `git add . `当前所在文件夹\r\n* `git status`\t查看仓库当前的状态，显示有变更的文件。\r\n  * `-s`参数来获得简短的输出结果\r\n  * `红色??` 表示该文夹没有被追踪（添加到缓存区）\r\n  * `绿色A`  表示该文件已被追踪（添加到缓存区）\r\n  * `绿A红M `    表示该文件添加到缓存之后又有改动。\r\n* `git diff`\t    比较文件的不同，即暂存区和工作区的差异。\r\n  * 尚未缓存的改动：`git diff`\r\n  * 查看已缓存的改动： `git diff --cached`\r\n  * 查看已缓存的与未缓存的所有改动：`git diff HEAD`\r\n  * 显示摘要而非整个diff：`git diff --stat`\r\n  * 显示暂存区和工作区的差异: `git diff [file]`\r\n  * 显示暂存区和上一次提交(commit)的差异:\r\n    * `git diff --cached [file]`\r\n    * `git diff --staged [file]`\r\n  * 显示两次提交之间的差异:\r\n    * `git diff [first-branch]...[second-branch]`\r\n* `git commit`\t提交暂存区到本地仓库。\r\n  * 提交暂存区所有内容：`git commit -m [message]`\r\n  * 提交暂存区指定内容：`git commit [file1] [file2] ... -m [message]`\r\n  * `git -am \"修改了123.txt文件\"`\r\n    * `-a`意味着可以跳过`git add 123.txt`步骤，直接提交\r\n*` git reset`\t    回退版本。\r\n  * `git reset [--soft | --mixed | --hard] [HEAD]`\r\n  * `--soft` 工作区和暂存区内容保持不变，本地仓库回退一个版本\r\n  * `--mixed `为默认，工作区保持不变,暂存区内容回退到上一次提交版本\r\n  * `--hard` 工作区和暂存区内容都回退到上一次提交版本\r\n* `git rm`\t    删除工作区文件。\r\n  * 将文件从暂存区和工作区中删除(该文件提交到暂存区后未被修改)：`git rm fileName.txt`\r\n  * 强行从暂存区和工作区中删除一个文件(该文件提交到暂存区后又被修改)：`git rm -f fileName.txt `\r\n  * 将文件从暂存区删除，但在工作区中保留：`git rm --cached fileName.txt`\r\n  * 进入某个目录中，递归删除该目录下的所有文件和子目录： `git rm –r * `\r\n* `git mv`\t    移动或重命名工作区文件。\r\n  * 移动或重命名：`git mv [file] [newfile]`\r\n  * 强制移动并覆盖：`git mv -f [file] [newfile]`\r\n\r\n## git-查看提交历史\r\n* `git log` - 查看历史提交记录。\r\n  * `-6` 指定列出条数\r\n  *  `--oneline` 选项来查看历史记录的简洁的版本\r\n  *  `--all` 查看所有分支的提交历史\r\n  *  `--graph` 选项，查看历史中什么时候出现了分支、合并。\r\n  *  ` --no-merges` 选项以隐藏合并提交记录\r\n  *  `--reverse` 参数来逆向显示所有日志\r\n  *  `--author=YiguiDing` 查找指定用户的提交日志\r\n  *   `--after` `--since`指定日期之后，使用格式：`--after={2010-04-18}`\r\n  *   `--before` `--until`指定日期之前，使用格式：`--before={3.weeks.ago}` \r\n* `git blame file` - 以列表形式查看指定文件的历史修改记录。\r\n\r\n\r\n## 远程操作\r\n* `git remote`\t远程仓库操作\r\n  * `git remote show [remote]` 显示某个远程仓库详细信息\r\n  * `git remote add [shortName] [url]` 为一个远程库取一个**简短名**\r\n  * `git remote rm shortName`  # 删除远程仓库**简短名**\r\n  * `git remote reName old_shortName new_shortName`  # 修改仓库**简短名**\r\n  * `-v` 列举当前仓库remote远程仓库**简短名**和**实际地址**之间的对应关系\r\n* `git fetch`   从远程获取代码库\r\n  * `git fetch origin` 从远程获取代码库但不合并到当前分支\r\n  * `git merge origin/master` 将远程代码的主分支合并到当前分支\r\n* `git pull`    下载远程代码并合并\r\n  * 其实就是 `git fetch` 和 `git merge local_master` 的简写\r\n  * `git pull <远程主机名> <远程分支名>:<本地分支名>`\r\n  * `git pull origin master:brantest`将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。\r\n  * `git pull origin master`与当前分支合并,冒号后面的部分可以省略。\r\n* `git push`    上传远程代码并合并\r\n    * `git push <远程主机名> <本地分支名>:<远程分支名>` \r\n    * `git push <远程主机名> <本地分支名>` 如果远程分支名与本地分支名相同，则可以省略冒号`:`及其之后内容\r\n\r\n## git分支管理\r\n* `git branch`列出分支\r\n* `git branch newBranchName`创建一个分支\r\n  * `-b` 创建分支后立马切换\r\n  * `-d` 删除分支\r\n* `git checkout newBranchName`切换到新创建的分支\r\n* 分支切换时，如果工作区内容的全部提交，工作区的全部内容会变成新分支的内容，否则未提交的内容会带新分支去\r\n* `git merge branchA` 将分支branchA合并到当前分支中去\r\n  * 合并完成后可以删除branchA分支\r\n  * 当两个分支内容存在冲突时，合并的操作步骤：\r\n    1. 执行合并操作\r\n    1. 提示有文件存在冲突\r\n    1. 手动编辑那些已经合并但存在冲突的文件，删除冲突代码\r\n    1. 执行`git add 文件名` 用用于告诉Git 文件冲突已经解决\r\n    1. 不带参数的执行`git commit`\r\n    1. 成功合并后git将会做出提示\r\n\r\n## git 标签\r\n* `git tag` 默认为给最新一次提交（HEAD）打上标签\r\n* `git tag 3e92c19 ` 给3e92c19(commit id)打上标签\r\n* `-m` 指定标签信息注解内容,示例`git tag -a <tagname> -m \"runoob.com标签\"`\r\n* `-a` (annotated)选项意为\"创建一个带注解的标签\" 会记录这标签是啥时候打的，谁打的，\r\n* `-s` (signed)如果有私钥,可用GPG签署标签,示例：`git tag -s 标签名 -m '标签说明'`\r\n* `-d` 删除标签 `git tag -d 标签名`\r\n* `git show 标签名` 查看标签信息\r\n* `git tag` 查看所有标签\r\n* `git log --decorate` ，也可以看到打的标签\r\n\r\n## ssh加密通信配置\r\n* 配置成功后可以免密码向远程仓库推送\r\n  * 使用格式大致为`git push git@github.com:username/pathToProgectName.git localBranchName:remoteBranchName`\r\n1. 生成 SSH密钥 `ssh-keygen -t rsa -C \"youremail@example.com\"`\r\n    * 将生成两个文件 公钥 `~/.ssh/id_rsa.pub` 和 私钥`~/.ssh/id_rsa`\r\n        * 其中.ssh目录的权限最高允许为755，最低允许为700，也就是说属主用户的权限为rwx,其他用户不能拥有w权限\r\n        * 私钥的权限必须为600 \r\n        * 公钥的权限一般为644,最低应该是600\r\n        * `authoried_keys`权限一般为644，最低应该是600\r\n1. 将生成的SSH公钥附加到服务端的authoried_keys记录文件中\r\n    * 先在客户端将文件拷贝到服务端`scp ~/.ssh/id_rsa.pub root@域名或IP:~/.ssh/authorized_keys`\r\n    * scp使用SSH方式登录，会要求输入密码\r\n1. 再在服务端执行附加命令`cat id_rsa.pub >> authorized_keys`\r\n1. 确保服务端的SSH配置`/etc/ssh/sshd_config`文件中有：\r\n    * `RSAAuthentication yes`\r\n    * `PubkeyAuthentication yes`\r\n    * 其他无关紧要的配置\r\n      * `PermitRootLogin yes`\r\n      * `PasswordAuthentication no`\r\n    * 如有不同需要修改,然后重启服务`service sshd restart`\r\n1. 客户端SSH配置示例`/etc/ssh/ssh_config`\r\n```\r\nHost *\r\n  IdentityFile ~/.ssh/id_rsa\r\nHost github.com\r\n  IdentityFile ~/.ssh/id_rsa\r\nHost gitee.com\r\n  IdentityFile ~/.ssh/id_rsa\r\n```\r\n\r\n## windows-git工具打开后自动测试\r\n附加两行内容到`/etc/profile`或`~/.profile`文件中\r\n  * `ssh git@github.com`\r\n  * `ssh git@gitee.com\r\n`\r\n\r\n## 将已经提交到远程仓库的版本撤销\r\n* `git log --oneline` 找出上一次提交版本的commitID\r\n* `git reset --mixed xxxx` 将缓存区恢复成该commitID\r\n* `git add .` 重新将工作区文件添加到缓存区\r\n* `git commit -m \"xxxxxxx\"` 提交到本地仓库\r\n* `git push origin master --force` 强制推送到远程仓库\r\n\r\n\r\n## 子仓库\r\n### 包含子仓库\r\n* 格式：`git submodule add \"url\" \"add_To_path\"`\r\n    * `git submodule add git@github.com:YiguiDing/js_russuaGame.git`\r\n    * `git submodule add git@github.com:YiguiDing/js_russuaGame.git ./js_russuaGame`\r\n\r\n### 从远端克隆父仓库后子仓库为默认为空，需执行以下操作来下载子仓库\r\n* `git submodule init`\r\n* `git submodule update`\r\n\r\n### 删除误添加到暂存区的子仓库\r\n* `git rm --cached html-js_russiaGame`\r\n\r\n## 提交信息为当前日期\r\n* `git commit -m \"$(date)\"`\r\n* **$(command)** 与 **\\`command\\`**\r\n  * linux中**echo $(date)** 和 **echo \\`date\\`** 的作用是将date命令的结果用echo输出\r\n  * 在Windows的git工具中两种都能使用（类似Linux环境）\r\n  * 但是在powerShell中只有第一种能使用\r\n"},{"shortInfo":{"layout":"post","title":"Hexo备忘笔记","date":"2022-02-23T01:50:00.000Z","cover":"\\self_server\\assets\\images\\Hexo.jpg","tags":["笔记","Hexo"],"hideAtIndex":true,"categories":"笔记","id":18,"countWords":360,"readSeconds":36,"assetsbaseUrl":"/self_server/assets/"},"content":"# Hexo安装使用\r\nHexo 是一个快速、简洁且高效的博客框架。\r\nNexmoe是该博客框架的一个主题\r\n\r\n1. 创建conda环境（可有可无\r\n    * conda creat --name Hexo\r\n    * conda activate Hexo\r\n\r\n\r\n1. 安装 Hexo \r\n\t* 环境安装\r\n\t\tNode.js（包含npm，npx\r\n\t\tGit\r\n\t* 安装 Hexo\r\n\t\t安装给当前目录的项目：\r\n\t\t\tnpm install hexo\r\n\t\t安装到全局：（如果不想把所有文件防在当前目录）\r\n\t\t\tnpm install -g hexo-cli\r\n\t\ttips：hexo-cli是hexo命令行模式\r\n\r\n1. 使用Hexo：\r\n    * npx hexo + 参数\r\n    * hexo + 参数\r\n\t    + 需将 Hexo 所在的目录下的 node_modules 添加到环境变量：\r\n\t    + echo 'PATH=\"$PATH:./node_modules/.bin\"' >> ~/.profile\r\n\r\n## Hexo常用命令\r\n1. hexo init [folder] 默认在目前的文件夹建立网站\r\n\t本命令相当于执行了以下几步：\r\n\t\tGit clone hexo-starter 和 hexo-theme-landscape 主题到当前目录或指定目录。\r\n\t\t使用npm 包管理器下载依赖\r\n\r\n1. hexo generate\r\n\t使用 Hexo 生成静态文件\r\n1. hexo generate --watch\r\n\t监视文件变动并立即重新生成静态文件\r\n1. hexo generate --deploy\r\n1. hexo deploy --generate\r\n\t生成完毕后自动部署网站\r\n\r\n1. **hexo clean && hexo generate && hexo deploy**\r\n\t清除,生成,部署\r\n\r\n## 为Hexo安装配置修改Nexmoe主题\r\n* 安装\r\n\tnpm i hexo-theme-nexmoe\r\n* 安装依赖 WordCount\r\n\tnpm i --save hexo-wordcount\r\n* 配置 Nexmoe​\r\n\t在 Hexo 根目录下修改 _config.nexmoe.yml\r\n* 在本地启动一个 Hexo Server\r\n\thexo s --debug\r\n\r\n## 官方文档\r\n- hexo博客框架: https://hexo.io/zh-cn/docs/index.html\r\n- Nexmoe主题: https://docs.nexmoe.com/"},{"shortInfo":{"title":"Hexo文章中图片的点击放大fancyBox效果添加过程记录","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-06-02T06:51:44.000Z","tags":["Hexo","fancybox"],"hideAtIndex":true,"categories":"前端","id":19,"countWords":298,"readSeconds":29.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# Hexo文章中图片的点击放大fancyBox效果添加过程记录\r\n* 根据文档应该在post模板head中添加:\r\n```html\r\n<script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"></script>\r\n\r\n<link  href=\"/path/to/jquery.fancybox.min.css\" rel=\"stylesheet\">\r\n<script src=\"/path/to/jquery.fancybox.min.js\"></script>\r\n\r\n```\r\n\r\n* 根据文档需要有以下代码才能使图片有点击放大查看的效果\r\n```html\r\n<a data-fancybox=\"gallery\" href=\"big_1.jpg\">\r\n    <img src=\"small_1.jpg\">\r\n</a>\r\n```\r\n\r\n* 于是找到`node_modules/hexo-renderer-marked/renderer.js`文件，修改代码\r\n    * 该文件负责将Markdown转换为html标签\r\n    * 如负责将`![text](/path/to/image.jpg)` 转换为 `<img src=\"/blog/path/to/image.jpg\" alt=\"text\">`\r\n\r\n```js\r\n// Prepend root to image path\r\n  image(href, title, text) {\r\n    const { hexo, options } = this;\r\n    const { relative_link } = hexo.config;\r\n    const { lazyload, prependRoot, postPath } = options;\r\n\r\n    if (!/^(#|\\/\\/|http(s)?:)/.test(href) && !relative_link && prependRoot) {\r\n      if (!href.startsWith('/') && !href.startsWith('\\\\') && postPath) {\r\n        const PostAsset = hexo.model('PostAsset');\r\n        // findById requires forward slash\r\n        const asset = PostAsset.findById(join(postPath, href.replace(/\\\\/g, '/')));\r\n        // asset.path is backward slash in Windows\r\n        if (asset) href = asset.path.replace(/\\\\/g, '/');\r\n      }\r\n      href = url_for.call(hexo, href);\r\n    }\r\n\r\n    //原版代码\r\n    // let out = `<img src=\"${encodeURL(href)}\"`;\r\n    // if (text) out += ` alt=\"${text}\"`;\r\n    // if (title) out += ` title=\"${title}\"`;\r\n    // if (lazyload) out += ' loading=\"lazy\"';\r\n    // out += '>';\r\n    // return out;\r\n\r\n    //为gallery效果而改的代码\r\n    let out = `<a data-fancybox=\"gallery\" href=\"${encodeURL(href)}\"><img src=\"${encodeURL(href)}\"`;\r\n    if (text) out += ` alt=\"${text}\"`;\r\n    if (title) out += ` title=\"${title}\"`;\r\n    if (lazyload) out += ' loading=\"lazy\"';\r\n    out += '></a>';\r\n    \r\n    return out;\r\n\r\n  }\r\n\r\n```\r\n"},{"shortInfo":{"layout":"post","title":"Hexo设置文章展示优先级","date":"2022-02-23T19:15:00.000Z","cover":"\\self_server\\assets\\images\\book1.jpg","tags":["笔记","Hexo"],"hideAtIndex":true,"categories":"笔记","id":20,"countWords":54,"readSeconds":5.4,"assetsbaseUrl":"/self_server/assets/"},"content":"1.安装插件\r\n\r\n```bash\r\nnpm install hexo-generator-index --save\r\n```\r\n2.设置文章优先级\r\n```md\r\n---\r\n**top: 1**\r\nlayout: post\r\ntitle: \"Hexo设置文章展示优先级\"\r\ndate: 2022-02-24 03:15:00 +0800\r\n---\r\n```\r\n1. 数值越大优先级越高"},{"shortInfo":{"title":"HTML5重学笔记","cover":"\\self_server\\assets\\images\\HTML5重学笔记\\cover.png","coverWidth":1920,"coverHeight":1080,"date":"2022-06-04T10:25:06.000Z","tags":["HTML","前端"],"hideAtIndex":true,"categories":"笔记","id":21,"countWords":4219,"readSeconds":421.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# HTML5重学笔记\r\n\r\n## 说明\r\n* 重学HTML5时顺便做的笔记，查缺补漏。\r\n* 受本网页内css样式的影响，展示的效果会与默认样式有所不同\r\n* `2022.06.12`：增添标签结构说明、SEO、ICO相关笔记\r\n## 目录\r\n- [HTML5重学笔记](#html5重学笔记)\r\n  - [说明](#说明)\r\n  - [目录](#目录)\r\n  - [基本结构](#基本结构)\r\n  - [标题h](#标题h)\r\n  - [段落p](#段落p)\r\n  - [换行和分割线](#换行和分割线)\r\n  - [文本格式化标签](#文本格式化标签)\r\n  - [链接标签a](#链接标签a)\r\n  - [图片](#图片)\r\n    - [媒体标签-图片](#媒体标签-图片)\r\n    - [媒体标签-音频](#媒体标签-音频)\r\n    - [媒体标签-视频](#媒体标签-视频)\r\n  - [列表标签](#列表标签)\r\n    - [列表标签-无序表](#列表标签-无序表)\r\n    - [列表标签-有序表](#列表标签-有序表)\r\n    - [列表标签-自定义列表](#列表标签-自定义列表)\r\n  - [表单](#表单)\r\n    - [表单-input输入标签](#表单-input输入标签)\r\n    - [表单-button标签](#表单-button标签)\r\n    - [表单-select标签下拉菜单](#表单-select标签下拉菜单)\r\n    - [表单-textaera文本域](#表单-textaera文本域)\r\n    - [实现点击文字也能选中单选按钮](#实现点击文字也能选中单选按钮)\r\n  - [table 表格](#table-表格)\r\n  - [语义化标签](#语义化标签)\r\n  - [字符实体标签](#字符实体标签)\r\n  - [seo搜索引擎优化](#seo搜索引擎优化)\r\n  - [ico浏览器标题栏图标](#ico浏览器标题栏图标)\r\n\r\n\r\n## 基本结构\r\n* `<!DOCTYPE html>` 说明是html5版本\r\n* `<html lang=\"en\">`\r\n    * **标识网页使用的语言**\r\n    * 作用： **搜索引擎归类** + **浏览器翻译**\r\n    * 常见语言：`zh-CN`简体中文 `en`英文\r\n* `<meta charset=\"UTF-8\">` 标识网页使用的字符编码\r\n    * `UTF-8` 万国码\r\n    * `GB3212` 6000+汉子\r\n    * `GBK` 20000+汉子\r\n* `<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">`\r\n    * 用于解决IE浏览器兼容性问题\r\n* `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">`\r\n    * `宽度=设备宽度`使得宽度等于设备宽度，用于移动端开发\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n</head>\r\n<body>\r\n    \r\n</body>\r\n</html>\r\n```\r\n\r\n\r\n## 标题h\r\n* h标签会自动换行\r\n* 共6级\r\n\r\n\r\n```html\r\n<h1>h1标题</h1> \r\n<h2>h2标题</h2> \r\n<h3>h3标题</h3> \r\n<h4>h4标题</h4> \r\n<h5>h5标题</h5> \r\n<h6>h6标题</h6>\r\n```\r\n\r\n效果：\r\n\r\n![](./images/HTML5重学笔记/2022-06-08-18-49-07.png)\r\n\r\n<hr>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 段落p\r\n* 段落之间有缝隙\r\n* 会自动换行\r\n* 但是连续的纯英文被认为是一个单词 不换行\r\n\r\n\r\n```html\r\n<p>ppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp</p>\r\n<p>自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行</p>\r\n<p>自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行自动换行</p>\r\n```\r\n\r\n效果：\r\n![](./images/HTML5重学笔记/2022-06-08-18-50-03.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 换行和分割线\r\n\r\n```html\r\n123<br>456<hr>\r\n```\r\n\r\n效果：\r\n![](./images/HTML5重学笔记/2022-06-08-18-49-46.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 文本格式化标签\r\n\r\n```html\r\n<b>加粗b</b>    <strong>表示重要性的加粗strong</strong> <br>\r\n<u>下划线u</u>  <ins>表示重要性的下划线ins</ins> <br>\r\n<i>倾斜i</i>  <em>表示重要性的倾斜em</em> <br>\r\n<s>删除s</s>  <del>表示重要性的删除del</del> <br>\r\n\r\n```\r\n\r\n效果：\r\n\r\n![](./images/HTML5重学笔记/2022-06-08-18-51-14.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 链接标签a\r\n* href 跳转地址\r\n* #空链接\r\n* target 目标网页的打开形式 \r\n    * _self（默认）在当前窗口打开\r\n    * _blank打开一个新窗口跳转\r\n\r\n```html\r\n\r\n<a href=\"baidu.com\">会出错 必须加协议</a>\r\n<br>\r\n<a href=\"http://baidu.com\">正常http://baidu.com</a>\r\n<br>\r\n<a href=\"./pathTofileName.html\">pathTofileName.html</a>\r\n<br>\r\n<a href=\"#\">空链接</a> \r\n<br>\r\n<a href=\"http://baidu.com\" target=\"_blank\">在新窗口打开百度</a>\r\n\r\n```\r\n\r\n效果：<br>\r\n<a href=\"baidu.com\">会出错 必须加协议</a>\r\n<br>\r\n<a href=\"http://baidu.com\">正常http://baidu.com</a>\r\n<br>\r\n<a href=\"./pathTofileName.html\">pathTofileName.html</a>\r\n<br>\r\n<a href=\"#\">空链接</a> \r\n<br>\r\n<a href=\"http://baidu.com\" target=\"_blank\">在新窗口打开百度</a>\r\n\r\n\r\n\r\n## 图片\r\n- [媒体标签-图片](#媒体标签-图片)\r\n- [媒体标签-音频](#媒体标签-音频)\r\n- [媒体标签-视频](#媒体标签-视频)\r\n\r\n### 媒体标签-图片\r\n* 概念\r\n    * img 是标签 \r\n    * src=\"\" 是标签的属性 \r\n    * src是属性名 \r\n    * \"\"是属性值\r\n* 标签和属性之间必须以空格隔开\r\n* 属性之间没有顺序\r\n* src 资源路径\r\n* alt 图片加载失败时的替换文本\r\n* title 鼠标悬停时的显示文本\r\n* width height 写一个就好 另一个会自动确定 写两个容易造成图片畸变，除非你非要这么做\r\n\r\n```html\r\n<img src=\"./images/web_img/user_icon.png\" alt=\"图片加载失败了\" title=\"鼠标悬停显示\" width=\"100px\">\r\n```\r\n\r\n效果：<br>\r\n<img src=\"./images/web_img/user_icon.png\" alt=\"图片加载失败了\" title=\"鼠标悬停显示\" width=\"100px\">\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 媒体标签-音频\r\n* controls 显示控制面板 默认不显示\r\n* autoplay 自动播放（好像基本上浏览器都不支持音频自动播放）\r\n* loop 循环\r\n\r\n```html\r\n<audio src=\"piano.mp3\" controls autoplay loop></audio>\r\n```\r\n\r\n### 媒体标签-视频\r\n* controls 添加播放控制面板\r\n* autoplay 自动播放 谷歌不支持(静音才能自动播放)\r\n* muted 静音\r\n* loop\r\n\r\n```html\r\n<video src=\"./00.mp4\" controls muted autoplay></video>\r\n```\r\n\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 列表标签\r\n- [列表标签-无序表](#列表标签-无序表)\r\n- [列表标签-有序表](#列表标签-有序表)\r\n- [列表标签-自定义列表](#列表标签-自定义列表)\r\n  \r\n### 列表标签-无序表\r\n* 无序列表\r\n* ul只能包含li标签\r\n* li标签可以包含任意标签\r\n\r\n```html\r\n<ul>\r\n    <li>西瓜</li>\r\n    <li>南瓜</li>\r\n    <li>冬瓜</li>\r\n</ul>\r\n```\r\n\r\n效果：\r\n\r\n![](./images/HTML5重学笔记/2022-06-08-18-52-43.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 列表标签-有序表\r\n* 有序列表\r\n* 默认有数字序号\r\n* ol中只能包含li\r\n* li中可以包含任意标签\r\n\r\n```html\r\n<ol>\r\n    <li>kkk</li>\r\n    <li>jjj</li>\r\n    <li>bbb</li>\r\n</ol>\r\n```\r\n\r\n效果：<br>\r\n![](./images/HTML5重学笔记/2022-06-08-18-53-11.png)\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 列表标签-自定义列表\r\n* 自定义列表\r\n* dl只能包含dt和dd\r\n* dt和dt可以包含任意标签\r\n\r\n```html\r\n<dl>\r\n    <dt>列标题</dt>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n</dl>\r\n```\r\n\r\n效果：<br>\r\n<dl>\r\n    <dt>列标题</dt>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n    <dd>列项</dd>\r\n</dl>\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 表单\r\n- [input输入标签](#表单-input输入标签)\r\n- [button标签](#表单-button标签)\r\n- [select标签下拉菜单](#表单-select标签下拉菜单)\r\n- [textaera文本域](#表单-textaera文本域)\r\n- [实现点击文字也能选中单选按钮](#实现点击文字也能选中单选按钮)\r\n\r\n### 表单-input输入标签\r\n\r\n```html\r\ntext:<input type=\"text\" placeholder=\"请输入用户名\"> <!--占位符placeholder-->\r\n<br><br>\r\npassword:<input type=\"password\" placeholder=\"请输入密码\"> <!--占位符placeholder-->\r\n<br><br>\r\nradio:<input type=\"radio\" name=\"性别\">男 <input type=\"radio\" name=\"性别\" checked>女  <!-- 单选框需要有同样的name --> <!--checked表示默认选中 -->\r\n<br><br>\r\ncheckbox:<input type=\"checkbox\" checked> <!--checked表示默认选中 -->\r\n<br><br>\r\nfile:<input type=\"file\" multiple>  <!-- multiple表示可以选中多个文件 -->\r\n<br><br>\r\nsubmit:<input type=\"submit\"> <!-- 提交按钮点击提交数据          要让其能够使用 需要一个表单域标签  value=\"显示的内容\" value默认为submit -->\r\n<br><br>\r\nreset:<input type=\"reset\"> <!-- 重置按钮 点击恢复表单默认值      要让其能够使用 需要一个表单域标签  value=\"显示的内容\" value默认为reset  -->\r\n<br><br>\r\nbutton:<input type=\"button\" value=\"这是一个按钮\"><!-- 普通按钮默认无功能要配合js  value=\"显示的内容\" value默认为空  -->\r\n\r\n<br><br>\r\n<hr>\r\n<form action=\"#提交地址\">\r\n    用户名：<input type=\"text\" name=\"\" id=\"\"><br>\r\n    密码：<input type=\"password\" name=\"\" id=\"\"><br>\r\n    <input type=\"submit\" name=\"\" id=\"\"><!--submit需要一个表单域标签-->\r\n    <input type=\"reset\"><!--reset需要一个表单域标签-->\r\n</form>\r\n\r\n```\r\n\r\n效果：<br>\r\ntext:<input type=\"text\" placeholder=\"请输入用户名\"> <!--占位符placeholder-->\r\n<br><br>\r\npassword:<input type=\"password\" placeholder=\"请输入密码\"> <!--占位符placeholder-->\r\n<br><br>\r\nradio:<input type=\"radio\" name=\"性别\">男 <input type=\"radio\" name=\"性别\" checked>女  <!-- 单选框需要有同样的name --> <!--checked表示默认选中 -->\r\n<br><br>\r\ncheckbox:<input type=\"checkbox\" checked> <!--checked表示默认选中 -->\r\n<br><br>\r\nfile:<input type=\"file\" multiple>  <!-- multiple表示可以选中多个文件 -->\r\n<br><br>\r\nsubmit:<input type=\"submit\"> <!-- 提交按钮点击提交数据          要让其能够使用 需要一个表单域标签  value=\"显示的内容\" value默认为submit -->\r\n<br><br>\r\nreset:<input type=\"reset\"> <!-- 重置按钮 点击恢复表单默认值      要让其能够使用 需要一个表单域标签  value=\"显示的内容\" value默认为reset  -->\r\n<br><br>\r\nbutton:<input type=\"button\" value=\"这是一个按钮\"><!-- 普通按钮默认无功能要配合js  value=\"显示的内容\" value默认为空  -->\r\n\r\n<br><br>\r\n<hr>\r\n<form action=\"#提交地址\">\r\n    用户名：<input type=\"text\" name=\"\" id=\"\"><br>\r\n    密码：<input type=\"password\" name=\"\" id=\"\"><br>\r\n    <input type=\"submit\" name=\"\" id=\"\"><!--submit需要一个表单域标签-->\r\n    <input type=\"reset\"><!--reset需要一个表单域标签-->\r\n</form>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 表单-button标签\r\n* button 谷歌中默认type是submit  \r\n* button type可选值为submit reset button\r\n* value属性似乎没什么用\r\n\r\n```html\r\n<button>提交</button>\r\n<button type=\"submit\" value=\"submit\">提交</button>\r\n<button type=\"reset\">重置</button>\r\n<button type=\"button\">普通按钮</button>\r\n```\r\n\r\n效果：<br>\r\n<button>提交</button>\r\n<button type=\"submit\" value=\"submit\">提交</button>\r\n<button type=\"reset\">重置</button>\r\n<button type=\"button\">普通按钮</button>\r\n\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 表单-select标签下拉菜单\r\n* select\r\n    * option\r\n        * selected\r\n\r\n```html\r\n<select name=\"\" id=\"\">\r\n    <option value=\"\">北京</option>\r\n    <option value=\"\">上海</option>\r\n    <option value=\"\">深证</option>\r\n    <option value=\"\" selected>广东</option>     <!--selected 属性表示默认被选中-->\r\n</select>\r\n```\r\n\r\n效果：<br>\r\n<select name=\"\" id=\"\">\r\n    <option value=\"\">北京</option>\r\n    <option value=\"\">上海</option>\r\n    <option value=\"\">深证</option>\r\n    <option value=\"\" selected>广东</option>     <!--selected 属性表示默认被选中-->\r\n</select>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 表单-textaera文本域\r\n* cols是控制列数\r\n* rows是控制行数\r\n* 但真正控制这个一般用css\r\n\r\n```html\r\n<textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"></textarea>\r\n```\r\n\r\n效果：<br>\r\n<textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"></textarea>\r\n\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n### 实现点击文字也能选中单选按钮\r\n* 方法1\r\n    *  将选项内容用lable扩起来\r\n    * 将lable的for属性设为radio的id\r\n* 方法2\r\n    * 直接用lable把input包裹起来\r\n需要删除lable的for属性\r\n\r\n```html\r\n<!-- 方法1 -->\r\n<input id=\"id_1\" type=\"radio\" name=\"sex\"> <label for=\"id_1\">男</label>\r\n<input id=\"id_2\" type=\"radio\" name=\"sex\"> <label for=\"id_2\">女</label>\r\n<!-- 方法2 -->\r\n<label  > <input  type=\"radio\" name=\"sex\"> 男    </label>\r\n<label > <input  type=\"radio\" name=\"sex\"> 女    </label>\r\n```\r\n\r\n效果：<br>\r\n<!-- 方法1 -->\r\n<input id=\"id_1\" type=\"radio\" name=\"sex\"> <label for=\"id_1\">男</label>\r\n<input id=\"id_2\" type=\"radio\" name=\"sex\"> <label for=\"id_2\">女</label>\r\n<!-- 方法2 -->\r\n<label  > <input  type=\"radio\" name=\"sex\"> 男    </label>\r\n<label > <input  type=\"radio\" name=\"sex\"> 女    </label>\r\n\r\n\r\n## table 表格\r\n* table 表格\r\n    * caption是表的标题\r\n    * tr是行\r\n        * th是表头单元格\r\n        * td是普通单元格\r\n* 表格也有结构(可省略)\r\n    * thead\r\n    * tbody\r\n    * tfoot\r\n* 表格跨行合并 表格跨列合并\r\n    * 原则 保留左上的并删除其他的，然后为保留的单元格设置属性\r\n    * 跨列rowspan=\"合并了几列?\"\r\n    * 跨行colspan\r\n    * 不能跨结构合并\r\n* 表格默认没有边框线,要border=\"1\"\r\n* 实际的样式应该在写在css中\r\n\r\n```html\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>标题</caption>\r\n    <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    <tr> <td>总结</td>   <td>男</td>     <td>18</td> </tr>\r\n</table>\r\n\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>标题</caption>\r\n    <tr> <th>姓名</th>   <td>DYG</td>    <td>HHH</td>   <td>KKK</td> </tr>\r\n    <tr> <th>性别</th>   <td>男</td>     <td>男</td>    <td>男</td>  </tr>\r\n    <tr> <th>年龄</th>   <td>18</td>     <td>18</td>    <td>18</td> </tr>\r\n</table>\r\n\r\n<!-- 表格也有结构(可省略) -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格也有结构(可省略)</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>   <td>XXX</td>     <td>XXX</td> </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨列合并 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨列合并</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>   <td colspan=\"2\">XXX</td>      </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨行合并 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨行合并</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>       <td rowspan=\"2\">男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>                                   <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>     <td>XXX</td>               <td>XXX</td>       </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨行又跨列 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨行又跨列</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>       <td rowspan=\"2\" colspan=\"2\">男</td>                      </tr>\r\n        <tr> <td>DYG</td>                                                               </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>     <td>XXX</td>               <td>XXX</td>                 </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n```\r\n\r\n效果：<br>\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>标题</caption>\r\n    <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    <tr> <td>总结</td>   <td>男</td>     <td>18</td> </tr>\r\n</table>\r\n\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>标题</caption>\r\n    <tr> <th>姓名</th>   <td>DYG</td>    <td>HHH</td>   <td>KKK</td> </tr>\r\n    <tr> <th>性别</th>   <td>男</td>     <td>男</td>    <td>男</td>  </tr>\r\n    <tr> <th>年龄</th>   <td>18</td>     <td>18</td>    <td>18</td> </tr>\r\n</table>\r\n\r\n<!-- 表格也有结构(可省略) -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格也有结构(可省略)</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>   <td>XXX</td>     <td>XXX</td> </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨列合并 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨列合并</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>   <td>男</td>     <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>   <td colspan=\"2\">XXX</td>      </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- 表格跨行合并 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨行合并</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>       <td rowspan=\"2\">男</td>     <td>18</td> </tr>\r\n        <tr> <td>DYG</td>                                   <td>18</td> </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>     <td>XXX</td>               <td>XXX</td>       </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n\r\n<!-- 表格跨行又跨列 -->\r\n<table border=\"1\" width=\"500\" height=\"200\" >\r\n    <caption>表格跨行又跨列</caption>\r\n    <thead>\r\n        <tr> <th>姓名</th>  <th>性别</th>    <th>年龄</th> </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr> <td>DYG</td>       <td rowspan=\"2\" colspan=\"2\">男</td>                      </tr>\r\n        <tr> <td>DYG</td>                                                               </tr>\r\n    </tbody>\r\n    <tfoot>\r\n        <tr> <td>总结:</td>     <td>XXX</td>               <td>XXX</td>                 </tr>\r\n    </tfoot>\r\n</table>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 语义化标签\r\n* 没有语义的标签div span\r\n    * div span是布局标签\r\n    * div独占一行\r\n    * span一行可以显示多个\r\n* 有语义的标签\r\n    * 这些标签是HTML5中的 主要用于移动端\r\n    * 这些标签特点和div一致，只是多了语义\r\n\r\n```html\r\n<!-- 没有语义的标签div span -->\r\n<div>div独占一行</div>\r\n<div>div独占一行</div>\r\n<span>span一行显示多个</span>\r\n<span>span一行显示多个</span>\r\n<br><hr>\r\n<!-- 有语义的标签 -->\r\n<header>网页头部</header>\r\n<nav>网页导航条</nav>\r\n<footer>网页底部</footer>\r\n<aside>网页侧边栏</aside>\r\n<section>网页区块</section>\r\n<article>网页文章article</article>\r\n```\r\n\r\n效果：<br>\r\n<!-- 没有语义的标签div span -->\r\n<div>div独占一行</div>\r\n<div>div独占一行</div>\r\n<span>span一行显示多个</span>\r\n<span>span一行显示多个</span>\r\n<br><hr>\r\n<!-- 有语义的标签 -->\r\n<header>网页头部</header>\r\n<nav>网页导航条</nav>\r\n<footer>网页底部</footer>\r\n<aside>网页侧边栏</aside>\r\n<section>网页区块</section>\r\n<article>网页文章article</article>\r\n\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## 字符实体标签\r\n* 只要记住一个，空格\\&nbsp;\r\n\r\n```html\r\n<p>这里有很多空格（                         ）但却只显示一个</p>\r\n<p>这里有很多空格（&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ）能显示多个</p>\r\n```\r\n\r\n效果：<br>\r\n<p>这里有很多空格（                         ）但却只显示一个</p>\r\n<p>这里有很多空格（&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ）能显示多个</p>\r\n\r\n<!-- <hr style=\"border-color:red;\"> -->\r\n\r\n## seo搜索引擎优化\r\n* SEO(Search Engine Optimization)搜索引擎优化\r\n* 作用，让网站在搜索引擎中排名靠前\r\n* 提升排名的方法\r\n    * 竞价排名\r\n    * 将网页制作成.html后缀\r\n    * 标签语义化（在合适的地方使用合适的标签，如H1 p strong）\r\n    * 等...\r\n* 搜索引擎优化三大标签，\r\n    ```html\r\n    <title>文章标题</title>\r\n    <meta name=\"description\" content=\"描述\">\r\n    <meta name=\"keywords\" content=\"关键词1,关键词2\">\r\n    ```\r\n![](./images/HTML5重学笔记/2022-06-12-20-57-03.png)\r\n\r\n## ico浏览器标题栏图标\r\n* 文件名一般为`favicon.ico`\r\n* 一般放在根目录\r\n```html\r\n<!-- 图片一般放根目录 -->\r\n<link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\">\r\n```\r\n![](./images/HTML5重学笔记/2022-06-12-21-03-27.png)"},{"shortInfo":{"layout":"post","title":"I am Tiny Rick","date":"2021-12-28T12:21:00.000Z","cover":"\\self_server\\assets\\images\\rick.jpg","tags":["Tiny Rick","日志"],"categories":"日志","id":22,"countWords":52,"readSeconds":5.2,"assetsbaseUrl":"/self_server/assets/"},"content":"#### Is anybody listening，can anyone understand？\r\n\r\n<div style=\"position: relative; padding: 30% 45%;\">\r\n<iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" src=\"https://player.bilibili.com/player.html?aid=889771805&bvid=BV1hP4y1W7cb&cid=387720584&page=1&as_wide=1&high_quality=1&danmaku=0\" frameborder=\"no\" scrolling=\"no\"></iframe>\r\n</div>"},{"shortInfo":{"title":"indexedDB学习笔记","date":"2022-07-17T06:49:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["indexedDB"],"hideAtIndex":true,"categories":"笔记","id":22,"countWords":2693,"readSeconds":269.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# indexedDB学习笔记\r\n\r\n**特点**\r\n* **存储容量大**\r\n  * IndexedDB主要用来客户端存储大量数据而生的，\r\n  * cookie、localstorage等存储方式都有存储大小限制。\r\n* **非关系型数据库(NoSql)**，以键值对的形式存储数据\r\n* **只能通过主键、索引、游标方式查询数据**\r\n* **持久化存储**，清除浏览器缓存不会清除其数据\r\n  * cookie、localStorage、sessionStorage会清除数据\r\n* **异步操作**，IndexedDB操作时不会锁死浏览器，而localstorage是同步的\r\n* **支持事务transaction**，一系列的操作步骤中，若有一步失败，整个操作都会取消\r\n* **同源策略**，网页只能访问自身域名下的数据库\r\n\r\n**重要概念**\r\n* **事务 transaction**\r\n    * 对数据库进行一系列操作时，若有一步失败，则会回滚到最初始的状态，确保数据的一致性\r\n* **仓库 objectStore** ，可以把仓库理解为表\r\n* **索引 index**\r\n    * 可在创建store时创建索引\r\n    * 查询时可通过索引来筛选\r\n    * 插入数据时，索引字段不能为空\r\n* **游标 cursor**\r\n    * 游标是IndexedDB数据库新的概念\r\n    * 概念类似c的指针，\r\n    * 作用类似Python的生成器\r\n\r\n\r\n\r\n## 打开数据库\r\n```js\r\n/**\r\n * 打开数据库\r\n * @param {object} dbName 数据库的名字\r\n * @param {string} storeName 仓库名称\r\n * @param {string} version 所创建的数据库的版本号\r\n * @return {object} 该函数会返回一个数据库实例\r\n */\r\n\r\nfunction openDB(dbName, version = 1) {\r\n  return new Promise((resolve, reject) => { //返回promise对象使得可以链式调用\r\n    //  兼容浏览器\r\n    var indexedDB =\r\n      window.indexedDB ||\r\n      window.mozIndexedDB ||\r\n      window.webkitIndexedDB ||\r\n      window.msIndexedDB;\r\n    let db;//用于存储数据库实例\r\n    // 打开数据库，若没有则会创建\r\n    const request = indexedDB.open(dbName, version);\r\n    // 数据库打开成功的回调（连接成功或创建成功）\r\n    request.onsuccess = function (event) {\r\n      db = event.target.result; // db数据库对象实例,包含了很多增删查改的操作\r\n      console.log(\"数据库打开成功\");\r\n      resolve(db);//返回给外部调用者\r\n    };\r\n    // 数据库打开失败的回调（连接或创建失败）\r\n    request.onerror = function (event) {\r\n      console.log(\"数据库打开报错\");\r\n    };\r\n    // 数据库创建或版本号有更新时候的回调，数据内容的更新不会触发该回调\r\n    request.onupgradeneeded = function (event) {\r\n      // 数据库创建或升级的时候会触发\r\n      console.log(\"onupgradeneeded\");\r\n      db = event.target.result; // 获取数据库对象\r\n      // 创建存储库\r\n      var objectStore;\r\n      objectStore = db.createObjectStore(\"users\", {//概念对应于sql数据库的表的名称\r\n        keyPath: \"userID\", // 指定userID为主键\r\n        // autoIncrement: true // 实现自增\r\n      });\r\n      // 通过主键仅能查询一条数据，通过索引能查询多条满足指定条件的数据，如查询userSex:男\r\n      // 创建索引，在后面查询数据的时候可以根据索引查，若不创建，则只能根据主键来查询\r\n      objectStore.createIndex(\"userID\", \"userID\", { unique: true }); // 主键应当唯一，unique\r\n      objectStore.createIndex(\"userName\", \"userName\", { unique: false }); \r\n      objectStore.createIndex(\"userSex\", \"userSex\", { unique: false });\r\n      objectStore.createIndex(\"userAge\", \"userAge\", { unique: false });\r\n    };\r\n  });\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\n\r\n/* \r\n    由于openDB返回的是promise对象,是异步的，所以这么写是错误的：\r\n        let db = openDB(\"test\",1);\r\n        console.log(db)\r\n*/\r\n// 正确写法应该使用链式方法调用\r\nlet db;\r\nopenDB(\"test\",1).then((db)=>{ //链式方法调用，并接收值\r\n    db=db\r\n    console.log(db)\r\n    // 后续代码必须写在这个里面，但是也可以使用wait方法将该异步操作变同步操作\r\n\r\n    // 后续代码.....\r\n\r\n\r\n\r\n})\r\n    console.log(db); //报错，因为上述的函数返回的是promise对象，是异步的，\r\n\r\n```\r\n\r\n\r\n## 新增数据\r\n```js\r\n/**\r\n * 新增数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} data 数据 必须是一个对象，必须包含主键、索引\r\n */\r\nfunction addData(db, storeName, data) {\r\n  var request = db\r\n    //这里写成了链式调用的形式，也可以不这样写\r\n    //插入数据需要通过事务transaction来操作，\r\n    //事务的第一个参数是一个列表\r\n    .transaction([storeName], \"readwrite\") // 参数分别是：事务对象（指定表格名称） 和  操作模式（\"只读\"或\"读写\"）\r\n    .objectStore(storeName) // 仓库对象\r\n    .add(data);\r\n\r\n  request.onsuccess = function (event) {\r\n    console.log(\"数据写入成功\");\r\n  };\r\n\r\n  request.onerror = function (event) {\r\n    console.log(\"数据写入失败\");\r\n  };\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\nlet data={\r\n    \"主键名\":\"主键值\"， //可以使用UUID作为主键值，主键必须存在\r\n    \"索引名1\":\"索引1值\",\r\n    \"索引名2\":\"索引2值\",\r\n    \"索引名3\":\"索引3值\",\r\n    \"其他键名\":\"其他键值\" // 可以第一次插入的data有3个键值对，第二次插入的数据有4个键值对，可以不一致\r\n}\r\naddData(db, \"storeName\", data)\r\n\r\n```\r\n\r\n\r\n## 通过主键读取数据\r\n```js\r\n/**\r\n * 通过主键读取数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} key 主键值\r\n */\r\nfunction getDataByKey(db, storeName, key) {\r\n  return new Promise((resolve, reject) => {\r\n    var transaction = db.transaction([storeName]); // 创建事务\r\n    var objectStore = transaction.objectStore(storeName); // 仓库对象\r\n    var request = objectStore.get(key); // 通过主键获取数据\r\n\r\n    request.onerror = function (event) {\r\n      console.log(\"事务失败\");\r\n    };\r\n\r\n    request.onsuccess = function (event) {\r\n      console.log(\"主键查询结果: \", request.result);\r\n      resolve(request.result);\r\n    };\r\n  });\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\n\r\ngetDataByKey(db, \"storeName\", \"主键值\").then((result)=>{\r\n    console.log(result)\r\n})\r\n\r\n```\r\n\r\n\r\n## 通过游标读取数据\r\n```js\r\n/**\r\n * 通过游标读取数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n */\r\nfunction cursorGetData(db, storeName) {\r\n  let list = [];\r\n  var store = db\r\n    .transaction(storeName, \"readwrite\") // 事务\r\n    .objectStore(storeName); // 仓库对象\r\n  var request = store.openCursor(); // 指针对象，初始化一个游标\r\n\r\n  // 游标开启成功，逐行读数据\r\n  request.onsuccess = function (e) {\r\n    var cursor = e.target.result;\r\n    if (cursor) {// 必须要检查 因为需要判断是否为游标已经走到了末尾\r\n        // 放入列表；\r\n            // 可以在此通过条件判断来筛选出想要的数据,但这里效率会非常低，因为会遍历所有表项，要想筛选，应该先通过索引来筛选\r\n            //这里没有进行判断，所以获取到的是整张表，但若要想获取整张表 可以用db.transaction().objectStore().getAll()\r\n        list.push(cursor.value); \r\n        cursor.continue(); // 遍历了存储对象中的所有内容\r\n    } else {\r\n      console.log(\"游标读取的数据：\", list); //获取到值，\r\n      // 这里没有用promise，但是indexedDB本身就是异步的，且这是一个事件处理函数，推测仍然不能使用return，具体如何获取返回值应该可以参考之前的代码\r\n    }\r\n  };\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\n\r\n// 因为内部没有写判断条件，所以获取的是整张表的数据\r\ncursorGetData(db, \"storeName\", \"主键值\");// 异步函数\r\n\r\n```\r\n\r\n\r\n## 通过索引读取数据\r\n```js\r\n/**\r\n * 通过索引读取数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} indexName 索引名称\r\n * @param {string} indexValue 索引值\r\n */\r\nfunction getDataByIndex(db, storeName, indexName, indexValue) {\r\n  var store = db.transaction(storeName, \"readwrite\").objectStore(storeName);\r\n  var request = store.index(indexName).get(indexValue);\r\n  request.onerror = function () {\r\n    console.log(\"事务失败\");\r\n  };\r\n  request.onsuccess = function (e) {\r\n    var result = e.target.result;\r\n    console.log(\"索引查询结果：\", result);\r\n  };\r\n}\r\n```\r\n\r\n**使用**\r\n```js\r\n\r\n// 获取的是第一条满足条件的数据\r\ngetDataByIndex(db, \"storeName\", \"索引键名\", \"索引键值\");// 异步函数\r\n\r\n```\r\n\r\n\r\n\r\n## 通过索引和游标查询记录\r\n```js\r\n/**\r\n * 通过索引和游标查询记录\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} indexName 索引名称\r\n * @param {string} indexValue 索引值\r\n */\r\nfunction cursorGetDataByIndex(db, storeName, indexName, indexValue) {\r\n  let list = [];\r\n  var store = db.transaction(storeName, \"readwrite\").objectStore(storeName); // 仓库对象\r\n  var request = store\r\n    .index(indexName) // 索引对象\r\n    .openCursor( \r\n        IDBKeyRange.only(indexValue) //表示查询所有值等于(only) indexValue的游标\r\n        ); //此时拿到的游标就是索引为指定值的表项了\r\n  request.onsuccess = function (e) {\r\n    var cursor = e.target.result;\r\n    if (cursor) { // 必须要检查\r\n      list.push(cursor.value);\r\n      cursor.continue(); // 遍历了存储对象中的所有内容\r\n    } else {\r\n      console.log(\"游标索引查询结果：\", list);\r\n    }\r\n  };\r\n  request.onerror = function (e) {};\r\n}\r\n```\r\n\r\n\r\n**使用**\r\n```js\r\n\r\n// 获取的是所有满足条件的数据\r\ngetDataByIndex(db, \"storeName\", \"索引键名\", \"索引键值\");// 异步函数\r\n\r\n// 获取所有age=5的表项\r\ngetDataByIndex(db, \"storeName\", \"age\", \"5\");// 异步函数\r\n\r\n```\r\n\r\n## 通过索引和游标分页查询记录\r\n如果一个数据库有十万条数据，浏览器的页面不可能全部渲染出来，需要做成分页的形式，点击第几页再渲染第几页的内容\r\n\r\n* advance 该函数可以让我们的游标跳过多少条开始查询。\r\n\r\n```js\r\n/**\r\n * 通过索引和游标分页查询记录\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} indexName 索引名称\r\n * @param {string} indexValue 索引值\r\n * @param {number} page 页码\r\n * @param {number} pageSize 查询条数\r\n */\r\nfunction cursorGetDataByIndexAndPage(\r\n  db,\r\n  storeName,\r\n  indexName,\r\n  indexValue,\r\n  page,//查询的是第几页的内容，从1开始\r\n  pageSize\r\n) {\r\n  let list = [];\r\n  let counter = 0; // 计数器\r\n  let advanced = true; // 是否跳过多少条查询\r\n  var store = db.transaction(storeName, \"readwrite\").objectStore(storeName); // 仓库对象\r\n  var request = store\r\n    .index(indexName) // 索引对象\r\n    .openCursor(IDBKeyRange.only(indexValue)); // 指针对象\r\n  request.onsuccess = function (e) {\r\n    var cursor = e.target.result;\r\n    if (page > 1 && advanced) { //判断是否需要跳过多少条开始查询，其实判断page>=1也可以\r\n      advanced = false;\r\n      cursor.advance((page - 1) * pageSize); // 跳过多少条\r\n      return;\r\n    }\r\n    if (cursor) {\r\n      // 必须要检查\r\n      list.push(cursor.value);\r\n      counter++;\r\n      if (counter < pageSize) {\r\n        cursor.continue(); // 遍历了存储对象中的所有内容\r\n      } else {\r\n        cursor = null;\r\n        console.log(\"分页查询结果\", list);\r\n      }\r\n    } else {\r\n      console.log(\"分页查询结果\", list);\r\n    }\r\n  };\r\n  request.onerror = function (e) {};\r\n}\r\n```\r\n\r\n\r\n**使用**\r\n```js\r\n\r\n// 获取的是所有满足条件的数据的指定页码的指定条数\r\ncursorGetDataByIndexAndPage(db, \"storeName\", \"索引键名\", \"索引键值\",页码，条数);\r\n\r\n// 获取的是age=5的第二页中的数据，每页有10条数据\r\ngetDataByIndex(db, \"storeName\", \"age\", \"5\",2,10);\r\n\r\n```\r\n\r\n## 更新数据\r\n```js\r\n/**\r\n * 更新数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {object} data 数据\r\n */\r\nfunction updateDB(db, storeName, data) {\r\n  var request = db\r\n    .transaction([storeName], \"readwrite\") // 事务对象\r\n    .objectStore(storeName) // 仓库对象\r\n    .put(data);//若有该数据则更新该数据，若没有则添加该数据\r\n\r\n  request.onsuccess = function () {\r\n    console.log(\"数据更新成功\");\r\n  };\r\n\r\n  request.onerror = function () {\r\n    console.log(\"数据更新失败\");\r\n  };\r\n}\r\n```\r\n\r\n## 通过主键删除数据\r\n```js\r\n/**\r\n * 通过主键删除数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {object} id 主键值\r\n */\r\nfunction deleteDB(db, storeName, id) {\r\n  var request = db\r\n    .transaction([storeName], \"readwrite\")\r\n    .objectStore(storeName)\r\n    .delete(id);\r\n\r\n  request.onsuccess = function () {\r\n    console.log(\"数据删除成功\");\r\n  };\r\n\r\n  request.onerror = function () {\r\n    console.log(\"数据删除失败\");\r\n  };\r\n}\r\n```\r\n\r\n## 通过索引和游标删除指定的数据\r\n```js\r\n/**\r\n * 通过索引和游标删除指定的数据\r\n * @param {object} db 数据库实例\r\n * @param {string} storeName 仓库名称\r\n * @param {string} indexName 索引名\r\n * @param {object} indexValue 索引值\r\n */\r\nfunction cursorDelete(db, storeName, indexName, indexValue) {\r\n  var store = db.transaction(storeName, \"readwrite\").objectStore(storeName);\r\n  var request = store\r\n    .index(indexName) // 索引对象\r\n    .openCursor(IDBKeyRange.only(indexValue)); // 指针对象\r\n  request.onsuccess = function (e) {\r\n    var cursor = e.target.result;\r\n    var deleteRequest;\r\n    if (cursor) {\r\n      deleteRequest = cursor.delete(); // 请求删除当前项\r\n      deleteRequest.onerror = function () {\r\n        console.log(\"游标删除该记录失败\");\r\n      };\r\n      deleteRequest.onsuccess = function () {\r\n        console.log(\"游标删除该记录成功\");\r\n      };\r\n      cursor.continue(); //游标移动到下一个，以便删除所有匹配数据\r\n    }\r\n  };\r\n  request.onerror = function (e) {};\r\n}\r\n```\r\n\r\n## 关闭数据库\r\n```js\r\n/**\r\n * 关闭数据库\r\n * @param {object} db 数据库实例\r\n */\r\nfunction closeDB(db) {\r\n  db.close();\r\n  console.log(\"数据库已关闭\");\r\n}\r\n```\r\n\r\n\r\n## 删除数据库\r\n\r\n```js\r\n/**\r\n * 删除数据库\r\n * @param {object} dbName 数据库名称\r\n */\r\nfunction deleteDBAll(dbName) {\r\n  console.log(dbName);\r\n  let deleteRequest = window.indexedDB.deleteDatabase(dbName);\r\n  deleteRequest.onerror = function (event) {\r\n    console.log(\"删除失败\");\r\n  };\r\n  deleteRequest.onsuccess = function (event) {\r\n    console.log(\"删除成功\");\r\n  };\r\n}\r\n```"},{"shortInfo":{"title":"JavaScript基础知识复习笔记","date":"2022-06-23T21:27:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["JavaScript","前端"],"hideAtIndex":true,"categories":"笔记","id":23,"countWords":6624,"readSeconds":662.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# JavaScript基础知识复习笔记\r\n\r\n## 目录\r\n- [JavaScript基础知识复习笔记](#javascript基础知识复习笔记)\r\n  - [目录](#目录)\r\n  - [简介](#简介)\r\n    - [用处](#用处)\r\n    - [浏览器组成](#浏览器组成)\r\n    - [js组成](#js组成)\r\n      - [ECMAScript](#ecmascript)\r\n      - [DOM](#dom)\r\n      - [BOM](#bom)\r\n  - [书写位置](#书写位置)\r\n    - [行内式](#行内式)\r\n    - [内嵌式](#内嵌式)\r\n    - [外链式](#外链式)\r\n  - [注释](#注释)\r\n  - [输入输出](#输入输出)\r\n  - [变量](#变量)\r\n    - [特殊情况](#特殊情况)\r\n    - [命名规范](#命名规范)\r\n  - [数据类型](#数据类型)\r\n    - [数据类型分类](#数据类型分类)\r\n      - [数字型Number](#数字型number)\r\n      - [字符串型String](#字符串型string)\r\n        - [转义字符](#转义字符)\r\n        - [长度](#长度)\r\n        - [拼接](#拼接)\r\n      - [布尔型Boolean](#布尔型boolean)\r\n      - [未定义Undefined](#未定义undefined)\r\n      - [空值Null](#空值null)\r\n    - [数据类型检测](#数据类型检测)\r\n    - [通过控制台颜色判断类型](#通过控制台颜色判断类型)\r\n    - [字面量](#字面量)\r\n    - [数据类型转换](#数据类型转换)\r\n      - [转为字符串](#转为字符串)\r\n      - [转为数值型](#转为数值型)\r\n      - [转为布尔型](#转为布尔型)\r\n  - [标识符、关键字、保留字](#标识符关键字保留字)\r\n  - [运算符](#运算符)\r\n    - [逻辑与的逻辑中断](#逻辑与的逻辑中断)\r\n    - [逻辑或的逻辑中断](#逻辑或的逻辑中断)\r\n  - [运算符优先级](#运算符优先级)\r\n  - [流程控制](#流程控制)\r\n    - [分支](#分支)\r\n    - [循环](#循环)\r\n    - [相关关键字](#相关关键字)\r\n  - [数组Arrary](#数组arrary)\r\n    - [创建](#创建)\r\n    - [遍历](#遍历)\r\n    - [新增元素](#新增元素)\r\n  - [函数](#函数)\r\n    - [先声明后使用](#先声明后使用)\r\n    - [形参和实参个数问题](#形参和实参个数问题)\r\n    - [arguments](#arguments)\r\n  - [立即执行函数](#立即执行函数)\r\n    - [写法](#写法)\r\n  - [作用域](#作用域)\r\n    - [作用域链](#作用域链)\r\n  - [预解析](#预解析)\r\n    - [案例1](#案例1)\r\n    - [案例2](#案例2)\r\n    - [案例3](#案例3)\r\n    - [案例4（经典面试题）](#案例4经典面试题)\r\n  - [自定义对象](#自定义对象)\r\n    - [创建对象](#创建对象)\r\n    - [new关键字](#new关键字)\r\n    - [遍历对象](#遍历对象)\r\n  - [内置对象](#内置对象)\r\n    - [Math对象](#math对象)\r\n    - [Date对象](#date对象)\r\n      - [网页倒计时效果例程](#网页倒计时效果例程)\r\n    - [Array对象](#array对象)\r\n    - [String对象](#string对象)\r\n      - [基本包装类型](#基本包装类型)\r\n      - [字符串不可变性](#字符串不可变性)\r\n    - [String对象的常用方法](#string对象的常用方法)\r\n    - [试写相关算法](#试写相关算法)\r\n  - [数据类型总结](#数据类型总结)\r\n    - [分类](#分类)\r\n    - [堆和栈](#堆和栈)\r\n    - [函数的值传递：类似c语言](#函数的值传递类似c语言)\r\n\r\n## 简介\r\n* 布兰登艾奇（Brendan Eich 1961~）在1995年10天时间设计出了JavaScript  \r\n* 网景公司最初命名为LiveScript 后与sun公司（Java由Sun公司发明）合作改名为JavaScript   \r\n* JavaScript是运行在客户端的脚本（script）语言  \r\n* 脚本语言 ：不需要编译，运行过程有js解释器逐行解释并执行  \r\n* 现在也可以基于nodejs进行服务端编程  \r\n\r\n### 用处\r\n* 表单动态校验 ：密码强度检测（js产生的最初目的）\r\n* 网页特效\r\n* 服务端开发（nodejs）\r\n* 桌面程序（Electron）\r\n* App（Cordova）\r\n* 硬件控制-物联网（Ruff）\r\n* 游戏开发（cocos2d-js）\r\n\r\n### 浏览器组成\r\n* 渲染引擎 ：解析html css 俗称内核，Chrome的blink 老版本的webkit\r\n* js引擎 ：**解释执行**网页的JavaScript代码，Chrome的v8\r\n    * 浏览器本身并不会执行js代码，而是通过内置引擎来执行\r\n    * **其它的JavaScript的引擎**转换成**字节码**或JavaScript，**V8使用c++开发**，**V8将JavaScript编译成原生机器码**，使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，**JavaScript程序在V8引擎下的运行速度媲美二进制程序。**\r\n\r\n\r\n### js组成\r\n* ECMAScript ：JavaScript语法\r\n* DOM ：页面文档对象模型\r\n* BOM ：浏览器对象模型\r\n\r\n#### ECMAScript\r\n* ECMAScript 国际标准 由ECMA国际组织进行标准化 规定了JS的编程语法和基础核心知识\r\n* JavaScript 工业标准 网景公司\r\n* JScript 工业标准 微软公司\r\n\r\n#### DOM\r\n* （Document Object Model）页面文档对象模型\r\n* 是W3C组织推荐的处理可扩展标记语言的标准编程接口\r\n* 通过DOM提供的接口可对页面元素进行操作（大小、位置、颜色...）\r\n\r\n#### BOM\r\n* （Browser Object Model）浏览器对象模型\r\n* 通过BOM可操作浏览器窗口，如弹出框，控制跳转，获取分辨率\r\n\r\n\r\n## 书写位置\r\n\r\n### 行内式\r\n直接写在html元素标签内部   \r\n因为html标签属性值使用双引号，js字符串应当使用单引号\r\n```html\r\n<input type=\"button\" value=\"这是一个按钮\" onclick=\"alert('提示框内容')\">\r\n```\r\n\r\n### 内嵌式\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <script>\r\n        alert('提示框内容');\r\n    </script>\r\n</head>\r\n<body>\r\n    \r\n</body>\r\n</html>\r\n```\r\n\r\n### 外链式\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <script src=\"./js/index.js\"></script>\r\n</head>\r\n<body>\r\n    \r\n</body>\r\n</html>\r\n```\r\n\r\n## 注释\r\n* 单行注释\r\n* 多行注释\r\n```js\r\n\r\n//单行注释\r\n\r\n/*\r\n多行注释\r\n多行注释\r\n*/\r\n\r\n```\r\n\r\n\r\n## 输入输出\r\n* 弹出输入框 `prompt(\"字符串\")` 返回值类型：`string`\r\n* 弹出提示框 `alert(\"字符串\")`\r\n* 控制台打印信息 `console.log(\"字符串\")`\r\n\r\n## 变量\r\n* 使用var关键字声明变量：`var num;`\r\n* 赋值 `num=1;`\r\n* 声明并赋值 `var myname=\"DingYigui\";`\r\n\r\n### 特殊情况\r\n* 只声明不赋值，直接使用，变量为`undefined`\r\n* 不声明不赋值，直接使用，程序会报错：变量未定义；**报错之后，后续代码不再执行**\r\n* 不声明直接赋值，可以直接使用，成为全局变量\r\n\r\n### 命名规范\r\n* 有字母数字下划线及$组成  \r\n* 区分大小写  \r\n* 不能以数字开头  \r\n* 不能是关键字、保留字  \r\n\r\n* 其他\r\n    * **建议**变量名、函数名有意义  \r\n    * **建议**遵循驼峰命名法thisIsAVar  \r\n    * 变量名一般用名词\r\n    * 函数名一般用动词\r\n    * name不是关键字也不是保留字，但在一些浏览器中有其他含义，最好不要用作变量名\r\n    * \r\n\r\n\r\n\r\n## 数据类型\r\nJavaScript是**弱类型语言**，或者说**动态语言**。   \r\n不用提前声明变量的类型，**在程序运行过程中类型会自动被确定**  \r\n数字型变量在被赋值为字符串后自动变为字符串型\r\n\r\n### 数据类型分类\r\n* 简单数据类型 ： **Number** **String** **Boolean** **Undefined** **Null**\r\n* 复杂数据类型：object\r\n![](./images/JavaScript基础知识复习笔记/2022-06-24-15-01-21.png)\r\n\r\n#### 数字型Number\r\n* 整数：`var a=0;`\r\n* 小数：`var a=1.5;`\r\n* 八进制：`var a=07;//八进制`\r\n* 十六进制：`var a=0xff;//十六进制`\r\n\r\n范围\r\n```js\r\nalert(Number.MAX_VALUE);//最大值 \r\nalert(Number.MIN_VALUE);//最小值 \r\n```\r\n\r\n特殊值\r\n```js\r\nalert(Infinity);//无穷大\r\nalert(-Infinity);//无穷小 \r\nalert(NaN);//Not a Number 不是一个数\r\n\r\nalert(Number.MAX_VALUE*2);//将会输出Infinity\r\nalert(\"字符串\"-100);//将会输出NaN\r\n```\r\n\r\n函数\r\n```js\r\nisNaN() //判断是否是NaN\r\n```\r\n\r\n#### 字符串型String\r\n加了引号或双引号就是字符串  \r\n字符串中需要包含单引号时外部用双引号  \r\n字符串中需要包含双引号时外部用单引号  \r\n\r\n##### 转义字符\r\n* \\t\r\n* \\n newline换行\r\n* \\\\\\\r\n* \\'\r\n* \\\" \r\n* \\b blank空格\r\n\r\n##### 长度  \r\n```js\r\nvar str=\"123\"  \r\nalert(str.length)\r\n```\r\n\r\n##### 拼接  \r\n```js\r\n\"123\"+\"456\"  \r\nstr1 + str2\r\n```\r\n\r\n字符串和其他类型拼接，先会把其他类型自动转为字符串，结果为字符串\r\n```js\r\n\"123\"+ 456\r\n\"123\"+ true\r\n```\r\n#### 布尔型Boolean\r\n* 取值为 **true** 或 **false**  \r\n* 在餐饮数值运算时被当做1或0  \r\n\r\n#### 未定义Undefined\r\n* 变量声明不赋值时，变量的默认值\r\n    ```js\r\n    var i;\r\n    ```\r\n* 也可以直接赋值为undefined\r\n    ```js\r\n    var i=undefined;\r\n    ```\r\n* 和字符串相连会被转换成字符串\"undefined\"  \r\n* 和数值运算结果为NaN\r\n\r\n#### 空值Null\r\n```js\r\nvar i=null\r\n```\r\n* 空值和字符串相连被当做字符串\"undefined\"  \r\n* 空值和数字相加被当做0\r\n\r\n### 数据类型检测\r\n* 语法：`typeof 变量名` \r\n* 结果为\"number\" 、 \"string\" 、 \"boolean\" 、 \"undefined\" 、 \"object\"(var a=null;a是对象)\r\n\r\n```js\r\nvar x= prompt(\"请输入数字\")\r\nconsole.log(typeof x);//输出string\r\n```\r\n\r\n### 通过控制台颜色判断类型\r\n* 蓝色为数值\r\n* 深蓝色为布尔值\r\n* 灰色为字符串\r\n\r\n![](./images/JavaScript基础知识复习笔记/2022-06-25-04-32-58.png)\r\n![](./images/JavaScript基础知识复习笔记/2022-06-25-04-32-43.png)\r\n\r\n### 字面量\r\n数字字面量1，2，3 1.5\r\n字符串字面量 \"123\" '123'\r\n布尔字面量 true false\r\n\r\n### 数据类型转换\r\n* 表单、prompt()获取到的数据默认是字符串类型，不能进行加减运算\r\n* 三种转换\r\n    * 转换成字符串\r\n    * 转换成数字\r\n    * 转换成布尔型\r\n\r\n#### 转为字符串\r\n* `XXX.toString()`\r\n* `String(XXX)`强制转换\r\n* `XXX+\"\"`拼接字符串 利用+运算转换为字符串\r\n```js\r\n// toString()\r\nvar num=1;\r\nvar str=num.toString();\r\nconsole.log(typeof str)\r\n\r\n// String()强制转换\r\nconsole.log(typeof String(123))\r\n\r\n\r\n// 加号拼接字符串\r\n123+\"\"\r\nconsole.log(typeof (123+\"\"))\r\n```\r\n#### 转为数值型\r\n* `parseInt(string)` 获取整数部分\r\n* `parseFloat(string)` 获取整数及小数部分\r\n* `Number()` 强制转换为数值型 获取整数及小数部分\r\n* js隐式转换（`- * /`）利用算术运算转换为数值型\r\n\r\n```js\r\nparseInt(\"1.5px\")//结果：1\r\nparseInt(\"width:1.5px\")//结果：NaN\r\n\r\nparseFloat(\"1.5px\")//结果：1.5\r\nparseFloat(\"width:1.5px\")//结果：NaN\r\n\r\nNumber(\"1.\")//结果：1\r\nNumber(\"1.5\")//结果：1.5\r\n\r\n\"1.5\"+1.5 //结果为字符串拼接效果：\"1.51.5\"\r\n\"1.5\"-1.5 //结果为数值相相减效果：0\r\n\"1.5\"*1.5 //结果为数值相乘效果：2.25\r\n\"1.5\"/1.5 //结果为数值相除效果：1\r\n\r\n```\r\n\r\n#### 转为布尔型\r\n* Boolean()\r\n* 代表空的否定的值都会转换成`false`：0 、 \"\" 、null 、NaN 、undefined \r\n* 其余都会被转换成`true`\r\n\r\n```js\r\nBoolean(null)//false\r\nBoolean(0)//false\r\nBoolean(NaN)//false\r\nBoolean(\"\")//false\r\nBoolean(undefined)//false\r\n\r\n```\r\n\r\n## 标识符、关键字、保留字\r\n* **标识(zhi)符**:变量名、函数名、参数名...\r\n    * 不能是关键字或保留字\r\n* **关键字**：编程语言中已经使用的字，for break case...\r\n* **保留字**：预留的关键字byte char const double\r\n\r\n## 运算符\r\n* 算数：+ - * %\r\n    * 由于表示精度问题，浮点数0.1+0.2不一定等于0.3\r\n* 自增自减：++i --i i++ i--\r\n* 比较运算符（关系运算符）\r\n    * <\r\n    * \\>\r\n    * \\<=\r\n    * \\>=\r\n    * == 会自动类型转换：1==\"1\"为真\r\n    * != 不等\r\n    * === 全等，要求值相同，类型也相同，才为真\r\n    * !== 不等\r\n\r\n* 逻辑运算符:\r\n    * 与&&\r\n    * 或||\r\n    * 非!\r\n\r\n* 赋值运算符\r\n    * =\r\n    * += -=\r\n    * *= /= %=\r\n\r\n### 逻辑与的逻辑中断\r\n表达式1&&表达式2  \r\n* 当表达式1的值为真，整个表达式的返回值为表达式2\r\n* 当表达式1的值为假，整个表达式的返回值为表达式1\r\n\r\n```js\r\n123 && 321 //返回321\r\n\r\n0 && 321 //返回0\r\n'' && 321 //返回''\r\nfalse && 321 //返回false\r\nundefined && 321 //返回undefined\r\n```\r\n\r\n### 逻辑或的逻辑中断\r\n表达式1||表达式2  \r\n* 如果表达式1的值为真，则整个表达式的值为表达式1\r\n* 如果表达式1的值为假，则整个表达式的值为表达式2\r\n\r\n```js\r\n123 || 321 //返回123\r\n\r\n0 || 321 //返回321\r\n'' || 321 //返回321\r\nfalse || 321 //返回321\r\nundefined || 321 //返回321\r\n```\r\n\r\n\r\n## 运算符优先级\r\n![](./images/JavaScript基础知识复习笔记/2022-06-26-04-17-35.png)\r\n\r\n## 流程控制\r\n\r\n### 分支\r\nif分支:和c语言语法一致\r\n```js\r\nif(表达式){\r\n    语句;\r\n}\r\n\r\nif(表达式){\r\n    语句;\r\n}else{\r\n    语句2;\r\n}\r\n\r\nif(表达式){\r\n    语句;\r\n}\r\nelse if(表达式2){\r\n    语句2;\r\n}else{\r\n    语句3;\r\n}\r\n```\r\n\r\n三元表达式\r\n```js\r\nresult=表达式1? 表达式2:表达式3;\r\n```\r\n\r\n多分支语句：也是和c语言类似\r\n```js\r\nswitch(变量 或 表达式){\r\n    case 变量值1:  //要求 switch中的值 和 case 的值 是全等的关系\r\n        语句1;\r\n        break;\r\n    case 变量值2:\r\n        语句2;\r\n        break;\r\n    case 变量值3:\r\n        语句3;\r\n        break;\r\n    default:\r\n        语句4;\r\n        break; //default如果没有写在所有case的最后，则break不能省略，\r\n}\r\n```\r\n\r\n### 循环\r\nfor\r\n```js\r\nfor(var i=1;i<=100;i++){\r\n    语句1;\r\n}\r\n```\r\n\r\nwhile\r\n```js\r\nwhile(表达式){\r\n    语句1;\r\n}\r\n```\r\n\r\ndo\r\n```js\r\ndo{\r\n    语句1;\r\n}while(表达式);\r\n```\r\n\r\n```js\r\n//语法\r\nfor(变量名 in 对象或数组){\r\n    //\r\n}\r\n```\r\n\r\n### 相关关键字\r\n* continue 立即结束本次循环，进入下一次循环\r\n* break 立即跳出整个循环\r\n\r\n\r\n## 数组Arrary\r\n* 数组中可以存放**任意类型**的数据\r\n### 创建\r\n* 利用字面量创建数组\r\n```js\r\nvar arr=[];//创建空数组\r\nvar arr=[1,2.5,\"3\",ture];\r\narr[2]//\"3\"\r\n```\r\n* new创建数组\r\n```js\r\n    var arr=new Array();//创建空数组\r\n```\r\n### 遍历\r\n```js\r\nvar arr=[1,2,3,4,5];\r\nfor(var i=0;i<arr.length;i++){\r\n    console.log(arr[i]);\r\n}\r\n```\r\n\r\n### 新增元素\r\n方法1\r\n* XXX.length是可修改的\r\n* XXX.length+=2后，会新增两个undefined的元素\r\n* 在这个位置赋值就好了\r\n\r\n方法2\r\n* 直接索引到元素然后赋值\r\n```js\r\nvar arr=[];\r\nfor(var i=0;i<100;i++)\r\n{\r\n    arr[i]=i;\r\n}\r\nconsole.log(arr);\r\n```\r\n\r\n## 函数\r\n### 先声明后使用\r\n* 声明方法1：\r\n    ```js\r\n    // 声明方法1：\r\n    function 函数名(形式参数1,形式参数2,....){\r\n        语句;\r\n        //利用return返回值：\r\n        return 需要返回的结果 ;\r\n        //利用return返回多个结果\r\n        return [result1,result2];\r\n        //利用return终止函数：\r\n        return;//没有返回值的函数 或返回值为return; 其返回值的值为undefined\r\n    }\r\n    //调用：\r\n    var y = 函数名(实际参数1,实际参数2,....);\r\n    ```\r\n\r\n* 声明方法2（匿名函数）：\r\n    ```js\r\n    // 声明方法2（匿名函数）：\r\n    var 变量名 = function(形式参数1,形式参数2,....){\r\n        // 语句;\r\n    }\r\n    // 调用：\r\n    变量名(实际参数1,实际参数2,....);\r\n    ```\r\n\r\n### 形参和实参个数问题\r\n```js\r\nfunction A(x1,x2){\r\n    console.log(x1+x2);\r\n}\r\n\r\nA(1);// 形参x1被赋值为1 x2没有被赋值 结果为undefined 于是x1+x2结果为NaN\r\nA(1,2);//结果为3\r\nA(1,2,3);//形参x1被赋值为1 x2被赋值为2 实参3被忽略\r\n\r\n```\r\n\r\n### arguments\r\n* arguments是所有函数都具有的**内置对象**\r\n* 可以通过该对象获取函数传入的所有实参、和实参的具体个数\r\n* arguments是一个**伪数组**\r\n    * 具有length属性\r\n    * 按索引获取元素\r\n    * 没有pop push 等方法\r\n\r\n```js\r\nfunction A(){\r\n    console.log(arguments)\r\n}\r\n\r\nA();\r\nA(1,2,3,4,5);\r\n```\r\n\r\n## 立即执行函数\r\n* 不需要先声明后调用，声明后立马就能执行的函数\r\n* 立即函数的最大作用就是创建了一个独立的作用域，其中创建的所有变量都是局部变量\r\n* 两个不同的立即函数直接需用分号隔开\r\n\r\n### 写法\r\n```js\r\n//写法1：相当于 var fun = function(形参列表){}; (fun)(实参列表);\r\n(function(形参列表){})(实参列表);\r\n\r\n//写法2: 相当于 var fun = function(形参列表){}; fun(实参列表);\r\n(function(形参列表){}(实参列表));\r\n```\r\n\r\n\r\n\r\n\r\n## 作用域\r\n* 全局变量：\r\n    * 作用域：作用于整个js文件或整个script标签\r\n    * 全局变量在作用域中的任何位置都可以使用\r\n    * 若在局部使用的一个未声明的变量，则该变量自动变为全局变量\r\n* 局部变量\r\n    * 形参、函数内部变量\r\n    * \r\n* 块级作用域（ es6新增）\r\n    * {}\r\n    * if(){}\r\n    * for(){} while(){} do{}while()\r\n    * 大括号里面声明的变量不能在之外声明\r\n\r\n### 作用域链\r\n内部函数访问外部变量时，按嵌套的深度查找，深度优先\r\n\r\n```js\r\nvar num=1;\r\nfunction a(){\r\n    var num=2;\r\n    function b(){\r\n        console.log(num);//2\r\n    }\r\n}\r\n```\r\n\r\n## 预解析\r\njs引擎在执行js脚本时分为两步\r\n* 预解析：将所有 var声明的全局变量 和 函数 提升到**当前**作用域之前\r\n    * 变量预解析（变量提升）：仅仅是将var变量的声明提前，**赋初值的操作不会提前。**\r\n    * 函数预解析（函数提升）：把函数声明提升到最前\r\n* 执行代码：按书写顺序执行\r\n\r\n\r\n变量预解析导致undefined的示例：\r\n```js\r\nconsole.log(y);//undefined\r\nvar y=123;\r\n//相当于：\r\nvar y;\r\nconsole.log(y);//undefined\r\ny=123;\r\n```\r\n\r\n```js\r\na();// 返回：1\r\nfunction a(){\r\n    return 1;\r\n}\r\n// 相当于：\r\nfunction a(){\r\n    return 1;\r\n}\r\na();// 返回：1\r\n\r\n//所以非匿名函数的声明写在使用语句之前不会有什么问题\r\n```\r\n\r\n```js\r\nf();//undefined\r\nvar f=function(){return 123;}\r\n\r\n// 相当于：\r\nvar f;\r\nf();//undefined\r\nf=function(){return 123;}\r\n```\r\n\r\n\r\n### 案例1  \r\n输出结果是undefined而不是10\r\n```js\r\nvar num=10;\r\nfun();\r\nfunction fun(){\r\n    console.log(num);\r\n    var num = 20;\r\n}\r\n```\r\n相当于：\r\n```js\r\nvar num=10;\r\nfunction fun(){\r\n    var num;\r\n    console.log(num);\r\n    num = 20;\r\n}\r\nfun();\r\n```\r\n\r\n### 案例2  \r\n结果：  \r\nundefined  \r\n20  \r\n![](./images/JavaScript基础知识复习笔记/2022-06-26-10-21-28.png)\r\n\r\n### 案例3  \r\n结果：  \r\nundefined  \r\n9\r\n\r\n![](./images/JavaScript基础知识复习笔记/2022-06-26-10-23-27.png)\r\n\r\n### 案例4（经典面试题）  \r\n结果：  \r\n9  \r\n9  \r\n9  \r\n9  \r\n9  \r\n报错：undefined  \r\n![](./images/JavaScript基础知识复习笔记/2022-06-26-10-26-27.png)\r\n\r\n## 自定义对象\r\n* js中对象有三种\r\n    * 自定义对象\r\n    * 内置对象\r\n    * 浏览器对象\r\n* 对象由**属性**和**方法**组成\r\n* 对象是**复杂数据类型**object\r\n* 对象是无序的相关属性和方法的集合\r\n* 构造函数抽象出了对象的公共部分，封装到了函数中，泛指了某一大类\r\n* 利用构造函数创建对象的过程也称为**对象实例化**\r\n### 创建对象\r\n* **字面量**创建对象,大括号{} \r\n    ```js\r\n    //创建\r\n    var obj={\r\n        //键值对\r\n        name:\"dyg\",\r\n        age:18,\r\n        sayHi:function(){\r\n                ;\r\n            }\r\n        }\r\n    //使用\r\n    obj.name\r\n    obj[\"name\"]\r\n    obj.age\r\n    obj.sayHi();\r\n    ```\r\n* **new**创建对象\r\n    ```js\r\n    var obj=new Object();//创建空对象\r\n    obj.name=\"DingYigui\" //追加属性\r\n    obj.age=18;\r\n    obj.sayHi=function(){};//追加方法\r\n    ```\r\n* **构造函数**创建对象  \r\n    构造函数是特殊的函数，用来初始化对象，为对象初始化值，与new一起使用  \r\n    * **构造函数首字母必须大写**    \r\n    * **构造函数不需要返回值就能返回对象**  \r\n    * **调用构造函数必须使用new**  \r\n    ```js\r\n    function 构造函数名(形式参数1,形式参数2,...){\r\n        this.属性名=形式参数1;\r\n        this.方法名=function (){};\r\n    }\r\n\r\n    var obj=new 构造函数名(实际参数1,形式参数2,...);\r\n    ```\r\n\r\n### new关键字\r\nnew关键字创建对象的过程  \r\n1. new 构造函数(); 会在内存中创建一个空对象。\r\n2. this会指向创建的空对象。\r\n3. 执行构造函数内的语句，给空对象添加属性和方法\r\n4. 返回这个对象\r\n\r\n### 遍历对象\r\n```js\r\n//语法\r\nfor(变量 in 对象){\r\n    //\r\n}\r\n\r\n//示例\r\nvar obj = {name:\"dingYigui\",age:\"18\"}\r\nfor(key in obj){\r\n    console.log(key);//属性名\r\n    console.log(obj[key]);//属性值\r\n}\r\n```\r\n\r\n## 内置对象\r\n* **一般查文档**[**MDN**](https://developer.mozilla.org/)\r\n### Math对象\r\n* Math不是一个构造函数名，而是一个静态的对象（就是字面量创建的对象{}）\r\n* 常用属性\r\n    * `Math.PI` \r\n    * `Math.E` \r\n* 常用方法\r\n    * `Math.sqrt()`\r\n    * `Math.max()` \r\n        * 正常返回实参数组的最大值\r\n        * 有非数返回NaN\r\n        * 没有实参返回负无穷\r\n    * `Math.min()`\r\n    * `Math.floor()` 向下取整\r\n    * `Math.ceil()` 向上取整\r\n    * `Math.round()` 四舍五入 \r\n        * **3.5结果为4** \r\n        * 但：**-3.5结果为-3** \r\n    * `Math.abs()` 绝对值 \"-1\"能隐式转换\r\n    * `Math.random()`  `[0,1)`\r\n\r\n### Date对象\r\n* Date不是静态对象，而是一个构造函数名 只能通过new实例化日期对象\r\n* 常用声明写法\r\n    * `new Date();` 默认传入值为当前时间\r\n    * `new Date(value);` value是毫秒数\r\n    * `new Date(dateString);`\r\n        * `new Date(\"1995-12-17 03:24:00\");`\r\n    * `new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);`\r\n        * `new Date(2022,6,27)`\r\n* 常用方法\r\n    * `obj.getFullYear()` 年\r\n    * `obj.getMonth()` 月，0-11\r\n    * `obj.getDate()` 日\r\n    * `obj.getDay()` 星期日->六 0->6 \r\n    * `obj.getHours()` 时\r\n    * `obj.getMinutes()` 分\r\n    * `obj.getSeconds()` 秒\r\n    * `obj.valueOf()` 获取毫秒数（自1970.1.1）\r\n    * `obj.getTime()` 获取毫秒数（自1970.1.1）\r\n    * `var date = + new Date();` 获取毫秒数（自1970.1.1）\r\n    * `Date.now()` 获取毫秒数（自1970.1.1） **H5新增的方法，不用new**\r\n* 由于不同时刻获取到的毫秒数不会重复，所以毫秒数也叫**时间戳**\r\n\r\n#### 网页倒计时效果例程\r\n```js\r\nfunction getLast(targetTime){\r\n    var target=+new Date(targetTime);\r\n    var now=+new Date();\r\n\r\n    var last=(target-now)/1000;//剩余总毫秒数\r\n    last=last<=0? 0:last;\r\n\r\n    var d=parseInt(last/60/60/24);\r\n    var h=parseInt(last/60/60%24);\r\n    var m=parseInt(last/60%60);\r\n    var s=parseInt(last%60);\r\n\r\n    d=d<10? \"0\"+d:d;\r\n    h=h<10? \"0\"+h:h;\r\n    m=m<10? \"0\"+m:m;\r\n    s=s<10? \"0\"+s:s;\r\n\r\n    return d+\" \"+h+\":\"+m+\":\"+s;\r\n}\r\n\r\nconsole.log(getLast(\"2022-6-28 12:24:00\"));\r\nconsole.log(getLast(0));\r\n```\r\n\r\n### Array对象\r\n* 常用字面量`[]`声明，或用`new Array()`声明空数组\r\n* 检测是否为数组： \r\n    * `instanceof` **运算符** 返回布尔值 `obj instanceof Array` 判断x是否为Array\r\n    * `Array.isArray(obj)` 检测是否为数组 Array内置方法\r\n* 常用方法\r\n    * `new Array(2)` 表示声明一个长度为2的空数组\r\n    * `new Array(2,3)` 表示声明一个数组`[2,3]`\r\n    * `Array.isArray(obj)` 检测是否为数组 Array内置方法\r\n    * `obj.push(x[,y,z])` 数组**末尾**添加一个或多个元素 **返回新数组长度**\r\n    * `obj.unshift(x[,y,z])` 数组**开头**添加一个或多个元素 **返回新数组长度**\r\n    * `obj.pop()` **弹出（删除）**数组中**最后一个**元素，**返回值为弹出的这个元素**\r\n    * `obj.shift()` **弹出（删除）**数组中**第一个**元素，**返回值为弹出的这个元素**\r\n    * `obj.reverse()` 翻转原数组 返回该数组\r\n    * `obj.sort()` 字典序排序 只能对0-9的数字完美排序\r\n    * `obj.sort(function(a,b){return a-b;})` 能对数字大小排序 a-b升序 b-a降序\r\n    * `obj.indexOf(x)` 返回数组中**第一个**元素x的索引  查找不到返回-1\r\n    * `obj.indexOf(x)` 返回数组中**最后一个**元素x的索引  查找不到返回-1\r\n    * `obj.indexOf(x,startIndex)` 同上，从某个位置开始查找\r\n    * `obj.toString()` 数组转字符串,逗号分隔 返回值字符串，不修改原数组\r\n    * `obj.join(\"分隔符 无实参默认逗号\")` 数组转字符串,自定义分隔符分隔 返回值字符串，不修改原数组\r\n    * `obj.concat()` 连接两个或多个数组，应该不影响原数组\r\n    * `obj.slice(beginIndex,endIndex)` 数组截取，返回被截取出的新数组 不会影响原数组\r\n    * `obj.splice(beginIndex,要删除个数)` 数组删除，返回被删除的数组，会影响原数组\r\n    * `obj.splice(obj.findIndex( (item)=> item.id == targetId),1)` 删除符合条件的指定元素\r\n    * `obj.filter( (item,index,arr) => return item > 10 )` filter过滤器,不会对空数组进行检测；不会改变原始数组\r\n    * `obj.includes(item)` 判断数组中是否包含某元素\r\n\r\n去重\r\n```js\r\n//遍历旧数组\r\n//如果旧数字的元素在新数组中查找不到，则插入新数组\r\n//否则进入下一次循环\r\n\r\nvar oldArray=[123,123,123,456,456,789,789]\r\nvar newArray=[];\r\nfor(index in oldArray){\r\n    if(newArray.indexOf(oldArray[index])==-1)\r\n        newArray.push(oldArray[index])\r\n}\r\nconsole.log(newArray);\r\n```\r\n\r\n### String对象\r\n\r\n#### 基本包装类型\r\n基本包装类型：js会把基本数据类型包装成复杂数据类型，这样基本数据类型就有了属性和方法\r\n\r\njs提供了三个特殊的引用类型：\r\n* String\r\n* Number\r\n* Boolean  \r\n\r\n```js\r\n//基本数据类型是没有属性和方法的，但是一下代码能正常执行\r\nvar str=\"DingYigui\"\r\nconsole.log(str.length);\r\n\r\n//上述代码的执行过程为\r\n// 1、生成临时变量，把简单类型保证成复杂数据类型\r\nvar temp = new String(\"DingYigui\")\r\n//2.赋值\r\nstr=temp;\r\n// 3. 销毁\r\ntemp=null;\r\n\r\n```\r\n\r\n#### 字符串不可变性\r\n字符串内的值不可变，虽看上去内容可以改变，实际是在内存中开辟了新的空间，地址变了  \r\n不要频繁拼接字符串：\r\n```js\r\n// 不要频繁拼接字符串，因为该过程会不断申请新内存\r\nvar str=\"123\"\r\nstr=\"456\"//重新给字符串赋值会在内存中重新开辟空间，这个特点就是字符串不可变\r\n\r\n//由于字符串不可变，频繁拼接字符串就会有效率问题，因为开辟空间需要时间\r\n\r\nfor(var i=0;i<10000000;i++)\r\n{\r\n    str+=i;\r\n}\r\nconsole.log(str)//非常耗时\r\n\r\n```\r\n\r\n### String对象的常用方法\r\n由于字符串的不可变性，字符串的所有方法不会修改字符串本身，只会返回一个新的字符串\r\n\r\n* `str.indexOf(\"查找字符\")`\r\n* `str.indexOf(\"查找字符\",startIndex)`\r\n* `str.charAt(index)` 返回指定位置字符\r\n* `str[index]` 返回指定位置字符 (html5 IE8+)\r\n* `str.charCodeAt(index)` 返回指定位置字符的ASCII码\r\n* `str.concat(str1,str2,str3)` 拼接两个多多个字符串 等效+运算符\r\n* `str.substr(starIndex,length)` 返回从某位置开始指定长度的字符串\r\n* `str.slice(start,end)` 截取下标(start,end] 的字符串，可以理解为切片\r\n* `str.substring(start,end)` 截取下标(start,end] 的字符串，同上，但是不接受负数\r\n* `str.replace(\"被替换的字符\",\"替换为字符\")`  只替换第一个字符  \r\n* `str.split(\"根据字符串中的什么字符作为分隔符\")` 字符转数组 \r\n    * `arr.join(\"分隔符\")` 是数组转字符串\r\n* `str.toUpperCase()` 转大写\r\n* `str.toLowerCase()` 转小写\r\n* \r\n\r\n### 试写相关算法\r\n查找字符串中所有z出现的位置及次数\r\n\r\n```js\r\nvar str=\"abcdzqwezxqwezgeflz\"\r\nvar list=[];\r\n\r\nlist.push(str.indexOf(\"z\"));//查找第一个z的位置\r\nwhile(true)\r\n{\r\n    var temp=str.indexOf(\"z\",list[list.length-1]+1)//从上一个位置之后开始查找\r\n    if(temp==-1)\r\n        break;\r\n    list.push(temp);\r\n}\r\nconsole.log(list)\r\nconsole.log(\"z出现了\" + list.length + \"次\")\r\n```\r\n\r\n统计每个字符出现的次数\r\n```js\r\nvar str=\"abcdzqwezxqwezgeflz\"\r\nvar obj={};\r\n\r\nfor(i in str)//统计每个字符出现的次数\r\n{\r\n    if(obj[str[i]])\r\n    {\r\n        obj[str[i]]++\r\n    }else{\r\n        obj[str[i]]=1;\r\n    }\r\n}\r\nconsole.log(obj)\r\n```\r\n\r\n统计每个字符出现的次数和具体位置\r\n```js\r\nvar str=\"abcdzqwezxqwezgeflz\"\r\nvar obj={};\r\n\r\nfor(i in str)//统计每个字符出现的次数\r\n{\r\n    if(obj[str[i]])\r\n    {\r\n        obj[str[i]].count++;\r\n        obj[str[i]].position.push(i);\r\n    }else{\r\n        obj[str[i]]={count:1,position:[i]}\r\n    }\r\n}\r\nconsole.log(obj)\r\n```\r\n![](./images/JavaScript基础知识复习笔记/2022-06-27-21-26-13.png)\r\n\r\n\r\n## 数据类型总结\r\n### 分类\r\n* **简单数据类型** 也叫基本数据类型、值类型\r\n    * 存储时，存储的是值本身，因此也叫值类型\r\n    * number string boolean undefined null(空对象，设计遗留问题)\r\n* **复杂数据类型** 也叫 引用类型\r\n    * Object Array Date等\r\n\r\n### 堆和栈\r\n* JavaScript中没有堆和栈的概念，下面的概念只是为了理解。\r\n* 一般是局部变量、函数形参、返回值\r\n    * 简单数据类型放入栈\r\n* 有程序员分配和释放，若程序员不释放，由垃圾回收机制回收\r\n    * 复杂数据类型放入堆\r\n\r\n* 简单数据类型存放在栈，直接在栈中存储值\r\n* 复杂数据类型存放在堆，在栈中存放地址\r\n![](./images/JavaScript基础知识复习笔记/2022-06-27-22-19-50.png)\r\n\r\n### 函数的值传递：类似c语言\r\n* 简单数据类型，实参传给形参的是值，对形参的操作不会影响原值\r\n* 复杂数据类型，实参传给形参的是地址，对形参的操作会印象原值"},{"shortInfo":{"title":"jQuery学习笔记","date":"2022-07-07T19:16:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["jQuery"],"hideAtIndex":true,"categories":"笔记","requirejQuery":true,"id":4261251047,"countWords":12248,"readSeconds":1224.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# jQuery学习笔记\r\n\r\n## 目录\r\n- [jQuery学习笔记](#jquery学习笔记)\r\n  - [目录](#目录)\r\n  - [概述](#概述)\r\n  - [jQuery基本使用](#jquery基本使用)\r\n    - [版本区别](#版本区别)\r\n    - [$符号](#符号)\r\n    - [JQuery对象和DOM对象](#jquery对象和dom对象)\r\n    - [入口函数](#入口函数)\r\n  - [jQuery选择器](#jquery选择器)\r\n    - [隐式迭代](#隐式迭代)\r\n    - [链式编程](#链式编程)\r\n    - [项目练习](#项目练习)\r\n      - [测试](#测试)\r\n      - [下拉菜单](#下拉菜单)\r\n      - [排他思想](#排他思想)\r\n      - [简易轮播图](#简易轮播图)\r\n  - [jQuery样式操作](#jquery样式操作)\r\n    - [案例练习](#案例练习)\r\n      - [tab栏切换](#tab栏切换)\r\n  - [jQuery效果](#jquery效果)\r\n    - [显示隐藏](#显示隐藏)\r\n    - [滑动](#滑动)\r\n    - [淡入淡出](#淡入淡出)\r\n    - [自定义动画](#自定义动画)\r\n    - [测试使用效果](#测试使用效果)\r\n      - [显示/隐藏测试](#显示隐藏测试)\r\n      - [滑动测试](#滑动测试)\r\n      - [淡入淡出测试1](#淡入淡出测试1)\r\n      - [淡入淡出测试2](#淡入淡出测试2)\r\n      - [动画测试](#动画测试)\r\n    - [案例练习](#案例练习-1)\r\n  - [hover事件切换](#hover事件切换)\r\n  - [动画：stop()停止排队](#动画stop停止排队)\r\n  - [Jquery内容操作](#jquery内容操作)\r\n    - [案例练习](#案例练习-2)\r\n  - [Jquery属性操作](#jquery属性操作)\r\n  - [元素操作](#元素操作)\r\n    - [遍历](#遍历)\r\n      - [each()遍历](#each遍历)\r\n      - [$.each()遍历](#each遍历-1)\r\n    - [创建、添加、删除元素](#创建添加删除元素)\r\n  - [jQuery尺寸及位置](#jquery尺寸及位置)\r\n    - [jQuery尺寸](#jquery尺寸)\r\n    - [jQuery位置](#jquery位置)\r\n  - [JQuery事件](#jquery事件)\r\n    - [事件注册](#事件注册)\r\n    - [事件解绑](#事件解绑)\r\n    - [事件处理](#事件处理)\r\n    - [触发事件](#触发事件)\r\n    - [事件对象](#事件对象)\r\n    - [案例测试](#案例测试)\r\n  - [jQuery拷贝](#jquery拷贝)\r\n  - [多库共存](#多库共存)\r\n  - [jquery插件](#jquery插件)\r\n  - [元素的缓存数据](#元素的缓存数据)\r\n\r\n## 概述\r\n* jQuery是一个用原生js写成的库，用于方便的操作DOM \r\n* j就是js，query就是查询，jQuery就是把原生js中的DOM操作做了封装\r\n* 其设计宗旨是“write less，do more”，倡导写更少的代码做更多的事\r\n* jQuery封装了js常用功能，优化了DOM操作、事件处理，动画设计，Ajax交互\r\n* 学习jQuery就是学习使用这些函数\r\n\r\n## jQuery基本使用\r\n### 版本区别\r\n* 1.X 支持ie678,不再更新维护\r\n* 2.X 不支持ie678,不再更新维护\r\n* 3.X 不支持ie678,官网更新维护\r\n    * production 版本，用于生产环境，代码经过压缩，jQuery.mini.js\r\n    * development 版本，开发版本，代码保留了注释和缩进格式\r\n\r\n\r\n### $符号\r\n`$`符号是jQuery的**别称**\r\n```js\r\n//两种写法等效\r\n$(\"div\").hide();\r\njQuery(\"div\").hide();\r\n```\r\n`$`符号、或者说`jQuery`，是jQuery的**顶级对象**\r\n  * jQuery对象以**伪数组**形式存储，数组的**每个元素为DOM对象**\r\n  * jQuery对象本质就是对DOM对象进行了封装，增添了一些属性和方法\r\n```js\r\n//$(\"div\") 和 jQuery(\"div\") 等效，\r\n//是一个jQuery对象，能够调用在jQuery中定义的属性和方法\r\n$(\"div\").hide()\r\njQuery(\"div\").hide()\r\n```\r\n\r\n### JQuery对象和DOM对象\r\n* DOM对象: \r\n  * `document.querySelector(\"#DEMOwoejwe\")`\r\n  * 获取DOM对象的方法不止这一种\r\n* JQuery对象: \r\n  * 几种不同的写法：\r\n    * `jQuery(document.querySelector(\"#DEMOwoejwe\"))`\r\n    * `$(document.querySelector(\"#DEMOwoejwe\"))`\r\n    * `$(\"#DEMOwoejwe\")`\r\n* 相互转换\r\n  * DOM对象->Jquery对象: `$(DOM对象)`\r\n  * Jquery对象->DOM对象：\r\n    * `Jquery对象[0]`\r\n    * `Jquery对象.get(0)`\r\n\r\n```js\r\n// 以下写法是等效的\r\n\r\n// 通过Jquery对象操作元素:\r\n$(document.querySelector(\"div\")).hide()\r\n$(\"div\").hide()\r\n\r\n//通过DOM对象操作元素:\r\ndocument.querySelector(\"div\").style.display=\"none\"\r\n$(\"div\")[0].style.display=\"none\"\r\n$(\"div\").get(0).style.display=\"none\"\r\n```\r\n\r\n\r\n\r\n### 入口函数\r\n```js\r\n//隐藏元素，但只能操作已经加载完毕的DOM元素\r\n$(\"div\").hide();\r\n\r\n//等到dom结构加载完毕后再执行回调函数，相当于DOMContentLoaded事件,不是load事件\r\n$(document).ready(\r\n    function(){\r\n        $(\"div\").hide();\r\n    }\r\n)\r\n\r\n//更简洁的写法，功能同上，等待dom结构加载完毕后再执行回调函数\r\n$(\r\n    function(){\r\n        $(\"div\").hide();\r\n    }\r\n)\r\n```\r\n\r\n## jQuery选择器\r\n原生js获取元素的方式多而杂，jQuery对此做了封装，通过css选择器的语法格式来选中元素\r\n```js\r\n$(\"css选择器格式\")\r\n```\r\n\r\n普通选择器\r\n* `$(\"div\")` 标签选择器\r\n* `$(\"*\")` 全选选择器\r\n* `$(\"#id\")` id选择器\r\n* `$(\".class\")` 类名选择器\r\n* `$(\"div.class#id\")` 交集选择器\r\n* `$(\"div,class,id\")` 并集选择器\r\n\r\n层级选择器\r\n* `$(\"ul>li>a\")` 子代选择器\r\n* `$(\"ul li a\")` 后代选择器\r\n\r\n筛选选择器\r\n* `$(选择器:first)` 获取第一个元素\r\n* `$(选择器:last)` 获取最后一个元素\r\n* `$(选择器:eq(index))` 获取第Index个元素(第一个为0)\r\n* `$(选择器:obb)` 获取索引号为奇数的选择器\r\n* `$(选择器:even)` 获取索引号为偶数的选择器\r\n\r\n筛选函数\r\n* ★`jQueryObj.parent()` 查找直系父级\r\n* ★`jQueryObj.parents()` 获取所有父级，伪数组，第0个元素为直系父级 \r\n* ★`jQueryObj.parents(\"css格式选择器\")` 获取所有满足条件的父级，伪数组，下标越大，辈分越高。\r\n* ★`jQueryObj.children(\"css格式选择器\")` 查找子元素，子代选择器\r\n* `jQueryObj.find(\"css格式选择器\")` 查找后代元素，后代选择器\r\n* ★`jQueryObj.siblings(\"css格式选择器\")` 查找兄弟元素，不包括自身\r\n* `jQueryObj.nextAll([expr])` 查找之后的所有兄弟节点\r\n* `jQueryObj.prevAll([expr])` 查找之前的所有兄弟节点\r\n* ★`jQueryObj.hasClass(\"类名\")` 检测当前元素是否有某类名\r\n* ★`jQueryObj.eq(index)` 获取当前元素中第Index个元素\r\n\r\n\r\n\r\n### 隐式迭代\r\n* 遍历jQuery对象内部存储的DOM元素的过程就称为**隐式迭代**\r\n* 如：`$(\"div a\")` 是一个JQuery对象，其存储形式是一个伪数组，该数组中的每一个元素都是一个DOM对象，隐式迭代就是遍历该JQuery伪数组中的每一个DOM对象，对其执行相同的操作，省去了手动写for循环的过程\r\n```js\r\n//div中的所有a的背景色都会改变\r\n$(\"div a\").css(\"background-color\",\"skyblue\");\r\n```\r\n\r\n### 链式编程\r\n```js\r\n//这种写法，需要将选择器$(\"#demoBoxj02r002 .right li\")写两遍，会使得代码变得冗长\r\n$(\"#demoBoxj02r002 .right li\").css(\"background-color\",\"red\")\r\n$(\"#demoBoxj02r002 .right li\").show()\r\n//上面两句话可以合并写成一句\r\n$(\"#demoBoxj02r002 .right li\").css(\"background-color\",\"red\").show()\r\n```\r\n\r\n### 项目练习\r\n\r\n#### 测试\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<div id=\"test\">已引入jQuery库</div>\r\n<style>\r\n    #test{\r\n        display: none;\r\n        min-width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        line-height: 100px;\r\n        text-align: center;\r\n        color: white;\r\n    }\r\n</style>\r\n<script>\r\n    $(\"#test\").css(\"display\",\"inline-block\")\r\n</script>\r\n\r\n```html\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<div id=\"test\">已引入jQuery库</div>\r\n<style>\r\n    #test{\r\n        display: none;\r\n        min-width: 100px;\r\n        height: 100px;\r\n        background-color: green;\r\n        line-height: 100px;\r\n        text-align: center;\r\n        color: white;\r\n    }\r\n</style>\r\n<script>\r\n    $(\"#test\").css(\"display\",\"inline-block\")\r\n</script>\r\n```\r\n\r\n#### 下拉菜单  \r\n\r\n<script>\r\n$(function () {//DOMContentLoaded\r\n        $(\"ul#demoXLCD>li\").mouseenter(function () { //应当注册给不支持冒泡的mouseenter事件\r\n            $(this).children(\"ul\").show()\r\n        });\r\n        $(\"ul#demoXLCD>li\").mouseleave(function () { //应当注册给不支持冒泡的mouseleave事件\r\n            $(this).children(\"ul\").hide()\r\n        });\r\n    }\r\n);\r\n</script>\r\n<ul id=\"demoXLCD\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demoXLCD,\r\n    ul#demoXLCD *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demoXLCD *::before,\r\n    ul#demoXLCD *::after{\r\n        content: none;\r\n    }\r\n    ul#demoXLCD{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demoXLCD>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demoXLCD>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demoXLCD>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demoXLCD>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demoXLCD>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demoXLCD>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demoXLCD>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script>\r\n$(function () {//DOMContentLoaded\r\n        $(\"ul#demoXLCD>li\").mouseenter(function () { //应当注册给不支持冒泡的mouseenter事件\r\n            $(this).children(\"ul\").show()\r\n        });\r\n        $(\"ul#demoXLCD>li\").mouseleave(function () { //应当注册给不支持冒泡的mouseleave事件\r\n            $(this).children(\"ul\").hide()\r\n        });\r\n    }\r\n);\r\n</script>\r\n<ul id=\"demoXLCD\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demoXLCD,\r\n    ul#demoXLCD *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demoXLCD *::before,\r\n    ul#demoXLCD *::after{\r\n        content: none;\r\n    }\r\n    ul#demoXLCD{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demoXLCD>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demoXLCD>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demoXLCD>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demoXLCD>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demoXLCD>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demoXLCD>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demoXLCD>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n```\r\n\r\n#### 排他思想\r\n\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<div id=\"DemoTEST123\">\r\n    <button>测试1</button>\r\n    <button>测试2</button>\r\n    <button>测试3</button>\r\n    <button>测试4</button>\r\n    <button>测试5</button>\r\n</div>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#DemoTEST123>button\").click(function(){\r\n            $(this).siblings().css(\"color\",\"red\")\r\n            $(this).css(\"color\",\"green\")\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<div id=\"DemoTEST123\">\r\n    <button>测试1</button>\r\n    <button>测试2</button>\r\n    <button>测试3</button>\r\n    <button>测试4</button>\r\n    <button>测试5</button>\r\n</div>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#DemoTEST123>button\").click(function(){\r\n            $(this).siblings().css(\"color\",\"red\")\r\n            $(this).css(\"color\",\"green\")\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### 简易轮播图\r\n注意：\r\n* 可以通过`$(this).index()`函数获取当前元素的索引号\r\n* 需通过`jQueryObj.eq(index)`获取jQuery元素，`jQueryObj[index]`获取到的是DOM元素\r\n\r\n\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoBoxj02r002 .left li\").mouseenter(function(){\r\n            $(\"#demoBoxj02r002 .right li\").hide()\r\n            $(\"#demoBoxj02r002 .right li\").eq($(this).index()).show()\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demoBoxj02r002\">\r\n    <ul class=\"left\">\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n    </ul>\r\n    <ul class=\"right\">\r\n        <li style=\"background-color:skyblue;\">图片切换区</li>\r\n        <li style=\"background-color:pink;display: block;\">图片切换区</li>\r\n        <li style=\"background-color:green;\">图片切换区</li>\r\n        <li style=\"background-color:greenyellow;\">图片切换区</li>\r\n        <li style=\"background-color:yellow;\">图片切换区</li>\r\n        <li style=\"background-color:gold;\">图片切换区</li>\r\n        <li style=\"background-color:red;\">图片切换区</li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    #demoBoxj02r002 *,\r\n    #demoBoxj02r002 *::after,\r\n    #demoBoxj02r002 *::before{\r\n        content: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    #demoBoxj02r002{\r\n        display: flex;\r\n        justify-content: space-between;\r\n        align-items: flex-start;\r\n        width: 400px;\r\n        height: 400px;\r\n        background-color: #fff;\r\n    }\r\n    #demoBoxj02r002 .left{\r\n        display: flex;\r\n        flex-direction: column;\r\n        justify-content: space-evenly;\r\n        width: 100px;\r\n        height: 100%;\r\n        background-color: green;\r\n    }\r\n    #demoBoxj02r002 .left li{\r\n        flex: 1;\r\n        width: 100%;\r\n        background-color: white;\r\n        /* border: 5px solid gray; */\r\n        box-sizing: border-box;\r\n        color: black;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n    }\r\n    #demoBoxj02r002 .left li:hover{\r\n        background-color: gray;\r\n    }\r\n    #demoBoxj02r002 .right{\r\n        flex: 1;\r\n        height: 100%;\r\n        /* background-color: blue; */\r\n    }\r\n    #demoBoxj02r002 .right li{\r\n        display: none;\r\n        width: 100%;\r\n        height: 100%;\r\n        color: black;\r\n    }\r\n</style>\r\n\r\n\r\n```html\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoBoxj02r002 .left li\").mouseenter(function(){\r\n            $(\"#demoBoxj02r002 .right li\").hide()\r\n            $(\"#demoBoxj02r002 .right li\").eq($(this).index()).show()\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demoBoxj02r002\">\r\n    <ul class=\"left\">\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n        <li>测试</li>\r\n    </ul>\r\n    <ul class=\"right\">\r\n        <li style=\"background-color:skyblue;\">图片切换区</li>\r\n        <li style=\"background-color:pink;display: block;\">图片切换区</li>\r\n        <li style=\"background-color:green;\">图片切换区</li>\r\n        <li style=\"background-color:greenyellow;\">图片切换区</li>\r\n        <li style=\"background-color:yellow;\">图片切换区</li>\r\n        <li style=\"background-color:gold;\">图片切换区</li>\r\n        <li style=\"background-color:red;\">图片切换区</li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    #demoBoxj02r002 *,\r\n    #demoBoxj02r002 *::after,\r\n    #demoBoxj02r002 *::before{\r\n        content: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    #demoBoxj02r002{\r\n        display: flex;\r\n        justify-content: space-between;\r\n        align-items: flex-start;\r\n        width: 400px;\r\n        height: 400px;\r\n        background-color: #fff;\r\n    }\r\n    #demoBoxj02r002 .left{\r\n        display: flex;\r\n        flex-direction: column;\r\n        justify-content: space-evenly;\r\n        width: 100px;\r\n        height: 100%;\r\n        background-color: green;\r\n    }\r\n    #demoBoxj02r002 .left li{\r\n        flex: 1;\r\n        width: 100%;\r\n        background-color: white;\r\n        /* border: 5px solid gray; */\r\n        box-sizing: border-box;\r\n        color: black;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n    }\r\n    #demoBoxj02r002 .left li:hover{\r\n        background-color: gray;\r\n    }\r\n    #demoBoxj02r002 .right{\r\n        flex: 1;\r\n        height: 100%;\r\n        /* background-color: blue; */\r\n    }\r\n    #demoBoxj02r002 .right li{\r\n        display: none;\r\n        width: 100%;\r\n        height: 100%;\r\n        color: black;\r\n    }\r\n</style>\r\n``` \r\n\r\n## jQuery样式操作\r\n* 对于**简单的样式**修改，可用css()方法实现\r\n  * **修改**css属性值：\r\n    * 方法1：`jQueryObj.css(\"属性名\"，属性值);`\r\n      * 属性名必须加双引号\r\n      * 属性名属性格式和css一致\r\n      * 属性值若是数字可以不加单位，不加双引号\r\n    * 方法2：`jQueryObj.css({\"属性名1\":属性值1,\"属性名2\":属性值2});`\r\n      * css(参数)；参数是一个对象\r\n      * 属性名可以不加双引号，若不加双引号则遵循驼峰命名法\r\n      * 属性名加双引号时，属性名书写和css属性名一致\r\n      * 属性值若是数字可以不加单位，不加引号\r\n  * **获取**css属性值：`jQueryObj.css(\"属性名\");`\r\n* 对**于复杂的样式**修改，可通过附加类名的方式实现\r\n  * 添加类名：`jQueryObj.addClass(\"类名\");`\r\n  * 移除类名：`jQueryObj.removeClass(\"类名\");`\r\n  * 切换类名：`jQueryObj.toggleClass(\"类名\");` 如果没有该类名，则附加，若有则移除\r\n\r\n\r\n\r\n### 案例练习\r\n#### tab栏切换\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n$(document).ready(function(){\r\n    $(\"#demo234r034930>ul>li\").click(function(){\r\n        $(this).addClass(\"actived\").siblings().removeClass(\"actived\")\r\n        $(\"#demo234r034930>ol>li\").eq($(this).index()).addClass(\"actived\").siblings().removeClass(\"actived\")\r\n    })\r\n})\r\n</script>\r\n<div id=\"demo234r034930\">\r\n    <ul>\r\n        <li class=\"actived\">栏目1</li>\r\n        <li>栏目2</li>\r\n        <li>栏目3</li>\r\n        <li>栏目4</li>\r\n    </ul>\r\n    <ol>\r\n        <li class=\"actived\">测试内容1</li>\r\n        <li>测试内容2</li>\r\n        <li>测试内容3</li>\r\n        <li>测试内容4</li>\r\n    </ol>\r\n</div>\r\n<style>\r\n    #demo234r034930 *,\r\n    #demo234r034930 *::after,\r\n    #demo234r034930 *::before{\r\n        content: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    #demo234r034930{\r\n        display: flex;\r\n        flex-direction:column;\r\n        justify-content: flex-start;\r\n        align-self: start;\r\n        width: 100%;\r\n        min-height: 500px;\r\n        background-color: #fff;\r\n    }\r\n    #demo234r034930>ul{\r\n        display: flex;\r\n        justify-content: flex-start;\r\n        align-items: center;\r\n        height: 50px;\r\n        /* background-color: gray; */\r\n    }\r\n    #demo234r034930>ul>li{\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        height: 100%;\r\n        font-size: 15px;\r\n        font-weight: bold;\r\n        padding: 0 20px;\r\n        color: black;\r\n    }\r\n    #demo234r034930>ul>li:hover{\r\n        background-color: red;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ul>li.actived{\r\n        background-color: red;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ol{\r\n        flex: 1;\r\n        background-color: skyblue;\r\n    }\r\n    #demo234r034930>ol>li{\r\n        display: none;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ol>li.actived{\r\n        display: block;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n$(document).ready(function(){\r\n    $(\"#demo234r034930>ul>li\").click(function(){\r\n        $(this).addClass(\"actived\").siblings().removeClass(\"actived\")\r\n        $(\"#demo234r034930>ol>li\").eq($(this).index()).addClass(\"actived\").siblings().removeClass(\"actived\")\r\n    })\r\n})\r\n</script>\r\n<div id=\"demo234r034930\">\r\n    <ul>\r\n        <li class=\"actived\">栏目1</li>\r\n        <li>栏目2</li>\r\n        <li>栏目3</li>\r\n        <li>栏目4</li>\r\n    </ul>\r\n    <ol>\r\n        <li class=\"actived\">测试内容1</li>\r\n        <li>测试内容2</li>\r\n        <li>测试内容3</li>\r\n        <li>测试内容4</li>\r\n    </ol>\r\n</div>\r\n<style>\r\n    #demo234r034930 *,\r\n    #demo234r034930 *::after,\r\n    #demo234r034930 *::before{\r\n        content: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    #demo234r034930{\r\n        display: flex;\r\n        flex-direction:column;\r\n        justify-content: flex-start;\r\n        align-self: start;\r\n        width: 100%;\r\n        min-height: 500px;\r\n        background-color: #fff;\r\n    }\r\n    #demo234r034930>ul{\r\n        display: flex;\r\n        justify-content: flex-start;\r\n        align-items: center;\r\n        height: 50px;\r\n        /* background-color: gray; */\r\n    }\r\n    #demo234r034930>ul>li{\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        height: 100%;\r\n        font-size: 15px;\r\n        font-weight: bold;\r\n        padding: 0 20px;\r\n        color: black;\r\n    }\r\n    #demo234r034930>ul>li:hover{\r\n        background-color: red;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ul>li.actived{\r\n        background-color: red;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ol{\r\n        flex: 1;\r\n        background-color: skyblue;\r\n    }\r\n    #demo234r034930>ol>li{\r\n        display: none;\r\n        color: white;\r\n    }\r\n    #demo234r034930>ol>li.actived{\r\n        display: block;\r\n    }\r\n</style>\r\n```\r\n\r\n## jQuery效果\r\n### 显示隐藏\r\n* `jQueryObj.hide([speed,[easing],[callback]])`\r\n* `jQueryObj.show()`\r\n* `jQueryObj.toggle()` 显示隐藏效果的切换\r\n\r\n### 滑动\r\n* `jQueryObj.slideDown([speed,[easing],[callback]])`\r\n* `jQueryObj.slideUp([speed,[easing],[callback]])`\r\n* `jQueryObj.slideToggle([speed,[easing],[callback]])`\r\n\r\n### 淡入淡出\r\n* `jQueryObj.fadeIn([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeOut([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeToggle([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeTo()`\r\n\r\n### 自定义动画\r\n* `jQueryObj.animate()`\r\n\r\n\r\n### 测试使用效果\r\n\r\n#### 显示/隐藏测试\r\n\r\n* `jQueryObj.show([speed,[easing],[callback]])`\r\n* `jQueryObj.toggle([speed,[easing],[callback]])`\r\n* `jQueryObj.hide([speed,[easing],[callback]])`\r\n\r\n这几个函数的参数取值一致\r\n* **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n* **easing**取值: \r\n    * \"swing\" 慢-快-慢；默认取值\r\n    * \"linear\" 线性匀速\r\n* **callback** 回调函数 \r\n\r\n\r\n\r\n<button id=\"demoTesthide_btn1\" >不带参数show/hide：显示/隐藏测试</button>\r\n<button id=\"demoTesthide_btn2\" >带参数的show/hide：显示/隐藏测试</button>\r\n<div id=\"demoTesthide\" style=\"width: 100px;height: 100px;background-color: skyblue;\">显示/隐藏测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoTesthide_btn1\").click(function(){\r\n            $(\"#demoTesthide\").toggle()\r\n        })\r\n        $(\"#demoTesthide_btn2\").click(function(){\r\n            $(\"#demoTesthide\").toggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demoTesthide_btn1\" >不带参数show/hide：显示/隐藏测试</button>\r\n<button id=\"demoTesthide_btn2\" >带参数的show/hide：显示/隐藏测试</button>\r\n<div id=\"demoTesthide\" style=\"width: 100px;height: 100px;background-color: skyblue;\">显示/隐藏测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoTesthide_btn1\").click(function(){\r\n            $(\"#demoTesthide\").toggle()\r\n        })\r\n        $(\"#demoTesthide_btn2\").click(function(){\r\n            $(\"#demoTesthide\").toggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### 滑动测试\r\n\r\n\r\n* `jQueryObj.slideDown([speed,[easing],[callback]])`\r\n* `jQueryObj.slideUp([speed,[easing],[callback]])`\r\n* `jQueryObj.slideToggle([speed,[easing],[callback]])`\r\n\r\n这几个函数的参数取值一致\r\n* **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n* **easing**取值: \r\n    * \"swing\" 慢-快-慢；默认取值\r\n    * \"linear\" 线性匀速\r\n* **callback** 回调函数  \r\n\r\n<button id=\"demoTowweijfwe1\">不带参数slide：下滑动、上滑动测试</button>\r\n<button id=\"demoTowweijfwe2\">带参数的slide：下滑动、上滑动测试</button>\r\n<div id=\"demoTowweijfwe3\" style=\"width: 100px;height: 100px;background-color: skyblue;\">下滑动、上滑动测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoTowweijfwe1\").click(function(){\r\n            $(\"#demoTowweijfwe3\").slideToggle()\r\n        })\r\n        $(\"#demoTowweijfwe2\").click(function(){\r\n            $(\"#demoTowweijfwe3\").slideToggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n```html\r\n<button id=\"demoTowweijfwe1\">不带参数slide：下滑动、上滑动测试</button>\r\n<button id=\"demoTowweijfwe2\">带参数的slide：下滑动、上滑动测试</button>\r\n<div id=\"demoTowweijfwe3\" style=\"width: 100px;height: 100px;background-color: skyblue;\">下滑动、上滑动测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demoTowweijfwe1\").click(function(){\r\n            $(\"#demoTowweijfwe3\").slideToggle()\r\n        })\r\n        $(\"#demoTowweijfwe2\").click(function(){\r\n            $(\"#demoTowweijfwe3\").slideToggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n#### 淡入淡出测试1\r\n\r\n* `jQueryObj.fadeIn([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeOut([speed,[easing],[callback]])`\r\n* `jQueryObj.fadeToggle([speed,[easing],[callback]])`\r\n\r\n这几个函数的参数取值一致\r\n* **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n* **easing**取值: \r\n    * \"swing\" 慢-快-慢；默认取值\r\n    * \"linear\" 线性匀速\r\n* **callback** 回调函数  \r\n\r\n<button id=\"demofnwfo\">不带参数fade：淡入淡出测试</button>\r\n<button id=\"demofwioefog\">带参数的fade：淡入淡出测试</button>\r\n<div id=\"demoTowwedfwofwfp\" style=\"width: 100px;height: 100px;background-color: skyblue;\">淡入淡出测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnwfo\").click(function(){\r\n            $(\"#demoTowwedfwofwfp\").fadeToggle()\r\n        })\r\n        $(\"#demofwioefog\").click(function(){\r\n            $(\"#demoTowwedfwofwfp\").fadeToggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demofnwfo\">不带参数fadeToggle：淡入淡出测试</button>\r\n<button id=\"demofwioefog\">带参数的fadeToggle：淡入淡出测试</button>\r\n<div id=\"demoTowwedfwofwfp\" style=\"width: 100px;height: 100px;background-color: skyblue;\">淡入淡出测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnwfo\").click(function(){\r\n            $(\"#demoTowwedfwofwfp\").fadeToggle()\r\n        })\r\n        $(\"#demofwioefog\").click(function(){\r\n            $(\"#demoTowwedfwofwfp\").fadeToggle(\"fast\",\"swing\")\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### 淡入淡出测试2\r\n\r\n* `jQueryObj.fadeTo( speed ,  opacity  [,[easing],[callback]])`\r\n\r\n* **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n* **opacity**取值： 透明度，小数\r\n* **easing**取值: \r\n    * \"swing\" 慢-快-慢；默认取值\r\n    * \"linear\" 线性匀速\r\n* **callback** 回调函数  \r\n\r\n<button id=\"demofnwfo123\">fadeTo测试</button>\r\n<div id=\"demoTowwedfwofwfp111\" style=\"width: 100px;height: 100px;background-color: skyblue;\">fadeTo测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnwfo123\").click(function(){\r\n            $(\"#demoTowwedfwofwfp111\").fadeTo(\"fast\",0.5)\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demofnwfo123\">fadeTo测试</button>\r\n<div id=\"demoTowwedfwofwfp111\" style=\"width: 100px;height: 100px;background-color: skyblue;\">fadeTo测试</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnwfo123\").click(function(){\r\n            $(\"#demoTowwedfwofwfp111\").fadeTo(\"fast\",0.5)\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### 动画测试\r\n* `jQueryObj.animate(params  [,speed,[easing],[callback]])`\r\n    * params是一个对象，其中属性名可以不带引号，复合属性需要驼峰命名法或者带引号\r\n    * 其他参数都可以省略\r\n    * **speed**取值: \"slow\"、\"normal\"、\"fast\"、或 毫秒数1000\r\n    * **easing**取值: \r\n        * \"swing\" 慢-快-慢；默认取值\r\n        * \"linear\" 线性匀速\r\n    * **callback** 回调函数  \r\n\r\n<button id=\"demofnfwef\">动画测试</button>\r\n<div style=\"position:relative;width: 100px;height: 100px;\">\r\n    <div id=\"demoToww3432\" style=\"position: absolute; width: 100px;height: 100px;background-color: skyblue;\">动画测试</div>\r\n</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnfwef\").click(function(){\r\n            $(\"#demoToww3432\").animate(\r\n                {\r\n                    \"top\":50,\r\n                    \"left\":100,\r\n                    \"opacity\":0.5,\r\n                    \"width\":50,\r\n                    \"height\":50\r\n                },\r\n                1000,//速度 1s\r\n                \"swing\"\r\n            )\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demofnfwef\">动画测试</button>\r\n<div style=\"position:relative;width: 100px;height: 100px;\">\r\n    <div id=\"demoToww3432\" style=\"position: absolute; width: 100px;height: 100px;background-color: skyblue;\">动画测试</div>\r\n</div>\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demofnfwef\").click(function(){\r\n            $(\"#demoToww3432\").animate(\r\n                {\r\n                    \"top\":50,\r\n                    \"left\":100,\r\n                    \"opacity\":0.5,\r\n                    \"width\":50,\r\n                    \"height\":50\r\n                },\r\n                1000,//速度 1s\r\n                \"swing\"\r\n            )\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n### 案例练习\r\n\r\n王者荣耀手风琴效果\r\n\r\n主要思路：\r\n* 动画调整大盒子li的宽度\r\n* fadeIn、fadeOUt\r\n\r\n![](./images/jQuery学习笔记/2022-07-09-07-17-10.png)\r\n\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n$(document).ready(function(){\r\n    $(\"#wzryBox ul li\").mouseenter(function(){\r\n        // \r\n        $(this).siblings().stop().animate({width:50})\r\n        $(this).siblings().find(\".small\").stop().fadeIn()\r\n        $(this).siblings().find(\".big\").stop().fadeOut()\r\n        // \r\n        $(this).stop().animate({width:150})\r\n        $(this).find(\".small\").stop().fadeOut()\r\n        $(this).find(\".big\").stop().fadeIn()\r\n    })\r\n})\r\n</script>\r\n<div id=\"wzryBox\">\r\n    <h2>文字介绍</h2>\r\n    <ul>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    #wzryBox *,\r\n    #wzryBox *::after,\r\n    #wzryBox *::before{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        content: none;\r\n    }\r\n    #wzryBox{\r\n        padding: 0 5px;\r\n        width: 650px;\r\n        height: 85px;\r\n        background-color: skyblue;\r\n    }\r\n    #wzryBox h2{\r\n        display: inline-block;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        font-size: 10px;\r\n        color: gray;\r\n    }\r\n    #wzryBox ul{\r\n        display: flex;\r\n    }\r\n    #wzryBox ul li{\r\n        margin: 0 2.5px;\r\n        height: 50px;\r\n        width: 50px;\r\n        border-radius: 5px;\r\n        /* background-color: white; */\r\n    }\r\n    #wzryBox ul li a{\r\n        position: relative;\r\n        display: block;\r\n        height: 50px;\r\n        min-width: 50px;\r\n    }\r\n    #wzryBox ul li a .small{\r\n        display: block;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: red;\r\n        border-radius: 5px;\r\n    }\r\n    #wzryBox ul li a .big{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        width: 150px;\r\n        height: 50px;\r\n        background-color: green;\r\n        border-radius: 5px;\r\n    }\r\n    #wzryBox ul li:nth-child(1){\r\n        width: 150px;\r\n    }\r\n    #wzryBox ul li:nth-child(1) a .big{\r\n        display: block;\r\n    }\r\n    #wzryBox ul li:nth-child(1) a .small{\r\n        display: none;\r\n    }\r\n</style>\r\n\r\n\r\n```html\r\n<script src=\"./_js/jQuery.js\"></script>\r\n<script>\r\n$(document).ready(function(){\r\n    $(\"#wzryBox ul li\").mouseenter(function(){\r\n        // \r\n        $(this).siblings().stop().animate({width:50})\r\n        $(this).siblings().find(\".small\").stop().fadeIn()\r\n        $(this).siblings().find(\".big\").stop().fadeOut()\r\n        // \r\n        $(this).stop().animate({width:150})\r\n        $(this).find(\".small\").stop().fadeOut()\r\n        $(this).find(\".big\").stop().fadeIn()\r\n    })\r\n})\r\n</script>\r\n<div id=\"wzryBox\">\r\n    <h2>文字介绍</h2>\r\n    <ul>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n        <li>\r\n            <a href=\"void;\">\r\n                <div class=\"big\"></div>\r\n                <div class=\"small\"></div>\r\n            </a>\r\n        </li>\r\n    </ul>\r\n</div>\r\n<style>\r\n    #wzryBox *,\r\n    #wzryBox *::after,\r\n    #wzryBox *::before{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        content: none;\r\n    }\r\n    #wzryBox{\r\n        padding: 0 5px;\r\n        width: 650px;\r\n        height: 85px;\r\n        background-color: skyblue;\r\n    }\r\n    #wzryBox h2{\r\n        display: inline-block;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        font-size: 10px;\r\n        color: gray;\r\n    }\r\n    #wzryBox ul{\r\n        display: flex;\r\n    }\r\n    #wzryBox ul li{\r\n        margin: 0 2.5px;\r\n        height: 50px;\r\n        width: 50px;\r\n        border-radius: 5px;\r\n        /* background-color: white; */\r\n    }\r\n    #wzryBox ul li a{\r\n        position: relative;\r\n        display: block;\r\n        height: 50px;\r\n        min-width: 50px;\r\n    }\r\n    #wzryBox ul li a .small{\r\n        display: block;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: red;\r\n        border-radius: 5px;\r\n    }\r\n    #wzryBox ul li a .big{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        width: 150px;\r\n        height: 50px;\r\n        background-color: green;\r\n        border-radius: 5px;\r\n    }\r\n    #wzryBox ul li:nth-child(1){\r\n        width: 150px;\r\n    }\r\n    #wzryBox ul li:nth-child(1) a .big{\r\n        display: block;\r\n    }\r\n    #wzryBox ul li:nth-child(1) a .small{\r\n        display: none;\r\n    }\r\n</style>\r\n```\r\n\r\n## hover事件切换\r\n`jQueryObj.hover([over,]out)`\r\n* over:回调函数，mouseenter事件触发后调用\r\n* out：回调函数，mouseleaver事件触发后调用\r\n* 只写一个回调函数时表示，mouseenter事件和mouseleaver事件触发均调用该函数\r\n\r\n<script>\r\n    $(function () {//DOMContentLoaded\r\n    //原先写法：\r\n            // $(\"ul#demofiwuwhfi>li\").mouseenter(function () { //应当注册给不支持冒泡的mouseenter事件\r\n            //     $(this).children(\"ul\").show()\r\n            // });\r\n            // $(\"ul#demofiwuwhfi>li\").mouseleave(function () { //应当注册给不支持冒泡的mouseleave事件\r\n            //     $(this).children(\"ul\").hide()\r\n            // });\r\n    //hover写法：\r\n        //hover的两个实参均为回调函数，分别对应mouseenter和mouseleave事件\r\n            // $(\"ul#demofiwuwhfi>li\").hover(\r\n            //     function () {\r\n            //         $(this).children(\"ul\").slideDown(200)\r\n            //     },\r\n            //     function(){\r\n            //         $(this).children(\"ul\").slideUp(100)\r\n            //     }\r\n            // );\r\n        //hover只写一个参数时，表示两个事件均触发该事件\r\n            $(\"ul#demofiwuwhfi>li\").hover(function () {\r\n                $(this).children(\"ul\").slideToggle(200)\r\n            });\r\n    });\r\n</script>\r\n<ul id=\"demofiwuwhfi\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demofiwuwhfi,\r\n    ul#demofiwuwhfi *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demofiwuwhfi *::before,\r\n    ul#demofiwuwhfi *::after{\r\n        content: none;\r\n    }\r\n    ul#demofiwuwhfi{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demofiwuwhfi>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demofiwuwhfi>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demofiwuwhfi>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demofiwuwhfi>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script>\r\n    $(function () {//DOMContentLoaded\r\n    //原先写法：\r\n            // $(\"ul#demofiwuwhfi>li\").mouseenter(function () { //应当注册给不支持冒泡的mouseenter事件\r\n            //     $(this).children(\"ul\").show()\r\n            // });\r\n            // $(\"ul#demofiwuwhfi>li\").mouseleave(function () { //应当注册给不支持冒泡的mouseleave事件\r\n            //     $(this).children(\"ul\").hide()\r\n            // });\r\n    //hover写法：\r\n        //hover的两个实参均为回调函数，分别对应mouseenter和mouseleave事件\r\n            // $(\"ul#demofiwuwhfi>li\").hover(\r\n            //     function () {\r\n            //         $(this).children(\"ul\").slideDown(200)\r\n            //     },\r\n            //     function(){\r\n            //         $(this).children(\"ul\").slideUp(100)\r\n            //     }\r\n            // );\r\n        //hover只写一个参数时，表示两个事件均触发该事件\r\n            $(\"ul#demofiwuwhfi>li\").hover(function () {\r\n                $(this).children(\"ul\").slideToggle(200)\r\n            });\r\n    });\r\n</script>\r\n<ul id=\"demofiwuwhfi\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demofiwuwhfi,\r\n    ul#demofiwuwhfi *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demofiwuwhfi *::before,\r\n    ul#demofiwuwhfi *::after{\r\n        content: none;\r\n    }\r\n    ul#demofiwuwhfi{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demofiwuwhfi>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demofiwuwhfi>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demofiwuwhfi>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demofiwuwhfi>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demofiwuwhfi>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n```\r\n\r\n## 动画：stop()停止排队\r\n* stop()函数可以停止排队,必须写在动画之前\r\n* 用来暂停队列中未播放完毕的动画\r\n\r\n<script>\r\n    $(function () {//DOMContentLoaded\r\n        //原先写法： 当鼠标在li之间快速移动时，由于动画是被丢入了队列，动画会排队播放完毕后再播放下一个动画\r\n            // $(\"ul#demonwoefh945fj0e>li\").hover(function () {\r\n                // $(this).children(\"ul\").slideToggle(200)\r\n            // });\r\n        // stop()函数可以停止排队\r\n            $(\"ul#demonwoefh945fj0e>li\").hover(function () {\r\n                $(this).children(\"ul\").stop()\r\n                $(this).children(\"ul\").slideToggle(200)\r\n                // $(this).children(\"ul\").stop().slideToggle(200) //链式写法\r\n            }); \r\n    });\r\n</script>\r\n<ul id=\"demonwoefh945fj0e\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demonwoefh945fj0e,\r\n    ul#demonwoefh945fj0e *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demonwoefh945fj0e *::before,\r\n    ul#demonwoefh945fj0e *::after{\r\n        content: none;\r\n    }\r\n    ul#demonwoefh945fj0e{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demonwoefh945fj0e>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demonwoefh945fj0e>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demonwoefh945fj0e>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script>\r\n    $(function () {//DOMContentLoaded\r\n        //原先写法： 当鼠标在li之间快速移动时，由于动画是被丢入了队列，动画会排队播放完毕后再播放下一个动画\r\n            // $(\"ul#demonwoefh945fj0e>li\").hover(function () {\r\n                // $(this).children(\"ul\").slideToggle(200)\r\n            // });\r\n        // stop()函数可以停止排队\r\n            $(\"ul#demonwoefh945fj0e>li\").hover(function () {\r\n                $(this).children(\"ul\").stop()\r\n                $(this).children(\"ul\").slideToggle(200)\r\n                // $(this).children(\"ul\").stop().slideToggle(200) //链式写法\r\n            }); \r\n    });\r\n</script>\r\n<ul id=\"demonwoefh945fj0e\">\r\n    <li>\r\n        <a href=\"javascript:;\">目录1</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录2</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录3</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <a href=\"javascript:;\">目录4</a>\r\n        <ul>\r\n            <li><a href=\"JavaScript:;\">选项1</a></li>\r\n            <li><a href=\"JavaScript:;\">选项2</a></li>\r\n            <li><a href=\"JavaScript:;\">选项4</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n            <li><a href=\"JavaScript:;\">选项5</a></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n<style>\r\n    ul#demonwoefh945fj0e,\r\n    ul#demonwoefh945fj0e *{\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n    }\r\n    ul#demonwoefh945fj0e *::before,\r\n    ul#demonwoefh945fj0e *::after{\r\n        content: none;\r\n    }\r\n    ul#demonwoefh945fj0e{\r\n        display: inline-block;\r\n        height: 30px;\r\n        background-color: white;\r\n    }\r\n    ul#demonwoefh945fj0e>li{\r\n        position: relative;\r\n        float: left;\r\n        height: 100%;\r\n        /* background-color: red; */\r\n    }\r\n    ul#demonwoefh945fj0e>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demonwoefh945fj0e>li>a\r\n    {\r\n        display: inline-block;\r\n        padding: 0 25px;\r\n        height: 100%;\r\n        /* background-color: purple; */\r\n        text-align: center;\r\n        line-height: 30px;\r\n        font-size: 15px;\r\n        color: black;\r\n        text-decoration: none;\r\n        font-weight: bold;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        transform: translate(0,30px);\r\n        z-index: 999;\r\n        min-width: 200%;\r\n        background-color: white;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li{\r\n        width: 100%;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li:hover{\r\n        background-color: gray;\r\n    }\r\n    ul#demonwoefh945fj0e>li>ul>li>a{\r\n        /* display: none; */\r\n        display: inline-block;\r\n        width: 100%;\r\n        height: 30px;\r\n        line-height: 30px;\r\n        text-align: center;\r\n        text-decoration: none;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n</style>\r\n```\r\n\r\n## Jquery内容操作\r\n**设置/获取元素内容**\r\n* `jQueryObj.html()` 获取内容，相当于`element.innerHTML`\r\n* `jQueryObj.html(value)` 写入内容，相当于`element.innerHTML=value`\r\n\r\n**设置/获取元素文本**\r\n* `jQueryObj.text()` 获取内容，相当于`element.innerText`\r\n* `jQueryObj.text(value)` 写入内容，相当于`element.innerText=value`\r\n\r\n**设置/获取表单值**\r\n* `jQueryObj.val()` 获取内容，相当于`element.value`\r\n* `jQueryObj.val(value)` 写入内容，相当于`element.value=value`\r\n\r\n### 案例练习\r\n\r\n**增减商品数量**\r\n* 若要根据单价计算总价，如要保留两位小数，使用`value.toFixed(2)`函数\r\n\r\n\r\n<script>\r\n    $(document).ready(function(){\r\n        //按钮+\r\n        $(\"#demo2j4r20 > .box > .add\").click(function(){\r\n            var value = $(this).siblings(\".count\").val()\r\n            value++;\r\n            $(this).siblings(\".count\").val(value)\r\n            $(this).siblings(\".count\").text( value )\r\n            $(this).siblings(\"span\").text(value.toFixed(2))//测试\r\n        });\r\n        //按钮-\r\n        $(\"#demo2j4r20 > .box > .min\").click(function(){\r\n            var value = $(this).siblings(\".count\").val()\r\n            if(value>1){\r\n                value--;\r\n                $(this).siblings(\".count\").val(value)\r\n            }\r\n            $(this).siblings(\".count\").text( value )\r\n            $(this).siblings(\"span\").text(value.toFixed(2))//测试\r\n        });\r\n        //文本框输入\r\n        $(\"#demo2j4r20 > .box > .count\").keyup(function(){\r\n            var value =Number( $(this).val() )\r\n            if(typeof value == \"number\" && value>=1)//判断是否是数字,且大于1\r\n            {\r\n                $(this).val(value)\r\n                $(this).siblings(\"span\").text(value.toFixed(2))//测试\r\n            }else\r\n            {\r\n                $(this).val(1)\r\n                $(this).siblings(\"span\").text(\"1.00\")//测试\r\n            }\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demo2j4r20\">\r\n    <div class=\"box\" >\r\n        <button class=\"min\">-</button><input  class=\"count\" type=\"text\" value=\"1\"><button class=\"add\">+</button>\r\n        <br>当前值（保留两位小数测试）：<span>1.00</span>\r\n    </div>\r\n    <div class=\"box\">\r\n        <button class=\"min\">-</button><input  class=\"count\" type=\"text\" value=\"1\"><button class=\"add\">+</button>\r\n        <br>当前值（保留两位小数测试）：<span>1.00</span>\r\n    </div>\r\n</div>\r\n<style>\r\n    #demo2j4r20 .box button,\r\n    #demo2j4r20 .box .count{\r\n        display: inline-block;\r\n        padding: 0;\r\n        margin: 0;\r\n        height:25px;\r\n        line-height:25px;\r\n        border: 1px solid gray;\r\n        box-sizing: border-box;\r\n        outline: none;\r\n        text-align: center;\r\n        vertical-align: middle;\r\n        background-color: white;\r\n        color: black;\r\n    }\r\n    #demo2j4r20  .box button{\r\n        width:25px;\r\n        cursor: pointer;\r\n    }\r\n    #demo2j4r20  .box .count{\r\n        width: 40px;\r\n        background-color: whitesmoke;\r\n    }\r\n    #demo2j4r20  .box p{\r\n        width: 40px;\r\n    }\r\n</style>\r\n\r\n\r\n```html\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demo2j4r20> .box >.add\").click(function(){\r\n            var value = $(this).siblings(\".count\").val()\r\n            value++;\r\n            $(this).siblings(\".count\").val(value)\r\n            $(this).siblings(\".count\").text( value )\r\n            $(this).siblings(\"span\").text(value.toFixed(2))//测试\r\n        });\r\n        $(\"#demo2j4r20> .box>.min\").click(function(){\r\n            var value = $(this).siblings(\".count\").val()\r\n            if(value>1){\r\n                value--;\r\n                $(this).siblings(\".count\").val(value)\r\n            }\r\n            $(this).siblings(\".count\").text( value )\r\n            $(this).siblings(\"span\").text(value)//测试\r\n        });\r\n        $(\"#demo2j4r20>.count\").keyup(function(){\r\n            var value = $(this).val()\r\n            $(this).val(value)\r\n            $(this).siblings(\"span\").text(value)//测试\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demo2j4r20\">\r\n    <div class=\"box\" >\r\n        <button class=\"min\">-</button><input  class=\"count\" type=\"text\" value=\"1\"><button class=\"add\">+</button>\r\n        <br>当前值（保留两位小数测试）：<span>1.00</span>\r\n    </div>\r\n    <div class=\"box\">\r\n        <button class=\"min\">-</button><input  class=\"count\" type=\"text\" value=\"1\"><button class=\"add\">+</button>\r\n        <br>当前值（保留两位小数测试）：<span>1.00</span>\r\n    </div>\r\n</div>\r\n<style>\r\n    #demo2j4r20 .box button,\r\n    #demo2j4r20 .box .count{\r\n        display: inline-block;\r\n        padding: 0;\r\n        margin: 0;\r\n        height:25px;\r\n        line-height:25px;\r\n        border: 1px solid gray;\r\n        box-sizing: border-box;\r\n        outline: none;\r\n        text-align: center;\r\n        vertical-align: middle;\r\n        background-color: white;\r\n        color: black;\r\n    }\r\n    #demo2j4r20  .box button{\r\n        width:25px;\r\n        cursor: pointer;\r\n    }\r\n    #demo2j4r20  .box .count{\r\n        width: 40px;\r\n        background-color: whitesmoke;\r\n    }\r\n    #demo2j4r20  .box p{\r\n        width: 40px;\r\n    }\r\n</style>\r\n```\r\n\r\n## Jquery属性操作\r\n* `jQueryObj.prop(\"固有属性名\")` 获取属性值 类似原生js的 `element.内置属性名`\r\n* `jQueryObj.prop(\"固有属性名\",value)` 设置属性值 类似原生js的 `element.内置属性名=属性值`\r\n* `jQueryObj.attr(\"自定义属性名\")` 获取属性值 类似原生js的`getAttribute()`\r\n* `jQueryObj.attr(\"自定义属性名\",value)` 设置属性值 类似原生js的`setAttribute()`\r\n* `jQueryObj.data(\"键名\")` **数据缓存** 获取存放在dom对象中的键值 \r\n* `jQueryObj.data(\"键名\",键值)` **数据缓存** 设置存放在dom对象中的键值对 \r\n    * 注意这种方式的键值对不是存放在html标签中的，而是存储在标签的dom对象中的，且经测试，可以包含中划线，甚至是中文，\r\n    * 经测试data()无法获取到html标签的属性data-yearlyPlan,似乎不能支持大小写\r\n    * 这种方式也能获取data-index的属性值，data(\"index\")，且相比于getAttribute有一点不同，该函数能获取到数字的值\r\n    * `element.dataset[\"index\"]`这种方式获取到的是html标签中的data-index属性\r\n    * `jQueryObj.data(\"index\")` 这种方式获取到的是html标签的DOM对象中的data-index属性,也可以获取html标签中data-开头的属性\r\n\r\n\r\n**属性操作测试**\r\n\r\n<div id=\"demofwuf210\">\r\n    <a href=\"https://test1.com\">这里有一个固有属性href，其值为: </a>\r\n    <br>\r\n    <a index=\"测试2\">这里有一个自定义属性index，其值为: </a>\r\n    <br>\r\n    <a >该标签的DOM对象中存储了一个属性，其值为: </a>\r\n</div>\r\n<script>\r\n    $(\"#demofwuf210>a:eq(0)\")[0].innerText+=$(\"#demofwuf210>a:eq(0)\").prop(\"href\")\r\n    $(\"#demofwuf210>a:eq(1)\")[0].innerText+=$(\"#demofwuf210>a:eq(1)\").attr(\"index\")\r\n    $(\"#demofwuf210>a:eq(2)\").data(\"test3-中文\",\"测试3\")\r\n    $(\"#demofwuf210>a:eq(2)\")[0].innerText+=$(\"#demofwuf210>a:eq(2)\").data(\"test3-中文\")\r\n</script>\r\n\r\n```html\r\n<div id=\"demofwuf210\">\r\n    <a href=\"https://test1.com\">这里有一个固有属性href，其值为: </a>\r\n    <br>\r\n    <a index=\"测试2\">这里有一个自定义属性index，其值为: </a>\r\n    <br>\r\n    <a >该标签的DOM对象中存储了一个属性，其值为: </a>\r\n</div>\r\n<script>\r\n    $(\"#demofwuf210>a:eq(0)\")[0].innerText+=$(\"#demofwuf210>a:eq(0)\").prop(\"href\")\r\n    $(\"#demofwuf210>a:eq(1)\")[0].innerText+=$(\"#demofwuf210>a:eq(1)\").attr(\"index\")\r\n    $(\"#demofwuf210>a:eq(2)\").data(\"test3-中文\",\"测试3\")\r\n    $(\"#demofwuf210>a:eq(2)\")[0].innerText+=$(\"#demofwuf210>a:eq(2)\").data(\"test3-中文\")\r\n</script>\r\n```\r\n\r\n案例练习\r\n\r\n<script>\r\n    $(document).ready(function()\r\n    {\r\n        $(\"#demo2j3r0924>.checkAll\").change(function(){\r\n            //单选框的状态由全选框的状态决定\r\n            $(\"#demo2j3r0924>input\").prop(\"checked\",$(this).prop(\"checked\"))\r\n        })\r\n        $(\"#demo2j3r0924>.items\").change(function(){\r\n            //功能：所以单选框打钩后，将全选框也打钩，若有任何单选框为打钩，则全选框不打勾\r\n            //判断是否全部打钩\r\n            if($(\"#demo2j3r0924>.items:checked\").length== $(\"#demo2j3r0924>.items\").length)\r\n            {\r\n                //给全选框打钩\r\n                $(this).siblings(\".checkAll\").prop(\"checked\",true)\r\n            }else{\r\n                //给全选框取消打钩\r\n                $(this).siblings(\".checkAll\").prop(\"checked\",false)\r\n            }\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demo2j3r0924\">\r\n    全选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"checkAll\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    全选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"checkAll\"><br>\r\n</div>\r\n\r\n```html\r\n<script>\r\n    $(document).ready(function()\r\n    {\r\n        $(\"#demo2j3r0924>.checkAll\").change(function(){\r\n            //单选框的状态由全选框的状态决定\r\n            $(\"#demo2j3r0924>input\").prop(\"checked\",$(this).prop(\"checked\"))\r\n        })\r\n        $(\"#demo2j3r0924>.items\").change(function(){\r\n            //功能：所以单选框打钩后，将全选框也打钩，若有任何单选框为打钩，则全选框不打勾\r\n            //判断是否全部打钩\r\n            if($(\"#demo2j3r0924>.items:checked\").length== $(\"#demo2j3r0924>.items\").length)\r\n            {\r\n                //给全选框打钩\r\n                $(this).siblings(\".checkAll\").prop(\"checked\",true)\r\n            }else{\r\n                //给全选框取消打钩\r\n                $(this).siblings(\".checkAll\").prop(\"checked\",false)\r\n            }\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demo2j3r0924\">\r\n    全选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"checkAll\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    单选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"items\"><br>\r\n    全选：<input type=\"checkbox\" name=\"\" id=\"\" class=\"checkAll\"><br>\r\n</div>\r\n```\r\n\r\n\r\n\r\n## 元素操作\r\n\r\n### 遍历\r\n\r\n\r\n#### each()遍历\r\n* each遍历操作用于针对同一类元素做不同操作，类似for但又比for强大\r\n* each()的回调函数的**第一个参数是索引**，**第二个参数是元素的DOM对象**\r\n\r\n**例程**\r\n<div id=\"demownefu02\">\r\n    <div>1</div>\r\n    <div>2</div>\r\n    <div>3</div>\r\n    <div>4</div>\r\n    <div>5</div>\r\n    <div>6</div>\r\n    <div>7</div>\r\n    <div>8</div>\r\n    <div>9</div>\r\n    <div>10</div>\r\n</div>\r\n<script>\r\n    $(document).ready(function(){\r\n        function getColor(r,g,b)\r\n        {\r\n            return \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        }\r\n        $(\"#demownefu02>div\").each(function(index,DOMElementObj){\r\n            if(index%3==0)\r\n                $(DOMElementObj).css(\"background-color\",getColor(index*30,0,0))\r\n            else if(index%3==1)\r\n                $(DOMElementObj).css(\"background-color\",getColor(0,index*30,0))\r\n            else\r\n                $(DOMElementObj).css(\"background-color\",getColor(0,0,index*30))\r\n        })\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demownefu02\">\r\n    <div>1</div>\r\n    <div>2</div>\r\n    <div>3</div>\r\n    <div>4</div>\r\n    <div>5</div>\r\n    <div>6</div>\r\n    <div>7</div>\r\n    <div>8</div>\r\n    <div>9</div>\r\n    <div>10</div>\r\n</div>\r\n<script>\r\n    $(document).ready(function(){\r\n        function getColor(r,g,b)\r\n        {\r\n            return \"rgb(\" + r + \",\" + g + \",\" + b + \")\";\r\n        }\r\n        $(\"#demownefu02>div\").each(function(index,DOMElementObj){\r\n            if(index%3==0)\r\n                $(DOMElementObj).css(\"background-color\",getColor(index*30,0,0))\r\n            else if(index%3==1)\r\n                $(DOMElementObj).css(\"background-color\",getColor(0,index*30,0))\r\n            else\r\n                $(DOMElementObj).css(\"background-color\",getColor(0,0,index*30))\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n#### $.each()遍历\r\n* $.each()主要用于数据处理,遍历数组，对象\r\n* each()的第一个参数是待遍历的数据对象，第二个参数是回调函数，回调函数的**第一个参数是数据的索引**，**第二个参数数据的值**\r\n* 格式：$.each(遍历数据,function(index,DOMElementObj){})\r\n* 用处：可以用来遍历表单，获取关键值，做数据处理工作\r\n\r\n**遍历数据：遍历数组测试**\r\n<div id=\"demojfi02rjf0\"></div>\r\n<script>\r\n    var list=[\"DingYigui\",\"HaHaHa\",\"男\"];\r\n    $.each(list,function(index,value){\r\n        $(\"#demojfi02rjf0\").html($(\"#demojfi02rjf0\").html() + index + \":\" + value + \"<br>\" )\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demojfi02rjf0\"></div>\r\n<script>\r\n    var list=[\"DingYigui\",\"HaHaHa\",\"男\"];\r\n    $.each(list,function(index,value){\r\n        $(\"#demojfi02rjf0\").html($(\"#demojfi02rjf0\").html() + index + \":\" + value + \"<br>\" )\r\n    })\r\n</script>\r\n```\r\n\r\n**遍历数据：遍历对象测试**\r\n\r\n<div id=\"demojfi0123123dfw\"></div>\r\n<script>\r\n    var list={\r\n        \"键1\":\"值1\",\r\n        \"键2\":\"值2\",\r\n        \"键3（数组）\":[0,1,2],\r\n        \"键4（对象）\":{\r\n            \"1\":1,\r\n            \"2\":2\r\n        }\r\n    };\r\n    $.each(list,function(index,value){\r\n        $(\"#demojfi0123123dfw\").html($(\"#demojfi0123123dfw\").html() + index + \":\" + value + \"<br>\" )\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demojfi0123123dfw\"></div>\r\n<script>\r\n    var list={\r\n        \"键1\":\"值1\",\r\n        \"键2\":\"值2\",\r\n        \"键3（数组）\":[0,1,2],\r\n        \"键4（对象）\":{\r\n            \"1\":1,\r\n            \"2\":2\r\n        }\r\n    };\r\n    $.each(list,function(index,value){\r\n        $(\"#demojfi0123123dfw\").html($(\"#demojfi0123123dfw\").html() + index + \":\" + value + \"<br>\" )\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n### 创建、添加、删除元素\r\n\r\n* 创建元素： `var newjQueryObj = $(\"<div></div>\");`\r\n* 添加元素：\r\n    * 内部末尾附加：`jQueryObj.append(newjQueryObj);`\r\n    * 内部开头附加：`jQueryObj.prepend(newjQueryObj);`\r\n    * 外部之后附加：`jQueryObj.after(newjQueryObj);`\r\n    * 外部之前附加：`jQueryObj.before(newjQueryObj);`\r\n* 删除元素：\r\n    * 删除元素本身：`jQueryObj.remove();`\r\n    * 删除元素子集：`jQueryObj.remove(选择器表达式);`\r\n    * 删除元素内容：`jQueryObj.empty();`\r\n    * 删除元素内容：`jQueryObj.html(\"\");`\r\n    \r\n<div id=\"demo3je02\">\r\n\r\n</div>\r\n<script>\r\n    var newDiv = $(\"<div>1</div>\");\r\n    $(\"#demo3je02\").append(newDiv);\r\n    $(\"#demo3je02\").prepend(newDiv);\r\n    $(\"#demo3je02\").after(newDiv);\r\n    $(\"#demo3je02\").before(newDiv);\r\n    $(\"#demo3je02\").remove()\r\n</script>\r\n<style>\r\n    #demo3je02,\r\n    #demo3je02 *{\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n\r\n\r\n## jQuery尺寸及位置\r\n### jQuery尺寸\r\n\r\n**设置或获取jQuery尺寸：**\r\n* 参数为空时，作用为获取相应值，返回数字型，无单位\r\n* 参数为数时，作用为设置相应值，实参数字型，无单位\r\n* 方法\r\n    * `jQweryObj.width()` content\r\n    * `jQweryObj.height()` content\r\n    * `jQweryObj.innerWidth()` content+padding\r\n    * `jQweryObj.innerHeight()` content+padding\r\n    * `jQweryObj.outerWidth()` content+padding+border\r\n    * `jQweryObj.outerHeight()` content+padding+border\r\n    * `jQweryObj.outerWidth(true)` content+padding+border+margin\r\n    * `jQweryObj.outerHeight(true)` content+padding+border+margin\r\n\r\n![](./images/jQuery学习笔记/2022-07-13-06-16-23.png)\r\n\r\n### jQuery位置\r\n* `jQweryObj.offset()` 相对于**文档**的位置；\r\n    * 无参数返回的是对象，拥有top，left属性，数值型，无单位\r\n    * 有参数是设置,传入的是对象，`jQweryObj.offset({top:100,left:100})`\r\n* `jQweryObj.position()`  相对于有定位的父级，没有定位则相对于文档\r\n    * 该方法只能获取偏移值，不能设置\r\n* `jQweryObj.scrollTop()` 被卷去的顶部的高度\r\n    * 可以传入参数，设置被卷去的高度\r\n* `jQweryObj.scrollLeft()` 被卷去的左侧的宽度\r\n\r\n\r\n**页面滚动到指定位置后显示某元素**\r\n<div id=\"demofwuf0h9\" style=\"width: 200px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; color: black;\">\r\n    页面滚动到指定位置后显示测试\r\n</div>\r\n<script>\r\n    var offsetTop =  $(\"#demofwuf0h9\").offset().top\r\n    $(window).scroll(function(){\r\n        if($(this).scrollTop()>offsetTop-200)\r\n            $(\"#demofwuf0h9\").fadeIn()\r\n        else\r\n            $(\"#demofwuf0h9\").fadeOut()\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demofwuf0h9\" style=\"width: 100px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; color: black;\">\r\n    返回顶部\r\n</div>\r\n<script>\r\n    $(window).scroll(function(){\r\n        if($(this).scrollTop()>100)\r\n            $(\"#demofwuf0h9\").fadeIn()\r\n        else\r\n            $(\"#demofwuf0h9\").fadeOut()\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n**动态返回顶部按钮测试**\r\n* 利用animate方法中的scrollTop\r\n* 注意事件添加给body,html\r\n\r\n<div id=\"demofi2f0\" style=\"width: 100px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; color: black;\">\r\n    动态返回顶部\r\n</div>\r\n<script>\r\n    $(\"#demofi2f0\").click(function(){\r\n        // $(document).scrollTop(0) //返回顶部无动画版\r\n        $(\"html,body\").animate({scrollTop:0})\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demofi2f0\" style=\"width: 100px; height: 100px; background-color: skyblue; line-height: 100px; text-align: center; color: black;\">\r\n    动态返回顶部\r\n</div>\r\n<script>\r\n    $(\"#demofi2f0\").click(function(){\r\n        // $(document).scrollTop(0) //返回顶部无动画版\r\n        $(\"html,body\").animate({scrollTop:0})\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n<!-- **电梯导航** -->\r\n<!-- <div id=\"demof82040\"></div>\r\n<script>\r\n    function getItems(selector){\r\n        var ul = $(\"<ul></ul>\" )\r\n        $(selector).each(function(index,DOMelement){\r\n            var li = $(\"<li></li>\" )\r\n            ul.append( $(DOMelement).text() )\r\n        });\r\n        return ul;\r\n    }\r\n    var ul = $(\"<ul></ul>\" )\r\n    // var currentTagName = \r\n        $(\"h1,h2,h3,h4,h5,h6\").each(function(index,DOMelement){\r\n            if(DOMelement.tagName<=currentTagName)\r\n            {\r\n                var li = $(\"<li></li>\" )\r\n            }\r\n\r\n            ul.append( $(DOMelement).text() )\r\n        });\r\n    $(\"#demof82040\").append(ul)\r\n</script> -->\r\n\r\n## JQuery事件\r\n\r\n### 事件注册\r\n```js\r\njQueryObj.事件名(function(){事件处理程序})\r\n```\r\n\r\n### 事件解绑\r\n* `jQueryObj.off()` 解绑所有事件处理程序\r\n* `jQueryObj.off(\"click\")` 解绑所有click事件处理程序\r\n* `jQueryObj.off(\"click\",\"li\")` 解绑对li的click事件委托\r\n* 对于想只触发一次的事件后就解绑的事件，可用one()方法来绑定\r\n\r\n### 事件处理\r\n* `on()`方法可在元素上为**多个事件**绑定事件处理处理函数\r\n* 优点\r\n    * 多个事件可共用一个事件处理函数\r\n    * 可分别为不同事件指定事件处理函数\r\n    * 该方法对于绑定事件之后动态创建的元素仍然生效\r\n\r\n* 语法： `jQueryObj.on(events,[selector],callback)`\r\n    * `events` 一个或多个用空格分隔的事件类型\r\n    * `selector` 元素的子元素选择器\r\n    * `callback` 回调函数\r\n* `on()`方法 对应老版本的`bind()` `live()` `delegate()`方法\r\n\r\n**多个事件共用一个事件处理函数**\r\n```js\r\njQueryObj.on(\"mouseenter click mouseleave\",function(){\r\n    //do someting\r\n})\r\n```\r\n\r\n**分别为不同事件指定事件处理函数**\r\n```js\r\njQueryObj.on({\r\n    mouseenter:function(){\r\n        //do someting \r\n    }\r\n    mouseleave:function(){\r\n        //do someting \r\n    }\r\n})\r\n```\r\n\r\n**事件委派**\r\n```js\r\n$(\"ul\").on(\"click\",\"li\",function(){\r\n    // do someting\r\n})\r\n```\r\n\r\n\r\n### 触发事件\r\n* `jQueryObj.事件名()`\r\n    * 会触发元素的默认行为\r\n    * 默认行为：如表单获取焦点后会有光标闪烁\r\n* `jQueryObj.trigger(\"事件名\")`\r\n    * 会触发元素的默认行为\r\n* `jQueryObj.triggerHandler(\"事件名\")` \r\n    * 不会触发元素的默认行为\r\n\r\n### 事件对象\r\n* event就是事件对象\r\n* 阻止默认行为：\r\n    * event.preventDefault()\r\n    * return false\r\n* 阻止冒泡：\r\n    * event.stopPropagation()\r\n```js\r\n$(\"ul\").on(\"click\",\"li\",function(event){\r\n    // do someting\r\n})\r\n```\r\n\r\n\r\n### 案例测试\r\n\r\n**事件委派测试：留言板删除键**\r\n\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demov92wufh9>div>button\").click(function(){\r\n            var text = $(this).siblings(\"textarea\").val()\r\n            if(text!=\"\")\r\n            {\r\n                var newLi = $(\"<li></li>\")\r\n                newLi.html(text+ \"<button>删除</button>\")\r\n                newLi.hide()\r\n                $(\"#demov92wufh9 > ul\").prepend(newLi)\r\n                newLi.slideDown()\r\n                $(this).siblings(\"textarea\").val(\"\")\r\n            }\r\n        })\r\n        $(\"#demov92wufh9>ul\").on(\"click\",\"button\",function(){\r\n            $(this).parent().slideUp(function(){\r\n                $(this).remove()\r\n            })\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demov92wufh9\">\r\n    <div>\r\n        <textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"></textarea><button>发布</button>\r\n    </div>\r\n    <ul>\r\n        <li>测试文字1<button>删除</button></li>\r\n        <li>测试文字2<button>删除</button></li>\r\n        <li>测试文字3<button>删除</button></li>\r\n        <li>测试文字4<button>删除</button></li>\r\n    </ul>\r\n</div>\r\n<style>\r\n     #demov92wufh9 *::after,\r\n     #demov92wufh9 *::before{\r\n        content: none;\r\n        display: none;\r\n     }\r\n    #demov92wufh9 *{\r\n        border: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        box-sizing: border-box;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n    #demov92wufh9{\r\n        width: 100%;\r\n        height: 500px;\r\n        background-color: skyblue;\r\n    }\r\n    #demov92wufh9 textarea{\r\n        margin: 0 auto;\r\n        width: 90%;\r\n        height: 50px;\r\n        outline: none;/*边线不显示*/\r\n        resize: none;/*禁止拉伸*/\r\n        border: none;\r\n        vertical-align: top;\r\n    }\r\n    #demov92wufh9 > div >button{\r\n        display: inline-block;\r\n        width: 10%;\r\n        height: 50px;\r\n        vertical-align: top;\r\n        border: none;\r\n        background-color: whitesmoke;\r\n        font-size: 15px;\r\n    }\r\n    #demov92wufh9 ul{\r\n        width: 100%;\r\n    }\r\n    #demov92wufh9 li{\r\n        position: relative;\r\n        margin: 10px;\r\n        margin-bottom: 0;\r\n        padding-bottom: 20px;\r\n        /* min-height: 50px; */\r\n        background-color: white;\r\n    }\r\n    #demov92wufh9 > ul>li >button{\r\n        display: inline-block;\r\n        position: absolute;\r\n        bottom: 0;\r\n        right: 0;\r\n        width: 40px;\r\n        height: 20px;\r\n        font-size: 10px;\r\n        background-color: whitesmoke;\r\n    }\r\n</style>\r\n\r\n```html\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#demov92wufh9>div>button\").click(function(){\r\n            var text = $(this).siblings(\"textarea\").val()\r\n            if(text!=\"\")\r\n            {\r\n                var newLi = $(\"<li></li>\")\r\n                newLi.html(text+ \"<button>删除</button>\")\r\n                newLi.hide()\r\n                $(\"#demov92wufh9 > ul\").prepend(newLi)\r\n                newLi.slideDown()\r\n                $(this).siblings(\"textarea\").val(\"\")\r\n            }\r\n        })\r\n        $(\"#demov92wufh9>ul\").on(\"click\",\"button\",function(){\r\n            $(this).parent().slideUp(function(){\r\n                $(this).remove()\r\n            })\r\n        })\r\n    })\r\n</script>\r\n<div id=\"demov92wufh9\">\r\n    <div>\r\n        <textarea name=\"\" id=\"\" cols=\"30\" rows=\"10\"></textarea><button>发布</button>\r\n    </div>\r\n    <ul>\r\n        <li>测试文字1<button>删除</button></li>\r\n        <li>测试文字2<button>删除</button></li>\r\n        <li>测试文字3<button>删除</button></li>\r\n        <li>测试文字4<button>删除</button></li>\r\n    </ul>\r\n</div>\r\n<style>\r\n     #demov92wufh9 *::after,\r\n     #demov92wufh9 *::before{\r\n        content: none;\r\n        display: none;\r\n     }\r\n    #demov92wufh9 *{\r\n        border: none;\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        box-sizing: border-box;\r\n        color: black;\r\n        font-size: 15px;\r\n    }\r\n    #demov92wufh9{\r\n        width: 100%;\r\n        height: 500px;\r\n        background-color: skyblue;\r\n    }\r\n    #demov92wufh9 textarea{\r\n        margin: 0 auto;\r\n        width: 90%;\r\n        height: 50px;\r\n        outline: none;/*边线不显示*/\r\n        resize: none;/*禁止拉伸*/\r\n        border: none;\r\n        vertical-align: top;\r\n    }\r\n    #demov92wufh9 > div >button{\r\n        display: inline-block;\r\n        width: 10%;\r\n        height: 50px;\r\n        vertical-align: top;\r\n        border: none;\r\n        background-color: whitesmoke;\r\n        font-size: 15px;\r\n    }\r\n    #demov92wufh9 ul{\r\n        width: 100%;\r\n    }\r\n    #demov92wufh9 li{\r\n        position: relative;\r\n        margin: 10px;\r\n        margin-bottom: 0;\r\n        padding-bottom: 20px;\r\n        /* min-height: 50px; */\r\n        background-color: white;\r\n    }\r\n    #demov92wufh9 > ul>li >button{\r\n        display: inline-block;\r\n        position: absolute;\r\n        bottom: 0;\r\n        right: 0;\r\n        width: 40px;\r\n        height: 20px;\r\n        font-size: 10px;\r\n        background-color: whitesmoke;\r\n    }\r\n</style>\r\n```\r\n\r\n## jQuery拷贝\r\n* 语法：`$.extend([deep],target,object1,[objectN])`\r\n* extend有合并的意思\r\n* deep: true or false是否为深拷贝\r\n* target：要拷贝到的目标对象\r\n* object1：待拷贝的对象1\r\n\r\n```js\r\nvar tempA = {\r\n    id:0,           //浅拷贝时将被覆盖\r\n    msg:{           //浅拷贝时整个对象将被覆盖\r\n        index:20    //深拷贝时，index将被保留 表现为合并对象\r\n    }\r\n}\r\nvar tempB = {\r\n    id:1,\r\n    name:\"string\",  //name是简单数据类型\r\n    msg:{           //msg是一个复杂数据类型，浅拷贝时仅拷贝地址\r\n        age:18\r\n    }\r\n}\r\n$.extend(tempA,tempB);\r\nconsole.log(tempA)\r\n```\r\n\r\n## 多库共存\r\n当使用的其他js库中也使用了$符号时，就会造成标识符的冲突\r\n\r\n**解决方案**\r\n\r\n* 若是因为`$`符号导致的冲突，则可以使用标识符`jQuery`来代替\r\n* 若标识符`JQuery`仍然冲突，则可使用`var 自定义标识符 = jQuery.noConflict()` 来定义\r\n\r\n## jquery插件\r\n[jQuery插件库](http://www.jq22.com)  \r\n[jQuery之家](http://www.htmleaf.com)\r\n\r\n* 瀑布流\r\n* 懒惰加载EasyLazyload\r\n* 全屏滚动fullpage.js\r\n\r\n瀑布流\r\n![](./images/jQuery学习笔记/2022-07-13-17-13-17.png)\r\n\r\n\r\n```html\r\n<script src=\"_js/jQuery.js\"></script>\r\n<script src=\"_PinterestGrid/js/pinterest_grid.js\"></script>\r\n<script>\r\n    $(document).ready(function(){\r\n        $(\"#gallery-wrapper\").pinterest_grid({\r\n\t\t\t\tno_columns: 4,\r\n                padding_x: 10,\r\n                padding_y: 10,\r\n                margin_bottom: 50,\r\n                single_column_breakpoint: 700\r\n\t\t\t});\r\n    })\r\n</script>\r\n<section id=\"gallery-wrapper\">\r\n    <article class=\"white-panel\"> \r\n      <img src=\"./_PinterestGrid/img/1.jpg\" alt=\"...\">\r\n      <h1><a href=\"#\">Title 1</a></h1>\r\n      <p>Description 1</p>\r\n    </article>\r\n    <article class=\"white-panel\"> \r\n      <img src=\"./_PinterestGrid/img/2.jpg\" alt=\"...\">\r\n      <h1><a href=\"#\">Title 2</a></h1>\r\n      <p>Description 2</p>\r\n    </article>\r\n    <article class=\"white-panel\"> \r\n        <img src=\"./_PinterestGrid/img/3.jpg\" alt=\"...\">\r\n        <h1><a href=\"#\">Title 3</a></h1>\r\n        <p>Description 3</p>\r\n      </article>\r\n      <article class=\"white-panel\"> \r\n        <img src=\"./_PinterestGrid/img/4.jpg\" alt=\"...\">\r\n        <h1><a href=\"#\">Title 3</a></h1>\r\n        <p>Description 3</p>\r\n      </article>\r\n      <article class=\"white-panel\"> \r\n        <img src=\"./_PinterestGrid/img/5.jpg\" alt=\"...\">\r\n        <h1><a href=\"#\">Title 3</a></h1>\r\n        <p>Description 3</p>\r\n      </article>\r\n      <article class=\"white-panel\"> \r\n        <img src=\"./_PinterestGrid/img/6.jpg\" alt=\"...\">\r\n        <h1><a href=\"#\">Title 3</a></h1>\r\n        <p>Description 3</p>\r\n      </article>\r\n  </section>  \r\n<style>\r\n    #gallery-wrapper {\r\n        position: relative;\r\n        max-width: 100%;\r\n        width: 100%;\r\n    }\r\n    img.thumb {\r\n        width: 100%;\r\n        max-width: 100%;\r\n        height: auto;\r\n    }\r\n    .white-panel {\r\n        position: absolute;\r\n        background: white;\r\n        border-radius: 5px;\r\n        box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3);\r\n        padding: 10px;\r\n    }\r\n    .white-panel h1 {\r\n        font-size: 1em;\r\n    }\r\n    .white-panel h1 a {\r\n        color: #A92733;\r\n    }\r\n    .white-panel:hover {\r\n        box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5);\r\n        margin-top: -5px;\r\n        -webkit-transition: all 0.3s ease-in-out;\r\n        -moz-transition: all 0.3s ease-in-out;\r\n        -o-transition: all 0.3s ease-in-out;\r\n        transition: all 0.3s ease-in-out;\r\n    }\r\n</style>\r\n```\r\n\r\n![](./images/jQuery学习笔记/2022-07-13-18-26-32.png)\r\n```html\r\n<img data-lazy-src=\"/images/jQuery学习笔记/2022-07-13-18-26-32.png\" />\r\n<img data-lazy-src=\"/images/jQuery学习笔记/2022-07-13-18-26-32.png\" />\r\n<img data-lazy-src=\"/images/jQuery学习笔记/2022-07-13-18-26-32.png\" />\r\n<script src=\"./_EasyLazyload/EasyLazyload.js\"></script>\r\n<script>\r\n    lazyLoadInit({\r\n        coverColor:\"white\",\r\n        coverDiv:\"<h1>test</h1>\",\r\n        offsetBottom:0,\r\n        offsetTopm:0,\r\n        showTime:1100,\r\n        onLoadBackEnd:function(i,e){\r\n            console.log(\"onLoadBackEnd:\"+i);\r\n        }\r\n        ,onLoadBackStart:function(i,e){\r\n            console.log(\"onLoadBackStart:\"+i);\r\n        }\r\n    });\r\n</script>\r\n```\r\n \r\n\r\n## 元素的缓存数据\r\n\r\n实际使用过程中碰到的问题，这里记录一下\r\n\r\n* 键名相同会覆盖，以下两个元素对象不同，但其键名相同，键值会覆盖\r\n    * jQueryElementObj1.data(\"键名\",键值)\r\n    * jQueryElementObj2.data(\"键名\",键值2)\r\n* 键名相同不覆盖，以下两个元素对象不同，但其键名相同，键值不会覆盖\r\n    * $.data(element,\"键名\",键值)\r\n    * $.data(element,\"键名\",键值2)\r\n* 使用深拷贝$.extend()函数时，由于克隆的整个元素，所以也能够访问键值，但拷贝前的元素remove()后，深拷贝的元素也将不存在\r\n* jquery.clone() 函数无法克隆元素的缓存数据\r\n\r\n\r\n克隆元素同时克隆缓存数据的方法：\r\n\r\n```\r\n// 方法1：\r\nnewObj.data(oldObj.data()) //这种方式对于ele.data(\"key\",value) 或 ele.data({\"key\":value}) 方式设置的数据生效\r\n\r\n//方法2：\r\n// $.data(DOMelement,key,value) // 设置键值\r\n// $.data(DOMelement,key) // 获取键值\r\n// $.data(DOMelement) // 获取一个包含所有键值对的js对象,jQuery内部自身使用这个方法来绑定数据,所以这类数据也包含在其中，\r\n\r\n// 所以这种方法只能使用指定键名的方式重新设置值，因为键名是不可省略的参数\r\n$.data(oldObj,key,$.data(oldObj,key))\r\n\r\n```\r\n"},{"shortInfo":{"title":"jsWebApis学习笔记之BOM","date":"2022-07-03T16:19:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["JavaScript","WebApis","BOM","DOM","前端"],"hideAtIndex":true,"categories":"笔记","id":24,"countWords":2629,"readSeconds":262.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# jsWebApis学习笔记之BOM\r\n\r\n## 目录\r\n- [jsWebApis学习笔记之BOM](#jswebapis学习笔记之bom)\r\n  - [目录](#目录)\r\n  - [概述](#概述)\r\n  - [window对象构成：](#window对象构成)\r\n  - [window对象事件](#window对象事件)\r\n  - [定时器](#定时器)\r\n    - [倒计时案例](#倒计时案例)\r\n    - [发送短信按钮案例](#发送短信按钮案例)\r\n  - [this指向问题](#this指向问题)\r\n  - [js执行机制](#js执行机制)\r\n    - [原来存在的问题](#原来存在的问题)\r\n    - [新标准](#新标准)\r\n  - [window的location对象](#window的location对象)\r\n    - [URL](#url)\r\n  - [window.navigator对象](#windownavigator对象)\r\n  - [window.history对象](#windowhistory对象)\r\n\r\n## 概述\r\n* BOM(Browser Object Model浏览器对象模型)\r\n* 提供了**与浏览器窗口进行交互的对象**，\r\n* 核心对象是`window`\r\n* **BOM最初是Netscape浏览器标准的一部分**\r\n* BOM是浏览器厂商在各自浏览器上定义的，兼容性差\r\n    * alert() 在不同的浏览器有不同的外观\r\n\r\n## window对象构成：\r\n* **DOM是BOM的一部分**\r\n![](./images/jsWebApis学习笔记之BOM/2022-07-07-07-45-10.png)\r\n\r\n* window对象是浏览器**顶级对象**，有双重角色\r\n    * 它是**js访问浏览器窗口的API**\r\n    * 它是全局对象，**定义在全局作用域的变量函数都会变成window对象的属性和方法**\r\n    * **在调用时可以省略`window.`**\r\n        * `window.alert()`  和  `alert()` \r\n        * `window.prompt()`  和  `prompt()`\r\n\r\n## window对象事件\r\n* `window.onload`是窗口（页面）加载事件，**当文档内容（图像，脚本，CSS等）完全加载完毕后触发**\r\n    <script>\r\n    //通过window.onload事件，可以把js代码写在元素代码之前\r\n    window.addEventListener(\"load\",function(){\r\n        var demoButtonwoefjwe93 = document.querySelector(\"#demoButtonwoefjwe93\")\r\n        demoButtonwoefjwe93.addEventListener(\"click\",function(){\r\n        window.alert(\"页面加载完毕：点击了按钮\")\r\n        })\r\n    })\r\n    </script>\r\n    <button id=\"demoButtonwoefjwe93\">测试</button>\r\n\r\n    ```html\r\n    <script>\r\n    //通过window.onload事件，可以把js代码写在元素代码之前\r\n    window.addEventListener(\"load\",function(){\r\n        var demoButtonwoefjwe93 = document.querySelector(\"#demoButtonwoefjwe93\")\r\n        demoButtonwoefjwe93.addEventListener(\"click\",function(){\r\n        window.alert(\"页面加载完毕：点击了按钮\")\r\n        })\r\n    })\r\n    </script>\r\n    <button id=\"demoButtonwoefjwe93\">测试</button>\r\n    ```\r\n\r\n* `window.onDOMContentLiaded` **DOM内容（html元素）加载完毕后触发的事件**，在CSS、图片 flash加载前触发，如果页面中图片很多，那么onload事件触发就要等很久，而该事件就不用\r\n\r\n* `window.onresize` 浏览器窗口调整后触发的事件，常配合`window.innerWidth`属性来做响应式布局\r\n\r\n\r\n\r\n## 定时器\r\n* `window.setTimeout(回调函数,[延迟毫秒数])` 用来延迟执行某个函数 **先延迟后执行**\r\n    * 回调函数的几种写法\r\n        * 匿名函数\r\n        * 函数名\r\n        * '函数名()'\r\n    * 延迟毫秒数不填默认为0\r\n    * 返回值，定时器ID\r\n    * `window.clearTimeout(定时器ID)`清除定时器\r\n* `window.setInterval(回调函数,[延迟毫秒数])` 用来**循环**延迟执行某个函数 **先延迟后执行**\r\n    * `window.clearInterval(定时器ID)`清除定时器\r\n\r\n### 倒计时案例\r\n\r\n<div id=\"demoJOIJE123\">\r\n    <span id=\"hh\">00</span>\r\n    <span id=\"mm\">00</span>\r\n    <span id=\"ss\">00</span>\r\n</div>\r\n<style>\r\n    #demoJOIJE123 span{\r\n        display: inline-block;\r\n        margin: 0 5px;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        color: white;\r\n        font-size: 40px;\r\n        line-height: 50px;        \r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n    var hh=document.querySelector(\"#hh\")\r\n    var mm=document.querySelector(\"#mm\")\r\n    var ss=document.querySelector(\"#ss\")\r\n    var targetTime =+new Date(\"9922-07-04T04:45:00\")//设置目标时间\r\n    updateTime()//防止刷新页面后要等1秒才更新倒计时\r\n    var timeDown = setInterval(updateTime,1000)\r\n    function updateTime(){\r\n        var now =+new Date();\r\n        var gap = targetTime - now;\r\n        if(gap<0)\r\n        {\r\n            gap = 0;//防止出现负号\r\n            clearInterval(timeDown)\r\n        }\r\n        var h = parseInt(gap/1000/60/60%24)\r\n        var m = parseInt(gap/1000/60%60)\r\n        var s = parseInt(gap/1000%60)\r\n        h = h<10? \"0\"+h:h\r\n        m = m<10? \"0\"+m:m\r\n        s = s<10? \"0\"+s:s\r\n        hh.innerText=h\r\n        mm.innerText=m\r\n        ss.innerText=s\r\n    }\r\n</script>\r\n\r\n\r\n```html\r\n<div id=\"demoJOIJE123\">\r\n    <span id=\"hh\">00</span>\r\n    <span id=\"mm\">00</span>\r\n    <span id=\"ss\">00</span>\r\n</div>\r\n<style>\r\n    #demoJOIJE123 span{\r\n        display: inline-block;\r\n        margin: 0 5px;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        color: white;\r\n        font-size: 40px;\r\n        line-height: 50px;        \r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n    var hh=document.querySelector(\"#hh\")\r\n    var mm=document.querySelector(\"#mm\")\r\n    var ss=document.querySelector(\"#ss\")\r\n    var targetTime =+new Date(\"9922-07-04T04:45:00\")//设置目标时间\r\n    updateTime()//防止刷新页面后要等1秒才更新倒计时\r\n    var timeDown = setInterval(updateTime,1000)\r\n    function updateTime(){\r\n        var now =+new Date();\r\n        var gap = targetTime - now;\r\n        if(gap<0)\r\n        {\r\n            gap = 0;//防止出现负号\r\n            clearInterval(timeDown)\r\n        }\r\n        var h = parseInt(gap/1000/60/60%24)\r\n        var m = parseInt(gap/1000/60%60)\r\n        var s = parseInt(gap/1000%60)\r\n        h = h<10? \"0\"+h:h\r\n        m = m<10? \"0\"+m:m\r\n        s = s<10? \"0\"+s:s\r\n        hh.innerText=h\r\n        mm.innerText=m\r\n        ss.innerText=s\r\n    }\r\n</script>\r\n```\r\n\r\n### 发送短信按钮案例\r\n\r\n<div id=\"demoInput12381039\">\r\n    <input type=\"text\" name=\"\" id=\"\"><button>发送</button>\r\n</div>\r\n<style>\r\n    #demoInput12381039 * {\r\n        box-sizing: border-box;\r\n        padding: 0;\r\n        margin: 0;\r\n        height: 25px;\r\n        padding: 0 5px;\r\n        vertical-align: middle;\r\n    }\r\n</style>\r\n<script>\r\n    var btn=document.querySelector(\"#demoInput12381039>button\")\r\n    var ipt=document.querySelector(\"#demoInput12381039>input\")\r\n    btn.addEventListener(\"click\",function(){\r\n        if(ipt.value){//检查输入框是否满足要求\r\n            btn.disabled=true; //禁用\r\n            var ss = 5; //倒计时\r\n            callback(); //先显示一次\r\n            var timmer = setInterval(callback,1000);\r\n            function callback(){//回调函数\r\n                btn.innerText = \"再次发送需等待\" + ss + \"秒\";\r\n                if(ss--<0){\r\n                    clearInterval(timmer);\r\n                    btn.innerText = \"发送\";\r\n                    btn.disabled = false;\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n\r\n```html\r\n<div id=\"demoInput12381039\">\r\n    <input type=\"text\" name=\"\" id=\"\"><button>发送</button>\r\n</div>\r\n<style>\r\n    #demoInput12381039 * {\r\n        box-sizing: border-box;\r\n        padding: 0;\r\n        margin: 0;\r\n        height: 25px;\r\n        padding: 0 5px;\r\n        vertical-align: middle;\r\n    }\r\n</style>\r\n<script>\r\n    var btn=document.querySelector(\"#demoInput12381039>button\")\r\n    var ipt=document.querySelector(\"#demoInput12381039>input\")\r\n    btn.addEventListener(\"click\",function(){\r\n        if(ipt.value){//检查输入框是否满足要求\r\n            btn.disabled=true; //禁用\r\n            var ss = 5; //倒计时\r\n            callback(); //先显示一次\r\n            var timmer = setInterval(callback,1000);\r\n            function callback(){//回调函数\r\n                btn.innerText = \"再次发送需等待\" + ss + \"秒\";\r\n                if(ss--<0){\r\n                    clearInterval(timmer);\r\n                    btn.innerText = \"发送\";\r\n                    btn.disabled = false;\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n## this指向问题\r\n\r\n全局作用域或普通函数中的this指向window对象\r\n```js\r\nconsole.log(this)//输出window \r\n//----------------------------------------------------//\r\nfunction test1(){\r\n    console.log(this)//输出window \r\n}\r\ntest1(); //相当于是window.test1();\r\n//----------------------------------------------------//\r\nwindow.setInterval(function(){\r\n    console.log(this) //输出window\r\n},1000)\r\n```\r\n\r\n对象的方法中的this指向调用者，也就是这个对象本身\r\n```js\r\nvar obj={\r\n    test2:function(){\r\n        console.log(this)//输出obj\r\n    }\r\n}\r\nobj.test2();\r\n//----------------------------------------------------//\r\nvar btn = document.querySelector(\"bhtton\");\r\nbtn.onclick = function(){\r\n    console.log(this);//输出btn对象 ,相当于在触发click事件后会自动调用btn.onclick();函数\r\n};\r\nbtn.addEventListener(\"click\",function(){\r\n    console.log(this);//输出btn对象\r\n});\r\n//----------------------------------------------------//\r\n```\r\n\r\n构造函数中的this指向返回的实例化后的对象\r\n```js\r\nfunction Obj(){\r\n    console.log(this);\r\n}\r\nvar obj1 = new Obj(); //控制台打印输出obj1\r\nvar obj2 = new Obj(); //控制台打印输出obj2\r\n```\r\n\r\nthis的指向是可以更改的\r\n\r\n\r\n## js执行机制\r\n### 原来存在的问题\r\n* js语言的特点是单线程，同时只能做一件事\r\n* 单线程的特点由js诞生的使命造成，js是为了处理页面交互，DOM的增删改。\r\n* 单线程意味着所有任务需要排队，前一个执行完毕才能执行下一个\r\n* 单线程的问题是，当单个任务耗费时间较长时会造成任务队列的堵塞\r\n\r\n### 新标准\r\n为了解决这样的问题，HTML5提出了Web Worker标准，允许js创建多个线程，利用多核cpu的计算能力，于是js中出现了同步和异步的概念\r\n\r\n* 同步任务: 同步任务都在主线程上执行，形成一个**执行栈**\r\n\r\n* 异步任务  \r\n    * js异步是通过回调函数实现  \r\n    * 回调函数会被添加到**任务队列**（消息队列）\r\n    * 异步任务一般分三类\r\n        * 普通事件：click resize 等\r\n        * 资源加载：load error 等\r\n        * 定时器： setInterval() setTimeout() 等\r\n\r\n* 执行机制\r\n    * 0.先执行**执行栈**中的同步任务\r\n    * 1.碰到异步任务则将其提交给对应的**异步进程处理程序**\r\n        * **异步进程处理程序**在事件触发、定时器等到、ajax返回后，将相应的异步任务放入**任务队列**中\r\n    * 3.等到同步任务执行完毕后，再到**任务队列**中查询是否有任务，如果有，就取出一个放入**执行栈**处理\r\n    * 1->2->3 称之为**事件循环**\r\n![](./images/jsWebApis学习笔记之BOM/2022-07-07-08-15-13.png)\r\n\r\n案例\r\n* 输出顺序为`1`->`2` 但`3`和`click`的顺序不定，主要看回调函数被添加到任务队列的顺序，该顺序由延迟时间，click时间发生的时间共同觉得\r\n* ![](./images/jsWebApis学习笔记之BOM/2022-07-07-08-30-54.png)\r\n\r\n## window的location对象\r\nlocation对象**属性**\r\n* `location.href` **获取或设置整个url**\r\n* `location.host` 返回域名 `www.baidu.com`\r\n* `location.hostname` 返回域名 `www.baidu.com`\r\n* `location.port` 返回端口号，默认为空字符串 `\"\"` \r\n* `location.pathname` 路径 `/index.html`\r\n* `location.search` **参数**  `?name=andy&age=18`\r\n* `location.hash` #片段 `#锚点名`\r\n\r\nlocation对象**方法**\r\n* location.assign() 和herf一样可以跳转页面，也称重定向页面 ，记录历史记录\r\n* location.replace() 替换当前页面，不记录历史记录，不能后退页面\r\n* location.reload() 重新加载页面，\r\n    * 参数为空或false时，相当于刷新或f5（使用缓存）  \r\n    * 参数为true则相当于ctrl+f5强制刷新页面（不使用缓存，而直接从服务器重新获取数据）\r\n\r\n\r\n### URL\r\n* 格式：`传输协议://域名或ip[:端口][/地址][?查询键值对][#片段]`\r\n* 示例：`https://www.baidu.com:80/index.html?wd=搜索内容`\r\n    * protocol 通信协议，http ftp maito\r\n    * host 主机，域名或ip地址\r\n    * port 端口，省略时使用协议的默认端口，如http是80端口\r\n    * path 路径，表示一个目录或文件\r\n    * query 参数,以键值对形式，通过&符号分隔，如`?name=andy&age=18`\r\n    * fragment 片段 `#锚点名` 常见于链接、锚点\r\n\r\n\r\n\r\n\r\n<button id=\"demoOHf9we8\">点击跳转到百度</button>\r\n<script>\r\n    var demoOHf9we8 = document.querySelector(\"#demoOHf9we8\")\r\n    demoOHf9we8.addEventListener(\"click\",function(){\r\n        var ss = 5;\r\n        reflash();\r\n        var timer = setInterval(reflash,1000)\r\n        function reflash(){\r\n            demoOHf9we8.innerText=\"即将在\"+ ss +\"秒后跳转到百度\";\r\n            if(ss--<=0)\r\n            {\r\n                clearInterval(timer)\r\n                location.href=\"https://baidu.com\"\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n```html\r\n<button id=\"demoOHf9we8\">点击跳转到百度</button>\r\n<script>\r\n    var demoOHf9we8 = document.querySelector(\"#demoOHf9we8\")\r\n    demoOHf9we8.addEventListener(\"click\",function(){\r\n        var ss = 5;\r\n        reflash();\r\n        var timer = setInterval(reflash,1000)\r\n        function reflash(){\r\n            if(ss>0)\r\n            {\r\n                demoOHf9we8.innerText=\"即将在\"+ ss +\"秒后跳转到百度\";\r\n                ss--;\r\n            }\r\n            else\r\n            {\r\n                clearInterval(timer)\r\n                location.href=\"https://baidu.com\";\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n将一个页面的数据送到另一个页面\r\n\r\n```html\r\n//login.html\r\n\r\n//form默认get\r\n<form action=\"index.html\">\r\n    用户名：<input type=\"text\" name=\"username\" ><input type=\"submit\" value=\"登录\">\r\n</form>\r\n```\r\n\r\n```html\r\n//index.html\r\n\r\n<p id=\"demowenwfj9230\"></p>\r\n<script>\r\n    var demowenwfj9230 = document.querySelector(\"#demowenwfj9230\") \r\n    var list = location.search.substr(1).split(\"=\")//去除？后再根据=分隔为数组\r\n    var uname = list[1]\r\n    demowenwfj9230.innerHTML=\"欢迎你，\" + uname\r\n</script>\r\n```\r\n\r\n## window.navigator对象\r\n常用属性\r\n* `navigator.userAgent` 可获取客户端发送给服务端的user-agent头部值，用来判断是移动端还是pc端\r\n\r\n**判断是移动端还是pc端**\r\n```js\r\nfunction isPhone(){\r\n    if(window.navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))\r\n    {\r\n      return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n## window.history对象\r\n* 该对象允许用户于浏览器历史记录进行交互\r\n* 该对象包含用户（在浏览器窗口中）访问过的URL\r\n\r\n常用方法\r\n* history.back() 后退一个页面\r\n* history.forward() 前进一个页面\r\n* history.go(参数) 参数是1前进一个页面，-1后退一个页面\r\n\r\n使用场景：\r\n![](./images/jsWebApis学习笔记之BOM/2022-07-07-08-31-52.png)\r\n"},{"shortInfo":{"title":"jsWebApis学习笔记之DOM","date":"2022-06-28T00:55:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["JavaScript","WebApis","BOM","DOM","前端"],"hideAtIndex":true,"categories":"笔记","id":25,"countWords":10828,"readSeconds":1082.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# jsWebApis学习笔记之DOM\r\n\r\n## 目录\r\n- [jsWebApis学习笔记之DOM](#jswebapis学习笔记之dom)\r\n  - [目录](#目录)\r\n  - [内容组成](#内容组成)\r\n    - [Web API](#web-api)\r\n    - [DOM](#dom)\r\n      - [DOM的一些概念](#dom的一些概念)\r\n  - [获取元素](#获取元素)\r\n    - [根据ID获取](#根据id获取)\r\n    - [根据标签获取](#根据标签获取)\r\n    - [根据类名获取](#根据类名获取)\r\n    - [查询选择器](#查询选择器)\r\n    - [特殊元素标签的获取](#特殊元素标签的获取)\r\n  - [事件](#事件)\r\n    - [常用事件类型](#常用事件类型)\r\n      - [面试题：mousemove与mouseenter的区别](#面试题mousemove与mouseenter的区别)\r\n    - [DOM事件流](#dom事件流)\r\n    - [注册事件](#注册事件)\r\n      - [传统注册方式](#传统注册方式)\r\n      - [方法监听注册方式](#方法监听注册方式)\r\n        - [事件监听方法的使用](#事件监听方法的使用)\r\n      - [解绑事件](#解绑事件)\r\n      - [事件委托](#事件委托)\r\n        - [面试题：事件委托原理](#面试题事件委托原理)\r\n    - [事件对象](#事件对象)\r\n      - [事件对象的属性和方法](#事件对象的属性和方法)\r\n    - [鼠标事件对象](#鼠标事件对象)\r\n      - [获取鼠标在页面中的坐标](#获取鼠标在页面中的坐标)\r\n      - [案例：拖拽移动元素](#案例拖拽移动元素)\r\n    - [键盘事件对象](#键盘事件对象)\r\n      - [案例：使输入框获得焦点](#案例使输入框获得焦点)\r\n      - [案例：放大显示输入内容](#案例放大显示输入内容)\r\n  - [操作元素](#操作元素)\r\n    - [修改元素内容](#修改元素内容)\r\n    - [修改元素属性](#修改元素属性)\r\n    - [修改元素样式](#修改元素样式)\r\n    - [修改元素类名](#修改元素类名)\r\n    - [单标签(表单)元素属性的修改](#单标签表单元素属性的修改)\r\n    - [操作元素示例](#操作元素示例)\r\n  - [节点操作](#节点操作)\r\n  - [元素偏移量offset系列属性](#元素偏移量offset系列属性)\r\n  - [元素可视区client系列属性](#元素可视区client系列属性)\r\n  - [元素滚动scroll系列属性](#元素滚动scroll系列属性)\r\n  - [页面window.scroll](#页面windowscroll)\r\n  - [offset、client、scroll三系列总结](#offsetclientscroll三系列总结)\r\n  - [dom核心知识点总结](#dom核心知识点总结)\r\n    - [创建](#创建)\r\n    - [增](#增)\r\n    - [删](#删)\r\n    - [改](#改)\r\n    - [查](#查)\r\n    - [属性操作](#属性操作)\r\n    - [事件操作](#事件操作)\r\n  - [一些案例](#一些案例)\r\n    - [全选框](#全选框)\r\n    - [tab栏切换制作](#tab栏切换制作)\r\n    - [新浪下拉菜单](#新浪下拉菜单)\r\n    - [简单留言发布案例实现](#简单留言发布案例实现)\r\n    - [动态生成表格](#动态生成表格)\r\n    - [实例：防止复制内容](#实例防止复制内容)\r\n      - [禁止鼠标右键菜单](#禁止鼠标右键菜单)\r\n      - [禁止鼠标选中文字](#禁止鼠标选中文字)\r\n      - [禁止f12键](#禁止f12键)\r\n    - [实例：阻止链接跳转](#实例阻止链接跳转)\r\n\r\n\r\n## 内容组成\r\n* JavaScript基础语法是ECMA组织制定的\r\n* Web Apis 是W3C组织制定的标准\r\n    * 主要学习BOM DOM\r\n\r\n![](./images/jsWebApis学习笔记之DOM/2022-06-28-08-58-57.png)\r\n\r\n\r\n\r\n### Web API\r\n* **API**（application programming interface应用程序编程接口）是一些预先定义的函数，提供给应用程序和开发人员基于某软件或硬件访问一组例程的能力，而又无需访问源码、理解内部工作机制细节\r\n* **Web API**是浏览器提供的一套操作浏览器功能和页面的API （BOM DOM）\r\n    * alert()是BOM API\r\n\r\n\r\n### DOM\r\n* **DOM**（Document Object Model文档对象模型），是**W3C**组织推荐的处理**可扩展标记语言**的标准**编程接口**\r\n    * 可扩展标记语言：\r\n        * HTML\r\n        * XML\r\n#### DOM的一些概念\r\n* **DOM树**\r\n    ![](./images/jsWebApis学习笔记之DOM/2022-06-28-09-16-59.png)\r\n* **文档document** ：一个页面就是一个文档\r\n* **元素element** ：页面中所有的标签都是元素\r\n* **节点node** ：页面中所有内容都可看做节点（标签，属性，文本，注释等）\r\n\r\n* **对象** ，DOM把文档，元素，节点看做对象\r\n\r\n## 获取元素\r\n* 根据ID获取\r\n* 根据标签获取\r\n* 根据HTML5新增方法获取\r\n* 特殊元素获取\r\n\r\n\r\n### 根据ID获取  \r\n`document.getElementById(\"idName\")`\r\n```html\r\n<div id=\"Demo1\">123</div>\r\n<script>\r\n    //参数是区分大小写的字符串\r\n    //返回一个对象\r\n    var Demo1=document.getElementById(\"Demo1\")\r\n\r\n    //测试：\r\n    console.log(Demo1)// <div id=\"Demo1\">123</div>\r\n    console.log(typeof Demo1)// object\r\n    console.dir(Demo1)// dir()用于打印查看元素对象，可以看到其属性和方法\r\n\r\n//注意：默认情况下，script标签需写在#Demo1 标签之后，因为文档页面从上往下加载，script加载时#Demo1标签必须已经存在，\r\n</script>\r\n```\r\n\r\n### 根据标签获取  \r\n获取整个页面的某标签`document.getElementsByTagName()`\r\n```html\r\n<ul>\r\n    <li>1</li>\r\n    <li>2</li>\r\n    <li>3</li>\r\n    <li>4</li>\r\n    <li>5</li>\r\n</ul>\r\n<script>\r\n    // 获得元素是动态的。个人理解：对元素的修改会同步到html，对html的修改会同步到获得到的元素\r\n\r\n    //返回值为获取的元素对象的集合，是伪数组\r\n    // 即使只有一个li，用该函数获取是有一个元素的伪数组，\r\n    //如果页面中没有li标签，返回值是空的伪数组\r\n    // document.getElementsByTagName获取到的是整个页面的相应标签\r\n    var elements2=document.getElementsByTagName(\"li\")\r\n    console.log(elements2)\r\n    console.log(elements2[0])\r\n    console.dir(elements2)\r\n    console.dir(elements2[0])\r\n\r\n</script>\r\n```\r\n获取某个标签的子标签`element.getElementsByTagName()`\r\n```html\r\n<ul>\r\n    <li>0</li>\r\n    <li>0</li>\r\n    <li>0</li>\r\n    <li>0</li>\r\n    <li>0</li>\r\n</ul>\r\n<ol id=\"olDemo\">\r\n    <li>1</li>\r\n    <li>2</li>\r\n    <li>3</li>\r\n    <li>4</li>\r\n    <li>5</li>\r\n</ol>\r\n<script>\r\n    // element.getElementsByTagName 获取到的是某元素的所有子标签\r\n    var ol=document.getElementById(\"olDemo\")\r\n    var ol_li=ol.getElementsByTagName(\"li\")\r\n    console.log(ol_li)\r\n    console.log(ol_li[0])\r\n    console.dir(ol_li)\r\n    console.dir(ol_li[0])\r\n</script>\r\n```\r\n\r\n### 根据类名获取  \r\n* getElementsByClassName()\r\n* **该方法是是HTML5标准**，ie678不支持html5  \r\n\r\n获取整个页面的某标签`document.getElementsByClassName()`\r\n\r\n```html\r\n<div class=\"classN1\">1</div>\r\n<div class=\"classN1\">2</div>\r\n\r\n<script>\r\n    var divs=document.getElementsByClassName(\"classN1\")\r\n    console.log(divs);\r\n    console.dir(divs);\r\n</script>\r\n```\r\n\r\n### 查询选择器  \r\n* **该方法是HTML5标准**  \r\n\r\nquerySelector返回查询到的**第一个**元素\r\n```html\r\n    <div class=\"father\">\r\n        <div id=\"id1\" class=\"class1\">1</div>\r\n        <div class=\"class1\">2</div>\r\n    </div>\r\n\r\n    <script>\r\n        // 传入的字符串类似css的选择器语法\r\n        // querySelector返回第一个查询到的元素\r\n        var divs=document.querySelector(\".father>div#id1.class1\")\r\n        console.log(divs);\r\n        console.dir(divs);\r\n    </script>\r\n```\r\n\r\nquerySelectorAll返回查询到的**所有**元素\r\n```html\r\n    <div class=\"father\">\r\n        <div id=\"id1\" class=\"class1\">1</div>\r\n        <div class=\"class1\">2</div>\r\n    </div>\r\n\r\n    <script>\r\n        // 返回值为存放节点的伪数组\r\n        var divs=document.querySelectorAll(\".father>div.class1\")\r\n        console.log(divs);\r\n        console.dir(divs);\r\n    </script>\r\n```\r\n\r\n\r\n### 特殊元素标签的获取\r\n```html\r\n<script>\r\n    //body标签直接用document.body获取\r\n    var bodyEle=document.body\r\n    console.log(bodyEle);\r\n    console.dir(bodyEle);\r\n\r\n    //body标签用document.documentElement获取\r\n    var htmlEle=document.documentElement\r\n    console.log(htmlEle);\r\n    console.dir(htmlEle);\r\n</script>\r\n```\r\n\r\n## 事件\r\n* 事件是可以被js检测到的行为\r\n* 可以理解为触发响应机制\r\n* 事件三要素（组成）\r\n    * 事件源：事件被触发的元素对象\r\n    * 事件类型：事件是如何触发的，鼠标点击？ 鼠标经过？\r\n    * 事件处理程序: 通过函数赋值的方式完成\r\n* 执行事件的步骤\r\n    * 获取事件源\r\n    * 注册事件（绑定事件）\r\n    * 添加事件处理程序（函数赋值）\r\n\r\n**示例**\r\n```html\r\n<button id=\"btn\">点击</button>\r\n<script>\r\n    //事件源\r\n    var btn=document.getElementById(\"btn\")\r\n    //事件类型，事件处理程序\r\n    btn.onclick = function(){\r\n        //do something...\r\n        alert(\"点击了按钮\")\r\n    }\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 常用事件类型\r\n* `element.onclick` 鼠标点击\r\n* `element.onfocus` 获得鼠标焦点\r\n* `element.onblur` 失去鼠标焦点\r\n* `element.onmouseover` 鼠标经过\r\n* `element.onmouseout` 鼠标离开\r\n* `element.onmousemove` 鼠标移动\r\n* `element.onmouseup` 鼠标弹起触发\r\n* `element.onmousedown` 鼠标按下触发\r\n* `element.onkeyup` 键盘弹起 松开按键时会触发一次\r\n* `element.onkeydown` 键盘按下 按下后会一直不断触发\r\n* `element.onkeypress` 键盘按下，按下后会一直不断触发 但不能识别功能键，如ctrl shift\r\n* 按键事件执行顺序为down->press->up\r\n\r\n#### 面试题：mousemove与mouseenter的区别\r\n* 当鼠标移动到元素上时就会触发moseenter事件\r\n* mouseover是鼠标经过自身盒子会触发，经过子盒子，父盒子也会触发该事件\r\n* moseenter是只有鼠标经过自身盒子才会触发，\r\n*  因为moseenter不支持冒泡，子元素的事件不会传播到父级\r\n*  常和moseenter搭配的mouseleave也不支持冒泡，\r\n\r\n### DOM事件流\r\n* 事件流描述的是从页面中接收事件的顺序\r\n* 时间发生时，事件会在元素节点之间按特定顺序传播，该过程称为DOM事件流\r\n* 模型三阶段\r\n    * 捕获阶段、\r\n    * 目标阶段、\r\n    * 冒泡阶段\r\n* 事件冒泡：IE提出\r\n* 事件冒泡：网景提出\r\n* 注意\r\n    * js代码中只能执行捕捉阶段和冒泡阶段中的一种事件\r\n    * onclick和attachEvent只能得到冒泡阶段的事件\r\n    * addEventListener\r\n        * 可以得到两种中任意一种阶段的事件，\r\n        * 默认接收冒泡阶段的事件，\r\n        * 第三个参数设置为true时，接收捕获阶段的事件\r\n    * 实际开发中很少使用事件捕捉，更关注事件冒泡\r\n    * 有些事件没有冒泡：onblur onfocus onmouseenter onmouseleave\r\n    * 事件冒泡有事会带来麻烦，有时又很有用\r\n\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-02-01-36-52.png)\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-02-01-31-07.png)\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-02-01-33-57.png)\r\n\r\n\r\n**两种事件传播方式测试**\r\n\r\n<div id=\"demoVMOWIEJF\" style=\"display: inline-block;background-color: skyblue; \">\r\n    <div>\r\n        <button style=\"margin: 20px;\">捕获阶段事件传播测试</button>\r\n    </div>\r\n</div>\r\n<div id=\"demoFBERT45\" style=\"display: inline-block;background-color: skyblue; \">\r\n    <div>\r\n        <button style=\"margin: 20px;\">冒泡阶段事件传播测试</button>\r\n    </div>\r\n</div>\r\n<script>\r\n    var father1=document.querySelector(\"#demoVMOWIEJF>div\")\r\n    father1.addEventListener(\"click\",function(){\r\n        alert(\"father:检测到捕获阶段事件click\")\r\n    },\r\n    true\r\n    )\r\n    father1.firstElementChild.addEventListener(\"click\",function(){\r\n        alert(\"child:检测到捕获阶段事件click\")\r\n    },\r\n    true\r\n    )\r\n    var father2=document.querySelector(\"#demoFBERT45>div\")\r\n    father2.addEventListener(\"click\",function(){\r\n        alert(\"father:检测到冒泡阶段事件click\")\r\n    },\r\n    false\r\n    )\r\n    father2.firstElementChild.addEventListener(\"click\",function(){\r\n        alert(\"child:检测到冒泡阶段事件click\")\r\n    },\r\n    false\r\n    )\r\n</script>\r\n\r\n```html\r\n<div id=\"demoVMOWIEJF\" style=\"display: inline-block;background-color: skyblue; \">\r\n    <div>\r\n        <button style=\"margin: 20px;\">捕获阶段事件传播测试</button>\r\n    </div>\r\n</div>\r\n<div id=\"demoFBERT45\" style=\"display: inline-block;background-color: skyblue; \">\r\n    <div>\r\n        <button style=\"margin: 20px;\">冒泡阶段事件传播测试</button>\r\n    </div>\r\n</div>\r\n<script>\r\n    var father1=document.querySelector(\"#demoVMOWIEJF>div\")\r\n    father1.addEventListener(\"click\",function(){\r\n        alert(\"father:检测到捕获阶段事件click\")\r\n    },\r\n    true\r\n    )\r\n    father1.firstElementChild.addEventListener(\"click\",function(){\r\n        alert(\"child:检测到捕获阶段事件click\")\r\n    },\r\n    true\r\n    )\r\n\r\n    var father2=document.querySelector(\"#demoFBERT45>div\")\r\n    father2.addEventListener(\"click\",function(){\r\n        alert(\"father:检测到冒泡阶段事件click\")\r\n    },\r\n    false\r\n    )\r\n    father2.firstElementChild.addEventListener(\"click\",function(){\r\n        alert(\"child:检测到冒泡阶段事件click\")\r\n    },\r\n    false\r\n    )\r\n    \r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n### 注册事件\r\n\r\n* 给元素添加事件称为注册事件或绑定事件\r\n* 注册事件有两种方式\r\n    * 传统方式\r\n    * 方法监听注册方式\r\n \r\n\r\n#### 传统注册方式\r\n * 利用on开头的事件名注册，如onclick\r\n * `<button onclick=\"alert('hi~')\"></button>`\r\n * `btn.onclick=function(){}`\r\n * 特点：注册事件的**唯一性** 同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数\r\n\r\n#### 方法监听注册方式\r\n* w3c标准 推荐的方式\r\n* `addEventListener()` **方法监听** ie678不支持\r\n* `attachEvent(eventNameWithOn,callback)`代替，**仅ie8及之前支持** 是一个非标准特性，应尽量不要在生产环境中使用\r\n* 同一个元素同一个事件可以注册多个**监听器（事件处理函数）**\r\n* 按注册顺序依次执行 \r\n\r\n##### 事件监听方法的使用\r\n* `element.addEventListener(type,listener[,useCapture])`\r\n* `type`:事件类型字符串，如click moseover 注意不带on\r\n* `listener`：事件处理函数，事件发生时，会调用该监听函数\r\n* `useCapture`:可选参数，布尔值，默认false，与DOM事件流相关\r\n\r\n\r\n#### 解绑事件\r\n* 传统方法：`element.onclick=null`\r\n* 事件监听方法: \r\n    1. 注册：`element.addEventListener(事件类型,非匿名函数名)`\r\n    2. 解绑：\r\n        * `element.addEventListener(事件类型,非匿名函数名)`\r\n        *  或  `element.detachEvent(eventNameWithOn,非匿名函数名)` **仅ie8及之前支持**\r\n\r\n**两种方法的测试**\r\n\r\n<div id=\"demoBIUBITYy\">\r\n    <button>传统注册事件</button>\r\n    <button>方法监听注册事件</button>\r\n</div>\r\n<script>\r\n    var buttons=document.querySelectorAll(\"#demoBIUBITYy>button\")\r\n    buttons[0].onclick=function(){\r\n        alert(\"传统注册事件,触发消息1\")\r\n    }\r\n    buttons[0].onclick=function(){\r\n        alert(\"传统注册事件,触发消息2\")\r\n    }\r\n    buttons[1].addEventListener(\"click\",function(){\r\n        alert(\"方法监听注册事件,触发消息1\")\r\n    })\r\n    buttons[1].addEventListener(\"click\",function(){\r\n        alert(\"方法监听注册事件,触发消息2\")\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demoBIUBITYy\">\r\n    <button>传统注册事件</button>\r\n    <button>方法监听注册事件</button>\r\n</div>\r\n<script>\r\n    var buttons=document.querySelectorAll(\"#demoBIUBITYy>button\")\r\n    buttons[0].onclick=function(){\r\n        alert(\"传统注册事件,触发消息1\")\r\n    }\r\n    buttons[0].onclick=function(){\r\n        alert(\"传统注册事件,触发消息2\")\r\n    }\r\n    \r\n    buttons[1].addEventListener(\"click\",function(){\r\n        alert(\"方法监听注册事件,触发消息1\")\r\n    })\r\n    buttons[1].addEventListener(\"click\",function(){\r\n        alert(\"方法监听注册事件,触发消息2\")\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n**封装兼容性事件注册函数**\r\n```js\r\n    function myAddEventListener(element,eventName,callback)\r\n    {\r\n        if(document.addEventListener)//兼容性处理原则：首先照顾大多数浏览器，再处理特殊浏览器\r\n        {\r\n            element.addEventListener(eventName,callback);\r\n        }else if(document.attachEvent)\r\n        {\r\n            element.attachEvent(\"on\"+eventName,callback);\r\n        }else{\r\n            element[\"on\"+eventName]=callback;\r\n        }\r\n    }\r\n```\r\n\r\n**封装兼容性事件解绑函数**\r\n```js\r\n    function myAddEventListener(element,eventName,callback)\r\n    {\r\n        if(document.removeEventListener)//兼容性处理原则：首先照顾大多数浏览器，再处理特殊浏览器\r\n        {\r\n            element.addEventListener(eventName,callback);\r\n        }else if(document.detachEvent)\r\n        {\r\n            element.detachEvent(\"on\"+eventName,callback);\r\n        }else{\r\n            element[\"on\"+eventName]=null;\r\n        }\r\n    }\r\n```\r\n\r\n\r\n#### 事件委托\r\n* 时间委托也称事件代理，在JQuery中称事件委派\r\n* 对于ul>li这样结构的元素标签，实现点击li后弹出对话框，需要给所有li注册事件，li越多，访问DOM的次数也越多，这就会延长整个页面交互就绪的时间。\r\n\r\n##### 面试题：事件委托原理\r\n不是用for循环为每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用event.target属性和冒泡原理控制每个子节点\r\n\r\n**事件委托测试**\r\n\r\n<ul id=\"demoHsfweo9\">\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n</ul>\r\n<script>\r\n    var ul = document.querySelector(\"#demoHsfweo9\");\r\n    ul.addEventListener(\"click\",function(event){\r\n        for(var i=0;i<ul.children.length;i++)\r\n        {\r\n            ul.children[i].style.backgroundColor=\"\"\r\n        }\r\n        event.target.style.backgroundColor=\"pink\"\r\n    })\r\n</script>\r\n\r\n```html\r\n<ul id=\"demoHsfweo9\">\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n    <li>123</li>\r\n</ul>\r\n<script>\r\n    var ul = document.querySelector(\"#demoHsfweo9\");\r\n    ul.addEventListener(\"click\",function(event){\r\n        for(var i=0;i<ul.children.length;i++)\r\n        {\r\n            ul.children[i].style.backgroundColor=\"\"\r\n        }\r\n        event.target.style.backgroundColor=\"pink\"\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 事件对象\r\n```js\r\nelement.onclick=function(event){\r\n    console.log(event)\r\n}\r\n```\r\n* 事件对象代表了事件的状态，如键盘按下的状态，鼠标的位置，鼠标的按钮状态\r\n* 事件对象是事件处理函数的第一个形参获取到的对象\r\n* 事件对象只有事件发生才会存在，是系统自动创建并传递的\r\n* 事件对象是与事件相关的一系列数据的集合，\r\n    * 如鼠标点击事件发生后，事件对象中就包含鼠标的坐标信息\r\n* 事件对象的形参名可以自定义\r\n* 兼容性问题：ie678需要通过window.event来获取事件对象\r\n    * 兼容性写法 `event=event||window.event`\r\n  \r\n#### 事件对象的属性和方法\r\n1. **获取的是触发事件的元素对象** `event.target` \r\n    * 与`this`的区别：this永远指向被绑定事件的元素\r\n    * 简单来说：对于click事件，this返回的是绑定该事件的元素，target返回的是被点击的元素\r\n    * `event.currentTarget` 和 `this` 的值一致\r\n    * 兼容性问题：**ie678**仅支持`event.srcElement`属性\r\n    * 兼容性写法：\r\n        1. `var e=event||window.event;` \r\n        1. `var target=e.target||e.srcElement`\r\n1. **获取事件类型** `event.type` ，不带on\r\n1. **阻止默认事件默认行为** `event.preventDefault()` dom标准函数，阻止默认事件默认行为，如不让链接跳转\r\n    * 兼容性问题：\r\n        * **ie678** 调用该属性：`e.returnValue;`\r\n        * 新旧浏览器通用写法： return false; 但只能用于传统的注册方式\r\n1. **阻止冒泡** `event.stopPropagation()` dom标准方法 直译为停止传播\r\n    * 兼容性问题：ie678仅支持 event.cancelBubble=true 直译为取消冒泡\r\n\r\n\r\n### 鼠标事件对象\r\n#### 获取鼠标在页面中的坐标\r\n* 鼠标相关事件能获取到坐标\r\n* `event.clientX` 鼠标相对于**浏览器窗口可视区域**的X坐标,**左上角为(0,0)**,无论页面是否拖动\r\n* `event.clientY`\r\n* `event.pageX` 鼠标相对于**整个html文档页面**的X坐标 **IE678不支持** \r\n* `event.pageY`\r\n* `event.screenX` 鼠标相对于**电脑屏幕**的X坐标\r\n* `event.screenY`\r\n\r\n* 画了张图：\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-02-22-22-00.png)\r\n\r\n#### 案例：拖拽移动元素\r\n\r\n<div id=\"demoKjowejf9\" style=\"position: fixed; background-color:skyblue;width:100px;height:100px; cursor:move;\"></div>\r\n<script>\r\n    var demoKjowejf9=document.querySelector(\"#demoKjowejf9\")\r\n    function move(event){\r\n        // console.log(event.target);\r\n        demoKjowejf9.style.left=event.clientX - parseInt(demoKjowejf9.style.width)/2  +\"px\"\r\n        demoKjowejf9.style.top=event.clientY -  parseInt(demoKjowejf9.style.height)/2  +\"px\"\r\n    }\r\n    demoKjowejf9.addEventListener(\"mousedown\",function(event){\r\n        // console.log(event);\r\n        document.addEventListener(\"mousemove\",move)\r\n    })\r\n    demoKjowejf9.addEventListener(\"mouseup\",function(event){\r\n        // console.log(event);\r\n        document.removeEventListener(\"mousemove\",move)\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demoKjowejf9\" style=\"position: fixed; background-color:skyblue;width:100px;height:100px; cursor:move;\"></div>\r\n<script>\r\n    var demoKjowejf9=document.querySelector(\"#demoKjowejf9\")\r\n    function move(event){\r\n        // console.log(event.target);\r\n        demoKjowejf9.style.left=event.clientX - parseInt(demoKjowejf9.style.width)/2  +\"px\"\r\n        demoKjowejf9.style.top=event.clientY -  parseInt(demoKjowejf9.style.height)/2  +\"px\"\r\n    }\r\n    demoKjowejf9.addEventListener(\"mousedown\",function(event){\r\n        // console.log(event);\r\n        document.addEventListener(\"mousemove\",move)\r\n    })\r\n    demoKjowejf9.addEventListener(\"mouseup\",function(event){\r\n        // console.log(event);\r\n        document.removeEventListener(\"mousemove\",move)\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n\r\n### 键盘事件对象\r\n触发事件名\r\n* 按键事件执行顺序为down->press->up\r\n* `element.onkeyup` 键盘弹起 松开按键时会触发一次\r\n* `element.onkeydown` 键盘按下 按下后会一直不断触发\r\n* `element.onkeypress` 键盘按下，按下后会一直不断触发 但不能识别功能键，如ctrl shift\r\n键盘事件对象属性\r\n* `event.key` 按键值，低版本浏览器不支持\r\n* `event.keyCode` 按键ASCII值\r\n* `keyup` 和 `keydown` 事件不区分字母大小写，a和A都是65\r\n* `keypress` 事件区分字母大小写，a是97 A是65\r\n\r\n#### 案例：使输入框获得焦点\r\n\r\n<input type=\"text\" id=\"demoNFOEWFH1234\">\r\n<script>\r\n    var demoNFOEWFH1234 = document.querySelector(\"#demoNFOEWFH1234\")\r\n    document.addEventListener(\"keyup\",function(e){//用keyup可以避免字符被输入进文本框\r\n        // console.log(e.keyCode);\r\n        if(e.keyCode==83)\r\n        {\r\n            demoNFOEWFH1234.focus();//使输入框获得焦点\r\n        }\r\n    })\r\n</script>\r\n\r\n```html\r\n<input type=\"text\" id=\"demoNFOEWFH1234\">\r\n<script>\r\n    var demoNFOEWFH1234 = document.querySelector(\"#demoNFOEWFH1234\")\r\n    document.addEventListener(\"keyup\",function(e){//用keyup可以避免字符被输入进文本框\r\n        // console.log(e.keyCode);\r\n        if(e.keyCode==83)\r\n        {\r\n            demoNFOEWFH1234.focus();//使输入框获得焦点\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n#### 案例：放大显示输入内容\r\n\r\n注意对于文本框来说，keydown keypress事件发生时，文字还未填入文本框中\r\nkeyup事件发生时，文字已经落入文本框\r\n\r\n<style>\r\n     #demo123WEFWF{\r\n        position: relative;\r\n     }\r\n    #demo123WEFWF input{\r\n        padding: 0;\r\n        margin-top: 0px;\r\n        height: 20px;\r\n        width: 200px;\r\n        box-sizing: border-box;\r\n        outline: none;\r\n        /* height: 50px; */\r\n    }\r\n    #demo123WEFWF div{\r\n        box-sizing: border-box;\r\n        display: none;\r\n        margin-bottom: 8px;\r\n        padding-left: 10px;\r\n        height:40px;\r\n        width: 200px;\r\n        background-color: white;\r\n        box-shadow: 0 0 8px gray;\r\n        line-height: 40px;\r\n        font-size: 30px;\r\n\r\n        word-break: keep-all;\r\n        overflow-x: auto;\r\n        overflow-y: hidden;\r\n    }\r\n    #demo123WEFWF div::-webkit-scrollbar{\r\n    /* 清除滚动条 */\r\n        /* display: none; */\r\n        height: 2px;\r\n    }\r\n    #demo123WEFWF div::-webkit-scrollbar-thumb{\r\n        /* height: 3px; */\r\n        background-color: gray;\r\n    }\r\n    #demo123WEFWF::after{\r\n        position:absolute;\r\n        top: 40px;\r\n        left: 10px;\r\n        display: block;\r\n        content: \"\";\r\n        width: 0;\r\n        height: 0;\r\n        border-top: 5px solid white;\r\n        border-bottom: 5px solid transparent;\r\n        border-left: 5px solid transparent;\r\n        border-right: 5px solid transparent;\r\n    }\r\n</style>\r\n<div id=\"demo123WEFWF\">\r\n    <div></div>\r\n    <input type=\"text\" >\r\n</div>\r\n<script>\r\n    var demo123WEFWF = document.querySelector(\"#demo123WEFWF\")\r\n    var input = demo123WEFWF.querySelector(\"input\")\r\n    var div = demo123WEFWF.querySelector(\"div\")\r\n    input.addEventListener(\"keyup\",function(event){\r\n        if(this.value==\"\")\r\n        {\r\n            div.style.display=\"none\"\r\n        }else{\r\n            div.style.display=\"block\"\r\n            div.innerHTML=this.value;\r\n            div.scrollLeft =div.scrollWidth;//使滚动条右对齐，以始终显示最新内容\r\n        }\r\n    })\r\n    input.addEventListener(\"focus\",function(){//获得焦点后显示盒子\r\n        if(this.value!=\"\")\r\n            div.style.display=\"block\"\r\n    })\r\n    input.addEventListener(\"blur\",function(){//失去焦点后隐藏盒子\r\n        div.style.display=\"none\"\r\n    })\r\n</script>\r\n\r\n```html\r\n<style>\r\n     #demo123WEFWF{\r\n        position: relative;\r\n     }\r\n    #demo123WEFWF input{\r\n        padding: 0;\r\n        margin-top: 0px;\r\n        height: 20px;\r\n        width: 200px;\r\n        box-sizing: border-box;\r\n        outline: none;\r\n        /* height: 50px; */\r\n    }\r\n    #demo123WEFWF div{\r\n        box-sizing: border-box;\r\n        display: none;\r\n        margin-bottom: 8px;\r\n        padding-left: 10px;\r\n        height:40px;\r\n        width: 200px;\r\n        background-color: white;\r\n        box-shadow: 0 0 8px gray;\r\n        line-height: 40px;\r\n        font-size: 30px;\r\n\r\n        word-break: keep-all;\r\n        overflow-x: auto;\r\n        overflow-y: hidden;\r\n    }\r\n    #demo123WEFWF div::-webkit-scrollbar{\r\n    /* 清除滚动条 */\r\n        /* display: none; */\r\n        height: 2px;\r\n    }\r\n    #demo123WEFWF div::-webkit-scrollbar-thumb{\r\n        /* height: 3px; */\r\n        background-color: gray;\r\n    }\r\n    #demo123WEFWF::after{\r\n        position:absolute;\r\n        top: 40px;\r\n        left: 10px;\r\n        display: block;\r\n        content: \"\";\r\n        width: 0;\r\n        height: 0;\r\n        border-top: 5px solid white;\r\n        border-bottom: 5px solid transparent;\r\n        border-left: 5px solid transparent;\r\n        border-right: 5px solid transparent;\r\n    }\r\n</style>\r\n<div id=\"demo123WEFWF\">\r\n    <div></div>\r\n    <input type=\"text\" >\r\n</div>\r\n<script>\r\n    var demo123WEFWF = document.querySelector(\"#demo123WEFWF\")\r\n    var input = demo123WEFWF.querySelector(\"input\")\r\n    var div = demo123WEFWF.querySelector(\"div\")\r\n    input.addEventListener(\"keyup\",function(event){\r\n        if(this.value==\"\")\r\n        {\r\n            div.style.display=\"none\"\r\n        }else{\r\n            div.style.display=\"block\"\r\n            div.innerHTML=this.value;\r\n            div.scrollLeft =div.scrollWidth;//使滚动条右对齐，以始终显示最新内容\r\n        }\r\n    })\r\n    input.addEventListener(\"focus\",function(){//获得焦点后显示盒子\r\n        if(this.value!=\"\")\r\n            div.style.display=\"block\"\r\n    })\r\n    input.addEventListener(\"blur\",function(){//失去焦点后隐藏盒子\r\n        div.style.display=\"none\"\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 操作元素\r\n### 修改元素内容\r\n* `element.innerText` \r\n    * IE发起的标准\r\n    * 写入的字符串被当成纯文本 \r\n    * 读取时会过滤掉html标签、空格、换行\r\n* `element.innerHtml`\r\n    * W3C发起的标准\r\n    * 写入的文本有html标签则会解析 \r\n    * 读取时保留html标签、空格、换行\r\n\r\n**修改元素内容示例**\r\n\r\n<button id=\"btn\">修改元素内容</button>\r\n<p id=\"textBox1\"></p>\r\n<p id=\"textBox2\"></p>\r\n<script>\r\n    var btn=document.getElementById(\"btn\")\r\n    var textBox1=document.getElementById(\"textBox1\")\r\n    btn.onclick = function(){\r\n        var date=new Date()\r\n        console.log(date);\r\n        //写入纯文本\r\n        textBox1.innerText='<strong>' + date + \"</strong>\"\r\n        //写入可包含html标签的文本\r\n        textBox2.innerHTML='<strong>' + date + \"</strong>\"\r\n    }\r\n</script>\r\n\r\n```html\r\n    <button id=\"btn\">修改元素内容</button>\r\n    <p id=\"textBox1\"></p>\r\n    <p id=\"textBox2\"></p>\r\n    <script>\r\n        var btn=document.getElementById(\"btn\")\r\n        var textBox1=document.getElementById(\"textBox1\")\r\n        btn.onclick = function(){\r\n            var date=new Date()\r\n            console.log(date);\r\n            //写入纯文本\r\n            textBox1.innerText='<strong>' + date + \"</strong>\"\r\n            //写入可包含html标签的文本\r\n            textBox2.innerHTML='<strong>' + date + \"</strong>\"\r\n        }\r\n    </script>\r\n```\r\n\r\n\r\n### 修改元素属性\r\n获取、修改标签内置属性\r\n* `element.src`\r\n* `element.title`\r\n* `element.herf`\r\n* `element.id`\r\n* `element.alt`\r\n* `element.display`\r\n\r\n获取、修改标签自定义属性\r\n* `element.getAttribute(\"标签内置属性名\")`\r\n* `element.getAttribute(\"自定义属性名\")`\r\n* `element.setAttribute(\"标签内置属性名\",\"属性值\")`\r\n* `element.setAttribute(\"自定义属性名\",\"属性值\")`\r\n* H5新增方法:\r\n    * h5规定自定义属性以`data-`开头，下述方法只能获取以这种方式命名的属性\r\n    * `element.dataset.index` 获取的是`data-index`属性 \r\n    * `element.dataset[\"index\"]` 获取的是`data-index`属性\r\n    * `element.dataset.listName` 获取的是`data-list-name`属性 \r\n\r\n移除属性\r\n* `element.removeAttribute(\"属性名\")`\r\n\r\n```html\r\n<div 自定义属性名=\"属性值\"></div>\r\n<script>\r\n    var div=document.querySelector(\"div\")\r\n    console.log(div.getAttribute(\"自定义属性名\"))\r\n    div.setAttribute(\"自定义属性名\",\"属性值\")\r\n</script>\r\n\r\n```\r\n\r\n### 修改元素样式\r\n* `element.style` **行内样式属性** 优先级较高\r\n    * `element.style.backgroundColor=\"pink\"` 修改背景颜色，驼峰命名法\r\n    * `element.style.fontSize` \r\n    * `element.style.width` \r\n  \r\n### 修改元素类名\r\n* `element.ClassName` **类名样式属性**\r\n    * 因为class是保留字，所以不能使用，名为ClassName\r\n    * `element.ClassName=\"类名1 类名2\"` 修改背景颜色，驼峰命名法\r\n\r\n### 单标签(表单)元素属性的修改\r\n* 对于`input`等的单标签，需通过`element.value`更改标签内容\r\n* element.type\r\n* element.value\r\n* element.value.length\r\n* element.checked\r\n* element.selected\r\n* element.disabled\r\n\r\n\r\n### 操作元素示例\r\n\r\n\r\n\r\n**修改单标签元素内容**\r\n\r\n<input id=\"input2\" type=\"text\" value=\"请输入内容\" style=\"color: #999;\">\r\n<button id=\"btn2\">提交</button>\r\n<script>\r\n    var btn2=document.getElementById(\"btn2\")\r\n    var input2=document.getElementById(\"input2\")\r\n    btn2.onclick = function(){//点击按钮后禁用输入框和按钮\r\n        //this 表示函数的调用者，也就是btn2\r\n        this.disabled=true\r\n        input2.disabled=true\r\n        input2.value+=\" 数据已锁定\"\r\n    }\r\n    input2.onfocus=function(){//点击后获得焦点 清空输入框默认值\r\n        if(this.value==\"请输入内容\")\r\n            this.value=\"\"\r\n        this.style.color=\"#333\"\r\n    }\r\n    input2.onblur=function(){//失去焦点后 若输入框为空 填写默认值\r\n        if(this.value==\"\")\r\n            this.value=\"请输入内容\"\r\n        this.style.color=\"#999\"\r\n    }\r\n</script>\r\n\r\n```html\r\n<input id=\"input2\" type=\"text\" value=\"请输入内容\" style=\"color: #999;\">\r\n<button id=\"btn2\">提交</button>\r\n<script>\r\n    var btn2=document.getElementById(\"btn2\")\r\n    var input2=document.getElementById(\"input2\")\r\n    btn2.onclick = function(){//点击按钮后禁用输入框和按钮\r\n        //this 表示函数的调用者，也就是btn2\r\n        this.disabled=true\r\n        input2.disabled=true\r\n        input2.value+=\" 数据已锁定\"\r\n    }\r\n    input2.onfocus=function(){//点击后获得焦点 清空输入框默认值\r\n        if(this.value==\"请输入内容\")\r\n            this.value=\"\"\r\n        this.style.color=\"#333\"\r\n    }\r\n    input2.onblur=function(){//失去焦点后 若输入框为空 填写默认值\r\n        if(this.value==\"\")\r\n            this.value=\"请输入内容\"\r\n        this.style.color=\"#999\"\r\n    }\r\n</script>\r\n```\r\n\r\n**密码框明文密文显示切换**\r\n\r\n<input id=\"input3\" type=\"password\" value=\"密码123\">\r\n<button id=\"btn3\">切换显示方式</button>\r\n<script>\r\n    var btn3=document.getElementById(\"btn3\")\r\n    var input3=document.getElementById(\"input3\")\r\n    btn3.onclick = function(){//点击按钮后显示明文密码\r\n        if(input3.type==\"password\")\r\n            input3.type=\"text\"\r\n        else\r\n            input3.type=\"password\"\r\n    }\r\n</script>\r\n\r\n```html\r\n<input id=\"input3\" type=\"password\" value=\"密码123\">\r\n<button id=\"btn3\">切换显示方式</button>\r\n<script>\r\n    var btn3=document.getElementById(\"btn3\")\r\n    var input3=document.getElementById(\"input3\")\r\n    btn3.onclick = function(){//点击按钮后显示明文密码\r\n        if(input3.type==\"password\")\r\n            input3.type=\"text\"\r\n        else\r\n            input3.type=\"password\"\r\n    }\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n## 节点操作\r\n* 节点类型 `node.nodeType`\r\n    * 元素节点：nodeType=1\r\n    * 属性节点：nodeType=2\r\n    * 文本节点：nodeType=3 包含文本空格换行等...）\r\n* 节点名 `node.nodeName`\r\n* 节点值 `node.nodeValue`\r\n* **获取父节点** `node.parentNode` 没有父节点返回空\r\n* **获取子节点** `node.childNodes` （标准） 包含元素子节点间的换行 空格等 可以用for循环遍历所有的子节点提取出节点类型为文本节点的节点 但一般不使用这种方式\r\n* **获取子元素节点** `node.children` （非标准，但已得到各浏览器支持）是一个只读属性\r\n* 第一个子节点 `node.firstChild` 包括文本节点\r\n* 最后一个子节点 `node.lastChild` 包括文本节点\r\n* 第一个子元素节点 `node.firstElementChild` 找不到返回null 存在兼容性问题ie678不支持\r\n* 最后一个子元素节点 `node.lastElementChild` 找不到返回null 存在兼容性问题\r\n* 解决兼容性的实际开发写法 \r\n    *  第一个子元素节点 `node.children[0]`\r\n    * 最后一个子元素节点 `node.children[node.children.length - 1 ]`\r\n* **获取下一个兄弟节点** `node.nextSibling`\r\n* **获取前一个兄弟节点** `node.previousSibling`\r\n* **获取下一个兄弟元素节点** `node.nextElementSibling` ie678不支持\r\n* **获取前一个兄弟元素节点** `node.previousElementSibling` ie678不支持\r\n* **兼容性获取兄弟元素节点**\r\n    ```js\r\n    function getNextElementSibling(node)\r\n    {\r\n        for(var i=0;i<node.children.length;i++)\r\n        {\r\n            if(node.children[i].nodeType==1)\r\n            {\r\n                return node.children[i]\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    ```\r\n* **创建元素节点** `document.createElement(\"标签名\")`\r\n* **附加子节点** node.appendChild(newNode)\r\n* **在某个子元素之前附加子节点** node.insertBefore(newNode,基准元素)\r\n\r\n* **删除节点** `node.removeChild(待删除的子节点)` 返回删除的节点\r\n\r\n* **克隆节点** `待克隆节点Node.cloneNode()` 参数为空或为false是浅拷贝，没有元素内容；参数为true是深拷贝\r\n\r\n* `document.write(\"<div></div>\")` 直接将n内容写入页面的内容流，**如果文档流已经执行完毕，执行该语句会导致页面全部重绘**\r\n\r\n* 创建元素的效率问题（经典面试题）\r\n    * 方法1\r\n        * `document.write(\"<div></div>\")` **如果文档流已经执行完毕，执行该语句会导致页面全部重绘**\r\n    * 方法2\r\n        * `node.appendChild(document.createElement(\"div\"))` **效率高** 循环执行1000次耗时17ms\r\n    * 方法3\r\n        * `node.innerHtml+=\"<div></div>\"`  **效率低** 循环执行1000次耗时3s 因为要拼接字符串\r\n    * 方法4\r\n        1. `list=[];` \r\n        2. `list.push(\"<div>循环执行1000次</div>\");`\r\n        3. `node.innerHtml=list.join(\"\")` **效率最高** 耗时8ms 不用拼接字符串\r\n\r\n\r\n## 元素偏移量offset系列属性\r\n* 可以动态的获取元素的**位置**，**大小**\r\n* 获取的元素**位置**偏移量是相对于带有定位属性的父元素的，若所有父元素都没有定位属性则相对于body\r\n* 获取的元素**大小**，也就是宽高，包含**width/height + padding + border**\r\n* 返回的数值**没有单位**\r\n* 是一个**只读**属性\r\n\r\n**常用属性**\r\n* `element.offsetParent` 返回该元素**带有定位属性的父级**，如果找不到则返回body\r\n* `element.offsetTop` 返回元素的上偏移（相对于offsetParent）\r\n* `element.offsetLeft` 返回元素的左偏移（相对于offsetParent）\r\n* `element.offsetWidth` 返回元素的宽度（包含width padding border）\r\n* `element.offsetHeight` 返回元素的宽度（包含height padding border）\r\n\r\noffset和style属性的区别\r\n* offset得到的是元素盒子的宽高（包含padding border），style得到的是元素行内样式中设置的宽高（不包含padding border）\r\n* offset没有单位 style有单位\r\n* offset是只读属性 style是可读写属性\r\n\r\n\r\n**商品细节展示**\r\n\r\n效果图:\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-05-04-58-49.png)\r\n\r\n```html\r\n<!-- div#demoOHdfn9e的父级需为body -->\r\n<style>\r\n    #demoOHdfn9e{\r\n        position: relative;\r\n        margin: 0;\r\n        width: 400px;\r\n        height: 400px;\r\n        background: url(./images/jsWebApis学习笔记之DOM/2022-07-05-04-19-00.png);\r\n        background-size: contain;\r\n    }\r\n    #demoOHdfn9e .mask{\r\n        display: none;\r\n        position: absolute;\r\n        width: 200px;\r\n        height: 200px;\r\n        background-color: gold;\r\n        opacity: 0.5;\r\n        cursor: move;\r\n    }\r\n    #demoOHdfn9e .big{\r\n        display: none;\r\n        position: absolute;\r\n        left: 100%;\r\n        top: 0;\r\n        width: 500px;\r\n        height: 500px;\r\n        overflow: hidden;\r\n    }\r\n    #demoOHdfn9e .big img{\r\n        position: absolute;\r\n\r\n    }\r\n</style>\r\n<div id=\"demoOHdfn9e\">\r\n    <div class=\"mask\"></div>\r\n    <div class=\"big\"><img src=\"/images/jsWebApis学习笔记之DOM/2022-07-05-04-19-00.png\" alt=\"\"></div>\r\n</div>\r\n<script>\r\n    var demoOHdfn9e = document.querySelector(\"#demoOHdfn9e\")\r\n    var mask = document.querySelector(\"#demoOHdfn9e>.mask\")\r\n    var big = document.querySelector(\"#demoOHdfn9e>.big\")\r\n    var img = document.querySelector(\"#demoOHdfn9e>.big>img\")\r\n    function updataPos(e){//更新子盒子的位置\r\n            //鼠标相对于父级盒子的坐标\r\n            var innerMousePosX = e.pageX - demoOHdfn9e.offsetLeft\r\n            var innerMousePosY = e.pageY - demoOHdfn9e.offsetTop\r\n            //计算子盒子相对于父盒子的偏移\r\n            var newMaskPosX = innerMousePosX-mask.offsetWidth/2\r\n            var newMaskPosY = innerMousePosY-mask.offsetHeight/2\r\n            //限制小盒子的移动范围\r\n            if(newMaskPosX < 0)\r\n            {\r\n                newMaskPosX=0\r\n            }else if(demoOHdfn9e.offsetWidth-mask.offsetWidth < newMaskPosX )\r\n            {\r\n                newMaskPosX=demoOHdfn9e.offsetWidth-mask.offsetWidth\r\n            }\r\n            if( newMaskPosY < 0 )\r\n            {\r\n                newMaskPosY= 0\r\n            }\r\n            else if(demoOHdfn9e.offsetHeight-mask.offsetHeight < newMaskPosY)\r\n            {\r\n                newMaskPosY=demoOHdfn9e.offsetHeight-mask.offsetHeight\r\n            }\r\n            mask.style.left=newMaskPosX + \"px\";\r\n            mask.style.top=newMaskPosY + \"px\"\r\n            //根据比例计算大图的宽高\r\n            img.style.width=demoOHdfn9e.offsetWidth * big.offsetWidth / mask.offsetWidth + \"px\"\r\n            img.style.height=demoOHdfn9e.offsetHeight * big.offsetHeight / mask.offsetHeight + \"px\"\r\n            //根据比例移动大图\r\n            img.style.left = - newMaskPosX * img.offsetWidth / demoOHdfn9e.offsetWidth  + \"px\"\r\n            img.style.top = - newMaskPosY * img.offsetHeight / demoOHdfn9e.offsetHeight + \"px\"\r\n        }\r\n    demoOHdfn9e.addEventListener(\"mouseenter\",function(e){\r\n        mask.style.display=\"block\";\r\n        big.style.display=\"block\";\r\n        demoOHdfn9e.addEventListener(\"mousemove\",updataPos);\r\n    })\r\n    demoOHdfn9e.addEventListener(\"mouseleave\",function(){\r\n        mask.style.display=\"none\";\r\n        big.style.display=\"none\";\r\n        demoOHdfn9e.removeEventListener(\"mousemove\",updataPos);\r\n    })\r\n</script>\r\n```\r\n## 元素可视区client系列属性\r\n* client可获得元素的大小（内容+padding），边框的大小\r\n* `element.clientTop` 上边框的大小\r\n* `element.clientLeft` 左边框的大小\r\n* `element.clientWidth` 内容区域+padding的宽\r\n* `element.clientHeight` 内容区域+padding的高\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-05-06-25-04.png)\r\n\r\n\r\n## 元素滚动scroll系列属性\r\n\r\n* element.scrollTop 被卷去的上侧边距 (没有bottom)\r\n* element.scrollLeft 被卷去的左侧边距 （没有right）\r\n* element.scrollWidth 自身实际宽度\r\n* element.scrollHeight 自身实际高度\r\n* 滚动事件`element.onscroll`\r\n\r\n\r\n**草图**\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-05-20-14-21.png)\r\n\r\n\r\n**测试**\r\n\r\n<div id=\"demo1237hf834r9\">\r\n    内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n</div>\r\n<p id=\"demoNDNDURNO\"></p>\r\n<style>\r\n    #demo1237hf834r9{\r\n        width: 200px;\r\n        height: 200px;\r\n        overflow: auto;\r\n        word-break: keep-all;\r\n    }\r\n</style>\r\n<script>\r\n    var demo1237hf834r9 = document.querySelector(\"#demo1237hf834r9\")\r\n    var demoNDNDURNO = document.querySelector(\"#demoNDNDURNO\")\r\n    demo1237hf834r9.addEventListener(\"scroll\",function(){\r\n        demoNDNDURNO.innerHTML=\r\n        \"scrollTop:\" + demo1237hf834r9.scrollTop + \"<br>\" +\r\n        \"scrollLeft:\" + demo1237hf834r9.scrollLeft + \"<br>\" +\r\n        \"scrollWidth:\" + demo1237hf834r9.scrollWidth + \"<br>\" +\r\n        \"scrollHeight:\" + demo1237hf834r9.scrollHeight;\r\n    })\r\n</script>\r\n\r\n\r\n```html\r\n<div id=\"demo1237hf834r9\">\r\n    内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n    容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容\r\n</div>\r\n<p id=\"demoNDNDURNO\"></p>\r\n<style>\r\n    #demo1237hf834r9{\r\n        width: 200px;\r\n        height: 200px;\r\n        overflow: auto;\r\n        word-break: keep-all;\r\n    }\r\n</style>\r\n<script>\r\n    var demo1237hf834r9 = document.querySelector(\"#demo1237hf834r9\")\r\n    var demoNDNDURNO = document.querySelector(\"#demoNDNDURNO\")\r\n    demo1237hf834r9.addEventListener(\"scroll\",function(){\r\n        demoNDNDURNO.innerHTML=\r\n        \"scrollTop:\" + demo1237hf834r9.scrollTop + \"<br>\" +\r\n        \"scrollLeft:\" + demo1237hf834r9.scrollLeft + \"<br>\" +\r\n        \"scrollWidth:\" + demo1237hf834r9.scrollWidth + \"<br>\" +\r\n        \"scrollHeight:\" + demo1237hf834r9.scrollHeight;\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n## 页面window.scroll\r\n* 页面被卷去的头部：window.pageYoffset\r\n* 页面被卷去的左侧：window.pageXoffset\r\n* ![](./images/jsWebApis学习笔记之DOM/2022-07-05-21-52-44.png)\r\n\r\n\r\n**案例测试**\r\n\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-06-00-26-26.png)\r\n\r\n```html\r\n<body>\r\n<div id=\"demofowefj3490\">\r\n    侧边栏测试 \r\n</div>\r\n<div style=\"margin: 0 auto; width:1000px;height: 2000px; background-color: pink;\">主体内容</div>\r\n<style>\r\n    #demofowefj3490{\r\n        position: absolute;\r\n        bottom: 200px;\r\n        right: 50px;\r\n        width: 50px;\r\n        height: 200px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    var demofowefj3490 = document.querySelector(\"#demofowefj3490\")\r\n    var offsetTop = demofowefj3490.offsetTop \r\n    document.addEventListener(\"scroll\",function()\r\n    {\r\n        if(window.pageYOffset >= offsetTop)\r\n        {\r\n            demofowefj3490.style.position = \"fixed\";\r\n            demofowefj3490.style.top = \"0\";\r\n        }else\r\n        {\r\n            demofowefj3490.style.position = \"absolute\";\r\n            demofowefj3490.style.top = \"\";\r\n        }\r\n    })\r\n</script>\r\n</body>\r\n```\r\n\r\n## offset、client、scroll三系列总结\r\n* offsetWidth 元素的宽度，包含边框\r\n* clientWidth 元素的宽度，content+padding部分的宽度；不包含边框；\r\n* scrollWidth 元素内容的实际宽度，大于等于content的宽度\r\n* offset主要用来获取在页面中的偏移位置\r\n* client主要用来获取元素的宽高\r\n* offset主要用来获取被滚动条卷去的内容部分的宽高\r\n* 获取整个页面在窗口中的滚动距离用window.pageYOffset\r\n![](./images/jsWebApis学习笔记之DOM/2022-07-06-00-35-41.png)\r\n\r\n## dom核心知识点总结\r\n### 创建\r\n* `document.write()`\r\n* `element.innerHTML`  \r\n* `document.createElement()`  \r\n\r\n### 增\r\n* `node.appendChild()`\r\n* `node.insertBefore()`\r\n\r\n### 删\r\n* `node.removeChild(childNode)`\r\n\r\n### 改\r\n修改元素属性\r\n* `element.src`\r\n* `element.href`\r\n* `element.title`\r\n\r\n修改普通元素内容\r\n* `element.innerHTML`\r\n* `element.innerText`\r\n\r\n修改表单元素\r\n* `element.value`\r\n* `element.type`\r\n* `element.disabled`\r\n* 注意： `element.active` 似乎不存在\r\n\r\n修改元素样式\r\n* `element.style`\r\n* `element.className`\r\n\r\n### 查\r\nDOM的API(古老用法不推荐)\r\n* `document.getElementById()`\r\n* `document.getElementsByTagName()`\r\n\r\nH5的新方法(提倡)\r\n* `document.querySelector()`\r\n* `document.querySelectorAll()`\r\n\r\n利用节点关系获取元素\r\n* `node.parentNode`\r\n* `node.children`\r\n* `node.previousElementSibling`\r\n* `node.nextElementSibling`\r\n\r\n### 属性操作\r\n主要针对于自定义属性\r\n* `element.setAttribute(属性名,属性值)`\r\n* `element.getAttribute(属性名)`\r\n* `element.removeAttribute(属性名)`\r\n\r\n### 事件操作\r\n* `element.onclick` 鼠标点击\r\n* `element.onfocus` 获得鼠标焦点\r\n* `element.onblur` 失去鼠标焦点\r\n* `element.onmouseover` 鼠标经过\r\n* `element.onmouseout` 鼠标离开\r\n* `element.onmousemove` 鼠标移动\r\n* `element.onmouseup` 鼠标弹起触发\r\n* `element.onmousedown` 鼠标按下触发\r\n* `element.onkeyup` 键盘弹起 松开按键时会触发一次\r\n* `element.onkeydown` 键盘按下 按下后会一直不断触发\r\n* `element.onkeypress` 键盘按下，按下后会一直不断触发 但不能识别功能键，如ctrl shift\r\n* 按键事件执行顺序为down->press->up\r\n\r\n\r\n## 一些案例\r\n\r\n### 全选框\r\n\r\n<table id=\"tb1\" >\r\n    <thead>\r\n        <tr style=\"background-color: rgb(174, 174, 174);\">\r\n            <td><input type=\"checkbox\">全选</td><td>商品名称</td><td>价钱</td>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<script>\r\n    var tb1InputMaster=document.querySelector(\"#tb1>thead input\")\r\n    var tb1_btOthers=document.querySelectorAll(\"#tb1>tbody input\")\r\n    console.log(tb1InputMaster)\r\n    tb1InputMaster.onclick=function(){\r\n        if(this.checked){\r\n            for(var i = 0;i<tb1_btOthers.length;i++)\r\n            {\r\n                tb1_btOthers[i].checked=true;\r\n            }\r\n        }else{\r\n            for(var i = 0;i<tb1_btOthers.length;i++)\r\n            {\r\n                tb1_btOthers[i].checked=false;\r\n            }\r\n        }\r\n    }\r\n</script>\r\n\r\n```html\r\n<table id=\"tb1\" >\r\n    <thead>\r\n        <tr style=\"background-color: rgb(174, 174, 174);\">\r\n            <td><input type=\"checkbox\">全选</td><td>商品名称</td><td>价钱</td>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n        <tr>\r\n            <td><input type=\"checkbox\"></td><td>XXX</td><td>123元</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<script>\r\n    var tb1InputMaster=document.querySelector(\"#tb1>thead input\")\r\n    var tb1_btOthers=document.querySelectorAll(\"#tb1>tbody input\")\r\n    console.log(tb1InputMaster)\r\n    tb1InputMaster.onclick=function(){\r\n        if(this.checked){\r\n            for(var i = 0;i<tb1_btOthers.length;i++)\r\n            {\r\n                tb1_btOthers[i].checked=true;\r\n            }\r\n        }else{\r\n            for(var i = 0;i<tb1_btOthers.length;i++)\r\n            {\r\n                tb1_btOthers[i].checked=false;\r\n            }\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n### tab栏切换制作 \r\n\r\n![](./images/jsWebApis学习笔记之DOM/2022-06-30-10-37-10.png)\r\n\r\n```html\r\n<style>\r\n    #lableBox{\r\n        margin: 0 auto;\r\n        width: 600px;\r\n        height: 600px;\r\n        background-color: gray;\r\n    }\r\n    #lableBox ul{\r\n        margin: 0;\r\n        padding: 0;\r\n        list-style: none;\r\n    }\r\n    #lableBox .head ul{\r\n        display: flex;\r\n        justify-content: space-evenly;\r\n        align-items: center;\r\n        background-color: green;\r\n    }\r\n    #lableBox .head li{\r\n        flex: 1;\r\n        text-align: center;\r\n        /* background-color: red; */\r\n    }\r\n    .current{\r\n        background-color: red;\r\n    }\r\n    #lableBox .body li{\r\n        display: none;\r\n    }\r\n</style>\r\n<div id=\"lableBox\">\r\n    <div class=\"head\">\r\n        <ul>\r\n            <li class=\"current\" index=\"\">标签1</li>\r\n            <li class=\"\" index=\"\">标签2</li>\r\n            <li class=\"\" index=\"\">标签3</li>\r\n            <li class=\"\" index=\"\">标签4</li>\r\n            <li class=\"\" index=\"\">标签5</li>\r\n        </ul>\r\n    </div>\r\n    <div class=\"body\">\r\n        <ul>\r\n            <li style=\"display: block;\">内容1</li>\r\n            <li>内容2</li>\r\n            <li>内容3</li>\r\n            <li>内容4</li>\r\n            <li>内容5</li>\r\n        </ul>\r\n    </div>\r\n</div>\r\n<script>\r\n    var lables=document.querySelectorAll(\"#lableBox .head li\")\r\n    var items=document.querySelectorAll(\"#lableBox .body li\")\r\n\r\n    for(var i=0;i<lables.length;i++)//给li添加序号\r\n    {\r\n        lables[i].setAttribute(\"index\",i)\r\n    }\r\n\r\n\r\n    for(var i=0;i<lables.length;i++)\r\n    {\r\n        lables[i].onclick=function(){\r\n\r\n            for(var i=0;i<lables.length;i++)//设置所有标签背景色为空\r\n            {\r\n                lables[i].className=\"\"\r\n            }\r\n\r\n            this.className=\"current\"//设置选中的标签背景色为红色\r\n\r\n\r\n            for(var i=0;i<items.length;i++)//设置所有内容为不显示\r\n            {\r\n                items[i].style.display=\"none\"\r\n            }\r\n\r\n            items[this.getAttribute(\"index\")].style.display=\"block\"//根据选中标签索引显示内容\r\n        }\r\n    }\r\n\r\n</script>\r\n```\r\n\r\n\r\n### 新浪下拉菜单\r\n\r\n<style>\r\n    #demoQWRWEFE *,\r\n    #demoQWRWEFE *::after,\r\n    #demoQWRWEFE *::before\r\n    {\r\n        padding: 0;\r\n        margin: 0;\r\n        content: \"\";\r\n        list-style: none;\r\n    }\r\n    #demoQWRWEFE{\r\n        margin: 0 auto;\r\n        width: 500px;\r\n        /* height: 50px; */\r\n        background-color: red;\r\n    }\r\n    #demoQWRWEFE>ul{\r\n        display: flex;\r\n        justify-content: space-evenly;\r\n        align-items: center;\r\n    }\r\n    #demoQWRWEFE>ul>li{\r\n        flex: 1;\r\n        position: relative;\r\n        /* height: 50px; */\r\n        text-align: center;\r\n        background-color: green;\r\n        border: 1px solid gray;\r\n    }\r\n    #demoQWRWEFE>ul>li:hover{\r\n        background-color: rgb(1, 112, 1);\r\n    }\r\n    #demoQWRWEFE>ul>li>ul{\r\n        z-index:10;\r\n        display: none;\r\n        position: absolute;\r\n        top:100%;\r\n        left: 0;\r\n        width: 100px;\r\n        background-color: rgb(222, 222, 222);\r\n    }\r\n    #demoQWRWEFE>ul>li>ul>li:hover{\r\n        background-color: rgb(131, 131, 131);\r\n    }\r\n</style>\r\n<div id=\"demoQWRWEFE\">\r\n    <ul>\r\n        <li>\r\n            <span>标签1</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签2</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签3</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签4</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签5</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签6</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n    </ul>\r\n</div>\r\n\r\n<script>\r\n    var demoQWRWEFE=document.querySelector(\"#demoQWRWEFE\")\r\n    var lis = demoQWRWEFE.children[0].children\r\n    for(var i=0;i<lis.length;i++ )\r\n    {   \r\n        //注意是给li添加事件 而不是给 li>span 和 li>ul 分别添加事件 否则会有bug\r\n        lis[i].onmouseover=function(){\r\n            for(var i=0;i<lis.length;i++ ){\r\n                lis[i].children[1].style.display=\"\"\r\n            }\r\n            this.children[1].style.display=\"block\"\r\n        }\r\n        lis[i].onmouseout=function(){\r\n            for(var i=0;i<lis.length;i++ ){\r\n                lis[i].children[1].style.display=\"\"\r\n            }\r\n        }\r\n    }\r\n    \r\n</script>\r\n\r\n```html\r\n<style>\r\n    #demoQWRWEFE *,\r\n    #demoQWRWEFE *::after,\r\n    #demoQWRWEFE *::before\r\n    {\r\n        padding: 0;\r\n        margin: 0;\r\n        content: \"\";\r\n        list-style: none;\r\n    }\r\n    #demoQWRWEFE{\r\n        margin: 0 auto;\r\n        width: 500px;\r\n        /* height: 50px; */\r\n        background-color: red;\r\n    }\r\n    #demoQWRWEFE>ul{\r\n        display: flex;\r\n        justify-content: space-evenly;\r\n        align-items: center;\r\n    }\r\n    #demoQWRWEFE>ul>li{\r\n        flex: 1;\r\n        position: relative;\r\n        /* height: 50px; */\r\n        text-align: center;\r\n        background-color: green;\r\n        border: 1px solid gray;\r\n    }\r\n    #demoQWRWEFE>ul>li:hover{\r\n        background-color: rgb(1, 112, 1);\r\n    }\r\n    #demoQWRWEFE>ul>li>ul{\r\n        display: none;\r\n        position: absolute;\r\n        top:100%;\r\n        left: 0;\r\n        width: 100px;\r\n        background-color: rgb(222, 222, 222);\r\n    }\r\n    #demoQWRWEFE>ul>li>ul>li:hover{\r\n        background-color: rgb(131, 131, 131);\r\n    }\r\n</style>\r\n<div id=\"demoQWRWEFE\">\r\n    <ul>\r\n        <li>\r\n            <span>标签1</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签2</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签3</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签4</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签5</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        <li>\r\n            <span>标签6</span>\r\n            <ul>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n                <li>123</li>\r\n            </ul>\r\n        </li>\r\n        \r\n    </ul>\r\n</div>\r\n\r\n<script>\r\n    var demoQWRWEFE=document.querySelector(\"#demoQWRWEFE\")\r\n    var lis = demoQWRWEFE.children[0].children\r\n    for(var i=0;i<lis.length;i++ )\r\n    {   \r\n        //注意是给li添加事件 而不是给 li>span 和 li>ul 分别添加事件 否则会有bug\r\n        lis[i].onmouseover=function(){\r\n            for(var i=0;i<lis.length;i++ ){\r\n                lis[i].children[1].style.display=\"\"\r\n            }\r\n            this.children[1].style.display=\"block\"\r\n        }\r\n        lis[i].onmouseout=function(){\r\n            for(var i=0;i<lis.length;i++ ){\r\n                lis[i].children[1].style.display=\"\"\r\n            }\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n\r\n### 简单留言发布案例实现\r\n<style>\r\n    #demoQweqdqw{\r\n        margin: 0 auto;\r\n        width: 500px;\r\n        height: 500px;\r\n        background-color: gray;\r\n    }\r\n    #demoQweqdqw textarea{\r\n        display: block;\r\n        padding: 0;\r\n        margin: 0;\r\n        border: 1px solid gray;\r\n        outline: none;\r\n        box-sizing: border-box;\r\n        width: 100% !important;\r\n        min-height:100px;\r\n    }\r\n    #demoQweqdqw>button{\r\n        float: right;\r\n        display: block;\r\n        height: 20px;\r\n    }\r\n    #demoQweqdqw ul{\r\n        margin-top: 50px;\r\n        padding: 0;\r\n    }\r\n    #demoQweqdqw li{\r\n        position: relative;\r\n        list-style: none;\r\n        background-color: #fff;\r\n        margin:10px 5px;\r\n        padding-bottom:20px;\r\n        word-break: break-all;\r\n    }\r\n    #demoQweqdqw li>button{\r\n        position: absolute;\r\n        right: 0px;\r\n        bottom: 0;\r\n        float:inline-end;\r\n    }\r\n</style>\r\n<div id=\"demoQweqdqw\">\r\n    <h3>简易评论框</h3>\r\n    发表评论：\r\n    <textarea ></textarea>\r\n    <button>发布评论</button>\r\n    <ul>\r\n    </ul>\r\n</div>\r\n\r\n<script>\r\n    var textarea=document.querySelector(\"#demoQweqdqw>textarea\")\r\n    var button=document.querySelector(\"#demoQweqdqw>button\")\r\n    var ul=document.querySelector(\"#demoQweqdqw>ul\")\r\n\r\n    button.onclick=function(){\r\n        var temp=document.createElement(\"li\")\r\n        console.log(textarea.value);\r\n        if(textarea.value!='')\r\n        {\r\n            temp.innerHTML=textarea.value + \"<button>删除评论</button>\"\r\n            temp.querySelector(\"button\").onclick=function(){\r\n                ul.removeChild(this.parentNode)\r\n            }\r\n            ul.appendChild(temp)\r\n\r\n            textarea.value=\"\"\r\n        }\r\n    }\r\n</script>\r\n\r\n### 动态生成表格\r\n\r\n<style>\r\n    #demoNQEUH123{\r\n        width: 500px;\r\n        margin: 100px auto;\r\n        border-collapse: collapse;\r\n        text-align: center;\r\n    }\r\n    #demoNQEUH123 td,\r\n    #demoNQEUH123 th{\r\n        border: 1px solid #333;\r\n    }\r\n    #demoNQEUH123 thead tr{\r\n        height: 40px;\r\n        background-color: #ccc;\r\n    }\r\n\r\n</style>\r\n<table id=\"demoNQEUH123\">\r\n    <thead>\r\n        <tr>\r\n            <th>姓名</th>\r\n            <th>科目</th>\r\n            <th>成绩</th>\r\n            <th>操作</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <!-- <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr> -->\r\n    </tbody>\r\n</table>\r\n<script>\r\n    var datas=[\r\n        {\r\n            name:\"dyg\",\r\n            class:\"javascript\",\r\n            score:99.9,\r\n        },\r\n        {\r\n            name:\"kkk\",\r\n            class:\"javascript\",\r\n            score:95.9,\r\n        },\r\n        {\r\n            name:\"jjj\",\r\n            class:\"javascript\",\r\n            score:92.9,\r\n        }\r\n    ];\r\n    var tbody=document.querySelector(\"#demoNQEUH123>tbody\")\r\n    for(var i=0;i<datas.length;i++)\r\n    {\r\n        var tempTr=document.createElement(\"tr\")\r\n        for(key in datas[i])\r\n        {\r\n            console.log(key);\r\n            tempTr.innerHTML+=\"<td>\" + datas[i][key] + \"</td>\";\r\n        }\r\n        tempTr.innerHTML+=\"<td>\" + \"<a href='javascript:;'>删除数据</a>\" + \"</td>\";\r\n        tempTr.querySelector(\"a\").onclick=function(){\r\n            this.parentNode.parentNode.parentNode.removeChild(this.parentNode.parentNode)\r\n        }\r\n        tbody.appendChild(tempTr)              \r\n    }\r\n</script>\r\n\r\n```html\r\n<style>\r\n    #demoNQEUH123{\r\n        width: 500px;\r\n        margin: 100px auto;\r\n        border-collapse: collapse;\r\n        text-align: center;\r\n    }\r\n    #demoNQEUH123 td,\r\n    #demoNQEUH123 th{\r\n        border: 1px solid #333;\r\n    }\r\n    #demoNQEUH123 thead tr{\r\n        height: 40px;\r\n        background-color: #ccc;\r\n    }\r\n\r\n</style>\r\n<table id=\"demoNQEUH123\">\r\n    <thead>\r\n        <tr>\r\n            <th>姓名</th>\r\n            <th>科目</th>\r\n            <th>成绩</th>\r\n            <th>操作</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <!-- <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dyg</td>\r\n            <td>javascript</td>\r\n            <td>99.9</td>\r\n            <td>删除</td>\r\n        </tr> -->\r\n    </tbody>\r\n</table>\r\n<script>\r\n    var datas=[\r\n        {\r\n            name:\"dyg\",\r\n            class:\"javascript\",\r\n            score:99.9,\r\n        },\r\n        {\r\n            name:\"kkk\",\r\n            class:\"javascript\",\r\n            score:95.9,\r\n        },\r\n        {\r\n            name:\"jjj\",\r\n            class:\"javascript\",\r\n            score:92.9,\r\n        }\r\n    ];\r\n    var tbody=document.querySelector(\"#demoNQEUH123>tbody\")\r\n    for(var i=0;i<datas.length;i++)\r\n    {\r\n        var tempTr=document.createElement(\"tr\")\r\n        for(key in datas[i])\r\n        {\r\n            console.log(key);\r\n            tempTr.innerHTML+=\"<td>\" + datas[i][key] + \"</td>\";\r\n        }\r\n        tempTr.innerHTML+=\"<td>\" + \"<a href='javascript:;'>删除数据</a>\" + \"</td>\";\r\n        tempTr.querySelector(\"a\").onclick=function(){\r\n            this.parentNode.parentNode.parentNode.removeChild(this.parentNode.parentNode)\r\n        }\r\n        tbody.appendChild(tempTr)              \r\n    }\r\n</script>\r\n```\r\n\r\n\r\n\r\n\r\n### 实例：防止复制内容\r\n\r\n#### 禁止鼠标右键菜单\r\n```html\r\n<div id=\"demowoejf923fe\">\r\n    这是一段不能直接复制的文字\r\n</div>\r\n<script>\r\n    var div = document.querySelector(\"#demowoejf923fe\");\r\n    div.addEventListener(\"contextmenu\",function(event){\r\n        event.preventDefault()\r\n    });\r\n</script>\r\n```\r\n\r\n\r\n#### 禁止鼠标选中文字\r\n```html\r\n<div id=\"demoGEOJweoir932\">\r\n    这是一段不能直接复制的文字\r\n</div>\r\n<script>\r\n    var div = document.querySelector(\"#demoGEOJweoir932\");\r\n    // div.addEventListener(\"contextmenu\",function(event){\r\n    //     event.preventDefault()\r\n    // });\r\n    div.addEventListener(\"selectstart\",function(event){\r\n        event.preventDefault()\r\n    });\r\n</script>\r\n```\r\n\r\n#### 禁止f12键\r\n```js\r\ndocument.addEventListener(\"keydown\",function(event){\r\n    if(event.keyCode==123)\r\n    {\r\n        event.preventDefault()\r\n    }\r\n})\r\n```\r\n\r\n\r\n\r\n### 实例：阻止链接跳转\r\n```html\r\n//两种方法\r\n<a href=\"javascript:;\"></a>\r\n<a href=\"javascript:void(0);\"></a>\r\n```"},{"shortInfo":{"title":"js动画","date":"2022-07-05T17:07:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["动画","js"],"hideAtIndex":true,"categories":"笔记","id":26,"countWords":2036,"readSeconds":203.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# js动画\r\n\r\n## 动画实现原理\r\n核心原理：通过定时器setinterval()不断移动盒子位置\r\n* 利用offset获取当前位置\r\n* 通过css定位设置新位置\r\n\r\n```html\r\n<div id=\"demoNOUH98u9\"></div>\r\n<style>\r\n    #demoNOUH98u9{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    var demoNOUH98u9 = document.querySelector(\"#demoNOUH98u9\")\r\n    var timer = setInterval(function(){\r\n        if(demoNOUH98u9.offsetLeft>=200)\r\n        {\r\n            clearInterval(timer)\r\n        }\r\n        demoNOUH98u9.style.left = demoNOUH98u9.offsetLeft + 1 + \"px\"\r\n    },50)\r\n</script>\r\n```\r\n\r\n## 封装成函数\r\n### 一般写法\r\n\r\n```html\r\n<div id=\"demoNOUH98123\"></div>\r\n<style>\r\n    #demoNOUH98123{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    var demoNOUH98123 = document.querySelector(\"#demoNOUH98123\")\r\n    function animate(elementObj,target){\r\n        var timer = setInterval(function(){\r\n        if(elementObj.offsetLeft>=target)\r\n        {\r\n            clearInterval(timer)\r\n        }\r\n        elementObj.style.left = elementObj.offsetLeft + 1 + \"px\"\r\n    },50)\r\n    }\r\n    animate(demoNOUH98123,200)\r\n</script>\r\n```\r\n\r\n### 优化写法\r\n\r\n<button id=\"demoNOUHdwee\">测试</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demoNOUH98456\"></div>\r\n</div>\r\n<style>\r\n    #demoNOUH98456{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n(function(){\r\n    var demoNOUH98456 = document.querySelector(\"#demoNOUH98456\")\r\n    var demoNOUHdwee = document.querySelector(\"#demoNOUHdwee\")\r\n    function animate(elementObj,target){\r\n        //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n        clearInterval(elementObj.timer)\r\n        //elementObj.timer可以避免反复申请内存\r\n        elementObj.timer = setInterval(function(){\r\n        if(elementObj.offsetLeft>=target)\r\n        {\r\n            clearInterval(elementObj.timer)\r\n        }\r\n        elementObj.style.left = elementObj.offsetLeft + 1 + \"px\"\r\n    },15)\r\n    }\r\n    demoNOUHdwee.addEventListener(\"click\",function(){\r\n        animate(demoNOUH98456,200)\r\n    })\r\n})();\r\n</script>\r\n\r\n```html\r\n<button id=\"demoNOUHdwee\">测试</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demoNOUH98456\"></div>\r\n</div>\r\n<style>\r\n    #demoNOUH98456{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n(function(){\r\n    var demoNOUH98456 = document.querySelector(\"#demoNOUH98456\")\r\n    var demoNOUHdwee = document.querySelector(\"#demoNOUHdwee\")\r\n    function animate(elementObj,target){\r\n        //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n        clearInterval(elementObj.timer)\r\n        //elementObj.timer可以避免反复申请内存\r\n        elementObj.timer = setInterval(function(){\r\n        if(elementObj.offsetLeft>=target)\r\n        {\r\n            clearInterval(elementObj.timer)\r\n        }\r\n        elementObj.style.left = elementObj.offsetLeft + 1 + \"px\"\r\n    },15)\r\n    }\r\n    demoNOUHdwee.addEventListener(\"click\",function(){\r\n        animate(demoNOUH98456,200)\r\n    })\r\n})();\r\n</script>\r\n```\r\n\r\n## 缓动动画\r\n* 原理：让盒子每次移动的距离慢慢变小，移动速度就会慢下来\r\n* 公式：步长 =（目标值-当前值）/10\r\n* 注意\r\n    * 需要向上或向下取整，否则，根据公式，步长将会无限接近0，这就导致(当前值+步长)永远无法到达目标值\r\n    * 如果步长是负数则应该向下取整，如果步长是正数则应该向上取整。\r\n        * 如果步长是0.1，则应该向上取整，步长应为1\r\n        * 如果步长是-0.1，则应该向下取整，步长应为-1\r\n    * 若只需要单方向移动，判断条件写成这样是没问题的：\r\n        * `elementObj.offsetLeft>=target` 左移\r\n        * `elementObj.offsetLeft<=target` 右移\r\n    * 若需要允许左右方向移动，判断条件应该写成：\r\n        * `elementObj.offsetLeft==target` \r\n        * 需要配合判断步长的正负性对其上下取整\r\n\r\n**公式测试**\r\n\r\n<button id=\"demoNOUHdw123we\">测试</button>\r\n<button id=\"demoNOUHddfwefe\">复位</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demoNOUH9fe12we\"></div>\r\n</div>\r\n<style>\r\n    #demoNOUH9fe12we{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    (function(){\r\n        var demoNOUH9fe12we = document.querySelector(\"#demoNOUH9fe12we\")\r\n        var demoNOUHdw123we = document.querySelector(\"#demoNOUHdw123we\")\r\n        var demoNOUHddfwefe = document.querySelector(\"#demoNOUHddfwefe\")\r\n        function animate(elementObj, target) {\r\n            //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            clearInterval(elementObj.timer)\r\n            //elementObj.timer可以避免反复申请内存\r\n            elementObj.timer = setInterval(function () {\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                }\r\n                //根据公式计算步长\r\n                var step = (target - elementObj.offsetLeft) / 10\r\n                //如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        demoNOUHdw123we.addEventListener(\"click\", function () {\r\n            animate(demoNOUH9fe12we, 200)\r\n        })\r\n        demoNOUHddfwefe.addEventListener(\"click\", function () {\r\n            animate(demoNOUH9fe12we, 0)\r\n        })\r\n    })();\r\n</script>\r\n\r\n```html\r\n<button id=\"demoNOUHdw123we\">测试</button>\r\n<button id=\"demoNOUHddfwefe\">复位</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demoNOUH9fe12we\"></div>\r\n</div>\r\n<style>\r\n    #demoNOUH9fe12we{\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    (function(){\r\n        var demoNOUH9fe12we = document.querySelector(\"#demoNOUH9fe12we\")\r\n        var demoNOUHdw123we = document.querySelector(\"#demoNOUHdw123we\")\r\n        var demoNOUHddfwefe = document.querySelector(\"#demoNOUHddfwefe\")\r\n        function animate(elementObj, target) {\r\n            //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            clearInterval(elementObj.timer)\r\n            //elementObj.timer可以避免反复申请内存\r\n            elementObj.timer = setInterval(function () {\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                }\r\n                //根据公式计算步长\r\n                var step = (target - elementObj.offsetLeft) / 10\r\n                //如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        demoNOUHdw123we.addEventListener(\"click\", function () {\r\n            animate(demoNOUH9fe12we, 200)\r\n        })\r\n        demoNOUHddfwefe.addEventListener(\"click\", function () {\r\n            animate(demoNOUH9fe12we, 0)\r\n        })\r\n    })();\r\n</script>\r\n```\r\n\r\n## 缓动动画函数添加回调函数\r\n\r\n\r\n\r\n### 回调函数\r\n```js\r\nfunction fuc(其他形式参数,callback){\r\n    //do sthing...\r\n    //判断是否传入了回调函数\r\n    if(callback)\r\n    {\r\n        callback();\r\n    }\r\n}\r\nfuc(其他实参,function(){\r\n    //do sthing...\r\n})\r\n```\r\n\r\n### 具体实现\r\n\r\n<button id=\"demonvefoijgfwf\">测试</button>\r\n<button id=\"demofjewoifjw12\">复位</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demofweijp090\"></div>\r\n</div>\r\n<style>\r\n    #demofweijp090 {\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    (function () {\r\n        var demofweijp090 = document.querySelector(\"#demofweijp090\")\r\n        var demonvefoijgfwf = document.querySelector(\"#demonvefoijgfwf\")\r\n        var demofjewoifjw12 = document.querySelector(\"#demofjewoifjw12\")\r\n        function animate(elementObj, target, callback) {\r\n            //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            clearInterval(elementObj.timer)\r\n            //elementObj.timer可以避免反复申请内存\r\n            elementObj.timer = setInterval(function () {\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                    if (callback) {\r\n                        callback();\r\n                    }\r\n                }\r\n                //根据公式计算步长\r\n                var step = (target - elementObj.offsetLeft) / 10\r\n                //如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        demonvefoijgfwf.addEventListener(\"click\", function () {\r\n            animate(demofweijp090, 200, function () {\r\n                demofweijp090.style.backgroundColor = \"pink\"\r\n            })\r\n        })\r\n        demofjewoifjw12.addEventListener(\"click\", function () {\r\n            animate(demofweijp090, 0, function () {\r\n                demofweijp090.style.backgroundColor = \"green\"\r\n            })\r\n        })\r\n    })();\r\n</script>\r\n\r\n```html\r\n<button id=\"demonvefoijgfwf\">测试</button>\r\n<button id=\"demofjewoifjw12\">复位</button>\r\n<div style=\"position:relative;height: 100px;\">\r\n    <div id=\"demofweijp090\"></div>\r\n</div>\r\n<style>\r\n    #demofweijp090 {\r\n        position: absolute;\r\n        width: 100px;\r\n        height: 100px;\r\n        background-color: skyblue;\r\n    }\r\n</style>\r\n<script>\r\n    (function () {\r\n        var demofweijp090 = document.querySelector(\"#demofweijp090\")\r\n        var demonvefoijgfwf = document.querySelector(\"#demonvefoijgfwf\")\r\n        var demofjewoifjw12 = document.querySelector(\"#demofjewoifjw12\")\r\n        function animate(elementObj, target, callback) {\r\n            //clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            clearInterval(elementObj.timer)\r\n            //elementObj.timer可以避免反复申请内存\r\n            elementObj.timer = setInterval(function () {\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                    if (callback) {\r\n                        callback();\r\n                    }\r\n                }\r\n                //根据公式计算步长\r\n                var step = (target - elementObj.offsetLeft) / 10\r\n                //如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        demonvefoijgfwf.addEventListener(\"click\", function () {\r\n            animate(demofweijp090, 200, function () {\r\n                demofweijp090.style.backgroundColor = \"pink\"\r\n            })\r\n        })\r\n        demofjewoifjw12.addEventListener(\"click\", function () {\r\n            animate(demofweijp090, 0, function () {\r\n                demofweijp090.style.backgroundColor = \"green\"\r\n            })\r\n        })\r\n    })();\r\n</script>\r\n```\r\n\r\n## 动画核心代码\r\n\r\n**animate.js**\r\n\r\n```js\r\nfunction animate(elementObj, target, callback) {\r\n    clearInterval(elementObj.timer)//clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n    elementObj.timer = setInterval(function () {//elementObj.timer可以避免反复申请内存\r\n        if (elementObj.offsetLeft == target) {\r\n            clearInterval(elementObj.timer)\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        }\r\n        var step = (target - elementObj.offsetLeft) / 10 //根据公式计算步长\r\n        step = step > 0 ? Math.ceil(step) : Math.floor(step)//如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n        elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n    }, 15)\r\n}\r\n```\r\n\r\n\r\n## 动画案例：侧边栏\r\n\r\n<div id=\"demo83492379\">\r\n    <div class=\"more\">→</div>\r\n    <div class=\"more-address\">了解更多</div>\r\n</div>\r\n<style>\r\n    #demo83492379{\r\n        position: relative;\r\n        height: 50px;\r\n        width: 50px;\r\n        background-color: pink;\r\n        overflow: visible;\r\n        word-break: keep-all;\r\n    }\r\n    #demo83492379 .more{\r\n        z-index: 2;\r\n        position: relative;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        font-size: 25px;\r\n        line-height: 50px;\r\n        text-align: center;\r\n    }\r\n    #demo83492379 .more-address{\r\n        position: absolute;\r\n        left: -500px;\r\n        top: 0;\r\n        display: inline-block;\r\n        padding: 0 10px;\r\n        padding-left: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        font-size: 25px;\r\n        line-height: 50px;\r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n(function(){\r\n    var more = document.querySelector(\"#demo83492379 .more\")\r\n    var more_address = document.querySelector(\"#demo83492379 .more-address\")\r\n    more_address.style.left=-more_address.offsetWidth+\"px\"\r\n    more.addEventListener(\"mouseenter\",function(){\r\n        animate(more_address,0,function(){\r\n            more.innerHTML=\"←\"\r\n        })\r\n    })\r\n    more.addEventListener(\"mouseleave\",function(){\r\n        animate(more_address,-more_address.offsetWidth,function(){\r\n            more.innerHTML=\"→\"\r\n        })\r\n    })\r\n    function animate(elementObj, target, callback) {\r\n    clearInterval(elementObj.timer)//clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n    elementObj.timer = setInterval(function () {//elementObj.timer可以避免反复申请内存\r\n        if (elementObj.offsetLeft == target) {\r\n            clearInterval(elementObj.timer)\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        }\r\n        var step = (target - elementObj.offsetLeft) / 10 //根据公式计算步长\r\n        step = step > 0 ? Math.ceil(step) : Math.floor(step)//如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n        elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n    }, 15)\r\n}\r\n})();\r\n</script>\r\n\r\n\r\n```html\r\n<div id=\"demo83492379\">\r\n    <div class=\"more\">→</div>\r\n    <div class=\"more-address\">了解更多</div>\r\n</div>\r\n<style>\r\n    #demo83492379{\r\n        position: relative;\r\n        height: 50px;\r\n        width: 50px;\r\n        background-color: pink;\r\n        overflow: visible;\r\n        word-break: keep-all;\r\n    }\r\n    #demo83492379 .more{\r\n        z-index: 2;\r\n        position: relative;\r\n        width: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        font-size: 25px;\r\n        line-height: 50px;\r\n        text-align: center;\r\n    }\r\n    #demo83492379 .more-address{\r\n        position: absolute;\r\n        left: -500px;\r\n        top: 0;\r\n        display: inline-block;\r\n        padding: 0 10px;\r\n        padding-left: 50px;\r\n        height: 50px;\r\n        background-color: black;\r\n        font-size: 25px;\r\n        line-height: 50px;\r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n(function(){\r\n    var more = document.querySelector(\"#demo83492379 .more\")\r\n    var more_address = document.querySelector(\"#demo83492379 .more-address\")\r\n    more_address.style.left=-more_address.offsetWidth+\"px\"\r\n    more.addEventListener(\"mouseenter\",function(){\r\n        animate(more_address,0,function(){\r\n            more.innerHTML=\"←\"\r\n        })\r\n    })\r\n    more.addEventListener(\"mouseleave\",function(){\r\n        animate(more_address,-more_address.offsetWidth,function(){\r\n            more.innerHTML=\"→\"\r\n        })\r\n    })\r\n    function animate(elementObj, target, callback) {\r\n    clearInterval(elementObj.timer)//clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n    elementObj.timer = setInterval(function () {//elementObj.timer可以避免反复申请内存\r\n        if (elementObj.offsetLeft == target) {\r\n            clearInterval(elementObj.timer)\r\n            if (callback) {\r\n                callback();\r\n            }\r\n        }\r\n        var step = (target - elementObj.offsetLeft) / 10 //根据公式计算步长\r\n        step = step > 0 ? Math.ceil(step) : Math.floor(step)//如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n        elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n    }, 15)\r\n}\r\n})();\r\n</script>\r\n```"},{"shortInfo":{"title":"js返回顶部","date":"2022-07-06T13:33:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["返回顶部","js"],"hideAtIndex":true,"categories":"笔记","id":27,"countWords":766,"readSeconds":76.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# js返回顶部\r\n\r\n## 主要思路\r\n* 需要有动态效果\r\n* 需要重新封装animate动画函数\r\n* `window.scroll(x,y)` 函数用于设置页面窗口滚动位置\r\n* `window.pageYOffset` 窗口滚动内容的上边距\r\n\r\n## 结束条件的问题\r\n由于鼠标滚动的原因，`window.pageYOffset`是含小数部分的，且目标位置`target`是整数，计算的步长`step`也是取整数，  \r\n这就导致`window.pageYOffset+step`永远也不会等于target   \r\n所以结束的判断条件只判断整数部分就好了：  \r\n```js\r\nif(parseInt(window.pageYOffset)==parseInt(targetY))\r\n{\r\n\r\n}\r\n```\r\n\r\n## 防止目标值过大的问题\r\n如果body的高度只有1000px，而指定target到2000px，这是不可能实现的，这会导致页面滚动到底部，且无法拖动滚动条，所以需要计算出target的最大值，以对其进行限制\r\n\r\n**相关属性**\r\n* `window.innerHeight`表示窗口内容区域的高度，这是不包括边框、菜单栏的。\r\n* `window.outerHeight`是窗口的整体高度，包括边框、菜单栏等。\r\n* `document.body.offsetHeight` 可以获得页面的高度\r\n\r\n所以，可以计算出当页面滚动条在底部时，pageYOffset的高度为：`document.body.offsetHeight-window.innerHeight`\r\n\r\n## 保持X轴的滚动条位置不变\r\n\r\n只需要把X偏移保持就好了\r\n\r\n```js\r\n\r\nwindow.scroll(window.pageXOffset, x的偏移 )\r\n\r\n```\r\n\r\n\r\n## 效果及源码\r\n\r\n<button id=\"returnTop\">动态返回顶部</button>\r\n<button id=\"returnMiddle\">动态返回中部</button>\r\n<button id=\"returnBottom\">动态返回底部</button>\r\n<script>\r\n    var returnTop = document.querySelector(\"#returnTop\")\r\n    var returnBottom = document.querySelector(\"#returnBottom\")\r\n    var returnMiddle = document.querySelector(\"#returnMiddle\")\r\n    returnTop.addEventListener(\"click\", function () {\r\n        //返回顶部\r\n        animateWinScrollToY(0);\r\n    })\r\n    returnBottom.addEventListener(\"click\", function () {\r\n        //返回底部\r\n        animateWinScrollToY(document.body.offsetHeight - window.innerHeight);\r\n    })\r\n    returnMiddle.addEventListener(\"click\", function () {\r\n        //返回中部\r\n        animateWinScrollToY( (document.body.offsetHeight - window.innerHeight) /2);\r\n    })\r\n    function animateWinScrollToY(targetY, callback) {\r\n        if (document.body.offsetHeight - window.innerHeight >= targetY) {//防止targetY过大导致死循环\r\n            clearInterval(window.returnTopTimer)//防止被反复调用\r\n            window.returnTopTimer = setInterval(function () {\r\n                if (parseInt(window.pageYOffset) == parseInt(targetY))//因为滚动的距离存在小数，所以这里只判断整数部分是否接近就好了\r\n                {\r\n                    clearInterval(window.returnTopTimer);\r\n                    callback && callback();\r\n                    // console.log(\"到达目标位置\");\r\n                }\r\n                else\r\n                {\r\n                    window.step = (targetY - window.pageYOffset) / 10 //根据公式计算步长\r\n                    window.step = window.step <= 0 ? Math.floor(window.step) : Math.ceil(window.step); //上下取整，防止小数\r\n                    window.scroll(window.pageXOffset, window.pageYOffset + window.step);\r\n                }\r\n            }, 15)\r\n        }\r\n    }\r\n</script>\r\n\r\n```html\r\n<button id=\"returnTop\">动态返回顶部</button>\r\n<button id=\"returnMiddle\">动态返回中部</button>\r\n<button id=\"returnBottom\">动态返回底部</button>\r\n<script>\r\n    var returnTop = document.querySelector(\"#returnTop\")\r\n    var returnBottom = document.querySelector(\"#returnBottom\")\r\n    var returnMiddle = document.querySelector(\"#returnMiddle\")\r\n    returnTop.addEventListener(\"click\", function () {\r\n        //返回顶部\r\n        animateWinScrollToY(0);\r\n    })\r\n    returnBottom.addEventListener(\"click\", function () {\r\n        //返回底部\r\n        animateWinScrollToY(document.body.offsetHeight - window.innerHeight);\r\n    })\r\n    returnMiddle.addEventListener(\"click\", function () {\r\n        //返回中部\r\n        animateWinScrollToY( (document.body.offsetHeight - window.innerHeight) /2);\r\n    })\r\n    function animateWinScrollToY(targetY, callback) {\r\n        if (document.body.offsetHeight - window.innerHeight >= targetY) {//防止targetY过大导致死循环\r\n            clearInterval(window.returnTopTimer)//防止被反复调用\r\n            window.returnTopTimer = setInterval(function () {\r\n                if (parseInt(window.pageYOffset) == parseInt(targetY))//因为滚动的距离存在小数，所以这里只判断整数部分是否接近就好了\r\n                {\r\n                    clearInterval(window.returnTopTimer);\r\n                    callback && callback();\r\n                    // console.log(\"到达目标位置\");\r\n                }\r\n                else\r\n                {\r\n                    window.step = (targetY - window.pageYOffset) / 10 //根据公式计算步长\r\n                    window.step = window.step <= 0 ? Math.floor(window.step) : Math.ceil(window.step); //上下取整，防止小数\r\n                    window.scroll(window.pageXOffset, window.pageYOffset + window.step);\r\n                }\r\n            }, 15)\r\n        }\r\n    }\r\n</script>\r\n```"},{"shortInfo":{"title":"js高级学习笔记","date":"2022-08-28T21:04:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["javascript","js","高级"],"hideAtIndex":true,"categories":"笔记","id":28,"countWords":708,"readSeconds":70.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# js高级学习笔记\r\n## 目录\r\n- [js高级学习笔记](#js高级学习笔记)\r\n  - [目录](#目录)\r\n  - [正则表达式](#正则表达式)\r\n    - [基本语法格式](#基本语法格式)\r\n    - [正则在search()和replace()中的使用](#正则在search和replace中的使用)\r\n    - [RegExp 对象](#regexp-对象)\r\n\r\n<!-- ## ES6模块化规范\r\n**早期社区版的模块化解决方案**\r\n* AMD CMD 用于浏览器的模块化规范\r\n* commonJS 用于服务端的模块化规范\r\n\r\n**当前ES6模块化规范**\r\n* 官方的模块化规范\r\n* 前端和后端共同的模块化规范 -->\r\n\r\n\r\n## 正则表达式\r\n### 基本语法格式\r\n`/正则表达式主体/修饰符(可选)`\r\n* 修饰符:\r\n    * i 不区分大小写\r\n    * g 全局匹配\r\n    * m 多行匹配\r\n* 范围查找:\r\n    * `[abc]`\t查找方括号之间的任何字符。\r\n    * `[0-9]`\t查找任何从 0 至 9 的数字。\r\n    * `(x|y)`\t查找任何以 | 分隔的选项。\r\n* 特殊字符:\r\n    * `\\d`\t    查找数字。\r\n    * `\\s`\t    查找空白字符。\r\n    * `\\b`\t    匹配单词边界。\r\n    * `\\uxxxx`\t查找以十六进制数 xxxx 规定的 Unicode 字符。\r\n* 量词:\r\n    * `n+`\t匹配任何包含至少一个 n 的字符串。\r\n    * `n*`\t匹配任何包含零个或多个 n 的字符串。\r\n    * `n?`\t匹配任何包含零个或一个 n 的字符串。\r\n\r\n### 正则在search()和replace()中的使用\r\n* `str.search(字符串或正则表达式)` 返回查找到的第一个子字符串的下标\r\n* `str.replace(字符串A或正则表达式A,字符串B)` 替换A为B\r\n\r\n\r\n### RegExp 对象\r\n在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。\r\n\r\n**创建对象**\r\n```js\r\nvar patt=new RegExp(正则表达式主体,修饰符);\r\nvar rpatte = new RegExp(\"\\\\w+\");\r\n// 或者更简单的方式:\r\nvar patt=/正则表达式主体/修饰符;\r\n```\r\n\r\n**RegExp方法**\r\n* `reg.exec(string)`    检索字符串中的正则表达式的匹配。返回该匹配值，否则返回null。\r\n* `reg.test()`    检测一个字符串是否匹配某个模式。返回 true 或 false。\r\n* `reg.toString()`    返回正则表达式的字符串值\r\n\r\n**RegExp属性**\r\n* `reg.constructor` 返回一个函数，该函数是一个创建 RegExp 对象的原型。\r\n* `reg.global`  判断是否设置了 \"g\" 修饰符\r\n* `reg.ignoreCase`  判断是否设置了 \"i\" 修饰符\r\n* `reg.multiline`   判断是否设置了 \"m\" 修饰符\r\n* `reg.lastIndex`   用于规定下次匹配的起始位置\r\n* `reg.source`  返回正则表达式的匹配模式\r\n\r\n**支持正则表达式的 String 对象的方法**\r\n* `str.search(字符串或正则)`\t检索与正则表达式相匹配的值\r\n* `str.match()`\t找到一个或多个正则表达式的匹配\r\n* `str.replace()`\t替换与正则表达式匹配的子串\r\n* `str.split()`\t把字符串分割为字符串数组\r\n\r\n\r\n```js\r\nvar regOBJ = /正则表达方式/i\r\n```"},{"shortInfo":{"layout":"post","title":"jupyter备忘笔记","date":"2022-01-29T12:09:00.000Z","cover":"\\self_server\\assets\\images\\jupyter.png","tags":["笔记","jupyter"],"hideAtIndex":true,"categories":"笔记","id":29,"countWords":434,"readSeconds":43.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# jupyter备忘笔记\r\n\r\n## c++ jupyter环境的安装\r\n1. 关闭系统代理否则可能无法创建环境\r\n1. 用conda创建环境 `conda create --name cPlusPlus`\r\n1. 查看现有环境 `conda env list`\r\n1. 激活 cPlusPlus 环境`conda activate cPlusPlus`\r\n1. 先安装jupyter(再安装C++解析器)`conda install jupyter`\r\n1. 安装C++ 解析器xeus-cling(现仅支持mac linux)\r\n    `conda install -c conda-forge xeus-cling`\r\n    * 如果在ubuntu20中安装时报错提示缺失zlib（zconf.h zlib.h libz.a zlib.pc）\r\n        * 安装缺失zlib\r\n        `conda install zlib` \r\n    * 如果在jupyter中提示内核无法启动，查询xeus-cling的github文档得知需安装如下依赖\r\n        * xeus-cling的依赖：\r\n            `xeus xtl cling pugixml cxxopts nlohmann_json`\r\n        * 安装当前版本xeus-cling要求依赖的指定版本：\r\n            `conda install cmake \"xeus>=2.0,<3.0\" cling=0.8 clangdev=5.0.0 llvmdev=5 \"nlohmann_json>=3.9.1,<3.10\" \"cppzmq>=4.6.0,<5\" \"xtl>=0.7,<0.8\" pugixml \"cxxopts>=2.1.1,<2.2\" -c conda-forge`\r\n1. 启动jupyter:\r\n    `jupyter notebook`\r\n\r\n## 允许远程访问\r\n1. 生成配置文件 `~/.jupyter/jupyter_notebook_config.py `\r\n    * `jupyter notebook --generate-config`\r\n1. 生成密码hash值\r\n    * 方法1\r\n        * 用命令生成密码hash值`jupyter notebook password`\r\n        * 打开 jupyter_notebook_config.json提取生成的sha1值\r\n    * 方法2\r\n        * 在pythonShell中输入`from notebook.auth import passwd; passwd();`按提示输入两次密码后将返回密码hash值\r\n1. 修改jupyter_notebook_config.py\r\n    * c.NotebookApp.password=由密码生成的sha1值 \r\n    * c.NotebookApp.ip='*'       #在所有的网卡接口上开启服务。同\"0.0.0.0\"\r\n    * c.NotebookApp.port =8888 #可自行指定一个端口, 访问时使用该端口7777\r\n    * c.NotebookApp.allow_remote_access = True  #允许远程\r\n\r\n## jupyter无法导出其他格式的问题\r\n* pip uninstall nbconvert\r\n* pip install nbconvert\r\n\r\n##### tips:\r\n* conda-forge是可以安装软件包的附加渠道\r\n* -c或--channel表示切换频道\r\n* conda install -c some-channel packagename\r\n"},{"shortInfo":{"title":"kaTex使用","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-05-31T19:06:10.820Z","modified":"2022-05-31T19:13:16.456Z","tags":["kaTex"],"hideAtIndex":true,"id":31,"countWords":182,"readSeconds":18.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# kaTex使用\r\n* KaTeX排版系统核心库\r\n```html\r\n<!-- KaTeX requires the use of the HTML5 doctype. Without it, KaTeX may not render properly -->\r\n<link rel=\"stylesheet\" href=\"/libs/katex/v0.15.6/katex.min.css\" >\r\n<!-- The loading of KaTeX is deferred to speed up page rendering -->\r\n<script defer src=\"/libs/katex/v0.15.6/katex.min.js\" ></script>\r\n```\r\n* 用于自动渲染的KaTeX扩展库\r\n```html\r\n<!-- To automatically render math in text elements, include the auto-render extension: -->\r\n<script defer src=\"/libs/katex/v0.15.6/contrib/auto-render.min.js\" ></script>\r\n<script>\r\n    document.addEventListener(\"DOMContentLoaded\", function() {\r\n        renderMathInElement(document.body, {\r\n          // customised options\r\n          delimiters: [\r\n              {left: '$$', right: '$$', display: true},\r\n              {left: '$', right: '$', display: false},\r\n              {left: '\\\\(', right: '\\\\)', display: true},\r\n              {left: '\\\\[', right: '\\\\]', display: false}\r\n          ],\r\n          // • rendering keys, e.g.:\r\n          throwOnError : true\r\n        });\r\n    });\r\n</script>\r\n```\r\n* 允许复制tex公式时复制其源代码的扩展库\r\n```html\r\n<link href=\"/libs/katex/v0.15.6/contrib/copy-tex.css\" rel=\"stylesheet\" type=\"text/css\">\r\n<script src=\"/libs/katex/v0.15.6/contrib/copy-tex.min.js\"></script>\r\n\r\n```\r\n"},{"shortInfo":{"title":"KaTeX数学公式语法官方文档","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-05-31T15:10:17.339Z","modified":"2022-05-31T16:22:18.928Z","tags":["KaTeX"],"hideAtIndex":true,"id":30,"countWords":4879,"readSeconds":487.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# KaTeX数学公式语法官方文档\r\n\r\nThis is a list of TeX functions supported by KaTeX. It is sorted into logical groups.\r\n\r\nThere is a similar [Support Table](support_table.md), sorted alphabetically, that lists both supported and un-supported functions.\r\n\r\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css\" integrity=\"sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs\" crossorigin=\"anonymous\">\r\n<style>\r\np {overflow-wrap: break-word;}\r\ntable tr,\r\ntable td {\r\n    vertical-align: middle;\r\n    overflow-wrap: break-word;\r\n}\r\n</style>\r\n\r\n<div class=\"katex-hopscotch\">\r\n\r\n## Accents\r\n\r\n||||\r\n|:----------------------------|:----------------------------------------------------|:------\r\n|$a'$ `a'`  |$\\tilde{a}$ `\\tilde{a}`|$\\mathring{g}$ `\\mathring{g}`\r\n|$a''$ `a''`|$\\widetilde{ac}$ `\\widetilde{ac}`  |$\\overgroup{AB}$ `\\overgroup{AB}`\r\n|$a^{\\prime}$ `a^{\\prime}` |$\\utilde{AB}$ `\\utilde{AB}`  |$\\undergroup{AB}$ `\\undergroup{AB}`\r\n|$\\acute{a}$ `\\acute{a}`|$\\vec{F}$ `\\vec{F}` |$\\Overrightarrow{AB}$ `\\Overrightarrow{AB}`\r\n|$\\bar{y}$ `\\bar{y}` |$\\overleftarrow{AB}$ `\\overleftarrow{AB}`|$\\overrightarrow{AB}$ `\\overrightarrow{AB}`\r\n|$\\breve{a}$ `\\breve{a}`|$\\underleftarrow{AB}$ `\\underleftarrow{AB}` |$\\underrightarrow{AB}$ `\\underrightarrow{AB}`\r\n|$\\check{a}$ `\\check{a}`|$\\overleftharpoon{ac}$ `\\overleftharpoon{ac}`  |$\\overrightharpoon{ac}$ `\\overrightharpoon{ac}`\r\n|$\\dot{a}$ `\\dot{a}` |$\\overleftrightarrow{AB}$ `\\overleftrightarrow{AB}`  |$\\overbrace{AB}$ `\\overbrace{AB}`\r\n|$\\ddot{a}$ `\\ddot{a}`  |$\\underleftrightarrow{AB}$ `\\underleftrightarrow{AB}`|$\\underbrace{AB}$ `\\underbrace{AB}`\r\n|$\\grave{a}$ `\\grave{a}`|$\\overline{AB}$ `\\overline{AB}` |$\\overlinesegment{AB}$ `\\overlinesegment{AB}`\r\n|$\\hat{\\theta}$ `\\hat{\\theta}`|$\\underline{AB}$ `\\underline{AB}`  |$\\underlinesegment{AB}$ `\\underlinesegment{AB}`\r\n|$\\widehat{ac}$ `\\widehat{ac}`|$\\widecheck{ac}$ `\\widecheck{ac}`  |$\\underbar{X}$ `\\underbar{X}`\r\n\r\n***Accent functions inside \\\\text{…}***\r\n\r\n|||||\r\n|:---------------------|:---------------------|:---------------------|:-----\r\n|$\\text{\\'{a}}$ `\\'{a}`|$\\text{\\~{a}}$ `\\~{a}`|$\\text{\\.{a}}$ `\\.{a}`|$\\text{\\H{a}}$ `\\H{a}`\r\n|$\\text{\\`{a}}$ <code>\\\\`{a}</code>|$\\text{\\={a}}$ `\\={a}`|$\\text{\\\"{a}}$ `\\\"{a}`|$\\text{\\v{a}}$ `\\v{a}`\r\n|$\\text{\\^{a}}$ `\\^{a}`|$\\text{\\u{a}}$ `\\u{a}`|$\\text{\\r{a}}$ `\\r{a}`|\r\n\r\nSee also [letters and unicode](#letters-and-unicode).\r\n\r\n## Delimiters\r\n\r\n||||||\r\n|:-----------------------------------|:---------------------------------------|:----------|:-------------------------------------------------------|:-----\r\n|$(~)$ `( )` |$\\lparen~\\rparen$ `\\lparen`<br>$~~~~$`\\rparen`|$⌈~⌉$ `⌈ ⌉`|$\\lceil~\\rceil$ `\\lceil`<br>$~~~~~$`\\rceil`  |$\\uparrow$ `\\uparrow`\r\n|$[~]$ `[ ]` |$\\lbrack~\\rbrack$ `\\lbrack`<br>$~~~~$`\\rbrack`|$⌊~⌋$ `⌊ ⌋`|$\\lfloor~\\rfloor$ `\\lfloor`<br>$~~~~~$`\\rfloor` |$\\downarrow$ `\\downarrow`\r\n|$\\{ \\}$ `\\{ \\}`|$\\lbrace \\rbrace$ `\\lbrace`<br>$~~~~$`\\rbrace`|$⎰⎱$ `⎰⎱`  |$\\lmoustache \\rmoustache$ `\\lmoustache`<br>$~~~~$`\\rmoustache`|$\\updownarrow$ `\\updownarrow`\r\n|$⟨~⟩$ `⟨ ⟩` |$\\langle~\\rangle$ `\\langle`<br>$~~~~$`\\rangle`|$⟮~⟯$ `⟮ ⟯`|$\\lgroup~\\rgroup$ `\\lgroup`<br>$~~~~~$`\\rgroup` |$\\Uparrow$ `\\Uparrow`\r\n|$\\vert$ <code>&#124;</code> |$\\vert$ `\\vert` |$┌ ┐$ `┌ ┐`|$\\ulcorner \\urcorner$ `\\ulcorner`<br>$~~~~$`\\urcorner`  |$\\Downarrow$ `\\Downarrow`\r\n|$\\Vert$ <code>&#92;&#124;</code> |$\\Vert$ `\\Vert` |$└ ┘$ `└ ┘`|$\\llcorner \\lrcorner$ `\\llcorner`<br>$~~~~$`\\lrcorner`  |$\\Updownarrow$ `\\Updownarrow`\r\n|$\\lvert~\\rvert$ `\\lvert`<br>$~~~~$`\\rvert`|$\\lVert~\\rVert$ `\\lVert`<br>$~~~~~$`\\rVert` |`\\left.`|  `\\right.` |$\\backslash$ `\\backslash`\r\n|$\\lang~\\rang$ `\\lang`<br>$~~~~$`\\rang`|$\\lt~\\gt$ `\\lt \\gt`|$⟦~⟧$ `⟦ ⟧`|$\\llbracket~\\rrbracket$ `\\llbracket`<br>$~~~~$`\\rrbracket`|$\\lBrace~\\rBrace$ `\\lBrace \\rBrace`\r\n\r\n**Delimiter Sizing**\r\n\r\n$\\left(\\LARGE{AB}\\right)$ `\\left(\\LARGE{AB}\\right)`\r\n\r\n$( \\big( \\Big( \\bigg( \\Bigg($ `( \\big( \\Big( \\bigg( \\Bigg(`\r\n\r\n||||||\r\n|:--------|:------|:--------|:-------|:------|\r\n|`\\left`  |`\\big` |`\\bigl`  |`\\bigm` |`\\bigr`\r\n|`\\middle`|`\\Big` |`\\Bigl`  |`\\Bigm` | `\\Bigr`\r\n|`\\right` |`\\bigg`|`\\biggl` |`\\biggm`|`\\biggr`\r\n|         |`\\Bigg`|`\\Biggl` |`\\Biggm`|`\\Biggr`\r\n\r\n</div>\r\n\r\n## Environments\r\n\r\n<div class=\"katex-cards\" id=\"environments\">\r\n\r\n|||||\r\n|:---------------------|:---------------------|:---------------------|:--------\r\n|$\\begin{matrix} a & b \\\\ c & d \\end{matrix}$ | `\\begin{matrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{matrix}` |$\\begin{array}{cc}a & b\\\\c & d\\end{array}$ | `\\begin{array}{cc}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{array}`\r\n|$\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$ |`\\begin{pmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{pmatrix}` |$\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}$ | `\\begin{bmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{bmatrix}`\r\n|$\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}$ |`\\begin{vmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{vmatrix}` |$\\begin{Vmatrix} a & b \\\\ c & d \\end{Vmatrix}$ |`\\begin{Vmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{Vmatrix}`\r\n|$\\begin{Bmatrix} a & b \\\\ c & d \\end{Bmatrix}$ |`\\begin{Bmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{Bmatrix}`|$\\def\\arraystretch{1.5}\\begin{array}{c:c:c} a & b & c \\\\ \\hline d & e & f \\\\ \\hdashline g & h & i \\end{array}$|`\\def\\arraystretch{1.5}`<br>&nbsp;&nbsp;&nbsp;`\\begin{array}{c:c:c}`<br>&nbsp;&nbsp;&nbsp;`a & b & c \\\\ \\hline`<br>&nbsp;&nbsp;&nbsp;`d & e & f \\\\`<br>&nbsp;&nbsp;&nbsp;`\\hdashline`<br>&nbsp;&nbsp;&nbsp;`g & h & i`<br>`\\end{array}`\r\n|$x = \\begin{cases} a &\\text{if } b \\\\ c &\\text{if } d \\end{cases}$ |`x = \\begin{cases}`<br>&nbsp;&nbsp;&nbsp;`a &\\text{if } b  \\\\`<br>&nbsp;&nbsp;&nbsp;`c &\\text{if } d`<br>`\\end{cases}`|$\\begin{rcases} a &\\text{if } b \\\\ c &\\text{if } d \\end{rcases}⇒…$ |`\\begin{rcases}`<br>&nbsp;&nbsp;&nbsp;`a &\\text{if } b  \\\\`<br>&nbsp;&nbsp;&nbsp;`c &\\text{if } d`<br>`\\end{rcases}⇒…`|\r\n|$\\begin{smallmatrix} a & b \\\\ c & d \\end{smallmatrix}$ | `\\begin{smallmatrix}`<br>&nbsp;&nbsp;&nbsp;`a & b \\\\`<br>&nbsp;&nbsp;&nbsp;`c & d`<br>`\\end{smallmatrix}` |$$\\sum_{\\begin{subarray}{l} i\\in\\Lambda\\\\  0<j<n\\end{subarray}}$$ | `\\sum_{`<br>`\\begin{subarray}{l}`<br>&nbsp;&nbsp;&nbsp;`i\\in\\Lambda\\\\`<br>&nbsp;&nbsp;&nbsp;`0<j<n`<br>`\\end{subarray}}`|\r\n\r\nThe auto-render extension will render the following environments even if they are not inside math delimiters such as `$$…$$`. They are display-mode only.\r\n\r\n<style>\r\n  #env + table tr td:nth-child(1) { min-width: 11em }\r\n  #env + table tr td:nth-child(3) { min-width: 13em }\r\n</style>\r\n<div id=\"env\"></div>\r\n\r\n|||||\r\n|:---------------------|:---------------------|:---------------------|:--------\r\n|$$\\begin{equation}\\begin{split}a &=b+c\\\\&=e+f\\end{split}\\end{equation}$$ |`\\begin{equation}`<br>`\\begin{split}`&nbsp;&nbsp;&nbsp;`a &=b+c\\\\`<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`&=e+f`<br>`\\end{split}`<br>`\\end{equation}` |$$\\begin{align} a&=b+c \\\\ d+e&=f \\end{align}$$ |`\\begin{align}`<br>&nbsp;&nbsp;&nbsp;`a&=b+c \\\\`<br>&nbsp;&nbsp;&nbsp;`d+e&=f`<br>`\\end{align}` |\r\n|$$\\begin{gather} a=b \\\\ e=b+c \\end{gather}$$ |`\\begin{gather}`<br>&nbsp;&nbsp;&nbsp;`a=b \\\\ `<br>&nbsp;&nbsp;&nbsp;`e=b+c`<br>`\\end{gather}`|$$\\begin{alignat}{2}10&x+&3&y=2\\\\3&x+&13&y=4\\end{alignat}$$ | `\\begin{alignat}{2}`<br>&nbsp;&nbsp;&nbsp;`10&x+&3&y=2\\\\`<br>&nbsp;&nbsp;&nbsp;`3&x+&13&y=4`<br>`\\end{alignat}`\r\n|$$\\begin{CD}A @>a>> B \\\\@VbVV @AAcA\\\\C @= D\\end{CD}$$ | `\\begin{CD}`<br>&nbsp;&nbsp;&nbsp;`A  @>a>>  B  \\\\`<br>`@VbVV    @AAcA \\\\`<br>&nbsp;&nbsp;&nbsp;`C  @=   D`<br>`\\end{CD}`\r\n\r\n#### Other KaTeX Environments\r\n\r\n| Environments | How they differ from those shown above |\r\n|:-----------------------------------------------|:------------------|\r\n| `darray`, `dcases`, `drcases`                  | … apply `displaystyle` |\r\n| `matrix*`, `pmatrix*`, `bmatrix*`<br>`Bmatrix*`, `vmatrix*`, `Vmatrix*` | … take an optional argument to set column<br>alignment, as in `\\begin{matrix*}[r]`\r\n| `equation*`, `gather*`<br>`align*`, `alignat*` | … have no automatic numbering. Alternatively, you can use `\\nonumber` or `\\notag` to omit the numbering for a specific row of the equation. |\r\n| `gathered`, `aligned`, `alignedat`             | … do not need to be in display mode.<br> … have no automatic numbering.<br> … must be inside math delimiters in<br>order to be rendered by the auto-render<br>extension. |\r\n\r\n</div>\r\n\r\nAcceptable line separators include: `\\\\`, `\\cr`, `\\\\[distance]`, and `\\cr[distance]`. *Distance* can be written with any of the [KaTeX units](#units).\r\n\r\nThe `{array}` environment supports `|` and `:` vertical separators.\r\n\r\nThe `{array}` environment does not yet support `\\cline` or `\\multicolumn`.\r\n\r\n`\\tag` can be applied to individual rows of top-level environments\r\n(`align`, `align*`, `alignat`, `alignat*`, `gather`, `gather*`).\r\n\r\n<div class=\"katex-hopscotch\">\r\n\r\n## HTML\r\n\r\nThe following \"raw HTML\" features are potentially dangerous for untrusted\r\ninputs, so they are disabled by default, and attempting to use them produces\r\nthe command names in red (which you can configure via the `errorColor`\r\n[option](options.md)).  To fully trust your LaTeX input, you need to pass\r\nan option of `trust: true`; you can also enable just some of the commands\r\nor for just some URLs via the `trust` [option](options.md).\r\n\r\n|||\r\n|:----------------|:-------------------|\r\n| $\\href{https://katex.org/}{\\KaTeX}$ | `\\href{https://katex.org/}{\\KaTeX}` |\r\n| $\\url{https://katex.org/}$ | `\\url{https://katex.org/}` |\r\n| $\\includegraphics[height=0.8em, totalheight=0.9em, width=0.9em, alt=KA logo]{https://katex.org/img/khan-academy.png}$ | `\\includegraphics[height=0.8em, totalheight=0.9em, width=0.9em, alt=KA logo]{https://katex.org/img/khan-academy.png}` |\r\n| $\\htmlId{bar}{x}$ <code>…&lt;span id=\"bar\" class=\"enclosing\"&gt;…x…&lt;/span&gt;…</code> | `\\htmlId{bar}{x}` |\r\n| $\\htmlClass{foo}{x}$ <code>…&lt;span class=\"enclosing foo\"&gt;…x…&lt;/span&gt;…</code> | `\\htmlClass{foo}{x}` |\r\n| $\\htmlStyle{color: red;}{x}$ <code>…&lt;span style=\"color: red;\" class=\"enclosing\"&gt;…x…&lt;/span&gt;…</code> | `\\htmlStyle{color: red;}{x}` |\r\n| $\\htmlData{foo=a, bar=b}{x}$ <code>…&lt;span data-foo=\"a\" data-bar=\"b\" class=\"enclosing\"&gt;…x…&lt;/span&gt;…</code> | `\\htmlData{foo=a, bar=b}{x}` |\r\n\r\n`\\includegraphics` supports `height`, `width`, `totalheight`, and `alt` in its first argument. `height` is required.\r\n\r\nHTML extension (`\\html`-prefixed) commands are non-standard, so loosening `strict` option for `htmlExtension` is required.\r\n\r\n\r\n## Letters and Unicode\r\n\r\n**Greek Letters**\r\n\r\nDirect Input: $Α Β Γ Δ Ε Ζ Η Θ Ι \\allowbreak Κ Λ Μ Ν Ξ Ο Π Ρ Σ Τ Υ Φ Χ Ψ Ω$\r\n$\\allowbreak α β γ δ ϵ ζ η θ ι κ λ μ ν ξ o π \\allowbreak ρ σ τ υ ϕ χ ψ ω ε ϑ ϖ ϱ ς φ ϝ$\r\n\r\n|||||\r\n|---------------|-------------|-------------|---------------|\r\n| $\\Alpha$ `\\Alpha` | $\\Beta$ `\\Beta` | $\\Gamma$ `\\Gamma`| $\\Delta$ `\\Delta`\r\n| $\\Epsilon$ `\\Epsilon` | $\\Zeta$ `\\Zeta` | $\\Eta$ `\\Eta` | $\\Theta$ `\\Theta`\r\n| $\\Iota$ `\\Iota` | $\\Kappa$ `\\Kappa` | $\\Lambda$ `\\Lambda` | $\\Mu$ `\\Mu`\r\n| $\\Nu$ `\\Nu` | $\\Xi$ `\\Xi` | $\\Omicron$ `\\Omicron` | $\\Pi$ `\\Pi`\r\n| $\\Rho$ `\\Rho` | $\\Sigma$ `\\Sigma` | $\\Tau$ `\\Tau` | $\\Upsilon$ `\\Upsilon`\r\n| $\\Phi$ `\\Phi` | $\\Chi$ `\\Chi` | $\\Psi$ `\\Psi` | $\\Omega$ `\\Omega`\r\n| $\\varGamma$ `\\varGamma`| $\\varDelta$ `\\varDelta` | $\\varTheta$ `\\varTheta` | $\\varLambda$ `\\varLambda`  |\r\n| $\\varXi$ `\\varXi`| $\\varPi$ `\\varPi` | $\\varSigma$ `\\varSigma` | $\\varUpsilon$ `\\varUpsilon` |\r\n| $\\varPhi$ `\\varPhi`  | $\\varPsi$ `\\varPsi`| $\\varOmega$ `\\varOmega` ||\r\n| $\\alpha$ `\\alpha`| $\\beta$ `\\beta`  | $\\gamma$ `\\gamma` | $\\delta$ `\\delta`|\r\n| $\\epsilon$ `\\epsilon` | $\\zeta$ `\\zeta`  | $\\eta$ `\\eta`| $\\theta$ `\\theta`|\r\n| $\\iota$ `\\iota` | $\\kappa$ `\\kappa` | $\\lambda$ `\\lambda`| $\\mu$ `\\mu`|\r\n| $\\nu$ `\\nu`| $\\xi$ `\\xi` | $\\omicron$ `\\omicron`  | $\\pi$ `\\pi`|\r\n| $\\rho$ `\\rho`  | $\\sigma$ `\\sigma` | $\\tau$ `\\tau`| $\\upsilon$ `\\upsilon` |\r\n| $\\phi$ `\\phi`  | $\\chi$ `\\chi`| $\\psi$ `\\psi`| $\\omega$ `\\omega`|\r\n| $\\varepsilon$ `\\varepsilon` | $\\varkappa$ `\\varkappa` | $\\vartheta$ `\\vartheta` | $\\thetasym$ `\\thetasym`\r\n| $\\varpi$ `\\varpi`| $\\varrho$ `\\varrho`  | $\\varsigma$ `\\varsigma` | $\\varphi$ `\\varphi`\r\n| $\\digamma $ `\\digamma`\r\n\r\n**Other Letters**\r\n\r\n||||||\r\n|:----------|:----------|:----------|:----------|:----------|\r\n|$\\imath$ `\\imath`|$\\nabla$ `\\nabla`|$\\Im$ `\\Im`|$\\Reals$ `\\Reals`|$\\text{\\OE}$ `\\text{\\OE}`\r\n|$\\jmath$ `\\jmath`|$\\partial$ `\\partial`|$\\image$ `\\image`|$\\wp$ `\\wp`|$\\text{\\o}$ `\\text{\\o}`\r\n|$\\aleph$ `\\aleph`|$\\Game$ `\\Game`|$\\Bbbk$ `\\Bbbk`|$\\weierp$ `\\weierp`|$\\text{\\O}$ `\\text{\\O}`\r\n|$\\alef$ `\\alef`|$\\Finv$ `\\Finv`|$\\N$ `\\N`|$\\Z$ `\\Z`|$\\text{\\ss}$ `\\text{\\ss}`\r\n|$\\alefsym$ `\\alefsym`|$\\cnums$ `\\cnums`|$\\natnums$ `\\natnums`|$\\text{\\aa}$ `\\text{\\aa}`|$\\text{\\i}$ `\\text{\\i}`\r\n|$\\beth$ `\\beth`|$\\Complex$ `\\Complex`|$\\R$ `\\R`|$\\text{\\AA}$ `\\text{\\AA}`|$\\text{\\j}$ `\\text{\\j}`\r\n|$\\gimel$ `\\gimel`|$\\ell$ `\\ell`|$\\Re$ `\\Re`|$\\text{\\ae}$ `\\text{\\ae}`\r\n|$\\daleth$ `\\daleth`|$\\hbar$ `\\hbar`|$\\real$ `\\real`|$\\text{\\AE}$ `\\text{\\AE}`\r\n|$\\eth$ `\\eth`|$\\hslash$ `\\hslash`|$\\reals$ `\\reals`|$\\text{\\oe}$ `\\text{\\oe}`\r\n\r\nDirect Input: $∂ ∇ ℑ Ⅎ ℵ ℶ ℷ ℸ ⅁ ℏ ð − ∗$\r\nÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖÙÚÛÜÝÞßàáâãäåçèéêëìíîïðñòóôöùúûüýþÿ\r\n₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ⁺⁻⁼⁽⁾⁰¹²³⁴⁵⁶⁷⁸⁹ᵃᵇᶜᵈᵉᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘʷˣʸᶻᵛᵝᵞᵟᵠᵡ\r\n\r\nMath-mode Unicode (sub|super)script characters will render as if you had written regular characters in a subscript or superscript. For instance, `A²⁺³` will render the same as `A^{2+3}`.\r\n\r\n</div>\r\n<div class=\"katex-cards\" id=\"math-alpha\">\r\n\r\n**Unicode Mathematical Alphanumeric Symbols**\r\n\r\n| Item        |  Range              |  Item             |  Range  |\r\n|-------------|---------------------|-------------------|---------------|\r\n| Bold        | $\\text{𝐀-𝐙 𝐚-𝐳 𝟎-𝟗}$  | Double-struck     | $\\text{𝔸-}ℤ\\ 𝕜$\r\n| Italic      | $\\text{𝐴-𝑍 𝑎-𝑧}$      | Sans serif        | $\\text{𝖠-𝖹 𝖺-𝗓 𝟢-𝟫}$\r\n| Bold Italic | $\\text{𝑨-𝒁 𝒂-𝒛}$      | Sans serif bold   | $\\text{𝗔-𝗭 𝗮-𝘇 𝟬-𝟵}$\r\n| Script      | $\\text{𝒜-𝒵}$         | Sans serif italic | $\\text{𝘈-𝘡 𝘢-𝘻}$\r\n|  Fractur    | $\\text{𝔄-}ℨ\\text{ 𝔞-𝔷}$| Monospace        | $\\text{𝙰-𝚉 𝚊-𝚣 𝟶-𝟿}$\r\n\r\n</div>\r\n<div class=\"katex-hopscotch\">\r\n\r\n**Unicode**\r\n\r\nThe letters listed above will render properly in any KaTeX rendering mode.\r\n\r\nIn addition, Armenian, Brahmic, Georgian, Chinese, Japanese, and Korean glyphs are always accepted in text mode. However, these glyphs will be rendered from system fonts (not KaTeX-supplied fonts) so their typography may clash.\r\nYou can provide rules for CSS classes `.latin_fallback`, `.cyrillic_fallback`, `.brahmic_fallback`, `.georgian_fallback`, `.cjk_fallback`, and `.hangul_fallback` to provide fallback fonts for these languages.\r\nUse of these glyphs may cause small vertical alignment issues: KaTeX has detailed metrics for listed symbols and most Latin, Greek, and Cyrillic letters, but other accepted glyphs are treated as if they are each as tall as the letter M in the current KaTeX font.\r\n\r\nIf the KaTeX rendering mode is set to `strict: false` or `strict: \"warn\"` (default), then KaTeX will accept all Unicode letters in both text and math mode.\r\nAll unrecognized characters will be treated as if they appeared in text mode, and are subject to the same issues of using system fonts and possibly using incorrect vertical alignment.\r\n\r\nFor Persian composite characters, a user-supplied [plug-in](https://github.com/HosseinAgha/persian-katex-plugin) is under development.\r\n\r\nAny character can be written with the `\\char` function and the Unicode code in hex. For example `\\char\"263a` will render as $\\char\"263a$.\r\n\r\n## Layout\r\n\r\n### Annotation\r\n\r\n|||\r\n|:------------------------------|:-----\r\n|$\\cancel{5}$ `\\cancel{5}`|$\\overbrace{a+b+c}^{\\text{note}}$ `\\overbrace{a+b+c}^{\\text{note}}`\r\n|$\\bcancel{5}$ `\\bcancel{5}` |$\\underbrace{a+b+c}_{\\text{note}}$ `\\underbrace{a+b+c}_{\\text{note}}`\r\n|$\\xcancel{ABC}$ `\\xcancel{ABC}`|$\\not =$ `\\not =`\r\n|$\\sout{abc}$ `\\sout{abc}`|$\\boxed{\\pi=\\frac c d}$ `\\boxed{\\pi=\\frac c d}`\r\n|$a_{\\angl n}$ `$a_{\\angl n}`|$a_\\angln$ `a_\\angln`\r\n|$\\phase{-78^\\circ}$`\\phase{-78^\\circ}` |\r\n\r\n`\\tag{hi} x+y^{2x}`\r\n$$\\tag{hi} x+y^{2x}$$\r\n\r\n`\\tag*{hi} x+y^{2x}`\r\n$$\\tag*{hi} x+y^{2x}$$\r\n\r\n### Line Breaks\r\n\r\nKaTeX 0.10.0+ will insert automatic line breaks in inline math after relations or binary operators such as “=” or “+”. These can be suppressed by `\\nobreak` or by placing math inside a pair of braces, as in `{F=ma}`. `\\allowbreak` will allow automatic line breaks at locations other than relations or operators.\r\n\r\nHard line breaks are `\\\\` and `\\newline`.\r\n\r\nIn display math, KaTeX does not insert automatic line breaks. It ignores display math hard line breaks when rendering option `strict: true`.\r\n\r\n### Vertical Layout\r\n\r\n||||\r\n|:--------------|:----------------------------------------|:-----\r\n|$x_n$ `x_n` |$\\stackrel{!}{=}$ `\\stackrel{!}{=}`| $a \\atop b$ `a \\atop b`\r\n|$e^x$ `e^x` |$\\overset{!}{=}$ `\\overset{!}{=}`  | $a\\raisebox{0.25em}{$b$}c$ `a\\raisebox{0.25em}{$b$}c`\r\n|$_u^o $ `_u^o `| $\\underset{!}{=}$ `\\underset{!}{=}` | $a+\\left(\\vcenter{\\frac{\\frac a b}c}\\right)$ `a+\\left(\\vcenter{\\hbox{$\\frac{\\frac a b}c$}}\\right)`\r\n||| $$\\sum_{\\substack{0<i<m\\\\0<j<n}}$$ `\\sum_{\\substack{0<i<m\\\\0<j<n}}`\r\n\r\n`\\raisebox` and `\\hbox` put their argument into text mode. To raise math, nest `$…$` delimiters inside the argument as shown above. \r\n\r\n`\\vcenter` can be written without an `\\hbox` if the `strict` rendering option is *false*. In that case, omit the nested `$…$` delimiters.\r\n\r\n### Overlap and Spacing\r\n\r\n|||\r\n|:-------|:-------|\r\n|${=}\\mathllap{/\\,}$ `{=}\\mathllap{/\\,}` | $\\left(x^{\\smash{2}}\\right)$ `\\left(x^{\\smash{2}}\\right)`\r\n|$\\mathrlap{\\,/}{=}$ `\\mathrlap{\\,/}{=}` | $\\sqrt{\\smash[b]{y}}$ `\\sqrt{\\smash[b]{y}} `\r\n\r\n$\\displaystyle\\sum_{\\mathclap{1\\le i\\le j\\le n}} x_{ij}$ `\\sum_{\\mathclap{1\\le i\\le j\\le n}} x_{ij}`\r\n\r\nKaTeX also supports `\\llap`, `\\rlap`, and `\\clap`, but they will take only text, not math, as arguments.\r\n\r\n</div>\r\n<div class=\"katex-cards\" id=\"spacing-tbl\">\r\n\r\n**Spacing**\r\n\r\n| Function        | Produces           | Function             | Produces|\r\n|:----------------|:-------------------|:---------------------|:--------------------------------------|\r\n| `\\,`            | ³∕₁₈ em space      | `\\kern{distance}`    | space, width = *distance*\r\n| `\\thinspace`    | ³∕₁₈ em space      | `\\mkern{distance}`   | space, width = *distance*\r\n| `\\>`            | ⁴∕₁₈ em space      | `\\mskip{distance}`   | space, width = *distance*\r\n| `\\:`            | ⁴∕₁₈ em space      | `\\hskip{distance}`   | space, width = *distance*\r\n| `\\medspace`     | ⁴∕₁₈ em space      | `\\hspace{distance}`  | space, width = *distance*\r\n| `\\;`            | ⁵∕₁₈ em space      | `\\hspace*{distance}` | space, width = *distance*\r\n| `\\thickspace`   | ⁵∕₁₈ em space      | `\\phantom{content}`  | space the width and height of content\r\n| `\\enspace`      | ½ em space         | `\\hphantom{content}` | space the width of content\r\n| `\\quad`         | 1 em space         | `\\vphantom{content}` | a strut the height of content\r\n| `\\qquad`        | 2 em space         | `\\!`                 | – ³∕₁₈ em space\r\n| `~`             | non-breaking space | `\\negthinspace`      | – ³∕₁₈ em space\r\n| `\\<space>`      | space              | `\\negmedspace`       | – ⁴∕₁₈ em space\r\n| `\\nobreakspace` | non-breaking space | `\\negthickspace`     | – ⁵∕₁₈ em space\r\n| `\\space`        | space              | `\\mathstrut`         | `\\vphantom{(}`\r\n\r\n</div>\r\n\r\n**Notes:**\r\n\r\n`distance` will accept any of the [KaTeX units](#units).\r\n\r\n`\\kern`, `\\mkern`, `\\mskip`, and `\\hspace` accept unbraced distances, as in: `\\kern1em`.\r\n\r\n`\\mkern` and `\\mskip` will not work in text mode and both will write a console warning for any unit except `mu`.\r\n\r\n<div class=\"katex-hopscotch\">\r\n\r\n## Logic and Set Theory\r\n\r\n|||||\r\n|:--------------------|:--------------------------|:----------------------------|:-----\r\n|$\\forall$ `\\forall`  |$\\complement$ `\\complement`|$\\therefore$ `\\therefore`    |$\\emptyset$ `\\emptyset`\r\n|$\\exists$ `\\exists`  |$\\subset$ `\\subset`  |$\\because$ `\\because`              |$\\empty$ `\\empty`\r\n|$\\exist$ `\\exist`    |$\\supset$ `\\supset`  |$\\mapsto$ `\\mapsto`                |$\\varnothing$ `\\varnothing`\r\n|$\\nexists$ `\\nexists`|$\\mid$ `\\mid`        |$\\to$ `\\to`                        |$\\implies$ `\\implies`\r\n|$\\in$ `\\in`          |$\\land$ `\\land`      |$\\gets$ `\\gets`                    |$\\impliedby$ `\\impliedby`\r\n|$\\isin$ `\\isin`      |$\\lor$ `\\lor`        |$\\leftrightarrow$ `\\leftrightarrow`|$\\iff$ `\\iff`\r\n|$\\notin$ `\\notin`    |$\\ni$ `\\ni`          |$\\notni$ `\\notni`                  |$\\neg$ `\\neg` or `\\lnot`\r\n|   | $\\Set{ x \\| x<\\frac 1 2 }$<br>`\\Set{ x \\| x<\\frac 1 2 }`  | $\\set{x\\|x<5}$<br>`\\set{x\\|x<5}`\r\n\r\nDirect Input: $∀ ∴ ∁ ∵ ∃ ∣ ∈ ∉ ∋ ⊂ ⊃ ∧ ∨ ↦ → ← ↔ ¬$ ℂ ℍ ℕ ℙ ℚ ℝ\r\n\r\n## Macros\r\n\r\n|||\r\n|:-------------------------------------|:------\r\n|$\\def\\foo{x^2} \\foo + \\foo$           | `\\def\\foo{x^2} \\foo + \\foo`\r\n|$\\gdef\\bar#1{#1^2} \\bar{y} + \\bar{y}$ | `\\gdef\\bar#1{#1^2} \\bar{y} + \\bar{y}`\r\n|                                      | `\\edef\\macroname#1#2…{definition to be expanded}`\r\n|                                      | `\\xdef\\macroname#1#2…{definition to be expanded}`\r\n|                                      | `\\let\\foo=\\bar`\r\n|                                      | `\\futurelet\\foo\\bar x`\r\n|                                      | `\\global\\def\\macroname#1#2…{definition}`\r\n|                                      | `\\newcommand\\macroname[numargs]{definition}`\r\n|                                      | `\\renewcommand\\macroname[numargs]{definition}`\r\n|                                      | `\\providecommand\\macroname[numargs]{definition}`\r\n\r\nMacros can also be defined in the KaTeX [rendering options](options.md).\r\n\r\nMacros accept up to nine arguments: #1, #2, etc.\r\n\r\n</div>\r\n\r\n<div id=\"gdef\">\r\n\r\nMacros defined by `\\gdef`, `\\xdef`, `\\global\\def`, `\\global\\edef`, `\\global\\let`, and `\\global\\futurelet` will persist between math expressions. (Exception: macro persistence may be disabled. There are legitimate security reasons for that.)\r\n\r\nKaTeX has no `\\par`, so all macros are long by default and `\\long` will be ignored.\r\n\r\nAvailable functions include:\r\n\r\n`\\char` `\\mathchoice` `\\TextOrMath` `\\@ifstar` `\\@ifnextchar` `\\@firstoftwo` `\\@secondoftwo` `\\relax` `\\expandafter` `\\noexpand`\r\n\r\n@ is a valid character for commands, as if `\\makeatletter` were in effect.\r\n\r\n## Operators\r\n\r\n### Big Operators\r\n\r\n|||||\r\n|------------------|-------------------------|--------------------------|--------------|\r\n| $\\sum$ `\\sum`    | $\\prod$ `\\prod`         | $\\bigotimes$ `\\bigotimes`| $\\bigvee$ `\\bigvee`\r\n| $\\int$ `\\int`    | $\\coprod$ `\\coprod`     | $\\bigoplus$ `\\bigoplus`  | $\\bigwedge$ `\\bigwedge`\r\n| $\\iint$ `\\iint`  | $\\intop$ `\\intop`       | $\\bigodot$ `\\bigodot`    | $\\bigcap$ `\\bigcap`\r\n| $\\iiint$ `\\iiint`| $\\smallint$ `\\smallint` | $\\biguplus$ `\\biguplus`  | $\\bigcup$ `\\bigcup`\r\n| $\\oint$ `\\oint`  | $\\oiint$ `\\oiint`       | $\\oiiint$ `\\oiiint`      | $\\bigsqcup$ `\\bigsqcup`\r\n\r\nDirect Input: $∫ ∬ ∭ ∮ ∏ ∐ ∑ ⋀ ⋁ ⋂ ⋃ ⨀ ⨁ ⨂ ⨄ ⨆$ ∯ ∰\r\n\r\n### Binary Operators\r\n\r\n|||||\r\n|-------------|-------------------|-------------------|--------------------|\r\n| $+$ `+`| $\\cdot$ `\\cdot`  | $\\gtrdot$ `\\gtrdot`| $x \\pmod a$ `x \\pmod a`|\r\n| $-$ `-`| $\\cdotp$ `\\cdotp` | $\\intercal$ `\\intercal` | $x \\pod a$ `x \\pod a` |\r\n| $/$ `/`| $\\centerdot$ `\\centerdot`| $\\land$ `\\land`  | $\\rhd$ `\\rhd` |\r\n| $*$ `*`| $\\circ$ `\\circ`  | $\\leftthreetimes$ `\\leftthreetimes` | $\\rightthreetimes$ `\\rightthreetimes` |\r\n| $\\amalg$ `\\amalg` | $\\circledast$ `\\circledast`  | $\\ldotp$ `\\ldotp` | $\\rtimes$ `\\rtimes` |\r\n| $\\And$ `\\And`| $\\circledcirc$ `\\circledcirc` | $\\lor$ `\\lor`| $\\setminus$ `\\setminus`  |\r\n| $\\ast$ `\\ast`| $\\circleddash$ `\\circleddash` | $\\lessdot$ `\\lessdot`  | $\\smallsetminus$ `\\smallsetminus`|\r\n| $\\barwedge$ `\\barwedge` | $\\Cup$ `\\Cup`| $\\lhd$ `\\lhd`| $\\sqcap$ `\\sqcap`  |\r\n| $\\bigcirc$ `\\bigcirc`  | $\\cup$ `\\cup`| $\\ltimes$ `\\ltimes`| $\\sqcup$ `\\sqcup`  |\r\n| $\\bmod$ `\\bmod`  | $\\curlyvee$ `\\curlyvee` | $x \\mod a$ `x\\mod a`| $\\times$ `\\times`  |\r\n| $\\boxdot$ `\\boxdot`| $\\curlywedge$ `\\curlywedge`  | $\\mp$ `\\mp` | $\\unlhd$ `\\unlhd`  |\r\n| $\\boxminus$ `\\boxminus` | $\\div$ `\\div`| $\\odot$ `\\odot`  | $\\unrhd$ `\\unrhd`  |\r\n| $\\boxplus$ `\\boxplus`  | $\\divideontimes$ `\\divideontimes`  | $\\ominus$ `\\ominus`| $\\uplus$ `\\uplus`  |\r\n| $\\boxtimes$ `\\boxtimes` | $\\dotplus$ `\\dotplus`  | $\\oplus$ `\\oplus` | $\\vee$ `\\vee` |\r\n| $\\bullet$ `\\bullet`| $\\doublebarwedge$ `\\doublebarwedge` | $\\otimes$ `\\otimes`| $\\veebar$ `\\veebar` |\r\n| $\\Cap$ `\\Cap`| $\\doublecap$ `\\doublecap`| $\\oslash$ `\\oslash`| $\\wedge$ `\\wedge`  |\r\n| $\\cap$ `\\cap`| $\\doublecup$ `\\doublecup`| $\\pm$ `\\pm` or `\\plusmn` | $\\wr$ `\\wr`  |\r\n\r\nDirect Input: $+ - / * ⋅ ∘ ∙ ± × ÷ ∓ ∔ ∧ ∨ ∩ ∪ ≀ ⊎ ⊓ ⊔ ⊕ ⊖ ⊗ ⊘ ⊙ ⊚ ⊛ ⊝ ◯ ∖ {}$\r\n\r\n### Fractions and Binomials\r\n\r\n||||\r\n|:--------------------------|:----------------------------|:-----\r\n|$\\frac{a}{b}$ `\\frac{a}{b}`|$\\tfrac{a}{b}$ `\\tfrac{a}{b}`|$\\genfrac ( ] {2pt}{1}a{a+1}$ `\\genfrac ( ] {2pt}{1}a{a+1}`\r\n|${a \\over b}$ `{a \\over b}`|$\\dfrac{a}{b}$ `\\dfrac{a}{b}`|${a \\above{2pt} b+1}$ `{a \\above{2pt} b+1}`\r\n|$a/b$ `a/b`                |  |$\\cfrac{a}{1 + \\cfrac{1}{b}}$ `\\cfrac{a}{1 + \\cfrac{1}{b}}`\r\n\r\n||||\r\n|:------------------------------|:------------------------------|:--------\r\n|$\\binom{n}{k}$ `\\binom{n}{k}`  |$\\dbinom{n}{k}$ `\\dbinom{n}{k}`|${n\\brace k}$ `{n\\brace k}`\r\n|${n \\choose k}$ `{n \\choose k}`|$\\tbinom{n}{k}$ `\\tbinom{n}{k}`|${n\\brack k}$ `{n\\brack k}`\r\n\r\n### Math Operators\r\n\r\n|||||\r\n|:--------------------|:--------------------|:----------------|:--------------|\r\n| $\\arcsin$ `\\arcsin` | $\\cosec$ `\\cosec`   | $\\deg$ `\\deg`   | $\\sec$ `\\sec` |\r\n| $\\arccos$ `\\arccos` | $\\cosh$ `\\cosh`     | $\\dim$ `\\dim`   | $\\sin$ `\\sin` |\r\n| $\\arctan$ `\\arctan` | $\\cot$ `\\cot`       | $\\exp$ `\\exp`   | $\\sinh$ `\\sinh` |\r\n| $\\arctg$ `\\arctg`   | $\\cotg$ `\\cotg`     | $\\hom$ `\\hom`   | $\\sh$ `\\sh` |\r\n| $\\arcctg$ `\\arcctg` | $\\coth$ `\\coth`     | $\\ker$ `\\ker`   | $\\tan$ `\\tan` |\r\n| $\\arg$ `\\arg`       | $\\csc$ `\\csc`       | $\\lg$ `\\lg`     | $\\tanh$ `\\tanh` |\r\n| $\\ch$ `\\ch`         | $\\ctg$ `\\ctg`       | $\\ln$ `\\ln`     | $\\tg$ `\\tg` |\r\n| $\\cos$ `\\cos`       | $\\cth$ `\\cth`       | $\\log$ `\\log`   | $\\th$ `\\th` |\r\n| $\\operatorname{f}$ `\\operatorname{f}`     | |||\r\n| $\\argmax$ `\\argmax` | $\\injlim$ `\\injlim` | $\\min$ `\\min`   | $\\varinjlim$ `\\varinjlim` |\r\n| $\\argmin$ `\\argmin` | $\\lim$ `\\lim`       | $\\plim$ `\\plim` | $\\varliminf$ `\\varliminf` |\r\n| $\\det$ `\\det`       | $\\liminf$ `\\liminf` | $\\Pr$ `\\Pr`     | $\\varlimsup$ `\\varlimsup` |\r\n| $\\gcd$ `\\gcd`       | $\\limsup$ `\\limsup` | $\\projlim$ `\\projlim` | $\\varprojlim$ `\\varprojlim` |\r\n| $\\inf$ `\\inf`       | $\\max$ `\\max`       | $\\sup$ `\\sup`   ||\r\n| $\\operatorname*{f}$ `\\operatorname*{f}` | $\\operatornamewithlimits{f}$ `\\operatornamewithlimits{f}` |||\r\n\r\nFunctions in the bottom six rows of this table can take `\\limits`.\r\n\r\n### \\sqrt\r\n\r\n$\\sqrt{x}$ `\\sqrt{x}`\r\n\r\n$\\sqrt[3]{x}$ `\\sqrt[3]{x}`\r\n\r\n## Relations\r\n\r\n$\\stackrel{!}{=}$ `\\stackrel{!}{=}`\r\n\r\n|||||\r\n|:--------|:------------------------|:----------------------------|:------------------|\r\n| $=$ `=` | $\\doteqdot$ `\\doteqdot` | $\\lessapprox$ `\\lessapprox` | $\\smile$ `\\smile` |\r\n| $<$ `<` | $\\eqcirc$ `\\eqcirc` | $\\lesseqgtr$ `\\lesseqgtr` | $\\sqsubset$ `\\sqsubset` |\r\n| $>$ `>` | $\\eqcolon$ `\\eqcolon` or<br>    `\\minuscolon` | $\\lesseqqgtr$ `\\lesseqqgtr` | $\\sqsubseteq$ `\\sqsubseteq` |\r\n| $:$ `:` | $\\Eqcolon$ `\\Eqcolon` or<br>    `\\minuscoloncolon` | $\\lessgtr$ `\\lessgtr` | $\\sqsupset$ `\\sqsupset` |\r\n| $\\approx$ `\\approx` | $\\eqqcolon$ `\\eqqcolon` or<br>    `\\equalscolon` | $\\lesssim$ `\\lesssim` | $\\sqsupseteq$ `\\sqsupseteq` |\r\n| $\\approxcolon$ `\\approxcolon` | $\\Eqqcolon$ `\\Eqqcolon` or<br>    `\\equalscoloncolon` | $\\ll$ `\\ll` | $\\Subset$ `\\Subset` |\r\n| $\\approxcoloncolon$ `\\approxcoloncolon` | $\\eqsim$ `\\eqsim` | $\\lll$ `\\lll` | $\\subset$ `\\subset` or `\\sub` |\r\n| $\\approxeq$ `\\approxeq` | $\\eqslantgtr$ `\\eqslantgtr` | $\\llless$ `\\llless` | $\\subseteq$ `\\subseteq` or `\\sube` |\r\n| $\\asymp$ `\\asymp` | $\\eqslantless$ `\\eqslantless` | $\\lt$ `\\lt` | $\\subseteqq$ `\\subseteqq` |\r\n| $\\backepsilon$ `\\backepsilon` | $\\equiv$ `\\equiv` | $\\mid$ `\\mid` | $\\succ$ `\\succ` |\r\n| $\\backsim$ `\\backsim` | $\\fallingdotseq$ `\\fallingdotseq` | $\\models$ `\\models` | $\\succapprox$ `\\succapprox` |\r\n| $\\backsimeq$ `\\backsimeq` | $\\frown$ `\\frown` | $\\multimap$ `\\multimap` | $\\succcurlyeq$ `\\succcurlyeq` |\r\n| $\\between$ `\\between` | $\\ge$ `\\ge` | $\\origof$ `\\origof` | $\\succeq$ `\\succeq` |\r\n| $\\bowtie$ `\\bowtie` | $\\geq$ `\\geq` | $\\owns$ `\\owns` | $\\succsim$ `\\succsim` |\r\n| $\\bumpeq$ `\\bumpeq` | $\\geqq$ `\\geqq` | $\\parallel$ `\\parallel` | $\\Supset$ `\\Supset` |\r\n| $\\Bumpeq$ `\\Bumpeq` | $\\geqslant$ `\\geqslant` | $\\perp$ `\\perp` | $\\supset$ `\\supset` |\r\n| $\\circeq$ `\\circeq` | $\\gg$ `\\gg` | $\\pitchfork$ `\\pitchfork` | $\\supseteq$ `\\supseteq` or `\\supe` |\r\n| $\\colonapprox$ `\\colonapprox` | $\\ggg$ `\\ggg` | $\\prec$ `\\prec` | $\\supseteqq$ `\\supseteqq` |\r\n| $\\Colonapprox$ `\\Colonapprox` or<br>    `\\coloncolonapprox` | $\\gggtr$ `\\gggtr` | $\\precapprox$ `\\precapprox` | $\\thickapprox$ `\\thickapprox` |\r\n| $\\coloneq$ `\\coloneq` or<br>    `\\colonminus` | $\\gt$ `\\gt` | $\\preccurlyeq$ `\\preccurlyeq` | $\\thicksim$ `\\thicksim` |\r\n| $\\Coloneq$ `\\Coloneq` or<br>    `\\coloncolonminus` | $\\gtrapprox$ `\\gtrapprox` | $\\preceq$ `\\preceq` | $\\trianglelefteq$ `\\trianglelefteq` |\r\n| $\\coloneqq$ `\\coloneqq` or<br>   `\\colonequals` | $\\gtreqless$ `\\gtreqless` | $\\precsim$ `\\precsim` | $\\triangleq$ `\\triangleq` |\r\n| $\\Coloneqq$ `\\Coloneqq` or<br>    `\\coloncolonequals` | $\\gtreqqless$ `\\gtreqqless` | $\\propto$ `\\propto` | $\\trianglerighteq$ `\\trianglerighteq` |\r\n| $\\colonsim$ `\\colonsim` | $\\gtrless$ `\\gtrless` | $\\risingdotseq$ `\\risingdotseq` | $\\varpropto$ `\\varpropto` |\r\n| $\\Colonsim$ `\\Colonsim` or<br>    `\\coloncolonsim` | $\\gtrsim$ `\\gtrsim` | $\\shortmid$ `\\shortmid` | $\\vartriangle$ `\\vartriangle` |\r\n| $\\cong$ `\\cong` | $\\imageof$ `\\imageof` | $\\shortparallel$ `\\shortparallel` | $\\vartriangleleft$ `\\vartriangleleft` |\r\n| $\\curlyeqprec$ `\\curlyeqprec` | $\\in$ `\\in` or `\\isin` | $\\sim$ `\\sim` | $\\vartriangleright$ `\\vartriangleright` |\r\n| $\\curlyeqsucc$ `\\curlyeqsucc` | $\\Join$ `\\Join` | $\\simcolon$ `\\simcolon` | $\\vcentcolon$ `\\vcentcolon` or<br>   `\\ratio` |\r\n| $\\dashv$ `\\dashv` | $\\le$ `\\le` | $\\simcoloncolon$ `\\simcoloncolon` | $\\vdash$ `\\vdash` |\r\n| $\\dblcolon$ `\\dblcolon` or<br>   `\\coloncolon` | $\\leq$ `\\leq` | $\\simeq$ `\\simeq` | $\\vDash$ `\\vDash` |\r\n| $\\doteq$ `\\doteq` | $\\leqq$ `\\leqq` | $\\smallfrown$ `\\smallfrown` | $\\Vdash$ `\\Vdash` |\r\n| $\\Doteq$ `\\Doteq` | $\\leqslant$ `\\leqslant` | $\\smallsmile$ `\\smallsmile` | $\\Vvdash$ `\\Vvdash` |\r\n\r\nDirect Input: $= < > : ∈ ∋ ∝ ∼ ∽ ≂ ≃ ≅ ≈ ≊ ≍ ≎ ≏ ≐ ≑ ≒ ≓ ≖ ≗ ≜ ≡ ≤ ≥ ≦ ≧ ≫ ≬ ≳ ≷ ≺ ≻ ≼ ≽ ≾ ≿ ⊂ ⊃ ⊆ ⊇ ⊏ ⊐ ⊑ ⊒ ⊢ ⊣ ⊩ ⊪ ⊸ ⋈ ⋍ ⋐ ⋑ ⋔ ⋙ ⋛ ⋞ ⋟ ⌢ ⌣ ⩾ ⪆ ⪌ ⪕ ⪖ ⪯ ⪰ ⪷ ⪸ ⫅ ⫆ ≲ ⩽ ⪅ ≶ ⋚ ⪋ ⟂ ⊨ ⊶ ⊷$ `≔ ≕ ⩴`\r\n\r\n### Negated Relations\r\n\r\n$\\not =$ `\\not =`\r\n\r\n|||||\r\n|--------------|-------------------|---------------------|------------------|\r\n| $\\gnapprox$ `\\gnapprox`  | $\\ngeqslant$ `\\ngeqslant`| $\\nsubseteq$ `\\nsubseteq`  | $\\precneqq$ `\\precneqq`|\r\n| $\\gneq$ `\\gneq`| $\\ngtr$ `\\ngtr`  | $\\nsubseteqq$ `\\nsubseteqq` | $\\precnsim$ `\\precnsim`|\r\n| $\\gneqq$ `\\gneqq`  | $\\nleq$ `\\nleq`  | $\\nsucc$ `\\nsucc`| $\\subsetneq$ `\\subsetneq`  |\r\n| $\\gnsim$ `\\gnsim`  | $\\nleqq$ `\\nleqq` | $\\nsucceq$ `\\nsucceq` | $\\subsetneqq$ `\\subsetneqq` |\r\n| $\\gvertneqq$ `\\gvertneqq` | $\\nleqslant$ `\\nleqslant`| $\\nsupseteq$ `\\nsupseteq`  | $\\succnapprox$ `\\succnapprox`|\r\n| $\\lnapprox$ `\\lnapprox`  | $\\nless$ `\\nless` | $\\nsupseteqq$ `\\nsupseteqq` | $\\succneqq$ `\\succneqq`|\r\n| $\\lneq$ `\\lneq`| $\\nmid$ `\\nmid`  | $\\ntriangleleft$ `\\ntriangleleft` | $\\succnsim$ `\\succnsim`|\r\n| $\\lneqq$ `\\lneqq`  | $\\notin$ `\\notin` | $\\ntrianglelefteq$ `\\ntrianglelefteq`  | $\\supsetneq$ `\\supsetneq`  |\r\n| $\\lnsim$ `\\lnsim`  | $\\notni$ `\\notni` | $\\ntriangleright$ `\\ntriangleright`| $\\supsetneqq$ `\\supsetneqq` |\r\n| $\\lvertneqq$ `\\lvertneqq` | $\\nparallel$ `\\nparallel`| $\\ntrianglerighteq$ `\\ntrianglerighteq` | $\\varsubsetneq$ `\\varsubsetneq`  |\r\n| $\\ncong$ `\\ncong`  | $\\nprec$ `\\nprec` | $\\nvdash$ `\\nvdash`  | $\\varsubsetneqq$ `\\varsubsetneqq` |\r\n| $\\ne$ `\\ne`  | $\\npreceq$ `\\npreceq`  | $\\nvDash$ `\\nvDash`  | $\\varsupsetneq$ `\\varsupsetneq`  |\r\n| $\\neq$ `\\neq` | $\\nshortmid$ `\\nshortmid`| $\\nVDash$ `\\nVDash`  | $\\varsupsetneqq$ `\\varsupsetneqq` |\r\n| $\\ngeq$ `\\ngeq`| $\\nshortparallel$ `\\nshortparallel` | $\\nVdash$ `\\nVdash`  |\r\n| $\\ngeqq$ `\\ngeqq`  | $\\nsim$ `\\nsim`  | $\\precnapprox$ `\\precnapprox`|\r\n\r\nDirect Input: $∉ ∌ ∤ ∦ ≁ ≆ ≠ ≨ ≩ ≮ ≯ ≰ ≱ ⊀ ⊁ ⊈ ⊉ ⊊ ⊋ ⊬ ⊭ ⊮ ⊯ ⋠ ⋡ ⋦ ⋧ ⋨ ⋩ ⋬ ⋭ ⪇ ⪈ ⪉ ⪊ ⪵ ⪶ ⪹ ⪺ ⫋ ⫌$\r\n\r\n### Arrows\r\n\r\n||||\r\n|:----------|:----------|:----------|\r\n|$\\circlearrowleft$ `\\circlearrowleft`|$\\leftharpoonup$ `\\leftharpoonup`|$\\rArr$ `\\rArr`\r\n|$\\circlearrowright$ `\\circlearrowright`|$\\leftleftarrows$ `\\leftleftarrows`|$\\rarr$ `\\rarr`\r\n|$\\curvearrowleft$ `\\curvearrowleft`|$\\leftrightarrow$ `\\leftrightarrow`|$\\restriction$ `\\restriction`\r\n|$\\curvearrowright$ `\\curvearrowright`|$\\Leftrightarrow$ `\\Leftrightarrow`|$\\rightarrow$ `\\rightarrow`\r\n|$\\Darr$ `\\Darr`|$\\leftrightarrows$ `\\leftrightarrows`|$\\Rightarrow$ `\\Rightarrow`\r\n|$\\dArr$ `\\dArr`|$\\leftrightharpoons$ `\\leftrightharpoons`|$\\rightarrowtail$ `\\rightarrowtail`\r\n|$\\darr$ `\\darr`|$\\leftrightsquigarrow$ `\\leftrightsquigarrow`|$\\rightharpoondown$ `\\rightharpoondown`\r\n|$\\dashleftarrow$ `\\dashleftarrow`|$\\Lleftarrow$ `\\Lleftarrow`|$\\rightharpoonup$ `\\rightharpoonup`\r\n|$\\dashrightarrow$ `\\dashrightarrow`|$\\longleftarrow$ `\\longleftarrow`|$\\rightleftarrows$ `\\rightleftarrows`\r\n|$\\downarrow$ `\\downarrow`|$\\Longleftarrow$ `\\Longleftarrow`|$\\rightleftharpoons$ `\\rightleftharpoons`\r\n|$\\Downarrow$ `\\Downarrow`|$\\longleftrightarrow$ `\\longleftrightarrow`|$\\rightrightarrows$ `\\rightrightarrows`\r\n|$\\downdownarrows$ `\\downdownarrows`|$\\Longleftrightarrow$ `\\Longleftrightarrow`|$\\rightsquigarrow$ `\\rightsquigarrow`\r\n|$\\downharpoonleft$ `\\downharpoonleft`|$\\longmapsto$ `\\longmapsto`|$\\Rrightarrow$ `\\Rrightarrow`\r\n|$\\downharpoonright$ `\\downharpoonright`|$\\longrightarrow$ `\\longrightarrow`|$\\Rsh$ `\\Rsh`\r\n|$\\gets$ `\\gets`|$\\Longrightarrow$ `\\Longrightarrow`|$\\searrow$ `\\searrow`\r\n|$\\Harr$ `\\Harr`|$\\looparrowleft$ `\\looparrowleft`|$\\swarrow$ `\\swarrow`\r\n|$\\hArr$ `\\hArr`|$\\looparrowright$ `\\looparrowright`|$\\to$ `\\to`\r\n|$\\harr$ `\\harr`|$\\Lrarr$ `\\Lrarr`|$\\twoheadleftarrow$ `\\twoheadleftarrow`\r\n|$\\hookleftarrow$ `\\hookleftarrow`|$\\lrArr$ `\\lrArr`|$\\twoheadrightarrow$ `\\twoheadrightarrow`\r\n|$\\hookrightarrow$ `\\hookrightarrow`|$\\lrarr$ `\\lrarr`|$\\Uarr$ `\\Uarr`\r\n|$\\iff$ `\\iff`|$\\Lsh$ `\\Lsh`|$\\uArr$ `\\uArr`\r\n|$\\impliedby$ `\\impliedby`|$\\mapsto$ `\\mapsto`|$\\uarr$ `\\uarr`\r\n|$\\implies$ `\\implies`|$\\nearrow$ `\\nearrow`|$\\uparrow$ `\\uparrow`\r\n|$\\Larr$ `\\Larr`|$\\nleftarrow$ `\\nleftarrow`|$\\Uparrow$ `\\Uparrow`\r\n|$\\lArr$ `\\lArr`|$\\nLeftarrow$ `\\nLeftarrow`|$\\updownarrow$ `\\updownarrow`\r\n|$\\larr$ `\\larr`|$\\nleftrightarrow$ `\\nleftrightarrow`|$\\Updownarrow$ `\\Updownarrow`\r\n|$\\leadsto$ `\\leadsto`|$\\nLeftrightarrow$ `\\nLeftrightarrow`|$\\upharpoonleft$ `\\upharpoonleft`\r\n|$\\leftarrow$ `\\leftarrow`|$\\nrightarrow$ `\\nrightarrow`|$\\upharpoonright$ `\\upharpoonright`\r\n|$\\Leftarrow$ `\\Leftarrow`|$\\nRightarrow$ `\\nRightarrow`|$\\upuparrows$ `\\upuparrows`\r\n|$\\leftarrowtail$ `\\leftarrowtail`|$\\nwarrow$ `\\nwarrow`\r\n|$\\leftharpoondown$ `\\leftharpoondown`|$\\Rarr$ `\\Rarr`\r\n\r\nDirect Input: $← ↑ → ↓ ↔ ↕ ↖ ↗ ↘ ↙ ↚ ↛ ↞ ↠ ↢ ↣ ↦ ↩ ↪ ↫ ↬ ↭ ↮ ↰ ↱↶ ↷ ↺ ↻ ↼ ↽ ↾ ↾ ↿ ⇀ ⇁ ⇂ ⇃ ⇄ ⇆ ⇇ ⇈ ⇉ ⇊ ⇋ ⇌⇍ ⇎ ⇏ ⇐ ⇑ ⇒ ⇓ ⇔ ⇕ ⇚ ⇛ ⇝ ⇠ ⇢ ⟵ ⟶ ⟷ ⟸ ⟹ ⟺ ⟼$ ↽\r\n\r\n**Extensible Arrows**\r\n\r\n|||\r\n|:----------------------------------------------------|:-----\r\n|$\\xleftarrow{abc}$ `\\xleftarrow{abc}`                |$\\xrightarrow[under]{over}$ `\\xrightarrow[under]{over}`\r\n|$\\xLeftarrow{abc}$ `\\xLeftarrow{abc}`                |$\\xRightarrow{abc}$ `\\xRightarrow{abc}`\r\n|$\\xleftrightarrow{abc}$ `\\xleftrightarrow{abc}`      |$\\xLeftrightarrow{abc}$ `\\xLeftrightarrow{abc}`\r\n|$\\xhookleftarrow{abc}$ `\\xhookleftarrow{abc}`        |$\\xhookrightarrow{abc}$ `\\xhookrightarrow{abc}`\r\n|$\\xtwoheadleftarrow{abc}$ `\\xtwoheadleftarrow{abc}`  |$\\xtwoheadrightarrow{abc}$ `\\xtwoheadrightarrow{abc}`\r\n|$\\xleftharpoonup{abc}$ `\\xleftharpoonup{abc}`        |$\\xrightharpoonup{abc}$ `\\xrightharpoonup{abc}`\r\n|$\\xleftharpoondown{abc}$ `\\xleftharpoondown{abc}`    |$\\xrightharpoondown{abc}$ `\\xrightharpoondown{abc}`\r\n|$\\xleftrightharpoons{abc}$ `\\xleftrightharpoons{abc}`|$\\xrightleftharpoons{abc}$ `\\xrightleftharpoons{abc}`\r\n|$\\xtofrom{abc}$ `\\xtofrom{abc}`                      |$\\xmapsto{abc}$ `\\xmapsto{abc}`\r\n|$\\xlongequal{abc}$ `\\xlongequal{abc}`\r\n\r\nExtensible arrows all can take an optional argument in the same manner<br>as `\\xrightarrow[under]{over}`.\r\n\r\n## Special Notation\r\n\r\n**Bra-ket Notation**\r\n\r\n||||\r\n|:----------|:----------|:----------|\r\n|$\\bra{\\phi}$ `\\bra{\\phi}` |$\\ket{\\psi}$ `\\ket{\\psi}` |$\\braket{\\phi\\vert\\psi}$ `\\braket{\\phi\\vert\\psi}` |\r\n|$\\Bra{\\phi}$ `\\Bra{\\phi}` |$\\Ket{\\psi}$ `\\Ket{\\psi}` |$\\Braket{ ϕ \\| \\frac{∂^2}{∂ t^2} \\| ψ }$ `\\Braket{ ϕ \\| \\frac{∂^2}{∂ t^2} \\| ψ }`|\r\n\r\n## Style, Color, Size, and Font\r\n\r\n**Class Assignment**\r\n\r\n`\\mathbin` `\\mathclose` `\\mathinner` `\\mathop`<br>\r\n`\\mathopen` `\\mathord` `\\mathpunct` `\\mathrel`\r\n\r\n**Color**\r\n\r\n$\\color{blue} F=ma$  `\\color{blue} F=ma`\r\n\r\nNote that `\\color` acts like a switch. Other color functions expect the content to be a function argument:\r\n\r\n$\\textcolor{blue}{F=ma}$ `\\textcolor{blue}{F=ma}`<br>\r\n$\\textcolor{#228B22}{F=ma}$ `\\textcolor{#228B22}{F=ma}`<br>\r\n$\\colorbox{aqua}{$F=ma$}$ `\\colorbox{aqua}{$F=ma$}`<br>\r\n$\\fcolorbox{red}{aqua}{$F=ma$}$ `\\fcolorbox{red}{aqua}{$F=ma$}`\r\n\r\nNote that, as in LaTeX, `\\colorbox` & `\\fcolorbox` renders its third argument as text, so you may want to switch back to math mode with `$` as in the examples above.\r\n\r\nFor color definition, KaTeX color functions will accept the standard HTML [predefined color names](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords). They will also accept an RGB argument in CSS hexa­decimal style. The \"#\" is optional before a six-digit specification.\r\n\r\n**Font**\r\n\r\n||||\r\n|:------------------------------|:------------------------------|:-----\r\n|$\\mathrm{Ab0}$ `\\mathrm{Ab0}`  |$\\mathbf{Ab0}$ `\\mathbf{Ab0}`  |$\\mathit{Ab0}$ `\\mathit{Ab0}`\r\n|$\\mathnormal{Ab0}$ `\\mathnormal{Ab0}`|$\\textbf{Ab0}$ `\\textbf{Ab0}`  |$\\textit{Ab0}$ `\\textit{Ab0}`\r\n|$\\textrm{Ab0}$ `\\textrm{Ab0}`  |$\\bf Ab0$ `\\bf Ab0`            |$\\it Ab0$ `\\it Ab0`\r\n|$\\rm Ab0$ `\\rm Ab0`            |$\\bold{Ab0}$ `\\bold{Ab0}`      |$\\textup{Ab0}$ `\\textup{Ab0}`\r\n|$\\textnormal{Ab0}$ `\\textnormal{Ab0}`|$\\boldsymbol{Ab0}$ `\\boldsymbol{Ab}`|$\\Bbb{AB}$ `\\Bbb{AB}`\r\n|$\\text{Ab0}$ `\\text{Ab0}`      |$\\bm{Ab0}$ `\\bm{Ab0}`          |$\\mathbb{AB}$ `\\mathbb{AB}`\r\n|$\\mathsf{Ab0}$ `\\mathsf{Ab0}`  |$\\textmd{Ab0}$ `\\textmd{Ab0}`  |$\\frak{Ab0}$ `\\frak{Ab0}`\r\n|$\\textsf{Ab0}$ `\\textsf{Ab0}`  |$\\mathtt{Ab0}$ `\\mathtt{Ab0}`  |$\\mathfrak{Ab0}$ `\\mathfrak{Ab0}`\r\n|$\\sf Ab0$ `\\sf Ab0`            |$\\texttt{Ab0}$ `\\texttt{Ab0}`  |$\\mathcal{AB0}$ `\\mathcal{AB0}`\r\n|                               |$\\tt Ab0$ `\\tt Ab0`            |$\\cal AB0$ `\\cal AB0`\r\n|                               |                               |$\\mathscr{AB}$ `\\mathscr{AB}`\r\n\r\nOne can stack font family, font weight, and font shape by using the `\\textXX` versions of the font functions. So `\\textsf{\\textbf{H}}` will produce $\\textsf{\\textbf{H}}$. The other versions do not stack, e.g., `\\mathsf{\\mathbf{H}}` will produce $\\mathsf{\\mathbf{H}}$.\r\n\r\nIn cases where KaTeX fonts do not have a bold glyph, `\\pmb` can simulate one. For example, `\\pmb{\\mu}` renders as : $\\pmb{\\mu}$\r\n\r\n**Size**\r\n\r\n|||\r\n|:----------------------|:-----\r\n|$\\Huge AB$ `\\Huge AB`  |$\\normalsize AB$ `\\normalsize AB`\r\n|$\\huge AB$ `\\huge AB`  |$\\small AB$ `\\small AB`\r\n|$\\LARGE AB$ `\\LARGE AB`|$\\footnotesize AB$ `\\footnotesize AB`\r\n|$\\Large AB$ `\\Large AB`|$\\scriptsize AB$ `\\scriptsize AB`\r\n|$\\large AB$ `\\large AB`|$\\tiny AB$ `\\tiny AB`\r\n\r\n\r\n**Style**\r\n\r\n||\r\n|:-------------------------------------------------------|\r\n|$\\displaystyle\\sum_{i=1}^n$ `\\displaystyle\\sum_{i=1}^n`\r\n|$\\textstyle\\sum_{i=1}^n$ `\\textstyle\\sum_{i=1}^n`\r\n|$\\scriptstyle x$ `\\scriptstyle x` &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(The size of a first sub/superscript)\r\n|$\\scriptscriptstyle x$ `\\scriptscriptstyle x` (The size of subsequent sub/superscripts)\r\n|$\\lim\\limits_x$ `\\lim\\limits_x`\r\n|$\\lim\\nolimits_x$ `\\lim\\nolimits_x`\r\n|$\\verb!x^2!$ `\\verb!x^2!`\r\n\r\n`\\text{…}` will accept nested `$…$` fragments and render them in math mode.\r\n\r\n## Symbols and Punctuation\r\n\r\n||||\r\n|:----------|:----------|:----------|\r\n|`% comment`|$\\dots$ `\\dots`|$\\KaTeX$ `\\KaTeX`\r\n|$\\%$ `\\%`|$\\cdots$ `\\cdots`|$\\LaTeX$ `\\LaTeX`\r\n|$\\#$ `\\#`|$\\ddots$ `\\ddots`|$\\TeX$ `\\TeX`\r\n|$\\&$ `\\&`|$\\ldots$ `\\ldots`|$\\nabla$ `\\nabla`\r\n|$\\_$ `\\_`|$\\vdots$ `\\vdots`|$\\infty$ `\\infty`\r\n|$\\text{\\textunderscore}$ `\\text{\\textunderscore}`|$\\dotsb$ `\\dotsb`|$\\infin$ `\\infin`\r\n|$\\text{--}$ `\\text{--}`|$\\dotsc$ `\\dotsc`|$\\checkmark$ `\\checkmark`\r\n|$\\text{\\textendash}$ `\\text{\\textendash}`|$\\dotsi$ `\\dotsi`|$\\dag$ `\\dag`\r\n|$\\text{---}$ `\\text{---}`|$\\dotsm$ `\\dotsm`|$\\dagger$ `\\dagger`\r\n|$\\text{\\textemdash}$ `\\text{\\textemdash}`|$\\dotso$ `\\dotso`|$\\text{\\textdagger}$ `\\text{\\textdagger}`\r\n|$\\text{\\textasciitilde}$ `\\text{\\textasciitilde}`|$\\sdot$ `\\sdot`|$\\ddag$ `\\ddag`\r\n|$\\text{\\textasciicircum}$ `\\text{\\textasciicircum}`|$\\mathellipsis$ `\\mathellipsis`|$\\ddagger$ `\\ddagger`\r\n|$`$ <code>`</code>|$\\text{\\textellipsis}$ `\\text{\\textellipsis}`|$\\text{\\textdaggerdbl}$ `\\text{\\textdaggerdbl}`\r\n|$\\text{\\textquoteleft}$ `text{\\textquoteleft}`|$\\Box$ `\\Box`|$\\Dagger$ `\\Dagger`\r\n|$\\lq$ `\\lq`|$\\square$ `\\square`|$\\angle$ `\\angle`\r\n|$\\text{\\textquoteright}$ `\\text{\\textquoteright}`|$\\blacksquare$ `\\blacksquare`|$\\measuredangle$ `\\measuredangle`\r\n|$\\rq$ `\\rq`|$\\triangle$ `\\triangle`|$\\sphericalangle$ `\\sphericalangle`\r\n|$\\text{\\textquotedblleft}$ `\\text{\\textquotedblleft}`|$\\triangledown$ `\\triangledown`|$\\top$ `\\top`\r\n|$\"$ `\"`|$\\triangleleft$ `\\triangleleft`|$\\bot$ `\\bot`\r\n|$\\text{\\textquotedblright}$ `\\text{\\textquotedblright}`|$\\triangleright$ `\\triangleright`|$\\$$ `\\$`\r\n|$\\colon$ `\\colon`|$\\bigtriangledown$ `\\bigtriangledown`|$\\text{\\textdollar}$ `\\text{\\textdollar}`\r\n|$\\backprime$ `\\backprime`|$\\bigtriangleup$ `\\bigtriangleup`|$\\pounds$ `\\pounds`\r\n|$\\prime$ `\\prime`|$\\blacktriangle$ `\\blacktriangle`|$\\mathsterling$ `\\mathsterling`\r\n|$\\text{\\textless}$ `\\text{\\textless}`|$\\blacktriangledown$ `\\blacktriangledown`|$\\text{\\textsterling}$ `\\text{\\textsterling}`\r\n|$\\text{\\textgreater}$ `\\text{\\textgreater}`|$\\blacktriangleleft$ `\\blacktriangleleft`|$\\yen$ `\\yen`\r\n|$\\text{\\textbar}$ `\\text{\\textbar}`|$\\blacktriangleright$ `\\blacktriangleright`|$\\surd$ `\\surd`\r\n|$\\text{\\textbardbl}$ `\\text{\\textbardbl}`|$\\diamond$ `\\diamond`|$\\degree$ `\\degree`\r\n|$\\text{\\textbraceleft}$ `\\text{\\textbraceleft}`|$\\Diamond$ `\\Diamond`|$\\text{\\textdegree}$ `\\text{\\textdegree}`\r\n|$\\text{\\textbraceright}$ `\\text{\\textbraceright}`|$\\lozenge$ `\\lozenge`|$\\mho$ `\\mho`\r\n|$\\text{\\textbackslash}$ `\\text{\\textbackslash}`|$\\blacklozenge$ `\\blacklozenge`|$\\diagdown$ `\\diagdown`\r\n|$\\text{\\P}$ `\\text{\\P}` or `\\P`|$\\star$ `\\star`|$\\diagup$ `\\diagup`\r\n|$\\text{\\S}$ `\\text{\\S}` or `\\S`|$\\bigstar$ `\\bigstar`|$\\flat$ `\\flat`\r\n|$\\text{\\sect}$ `\\text{\\sect}`|$\\clubsuit$ `\\clubsuit`|$\\natural$ `\\natural`\r\n|$\\copyright$ `\\copyright`|$\\clubs$ `\\clubs`|$\\sharp$ `\\sharp`\r\n|$\\circledR$ `\\circledR`|$\\diamondsuit$ `\\diamondsuit`|$\\heartsuit$ `\\heartsuit`\r\n|$\\text{\\textregistered}$ `\\text{\\textregistered}`|$\\diamonds$ `\\diamonds`|$\\hearts$ `\\hearts`\r\n|$\\circledS$ `\\circledS`|$\\spadesuit$ `\\spadesuit`|$\\spades$ `\\spades`\r\n|$\\text{\\textcircled a}$ `\\text{\\textcircled a}`|$\\maltese$ `\\maltese`|$\\minuso$ `\\minuso`|\r\n\r\nDirect Input: § ¶ $ £ ¥ ∇ ∞ · ∠ ∡ ∢ ♠ ♡ ♢ ♣ ♭ ♮ ♯ ✓ …  ⋮  ⋯  ⋱  !$ ‼ ⦵\r\n\r\n## Units\r\n\r\nIn KaTeX, units are proportioned as they are in TeX.<br>\r\nKaTeX units are different than CSS units.\r\n\r\n</div>\r\n<div class=\"katex-cards\" id=\"unit-tbl\">\r\n\r\n|  KaTeX Unit | Value       | KaTeX Unit  | Value  |\r\n|:---|:---------------------|:---|:----------------|\r\n| em | CSS em               | bp | 1/72​ inch × F × G|\r\n| ex | CSS ex               | pc | 12 KaTeX pt|\r\n| mu | 1/18 CSS em          | dd | 1238/1157​ KaTeX pt  |\r\n| pt | 1/72.27 inch × F × G | cc | 14856/1157 KaTeX pt |\r\n| mm | 1 mm × F × G         | nd | 685/642 KaTeX pt |\r\n| cm | 1 cm × F × G         | nc | 1370/107​ KaTeX pt|\r\n| in | 1 inch × F × G       | sp | 1/65536 KaTeX pt |\r\n\r\n</div>\r\n\r\nwhere:\r\n\r\n<div style=\"margin-left: 1.5em;\">\r\n\r\nF = (font size of surrounding HTML text)/(10 pt)\r\n\r\nG = 1.21 by default, because KaTeX font-size is normally 1.21 × the surrounding font size. This value [can be overridden](font.md#font-size-and-lengths) by the CSS of an HTML page.\r\n\r\n</div>\r\n\r\nThe effect of style and size:\r\n\r\n<div class=\"katex-cards\" id=\"unit-blocks\">\r\n\r\n|  Unit  |     textstyle     | scriptscript |  huge  |\r\n|:------:|:-----------------:|:------------:|:------:|\r\n|em or ex|$\\rule{1em}{1em}$  |$\\scriptscriptstyle\\rule{1em}{1em}$  |$\\huge\\rule{1em}{1em}$\r\n| mu     |$\\rule{18mu}{18mu}$|$\\scriptscriptstyle\\rule{18mu}{18mu}$|$\\huge\\rule{18mu}{18mu}$\r\n| others |$\\rule{10pt}{10pt}$|$\\scriptscriptstyle\\rule{10pt}{10pt}$|$\\huge\\rule{10pt}{10pt}$\r\n\r\n</div>\r\n\r\n"},{"shortInfo":{"title":"LESS层叠样式预处理语言","date":"2022-06-21T00:46:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["LESS","CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":32,"countWords":683,"readSeconds":68.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# LESS层叠样式预处理语言\r\n## 目录\r\n- [LESS层叠样式预处理语言](#less层叠样式预处理语言)\r\n  - [目录](#目录)\r\n  - [概述](#概述)\r\n  - [注释](#注释)\r\n  - [运算语法](#运算语法)\r\n  - [选择器嵌套语法](#选择器嵌套语法)\r\n  - [变量](#变量)\r\n  - [导入](#导入)\r\n  - [导出位置修改](#导出位置修改)\r\n    - [修改方法1](#修改方法1)\r\n    - [修改方法2](#修改方法2)\r\n  - [禁止导出](#禁止导出)\r\n\r\n## 概述\r\n* less是一个**css的预处理器**\r\n* less文件后缀是.less\r\n* 优点：\r\n    * 它扩充了 CSS 语言，\r\n    * 增加了诸如变量、混合（mixin）、函数等功能，\r\n    * 让 CSS 更易维护,简化了 CSS 的编写\r\n\r\n* vscode插件EasyLESS\r\n    * 可以在保存的时候自动编译生成同名的.css文件\r\n\r\n## 注释\r\n* 单行注释：`//注释内容`\r\n* 多行注释：`/* 注释内容 */` 多行注释会同步生成到css文件中\r\n\r\n## 运算语法\r\n* 加`+`\r\n* 减`-`\r\n* 乘`*` \r\n* 除法需要添加`(小括号)`或`.`\r\n    * `(1/1)`\r\n    * `1./1`\r\n    ```less\r\n    div{\r\n        // 加\r\n        height:10+10px;\r\n        // 减\r\n        height:10-10px;\r\n        // 乘\r\n        height:10*10px;\r\n        // 除\r\n        height:(10/10px);\r\n        height:10./10px;\r\n    }\r\n    ```\r\n* 注意：less4.0之前可以直接写`1 / 1`\r\n\r\n## 选择器嵌套语法\r\n* css后代选择器的写法比较冗长，但为了保证其选择器的权重又不得不这样写\r\n* less嵌套写法可以快速生成css语法的后代选择器\r\n* 语法格式\r\n    ```less\r\n    父选择器{\r\n        // 父级样式\r\n        子选择器{\r\n            // 子级样式\r\n        }\r\n    }\r\n    ```\r\n* 示例写法\r\n    ```less\r\n    .father{\r\n        width:100px;\r\n        .son{\r\n            width:50px;\r\n        }\r\n    }\r\n    ```\r\n* 生成css代码\r\n    ```css\r\n    .father{\r\n        width:100px;\r\n    }\r\n    .father .son{\r\n            width:50px;\r\n        }\r\n    ```\r\n* 注意： **`&`表示当前选择器，通常配合伪元素或伪类使用**\r\n    ```less\r\n    .father{\r\n        width:100px;\r\n        .son{\r\n            width:50px;\r\n        }\r\n        &:hover{\r\n            width:60px;\r\n        }\r\n    }\r\n    ```\r\n\r\n## 变量\r\n* 定义变量：`@变量名:值;`\r\n* 使用示例：\r\n    ```less\r\n    @bgcolor:#333;\r\n    div{\r\n        background-color:@bgcolor;\r\n    }\r\n    ```\r\n\r\n## 导入\r\n* 语法格式：`@import \"path/to/fileName.less\";`\r\n* 省略后缀：`@import \"path/to/fileName\";`\r\n* 注意: import之后后**一定**要有空格\r\n* 和c语言include含义类似，实际上就是把另一个文件的内容复制到该位置\r\n\r\n## 导出位置修改\r\n* 默认生成的css文件导出在当前文件所在位置\r\n* 一般less可以写在网站根目录的less文件夹\r\n* 导出的文件目录在网站根目录的css文件夹\r\n\r\n### 修改方法1\r\n配置vscode的easyLess插件\r\n\r\n* 注意：\r\n    * `*/css/`表示存放在`css`**文件夹** \r\n    * `*/css`表示存放为一个名为`css`的**文件**\r\n\r\nsetting.json\r\n```json\r\n{\r\n    \"less.compile\":{\r\n        \"out\":\"../css/\"\r\n    }\r\n}\r\n```\r\n\r\n### 修改方法2\r\n控制单个文件的导出路径\r\n\r\n* 语法：\r\n    * **写在第一行:**\r\n    * `//out: ./out/`\r\n\r\n## 禁止导出\r\n* 对于`base.less`、`common.less`等类似的公共样式文件，可以禁止其导出为css文件\r\n* 语法：`//out: false`\r\n* 如要调用这些被禁止导出的样式，可以使用`@import`导入"},{"shortInfo":{"layout":"post","title":"Linux备忘笔记","date":"2022-01-09T12:28:00.000Z","cover":"\\self_server\\assets\\images\\linux2.webp","tags":["笔记","Linux"],"hideAtIndex":true,"categories":"笔记","id":33,"countWords":956,"readSeconds":95.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# linux备忘笔记\r\n\r\n\r\n\r\n## 删除已设置生效的root密码\r\n```bash\r\n# 删除root:x: 中的x密码占位符号\r\nvim /etc/passwd\r\n# 删除root:xxxxxxxxxx: 中的xxxxxxxxxxxxxxxxxx加密后的密码，改为*\r\nvim /etc/shadow\r\n\r\n# 没有权限则重启进入拯救模式\r\n```\r\n\r\n## 用户管理\r\n**usermod**\r\n```bash\r\n# usermod 可选项：\r\n#     -d <登入目录>     修改用户登入时的目录。\r\n#     -g <群组>         修改用户所属的群组。\r\n#     -G <群组>         修改用户所属的附加群组。\r\n#     -l <帐号名称>     修改用户帐号名称(新账号在前，旧账号在后)\r\n#     -L                锁定用户密码，使密码无效。\r\n#     -s <shell>        修改用户登入后所使用的shell。\r\n#     -u <uid>          修改用户ID。\r\n#     -U                解除密码锁定。\r\n```\r\n\r\n\r\n## 权限管理\r\n**查看用户组的成员**\r\n```bash\r\nvi /etc/group\r\n```\r\n\r\n\r\n\r\n\r\n## 常用命令\r\n* 查看所有运行的任务和pid\r\n    + ps aux \r\n    + a 显示现行终端机下的所有程序，包括其他用户的程序。\r\n    + u 以用户为主的格式来显示程序状况。\r\n    + x 显示所有程序，不以终端机来区分。\r\n* 查看端口监听情况\r\n    + 软件包名：net-tools\r\n    + netstat -tunlp\r\n    + -a 全部\r\n    + -c或--continuous：持续列出网络状态；\r\n    + -l或--listening：显示监控中的服务器的Socket；\r\n    + -u或--udp：显示UDP传输协议的连线状况；\r\n    + -t或--tcp：显示TCP传输协议的连线状况；\r\n    + -n或--numeric：直接使用ip地址，而不通过域名服务器；\r\n    + -p或--programs：显示正在使用Socket的程序识别码和程序名称；\r\n\r\n* ctrl + z 将一个正在前台执行的命令放到后台，并且暂停\r\n*  jobs 查看当前有多少在后台运行的命令\r\n    + 无参数 查看当前作业\r\n    + -l 列出进程的PID和作业号\r\n    + -p 只列出作业的PID\r\n    + -s 只列出停止的作业\r\n    + -r 只列出运行的作业\r\n* fg 将后台中的命令调至前台继续运行\r\n* bg 将一个在后台暂停的命令，变成继续执行\r\n* commend & 后台执行一个程序\r\n* linux命令后台运行.两种方式：\r\n    * command & ： 后台运行，你关掉终端会停止运行\r\n    * nohup command & ： 后台运行，你关掉终端也会继续运行\r\n\r\n### 偶尔会忘的操作\r\n* 将普通用户加入wheel组使其获得sudo权限\r\n   * useradd dyg -G wheel 或者\r\n   * usermod dyg -G wheel\r\n* 递归更改文件夹属组\r\n   * chmod -R dyg:dyg 文件名\r\n\r\n\r\n## 软件安装升级\r\n1. 安装c++编译器\r\n    * yum install gcc gcc-c++ \r\n2. 安装make\r\n    * yum install make\r\n3. 安装nodejs \r\n    * yum install nodejs\r\n4. 安装指定版本的nodejs \r\n    1. 官网找到下载链接后\r\n        * wget https://npmmirror.com/mirrors/node/v16.13.1/node-v16.13.1-linux-x64.tar.xz\r\n    2. 解压 【v显示解压过程，x解压，f指定解压文件，z解压后缀为gz的压缩包】\r\n       * tar vxf node-v16.13.1-linux-x64.tar.xz\r\n       * tar vxfz node-v16.13.1-linux-x64.tar.gz  \r\n    3. 创建软连接；【-s表示soft 软】\r\n        * ln -s /home/用户名/node-v16.13.1-linux-x64/bin/node /usr/local/bin/\r\n        * ln -s /home/用户名/node-v16.13.1-linux-x64/bin/npm /usr/local/bin/\r\n5. CentOS8完美升级gcc版本方法\r\n   1. 安装gcc-toolset-10\r\n\t    * dnf install gcc-toolset-10\r\n   2. 激活gcc版本，使其生效\r\n      \t* scl enable gcc-toolset-10 bash 或\r\n      \t* source /opt/rh/gcc-toolset-10/enable\r\n   3. 此时通过gcc --version命令可以看到，gcc版本已经变成10.x.x，\r\n        ```\r\n        值得注意的是这仅仅在当前bash生效，\r\n        如果需要永久生效，可以请自行添加环境变量。\r\n        仅适用于CentOS8、Redhat8版本\r\n        在CentOS8版本中，红帽也提供了开发工具包管理gcc版本，\r\n        install的包名从devtoolset-x变成了gcc-toolset-x，\r\n        通过该方式升级gcc好处就是随时可以切换gcc版本，不破坏原有gcc环境。\r\n        gcc-toolset-9对应gcc9.x.x版本\r\n        gcc-toolset-10对应gcc10.x.x版本\r\n        ```\r\n"},{"shortInfo":{"layout":"post","title":"miniconda备忘笔记","date":"2022-01-29T05:52:00.000Z","cover":"\\self_server\\assets\\images\\conda.png","tags":["笔记","miniconda"],"hideAtIndex":true,"categories":"笔记","id":34,"countWords":323,"readSeconds":32.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# miniconda命令备忘笔记\r\n* miniconda和anaconda中都包含了conda。\r\n* conda是一款软件管理软件，相当于windows里面的应用商店。\r\n* miniconda 安装包大小约为51.4 Mb，包含conda、python\r\n* anaconda 安装包大小约为462 Mb，包含了数据科学和机器学习要用到的很多软件。\r\n\r\n## 安装Miniconda\r\n* win10安装方法\r\n    + 官网下载安装包安装\r\n    + 配置环境\r\n        + 自动配置环境(初始化终端Shell 以便往后可以直接运行conda命令)\r\n            + `/Miniconda3安装目录/Miniconda3/Scripts/conda init [shellName]`\r\n        - gitShell手动配置环境\r\n            + 在git安装目录中的etc/profile 添加如下代码\r\n            + `export PATH=\"$PATH:/Miniconda3安装目录/Miniconda3/Scripts/\"`\r\n        - powerShell手动配置环境\r\n            + 添加系统环境变量\r\n            + PATH:`/Miniconda3安装目录/Miniconda3/Scripts/`\r\n\r\n## 创建并激活环境\r\n* 重启shell\r\n* 创建一个名为d2l的环境 `conda create --name d2l python=3.8 -y`\r\n* 查看现有环境 `conda env list`\r\n* 激活 d2l 环境`conda activate d2l`\r\n## 环境\r\n* 创建环境\r\n    + conda create [--name|-n] 环境名\r\n* 列出环境\r\n    + conda env list\r\n* 删除环境\r\n    + conda env remove --name 环境名\r\n* 激活环境\r\n    + conda activate 环境名\r\n\r\n## 软件\r\n* 安装软件包\r\n    + conda install package_name\r\n* 切换默认channel安装软件包\r\n    + conda install -c channel_name package_name\r\n\r\n## 源\r\n* 恢复默认配置（删除家目录的配置文件）\r\n    + rm ~/.condarc\r\n\r\n"},{"shortInfo":{"title":"mkcert生成自签https证书过程记录","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-08-22T14:45:00.000Z","tags":["mkcert","自签","https","证书"],"hideAtIndex":true,"categories":"笔记","id":35,"countWords":1063,"readSeconds":106.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# mkcert生成自签https证书过程记录\r\n## 目录\r\n- ](#mkcert生成自签https证书过程记录)\r\n  - ](#目录)\r\n  - ](#相关概念)\r\n  - ](#安装mkcert)\r\n  - ](#生成用户证书)\r\n  - ](#安装颁发者证书)\r\n    - ](#在pc端安装)\r\n    - ](#在ios端安装)\r\n\r\n## 相关概念\r\n* **数字证书认证机构（CA），**\r\n  * 是负责发放和管理数字证书的权威机构，\r\n  * 负责签发证书、认证证书、管理已颁发证书\r\n  * CA 也拥有用户的证书（内含公钥）和私钥。\r\n  * 任何人都可以得到 CA 的证书（含公钥），用以验证 CA 所签发的证书。\r\n* **用户证书**\r\n  * 用户若欲获取证书，应先向 CA 提出申请，CA 判明申请者的身份后，为之分配一个公钥，并将该公钥与其身份信息绑定，为该整体签名，签名后的整体即为证书，发还给申请者。\r\n* **鉴别用户证书的真伪**\r\n  * 一个用户想鉴别另一个用户的证书的真伪，用 CA 的公钥对那个证书上的签字进行验证，一旦验证通过，该证书就被认为是有效的。\r\n\r\n\r\n\r\n## 安装mkcert\r\n**安装mkcert工具**\r\n```bash\r\nsudo apt-get install mkcert\r\n```\r\n\r\n\r\n## 生成用户证书\r\n**生成证书:`cert.crt` 和 私钥:`cert-key.key`**\r\n```bash\r\nmkcert -cert-file ~/.ssl/cert.crt -key-file ~/.ssl/cert-key.key cn-zz-bgp-2.natfrp.cloud 43.249.193.55 localhost 127.0.0.1 ::1\r\n\r\n# 输出结果:\r\n# Created a new local CA 💥\r\n# Note: the local CA is not installed in the system trust store.\r\n# Note: the local CA is not installed in the Firefox and/or Chrome/Chromium trust store.\r\n# Run \"mkcert -install\" for certificates to be trusted automatically ⚠️\r\n# \r\n# Created a new certificate valid for the following names 📜\r\n#  - \"cn-zz-bgp-2.natfrp.cloud\"\r\n#  - \"43.249.193.55\"\r\n#  - \"localhost\"\r\n#  - \"127.0.0.1\"\r\n#  - \"::1\"\r\n# \r\n# The certificate is at \"~/.ssl/cert.crt\" and the key at \"~/.ssl/cert-key.key\" ✅\r\n# \r\n# It will expire on 22 November 2024 🗓\r\n# \r\n# \r\n```\r\n\r\n**配置服务器安装用户证书(以code-server为例)**\r\n```bash\r\n# vi ~/.config/code-server/config.yaml\r\n# code-server的配置文件:\r\nbind-addr: 0.0.0.0:8080\r\nauth: password\r\npassword: ???????????????????????\r\n# cert 为刚刚生成的证书\r\ncert: /home/userName/.ssl/cert.crt\r\n# cert-key 为刚刚生成的私钥\r\ncert-key: /home/userName/.ssl/cert-key.key\r\n```\r\n\r\n**此时访问localhost将依然报错,因为没有为浏览器安装颁发者的证书**\r\n\r\n![](./images/mkcert生成自签https证书过程记录/98e2d9d7e5fd0ced7043c50a28be71243a50b4830341e38753308ed6f96eac4f.png)  \r\n\r\n## 安装颁发者证书\r\n\r\n### 在PC端安装\r\n**方法1:使用命令将颁发者mkcert机构证书添加到系统信任,同时安装到本机的火狐浏览器和谷歌浏览器**\r\n```bash\r\nmkcert -install\r\n\r\n# 输出结果:\r\n# \r\n# The local CA is now installed in the system trust store! \r\n# 翻译:本地证书已经添加到到系统信任仓库\r\n# Warning: \"certutil\" is not available, so the CA can't be automatically installed in Firefox and/or Chrome/Chromium! ⚠️\r\n# 翻译:certutil(证书工具)不可用,所以证书无法自动安装到本机的浏览器\r\n# Install \"certutil\" with \"apt install libnss3-tools\" and re-run \"mkcert -install\" 👈\r\n# 翻译: 执行 \"apt install libnss3-tools\"来安装\"certutil\",然后 重新执行 \"mkcert -install\"\r\n\r\n# 安装libnss3-tools\r\napt install libnss3-tools\r\n# 重新执行 \"mkcert -install\"\r\nmkcert -install\r\n```\r\n\r\n**此时浏览器就能正常访问了**\r\n\r\n![](./images/mkcert生成自签https证书过程记录/ea42bffa2f50e7090b52dced9381273fb9276f334a863d6e8c1cda6b3030a98e.png)  \r\n\r\n\r\n\r\n**方法2:手动将颁发者mkcert机构证书手动添加到客户端的浏览器**\r\n**查看 CA 证书的存放位置**\r\n```bash\r\nmkcert -CAROOT\r\n# 输出结果:\r\n# /root/.local/share/mkcert\r\n\r\ntree $(mkcert -CAROOT)\r\n# 输出结果: \r\n# /home/dyg/.local/share/mkcert\r\n# ├── rootCA-key.pem 颁发者机构的私钥\r\n# └── rootCA.pem 颁发者机构的证书\r\n```\r\n\r\n**然后将上述颁发者mkcert机构证书文件`rootCA.pem`手动添加到pc端的浏览器中**\r\n\r\n![](./images/mkcert生成自签https证书过程记录/d54fd4c159d8f58627c6ec16a28ced8b2f47fd3a1b7d57dedd94031a6c68c6d3.png)  \r\n\r\n\r\n### 在IOS端安装\r\n\r\n**将颁发者mkcert机构证书手动添加到**\r\n\r\n**安装前**\r\n![](./images/mkcert生成自签https证书过程记录/6c7400885884577a2b676133ffe162ed3485dea02996e03b7c9c9ef45c307f7d.png)  \r\n\r\n![](./images/mkcert生成自签https证书过程记录/c0eb4ee022cca679c29669fd4cd0171fb124ccacec29670bb9dcdca59d46176c.png)  \r\n\r\n\r\n**安装中**\r\n![](./images/mkcert生成自签https证书过程记录/273368cf71de2ec25d2f2db736245f692c0a4d209a18a8c7d8f2bb9c64d0c1ec.png)  \r\n![](./images/mkcert生成自签https证书过程记录/816173bb4129ce92bbb68192a9f57d0218df7d1f3fb78ba2f6e0ce90a37f858d.png)  \r\n![](./images/mkcert生成自签https证书过程记录/8146b3f22175a2139a6edd516eabedd020c7d394772057d918fba0c2d00ed3fc.png)  \r\n![](./images/mkcert生成自签https证书过程记录/3a54b606903275febc7a5e9d03f031bab96c4e1aa09b64e986b5b405a5581d48.png)  \r\n![](./images/mkcert生成自签https证书过程记录/379bb20613e6ebf812129a2ce13ca9a14eef295f69cdc41ecb5b40a9f45346bc.png)  \r\n![](./images/mkcert生成自签https证书过程记录/df4be11a914591cdeb1327c453b4d988bca8de2ce1deb45ab89f4015e821527e.png)  \r\n\r\n\r\n\r\n\r\n**安装后**\r\n![](./images/mkcert生成自签https证书过程记录/6e926867c2eb90dbcebe8911a7863ea099f4bc6c2230fafb7a94982fd8d4e4cd.png)  \r\n\r\n![](./images/mkcert生成自签https证书过程记录/b67d7716a9270e7e723ba322faa4293cf706c1e35d8b7969ee5356446923b6e7.png)  \r\n"},{"shortInfo":{"layout":"post","title":"MySql笔记","date":"2022-05-26T20:50:00.000Z","cover":"\\self_server\\assets\\images\\MySql.webp","tags":["笔记","MySql"],"hideAtIndex":true,"categories":"笔记","id":36,"countWords":131,"readSeconds":13.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# mySql笔记\r\n\r\n\r\n## mySql8.0\r\n* 列出所有数据库:show databases;\r\n* 清空MySQL——root密码\r\n    1. 停止 MySQL 任务 net stop MySQL\r\n    1. mysqld 命令 mysqld --console --skip-grant-tables --shared-memory\r\n    1. 无密码进入mysql mysql -u root\r\n    1. 清空root 密码 UPDATE user SET authentication_string=\"\" WHERE user='root';\r\n    2. 重新载入授权表。FLUSH PRIVILEGES;\r\n        * 如果你不使用该命令，你就无法使用新创建的用户来连接mysql服务器，除非你重启mysql服务器。\r\n* 修改用户密码\r\n  1. use mysql;\r\n  4. alter user root@localhost identified by '密码';\r\n  5. FLUSH PRIVILEGES;\r\n\r\n"},{"shortInfo":{"layout":"post","title":"nexmoe主题文章底部UTF-8链接转中文","date":"2022-02-23T13:46:00.000Z","cover":"\\self_server\\assets\\images\\nexmoe主题文章底部UTF-8链接转中文.png","tags":["笔记","nexmoe"],"hideAtIndex":true,"categories":"前端","id":37,"countWords":191,"readSeconds":19.1,"assetsbaseUrl":"/self_server/assets/"},"content":"## 原代码\r\n```\r\n<% if (page.hide_copyright !== true && theme.copyright || page.copyright) { %>\r\n    <div class=\"nexmoe-post-copyright\">\r\n        <strong><%- __('copyright.author') %>：</strong><%= config.author %><br>\r\n        <strong><%- __('copyright.permalink') %>：</strong>\r\n        <%- link_to(page.permalink, page.permalink, {external: true}) %><br>\r\n        <% if (page.copyright) { %>\r\n            <%- page.copyright %>\r\n        <% } else { %>\r\n            <%- theme.copyright %>\r\n        <% } %>\r\n    </div>\r\n<% } %>\r\n```\r\n\r\n## 修改后\r\n```\r\n<% if (page.hide_copyright !== true && theme.copyright || page.copyright) { %>\r\n    \r\n    <script type=\"text/javascript\">\r\n        var decodePageURI = decodeURI(\"<%- page.permalink %>\")\r\n        timer = null\r\n        timer=setInterval(function(){\r\n            do\r\n            {\r\n                document.getElementById(\"page_address\").href=decodePageURI\r\n                document.getElementById(\"page_address\").title=decodePageURI\r\n                document.getElementById(\"page_address\").innerHTML=decodePageURI\r\n            }while(document.getElementById(\"page_address\").innerHTML!=decodePageURI)\r\n            clearInterval(timer)\r\n        },\r\n        100\r\n        )\r\n    </script>\r\n\r\n    <div class=\"nexmoe-post-copyright\">\r\n        <strong><%- __('copyright.author') %>：</strong><%= config.author %><br>\r\n        <strong><%- __('copyright.permalink') %>：</strong>\r\n        <!-- <%- link_to(page.permalink, page.permalink, {external: true}) %><br> -->\r\n        <a id=\"page_address\" href=\"\" title=\"\" target=\"_blank\" rel=\"noopener\"></a><br>\r\n        <% if (page.copyright) { %>\r\n            <%- page.copyright %>\r\n        <% } else { %>\r\n            <%- theme.copyright %>\r\n        <% } %>\r\n    </div>\r\n<% } %>\r\n```\r\n## 效果\r\n修改后效果为能根据page.permalink内容展示UTF-8解码后的中文URL\r\n{% gallery %}\r\n![修改前](../images/修改前.png)\r\n![修改后](../images/修改后.png)\r\n{% endgallery %}\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n\r\n"},{"shortInfo":{"title":"nginx实现反向代理并启用ssl的最简配置","date":"2022-08-23T09:36:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["nginx","反向代理"],"hideAtIndex":true,"categories":"笔记","id":38,"countWords":159,"readSeconds":15.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# nginx实现反向代理并启用ssl的最简配置\r\n\r\n```confg\r\nserver {\r\n    listen       8082; \r\n    server_name  localhost;\r\n\r\n    #启用ssl\r\n    ssl on;\r\n    #ssl证书\r\n    ssl_certificate  /home/dyg/.ssl/cert.crt;\r\n    #ssl证书私钥\r\n    ssl_certificate_key /home/dyg/.ssl/cert-key.key;\r\n\r\n    location / {\r\n        #反向代理\r\n        proxy_pass http://localhost:8081;\r\n        #默认页面\r\n        index  index.html index.htm;\r\n    }\r\n}\r\n```\r\n\r\n# 将http请求转成https\r\n**案例:将http:80请求转成https:443**\r\n**仅适用于默认端口**\r\n```confg\r\nserver {\r\n    listen       443; \r\n    server_name  localhost;\r\n\r\n    #启用ssl\r\n    ssl on;\r\n    #ssl证书\r\n    ssl_certificate  /home/dyg/.ssl/cert.crt;\r\n    #ssl证书私钥\r\n    ssl_certificate_key /home/dyg/.ssl/cert-key.key;\r\n\r\n    location / {\r\n        #反向代理\r\n        proxy_pass http://localhost:8081;\r\n        #默认页面\r\n        index  index.html index.htm;\r\n    }\r\n}\r\nserver {\r\n    listen 80;\r\n    server_name localhost;\r\n    #将http请求转成https\r\n    rewrite ^(.*)$ https://$host$1 permanent;\r\n}\r\n```"},{"shortInfo":{"layout":"post","title":"nodejs-npm备忘笔记","date":"2022-01-09T12:28:00.000Z","cover":"\\self_server\\assets\\images\\nodejs2.webp","tags":["笔记","nodejs","npm"],"hideAtIndex":true,"categories":"笔记","id":39,"countWords":168,"readSeconds":16.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# nodejs-npm备忘笔记\r\n\r\n## npm工具的使用\r\n\r\n### npm 镜像源的设置和删除\r\n1. npm查看源：\r\n    * npm config get registry 或\r\n    * npm config list\r\n\r\n2. 设置成淘宝源:\r\n    * npm config set registry https://registry.npm.taobao.org/\r\n\r\n3. 设置成npm官方源:\r\n    * npm config set registry https://registry.npmjs.org/\r\n\r\n4. npm删除源\r\n   * npm config rm registry\r\n\r\n### npm 安装模块\r\n1. 安装给当前目录的项目：\r\n   * npm install [模块名]\r\n2. 安装到全局：\r\n   * npm install -g [模块名]\r\n3. 查看当前项目已安装的模块\r\n    * npm list\r\n4. 查看全局已安装的模块\r\n    * npm list -g\r\n5. 卸载【uninstall】已安装的模块 更新【update】 搜索【search】 \r\n    * npm uninstall  XXX\r\n    * npm uninstall  XXX -g\r\n6. 运行node\r\n    * npm run test"},{"shortInfo":{"title":"nodejs学习笔记","date":"2022-08-28T13:13:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["nodejs"],"hideAtIndex":true,"categories":"后端","id":40,"countWords":3017,"readSeconds":301.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# nodejs学习笔记\r\n## 目录\r\n- [nodejs学习笔记](#nodejs学习笔记)\r\n  - [目录](#目录)\r\n  - [基本概念](#基本概念)\r\n  - [模块](#模块)\r\n    - [概念](#概念)\r\n    - [通过`module.exports`实现模块化](#通过moduleexports实现模块化)\r\n    - [npm包管理工具](#npm包管理工具)\r\n  - [内置模块](#内置模块)\r\n    - [fs模块](#fs模块)\r\n    - [path路径模块](#path路径模块)\r\n    - [http模块](#http模块)\r\n  - [尝试自定义模块](#尝试自定义模块)\r\n  - [第三方模块](#第三方模块)\r\n    - [moment.js 三方模块](#momentjs-三方模块)\r\n    - [i5ting_toc 第三方模块](#i5ting_toc-第三方模块)\r\n    - [express模块](#express模块)\r\n\r\n\r\n## 基本概念\r\n* <red>**Nodejs是基于ChromeV8的js解析引擎**</red>\r\n* **js解析引擎**\r\n    * Chrome 浏览器 -> V8 **性能最好**\r\n    * Firefox 浏览器 ->   OdinMonkey 奥丁猴\r\n    * Safri 浏览器 -> JSCore\r\n    * IE 浏览器 -> Chakra查克拉\r\n* **运行环境区别**\r\n    * **Nodejs**是js的**后端**运行环境,能调用**nodejs的内置API**\r\n    * **浏览器**是js的**前端**运行环境,能调用**浏览器的内置API**\r\n    * ![图 3](./images/nodejs学习笔记/afb25ede4b5e464b04d2e39ded97f116b68c751c3bb781cd329d73e78c10ca58.png)  \r\n    * ![图 2](./images/nodejs学习笔记/7aa213781d4b45aa5495200255be62941fb36990715cf6fc70c800ca6d6ee2dd.png)  \r\n* **nodejs用途**\r\n  * 基于 **Express** 框架,可快速构建 **Web应用**\r\n  * 基于 **Express** 框架,可快速构建 **跨平台桌面应用**\r\n  * 基于 **restify** 框架,可快速构建 **API接口项目**\r\n  * 读写和操作数据库;创建实用的命令行辅助前端开发;......\r\n* 学习路径\r\n  * js基础语法\r\n  * nodejs内置API\r\n  * 第三方API:express mysql\r\n\r\n\r\n## 模块\r\n\r\n### 概念\r\n**模块的分类**\r\n* 内置模块\r\n* 第三方模块\r\n* 自定义模块\r\n\r\n**CommonJS模块化规范**\r\n* 一个 `.js` 文件就是一个模块,每个模块内部的 **module变量** 代表 **当前模块**\r\n* `module` 变量是一个 **对象** ,其 exports属性 是 对外的接口\r\n* 使用 `require()` 加载模块时,就是在加载 `module.exports` 属性\r\n\r\n>注意: 现已新增 **exports 变量** ,其默认指向`module.exports`所指向的对象,能够被覆盖,即当:`exports={}`时, `exports`便不再指向`module.exports`所指向的对象.\r\n\r\n**模块的加载机制**\r\n> 注意: 使用`require()`引入模块 `XXX.js` 时,会执行 `XXX.js` 中的代码  \r\n> 但模块在第一次引入后会被缓存,后续再次引入不会执行其中代码\r\n* 引入**内置模块**\r\n    ```js\r\n    const fs = require(fs)\r\n    ```\r\n    > 内置模块的优先级最高,即使`./node_modules/`下有`./fs/` 同名模块文件,也会优先加载内置模块\r\n* 引入**第三方模块**\r\n    ```js\r\n    const app = require(express)\r\n    ```\r\n    > 先到当前目录的`./node_modules/`查找模块,若没有则进入到上一级目录的`../node_modules/`,直到文件系统的根目录`/node_modules/`\r\n* 引入**自定义模块**\r\n    ```js\r\n    // 可以省略.js后缀\r\n    const demo1 = require(./demo/demo1.js)\r\n    const demo/demo1 = require(./demo/demo1)\r\n\r\n    // 若/demo2/目录下有package.json文件 则会从main属性找到模块的入口\r\n    const demo2 = require(./demo/demo2/demo2.js)\r\n    const demo2 = require(./demo/demo2)\r\n    ```\r\n    > 注意:引入**自定义模块**时必须使用`./`或`../`的相对路径,可以省略 `.js` 的文件名,  \r\n    > **require会自动按一下顺序补全后缀名**\r\n    > * 不补全\r\n    > * 补全`.js`\r\n    > * 补全`.json`\r\n    > * 补全`.node`\r\n    > * 任然无法定位文件则报错\r\n* **自定义模块:引入目录**\r\n    ```js\r\n    const demo2 = require(./demo/demo2)\r\n    ```\r\n    > 若引入的是一个目录,则有三种情况\r\n    > * 优先在查找**被引入目录**下的`package.json`的`main`属性所指向的文件\r\n    > * 若失败则查找**被引入目录**下的`index.js`文件\r\n    > * 若仍然无法找到,则报错\r\n\r\n\r\n### 通过`module.exports`实现模块化\r\n**使用示例**\r\n```js\r\n// demo1.js\r\nmodule.exports.name = \"DingYigui\"\r\nmodule.exports.sayHi = function(){\r\n    console.log(\"Hi\")\r\n}\r\n```\r\n```js\r\n// demo2.js\r\nconst demo1 = require(\"./demo1\")\r\ndemo1.sayHi();\r\n```\r\n\r\n\r\n### npm包管理工具\r\n\r\n**包的分类**\r\n* 项目包 存放在`./node_modules/`\r\n* 全局包 只有工具性质的包才有安装到全局的必要,因为其提供了终端命令工具\r\n\r\n**包的规范结构**\r\n* 包必须以单独的目录存在\r\n* 包的根目录下必须包含`package.js`\r\n* `package.js`必须包含 `name` `version` `main` 三个属性,其中main表示包的入口\r\n    > 通过`require(express)`引入包的过程: `./node_modules/express/package.js` -> `main` -> `./express.js` -> `module.exports`\r\n\r\n**使用npm安装第三方包后多出的文件夹和文件**\r\n* `node_modules/` 存放以安装的包, **require** 的搜索路径\r\n* `package-lock.json` 记录 **node_modules** 目录下每一个包的下载信息,包名,版本,下载地址.\r\n> 不要手动修改`node_modules/`和`package-lock.json`中的内容\r\n\r\n\r\n**包管理配置文件package.js**\r\n* 记录项目名称,版本,描述等\r\n* 记录项目中用到的其他包\r\n* 记录仅在开发期间用到的包\r\n* 记录仅在开发和部署期间用到的包\r\n> 该文件可通过`npm init -y` 命令生成  \r\n> 该文件中的 `dependencies` 项 会在执行 `npm install/uninstall packageName` 后更新  \r\n> 若省略包名,即执行 `npm install` 则会安装 `package.js` 中 `dependencies` 节点所记录的**所有包**\r\n\r\n**npm命令**\r\n* `npm init -y` 初始化当前项目\r\n* `npm install/uninstall pkgName` 安装/卸载包名\r\n* `npm install/uninstall pkgName@1.0.0` 安装/卸载包名\r\n  * `-g` 执行全局的操作\r\n  * `-D` `--save-dev` 所安装的包仅开发过程中使用到,记录到 `devDependencise` 节点中\r\n* `npm config set registry=https://registry.npmmirror.com/` 换源\r\n* `npm config get registry` 查看源设置情况\r\n* `npm login` 登陆npm帐号\r\n* `npm publish` 发布当前包\r\n* `npm unpublish  包名 --force` 删除发布的包\r\n  * 只能删除72小时以内发布的包\r\n  * 不能重新发布24小时内删除的包\r\n\r\n\r\n**版本号规范X.X.X**\r\n* 第一位数字 大版本,从底层重构\r\n* 第二位数字 功能版本,添加了新功能\r\n* 第三位数字 Bug修复版本,修复了Bug \r\n> 版本号提升规则: 某一位数字提升,该位之后的所有位归零\r\n\r\n\r\n\r\n**搜索包的官网**<br>\r\n搜索包:[npmjs.com](npmjs.com) <br>\r\n下载包:[registry.npmjs.org](registry.npmjs.org)\r\n\r\n\r\n**nrm工具**\r\n* 安装: `npm install nrm -g`\r\n* 查看可用镜像 nrm ls\r\n* 切换镜像 nrm use taobao\r\n\r\n\r\n\r\n\r\n\r\n## 内置模块\r\n\r\n\r\n### fs模块\r\n* `fs.readFile(path[,options],callback(err,data))` 读取指定文件,options默认为`utf-8`\r\n* `fs.writeFile(path,data[,options],callback(err))` 写入指定文件,options默认为`utf-8`\r\n  * 注意该函数只能创建文件不能创建文件夹\r\n  * 重复调用会覆盖上一次写入文件的内容\r\n\r\n**简单案例**\r\n```js\r\nconst fs = require(\"fs\")\r\n\r\nfs.readFile(\"./1.fs.js\",\"utf-8\",(err,data)=>{\r\n    if (err) {\r\n        console.log(err);\r\n    }else{\r\n        console.log(data);\r\n    }\r\n})\r\n\r\nfs.writeFile(\"./1.readfile.js\",\"这是写入的数据\",err=>{\r\n    if (err) {\r\n        console.log(err);\r\n    }\r\n})\r\n```\r\n\r\n**实际案例:数据格式化**\r\n```js\r\n/*\r\n将原数据:\r\n语文=100 数学=100 英语=100\r\n转换为: \r\n语文:100\r\n数学:100\r\n英语:100\r\n*/\r\n\r\nconst fs = require(\"fs\")\r\n\r\nfs.readFile(\"./src/成绩.txt\",\"utf-8\",(err,data)=>{\r\n    if (err) {\r\n        console.log(\"文件读取错误\" + err.message);\r\n    }else{\r\n        console.log(\"文件读取成功:\" + data);\r\n\r\n        var list = data.split(\" \")\r\n        var newList = []\r\n        var target = \"\"\r\n\r\n        console.log(\"处理数据中......\");\r\n        list.forEach((value,index)=>{\r\n            newList.push(value.replace(\"=\",\":\"))\r\n        })\r\n        target = newList.join(\"\\r\\n\")\r\n\r\n        console.log(\"处理数据完毕:\");\r\n        console.log(target);\r\n\r\n        console.log(\"写入数据中......\");\r\n        fs.writeFile(\"./src/成绩-output.txt\",target,err=>{\r\n            if (err) {\r\n                console.log(err);\r\n            }else{\r\n                console.log(\"写入完毕.\");\r\n            }\r\n        })\r\n    }\r\n})\r\n```\r\n\r\n\r\n**路径拼接的问题**<br>\r\n在使用相对路径读取文件时,`./`表示**当前目录**,在程序中,该**当前目录**默认为node命令执行时所在的目录,而不是程序文件所在的目录\r\n<br>\r\n**解决方案**\r\n* 使用 绝对路径\r\n* 使用字符串拼接 `__dirname` + 相对路径(不能带有 `./` 或 `../`)\r\n  * __dirname表示当前`.js`文件所在目录 \r\n  * 这种方式仍然存在一些问题\r\n\r\n\r\n### path路径模块\r\n* `path.join([...paths])` 用来将多个路径片段拼接成一个完整的路径字符串\r\n* `path.basename(/path/to/fileName.txt)` 用来获取路径中的`文件名.扩展名`\r\n* `path.extname(/path/to/fileName.txt)` 用来获取路径中的`.扩展名`\r\n\r\n**简单案例**\r\n```js\r\nconst path = require(\"path\")\r\n\r\nvar temp1 = path.join(\"/home\",\"/dyg\",\"./\",\"../\",\"/admin\",\"test.txt\")\r\nconsole.log(temp1);\r\n/*\r\n输出:\r\n/home/admin/test.txt\r\n*/\r\n\r\nvar temp2 = path.join(__dirname,\"test.txt\")\r\nconsole.log(temp2);\r\n/*\r\n输出:\r\n/mnt/D/GitProject/YiguiDing.github.ioV2/source/_posts/nodejs学习笔记/demos/test.txt\r\n*/\r\n```\r\n\r\n```js\r\nvar temp3 = path.basename(\"/path/to/fileName.txt\")\r\nconsole.log(temp3);\r\n/*\r\n输出:\r\nfileName.txt\r\n*/\r\n\r\nvar temp4 = path.basename(\"/path/to/fileName.12345\",\"345\")\r\nconsole.log(temp4);\r\n/*\r\n输出:\r\nfileName.12\r\n*/\r\n```\r\n\r\n\r\n```js\r\nvar temp5 = path.extname(\"/path/to/fileName.12345\")\r\nconsole.log(temp5);\r\n/*\r\n输出:\r\n.12345\r\n*/\r\n```\r\n\r\n**综合案例**\r\n```js\r\nconst fs = require(\"fs\")\r\nconst path = require(\"path\")\r\n\r\n\r\nfs.readFile(path.join(__dirname,\"./src/待拆分文件.html\"),\"utf-8\",(err,data)=>{\r\n    if(err){\r\n        console.log(err);\r\n    }else{\r\n        // console.log(data);\r\n        resolveCSS(data);\r\n        resolveJS(data);\r\n        resolveHTML(data);\r\n    }\r\n})\r\n\r\n\r\nfunction resolveCSS(html){\r\n    const reg = /<style>[\\s\\S]*<\\/style>/\r\n    var value = reg.exec(html)[0].replace(/<style>/g,\"\").replace(/<\\/style>/g,\"\")\r\n    // console.log(value);\r\n    fs.writeFile(path.join(__dirname,\"./src/index.css\"),value,err=>{\r\n        if(err)\r\n            console.log(\"resolveCSS failed:\"+err);\r\n        else\r\n            console.log(\"resolveCSS success\");\r\n    })\r\n}\r\n\r\nfunction resolveJS(html){\r\n    const reg = /<script>[\\s\\S]*<\\/script>/\r\n    var value = reg.exec(html)[0].replace(/<script>/g,\"\").replace(/<\\/script>/g,\"\")\r\n    // console.log(value);\r\n    fs.writeFile(path.join(__dirname,\"./src/index.js\"),value,err=>{\r\n        if(err)\r\n            console.log(\"resolveJS failed:\"+err);\r\n        else\r\n            console.log(\"resolveJS success\");\r\n    })\r\n    return value;\r\n}\r\n\r\nfunction resolveHTML(html){\r\n    var value = html\r\n    .replace(/<style>[\\s\\S]*<\\/style>/,\"\")\r\n    .replace(/<script>[\\s\\S]*<\\/script>/,\"\")\r\n    .replace(/<\\/title>/,`</title>\r\n        <link rel=\"stylesheet\" href=\"./index.css\" \\>\r\n        <script src=\"./index.js\"></script>\r\n    `)\r\n    fs.writeFile(path.join(__dirname,\"./src/index.html\"),value,err=>{\r\n        if(err)\r\n        console.log(\"resolveHTML failed:\"+err);\r\n        else\r\n        console.log(\"resolveHTML success:\"+value);\r\n    })\r\n}\r\n```\r\n**./src/待拆分文件.html**\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Document</title>\r\n    <style>\r\n        #id_1{\r\n            width: 200px;\r\n            height: 100px;\r\n            background-color: skyblue;\r\n            color: red;\r\n        }\r\n    </style>\r\n        <style>\r\n            #id_2{\r\n                width: 200px;\r\n                height: 100px;\r\n                background-color: skyblue;\r\n                color: red;\r\n            }\r\n        </style>\r\n    <script>\r\n        console.log(\"this is js code\")\r\n    </script>\r\n</head>\r\n<body>\r\n    <div id=\"id_1\">\r\n        测试文字\r\n        测试文字\r\n        测试文字\r\n        测试文字\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n### http模块\r\n**request 的属性和方法**\r\n* `request.url` 如:`/`;`/index.html` \r\n* `request.method` 如 `GET` `POST`\r\n\r\n**response 的属性和方法**\r\n* `response.end(string)` 向客户端响应内容\r\n* `response.setHeader(\"key\",\"value\")` 设置响应头\r\n  * 防止中文乱码`response.setHeader(\"Content-Type\",\"text/url;charset=utf-8\")`\r\n\r\n\r\n**简易案例**\r\n```js\r\n//导入http模块\r\nconst http = require(\"http\")\r\n\r\n//创建实例对象\r\nconst server = http.createServer()\r\n\r\n//绑定request事件\r\nserver.on(\"request\",(req,res)=>{\r\n    console.log(\"收到了一个http请求...\");\r\n})\r\n\r\n//启动服务\r\nserver.listen(8000,()=>{\r\n    console.log(\"服务器已启动,正在监听8000端口...\");\r\n})\r\n```\r\n**简易动态响应(路由)的实现**\r\n```js\r\n//导入http模块\r\nconst http = require(\"http\")\r\n\r\n//创建实例对象\r\nconst server = http.createServer()\r\n\r\n//绑定request事件\r\nserver.on(\"request\",(req,res)=>{\r\n    const url = req.url\r\n    let content = `<h1>404</h1>`\r\n    \r\n    if(url===\"/\" || url===\"/index\" || url===\"/index.html\"){\r\n        content = `<h1>index</h1>`\r\n    }else\r\n    if(url===\"/about\" ||  url===\"/about.html\"){\r\n        content = `<h1>about</h1>`\r\n    }\r\n\r\n    res.setHeader(\"Content-Type\",\"text/html;charset=utf-8\")\r\n    res.end(content)\r\n})\r\n\r\n//启动服务\r\nserver.listen(8000,()=>{\r\n    console.log(\"服务器已启动,正在监听8000端口...\");\r\n})\r\n```\r\n\r\n**实现简易Web服务器**\r\n```js\r\n//导入http模块\r\nconst fs = require(\"fs\")\r\nconst path = require(\"path\")\r\nconst http = require(\"http\")\r\n\r\n//创建实例对象\r\nconst server = http.createServer()\r\n\r\n//绑定request事件\r\nserver.on(\"request\",(req,res)=>{\r\n    const rootUrl = \"./src\"\r\n    let url = req.url\r\n    let content = `<h1>404</h1>`\r\n    \r\n    if(url===\"/\" || url===\"/index\" || url===\"/index.html\"){\r\n        url=`/index.html`\r\n    }\r\n\r\n    fs.readFile(path.join(__dirname,rootUrl,url),\"utf-8\",(err,data)=>{\r\n        if(err) {\r\n            // content = err.message\r\n        }\r\n        else {\r\n            content = data\r\n        }\r\n        // res.setHeader(\"Content-Type\",\"text/html;charset=utf-8\") //text/html会导致浏览器无法识别css代码\r\n        res.end(content)\r\n    })\r\n})\r\n\r\n//启动服务\r\nserver.listen(8000,()=>{\r\n    console.log(\"服务器已启动,http://127.0.0.1:8000/\");\r\n})\r\n```\r\n\r\n\r\n\r\n## 尝试自定义模块\r\n**目录结构**\r\n* 自定义模块根目录\r\n  * index.js\r\n  * package.json\r\n  * README.md\r\n* test.js\r\n\r\n\r\n\r\n\r\n**index.js**\r\n```js\r\n// 实现html转义\r\nfunction htmlEncode(content){//编码\r\n    return content.replace(/<|>|\"|&/g,march=>{\r\n        switch(march){\r\n            case '<':\r\n                return '&lt;';\r\n            case '>':\r\n                return '&gt;';\r\n            case '\"':\r\n                return '&quot;';\r\n            case '&':\r\n                return \"&amp;\";\r\n         }\r\n    })\r\n}\r\nfunction htmlDecode(content){//解码\r\n    return content.replace(/&lt;|&gt;|&quot;|&amp;/g,march=>{\r\n        switch(march){\r\n            case '&lt;':\r\n                return '<';\r\n            case '&gt;':\r\n                return '>';\r\n            case '&quot;':\r\n                return '\"';\r\n            case '&amp;':\r\n                return \"&\";\r\n         }\r\n    })\r\n}\r\nmodule.exports.htmlEncode = htmlEncode\r\nmodule.exports.htmlDecode = htmlDecode\r\n```\r\n\r\n**package.json**\r\n```json\r\n{\r\n  \"name\": \"demo-test\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"描述\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\"\r\n}\r\n\r\n```\r\n\r\n**test.js**\r\n```js\r\nconst test = require(\"./6.自定义模块\")\r\n\r\nvar html = `<h1 style=\"color:skyblue\">测试</h1>`\r\nvar encode = test.htmlEncode(html)\r\nvar decode = test.htmlDecode(encode)\r\n\r\nconsole.log(encode);\r\nconsole.log(decode);\r\n```\r\n\r\n\r\n## 第三方模块\r\n\r\n**为什么需要第三方包?**<br>\r\nnodejs内置模块仅提供了底层API,使用内置模块开发效率低,<br>\r\n第三方模块是基于内置模块开发的,提供了更高级更方便的API,提高了开发效率\r\n\r\n\r\n\r\n### moment.js 三方模块\r\n```js\r\nconst moment = require(\"moment\")\r\n\r\nvar tm = moment().format(\"YYYY-MM-DD HH-mm-ss\")\r\nconsole.log(tm);\r\n```\r\n\r\n### i5ting_toc 第三方模块\r\n(用处不大)<br>\r\ni5ting_toc 是md转html的命令行工具,需全局安装<br>\r\n**使用**\r\n```\r\ni5ting_toc -f ./fileName.md -o \r\n```\r\n\r\n\r\n### express模块\r\n<red>详细笔记:[express学习笔记]()</red>  \r\nexpress作用和nodejs的http模块类似,用于创建web服务器<br>\r\nexpress是基于http模块封装的,使用起来比http模块简单,效率更高\r\n\r\n\r\n<style>\r\n    red{\r\n        color:red;\r\n    }\r\n    sky{\r\n        color:skyblue;\r\n    }\r\n    \r\n</style>"},{"shortInfo":{"title":"nodejs的mysql模块学习笔记","date":"2022-08-30T23:25:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["nodejs","mysql"],"hideAtIndex":true,"categories":"后端","id":41,"countWords":888,"readSeconds":88.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# nodejs的mysql模块学习笔记\r\n\r\n\r\n**无法连接数据库的解决**  \r\n`MySQL8` 之前的版本中加密规则是 `mysql_native_password` ,而在之后版本，加密规则是 `caching_sha2_password` ,当前nodejs的mysql模块不支持该加密规则,于是需要修改会旧的加密规则\r\n```bash\r\n# 进入mysql\r\nmysql -u root -p\r\n# 输入:\r\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY \"新密码\";\r\n```\r\n\r\n## 连接数据库\r\n**示例代码**\r\n```js\r\nconst mysql = require(\"mysql\") \r\nconst db = mysql.createConnection({\r\n    host: \"localhost\",\r\n    user: \"root\",\r\n    password: \"root\",\r\n    database: \"my_db_01\",\r\n})\r\n\r\ndb.connect();\r\n\r\n```\r\n\r\n\r\n## 查询数据库\r\n**示例代码**\r\n```js\r\ndb.query(\"SELECT * from users\",(err,result)=>{\r\n    if(err){\r\n        console.log(err);\r\n    }else{\r\n        console.log(message);\r\n    }\r\n})\r\n```\r\n\r\n**输出result结果**  \r\n注意: 执行`select`语句的查询结果为数组\r\n```js\r\n[\r\n  RowDataPacket {\r\n    id: 1,\r\n    username: 'DingYigui',\r\n    password: '123',\r\n    status: 0\r\n  },\r\n  RowDataPacket {\r\n    id: 10,\r\n    username: 'DYG1231',\r\n    password: 'd12yg1232',\r\n    status: 0\r\n  }\r\n]\r\n```\r\n\r\n## 插入数据\r\n**方法1**\r\n```js\r\nvar user = {username:\"newUser\",password:\"newPasswd\"}\r\nvar sqlStr = \"INSERT INTO users (username,password) VALUES (?,?);\" //?为占位符\r\n\r\ndb.query(sqlStr,[user.username,user.password],(err,result)=>{ //第二个参数中的数据将被依次填入占位符\r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"插入成功!,新增\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"插入数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n**输出result结果**  \r\n注意: 执行`INSERT` `UPDATE` `DELETE` 语句的结果均为对象\r\n```js\r\nOkPacket {\r\n  fieldCount: 0,\r\n  affectedRows: 1,\r\n  insertId: 11,\r\n  serverStatus: 2,\r\n  warningCount: 0,\r\n  message: '',\r\n  protocol41: true,\r\n  changedRows: 0\r\n}\r\n```\r\n\r\n**方法2:更高效的方式**\r\n```js\r\nvar user = {username:\"newUser2\",password:\"newPasswd2\"}\r\nvar sqlStr = \"INSERT INTO users set ?;\" //?为占位符\r\n\r\ndb.query(sqlStr,user,(err,result)=>{ //将会自动展开为: UPDATE users SET username = \"newUser2\" , password = \"newPasswd2\" \r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"插入成功!,新增\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"插入数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n## 更新数据\r\n**方法1**\r\n```js\r\nvar user = {username:\"newUser3\",password:\"newPasswd3\",id:2}\r\nvar sqlStr = \"UPDATE users SET username=?,password=? WHERE id=?;\" //?为占位符\r\ndb.query(sqlStr,[user.username,user.password,user.id],(err,result)=>{ //第二个参数中的数据将被依次填入占位符\r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"更新成功!,新增\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"更新数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n**方法2:更高效的方式**\r\n```js\r\nvar user = {username:\"newUser3\",password:\"newPasswd3\",id:2 }\r\nvar sqlStr = \"UPDATE users SET ? WHERE id=?;\" //?为占位符\r\n\r\ndb.query(sqlStr,[user,user.id],(err,result)=>{ //将会自动展开为: UPDATE users SET username=newUser3,password=newPasswd3,id=2 WHERE id=2;\r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"更新成功!,新增\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"更新数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n## 删除数据\r\n```js\r\nvar userID = 5 \r\nvar sqlStr = \"DELETE FROM users WHERE id=?;\" //?为占位符\r\ndb.query(sqlStr,userID,(err,result)=>{ \r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"删除成功!,删除\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"删除数据失败!\");\r\n    }\r\n})\r\n```\r\n\r\n## 标记数据为删除\r\n实际中删除一个用户后存在用户想要撤销删除操作的可能,对于这种需求可以采取修改用户状态为已删除的方式来实现\r\n```js\r\nvar userID = 5 \r\nvar sqlStr = \"UPDATE users SET status=? WHERE id=?;\" //?为占位符\r\ndb.query(sqlStr,[1,5],(err,result)=>{ \r\n    if(err){\r\n        console.log(err.message);\r\n    }else{\r\n        //affectedRows中记录了本次操作影响的行数\r\n        if(result.affectedRows>0) console.log(\"标记用户为已删除成功!,更新了\" + result.affectedRows + \"条数据\");\r\n        else console.log(\"标记用户为已删除失败!\");\r\n    }\r\n})\r\n```\r\n\r\n\r\n## mysql2基本使用\r\n```js\r\nimport mysql from \"mysql2\"\r\nconst pool = mysql.createPool({\r\n    host: \"localhost\",\r\n    user: \"root\",\r\n    password: \"root\",\r\n    database: \"my_db_01\",\r\n})\r\n\r\nexport default  pool.promise()\r\n\r\n\r\n// --------------------------------------------\r\nimport db from \"./mysql.js\" \r\nexport async function getUserInfo(req,res){\r\n    const sql = \"???????\"\r\n    let result = await db.query(sql)\r\n    res.send({\r\n         status:0,\r\n         message:\"\",\r\n         data:result,\r\n    })\r\n}\r\n```"},{"shortInfo":{"title":"promise学习笔记","date":"2022-07-17T23:38:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["promise"],"hideAtIndex":true,"categories":"笔记","id":43,"countWords":5429,"readSeconds":542.9,"assetsbaseUrl":"/self_server/assets/"},"content":"## 简介\r\n* promise对象是ES6（ECMAscript 6 ）引入的用于**异步编程**的**新**解决方案\r\n  * **旧**方法单纯使用回调函数\r\n  * **新**方法使用promise\r\n* 从语法上来说就是一个构造函数，用来封装异步的任务，并能对结果进行处理\r\n* promise在app、web中应用广泛；\r\n* 前端和后端都会用到；\r\n* 也是面试高频题目，进大厂需要掌握其内部原理\r\n* Promise支持链式操作，能够解决**回调地狱问题**\r\n* promise指定回调函数非常灵活，\r\n  * 旧方法必须在启动异步任务前指定回调函数`setTimeout(()=>{},2000)`\r\n  * promise方法可以在启动异步任务后指定回调函数\r\n\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**常见异步操作**\r\n* 定时器\r\n    ```js\r\n    //旧方法\r\n    setTimeout(()=>{},2000)\r\n    ```\r\n* ajax\r\n    ```js\r\n    //旧方法\r\n    $.get(\"./path/to/file\",(data)=>{})\r\n    ```\r\n* 数据库操作\r\n* fs文件操作\r\n    ```js\r\n    require(\"fs\").readFile(\"./file\",(error,data)=>{})\r\n    ```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**回调地狱问题**\r\n* **旧**方法单纯使用回调函数，需反复嵌套，不支持链式操作\r\n* 不利于阅读\r\n* 不便于错误处理\r\n```js\r\nfunctionA(args,(err,data)=>{\r\n    functionB(args,(err,data)=>{\r\n        functionC(args,(err,data)=>{\r\n            functionE(args,(err,data)=>{\r\n                functionF(args,(err,data)=>{\r\n                })\r\n            })\r\n        })\r\n    })\r\n})\r\n\r\n```\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**箭头函数**\r\n* `()=>{}`\r\n* ES6标准\r\n* 箭头函数中形参若只有一个则可以省略小括号\r\n* 箭头函数中的`this`始终指向该函数的创建环境，而不是其调用者\r\n* 箭头函数不能定义构造函数\r\n* 箭头函数显式定义需要变量关键字`var`、`let`、`const`，由于变量提升的特性，所以必须先定义声明再调用该函数\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**关于let**\r\n* `let`命令是ES6 新增的，用来声明变量。\r\n* `let`声明的变量只在局部作用域内有效，可用在`for`循环中\r\n* 不存在变量提升，必须先声明后使用，否则报错\r\n\r\n\r\n\r\n## promise的状态\r\n* promise状态是promise实例对象中的一个属性\r\n* 属性名为PromiseState\r\n* 该属性是一个内置属性，不能直接对其进行操作\r\n* 属性值有三种状态\r\n    * pending 未定义的初始状态\r\n    * resolved、fullfilled 成功的状态\r\n    * rejected 失败的状态\r\n* 属性的三种状态只有两种变化过程\r\n    * pending -> resolved\r\n    * pending -> rejected\r\n    * 不能由失败、成功变为未定义状态\r\n    * 不能由失败变成功，也不能由成功变失败\r\n* 属性的状态只能改变一次\r\n\r\n## promise的结果\r\n* promise结果是promise实例对象中的一个属性\r\n* 属性名为`PromiseResult`\r\n* 该属性是一个内置属性，不能直接对其进行操作\r\n* 只有函数`resolve(valure)`、`reject(reason)` 能对其值进行修改\r\n* 属性值有三种状态\r\n\r\n## 基本使用\r\n* `new Promise((resolve,reject)=>{})`构造函数的第一个形参是一个函数，该函数又接收了两个参数resolve和reject，这两个参数也是函数\r\n* `resolve()`调用完毕后会将promise对象状态设置为**成功**\r\n* `reject()`调用完毕后会将promise对象状态设置为**失败**\r\n* `promiseObj.then()`函数有两个形式参数，都是函数，\r\n    * 当promise对象状态为成功时执行第一个回调函数，为失败时执行第二个回调函数\r\n    * 第一个函数其形参value为resolve传递过来的参数\r\n    * 第二个函数其形参reason为reject传递过来的参数\r\n\r\n**新旧两种解决方案的对比**\r\n\r\n<div id=\"demo23r023jfr02\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btn = document.querySelector(\"#demo23r023jfr02>button\")\r\n    var p = document.querySelector(\"#demo23r023jfr02>p\")\r\n    btn.addEventListener(\"click\",function(){\r\n        setTimeout(function(){//模拟服务端延迟\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30)// r落在0~30区间的概率为30%if(accurate(30))\r\n                    p.innerHTML+=\"恭喜中奖\"\r\n                else\r\n                    p.innerHTML+=\"再接再厉\"\r\n        },1000)\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demo23r023jfr02\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btn = document.querySelector(\"#demo23r023jfr02>button\")\r\n    var p = document.querySelector(\"#demo23r023jfr02>p\")\r\n    btn.addEventListener(\"click\",function(){\r\n        setTimeout(function(){//模拟服务端延迟\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30)// r落在0~30区间的概率为30%if(accurate(30))\r\n                    p.innerHTML+=\"恭喜中奖\"\r\n                else\r\n                    p.innerHTML+=\"再接再厉\"\r\n        },1000)\r\n    })\r\n</script>\r\n```\r\n\r\n<div id=\"demo12312312qq\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btnn = document.querySelector(\"#demo12312312qq>button\");\r\n    var pp = document.querySelector(\"#demo12312312qq>p\");\r\n    btnn.addEventListener(\"click\",function(){\r\n        //Promise构造函数的第一个形参是一个函数，该函数又接收了两个参数resolve和reject，这两个参数也是函数\r\n        const promise = new Promise((resolve,reject)=>{\r\n            setTimeout(()=>{\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30){ // r落在0~30区间的概率为30%\r\n                    resolve(r) //调用完毕后会将promise对象状态设置为**成功**\r\n                }else{\r\n                    reject(r) //调用完毕后会将promise对象状态设置为**失败**\r\n                }\r\n            },1000);\r\n        })\r\n        //then函数有两个形式参数，都是函数，\r\n        //当promise对象状态为成功时执行第一个回调函数，为失败时执行第二个回调函数\r\n        //第一个函数其形参value为resolve传递过来的参数\r\n        //第二个函数其形参reason为reject传递过来的参数\r\n        promise.then((value)=>{\r\n            pp.innerHTML+=\"恭喜中奖\"+value\r\n        },(reason)=>{\r\n            pp.innerHTML+=\"再接再厉\"+reason\r\n        });\r\n    });\r\n</script>\r\n\r\n```html\r\n<div id=\"demo12312312qq\">\r\n    <button>点击抽奖</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    var btnn = document.querySelector(\"#demo12312312qq>button\");\r\n    var pp = document.querySelector(\"#demo12312312qq>p\");\r\n    btnn.addEventListener(\"click\",function(){\r\n        //Promise构造函数的第一个形参是一个函数，该函数又接收了两个参数resolve和reject，这两个参数也是函数\r\n        const promise = new Promise((resolve,reject)=>{\r\n            setTimeout(()=>{\r\n                var r = Math.round(Math.random()*100); //获取0-100随机数 \r\n                if(r<30){ // r落在0~30区间的概率为30%\r\n                    resolve(r) //调用完毕后会将promise对象状态设置为**成功**\r\n                }else{\r\n                    reject(r) //调用完毕后会将promise对象状态设置为**失败**\r\n                }\r\n            },1000);\r\n        })\r\n        //then函数有两个形式参数，都是函数，\r\n        //当promise对象状态为成功时执行第一个回调函数，为失败时执行第二个回调函数\r\n        //第一个函数其形参value为resolve传递过来的参数\r\n        //第二个函数其形参reason为reject传递过来的参数\r\n        promise.then((value)=>{\r\n            pp.innerHTML+=\"恭喜中奖\"+value\r\n        },(reason)=>{\r\n            pp.innerHTML+=\"再接再厉\"+reason\r\n        });\r\n    });\r\n</script>\r\n```\r\n\r\n## 用promise封装fs\r\n\r\n**promise封装前**\r\n```js\r\nconst fs = require(\"fs\");\r\nfs.readFile(\"./path/to/fileName\",(err,data)=>{\r\n    if(err) throw err;//异常处理\r\n    console.log(data.toString());//数据处理\r\n})\r\n```\r\n\r\n**promise封装后**\r\n```js\r\nconst fs = require(\"fs\");\r\n\r\nconst p = new Promise((resolve,reject)={\r\n    fs.readFile(\"./path/to/fileName\",(err,data)=>{\r\n        if(err)\r\n            reject(err);\r\n        else\r\n            resolve(data)\r\n    })\r\n})\r\n\r\n// 使用\r\np.then(value=>{// 形式参数只有一个，箭头函数的括号可省略\r\n    console.log(value.toString();//数据处理\r\n},reason=>{\r\n    throw reason;//异常处理\r\n})\r\n```\r\n\r\n**手动用promise将fs封装为一个函数**\r\n```js\r\n\r\nfunction myreadFile(path){\r\n    return new Promise((resolve,reject)={\r\n        require(\"fs\").readFile(path,(err,data)=>{\r\n            if(err)\r\n                reject(err);\r\n            else\r\n                resolve(data)\r\n        })\r\n    })\r\n}\r\n\r\n// 使用\r\nmyreadFile(\"./path/to/file\")\r\n.then(value=>{\r\n    console.log(value.toString());\r\n},reason=>{\r\n    console.log(reason);\r\n})\r\n```\r\n\r\n**通过util.promisify获取已经使用promise封装好的fs函数**\r\n```js\r\nconst util = require(\"util\")\r\nconst fs = require(\"fs\")\r\n\r\nfunction myreadFile = util.promisify(fs.readFile)\r\n\r\n// 使用\r\nmyreadFile(\"./path/to/file\")\r\n.then(value=>{\r\n    console.log(value.toString());\r\n},reason=>{\r\n    console.log(reason);\r\n})\r\n```\r\n\r\n\r\n## 用promise封装ajax\r\n\r\n**promise封装前**\r\n\r\n<div id=\"demofjwif02\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif02>button\").click(function(){\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\",\"https://api.apiopen.top/api/sentences\")\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function(){\r\n            if(xhr.readyState===4){\r\n                // 判断响应状态码\r\n                if(xhr.status>=200&&xhr.status<300){\r\n                    $(\"#demofjwif02>p\").text(xhr.response)\r\n                }else{\r\n                    $(\"#demofjwif02>p\").text(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n\r\n```js\r\n<div id=\"demofjwif02\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif02>button\").click(function(){\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\",\"https://api.apiopen.top/api/sentences\")\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function(){\r\n            if(xhr.readyState===4){\r\n                // 判断响应状态码\r\n                if(xhr.status>=200&&xhr.status<300){\r\n                    $(\"#demofjwif02>p\").text(xhr.response)\r\n                }else{\r\n                    $(\"#demofjwif02>p\").text(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n\r\n```\r\n\r\n**promise封装后**\r\n\r\n<div id=\"demofjwif021231\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif021231>button\").click(function(){\r\n        const promise = new Promise((resolve,reject)=>{\r\n            //创建对象\r\n            const xhr = new XMLHttpRequest();\r\n            // 初始化\r\n            xhr.open(\"GET\", \"https://api.apiopen.top/api/sentences\")\r\n            // 发送\r\n            xhr.send();\r\n            // 处理响应结果\r\n            xhr.onreadystatechange = function () {\r\n                if (xhr.readyState === 4) {\r\n                    // 判断响应状态码\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        resolve(xhr.response)\r\n                    } else {\r\n                        reject(xhr.status)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n        promise.then(response=>{\r\n            $(\"#demofjwif021231>p\").text(response)\r\n        },states=>{\r\n            $(\"#demofjwif021231>p\").text(states)\r\n        })\r\n    })\r\n</script>\r\n\r\n```js\r\n<div id=\"demofjwif021231\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwif021231>button\").click(function(){\r\n        const promise = new Promise((resolve,reject)=>{\r\n            //创建对象\r\n            const xhr = new XMLHttpRequest();\r\n            // 初始化\r\n            xhr.open(\"GET\", \"https://api.apiopen.top/api/sentences\")\r\n            // 发送\r\n            xhr.send();\r\n            // 处理响应结果\r\n            xhr.onreadystatechange = function () {\r\n                if (xhr.readyState === 4) {\r\n                    // 判断响应状态码\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        resolve(xhr.response)\r\n                    } else {\r\n                        reject(xhr.status)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n        promise.then(response=>{\r\n            $(\"#demofjwif021231>p\").text(response)\r\n        },states=>{\r\n            $(\"#demofjwif021231>p\").text(states)\r\n        })\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n**用promise将ajex封装为一个函数**\r\n\r\n```js\r\nfunction sendAjax(url){\r\n    return new Promise((resolve,reject)=>{\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\", url)\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function () {\r\n            if (xhr.readyState === 4) {\r\n                // 判断响应状态码\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(xhr.response)\r\n                } else {\r\n                    reject(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n// 使用\r\nsendAjax(\"https://api.apiopen.top/api/sentences\")\r\n.then(vaule=>{\r\n    console.log(vaule)\r\n},reason=>{\r\n    console.warm(reason)\r\n})\r\n```\r\n\r\n## APIs\r\n\r\n**`new Promise(executor);`构造函数**\r\n* 形参`executor`是一个函数， 称为**执行器**，写为`(resolve,reject)=>{}`\r\n* 执行器的形参resolve，是一个函数，写在执行器函数中，执行器执行成功时调用\r\n* 执行器的形参reject，是一个函数，写在执行器函数中，执行器执行失败时调用\r\n* 执行器中的语句是随构造函数同步执行的\r\n    ```js\r\n    // 1111 2222 顺序输出\r\n    let p = new Promise((rosolve,reject)=>{\r\n        console.log(\"1111\")\r\n    })\r\n    console.log(\"2222\")\r\n    ```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.prototype.then(onResolved,onRejected);`方法**\r\n* onResolved 成功的回调函数 写为`(value)=>{}`\r\n* onRejected 失败的回调函数 写为`(reason)=>{}`\r\n* 返回值是一个新的Promise对象\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.prototype.cache(onRejected);`方法**\r\n* onRejected 失败的回调函数 写为`(reason)=>{}`\r\n* 该函数内部由then()封装实现\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.resolve(value);`方法**\r\n* 该方法是Promise对象的内置方法，不是实例化后的对象的方法\r\n* 该方法用来快速获取一个Promise实例对象，并且给其封装一个值和状态\r\n* 该方法返回值是一个promise实例对象\r\n* 当value值是一个非promise类型的对象时，返回的结果为成功的promise对象\r\n* 当value值是一个promise类型的对象时，返回的promise对象的结果（result、成功与否）与传入的promise对象的结果一致\r\n```js\r\nvar p = Promise.resolve(123)\r\nconsole.log(p)//p是一个promise对象，其结果为成功，值为123\r\n\r\nvar k = Promise.resolve(new Promise((resolve,reject)=>{\r\n    resolve(\"成功AAA\")\r\n}))\r\n\r\nconsole.log(k) // k是一个promise对象，其结果为成功，值为“成功AAA”\r\n\r\nvar k = Promise.resolve(new Promise((resolve,reject)=>{\r\n    reject(\"失败BBB\")\r\n}))\r\n\r\nconsole.log(k) // k是一个promise对象，其结果为失败，值为“失败BBB”\r\n//且由于k是一个失败的Promise对象，也没有处理失败的回调，所以会报错\r\n//解决：\r\nk.cach(reason=>{//对失败进行处理\r\n    console.log(reason)\r\n})\r\n```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.reject(value);`方法**\r\n* 和resolve基本一致，\r\n* 但是该函数不论传入的promise对象的状态是成功还是失败，其返回的promise对象的状态是失败，值为传入的promise对象\r\n* 也就是说该函数永远返回一个失败的promise，其值为传入的value值，无论传入的是否为一个Promise对象\r\n\r\n```js\r\nvar j = new Promise((resolve,reject)=>{\r\n    resolve(\"成功AAA\")\r\n})\r\nvar k = Promise.resolve(j)\r\n\r\nconsole.log(k) // k是一个promise对象，其结果为失败，其值为j，也就是为传入的成功的promise对象\r\n```\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.all(promises);`方法**\r\n* 基本同上；\r\n* 用于返回一个Promise对象，状态由promises决定\r\n* promises是一个数组，包含多个promise对象，\r\n* 若promises中有一个promise对象为失败，则该函数返回的Promise对象的状态为失败，且该对象的结果为数组中的这个Promise对象本身\r\n* 仅当promises都为成功时，该函数返回的Promise对象的状态为成功，且该对象的结果是由数组中每个Promise对象的结果组成的数组\r\n\r\n```js\r\nvar p1 = new Promise((resolve,reject)=>{\r\n    resolve(\"成功结果1\")\r\n})\r\nvar p2 = Promise.resolve(\"成功结果2\")\r\nvar p3 = Promise.resolve(\"成功结果3\")\r\n\r\nvar pk = Promise.all([p1,p2,p3]);\r\nconsole.log(pk)\r\n```\r\n结果：  \r\n![](./images/promise学习笔记/2022-07-18-15-36-38.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve,reject)=>{\r\n    resolve(\"成功结果1\")\r\n})\r\nvar p2 = Promise.reject(\"失败结果2\")\r\nvar p3 = Promise.resolve(\"成功结果3\")\r\n\r\nvar pk = Promise.all([p1,p2,p3]);\r\nconsole.log(pk)\r\n```\r\n结果：  \r\n![](./images/promise学习笔记/2022-07-18-15-41-47.png)\r\n\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**`Promise.race(promises);`方法**\r\n* 返回的的是promises中第一个改变状态的promsie\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n        resolve(\"成功结果1\")\r\n    }, 1000);\r\n})\r\nvar p2 = Promise.resolve(\"成功结果2\")\r\nvar p3 = Promise.resolve(\"成功结果3\")\r\nvar pk = Promise.race([p1, p2, p3]);\r\nconsole.log(pk)\r\n```\r\n\r\n结果：  \r\n![](./images/promise学习笔记/2022-07-18-15-53-23.png)\r\n\r\n\r\n## 关键问题\r\n\r\n**修改对象的状态的三种方式**\r\n* 在执行器函数中执行`resolve()` pending -> fulfilled/resolved\r\n* 在执行器函数中执行`reject()` pending -> rejected\r\n* 在执行器函数中抛出错误`throw \"字符串或error实例对象\";` pending -> rejected\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"成功结果1\")\r\n    reject(\"失败结果1\")\r\n    throw \"失败结果2\";\r\n})\r\nconsole.log(p1)\r\n```\r\n![](./images/promise学习笔记/2022-07-18-20-44-07.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**指定的多个回调都会执行**\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果\")\r\n})\r\nconsole.log(p1)\r\np1.then(value => {\r\n    console.log(\"执行了成功回调函数1,result为：\" + value)\r\n})\r\np1.then(value => {\r\n    console.log(\"执行了成功回调函数2,result为：\" + value)\r\n})\r\n```\r\n![](./images/promise学习笔记/2022-07-18-20-51-29.png)\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**改变状态和指定回调的then()函数执行顺序的问题**\r\n* 当改变状态的语句在执行器中被**同步**执行时，执行顺序是 改变状态 -> 指定回调函数 -> 执行回调函数\r\n* 当改变状态的语句在执行器中被**异步**执行时，执行顺序是 指定回调函数 -> 改变状态 -> 执行回调函数\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    console.log(\"即将执行改变状态的函数resolve()\");\r\n    resolve(\"这是成功的结果\")\r\n    console.log(\"resolve() 执行完毕\");\r\n})\r\n\r\nconsole.log(\"即将执行指定回调函数的函数then()\");\r\np1.then(value => {\r\n    console.log(\"执行了成功的回调函数，结果为:\"+ value)\r\n})\r\nconsole.log(\"then() 执行完毕\");\r\n```\r\n![](./images/promise学习笔记/2022-07-18-21-31-42.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    console.log(\"即将执行执行器中的代码\");\r\n    setTimeout(() => {\r\n        console.log(\"即将执行改变状态的函数resolve()\");\r\n        resolve(\"这是成功的结果\")\r\n        console.log(\"resolve() 执行完毕\");\r\n    }, 1000);\r\n    console.log(\"执行器中的代码执行完毕\");\r\n})\r\nconsole.log(\"即将执行指定回调函数的函数then()\");\r\np1.then(value => {\r\n    console.log(\"执行了成功的回调函数，结果为:\"+ value)\r\n})\r\nconsole.log(\"then() 执行完毕\");\r\n```\r\n\r\n![](./images/promise学习笔记/2022-07-18-21-40-21.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**then()方法的返回值问题**\r\n* 若回调函数抛出了异常，则then的返回值是一个promise对象，状态为失败，result为抛出的异常\r\n* 若回调函数的返回值是非promise对象，则then的返回值是一个promise对象，状态为成功，result为该返回值\r\n* 若回调函数的返回值是promise对象，则then的返回值是一个promise对象，状态为失败，result为该对象的result值\r\n* 若回调函数没有返回值，则then的返回值是一个promise对象，状态为成功，result为undefined\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果\")\r\n})\r\nvar k = p1.then(value => {\r\n    throw \"抛出异常\"\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-21-31.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果\")\r\n})\r\nvar k = p1.then(value => {\r\n    return 521;\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-16-14.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果1\")\r\n})\r\nvar k = p1.then(value => {\r\n    return new Promise((resolve,reject)=>{\r\n        resolve(\"这是成功的结果2\")\r\n    })\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-23-01.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果1\")\r\n})\r\nvar k = p1.then(value => {\r\n    return new Promise((resolve,reject)=>{\r\n        resolve(\"这是失败的结果1\")\r\n    })\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-24-00.png)\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是成功的结果1\")\r\n})\r\nvar k = p1.then(value => {\r\n    console.log(\"执行了成功回调函数，且没有返回值\")\r\n})\r\nconsole.log(k);\r\n```\r\n![](./images/promise学习笔记/2022-07-18-22-37-37.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**promise串联多个任务**\r\n* 由于then()的返回值是一个promsie对象，所以可以通过then().then()的方式实现\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是Promise1的成功结果\")\r\n})\r\np1\r\n.then(value => {\r\n    console.log(\"这是Promise1的成功的回调函数 ，获取到的value是：\", value)\r\n    return new Promise((resolve, reject) => {\r\n        resolve(\"这是Promise2的成功结果\")\r\n    })\r\n}).then(value => {\r\n    console.log(\"这是Promise2的成功的回调函数 ，获取到的value是：\", value)\r\n    return new Promise((resolve, reject) => {\r\n        resolve(\"这是Promise3的成功结果\")\r\n    })\r\n}).then(value => {\r\n    console.log(\"这是Promise3的成功的回调函数 ，获取到的value是：\", value)\r\n}).then(value => {\r\n    console.log(\"这是Promise4的成功的回调函数 ，获取到的value是：\", value)\r\n})\r\n```\r\n![](./images/promise学习笔记/2022-07-18-23-16-20.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**异常穿透现象(或者说功能)**\r\n* 可以把异常处理的回调函数写在最后，能够对串联的所有回调函数中的异常进行处理\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    resolve(\"这是Promise1的成功结果\")\r\n})\r\np1\r\n    .then(value => {\r\n        console.log(\"这是Promise1的成功的回调函数 ，获取到的value是：\", value)\r\n        return new Promise((resolve, reject) => {\r\n            resolve(\"这是Promise2的成功结果\")\r\n        })\r\n    }).then(value => {\r\n        console.log(\"这是Promise2的成功的回调函数 ，获取到的value是：\", value)\r\n        return new Promise((resolve, reject) => {\r\n            // resolve(\"这是Promise3的成功结果\")\r\n            reject(\"这是Promise3的失败结果\")\r\n        })\r\n    }).then(value => {\r\n        console.log(\"这是Promise3的成功的回调函数 ，获取到的value是：\", value)\r\n    }).then(value => {\r\n        console.log(\"这是Promise4的成功的回调函数 ，获取到的value是：\", value)\r\n    }).catch(reason => {\r\n        console.warn(\"这是串联的所有回调函数的异常处理回调函数，获取到的reason为\", reason)\r\n    })\r\n```\r\n\r\n![](./images/promise学习笔记/2022-07-18-23-34-16.png)\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**中断Promise的链式调用**\r\n* 有且只有一种方式，那就是在回调函数中返回一个pending状态的promise实例对象\r\n* 因为then(()=>{})函数中的回调函数无论返回什么都会被封装成一个promise函数，用来交给下一个then来进行处理，若返回的是pending状态的promise对象，那么后续then中的回调函数就不会被触发\r\n\r\n```js\r\nvar p1 = new Promise((resolve, reject) => {\r\n    console.log(\"1111111111111111111\")\r\n    resolve(\"这是Promise1的成功结果\")\r\n})\r\np1\r\n    .then(value => {\r\n        console.log(\"222222222222222222\")\r\n        return new Promise((resolve, reject) => {\r\n            resolve(\"这是Promise2的成功结果\")\r\n        })\r\n    }).then(value => {\r\n        console.log(\"333333333333333333,中断链式调用，返回了一个pending状态的promise\")\r\n        return new Promise((resolve, reject) => {})\r\n    }).then(value => {\r\n        console.log(\"4444444444444444444444\")\r\n    }).then(value => {\r\n        console.log(\"55555555555555555555555\")\r\n    }).catch(reason => {\r\n        console.warn(\"err\")\r\n    })\r\n```\r\n![](./images/promise学习笔记/2022-07-19-00-03-08.png)\r\n\r\n\r\n\r\n\r\n## 手写实现promsie全部功能\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## async 与 await\r\n**async关键字**\r\n* 经async关键字修饰后的函数的返回值是一个promsie对象\r\n* 该promise对象的状态和结果由该函数的return值决定\r\n    * 若该函数抛出错误已,则该函数返回一个状态为失败的promsie，且其结果为抛出的错误值\r\n    * 若该函数return一个非promise对象,则该函数返回一个状态为成功的promsie，且其结果为return的值\r\n    * 若该函数return一个promise对象\r\n        * 若该对象状态为成功 则返回的promise状态也为成功，且结果为返回的promsie对象的结果\r\n        * 若该对象状态为失败 则返回的promise状态也为失败，且结果为返回的promsie对象的结果\r\n        * 若该对象状态为pending 则返回的promise状态也为pending，且结果为undefined\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**await关键字**\r\n* `await`必须写在经`async`修饰后的函数中，但`async`修饰的函数中可以没有await\r\n* 如果`await`获得的`promsie`**失败**，则**抛出异常**，需`try{}cach{}`捕获\r\n* 如果`await`获得的`promise`**成功**，则返回该**promise成功的结果值**result\r\n* 如果`await`获得的是**非promsie对象**，则返回的就是**该非promise对象**\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n**async与await结合的执行顺序问题**\r\n```js\r\nasync function main() {\r\n    var promiseA = new Promise((resolve, reject) => {\r\n        console.log(\"执行器执行\");\r\n        setTimeout(() => {\r\n            console.log(\"执行器中的异步函数执行\");\r\n            resolve(123)\r\n        }, 1000);\r\n    })\r\n    try {\r\n        console.log(\"promiseA状态：\");\r\n        console.log(promiseA);\r\n        console.log(\"await promiseA\");\r\n        var result = await promiseA;\r\n        console.log(\"获取到promiseA的result:\");\r\n        console.log(result);\r\n        console.log(\"执行return\");\r\n        return result;\r\n    } catch (e) {\r\n        return e;\r\n    }\r\n}\r\nconsole.log(\"调用async修饰的函数\");\r\nlet result = main()\r\nconsole.log(\"调用async修饰的函数结束\");\r\nconsole.log(\"async修饰的函数结果为\");\r\nconsole.log(result);\r\n```\r\n![](./images/promise学习笔记/2022-07-19-10-37-38.png)\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n**async于await结合案例之文件操作**\r\n\r\n\r\n回调函数方式文件操作，合并三个文件\r\n```js\r\nconst fs = require(\"fs\")\r\nfs.readFile(\"./path/to/file1\",(err,data1)=>{\r\n    if(err) throw err;\r\n    fs.readFile(\"./path/to/file2\",(err,data2)=>{\r\n        if(err) throw err;\r\n        fs.readFile(\"./path/to/file3\",(err,data3)=>{\r\n            if(err) throw err;\r\n            console.log(data1+data2+data3)\r\n        })\r\n    })\r\n})\r\n\r\n```\r\n\r\nasync于await结合方式合并三个文件\r\n\r\n```js\r\nconst fs = require(\"fs\")\r\nconst util = require(\"util\")\r\nconst myReadFile = util.promisify(fs.readFile);\r\n\r\n(async function{\r\n    try{\r\n      let data1 = await myReadFile(\"./path/to/file1\")\r\n      let data2 = await myReadFile(\"./path/to/file2\")\r\n      let data3 = await myReadFile(\"./path/to/file3\")\r\n      console.log(data1+data2+data3)\r\n    }cache(e){\r\n        console.log(\"文件打开失败\")\r\n    }\r\n})();\r\n\r\n```\r\n\r\n------------------------------------------------------------------------------------------------------------\r\n\r\n**async与await结合案例之发送AJAX**\r\n\r\n\r\n\r\n需要用到之前写的用Promise封装好的sendAjax函数\r\n```js\r\nfunction sendAjax(url){\r\n    return new Promise((resolve,reject)=>{\r\n        //创建对象\r\n        const xhr = new XMLHttpRequest();\r\n        // 初始化\r\n        xhr.open(\"GET\", url)\r\n        // 发送\r\n        xhr.send();\r\n        // 处理响应结果\r\n        xhr.onreadystatechange = function () {\r\n            if (xhr.readyState === 4) {\r\n                // 判断响应状态码\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(xhr.response)\r\n                } else {\r\n                    reject(xhr.status)\r\n                }\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n// 使用\r\nsendAjax(\"https://api.apiopen.top/api/sentences\")\r\n.then(vaule=>{\r\n    console.log(vaule)\r\n},reason=>{\r\n    console.warm(reason)\r\n})\r\n```\r\n\r\n有了这个封装好的函数，再结合async与await，就可以实现下列操作\r\n\r\n\r\n\r\n<script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"\r\n    integrity=\"sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=\" crossorigin=\"anonymous\"></script>\r\n<div id=\"demofjwi123131f334\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwi123131f334>button\").click(async function () {\r\n        var result = await sendAjax(\"https://api.apiopen.top/api/sentences\")\r\n        $(\"#demofjwi123131f334>p\").text(result)\r\n    })\r\n    function sendAjax(url) {\r\n        return new Promise((resolve, reject) => {\r\n            //创建对象\r\n            const xhr = new XMLHttpRequest();\r\n            // 初始化\r\n            xhr.open(\"GET\", url)\r\n            // 发送\r\n            xhr.send();\r\n            // 处理响应结果\r\n            xhr.onreadystatechange = function () {\r\n                if (xhr.readyState === 4) {\r\n                    // 判断响应状态码\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        resolve(xhr.response)\r\n                    } else {\r\n                        reject(xhr.status)\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n</script>\r\n\r\n```js\r\n<div id=\"demofjwi123131f334\">\r\n    <button>获取</button>\r\n    <p></p>\r\n</div>\r\n<script>\r\n    $(\"#demofjwi123131f334>button\").click(async function () {  //async修饰\r\n        var result = await sendAjax(\"https://api.apiopen.top/api/sentences\") //await等待\r\n        $(\"#demofjwi123131f334>p\").text(result)\r\n    })\r\n</script>\r\n```"},{"shortInfo":{"title":"SQL学习笔记","date":"2022-08-30T19:29:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["SQL"],"hideAtIndex":true,"categories":"笔记","id":42,"countWords":2247,"readSeconds":224.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# SQL学习笔记\r\n\r\n## 目录\r\n- [SQL学习笔记](#sql学习笔记)\r\n  - [目录](#目录)\r\n  - [概念](#概念)\r\n  - [数据类型和字段特殊标识](#数据类型和字段特殊标识)\r\n  - [SQL语法](#sql语法)\r\n    - [注释](#注释)\r\n    - [数据库相关](#数据库相关)\r\n    - [表相关](#表相关)\r\n    - [SELECT 查询](#select-查询)\r\n    - [INSERT 插入](#insert-插入)\r\n    - [UPDATE 更新](#update-更新)\r\n    - [DELETE 删除](#delete-删除)\r\n    - [WHERE 子句](#where-子句)\r\n    - [WHERE 子句 的 AND 和 OR](#where-子句-的-and-和-or)\r\n    - [ORDER BY 子句 排序](#order-by-子句-排序)\r\n    - [ORDER BY 子句 `多重排序`](#order-by-子句-多重排序)\r\n    - [COUNT(*)函数](#count函数)\r\n    - [AS 为列设置列名](#as-为列设置列名)\r\n  - [2022_09_22课堂笔记](#2022_09_22课堂笔记)\r\n    - [基本概念](#基本概念)\r\n    - [数据模型](#数据模型)\r\n  - [2022_10_10课堂笔记](#2022_10_10课堂笔记)\r\n    - [SQL](#sql)\r\n    - [定义模式](#定义模式)\r\n    - [创建表](#创建表)\r\n    - [插入数据](#插入数据)\r\n    - [修改表](#修改表)\r\n  - [数据查询](#数据查询)\r\n    - [where子句 between关键字](#where子句-between关键字)\r\n    - [where子句 in关键字](#where子句-in关键字)\r\n    - [where子句 字符串匹配](#where子句-字符串匹配)\r\n    - [where子句 `is null` 空值查询](#where子句-is-null-空值查询)\r\n    - [order by 子句](#order-by-子句)\r\n\r\n## 概念\r\n\r\n**常见数据库**\r\n* `MySQL` 使用最广泛最流行的数据库,开源,分为社区版(免费)和企业版\r\n  * `MySQL WorkBench`为其配套的连接和管理数据库的图像化界面\r\n* `Oracle` 收费\r\n* `SQL Server` 收费(由微软开发)\r\n* `MongoDB` 分为社区版(免费)和企业版\r\n\r\n**区分**\r\n* 关系型数据库,SQL数据库\r\n  * MySQL\r\n  * Oracle\r\n  * SQL Server\r\n* 非关系型数据库,NoSQL数据库\r\n  * MongoDB\r\n\r\n\r\n**关系型数据库组织结构的组成**\r\n* 数据库database : 一般每个项目都有一个单独的数据库\r\n* 数据表table : 不同的数据存入不同的表 如:student表 class表 \r\n* 数据行row : 表中一行就是一条具体的数据\r\n* 字段field : 决定能够存储数据的类型,数据的名称,如id name age\r\n\r\n\r\n## 数据类型和字段特殊标识\r\n\r\n\r\n**数据类型**\r\n* INT 整数\r\n* varchar(len) 长度不超过len的字符串\r\n* TinyInt(1) 布尔值\r\n\r\n**字段特殊标识**\r\n* PK(Primary Key) 主键\r\n* NN(Not NULL) 不允许为空\r\n* UQ(Unique) 唯一\r\n* B(Binary)\r\n* UN(Unsigned) 无符号\r\n* ZF(Zero Fill)\r\n* G(Generated)\r\n* AI(Auto Increment) 值自动增长\r\n* default 默认值\r\n\r\n\r\n![图 4](./images/SQL学习笔记/9f237b06e403823a93e74262adfefaaa789ffffef977a68ea559930c26eaeea7.png) \r\n\r\n\r\n**创建表**\r\n```sql\r\nCREATE TABLE `my_db_01`.`users` (\r\n  `id` INT NOT NULL AUTO_INCREMENT COMMENT '主键',\r\n  `username` VARCHAR(45) NOT NULL COMMENT '用户登陆名',\r\n  `password` VARCHAR(45) NOT NULL COMMENT '用户登陆密码',\r\n  `status` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '0 用户状态正常\\n1 用户被禁用',\r\n  PRIMARY KEY (`id`),\r\n  UNIQUE INDEX `id_UNIQUE` (`id` ASC) VISIBLE,\r\n  UNIQUE INDEX `username_UNIQUE` (`username` ASC) VISIBLE);\r\n\r\n```\r\n\r\n**插入数据**\r\n```sql\r\nINSERT INTO `my_db_01`.`users` (`username`, `password`) VALUES ('DingYigui', '123');\r\n```\r\n\r\n\r\n\r\n## SQL语法\r\n### 注释\r\n```sql\r\n-- 这是注释\r\n```\r\n\r\n### 数据库相关\r\n```sql\r\n-- 查看所有的数据\r\nSHOW DATABASES; \r\n\r\n-- 创建数据库\r\nCREATE DATABASE db_01;\r\n\r\n-- 删除数据库\r\nDROP DATABASE db_01;\r\n\r\n-- 使用数据库\r\nUSE db_01;\r\n\r\n```\r\n\r\n\r\n### 表相关\r\n```sql\r\n\r\n-- 查看当前数据库中所有的表\r\nSHOW TABLES;\r\n\r\n-- 创建表\r\nCREATE TABLE 表名称\r\n(\r\n列名称1     数据类型    约束规则,\r\n列名称2     数据类型    约束规则,\r\n列名称3     数据类型    约束规则,\r\n)\r\n--- 创建user表\r\nCREATE TABLE users(\r\n  id INT auto_increment PRIMARY KEY,\r\n  name VARCHAR(255) NOT NULL,\r\n  age INT ,\r\n  gender VARCHAR(4),\r\n  content VARCHAR(255)\r\n);\r\n\r\n-- 删除表\r\nDROP TABLE users;\r\n```\r\n\r\n### SELECT 查询\r\n```sql\r\n-- SELECT语法格式\r\nSELECT 列名 FROM 表名 ;\r\n\r\n-- 选中该表的所有列\r\nSELECT * FROM 表名 ;\r\n\r\n-- 模糊查询 %表示通配 _ 表示单字符\r\nSELECT * from user where name LIKE '丁%'\r\n\r\n-- in语句\r\nSELECT * from user where name in ('DYG', 'dyg')\r\n\r\n-- limit分页\r\nSELECT * from user ORDER BY id desc limit 3\r\nSELECT * from user ORDER BY id desc limit 3,3\r\n\r\n\r\n-- 选中表中的username,password\r\nSELECT username,password FROM users ;\r\n```\r\n\r\n### INSERT 插入\r\n```sql\r\n--- \r\n-- INSERT语法格式\r\nINSERT INTO 表名 (列名1,列名2,...) VALUES (列值1,列值2,...) ;\r\nINSERT INTO 表名 SET 列名1 = 列值1 ,列名2 = 列值2 ,列名3 = 列值3 ;\r\nINSERT INTO 表名 VALUES (列值1, 列值2, 列值3, 列值4, 列值5) --若省略列名则列值位置需一一对应\r\n\r\n-- 插入一条数据\r\nINSERT INTO users (username,password) VALUES (\"DYG\",\"321\") ;\r\n```\r\n\r\n### UPDATE 更新\r\n```sql\r\n--- UPDATE语法格式\r\nUPDATE 表名 SET 列名1 = 新的列值1  WHERE 列名 = 列值 ;\r\nUPDATE 表名 SET 列名1 = 新的列值1 , 列名2 = 新的列值2  WHERE 列名 = 列值 ;\r\n\r\n--- 将id为2的用户密码修改为222\r\nUPDATE users SET password = 222 WHERE id = 2 ;\r\nUPDATE users SET username = \"admin\" , password = \"admin\" WHERE id = 1 ;\r\n\r\n--- 注意: 不加 WHERE 会修改所有用户的密码 \r\n```\r\n\r\n### DELETE 删除\r\n```sql\r\n---DELETE 语法\r\nDELETE FROM 表名 --删除所有用户数据\r\nDELETE FROM 表名 WHERE 列名 = 列值 ; --删除指定数据\r\n\r\n--- 删除id为3的用户\r\nDELETE FROM users WHERE id = 3 ;\r\n\r\n--- 注意: 不加 WHERE 会删除所有用户 \r\n```\r\n\r\n### WHERE 子句\r\n`WHERE` 子句用于**限定选择的标准**  \r\n\r\n`WHERE` 子句在 `SELECT` `UPDATE` `DELETE` 中皆可使用\r\n```sql\r\n--- 查询语句中的WHERE\r\nSELECT 列名 FROM 表名\r\n    WHERE 列名 = 列值 ;\r\n\r\n--- 更新语句中的WHERE\r\nUPDATE 表名 SET 列名 = 新的列值\r\n    WHERE 列名 = 列值 ;\r\n\r\n--- 删除语句中的WHERE\r\nDELETE FROM 表名\r\n    WHERE 列名 = 列值 ;\r\n```\r\n\r\n**WHERE子句的运算符**  \r\n|  操作符  |     描述     |\r\n| :------: | :----------: |\r\n|    =     |     等于     |\r\n| <> 或 != |    不等于    |\r\n|    >     |     大于     |\r\n|    <     |     小于     |\r\n|    >=    |   大于等于   |\r\n|    <=    |   小于等于   |\r\n| BETWEEN  | 在某个范围内 |\r\n|   LIKE   | 搜索某种模式 |\r\n\r\n```sql\r\n--- 删除除admin以外的所有用户\r\nDELETE FROM 表名\r\n    WHERE username != \"admin\" ;\r\n```\r\n\r\n### WHERE 子句 的 AND 和 OR\r\n```sql\r\n--- AND 和 OR 的语法格式\r\nSELECT 列名 FROM 表名\r\n    WHERE 条件1 AND 条件2;\r\n\r\nSELECT 列名 FROM 表名\r\n    WHERE 条件1 OR 条件2;\r\n```\r\n\r\n### ORDER BY 子句 排序\r\n```sql\r\n--- ORDER BY语法格式;默认升序排序\r\nSELECT 列名 FROM 表名\r\n    ORDER BY 列名;\r\n\r\n--- ORDER BY语法格式;ASC为升序排序\r\nSELECT 列名 FROM 表名\r\n    ORDER BY 列名 ASC;\r\n\r\n--- ORDER BY语法格式;DESC为降序排序\r\nSELECT 列名 FROM 表名\r\n    ORDER BY 列名 DESC;\r\n```\r\n\r\n### ORDER BY 子句 `多重排序`\r\n```sql\r\n--- ORDER BY多重排序 语法格式:\r\nSELECT 列名 FROM 表名\r\n    ORDER BY 列名1 ASC,列名2 DESC; ---先按列名1升序排序 再按列名2降序排序\r\n```\r\n\r\n### COUNT(*)函数\r\n返回`SELECT`查询结果的总条数\r\n```sql\r\n--- COUNT(*)语法\r\nSELECT COUNT(*) FROM 表名;\r\n```\r\n**示例**\r\n```sql\r\n--- 示例: 统计users表中status为1的用户数\r\nSELECT COUNT(*) FROM users\r\n    WHERE status=1;\r\n```\r\n![图 6](./images/SQL学习笔记/6f6bc3d73694312746a9cd28e1c1e094104f34e5fdb7cdf19f64a7ce7486009f.png)  \r\n\r\n\r\n### AS 为列设置列名\r\n```sql\r\n--- AS语法\r\nSELECT 旧列名1 AS 新列名1 , 旧列名2 AS 新列名2 FROM 表名;\r\nSELECT COUNT(*) AS total FROM 表名;\r\n```\r\n\r\n**示例1**\r\n```sql\r\n-- 查询user表的id和username字段,并为user字段起别名uname,为id字段起别名uid\r\nSELECT id AS uid , username AS uname FROM users;\r\n```\r\n![图 8](./images/SQL学习笔记/a0abf515a12f083d098b4a8603999dbd34cb0817f6f48701e8316fed84b13337.png)  \r\n\r\n**示例2**\r\n```sql\r\n-- 统计表中所有数据,并为字段取名为total\r\nSELECT COUNT(*) as total FROM users;\r\n```\r\n![图 7](./images/SQL学习笔记/c6b0ce51605b0c75a54c2dcb85b67257027a67f4ce44a0f8a0249d14773e11e0.png)  \r\n\r\n\r\n\r\n\r\n\r\n\r\n## 2022_09_22课堂笔记\r\n\r\n### 基本概念\r\n* **四个概念**: DATA数据 DB数据库 DBS数据库系统 DBMS数据库管理系统 \r\n* **三个阶段**: 人工管理阶段 文件系统阶段 数据库系统届阶段\r\n* **两个独立性**: 物理独立性 逻辑独立性\r\n* **无法解决的问题**: 无法做到零冗余\r\n\r\n### 数据模型\r\n* **两类数据模型**: 概念模型 逻辑物理模型\r\n* **常用概念模型**: 实体-联系模型(E-R模型)\r\n  * E-R模型三要素: 实体(集) 属性 联系:[一对一(1:1) 一对多(1:n) 多对多(m:n)]\r\n* **主要逻辑模型**\r\n  * 层次模型\r\n  * 网状模型\r\n  * **关系模型**\r\n* 面向对象模型\r\n\r\n## 2022_10_10课堂笔记\r\n\r\n### SQL\r\n\r\n* 数据查询 SELECT\r\n* 数据定义 CREATE DROP ALER\r\n* 数据操作 INSERT UPDATE DELEE\r\n* 数据控制 GRANT REVOKE\r\n\r\n### 定义模式\r\n```sql\r\ncreate schema '模式名' authorization 用户名\r\n```\r\n\r\n### 创建表\r\n```sql\r\ncreate table 表名 (\r\n  列名 数据类型 约束条件,\r\n  列名 INT primary key,\r\n  列名 CHAR(20) unique,\r\n  列名 NUMERIC(10,3),\r\n  列名 DECIMAL(5,2)\r\n);\r\n```\r\n\r\n### 插入数据\r\n```sql\r\ninsert into 表名(Sno,Sname,Ssex,Sdep,Sage) \r\n      values('20121521','张三'，'男'，'cs','20');\r\n```\r\n\r\n\r\n### 修改表\r\n**删除列**\r\n```sql\r\nalter table 表名\r\n    drop column 列名\r\n```\r\n\r\n**增加列**\r\n```sql\r\nalter table 表名\r\n    add 列名 类型 数据约束\r\n```\r\n\r\n**修改列的数据类型**\r\n```sql\r\nalter table 表名\r\n    alter 列名 类型 数据约束\r\n```\r\n\r\n**删除表**\r\n```sql\r\ndrop table 表名 restrict;--有限制的删除表\r\ndrop table 表名 cascade;--无限制的删除表\r\n```\r\n\r\n\r\n## 数据查询\r\n```sql\r\nselect [all|distinct] 目标列表达式 -- distinct用于去重\r\nfrom 表名或视图名 \r\nas 别名\r\nwhere 条件表达式_\r\ngroup by 列名_sex having 表达式\r\norder by 列名_age asc｜desc ---desc降序\r\n\r\n```\r\n\r\n### where子句 between关键字\r\n```sql\r\nselect * from student where Sage between 18 and 20; ---相当于 sage >= 18 && sage <= 20\r\n```\r\n\r\n### where子句 in关键字\r\n```sql\r\nselect * from student where Sdep in(\"CS\",\"MA\",\"IS\"); --- 相当于 sdep == CS ｜｜ sdep == MA ｜｜ sdep == IS\r\n```\r\n\r\n### where子句 字符串匹配\r\n```sql\r\nselect * from student where Sname like \"李_浩\"; -- 匹配单个字符\r\nselect * from student where Sname like \"李__\"; --匹配两个单个单字符\r\nselect * from student where Sname like \"李%\"; --匹配0个或多个字符\r\n```\r\n\r\n### where子句 `is null` 空值查询\r\n```sql\r\n;\r\n```\r\n\r\n### order by 子句\r\n* `asc`升序【默认】\r\n* `desc`降序\r\n* 对于空值，排序顺序由系统决定\r\n\r\n```sql\r\nselect * from student order by Sage desc;\r\n```\r\n\r\n  "},{"shortInfo":{"title":"ubuntu22.04配置过程命令记录","date":"2022-08-12T03:54:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["ubuntu22"],"hideAtIndex":true,"categories":"笔记","id":44,"countWords":3539,"readSeconds":353.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# ubuntu22.04配置过程命令记录\r\nwin10关了开机自启的应用 什么程序都没运行 内存竟然吃了近5G CPU吹出来的风热的要死 卸了一堆应用关了一堆系统服务和应用服务内存仍然要吃2.4G 反观最新版的ubuntu22.04 启动至图形界面 只吃了1.5g内存 决定安装使用 在此记录下配置过程 以备不时之需\r\n\r\n\r\n## 目录\r\n- [ubuntu22.04配置过程命令记录](#ubuntu2204配置过程命令记录)\r\n  - [目录](#目录)\r\n  - [安装系统](#安装系统)\r\n    - [空间分配](#空间分配)\r\n  - [换源](#换源)\r\n  - [安装软件](#安装软件)\r\n    - [apt-get常用命令](#apt-get常用命令)\r\n    - [dpkg常用命令](#dpkg常用命令)\r\n  - [配置服务](#配置服务)\r\n  - [防火墙](#防火墙)\r\n  - [权限管理](#权限管理)\r\n    - [sudo命令提示用户不在sudoers中的问题的解决](#sudo命令提示用户不在sudoers中的问题的解决)\r\n  - [挂载NTFS分区](#挂载ntfs分区)\r\n    - [解决不能写入文件系统的问题](#解决不能写入文件系统的问题)\r\n  - [配置sshd](#配置sshd)\r\n  - [配置合上笔记本后不休眠](#配置合上笔记本后不休眠)\r\n  - [使用`./configure`编译文件时依赖报错问题的解决方法](#使用configure编译文件时依赖报错问题的解决方法)\r\n  - [ubuntu安装xfce4并配置xrdp过程记录](#ubuntu安装xfce4并配置xrdp过程记录)\r\n    - [安装及配置](#安装及配置)\r\n    - [在xfce中不能打开终端的解决](#在xfce中不能打开终端的解决)\r\n  - [ubuntu安装gnome并配置xrdp过程记录](#ubuntu安装gnome并配置xrdp过程记录)\r\n    - [安装及配置](#安装及配置-1)\r\n    - [解决“色彩管理设备” 弹窗](#解决色彩管理设备-弹窗)\r\n    - [解决“刷新系统软件源需要认证” / “refresh the system repositories” 弹窗](#解决刷新系统软件源需要认证--refresh-the-system-repositories-弹窗)\r\n    - [XRDP远程桌面连接Ubuntu后没有 Dock、桌面图标 背后的程序们](#xrdp远程桌面连接ubuntu后没有-dock桌面图标-背后的程序们)\r\n    - [使用默认桌面配置](#使用默认桌面配置)\r\n\r\n## 安装系统\r\n### 空间分配\r\n* `/` **根目录** 10-15-20g 足以 此处分配剩余的所有空间\r\n  * `/home` **家目录** 应当分配剩余的所有空间 此处未单独分配\r\n  * `/var` **存放数据库或程序输出日志的目录** 应当视情况而定 此处未单独分配\r\n  * `/boot` **引导分区** 512MB 可有可无 但最好单独分区 否则系统无法引导就只能重装系统了\r\n* `swap` **交换分区** 一倍内存大小足矣\r\n* `efi` **efi系统分区** 512MB\r\n\r\n## 换源\r\n\r\n**备份**\r\n```bash\r\nsudo cp /etc/apt/sources.list /etc/apt/sources.list.bak\r\n```\r\n\r\n**编辑创建新文件**\r\n```bash\r\nsudo gedit /etc/apt/sources.list\r\n```\r\n\r\n**写入文件**\r\n```bash\r\n# 清华源\r\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释\r\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse\r\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse\r\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse\r\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse\r\n# 预发布软件源，不建议启用\r\n# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse\r\n# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse\r\n```\r\n\r\n**更新软件包列表（Source）**\r\n```bash\r\napt-get update\r\n    # 其他操作：\r\n    # 更新已安装的软件包 (谨慎使用，会导致linux内核升级到最新版本)\r\n    # apt-get upgrade\r\n    # 更新已安装的软件包（识别并处理依赖关系的改变）\r\n    # apt-get dist-upgrade\r\n```\r\n\r\n## 安装软件\r\n**常用软件包名称**\r\n* python3.10 \r\n* python3-pip\r\n\r\n### apt-get常用命令\r\n```bash\r\n# 普通安装\r\napt-get install PackageName\r\n# 安装指定包的指定版本\r\napt-get install PackageName=VersionName\r\n# 重新安装\r\napt-get --reinstall install PackageName\r\n```\r\n\r\n```bash\r\n# 修复依赖关系\r\napt-get -f install\r\n```\r\n\r\n```bash\r\n# 下载软件包的源码\r\napt-get source PackageName\r\n# 安装源码包所需要的编译环境\r\napt-get build-dep PackageName\r\n```\r\n\r\n\r\n```bash\r\n# 删除软件包, 保留配置文件\r\napt-get remove PackageName\r\n# 删除软件包, 同时删除配置文件\r\napt-get --purge remove PackageName\r\n```\r\n\r\n```bash\r\n# 清除 已下载的软件包 和 旧软件包\r\napt-get clean && apt-get autoclean\r\n```\r\n\r\n```bash\r\n# 搜索软件包\r\napt-cache search PackageName\r\n```\r\n\r\n```bash\r\n# 获取软件包的相关信息, 如说明、大小、版本等\r\napt-cache show PackageName\r\n```\r\n\r\n```bash\r\n# 查看该软件包需要哪些依赖包\r\napt-cache depends PackageName\r\n# 查看该软件包被哪些包依赖\r\napt-cache rdepends PackageName\r\n```\r\n\r\n```bash\r\n# 检查是否有损坏的依赖\r\napt-get check PackageName\r\n```\r\n\r\n### dpkg常用命令\r\n* dpkg 是Debian Package的简写，是为Debian 专门开发的套件管理系统，方便软件的安装、更新及移除。\r\n* 所有源自Debian的Linux发行版都使用dpkg，如Ubuntu\r\n\r\n```bash\r\n# 安装本地Debian软件包\r\ndpkg -i <package.deb>\r\n# 列出包内容\r\ndpkg -c <package.deb>\r\n# 提取包裹信息(可以查看包的正式名称，用于卸载)\r\ndpkg -I <package.deb>\r\n```\r\n\r\n```bash\r\n# 列出已安装的所有软件包\r\ndpkg -l\r\n# 列出安装的所有文件清单\r\ndpkg -L <package>\r\n```\r\n\r\n```bash\r\n# 移除一个已安装的包裹 并删掉数据和可执行文件\r\ndpkg -r <package>\r\n# 完全清除一个已安装的包裹 并删掉数据和可执行文件 并删除所有的配置文件\r\ndpkg -P <package>\r\n```\r\n\r\n```bash\r\n# 显示已安装包裹的信息\r\ndpkg -s <package>\r\n# 重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹安装提供了一个统一的配制界面)\r\ndpkg-reconfigure <package>\r\n```\r\n\r\n\r\n## 配置服务\r\n```bash\r\n# 编辑配置为系统服务\r\nvim /usr/lib/systemd/system/XXXX.service\r\n#########################################\r\n[Unit]\r\nDescription=XXXX\r\nAfter=network.target\r\n[Service]\r\nTimeoutStartSec=1\r\nExecStart=/usr/local/bin/XXXX -c /etc/frp/XXXX.ini\r\nExecStop=/bin/kill $MAINPID\r\n[Install]\r\nWantedBy=multi-user.target\r\n###########################################\r\n\r\n# 启动 frp 并设置开机启动\r\nsystemctl enable XXXX\r\nsystemctl start XXXX\r\nsystemctl status XXXX\r\n \r\n# 部分服务器上,可以需要加 .service 后缀来操作,即:\r\nsystemctl enable XXXX.service\r\nsystemctl start XXXX.service\r\nsystemctl status XXXX.service\r\n```\r\n\r\n## 防火墙\r\n```bash\r\n# 查看防火墙状态\r\nsudo ufw status\r\n# 开启防火墙\r\nsudo ufw enable\r\n# 关闭防火墙\r\nsudo ufw disable\r\n```\r\n\r\n## 权限管理 \r\n### sudo命令提示用户不在sudoers中的问题的解决\r\n根据文件`/etc/sudoers`内容可知,只需要将指定用户添加到sudo组,指定的用户就能得到执行sudo命令的权限\r\n```txt\r\n# root 用户拥有所有权限 可在此添加一行给某个用户root权限\r\nroot    ALL=(ALL:ALL) ALL\r\n\r\n# admin 组的成员拥有root权限\r\n%admin ALL=(ALL) ALL\r\n\r\n# sudo 组的成员拥有执行任何命令的权限\r\n%sudo   ALL=(ALL:ALL) ALL\r\n```\r\n\r\n只需要将用户添加到sudo组(添加为附加组)\r\n```bash\r\nusermod 你的用户名 -G sudo\r\n# 修改用户组后可能需重启生效\r\n```\r\n\r\n\r\n## 挂载NTFS分区\r\n**查看所有磁盘分区情况**\r\n```bash\r\nfdisk -l\r\n```\r\n\r\n**查看磁盘分区挂载情况**\r\n```bash\r\ndf -h\r\n```\r\n**查看目标分区的UUID**\r\n```bash\r\nsudo blkid |grep sdb2\r\n```\r\n\r\n**查看ubuntu是否安装了ntfs-3g软件包**\r\n```bash\r\ndpkg -l | grep ntfs\r\n# 没有则安装\r\napt-get install ntfs-3g\r\n```\r\n\r\n**临时挂载磁盘**\r\n```bash\r\nmount -t ntfs-3g -o umask=022 /dev/sdc5 /mnt/E/\r\n```\r\n**卸载挂载的磁盘**\r\n```bash\r\numount /mnt/E/\r\n```\r\n\r\n**配置开机自动挂载磁盘**\r\n```bash\r\nsudo vim /etc/fstab\r\n```\r\n\r\n**配置方法1：**\r\n```bash\r\n# 挂载的分区使用默认的权限，也就是属于用户root 属于root组\r\nUUID=EA06BA3106B9FF1F /mnt/E/ ntfs-3g defaults 0 2\r\n```\r\n\r\n**配置方法2：**\r\n* 使用`UUID`的好处是可以保证在重新分区后仍然能够唯一定位一个分区 若使用`/dev/sdb3`的方式则会在分区数量改变后发生错误\r\n* `rw`表示读写 `dmask` 是目录权限掩码 `fmask` 是文件权限掩码 `uid` 和 `gid` 可分别通过 `id -u` `id -g`获取\r\n* `<dump>` 为0时 `dump` 工具不会对其备份,为 1 时则会\r\n* `<pass>` 为0时 `fsck` 工具不会对其检查,为 1 2 时则会,根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为 2\r\n```bash\r\n# <file system> <mount point>   <type>  <options>       <dump>  <pass>\r\nUUID=EA06BA3106B9FF1F /mnt/E/ ntfs-3g rw,uid=1000,gid=1000,dmask=022,fmask=111 0 2\r\n```\r\n\r\n**挂载测试：检查fstab有无错误**\r\n```bash\r\nmount -a\r\n```\r\n\r\n**创建软连接到桌面**\r\n```bash\r\nln -s /mnt/D ~/Desktop/D\r\nln -s /mnt/E ~/Desktop/E\r\n```\r\n\r\n\r\n### 解决不能写入文件系统的问题\r\n**问题:** 无法写入文件系统,且umount后,重新执行`mount -a`时,报错 `Could not mount read-write, trying read-only`\r\n\r\n**解决:** 该报错可能是由于文件系统错误导致的,须用ntfsfix命令修复之(ntfsfix包含在ntfs-3g中)\r\n```\r\nsudo ntfsfix /dev/sda4\r\nsudo umount /mnt/D/\r\nsudo umount /mnt/E/\r\n```\r\n\r\n## 配置sshd\r\n**安装**\r\n```\r\napt install openssh-server\r\n```\r\n**配置启动服务**\r\n```\r\n# 一条命令启动ssh和sshd\r\nsystemctl enable ssh\r\n```\r\n\r\n\r\n## 配置合上笔记本后不休眠\r\n**编辑文件/etc/systemd/logind.conf**\r\n```\r\nHandlePowerKey: 按下电源键后的行为，默认poweroff\r\nHandleSleepKey: 按下挂起键后的行为，默认suspend\r\nHandleHibernateKey: 按下休眠键后的行为，默认hibernate\r\nHandleLidSwitch: 合上笔记本盖后的行为，默认suspend（改为ignore即可）\r\n```\r\n**配置完毕后需重启服务**\r\n```\r\n# 如果执行下列代码后黑屏则需重启电脑\r\nsudo service systemd-logind restart\r\n```\r\n\r\n\r\n## 使用`./configure`编译文件时依赖报错问题的解决方法\r\n**故障重现**\r\n```bash\r\n./configure\r\n# 报错信息\r\n# checking for Qt5Svg >= 5.15.2... no\r\n# configure: error: Package requirements (Qt5Svg >= 5.15.2) were not met:\r\n# you may set the environment variables Qt5Svg_CFLAGS\r\n# and Qt5Svg_LIBS to avoid the need to call pkg-config.\r\n```\r\n```\r\n大概意思就是:提示缺少依赖Qt5Svg,并提示应当指定环境变量 Qt5Svg_CFLAGS Qt5Svg_LIBS\r\n```\r\n\r\n**查找相关库所在的包的包名**\r\n```bash\r\nsudo apt-cache search Qt5Svg\r\n# 输出: \r\n# libqt5svg5 - Qt 5 SVG module\r\n# libqt5svg5-dev - Qt 5 SVG module development files\r\n```\r\n**安装包名**\r\n```bash\r\nsudo apt-get install libqt5svg5-dev\r\n```\r\n\r\n**查找包的安装路径**\r\n```bash\r\ndpkg -L libqt5svg5-dev\r\n# 输出信息\r\n# /.\r\n# /usr\r\n# /usr/include\r\n# /usr/include/x86_64-linux-gnu\r\n# /usr/include/x86_64-linux-gnu/qt5\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QGraphicsSvgItem\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QSvgGenerator\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QSvgRenderer\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QSvgWidget\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QtSvg\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QtSvgDepends\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/QtSvgVersion\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qgraphicssvgitem.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qsvggenerator.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qsvgrenderer.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qsvgwidget.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qtsvgglobal.h\r\n# /usr/include/x86_64-linux-gnu/qt5/QtSvg/qtsvgversion.h\r\n# /usr/lib\r\n# /usr/lib/x86_64-linux-gnu\r\n# /usr/lib/x86_64-linux-gnu/cmake\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Gui\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Gui/Qt5Gui_QSvgIconPlugin.cmake\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Gui/Qt5Gui_QSvgPlugin.cmake\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Svg\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Svg/Qt5SvgConfig.cmake\r\n# /usr/lib/x86_64-linux-gnu/cmake/Qt5Svg/Qt5SvgConfigVersion.cmake\r\n# /usr/lib/x86_64-linux-gnu/libQt5Svg.prl\r\n# /usr/lib/x86_64-linux-gnu/pkgconfig\r\n# /usr/lib/x86_64-linux-gnu/pkgconfig/Qt5Svg.pc\r\n# /usr/lib/x86_64-linux-gnu/qt5\r\n# /usr/lib/x86_64-linux-gnu/qt5/mkspecs\r\n# /usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules\r\n# /usr/lib/x86_64-linux-gnu/qt5/mkspecs/modules/qt_lib_svg.pri\r\n# /usr/share\r\n# /usr/share/doc\r\n# /usr/share/doc/libqt5svg5-dev\r\n# /usr/share/doc/libqt5svg5-dev/copyright\r\n# /usr/lib/x86_64-linux-gnu/libQt5Svg.so \r\n# /usr/share/doc/libqt5svg5-dev/changelog.Debian.gz\r\n```\r\n\r\n\r\n**设定环境变量**\r\n根据上一步的输出可以推测出\r\n  * **头文件所在目录(XXX.h所在目录)** 和\r\n  * **库文件所在目录(XXX.so所在目录)**\r\n```bash\r\nexport Qt5Svg_CFLAGS=/usr/include/x86_64-linux-gnu/qt5/QtSvg\r\nexport Qt5Svg_LIBS=/usr/lib/x86_64-linux-gnu\r\n```\r\n\r\n**重新执行**\r\n```bash\r\n./configure\r\n```\r\n\r\n\r\n\r\n## ubuntu安装xfce4并配置xrdp过程记录\r\n当前ubuntu22.04的图像界面是gnome 而xrdp对gnome支持并不好 所以安装xfce4的图像界面\r\n\r\n### 安装及配置\r\n\r\n**安装xrdp**\r\n```\r\nsudo apt-get install xrdp\r\n```\r\n**安装xfce4**\r\n```\r\nsudo apt-get install xfce4\r\n```\r\n\r\n**配置xrdp开机自启动**\r\n```\r\n# xrdp xrdp的守护进程\r\nsudo service xrdp restart\r\nsudo systemctl enable xrdp\r\n# xrdp-sesman 会话管理的守护进程\r\nsudo service xrdp-sesman restart\r\nsudo systemctl enable xrdp-sesman\r\n```\r\n\r\n**配置 `xrdp` 的 `/etc/xrdp/startwm.sh`**\r\n```\r\n# 注释掉原先配置\r\n# test -x /etc/X11/Xsession && exec /etc/X11/Xsession\r\n# exec /bin/sh /etc/X11/Xsession\r\n\r\n# 添加新配置用于启动xfce4\r\nstartxfce4\r\n```\r\n**由于xrdp远程连接创建后，对登录使用的账户不知道该启动哪个桌面Session会话导致闪退,需手动创建**\r\n```\r\n# vi ~/.xsession\r\n# xfce4桌面\r\necho xfce4-session > ~/.xsession\r\n```\r\n\r\n\r\n### 在xfce中不能打开终端的解决\r\n\r\n**安装xfce4-terminal**\r\n```\r\nsudo apt install xfce4-terminal\r\n```\r\n**修改默认xfce4的默认terminal**  \r\n鼠标右键->`applications`->运行程序->输入：`xfce4-settings-manager`-> 找到:`默认应用程序` -> 工具 -> 修改默认terminal为**xfce终端**\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## ubuntu安装gnome并配置xrdp过程记录\r\n\r\n### 安装及配置\r\n\r\n\r\n**重新安装gnome使其自动解决依赖问题自动安装未安装的工具插件**\r\n```\r\nsudo apt-get install gnome\r\n```\r\n\r\n**安装xrdp**\r\n```\r\nsudo apt-get install xrdp\r\n```\r\n\r\n\r\n**配置xrdp开机自启动**\r\n```\r\n# xrdp xrdp的守护进程\r\nsudo service xrdp restart\r\nsudo systemctl enable xrdp\r\n# xrdp-sesman 会话管理的守护进程\r\nsudo service xrdp-sesman restart\r\nsudo systemctl enable xrdp-sesman\r\n```\r\n\r\n**配置 `xrdp` 的 `/etc/xrdp/startwm.sh`**\r\n```\r\n# 维持原先配置\r\ntest -x /etc/X11/Xsession && exec /etc/X11/Xsession\r\nexec /bin/sh /etc/X11/Xsession\r\n\r\n```\r\n\r\n**由于xrdp远程连接创建后，对登录使用的账户不知道该启动哪个桌面Session会话导致闪退,需手动创建**\r\n```\r\n# vi ~/.xsession\r\n# Unity 桌面(老版本)\r\necho unity> ~/.xsession\r\n \r\n# ubuntu-desktop 原始桌面\r\necho gnome-session > ~/.xsession\r\n```\r\n\r\n\r\n### 解决“色彩管理设备” 弹窗\r\n\r\n**创建文件 `/etc/polkit-1/localauthority/50-local.d/45-allow-colord.pkla`**\r\n\r\n**并写入内容：**\r\n```\r\n[Allow Colord all Users]\r\nIdentity=unix-user:*\r\nAction=org.freedesktop.color-manager.create-device;org.freedesktop.color-manager.create-profile;org.freedesktop.color-manager.delete-device;org.freedesktop.color-manager.delete-profile;org.freedesktop.color-manager.modify-device;org.freedesktop.color-manager.modify-profile\r\nResultAny=no\r\nResultInactive=no\r\nResultActive=yes\r\n```\r\n\r\n\r\n### 解决“刷新系统软件源需要认证” / “refresh the system repositories” 弹窗\r\n\r\n**创建文件 `/etc/polkit-1/localauthority/50-local.d/46-allow-packagekit.pkla`**\r\n\r\n**并写入内容：**\r\n```\r\n[Allow Refresh Repository all Users]\r\nIdentity=unix-user:*\r\nAction=org.freedesktop.packagekit.system-sources-refresh\r\nResultAny=no\r\nResultInactive=no\r\nResultActive=yes\r\n```\r\n\r\n\r\n### XRDP远程桌面连接Ubuntu后没有 Dock、桌面图标 背后的程序们\r\n\r\n各个扩展程序可在如下目录中看到\r\ncd /usr/share/gnome-shell/extensions/\r\n\r\n**安装并执行**\r\n```\r\nsudo apt-get install gnome-extensions-app \r\ngnome-extensions-app \r\n# 然后弹出的窗口中开启dock\r\n```\r\n\r\n\r\n### 使用默认桌面配置\r\n**添加配置文件`~/.xsessionrc`**\r\n```bash\r\nexport GNOME_SHELL_SESSION_MODE=ubuntu\r\nexport XDG_CURRENT_DESKTOP=ubuntu:GNOME\r\nexport XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg\r\n```"},{"shortInfo":{"title":"ubuntu下配置xRDP过程记录","date":"2022-08-11T22:55:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["ubuntu","xRDP"],"hideAtIndex":true,"categories":"笔记","id":45,"countWords":951,"readSeconds":95.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# ubuntu下配置xRDP过程记录\r\n\r\n## xRDP\r\n* RDP是windows系统下默认的远程桌面协议 默认端口3389\r\n* VNC是linux系统下默认的远程桌面协议 默认端口5900\r\n* **xRDP**是RDP的开源版本 \r\n  * 安装xRDP的linux可以通过windows原生的远程桌面连接程序MSTSC建立远程连接，\r\n  * 于是市面上一系列用于远程登录windows的手机端app和PC端应用程序也可用于登陆linux\r\n\r\n\r\n## 通过命令安装\r\n```shell\r\nsudo apt install  xrdp\r\n```\r\n\r\n## 添加用户到组\r\n```shell\r\n默认情况下，Xrdp 使用 /etc/ssl/private/ssl-cert-snakeoil.key 仅“ssl-cert” 用户组可读\r\nsudo adduser 用户名 ssl-cert\r\n或\r\nsudo usermod 用户名 -G ssl-cert\r\n```\r\n\r\n## 配置服务\r\n**配置文档/etc/xrdp/xrdp.ini**\r\nxrdp.ini 关键部分在globals\r\n```conf\r\n[globals]\r\nbitmap_cache=yes       #位图缓存\r\nbitmap_compression=yes #位图压缩\r\nport=3389              #监听端口\r\ncrypt_level=low        #加密程度（none为不加密 low为40位，默认为high 128位，medium为双40位）\r\nchannel_code=1         #????\r\n```\r\n**配置文档/etc/xrdp/sesman.ini**\r\n```conf\r\n[Globals]\r\nListenAddress=127.0.0.1      #监听ip地址(默认即可)\r\nListenPort=3350              #监听端口(默认即可)\r\nEnableUserWindowManager=1    #1为开启,可让用户自定义自己的启动脚本\r\nUserWindowManager=startwm.sh\r\nDefaultWindowManager=startwm.sh\r\n \r\n[Security]\r\nAllowRootLogin=1              #允许root登陆\r\nMaxLoginRetry=4               #最大重试次数\r\nTerminalServerUsers=tSUSErs   #允许连接的用户组(如果不存在则默认全部用户允许连接)\r\nTerminalServerAdmins=tsadmins #允许连接的超级用户(如果不存在则默认全部用户允许连接)\r\n \r\n[Sessions]\r\nMaxSessions=10           #最大会话数\r\nKillDisconnected=0       #是否立即关闭断开的连接(如果为1,则断开连接后会自动注销)\r\nIdleTimeLimit=0          #空闲会话时间限制(0为没有限制)\r\nDisconnectedTimeLimit=0  #断开连接的存活时间(0为没有限制)\r\n \r\n[Logging]\r\nLogFile=./sesman.log     #登陆日志文件\r\nLogLevel=DEBUG           #登陆日志记录等级(级别分别为,core,error,warn,info,debug)\r\nEnableSyslog=0           #是否开启日志\r\nSyslogLevel=DEBUG        #系统日志记录等级\r\n```\r\n\r\n## 启动服务\r\n```shell\r\nsudo systemctl enable xrdp\r\nsudo service xrdp start\r\n```\r\n\r\n<!-- \r\n\r\n\r\n## 通过源码编译安装安装\r\n```shell\r\n# 在github上下载\r\nwget https://github.com/neutrinolabs/xrdp/releases/download/v0.9.19/xrdp-0.9.19.tar.gz\r\n# 解压\r\ntar -xvf xrdp-0.9.19.tar.gz\r\n# \r\ncd ./xrdp-0.9.19\r\n\r\n\r\n# 略： 刚发现详细安装过程github的wiki上都有\r\n``` \r\n\r\n-->\r\n\r\n\r\n\r\n\r\n## 构建、编译、安装 pulseaudio 模块 实现音频重定向\r\ndata：2022-08-15\r\n**获得的构建文件**\r\n根据官方wiki文章[《Build-on-Debian-or-Ubuntu（在 Debian 或 Ubuntu 上构建）》](https://github.com/neutrinolabs/pulseaudio-module-xrdp/wiki/Build-on-Debian-or-Ubuntu)可知，**获得的文件构建**有**两种方式**，\r\n* 一种是从 pulseaudio 服务器构建中提取内部开发文件，或执行脚本 『暂不使用这种方式』\r\n* 另一方种方式是直接下载已经构建好的文件[pulseaudio-headers-xrdb](https://github.com/lnee94/pulseaudio-headers-xrdb/releases/tag/v1.0)并通过命令安装`pkg -i pulseaudio-headers-xrdb.deb`,将会解压到目录`/opt/pulseaudio-headers-xrdb/`\r\n\r\n```bash\r\ncd ~\r\nwget https://github.com/lnee94/pulseaudio-headers-xrdb/releases/download/v1.0/pulseaudio-headers-xrdb.deb\r\npkg -i pulseaudio-headers-xrdb.deb\r\n```\r\n\r\n**编译 xrdp pulseaudio 模块**\r\n```bash\r\n# 编译构建 pulseaudio 模块本身需要一些构建工具和包开发工具\r\nsudo apt install build-essential dpkg-dev libpulse-dev git autoconf libtool\r\n\r\ncd ~\r\ngit clone https://github.com/neutrinolabs/pulseaudio-module-xrdp.git\r\ncd pulseaudio-module-xrdp\r\n\r\n./bootstrap && ./configure PULSE_DIR=/opt/pulseaudio-headers-xrdb/\r\nmake\r\n```\r\n\r\n**安装 xrdp pulseaudio 模块**\r\n```bash\r\ncd pulseaudio-module-xrdp\r\nsudo make install\r\n\r\n# 该命令执行后，\r\n# 构建的模块将被安装在正确的目录\r\n# 同时：a script load_pa_modules.sh to load the modules when a session is started. On many systems this script is installed by default in /usr/libexec/pulseaudio-module-xrdp/\r\n# 同时：Install a desktop file pulseaudio-xrdp.desktop which will call the load_pa_modules.sh script when a desktop is loaded. On many systems this script is installed by default in /etc/xdg/autostart\r\n```\r\n\r\n\r\n**确认是否安装成功**\r\n```\r\nls $(pkg-config --variable=modlibexecdir libpulse) | grep xrdp\r\n# 输出结果中应当包含\r\n# module-xrdp-sink.so\r\n# module-xrdp-source.so\r\n```\r\n"},{"shortInfo":{"title":"ubuntu配置code-server过程记录","date":"2022-08-09T08:17:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["code-server","ubuntu"],"hideAtIndex":true,"categories":"笔记","id":46,"countWords":265,"readSeconds":26.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# ubuntu配置code-server过程记录\r\n**完整过程**\r\n```bash\r\n# 下载\r\nwget https://github.com/coder/code-server/releases/download/v4.5.1/code-server-4.5.1-linux-amd64.tar.gz\r\n## 或者在pc端下载好了之后通过sftp传输\r\n# 解压\r\ntar -xvf ./code-server-4.5.1-linux-amd64.tar.gz\r\n# 递归创建文件夹\r\nmkdir -p ~/.local/lib ~/.local/bin\r\n# 移动并改名\r\nmv ./code-server-4.5.1-linux-amd64 ~/.local/lib/code-server-4.5.1/\r\n# 建立软连接\r\nln -s ~/.local/lib/code-server-4.5.1/bin/code-server ~/.local/bin/code-server\r\n# 添加到环境变量\r\nPATH=\"~/.local/bin:$PATH\"\r\n# 运行\r\ncode-server \r\n```\r\n\r\n**编辑配置文件修改密码**\r\n```bash\r\ncat > ~/.config/code-server/config.yaml <<EOF\r\nbind-addr: 0.0.0.0:8080\r\nauth: password\r\npassword: *****数字加英文*****\r\ncert: false\r\nEOF\r\n```\r\n\r\n**配置自动添加环境变量**\r\n```bash\r\nvim  .profile\r\nPATH=\"~/.local/bin:$PATH\"\r\n```\r\n\r\n\r\n**配置服务**\r\n**若是通过`dpkg -i code-server-4.5.1-linux-amd64.deb` 这种安装方式安装的,服务配置文件`code-server.service`会被自动配置好,只需要执行:**\r\n```bash\r\n# 启动服务\r\nsystemctl start code-server@用户名.service\r\n# 添加到开机自启动\r\nsystemctl enable code-server@用户名.service\r\n```"},{"shortInfo":{"layout":"post","title":"vscode操作备忘笔记","date":"2022-01-09T12:28:00.000Z","cover":"\\self_server\\assets\\images\\vscode.webp","tags":["笔记","vscode"],"hideAtIndex":true,"categories":"笔记","id":47,"countWords":2261,"readSeconds":226.1,"assetsbaseUrl":"/self_server/assets/"},"content":"## vscode操作备忘笔记\r\n### 面板\r\n1. 命令面板是vscode快捷键的主要交互界面，可以使用f1或者Cmd+Shift+P(win Ctrl+Shift+P)打开。\r\n>在命令面板中你可以输入命令进行搜索(中英文都可以)，然后执行。\r\n命名面板中可以执行各种命令，包括编辑器自带的功能和插件提供的功能。\r\n所以一定要记住它的快捷键Cmd+Shift+P\r\n2. 搜索面板CTRL+E、R、P 打开文件或切换工作目录\r\n\r\n### 注释\r\n* 注释选中行 ctrl+/\r\n* 注释选中代码块 alt + shift + a\r\n\r\n### 代码格式化\r\n* 对选中代码格式化 ？？？？？？？\r\n* 对整个文件格式化 ctrl + shift + f 苹果：Option+Shift+F\r\n\r\n### 代码缩进\r\n* 对个文档进行缩进调节，使用Cmd+Shift+P打开命令面板，输入缩进,然后选择相应的命令\r\n* 对选中代码缩进调节：ctrl+] ctrl+[ 苹果：Cmd+] Cmd+[ \r\n\r\n### 一些小技巧\r\n* 调整选中代码的大小写 选中后在命令面板输入转化为大写或者转化为小写的中文或英文\r\n* 合并代码行，多行代码合并为一行，Cmd+J(win下未绑定\r\n* 对选中的代码行排序 调出命令面板，输入按升序排序或者按降序排序\r\n\r\n### 光标操作\r\n* 基础\r\n    1. 以单词为单位移动光标：windows中：CTRL+左右方向键\r\n    1. 鼠标滚轮效果：windows中：CTRL+上下方向键\r\n    1. 移动到行首 windows中：Home键 苹果中：Cmd+左方向键\r\n    1. 移动到行尾 windows中：end键 苹果中：Cmd+右方向键\r\n    1. 移动到文档的开头和末尾 windows中： Ctrl+Home/End 苹果中：Cmd+上下方向键\r\n* 进阶\r\n    1. 回到上一个光标的位置，win Ctrl+U(mac：Cmd+U) \r\n    1. 在不同的文件之间回到上一个光标的位置 win Ctrl+shift+U\r\n* 文本选择\r\n    1. 在光标移动的时候多按一个shift键就可以选中文本\r\n    1. 选中单词 Cmd+D\r\n* 删除\r\n    1. 选中代码之后再按删除\r\n    1. 删除当前行Ctrl+Shift+K Cmd+Shift+K\r\n* 代码移动 \r\n    1. 剪切移动Alt+上下 苹果：Option+上下方向键\r\n    2. 复制移动Alt+shift+上下 苹果：Option+Shift+上下\r\n\r\n### 多光标特性\r\n使用鼠标：按住Option(win Alt),然后用鼠标点，鼠标点在哪里哪里就会出现一个光标\r\n注意：有的mac电脑上是按住Cmd，然后用鼠标点才可以\r\n\r\n### 选中单词\r\nCmd+D (win Ctrl+D) 第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它。(注：cmd-k cmd-d 跳过当前的选择)\r\n\r\n### 在每行末尾添加光标\r\n首先你要选中多行代码，然后按Alt+Shift+i(苹果：Option+Shift+i),这样做的结果是：每一行后面都会多出来一个光标 Option+Shift+i\r\n\r\n### 撤销多光标\r\n使用Esc 或鼠标点击一下\r\n\r\n### 快速打开文件\r\nCmd+P （win Ctrl+P）输入你要打开的文件名,回车打开\r\n\r\n这里有个小技巧，选中你要打开的文件后，按Cmd+Enter,就会在一个新的编辑器窗口打开\r\n\r\n### 在tab不同的文件间切换，\r\nWindows：？？？ 苹果：cmd+shift+[] \r\n\r\n### 行跳转\r\n假如浏览器报了个错，错误在53行，如何快速跳转到53行\r\nCtrl+g 输入行号\r\n\r\n### 文件行跳转\r\n如果你想跳转到某个文件的某一行，你只需要先按下 “Cmd + P”，输入文件名，然后在这之后加上 “:”和指定行号即可。\r\n\r\n### 符号跳转\r\n符号可以是文件名、函数名，可以是css的类名\r\nCmd+Shift+O(win Ctrl+Shift+o) 输入你要跳转的符号，回车进行跳转\r\n\r\nwin下输入Ctrl+T，可以在不同文件的符号间进行搜索跳转\r\n\r\n\r\n\r\n### 定义(definition)和实现(implementation)处\r\nf12跳到函数的定义处\r\nCmd+f12(win Ctrl+f12)跳转到函数的实现处\r\n\r\n### 引用跳转\r\n很多时候，除了要知道一个函数或者类的定义和实现以外，你可能还希望知道它们被谁引用了，以及在哪里被引用了。这时你只需要将光标移动到函数或者类上面，然后按下 Shift + F12，VS Code 就会打开一个引用列表和一个内嵌的编辑器。在这个引用列表里，你选中某个引用，VS Code 就会把这个引用附近的代码展示在这个内嵌的编辑器里。\r\n\r\n### 代码重构\r\n当我们想修改一个函数或者变量的名字时候，我们只需把光标放到函数或者变量名上，然后按下 F2，这样这个函数或者变量出现的地方就都会被修改。\r\n\r\n### 一些插件\r\n1. 万能语言运行环境 （Code Runner）：\r\n > 如果你需要学习或者接触各种各样的开发语言，那么 Code Runner 插件可以让你不用搭建各种语言的开发环境，直接通过此插件就可以直接运行对应语言的代码，非常适合学习或测试各种开发语言。\r\n支持的语言有：C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script, C# (.NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, 以及一些自定义的命令。\r\n\r\n2. 快速注释（ Document This）：优秀的代码除了优秀的性能、规范的格式，注释也是不可或缺的，而且注释也应该有一套标准的注释方法，特别对于 JavaScript 这种语言。Document This 可以快速地帮你生成注释，如一些函数的注释还能帮你抽取出参数的定义等，是你编写规范代码必备的工具。Document This目前仅支持JavaScript和TypeScript。\r\n\r\n3. CSS 类名智能提示（HTML CSS Support）：它会提示一些类名供你选择。\r\n\r\n4. 代码拼写检查（Code Spell Checker）：此插件安装后就不用管就好了，在你代码中有单词拼写错误时，你就会发现它的好处，因为我们写代码毕竟都是大量的英文单词变量定义，插件还可以给出错误拼写单词的建议。如果单词有错下面就会出现波浪线。\r\n\r\n5. 备忘插件（TODO Highlight）：在很多的其他代码编辑器中都有 TODO 标注功能的，如你写到某一部分的代码时，其中部分的功能需要稍后再来实现，这是就可以在对应的代码处添加一个 TODO 类型的注释，那么后期就可以快速地跳转到这部分继续写，而且当项目很大的时候，TODO 就变得更加有用，因为有时候 TODO 可能有几十个，帮助你标注那些功能需要继续实现或优化。\r\n\r\n6. 自动重命名标签（Auto Rename Tag）：这个插件对你的标签修改起来一个很大的作用，当你修改起始标签的时候，结束标签也会随着起始标签的修改而修改\r\n\r\n7. html模板（HTML Boilerplate）：就是一个很标准html5的模板插件，兼容新老版浏览器。\r\n\r\n8. 代码格式化（Prettier - Code formatter）\r\n\r\n9. 颜色提示（Color Info）\r\n\r\n10. 自动闭合标签（Auto Close Tag）：安装了这个插件后，如果你的起始标签不小心删除的结束标签，只要打 </ 就会自动补全，根据就近原则，一次只能补全一个标签。\r\n\r\n\r\n## 预定义变量列表\r\n- `${workspaceFolder}` -在 VS Code 中打开的文件夹的路径\r\n- `${workspaceFolderBasename}` -在 VS Code 中打开的文件夹名称，不带任何斜杠（/）\r\n- `${file}` -当前打开的文件\r\n- `${relativeFile}` -当前相对于打开的文件 workspaceFolder\r\n- `${relativeFileDirname}` -当前打开文件的目录名，相对于 workspaceFolder\r\n- `${fileBasename}` -当前打开的文件的基本名称\r\n- `${fileBasenameNoExtension}` -当前打开的文件的基本名称，没有文件扩展名\r\n- `${fileDirname}` -当前打开的文件的目录名\r\n- `${fileExtname}` -当前打开的文件的扩展名\r\n- `${cwd}` -启动时任务运行器的当前工作目录\r\n- `${lineNumber}` -活动文件中当前选择的行号\r\n- `${selectedText}` -活动文件中的当前选定文本\r\n- `${execPath}` -正在运行的 VS Code 可执行文件的路径\r\n- `${defaultBuildTask}` -默认构建任务的名称\r\n\r\n## 预定义变量的例子\r\n### vscode 的当前状态\r\n|            描述            |                       路径                       |\r\n| :------------------------: | :----------------------------------------------: |\r\n|   当前打开工作区的路径。   |         /home/your-username/your-project         |\r\n| 当前编辑器打开的文件路径。 | /home/your-username/your-project/folder/file.ext |\r\n\r\n### 预定义变量值列表\r\n| 变量                         | 值                                               |\r\n| :--------------------------- | :----------------------------------------------- |\r\n| `${workspaceFolder}`         | /home/your-username/your-project                 |\r\n| `${workspaceFolderBasename}` | your-project                                     |\r\n| `${file}`                    | /home/your-username/your-project/folder/file.ext |\r\n| `${relativeFile}`            | folder/file.ext                                  |\r\n| `${relativeFileDirname}`     | folder                                           |\r\n| `${fileBasename}`            | file.ext                                         |\r\n| `${fileBasenameNoExtension}` | file                                             |\r\n| `${fileDirname}`             | /home/your-username/your-project/folder          |\r\n| `${fileExtname}`             | .ext                                             |\r\n| `${lineNumber}`              | 光标的行号                                       |\r\n| `${selectedText}`            | 在代码编辑器中选择的文本                         |\r\n| `${execPath}`                | Code.exe 的位置                                  |"},{"shortInfo":{"title":"vue3_blog项目笔记","date":"2022-10-19T11:23:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["vue3","blog"],"categories":"笔记","id":1876821530,"countWords":3972,"readSeconds":397.2,"assetsbaseUrl":"/self_server/assets/"},"content":"## 目录\r\n- [目录](#目录)\r\n- [导航条毛玻璃效果实现](#导航条毛玻璃效果实现)\r\n- [图片背景实现](#图片背景实现)\r\n- [封面文字动态输入效果实现](#封面文字动态输入效果实现)\r\n- [为数字添加单位函数实现](#为数字添加单位函数实现)\r\n- [分页器实现](#分页器实现)\r\n- [滚动事件切换类名animate改变封面高度](#滚动事件切换类名animate改变封面高度)\r\n- [文章页Markdown内容的渲染](#文章页markdown内容的渲染)\r\n- [filter实现文章页封面效果](#filter实现文章页封面效果)\r\n- [vue中hash路由与markdown中锚点链接冲突的解决及链接跳转的实现](#vue中hash路由与markdown中锚点链接冲突的解决及链接跳转的实现)\r\n- [markdown中script标签内代码不执行问题的解决](#markdown中script标签内代码不执行问题的解决)\r\n- [使markdown中script标签支持jQuery(`$`)语法](#使markdown中script标签支持jquery语法)\r\n- [使markdown支持渲染KaTex语法数学公式及复制KaTex源代码](#使markdown支持渲染katex语法数学公式及复制katex源代码)\r\n- [归档页github风格代码贡献统计效果的组件实现](#归档页github风格代码贡献统计效果的组件实现)\r\n- [将文章标题字符串计算HASH作为ID](#将文章标题字符串计算hash作为id)\r\n- [通过front-matter将markdown文章首部的yml格式信息获取](#通过front-matter将markdown文章首部的yml格式信息获取)\r\n\r\n\r\n## 导航条毛玻璃效果实现\r\n\r\n![](./images/2022-10-19-06-24-02.png)\r\n\r\n```less\r\n//contrast对比度\r\n//saturate饱和度\r\n//blur() 模糊(像素)\r\n@backdrop_Filter:saturate(200%) contrast(80%) blur(20px);\r\n.cssName{\r\n    backdrop-filter: @backdrop_Filter;\r\n    -webkit-backdrop-filter: @backdrop_Filter;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n## 图片背景实现\r\n\r\n![](./images/2022-10-19-06-25-09.png)\r\n\r\n```html\r\n<template>\r\n  <img class=\"bg_img\" src=\"./images/1.jpg\" alt=\"\">\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: 'BackGround'\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.bg_img {\r\n  z-index: -999;//放到最底层\r\n  position: fixed;//相对浏览器窗口定位\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;//宽为视口宽度的100%\r\n  height: 100vh; //高度为100%视口宽度\r\n  object-fit: cover;//内容以封面方式适应盒子宽高\r\n  object-position: center top;//内容对齐方式，水平方向居中，垂直方向顶部对齐\r\n}\r\n</style>\r\n```\r\n\r\n\r\n## 封面文字动态输入效果实现\r\n\r\n![](./images/2022-10-19-06-25-50.png)\r\n\r\n<span id=\"span\" data-value=\"在绝望中坚持真理,在荒诞中奋起抵抗.\" ></span><span class=\"_\">_</span>\r\n<br>\r\n<button id=\"btn\">点击此处触发效果</button>\r\n<style>\r\n._{\r\n    display: inline-block;\r\n    margin-left: 5px;\r\n    animation: dash_flash 0.7s ease infinite;\r\n}\r\n@keyframes dash_flash {\r\n    /* 定义动画 */\r\n    from{opacity: 0;}\r\n    to{opacity: 1;}\r\n}\r\n#btn{\r\n    padding:5px;\r\n    background-color:white;\r\n    color:black;\r\n}\r\n</style>\r\n<script>\r\nlet span = document.querySelector(\"#span\")\r\nlet btn = document.querySelector(\"#btn\")\r\nbtn.addEventListener('click',async ()=>{\r\n    try{\r\n        await autoTyping(span,'',span.dataset['value'],150)\r\n        await waitMs(2000)\r\n        await autoBackSpacing(span,span.dataset['value'],'',50)\r\n    }catch(e){\r\n        console.log(e);\r\n    }\r\n})\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nasync function autoTyping(DomElement, start_TextString, ended_TextString, interval = 150) {\r\n    return new Promise(async (TypingResolve, TypingReject) => {\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce() {\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nasync function autoBackSpacing(DomElement, start_TextString, ended_TextString = '', interval = 150) {\r\n    return new Promise(async (BackSpaceResolve, BackSpaceReject) => {\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce() {\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText != ended_TextString) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0, DomElement.innerText.length - 1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nfunction waitMs(timeout) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n</script>\r\n\r\n\r\n\r\n```js\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nexport const autoTyping = async function (DomElement, start_TextString, ended_TextString, interval = 150) {\r\n    return new Promise(async (TypingResolve, TypingReject) => {\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function WriteCharOnce() {\r\n                return new Promise((WriteCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (index < ended_TextString.length) {\r\n                            let char = ended_TextString[index++]\r\n                            DomElement.innerText += (char == ' ') ? '\\xa0' : char; //空格无法直接拼接,需要转移\r\n                            WriteCharOnceResolve('isTyping')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            WriteCharOnceResolve('done') //WriteCharOnce 的 done\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await WriteCharOnce() == 'isTyping');\r\n            TypingResolve('done') //autoTyping 的 done\r\n        } else {\r\n            TypingReject('in_use');\r\n        }\r\n    });\r\n}\r\n\r\n\r\n/****\r\n    * @param {DOM元素} DomElement \r\n    * @param {初始字符串} start_TextString \r\n    * @param {目标字符串} ended_TextString \r\n    * @param {字符写入速度} interval \r\n    */\r\nexport const autoBackSpacing = async function (DomElement, start_TextString, ended_TextString = '', interval = 150) {\r\n    return new Promise(async (BackSpaceResolve, BackSpaceReject) => {\r\n        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中\r\n            DomElement.in_use = true;//节流阀:标记为正在使用中\r\n            let index = 0;\r\n            DomElement.innerText = start_TextString //初始化\r\n            function BackSpaceCharOnce() {\r\n                return new Promise((BackSpaceCharOnceResolve, reject) => {\r\n                    setTimeout(() => {\r\n                        if (DomElement.innerText.length != 0 && DomElement.innerText != ended_TextString) {\r\n                            DomElement.innerText = DomElement.innerText.substring(0, DomElement.innerText.length - 1) //删除最后一个字符\r\n                            BackSpaceCharOnceResolve('isBackSpacing')\r\n                        } else {\r\n                            DomElement.in_use = false;//节流阀:标记为使用完毕\r\n                            BackSpaceCharOnceResolve('done')\r\n                        }\r\n                    }, interval);\r\n                });\r\n            }\r\n            while (await BackSpaceCharOnce() == 'isBackSpacing');\r\n            BackSpaceResolve('done');\r\n        } else {\r\n            BackSpaceReject('in_use');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * \r\n * @param {延迟时间} timeout 500\r\n * @returns Promise对象\r\n */\r\nexport const waitMs = function (timeout) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => {\r\n            resolve('done');\r\n        }, timeout);\r\n    });\r\n}\r\n```\r\n\r\n\r\n## 为数字添加单位函数实现\r\n\r\n\r\n![](./images/2022-10-19-06-59-04.png)\r\n\r\n```js\r\n//使用\r\nlet result = getNumberWithUnit(12345,2);\r\nconsole.log(result) // 12.34k\r\n```\r\n\r\n```js\r\n/**\r\n * @param {数字} number 12345\r\n * @param {保留小数位数} Fixed 2\r\n * @returns 12.34k\r\n */\r\nexport function getNumberWithUnit(number, Fixed = 1) {\r\n    number = Number(number); //数值化\r\n    if (number == 0) return '0';//处理0\r\n    let sign = number > 0 ? '' : (number = - number, '-') //处理负数\r\n\r\n    let units = [//单位和进率 关系\r\n        { char: '' , multiple: 1     },\r\n        { char: 'k', multiple: 1000  },\r\n        { char: 'w', multiple: 10000 },\r\n    ];\r\n\r\n    let i = 0 ;\r\n    let unit = units[i];\r\n    for (; i < units.length; i++) {\r\n        if (number / units[i].multiple > 1) {\r\n            unit = units[i]\r\n            continue;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (unit == units[0]) {\r\n        return sign + number\r\n    } else {\r\n        return sign + (number / unit.multiple).toFixed(Fixed) + unit.char\r\n    }\r\n}\r\n```\r\n\r\n\r\n## 分页器实现\r\n\r\n![](./images/2022-10-19-07-07-59.png)\r\n\r\n```html\r\n<!-- 使用 -->\r\n<Pagination :currentPage=\"pageRange_current\" :totalPage=\"pageRange_max\" :subPaginationSize=\"5\" @gotoPage=\"gotoPage\"></Pagination>\r\n<script>\r\nexport default {\r\n    methods: {\r\n        gotoPage(index) {\r\n            this.getHomeArticlesInfo(index);\r\n        }\r\n    },\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n  <div class=\"pagination\">\r\n    <a class=\"left\" @click=\"emitPages(currentPage-1)\">&lt;</a>\r\n    <a class=\"firstPage\" v-if=\"SubPagination.start_SubPagination != 1\" @click=\"emitPages(1)\">1</a>\r\n    <a class=\"dots\" v-if=\"SubPagination.start_SubPagination != 1\">...</a>\r\n    <a class=\"subPagination\" v-for=\"index in SubPagination.yieldRange\" :key=\"index\" :class=\"{'currentPage':index==currentPage}\" @click=\"emitPages(index)\"\r\n    >{{index}}\r\n    </a>\r\n    <a class=\"dots\" v-if=\"SubPagination.ended_SubPagination != totalPage\">...</a>\r\n    <a class=\"lastPage\" v-if=\"SubPagination.ended_SubPagination != totalPage\" @click=\"emitPages(totalPage)\">{{totalPage}}</a>\r\n    <a class=\"right\" @click=\"emitPages(currentPage+1)\">&gt;</a>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    name:'Pagination',\r\n    props:['currentPage','totalPage','subPaginationSize'],\r\n    emits:['gotoPage'],\r\n    methods:{\r\n        yieldRange(start,ended){//生成数组\r\n            let result = [];\r\n            if(start>ended) return result;\r\n            for(let i = start;i<=ended;i++){\r\n                result.push(i)\r\n            }\r\n            return result;\r\n        },\r\n        yieldSubPagination(currentPage){//计算页码\r\n            let start_SubPagination = currentPage - Number.parseInt(this.subPaginationSize/2);\r\n            let ended_SubPagination = currentPage + Number.parseInt(this.subPaginationSize/2);\r\n            if(start_SubPagination<=1) start_SubPagination = 1;\r\n            if(ended_SubPagination>=this.totalPage) ended_SubPagination = this.totalPage;\r\n            return {\r\n                start_SubPagination,\r\n                ended_SubPagination,\r\n                yieldRange:this.yieldRange(start_SubPagination,ended_SubPagination)\r\n            }\r\n        },\r\n        emitPages(newPage){\r\n            console.log(\"newPage:\",newPage);\r\n            console.log(\"totalPage:\",this.totalPage);\r\n            if(newPage>=1 && newPage <= this.totalPage){\r\n                this.$emit('gotoPage',newPage)\r\n            }\r\n        }\r\n    },\r\n    computed:{\r\n        SubPagination(){\r\n            return this.yieldSubPagination(this.currentPage)\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.pagination{\r\n    text-align: center;\r\n    margin: 20px;\r\n    a{\r\n        display: inline-block;\r\n        padding: 5px;\r\n        margin-right:5px;\r\n        margin-bottom:5px;\r\n        min-width: 50px;\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n\r\n## 滚动事件切换类名animate改变封面高度\r\n\r\n![](./images/d32023ri0fj234j003.gif)\r\n\r\n```html\r\n<template>\r\n    <div ref=\"cover\" class=\"cover\" :class=\"{\"small\":coverSmall}\" >\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { throttle } from 'lodash';\r\nexport default {\r\n    name: 'Cover',\r\n    data() {\r\n        return {\r\n            coverSmall:false,\r\n            updataSignThrottle:undefined,\r\n        }\r\n    },\r\n    computed: {\r\n    },\r\n    methods: {\r\n        updataSign_coverSmall(){\r\n            let newVal = window.pageYOffset\r\n            if(newVal>0 && this.coverSmall != true){\r\n                this.coverSmall = true\r\n                window.scroll(0, 0)\r\n            }else if(newVal<=0 && this.coverSmall != false){\r\n                this.coverSmall = false\r\n                window.scroll(0, 0)\r\n            }\r\n        },\r\n    },\r\n    mounted() {\r\n        this.updataSignThrottle = throttle(this.updataSign_coverSmall,50,{leading:true}) //节流,throttle返回一个带有节流功能的事件处理函数\r\n        window.addEventListener('scroll',this.updataSignThrottle)\r\n    },\r\n    beforeUnmount(){\r\n        window.removeEventListener('scroll',this.updataSignThrottle)//移除事件处理函数\r\n        console.log('removeEventListener');\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.cover {\r\n    width: 100%;\r\n    height: 75vh;\r\n    transition: height ease 1s ;\r\n    &.small{\r\n        height: 30vh;//改变高度\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n## 文章页Markdown内容的渲染\r\n*  Markdown的渲染器marked的配置\r\n* hljs代码高亮配置\r\n* Markdown的样式\r\n* hijs代码高亮样式配置\r\n* 资源相对路径修改\r\n\r\n![](./images/2022-10-19-07-50-41.png)\r\n\r\n```js\r\n// Create reference instance\r\nimport { marked } from 'marked';//markdown的渲染脚本\r\n\r\nimport hljs from 'highlight.js';//hijs的脚本\r\nimport './base16_dracula.min.css' //highlight的某个样式文件\r\nimport 'github-markdown-css/github-markdown-dark.css' //github风格的Markdown样式\r\n\r\nconst options = {\r\n  renderer: new marked.Renderer(),\r\n\r\n  langPrefix: 'hljs language-', // highlight.js css expects a top-level 'hljs' class.\r\n  highlight: function (code, lang) {\r\n    // ```lang\r\n    // code\r\n    // code\r\n    // code\r\n    // ```\r\n    const language = hljs.getLanguage(lang) ? lang : 'plaintext';\r\n    return hljs.highlight(code, { language:language }).value;\r\n  },\r\n  // baseUrl: //为所有相对路径添加的前缀\r\n  pedantic: false,// 只解析符合Markdwon定义的，不修正Markdown的错误\r\n  gfm: true,// 启动类似于Github样式的Markdown语法\r\n  breaks: false,\r\n  sanitize: false,//原始输出，忽略HTML标签（关闭后，可直接渲染HTML标签）\r\n  smartypants: false,\r\n  xhtml: false\r\n}\r\n\r\n// Set options\r\nmarked.setOptions(options);\r\n\r\n// export\r\nexport const markdownParser = (rawContent,assetsbaseUrl) => marked.parse(rawContent,{baseUrl:assetsbaseUrl})\r\n// export const markdownParser = (rawContent) => marked.parse(rawContent)\r\n```\r\n\r\n```less\r\n.markdown-body { //自定义样式： .markdown-body 为 github-markdown-css 中定义的类名\r\n    background-color: unset;\r\n\r\n    ul {\r\n        position: relative;\r\n\r\n        li {\r\n            position: relative;\r\n\r\n            &::before,\r\n            &::after {\r\n                content: '';\r\n                display: inline-block;\r\n                position: absolute;\r\n                box-sizing: border-box;\r\n            }\r\n\r\n            &::after {\r\n                left: -1.25em;\r\n                top: 0.75em;\r\n                width: 0.75em;\r\n                height: 0.75em;\r\n                background-color: #58a6ff;\r\n                border: 2px solid white;\r\n                transform: translate(0, -50%);\r\n                border-radius: 50%;\r\n            }\r\n\r\n            &::before {\r\n                left: -1em;\r\n                top: 1em;\r\n                width: 0.25em;\r\n                height: 100%;\r\n                background-color: white;\r\n            }\r\n\r\n            &:last-child::before {\r\n                content: none;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n## filter实现文章页封面效果\r\n\r\n\r\n\r\n![](./images/2022-10-19-09-38-34.png)\r\n\r\n虽呈现效果一般，但已经是一种折中了，封面宽度若和版心宽度一致则会导致封面高度的等比例放大，在pc端浏览效果不佳，封面的高度占用了整个浏览器视口，若用同时指定宽高的方式规定封面的高度则会导致封面的变形或是被封面截取导致封面部分信息丢失。\r\n\r\n```html\r\n<template>\r\n  <div class=\"article_header\">\r\n      <div class=\"cover\" v-if=\"article_Attrs.cover\">\r\n          <img :src=\"article_Attrs.cover\" alt=\"\" class=\"main_Img\">\r\n          <img :src=\"article_Attrs.cover\" alt=\"\" class=\"mask_Img\">\r\n      </div>\r\n  </div>\r\n</template>\r\n<style lang=\"less\">\r\n.article_header {\r\n    text-align: center;\r\n\r\n    .cover {\r\n        width: 100%;\r\n        height: 30vh;\r\n        overflow: hidden;\r\n        position: relative;\r\n\r\n        .main_Img {\r\n            z-index: 1;\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            object-fit: scale-down;\r\n            object-position: center center;\r\n        }\r\n\r\n        .mask_Img {\r\n            z-index: 0;\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            filter: contrast(200%) blur(50px);\r\n            // object-fit:  scale-down;\r\n            // object-position: center center;\r\n        }\r\n    }\r\n  }\r\n</style>\r\n```\r\n\r\n\r\n\r\n\r\n## vue中hash路由与markdown中锚点链接冲突的解决及链接跳转的实现\r\n\r\n![](./images/fiwqefj0302.gif)\r\n\r\n```html\r\n<template>\r\n    <div ref=\"markdown_body\" v-html=\"article_HTML\" @click=\"clickHandle\"></div>\r\n</template>\r\n\r\n<script>\r\nimport { mapActions, mapGetters } from 'vuex'\r\nexport default {\r\n    computed: {\r\n      ...mapGetters('article', ['article_HTML']),\r\n    },\r\n    methods: {\r\n        ...mapActions('article', ['getArticleById']),\r\n        clickHandle(event){\r\n            let address = event.target.getAttribute(\"href\")\r\n            if (address) {//有address\r\n                if(address[0] == '#') {//判断是否为锚点\r\n                    this.goToElementById(address);\r\n                }else if(address[0] == '/') {//绝对地址\r\n                    window.location.replace(address)\r\n                }else{//url地址\r\n                    window.location.replace(address)\r\n                }\r\n                event.preventDefault() //有address则禁止默认事件的触发\r\n            } else {\r\n                //不禁止\r\n            }\r\n        },\r\n        goToElementById(id) {//滚动到指定元素\r\n            document.querySelector( decodeURI(id) ).scrollIntoView({\r\n                behavior: \"smooth\", // 定义动画过渡效果， \"auto\"或 \"smooth\" 之一。默认为 \"auto\"\r\n                block: \"center\",// 定义垂直方向的对齐， \"start\", \"center\", \"end\", 或 \"nearest\"之一。默认为 \"start\"\r\n                inline: \"nearest\" // 定义水平方向的对齐， \"start\", \"center\", \"end\", 或 \"nearest\"之一。默认为 \"nearest\"\r\n            })\r\n        },\r\n    },\r\n    watch:{\r\n      \"$route.params\":{//监听路由变化请求文章内容\r\n          deep:true,\r\n          immediate:true,\r\n          handler(){\r\n              this.getArticleById(this.$route.params.id);\r\n          }\r\n      },\r\n    }\r\n}\r\n</script>\r\n```\r\n\r\n\r\n## markdown中script标签内代码不执行问题的解决\r\n\r\n* script只会在DOM第一次加载的时候执行，\r\n* 通过innerHTML方式插入的script标签不会执行，\r\n* 通过createElement(script);appendChild()附加的标签会执行\r\n\r\n\r\n```html\r\n<template>\r\n    <div ref=\"markdown_body\" v-html=\"article_HTML\" @click=\"clickHandle\"></div>\r\n</template>\r\n\r\n<script>\r\nimport { mapActions, mapGetters } from 'vuex'\r\nexport default {\r\n    computed: {\r\n        ...mapGetters('article', ['article_HTML']),\r\n    },\r\n    methods: {\r\n        ...mapActions('article', ['getArticleById']),\r\n    },\r\n    watch:{\r\n        \"$route.params\":{//监听路由变化请求文章内容\r\n            deep:true,\r\n            immediate:true,\r\n            handler(){\r\n                this.getArticleById(this.$route.params.id);\r\n            }\r\n        },\r\n        article_HTML:{//监听article_HTML的更新\r\n            handler(){\r\n                nextTick(()=>{//nextTick是为了等待Dom元素渲染完毕，因为应当等DOM元素渲染完毕后执行script脚本\r\n                    //附加文章中的script脚本\r\n                    //script只会在DOM第一次加载的时候执行，通过innerHTML方式插入的script标签不会执行，通过createElement(script);appendChild()附加的标签会执行\r\n                    this.$refs.markdown_body.querySelectorAll(\"script\").forEach(element => {\r\n                        var script = document.createElement(\"script\")\r\n                        if(element.src)//外链式\r\n                            script.src = element.src\r\n                        if(element.innerHTML)//内联代码\r\n                            script.innerHTML = element.innerHTML\r\n                        this.$refs.markdown_body.appendChild(script)\r\n                    });\r\n                })\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n```\r\n\r\n\r\n## 使markdown中script标签支持jQuery(`$`)语法\r\n\r\n```html\r\n<template>\r\n    <div ref=\"markdown_body\" v-html=\"article_HTML\" @click=\"clickHandle\"></div>\r\n</template>\r\n\r\n<script>\r\nimport jQuery from \"jQuery\" //jQuery\r\nimport { mapActions, mapGetters } from 'vuex'\r\nexport default {\r\n    computed: {\r\n        ...mapGetters('article', ['article_HTML']),\r\n    },\r\n    methods: {\r\n        ...mapActions('article', ['getArticleById']),\r\n    },\r\n    watch:{\r\n        \"$route.params\":{//监听路由变化请求文章内容\r\n            deep:true,\r\n            immediate:true,\r\n            handler(){\r\n                this.getArticleById(this.$route.params.id);\r\n            }\r\n        },\r\n        article_HTML:{//监听article_HTML的更新\r\n            handler(){\r\n                nextTick(()=>{//nextTick是为了等待Dom元素渲染完毕，因为应当等DOM元素渲染完毕后执行script脚本\r\n                    //附加文章中的script脚本\r\n                    //script只会在DOM第一次加载的时候执行，通过innerHTML方式插入的script标签不会执行，通过createElement(script);appendChild()附加的标签会执行\r\n                    this.$refs.markdown_body.querySelectorAll(\"script\").forEach(element => {\r\n                        var script = document.createElement(\"script\")\r\n                        if(element.src)//外链式\r\n                            script.src = element.src\r\n                        if(element.innerHTML)//内联代码\r\n                            script.innerHTML = element.innerHTML\r\n                        this.$refs.markdown_body.appendChild(script)\r\n                    });\r\n                })\r\n            }\r\n        }\r\n    },\r\n    created(){\r\n        window.$ = jQuery  //for jquery \r\n    }\r\n}\r\n</script>\r\n```\r\n\r\n\r\n## 使markdown支持渲染KaTex语法数学公式及复制KaTex源代码\r\n\r\n渲染前后效果\r\n![](./images/2022-10-19-09-35-14.png)\r\n![](./images/2022-10-19-09-34-04.png)\r\n\r\n```html\r\n<template>\r\n    <div ref=\"markdown_body\" v-html=\"article_HTML\" @click=\"clickHandle\"></div>\r\n</template>\r\n\r\n<script>\r\n//katex\r\nimport \"katex/dist/katex.css\" //katex样式\r\nimport \"katex/dist/katex.js\" //katex核心库\r\nimport renderMathInElement from \"katex/contrib/auto-render/auto-render\" //自动渲染扩展库\r\nimport \"katex/contrib/copy-tex\" //copy-tex扩展库 使得复制katex公式将得到katex源代码 $\\log_2{N}$\r\n\r\nimport { mapActions, mapGetters } from 'vuex'\r\nexport default {\r\n    computed: {\r\n        ...mapGetters('article', ['article_HTML']),\r\n    },\r\n    methods: {\r\n        ...mapActions('article', ['getArticleById']),\r\n    },\r\n    watch:{\r\n        \"$route.params\":{//监听路由变化请求文章内容\r\n            deep:true,\r\n            immediate:true,\r\n            handler(){\r\n                this.getArticleById(this.$route.params.id);\r\n            }\r\n        },\r\n        article_HTML:{//监听article_HTML的更新\r\n            handler(){\r\n                nextTick(()=>{//nextTick是为了等待Dom元素渲染完毕\r\n                    //自动渲染katex\r\n                    renderMathInElement(\r\n                        this.$refs.markdown_body,\r\n                        {\r\n                            delimiters: [\r\n                                {left: \"$$\", right: \"$$\", display: true},\r\n                                {left: \"$\", right: \"$\", display: false},\r\n                                {left: \"\\\\begin{equation}\", right: \"\\\\end{equation}\", display: true},\r\n                                {left: \"\\\\begin{align}\", right: \"\\\\end{align}\", display: true},\r\n                                {left: \"\\\\begin{alignat}\", right: \"\\\\end{alignat}\", display: true},\r\n                                {left: \"\\\\begin{gather}\", right: \"\\\\end{gather}\", display: true},\r\n                                {left: \"\\\\(\", right: \"\\\\)\", display: false},\r\n                                {left: \"\\\\[\", right: \"\\\\]\", display: true}\r\n                            ]\r\n                        }\r\n                    );\r\n                })\r\n            }\r\n        }\r\n    },\r\n}\r\n</script>\r\n```\r\n\r\n## 归档页github风格代码贡献统计效果的组件实现\r\n\r\n![](./images/2022-10-19-09-05-47.png)\r\n\r\n\r\n```html\r\n<template>\r\n    <div id=\"GitCalendar_bg\">\r\n        <h2 class=\"title\">博客内容更新及站点维护提交次数统计</h2>\r\n        <div class=\"_container\">\r\n            <div ref=\"GitCalendar\"></div>\r\n        </div>\r\n        <div id=\"tooltip\"></div>\r\n    </div>\r\n</template>\r\n<script>\r\nimport { SVGGraph } from 'calendar-graph/es/index.js';\r\nimport moment from 'moment';\r\nimport { mapActions, mapState } from 'vuex';\r\nexport default {\r\n    name: 'GitCalendar',\r\n    methods: {\r\n        SVGGraph,\r\n        ...mapActions('commit', ['getCommitData']),\r\n        tooltipInit() {\r\n            const tip = document.getElementById('tooltip');\r\n            let elems = document.getElementsByClassName('cg-day');\r\n            const mouseOver = function (e) {\r\n                e = e || window.event;\r\n                const elem = e.target || e.srcElement;\r\n                const rect = elem.getBoundingClientRect();\r\n                const count = elem.getAttribute('data-count');\r\n                const date = elem.getAttribute('data-date');\r\n                tip.style.display = 'block';\r\n                tip.textContent = `${count} contributions on ${date}`;\r\n                const w = tip.getBoundingClientRect().width;\r\n                tip.style.left = `${rect.left - (w / 2) + 6}px`;\r\n                tip.style.top = `${rect.top - 35}px`;\r\n            };\r\n            const mouseOut = function (e) {\r\n                e = e || window.event;\r\n                tip.style.display = 'none';\r\n            };\r\n            for (let i = 0; i < elems.length; i++) {\r\n                if (document.body.addEventListener) {\r\n                    elems[i].addEventListener('mouseover', mouseOver, false);\r\n                    elems[i].addEventListener('mouseout', mouseOut, false);\r\n                } else {\r\n                    elems[i].attachEvent('onmouseover', mouseOver);\r\n                    elems[i].attachEvent('onmouseout', mouseOut);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    computed: {\r\n        ...mapState('commit', ['CommitData'])\r\n    },\r\n    watch: {\r\n        CommitData(newVal, oldVal) {\r\n            // const newVal = [ //数据格式\r\n            //   { date: '2016-01-01', count: 1 },\r\n            //   { date: '2016-01-03', count: 4 },\r\n            //   { date: '2016-01-06', count: 2 },\r\n            //   // ...and so on\r\n            // ];\r\n            let mySVGGraph = new this.SVGGraph(this.$refs.GitCalendar, newVal, {\r\n                startDate: new Date(moment().add(-1, 'years')),//开始日期为去年的今日\r\n                endDate: new Date(moment()),//结束时间为今日\r\n                colorFun: (v) => {\r\n                    let colors = [ // https://colordesigner.io/\r\n                        '#d8f1ce',\r\n                        // '#b1e39e',\r\n                        // '#8ad56d',\r\n                        '#63c73d',\r\n                        '#4b9a2c',\r\n                        '#33691E',\r\n                    ];\r\n                    let count = v.count < colors.length ? v.count : colors.length - 1\r\n                    let result = colors[count]\r\n                    return result;\r\n                },\r\n                onClick: v => {\r\n                    // console.log('12312321');\r\n                },\r\n                size: 12,\r\n                space: 1,\r\n                padX: 20,\r\n                padY: 20,\r\n            })\r\n            this.tooltipInit();\r\n        }\r\n    },\r\n    mounted() {\r\n        this.getCommitData();\r\n    }\r\n}\r\n\r\n</script>\r\n<style lang=\"less\">\r\n#GitCalendar_bg {\r\n    width: 100%;\r\n    text-align: center;\r\n    background-color: white;\r\n    border-radius: 5px;\r\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\r\n    padding-top: 10px;\r\n    .title {\r\n        color: black;\r\n        font-size: medium;\r\n    }\r\n\r\n    ._container {\r\n        overflow: auto;\r\n\r\n        &::-webkit-scrollbar {\r\n            display: none; // 清除滚动条\r\n        }\r\n    }\r\n}\r\n\r\n#tooltip {\r\n    display: none;\r\n    position: fixed;\r\n    left: 0;\r\n    top: 0;\r\n    height: 20px;\r\n    background-color: rgba(0, 0, 0, .8);\r\n    color: #fff;\r\n    padding: 0px 10px;\r\n    border-radius: 3px;\r\n}\r\n\r\n#tooltip:after {\r\n    display: block;\r\n    position: absolute;\r\n    content: '';\r\n    bottom: -6px;\r\n    left: 50%;\r\n    margin-left: -6px;\r\n    width: 0;\r\n    height: 0;\r\n    border-left: 6px solid transparent;\r\n    border-right: 6px solid transparent;\r\n    border-top: 6px solid rgba(0, 0, 0, .8);\r\n}\r\n</style>\r\n```\r\n\r\n\r\n```js\r\n// 数据的生成\r\nconst counts = (arr, value) => arr.reduce((a, v) => v === value ? a + 1 : a + 0, 0)\r\nimport { execSync } from 'child_process'\r\nimport { log } from 'console'\r\nfunction getCommitData(weeks = '55') {\r\n  const _cmd = `git log --all --since=\"${weeks}.weeks\" --date=iso --pretty=format:\"%ad\"`//git log --all --since=\"40.weeks\" --date=iso --pretty=format:\"%ad\"\r\n  const _gitLog = execSync(_cmd).toString()\r\n  const gitlogData = _gitLog.split('\\n').map(e => {\r\n    return e.split(' ')[0]\r\n  })\r\n  // console.log(gitlogData);\r\n  const uniaueDate = [...new Set(gitlogData)]\r\n  const commitData = []\r\n  for (const e of uniaueDate) {\r\n    commitData.push({\r\n      date: e,\r\n      count: counts(gitlogData, e)\r\n    })\r\n  }\r\n  return commitData\r\n}\r\nawait fs.writeFile(path.join(webSiteRootDir, './api/archive_commitData.json'), JSON.stringify(getCommitData())) //写入新文件名\r\n```\r\n\r\n## 将文章标题字符串计算HASH作为ID\r\n\r\n```js\r\nimport stringHash from 'string-hash'\r\nlet id = stringHash(article_title)//给文章生成id\r\n```\r\n\r\n\r\n## 通过front-matter将markdown文章首部的yml格式信息获取\r\n\r\n```js\r\nimport FM from 'front-matter'\r\nlet fm = FM(articleTEXT);\r\n```"},{"shortInfo":{"title":"vue3学习笔记","date":"2022-09-07T15:37:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["vue3","学习笔记"],"categories":"前端","id":48,"countWords":13691,"readSeconds":1369.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# vue3学习笔记\r\n## 目录\r\n- [vue3学习笔记](#vue3学习笔记)\r\n  - [目录](#目录)\r\n  - [简介](#简介)\r\n  - [基本用法](#基本用法)\r\n  - [指令](#指令)\r\n    - [内容渲染指令](#内容渲染指令)\r\n    - [属性绑定指令](#属性绑定指令)\r\n    - [事件绑定指令](#事件绑定指令)\r\n    - [双向绑定指令](#双向绑定指令)\r\n    - [条件渲染指令](#条件渲染指令)\r\n    - [列表渲染指令](#列表渲染指令)\r\n    - [vue2过滤器](#vue2过滤器)\r\n    - [综合案例实现](#综合案例实现)\r\n  - [组件](#组件)\r\n    - [SPA概念](#spa概念)\r\n    - [Vite构建工具](#vite构建工具)\r\n    - [Vite基本使用](#vite基本使用)\r\n    - [注册全局组件](#注册全局组件)\r\n    - [注册局部组件](#注册局部组件)\r\n    - [组件案例](#组件案例)\r\n  - [computed属性](#computed属性)\r\n  - [触发自定义事件](#触发自定义事件)\r\n  - [父子组件间数据传递-props属性](#父子组件间数据传递-props属性)\r\n    - [props基本使用](#props基本使用)\r\n    - [数据合法性验证](#数据合法性验证)\r\n  - [父子组件间数据的双向同步](#父子组件间数据的双向同步)\r\n    - [v-bind:单向绑定数据](#v-bind单向绑定数据)\r\n    - [v-model双向绑定父子组件间数据](#v-model双向绑定父子组件间数据)\r\n  - [`todoList案例实现`](#todolist案例实现)\r\n  - [watch监听器](#watch监听器)\r\n  - [生命周期钩子函数](#生命周期钩子函数)\r\n  - [组件间数据共享](#组件间数据共享)\r\n    - [父子关系组件间数据共享](#父子关系组件间数据共享)\r\n    - [后代关系组件间数据共享](#后代关系组件间数据共享)\r\n    - [兄弟关系组件间数据共享](#兄弟关系组件间数据共享)\r\n    - [VueX全局数据共享](#vuex全局数据共享)\r\n      - [概念](#概念)\r\n      - [vuex原理](#vuex原理)\r\n      - [基本使用](#基本使用)\r\n      - [vueX的模块化](#vuex的模块化)\r\n    - [总结](#总结)\r\n  - [lodash节流防抖:throttle()](#lodash节流防抖throttle)\r\n  - [axios](#axios)\r\n    - [全局配置axios](#全局配置axios)\r\n    - [axios的拦截器](#axios的拦截器)\r\n    - [axios配置nprogress进度条](#axios配置nprogress进度条)\r\n  - [`购物车案例实现`](#购物车案例实现)\r\n  - [DOM的引用---ref属性](#dom的引用---ref属性)\r\n  - [DOM更新时机及nextTick()](#dom更新时机及nexttick)\r\n  - [动态组件component](#动态组件component)\r\n  - [插槽Slot](#插槽slot)\r\n  - [自定义的指令Directives](#自定义的指令directives)\r\n  - [表格案例实现](#表格案例实现)\r\n  - [路由](#路由)\r\n    - [路由原理](#路由原理)\r\n    - [基本使用:声明式导航](#基本使用声明式导航)\r\n    - [基本使用:编程式导航](#基本使用编程式导航)\r\n    - [导航守卫](#导航守卫)\r\n  - [登陆案例实现](#登陆案例实现)\r\n  - [vue-cli脚手架](#vue-cli脚手架)\r\n  - [vue组件库](#vue组件库)\r\n    - [element UI](#element-ui)\r\n  - [vue-cli的proxy代理服务](#vue-cli的proxy代理服务)\r\n  - [transition动画组件](#transition动画组件)\r\n  - [swiper在vue中的使用](#swiper在vue中的使用)\r\n  - [根据页面滚动位置改变盒子高度(存在兼容性问题)](#根据页面滚动位置改变盒子高度存在兼容性问题)\r\n\r\n\r\n------------------------------------------------------------------------------------------\r\n## 简介\r\nvue是一套用于**构建用户界面**的**前端框架**\r\n\r\n**vue全家桶**\r\n* vue 核心库\r\n* vue-router 路由方案\r\n* vuex 状态管理方案\r\n* vue组件库 快速搭建页面UI效果的方案\r\n\r\n**vue辅助开发工具**\r\n* vue-cli (npm全局包,一键生成工程化vue项目-基于webpack,大而全)\r\n* vite (npm全局包,一键生成工程化vue项目,小而巧)\r\n* vue-devtools 浏览器插件:辅助调试工具\r\n* vetur VScode插件:语法高亮和智能提示\r\n\r\n------------------------------------------------------------------------------------------\r\n\r\n## 基本用法\r\n\r\n\r\n**vue3基本使用**\r\n```js\r\n<script src=\"https://unpkg.com/vue@next\"></script>\r\n<div id=\"demo_1\">{{ test1 }}</div>\r\n<script>\r\n    const test1 = {\r\n        data() {\r\n            return {\r\n                test1 : \"hello world!!!\"\r\n            }\r\n        }\r\n    }\r\n    Vue.createApp(test1).mount('#demo_1')\r\n</script>\r\n```\r\n\r\n**Vue2基本使用**\r\n```js\r\n<script src=\"https://unpkg.com/vue@2.6.14/dist/vue.min.js\"></script>\r\n<div id=\"demo_1\">{{ test1 }}</div>\r\n<script>\r\n    const vm = new Vue({\r\n        el:\"#demo_1\",\r\n        data:{\r\n            test1:\"hello world!!!\",\r\n            count:123\r\n            methods:{\r\n                addAcount(){\r\n                    //this指向vm,可以访问到data中的属性\r\n                    this.count+=1;\r\n                }\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n------------------------------------------------------------------------------------------\r\n\r\n## 指令\r\n**分类**\r\n* 内容渲染指令\r\n* 属性绑定指令\r\n* 事件绑定指令\r\n* 双向绑定指令\r\n* 条件渲染指令\r\n* 列表渲染指令\r\n\r\n\r\n### 内容渲染指令\r\n```html\r\n语法格式: \r\n    {{ 变量名 }}        插值表达式\r\n    v-text=\"变量名\"     内容渲染指令(纯文本)\r\n    v-html=\"变量名\"     内容渲染指令(html)\r\n\r\n示例:\r\n<p >用户名: {{ username }}</p>\r\n<p v-text=\"test1\">原内容将被覆盖</p>\r\n<p v-html=\"test2\">原内容将被覆盖</p>\r\n\r\n\r\n<!-- 支持js表达式 -->\r\n<p>{{ number + 1 }}</p>\r\n<p>{{ ok ? 'YES' : 'NO' }}</p>\r\n<p>{{ message.split('').reverse().join('') }}</p>\r\n<div :id=\"`list-${id}`\"></div>\r\n<p>{{user.name}}</p>\r\n```\r\n\r\n\r\n### 属性绑定指令\r\n```html\r\n语法格式:   v-bind:属性名=\"变量名\"\r\n简写:       :属性名=\"变量名\"\r\n\r\n示例:\r\n    <img v-bind:src=\"imgSrc\" :alt=\"imgText\"  >\r\n```\r\n\r\n\r\n`v-bind:class` 和 `v-bind:style` 的绑定\r\n```html\r\n<template>\r\n  \r\n  <div class=\"defalutClassName\" :class=\"isClssNameA ? 'ClssNameA' : '' \">测试文字</div>\r\n  <div class=\"defalutClassName\" :class=\"[isClssNameA ? 'ClssNameA' : '' ,isClssNameB ? 'ClssNameB' : '' ]\">测试文字</div>\r\n  <div class=\"defalutClassName\" :class=\"classList\">测试文字</div>\r\n\r\n  <div class=\"defalutClassName\" :style=\"'color:' + isActive\">测试文字</div>\r\n  <div class=\"defalutClassName\" :style=\"{color:isActive,fontSize:fSize + 'px','background-color':bgcolor}\">测试文字</div><!-- fontSize和‘font-size‘等效 ‘background-color’和backgroundColor等效 -->\r\n  <div class=\"defalutClassName\" :style=\"styleObj\">测试文字</div>\r\n\r\n</template>\r\n\r\n\r\n\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      isClssNameA: true,\r\n      isClssNameB: true,\r\n      isActive: \"skyblue\",\r\n      fSize: 15,\r\n      bgcolor: \"pink\",\r\n      classList: [\r\n        \"ClssNameA\",\r\n        \"ClssNameB\",\r\n      ],\r\n      styleObj: {\r\n        color: \"red\",\r\n        fontSize: \"15px\",           //fontSize和'font-size'等效\r\n        'background-color': 'pink'\r\n      }\r\n    }\r\n  },\r\n}\r\n</script>\r\n<style>\r\n.defalutClassName {\r\n  color: red;\r\n}\r\n\r\n.ClssNameA {\r\n  font-size: 15px;\r\n}\r\n\r\n.ClssNameB {\r\n  background-color: pink;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n### 事件绑定指令\r\n```html\r\n语法格式:   v-on:事件名称.事件修饰符号=\"事件处理函数名 或 js表达式\"\r\n简写:       @事件名称.事件修饰符号=\"事件处理函数名 或 js表达式\"\r\n\r\n事件修饰符号\r\n    .prevent    阻止默认行为,如阻止点击超链接跳转\r\n    .stop       阻止事件冒泡\r\n    .capture    以捕获方式(从外到内)触发当前事件,浏览器默认以冒泡方式(从内到外)触发事件\r\n    .once       绑定的事件只触发一次\r\n    .self       只在event.target==this时触发\r\n\r\n按键事件修饰符\r\n    .enter      示例: @keyup.enter=\"事件处理函数名\"\r\n    .esc      \r\n\r\n示例:\r\n    <button v-on:click.self=\"addCount\"> +1 </button>\r\n    <button @click.self=\"count += 1\"> +1 </button>\r\n    <button @click.self=\"addCountA()\"> +1 </button> <!-- 事件处理函数的第一个形参默认是事件对象 -->\r\n    <button @click.self=\"addCountB(5,$event)\"> +1 </button> <!-- 若第一个形式参数的位置被占用,可手动传入事件对象$event -->\r\n\r\n\r\n```\r\n\r\n\r\n### 双向绑定指令\r\n```html\r\n语法格式:   v-model.修饰符=\"变量名\"\r\n\r\n修饰符:\r\n    .number     自动将输入表单的数据转换为数字\r\n    .trim       自动过滤输入数据的字符串首尾的空格\r\n    .lazy       仅在\"change\"事件触发时(失去焦点)写入用户输入的数据,而非\"input\"事件触发时\r\n\r\n注意:   双向绑定指令只能配合html的表单元素使用\r\n\r\n示例:\r\n    <input v-model=\"username\">\r\n    <input v-model.number=\"age\">\r\n```\r\n\r\n\r\n### 条件渲染指令\r\n```html\r\n语法格式:\r\n    v-if=\"布尔值 或 变量名\"\r\n        v-else-if=\"布尔值 或 变量名\"\r\n        v-else\r\n    v-show=\"布尔值 或 变量名\"\r\n\r\n区别:\r\n    原理区别\r\n        v-if是动态的添加和删除DOM元素\r\n        v-show是动态的修改DOM元素的CSS的display:none;属性\r\n    性能区别\r\n        在两者都在初始时不渲染,需要频繁切换是否渲染时,\r\n        v-show具有更高初始渲染开销,\r\n        v-if具有更高的切换开销,\r\n\r\n示例:\r\n    <button @click=\"flag=!flag\">change flag</button>\r\n    <div v-if=\"flag\">div1</div>\r\n    <div v-show=\"!flag\">div2</div>\r\n```\r\n\r\n### 列表渲染指令\r\n\r\n```html\r\n语法格式:\r\n    v-for=\"item in items\"\r\n    v-for=\"(item,index) in items\"\r\n\r\n示例:\r\n    <li v-for=\"userName in userNameS\">{{userName}}</li>\r\n    <li v-for=\"(userName,i) in userNameS\">索引号是:{{i}},用户名是:{{userName}}</li>\r\n\r\n注意:\r\n    在vue2中,可以使用  :id=\"字符串 或 数值 的变量名\"   属性防止列表渲染内容紊乱\r\n    <li v-for=\"(userInfo,i) in userInfoS\" :id=\"userInfo.userId\">索引号是:{{i}},用户名是:{{userInfo}}</li>\r\n```\r\n\r\n\r\n### vue2过滤器\r\n过滤器仅在vue1 vue2中支持,vue3中建议使用`计算属性`或`方法`来代替\r\n```html\r\n<script src=\"https://unpkg.com/vue@2.6.14/dist/vue.min.js\"></script>\r\n<div id=\"demo_1\">\r\n    <p>{{text | capitalize | maxLength }}</p>\r\n    <p>{{text | capitalize | maxLength(20) }}</p>\r\n</div>\r\n<script>\r\n//定义全局过滤器(公有过滤器)\r\n    Vue.filter(\"maxLength\", (data, maxLength = 10) => { //第一个默认为接收到的参数,之后的参数为可选参数,可以接收到\r\n        if (data.length <= maxLength) return data\r\n        else return data.slice(0, maxLength) + \"......\"\r\n    })\r\n\r\n    const vm = new Vue({\r\n        el: \"#demo_1\",\r\n        data: {\r\n            text: \"dingyiguidingyiguidingyiguidingyigui\"\r\n        },\r\n//定义局部过滤器(私有过滤器)\r\n        filters: {\r\n            capitalize(data) {\r\n                return data.charAt(0).toUpperCase() + data.slice(1)\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n### 综合案例实现\r\n\r\n**实现效果**\r\n![图 4](./images/vue3学习笔记/f5d86ec4438a1f6a0466d8b303e7b459e32831edc61ba091681e037cedc8c0f3.png)  \r\n\r\n\r\n**源代码**\r\n```html\r\n<!-- <script src=\"./lib/vue@2.6.14.min.js\"></script> -->\r\n<link href=\"https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.css\" rel=\"stylesheet\">\r\n<script src=\"https://unpkg.com/vue@2.6.14/dist/vue.js\"></script>\r\n<div id=\"app\" class=\"container container-fluid\">\r\n    <div class=\"card\">\r\n        <div class=\"card-header\">添加品牌</div>\r\n        <div class=\"card-body row\">\r\n            <div class=\"input-group col\">\r\n                <span class=\"input-group-text\">品牌名称</span>\r\n                <!-- v-model.trim=\"tempBrand.name\" 双向绑定 -->\r\n                <!-- @keyup.esc=\"tempBrand.name=``\"键盘esc弹出事件发生后执行 tempBrand.name=`` -->\r\n                <!-- @keyup.enter=\"addItem\"     键盘enter弹出事件事件发生后调用addItem() -->\r\n                <input type=\"text\" class=\"form-control\" placeholder=\"请输入品牌名称\" v-model.trim=\"tempBrand.name\"\r\n                    @keyup.esc=\"tempBrand.name=``\" @keyup.enter=\"addItem\">\r\n                <!-- @click=\"addItem\"点击事件发生后调用addItem() -->\r\n                <button class=\"btn btn-outline-secondary\" type=\"button\" @click=\"addItem\">添加</button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <table class=\"table table-striped\">\r\n        <thead>\r\n            <tr>\r\n                <th scope=\"col\">#</th>\r\n                <th scope=\"col\">品牌名称</th>\r\n                <th scope=\"col\">状态</th>\r\n                <th scope=\"col\">创建时间</th>\r\n                <th scope=\"col\">操作</th>\r\n            </tr>\r\n        </thead>\r\n        <tbody>\r\n            <!-- :id=\"`item_${item.id}`\" 控制防止vue2中列表顺序渲染紊乱 -->\r\n            <tr v-for=\"item in brandList\" :id=\"`item_${item.id}`\">\r\n                <th scope=\"row\">{{item.id}}</th>\r\n                <th>{{item.name}}</th>\r\n                <th>\r\n                    <div class=\"form-check form-switch\">\r\n                        <!-- v-model控制双向绑定更新数据 -->\r\n                        <input class=\"form-check-input\" :id=\"`item_check_${item.id}`\" type=\"checkbox\" role=\"switch\"\r\n                            v-model=\"item.status\">\r\n                        <!-- v-if=\"item.status\"控制是否显示 -->\r\n                        <!-- :for=\"`item_check_${item.id}`\" 绑定到指定id,表示点击该元素就相当于点击带有#id的元素 -->\r\n                        <label v-if=\"item.status\" class=\"form-check-label\"\r\n                            :for=\"`item_check_${item.id}`\">已启用</label>\r\n                        <label v-else class=\"form-check-label\" :for=\"`item_check_${item.id}`\">已禁用</label>\r\n                    </div>\r\n                </th>\r\n                <th>{{item.time}}</th>\r\n                <!-- removeItemById(item.id)控制删除项目 -->\r\n                <th><a href=\"\" @click.prevent=\"removeItemById(item.id)\">删除</a></th>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</div>\r\n<script>\r\n    const vm = new Vue({\r\n        el: \"#app\",\r\n        data: {\r\n            tempBrand: { name: \"\" },//用于临时存储数据\r\n            nextId: 4,\r\n            brandList: [\r\n                { id: 1, name: \"华为\", status: true, time: new Date() },\r\n                { id: 2, name: \"小米\", status: false, time: new Date() },\r\n                { id: 3, name: \"苹果\", status: true, time: new Date() },\r\n            ]\r\n        },\r\n        methods: {\r\n            removeItemById(targetId) {//根据id删除数据\r\n                this.brandList.splice(this.brandList.findIndex((item) => item.id == targetId), 1)\r\n            },\r\n            addItem() {\r\n                if (!this.tempBrand.name) return alert(\"名称不能为空!!!\")\r\n                this.brandList.push({\r\n                    id: this.nextId,\r\n                    name: this.tempBrand.name,\r\n                    status: true,\r\n                    time: new Date()\r\n                })\r\n                this.tempBrand = { name: \"\" }//清空\r\n                this.nextId++       //自增id\r\n            }\r\n        }\r\n    })\r\n</script>\r\n```\r\n--------------------------------------------------------------------\r\n\r\n## 组件\r\n\r\n\r\n\r\n### SPA概念\r\n```markdown\r\n# SPA概念\r\nSPA(single Page Application)单页面应用程序,指一个web网站只有唯一的HTML页面,所有功能与交互仅在一个页面完成.\r\n\r\n# 特点\r\n仅在页面初始化时加载相关资源,加载完毕后单页面应用不会因用户操作而重新加载页面或跳转页面,而是利用js动态改变内容\r\n\r\n# 优缺点\r\n* 交互体验好\r\n* 前后端分离,提升开发效率\r\n* 减轻服务器压力\r\n* 首页加载慢\r\n    * 解决方案: 路由懒加载、\r\n    * 代码压缩、\r\n    * CDN加速、\r\n    * 网络传输压缩、\r\n* 不利于SEO\r\n    * 解决方案: SSR服务器渲染\r\n```\r\n\r\n\r\n-------------------------------------------------------\r\n\r\n### Vite构建工具\r\n\r\n**概念**\r\nVite是Vue官方构建工具之一,用于构建SPA单网页应用\r\n![图 1](./images/vue3学习笔记/8aedff39e3d534c60b06ac2e0020dc798b4de170836de225fc7f9fd5efc7719c.png)  \r\n\r\n**Vite使用**\r\n```bash\r\n# 使用\r\nnpm create vite@latest\r\ncd ???\r\nnpm install\r\nnpm run dev\r\n```\r\n\r\n-------------------------------------------------------\r\n\r\n\r\n**Vite项目目录结构**  \r\n* `public/` 公共静态资源\r\n* `src/`   项目源代码\r\n  * `assets/` 编写的静态资源文件(css fonts)\r\n  * `components/` 编写的自定义组件\r\n  * `App.vue` 项目根组件\r\n  * `index.css` 全局样式表文件\r\n  * `main.js` 整个项目的打包入口\r\n* `index.html` SPA页面\r\n\r\n![图 2](./images/vue3学习笔记/047ffa1d1ac7da857630d9ee4568412ed299a93bec402f00fb35dc3752181b6e.png)  \r\n\r\n-------------------------------------------------------\r\n\r\n**Vite运行流程**  \r\n通过 `main.js` 把 `App.vue` 渲染到 `index.html`\r\n* `App.vue` 写待渲染的模板结构\r\n* `index.html` 需预留el区域\r\n* `main.js` 把 `App.vue` 渲染到 `index.html` 所预留的区域中\r\n\r\n\r\n### Vite基本使用\r\n\r\n**App.vue**\r\n```html\r\n<!-- ./src/App.vue -->\r\n<template>\r\n<h1>vue根组件</h1>\r\n<p>{{count}}</p>\r\n<button @click=\"addCount\">addCount</button>\r\n</template>\r\n\r\n\r\n<script>\r\nexport default{\r\n  name:\"AppIndex\",//组件名称\r\n  data(){\r\n    return{\r\n      count:0\r\n    }\r\n  },\r\n  methods:{\r\n    addCount(){\r\n      this.count++\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n\r\n<style scoped lang=\"less\">\r\n  /* scoped属性 */\r\n        /* scoped属性表示css的作用域为局部,可以防止样式冲突 */\r\n        /* \r\n            原理是自动给所有标签添加随机属性 <h1 data-v-dwed929>vue根组件</h1>\r\n            然后利用css属性选择器:\r\n            h1[data-v-dwed929]{\r\n                color: red;\r\n            }\r\n        */\r\n  /* lang=\"less\"属性 */\r\n        /* slang=\"less\"属性表示使用的css的语言为less,默认为css */\r\n        /* (需要安装 npm install less -d) */\r\n\r\nh1{\r\n  color: red;\r\n}\r\n:deep() h1{\r\n/* h1:deep {vue3写法}  */\r\n  color: red;\r\n/* \r\n    :deep() 称为样式穿透,\r\n    style标签添加了scoped属性后,其样式无法应用于子组件,\r\n    通过样式穿透可以使得样式对子组件生效\r\n    原理是将css选择器修改为\r\n        原 h1[data-v-dwed929]{\r\n                color: red;\r\n            }\r\n        修改后\r\n            [data-v-dwed929] h1{\r\n                color: red;\r\n            }\r\n        也就是自动将交集选择器 修改为子代选择器\r\n*/\r\n}\r\n\r\n</style>\r\n```\r\n\r\n\r\n### 注册全局组件\r\n```js\r\n// ./src/main.js\r\n\r\nimport { createApp } from 'vue'\r\nimport './style.css'\r\nimport App from './App.vue'\r\nconst app = createApp(App)\r\n\r\n//1.导入待注册的组件\r\nimport demo1 from \"./components/demo1.vue\"\r\n\r\n//2.使用app.component()注册为全局组件\r\n// app.component(demo1.name,demo1)//可以直接使用组件的name属性作为注册的组件名称\r\napp.component(\"my-global-comp-demo1\",demo1)\r\n\r\n//3.在 *.vue 中 通过 <my-global-comp-demo1></my-global-comp-demo1> 的方式使用全局组件\r\n\r\n\r\napp.mount('#app')\r\n```\r\n\r\n### 注册局部组件\r\n```html\r\n<template>\r\n......\r\n<my-global-comp-demo1></my-global-comp-demo1>\r\n<!-- 3.使用注册的局部组件 -->\r\n<my-local-comp-demo2></my-local-comp-demo2>\r\n</template>\r\n\r\n\r\n\r\n<script>\r\n//1.导入待注册的组件\r\nimport demo2 from \"./components/demo2.vue\"\r\n\r\nexport default{\r\n//2.使用components属性将其注册为局部组件\r\n    components:{\r\n      \"my-local-comp-demo2\": demo2\r\n    }\r\n}\r\n</script>\r\n```\r\n\r\n**注册组件名称命名格式**\r\n```html\r\npascalCase命名法 帕斯卡命名法 驼峰命名法    \r\n    用驼峰命名法注册的组件在使用时,可以使用两种格式     (适用性强)\r\n        * <pascalCase></pascalCase>\r\n        * <pascal-case></pascal-case>\r\n\r\nkebab-case命名法 短横线命名法\r\n    用短横线命名法注册的组件在使用时,仅可以使用一种格式\r\n        * <pascal-case></pascal-case>\r\n```\r\n\r\n\r\n### 组件案例\r\n**`./src/components/msgBox.vue`**\r\n```html\r\n<template>\r\n    <div class=\"main\" :style=\"{color:color || 'white',backgroundColor:bgcolor || 'skyblue'}\">\r\n        {{msg}}\r\n    </div>\r\n</template>\r\n  \r\n<script>\r\nexport default {\r\n    data() {\r\n        return {\r\n        }\r\n    },\r\n    //props属性概念相当于函数的形式参数列表\r\n    // 此处相当于是组件的形式参数列表\r\n    props: [\"msg\", \"color\", \"bgcolor\"]\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n.main {\r\n    text-align: center;\r\n    font-size: 20px;\r\n    height: 200px;\r\n    width: 400px;\r\n    margin: 0 auto;\r\n    box-shadow: 10px 10px gray;\r\n    padding: 10px;\r\n}\r\n</style>\r\n```\r\n\r\n**`./src/app.vue`**\r\n```html\r\n<template>\r\n<msgBox :msg=\"msg\" :color=\"color\" :bgcolor=\"bgcolor\"></msgBox>\r\n</template>\r\n\r\n<script>\r\nimport msgBox from \"./components/msgBox.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      msg:\"消息XXXXXXXXXXXXX\",\r\n      // color:\"skyblue\",\r\n      // bgcolor:\"pink\"\r\n    }\r\n  },\r\n  components:{\r\n    msgBox\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n</style>\r\n```\r\n\r\n\r\n## computed属性\r\n\r\n优点:\r\n计算属性会缓存结果值,节省了计算开销,只有依赖的数据源数据值发生改变时才会重新计算计算属性的结果,\r\n\r\n```js\r\n<template>\r\n    <p>名:{{firstName}}</p>\r\n    <p>姓:{{secondName}}</p>\r\n    <p>全名:{{fullName}}</p>\r\n</template>\r\n<script>\r\n    export default{\r\n        data(){\r\n            return{\r\n                firstName:\"Yigui\",\r\n                secondName:\"Ding\",\r\n            }\r\n        },\r\n        computed:{\r\n            fullName() {\r\n                return this.firstName + this.secondName\r\n            }\r\n        }\r\n    }\r\n</script>\r\n```\r\n\r\n## 触发自定义事件\r\n\r\n\r\n```html\r\n<template>\r\n  <p>{{count}}</p>\r\n  <button @click=\"addCount\">count++</button>\r\n</template>\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  //1.注册事件\r\n  emits: [\"countChanged\"],\r\n  methods: {\r\n    addCount() {\r\n      this.count++\r\n      //2.触发事件,可选参数传递值\r\n      this.$emit(\"countChanged\",this.count)\r\n      //3.在组件外部监听该事件\r\n    },\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n    <!-- 3.在组件的根标签上监听事件(经测试,仅能在根标签上监听到) -->\r\n    <testEmits @countChanged=\"callbackA\" ></testEmits>\r\n</template>\r\n<script>\r\nimport testEmits from \"./components/testEmits.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components:{\r\n    testEmits\r\n  },\r\n  methods:{\r\n    callbackA(value){\r\n      alert('自定义事件countChanged事件触发了,接受到数据:' + value )\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n## 父子组件间数据传递-props属性\r\n* props属性概念相当于函数的形式参数列表,调用函数者可以向其中传入参数\r\n*  此处props就是是组件的形式参数列表,调用该组件时可以通过这个传入参数\r\n\r\n### props基本使用\r\n```html\r\n<template>\r\n    <!-- demo3为子组件 通过data1=\"\"属性传递值 -->\r\n    <demo3 :data1=\"title\" :this-is-data=\"context\" ></demo3>\r\n    <!-- \r\n    若thisIsData使用驼峰命名法,则此处属性名可以使用 驼峰命名法 或 短横线命名法\r\n    经测试\r\n        短横线命名法必须全小写\r\n        仅测试驼峰命名法首字母必须小写\r\n        若 props:[\"ThisIsData\"]     则可使用 ThisIsData=\"\" 或 This-Is-Data=\"\"\r\n        若 props:[\"thisIsData\"]     则可使用 this-is-data=\"\" 或 this-Is-Data=\"\"\r\n     -->\r\n</template>\r\n\r\n<script>\r\nimport demo3 from \"./components/demo3.vue\"\r\nexport default{\r\n  data(){\r\n    return{\r\n      title:\"由父组件传给子组件的标题\",\r\n      context:\"由父组件传给子组件的内容\",\r\n    }\r\n  },\r\n  components:{\r\n    demo3\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n    <h2>标题:{{data1}}</h2>\r\n    <p>内容:{{thisIsData}}</p>\r\n</template>\r\n<script>\r\n    export default{\r\n        data(){\r\n            return{\r\n            }\r\n        },\r\n        // props指定要传入的数据\r\n        props:[\"data1\",\"thisIsData\"], //此处可以使用驼峰命名法,不能使用短横线命名法\r\n    }\r\n</script>\r\n```\r\n\r\n### 数据合法性验证\r\n```js\r\n//一般写法\r\nprops:[\"data1\",\"thisIsData\"]\r\n\r\n//类型验证\r\nprops:{\r\n    //props支持8种数据类型\r\n    \"data1\": String,        //指定数据的类型,否则报错\r\n    \"data2\": Number,\r\n    \"data3\": Boolean,\r\n    \"data4\": Array,\r\n    \"data5\": Object,\r\n    \"data6\": Date,\r\n    \"data7\": Function,\r\n    \"data8\": Symbol,\r\n}\r\n\r\n\r\n//多类型验证\r\nprops:{\r\n    \"data1\": [String,Number,Array],\r\n    \"data2\": Number,\r\n}\r\n\r\n\r\n// 必填项校验\r\nprops:{\r\n    \"id\": {\r\n        type:[Number,String],\r\n        required:true                   //id为必填属性\r\n    },\r\n    \"data1\": [String,Number,Array],\r\n}\r\n\r\n//默认值\r\nprops:{\r\n    \"id\": {\r\n        type:[Number,String],\r\n        default:0                   //id默认值为default\r\n    },\r\n    \"data1\": [String,Number,Array],\r\n}\r\n\r\n//用自定义函数验证传入值的合法性\r\nprops:{\r\n    \"msgType\": {\r\n        type:String,\r\n        validator(value){//validator函数用于验证合法性,返回值为布尔值\r\n            return [\"success\",\"warning\",\"danger\"].includes(value)\r\n        }        \r\n    },\r\n    \"data1\": [String,Number,Array],\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## 父子组件间数据的双向同步\r\n\r\n### v-bind:单向绑定数据\r\n父子组件数据 --> 子组件数据\r\n```html \r\n<template>\r\n  <div>\r\n    <p>子组件的count:{{count}}</p>\r\n  <button @click=\"addCount\">count++</button>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n    }\r\n  },\r\n  props:[\"count\"],//接受参数\r\n  methods: {\r\n    addCount() {\r\n    //   this.count++ //props只读属性无法修改\r\n    },\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\ndiv{\r\n  border: 1px solid gray;\r\n  padding: 20px;\r\n}\r\n</style>\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <p>父组件的count:{{count}}</p>\r\n    <button @click=\"addCount\">count++</button>\r\n    <hr>\r\n    <!-- v-bind:count=\"count\" 传递参数 -->\r\n    <updateCount v-bind:count=\"count\"></updateCount>\r\n  </div>\r\n</template>\r\n<script>\r\nimport updateCount from \"./components/updateCount.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components: {\r\n    updateCount\r\n  },\r\n  methods: {\r\n    addCount() {\r\n      this.count++\r\n    },\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n  div{\r\n    border: 1px solid gray;\r\n    padding: 20px;\r\n  }\r\n</style>\r\n```\r\n\r\n\r\n### v-model双向绑定父子组件间数据\r\n父子组件数据 `<-->` 子组件数据\r\n```html\r\n<template>\r\n  <div>\r\n    <p>父组件的count:{{count}}</p>\r\n    <button @click=\"addCount\">count++</button>\r\n    <hr>\r\n    <!-- 3.使用 v-model 绑定数据 -->\r\n    <updateCount v-model:count=\"count\"></updateCount>\r\n  </div>\r\n</template>\r\n<script>\r\nimport updateCount from \"./components/updateCount.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components: {\r\n    updateCount\r\n  },\r\n  methods: {\r\n    addCount() {\r\n      this.count++\r\n    },\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n  div{\r\n    border: 1px solid gray;\r\n    padding: 20px;\r\n  }\r\n  </style>\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <p>子组件的count:{{count}}</p>\r\n  <button @click=\"addCount\">count++</button>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n    }\r\n  },\r\n  // 0. props接受参数\r\n  props:[\"count\"],\r\n  //1.注册事件      注意:若props的是一个`v-model:对象`,则传入的是一个`引用`,则可直接修改引用的`对象.属性名`,无需注册事件和触发事件\r\n  emits: [\"update:count\"],\r\n  methods: {\r\n    addCount() {\r\n      // this.count+=1 //无法修改,因为是只读属性\r\n      //2. 触发 update:count 事件 并传递 更新后的值\r\n      this.$emit(\"update:count\",this.count+1)\r\n\r\n\r\n      //3. 如果count是一个数组且watch的deep:false,则更新数据时不能这样写,\r\n            // this.count.push(\"测试数据\")\r\n            // this.$emit(\"update:count\",this.count)\r\n      //4. 如果count是一个数组且watch的deep:false,则更新数据时应该写:\r\n            // this.count.push(\"测试数据\")\r\n            // this.$emit(\"update:count\",[...this.count])\r\n    },\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\ndiv{\r\n  border: 1px solid gray;\r\n  padding: 20px;\r\n}\r\n</style>\r\n```\r\n\r\n\r\n## `todoList案例实现`\r\n\r\n**实现效果**\r\n\r\n![图 1](./images/vue3学习笔记/36385537577cb1b773374304f88394d27b69940b4a5bd239191222889664dab5.png)  \r\n\r\n\r\n\r\n**实现代码**  \r\n`App.vue`\r\n```html\r\n<template>\r\n  <div class=\"todolist_main\">\r\n    <todoListInput @addTask=\"addTask\"></todoListInput>\r\n    <todoListList v-bind:todoListData=\" btnStatus==1?  allTodoListData : btnStatus==2? doneTodoListData : notDoneTodoListData \"></todoListList>\r\n    <toDoListBtns v-model:btnStatus=\"btnStatus\"></toDoListBtns>\r\n  </div>\r\n</template>\r\n<script>\r\nimport todoListInput from \"./components/todoListInput.vue\"\r\nimport todoListList from \"./components/todoListList.vue\"\r\nimport toDoListBtns from \"./components/toDoListBtns.vue\"\r\nexport default {\r\n  components: {//注册子组件\r\n    todoListInput,\r\n    todoListList,\r\n    toDoListBtns\r\n  },\r\n  data() {\r\n    return {//数据\r\n      nextId: 5,//用于创建新任务\r\n      btnStatus: 1, //变化范围:[1,2,3],用于记录按钮状态\r\n      todoList: [\r\n        { id: 0, task: \"测试文字0\", done: true },\r\n        { id: 1, task: \"测试文字1\", done: true },\r\n        { id: 2, task: \"测试文字2\", done: false },\r\n        { id: 3, task: \"测试文字3\", done: true },\r\n        { id: 4, task: \"测试文字4\", done: true },\r\n      ]\r\n    }\r\n  },\r\n  methods: {\r\n    addTask(task) {\r\n      if(!task) return alert(\"任务名称不能为空......\")\r\n      this.todoList.push({\r\n          id: this.nextId++,\r\n          task: task,\r\n          done: false,\r\n      })\r\n    },\r\n  },\r\n  computed: {//计算属性\r\n    allTodoListData() {\r\n      return this.todoList\r\n    },\r\n    doneTodoListData() {\r\n      return this.todoList.filter(item => item.done)\r\n    },\r\n    notDoneTodoListData() {\r\n      return this.todoList.filter(item => !item.done)\r\n    }\r\n  }\r\n\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n.todolist_main {\r\n  margin: 10px auto;\r\n  width: 600px;\r\n}\r\n</style>\r\n```\r\n\r\n`./components/todoListInput.vue`\r\n\r\n```html\r\n<template>\r\n      <div class=\"input-group \">\r\n      <span class=\"input-group-text\" >任务</span>\r\n      <input type=\"text\" class=\"form-control\" placeholder=\"请填写任务信息\" v-model=\"taskName\">\r\n      <button class=\"btn btn-primary\" type=\"button\" @click=\"addTask\">添加新任务</button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  emits:[\"addTask\"],//注册事件\r\n  data(){\r\n    return{\r\n      taskName:\"\"\r\n    }\r\n  },\r\n  methods:{\r\n    addTask(){\r\n      this.$emit(\"addTask\",this.taskName)//触发事件,向外部传递任务名称\r\n      this.taskName=\"\"//清空任务名称\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n`./components/todoListList.vue`\r\n```html\r\n<template>\r\n  <ul class=\"list-group\">\r\n    <li v-for=\"item in todoListData\" :key=\"item.id\"\r\n      class=\"list-group-item d-flex justify-content-between align-items-center\">\r\n      <input class=\"form-check-input tick\" type=\"checkbox\" v-model=\"item.done\">\r\n      <span class=\"context\" :class=\"item.done ? 'ticked':''\" >{{item.task}}</span>\r\n      <span v-if=\"item.done\" class=\"badge bg-success rounded-pill status\">已完成</span>\r\n      <span v-else class=\"badge bg-warning rounded-pill status\">未完成</span>\r\n      <span class=\"badge bg-danger del\" @click=\"del(item.id)\">删除</span>\r\n    </li>\r\n  </ul>\r\n</template>\r\n<script>\r\nexport default {\r\n  props: {\r\n    'todoListData': {//接受待渲染的数据\r\n      type: Array,\r\n      required: true,\r\n      defult: []\r\n    }\r\n  },\r\n  methods: {\r\n    del(id) {//根据id删除数据\r\n      this.todoListData.splice(this.todoListData.filter(item => item.id == id), 1)\r\n    }\r\n  }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\nul li {\r\n  display: flex;\r\n  justify-content:flex-between;\r\n  .tick {\r\n    margin-right: 10px;\r\n  }\r\n  .context {\r\n    flex:1;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis; /* 省略号 */\r\n    &.ticked{\r\n      text-decoration: line-through green ;\r\n      font-style:italic;/* 倾斜字体 */\r\n      color: gray;\r\n    }\r\n  }\r\n  .status {\r\n    margin-left: 10px;\r\n  }\r\n  .del {\r\n    margin-left: 10px;\r\n    cursor: pointer;\r\n  }\r\n}\r\n</style>\r\n```\r\n\r\n\r\n`./components/toDoListBtns.vue`\r\n```html\r\n<template>\r\n    <div class=\"btn-group btns\" role=\"group\">\r\n        <button type=\"button\" class=\"btn\" :class=\"btnStatus==1? 'btn-primary':'btn-secondary'\" @click=\"changeBtnStatus(1)\">全部</button>\r\n        <button type=\"button\" class=\"btn\" :class=\"btnStatus==2? 'btn-primary':'btn-secondary'\" @click=\"changeBtnStatus(2)\">已完成</button>\r\n        <button type=\"button\" class=\"btn\" :class=\"btnStatus==3? 'btn-primary':'btn-secondary'\" @click=\"changeBtnStatus(3)\">未完成</button>\r\n    </div>\r\n</template>\r\n<script>\r\nexport default {\r\n    emits:[\"update:btnStatus\"],\r\n    props: {\r\n        'btnStatus': {\r\n            type: Number,\r\n            required: true,\r\n            defult: 0\r\n        }\r\n    },\r\n    methods:{\r\n        changeBtnStatus(status){\r\n            this.$emit(\"update:btnStatus\",status)//触发事件,向外传递更新被双向绑定的数据\r\n        }\r\n    }\r\n}\r\n</script>\r\n<style lang=\"less\" scoped>\r\n.btns {\r\n    width: 100%;\r\n    display: flex;\r\n    button {\r\n        flex: 1;\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n## watch监听器\r\n\r\n\r\n\r\n**语法格式**\r\n```js\r\n// 基本语法\r\nwatch:{\r\n    变量名(newValue,oldValue){\r\n\r\n    }\r\n}\r\n\r\n// immediate 选项:渲染页面完毕后便执行\r\nwatch:{\r\n    变量名:{\r\n        handler(newValue,oldValue){\r\n            //do something\r\n       },\r\n        immediate:true\r\n}\r\n\r\n// deep选项: 监听对象的属性值的变化\r\nwatch:{\r\n    对象变量名:{\r\n        handler(newValue,oldValue){\r\n            //do something\r\n       },\r\n        immediate:true,\r\n        deep:true\r\n}\r\n\r\n//监听对象中单个属性值的变化\r\nwatch:{\r\n    '对象变量名.属性名':{\r\n        handler(newValue,oldValue){\r\n            //do something\r\n       },\r\n}\r\n```\r\n\r\n**基本使用**\r\n```html\r\n<template>\r\n<input type=\"text\" v-model=\"username\">\r\n<input type=\"text\" v-model=\"email\">\r\n</template>\r\n<script>\r\n  import axios from \"axios\"\r\nexport default{\r\n  data(){\r\n    return{\r\n      username:\"DingYigui\",\r\n      email:\"\"\r\n    }\r\n  },\r\n  watch:{\r\n    async username(newValue,oldValue){//监听username变量值的修改\r\n      console.log(oldValue);\r\n      console.log(newValue);\r\n\r\n      var {data:reqBody} = await axios.get(\"https://www.domain.cn/api/finduser/\" + newValue )\r\n      console.log(reqBody);\r\n    },\r\n    email(newValue,oldValue){\r\n      console.log(newValue);\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n## 生命周期钩子函数\r\n\r\n**组件生命周期**  \r\n**在内存中创建示例对象** ---> **将实例对象渲染到页面** ---> **根据需求销毁示例对象**\r\n\r\n**生命周期函数**  \r\n最常用的是 `mounted` 、 `updated` 和 `unmounted`\r\n![图 3](./images/vue3学习笔记/4caeab7c19b84315bae6af404a5cd296332c01342b32436ff20a582f92b5fd7b.png)  \r\n\r\n**官方文档生命周期图示**\r\n![图 2](./images/vue3学习笔记/a30ce229b7e5e5454aeb56e0f7a7de0cd7a880e1df57020f5ed20bd5a8d5c5d8.png)  \r\n\r\n\r\n## 组件间数据共享\r\n**组件间关系**\r\n* 父子关系\r\n* 后代关系\r\n* 兄弟关系\r\n\r\n### 父子关系组件间数据共享\r\n**`父组件 ---> 子组件 : `**\r\n\r\n父组件通过`v-bind:`向子组件绑定待共享的数据,子组件通过`props属性`接收数据\r\n```html \r\n<template>\r\n  <div>\r\n    <p>子组件的count:{{count}}</p>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  props:[\"count\"],//接受参数\r\n}\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <button @click=\"count++\"></button>\r\n    <!-- v-bind:count=\"count\" 传递参数 -->\r\n    <subComponent v-bind:count=\"count\"></subComponent>\r\n  </div>\r\n</template>\r\n<script>\r\nimport subComponent from \"./components/subComponent.vue\"//导入子组件\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components: {\r\n    subComponent\r\n  },\r\n}\r\n</script>\r\n```\r\n\r\n**`父组件 <--- 子组件 : `**\r\n\r\n子组件通过`emits[\"事件名\"]`注册自定义事件,并通过`this.emit(\"事件名\",传递数据)`触发事件,父组件通过`v-on:事件名=\"处理函数\"`来监听事件,其中处理函数的形式参数为接收到的数据\r\n```html \r\n<template>\r\n  <div>\r\n    <button @click=\"addCount\"></button>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n    data(){\r\n        return{\r\n            count:0\r\n        }\r\n    },\r\n  emits:[\"countUpdate\"],//注册事件\r\n  methods:{\r\n    addCount(){\r\n        this.count++\r\n        this.emit(\"countUpdate\",this.count)//触发事件,向外传递数据\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n      <subComponent @countUpdate=\"getCount\"></subComponent>//监听事件,指定处理函数\r\n        <p>从子组件获取到的gettedCount:{{gettedCount}}</p>\r\n  </div>\r\n</template>\r\n<script>\r\nimport subComponent from \"./components/subComponent.vue\"//导入子组件\r\nexport default {\r\n  data() {\r\n    return {\r\n      gettedCount: 0,\r\n    }\r\n  },\r\n  components: {\r\n    subComponent\r\n  },\r\n  methods:{\r\n    getCount(value){\r\n      this.gettedCount=value\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n**`父组件 <--> 子组件 :`**  \r\n父组件通过`v-model=\"变量名\"`向子组件绑定待共享的数据,子组件通过`emits[\"update:变量名\"]`注册数据更新事件,并通过`this.emit(\"update:变量名\",传递数据)`触发事件,父组件的变量便能自动接收到更新的数据\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <p>父组件的count:{{count}}</p>\r\n    <button @click=\"addCount\">count++</button>\r\n    <hr>\r\n    <!-- 3.使用 v-model 绑定数据 -->\r\n    <subComponent v-model:count=\"count\"></subComponent>\r\n  </div>\r\n</template>\r\n<script>\r\nimport subComponent from \"./components/subComponent.vue\"\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    }\r\n  },\r\n  components: {\r\n    subComponent\r\n  },\r\n  methods: {\r\n    addCount() {\r\n      this.count++\r\n    },\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n  <div>\r\n    <p>子组件的count:{{count}}</p>\r\n  <button @click=\"addCount\">addCount</button>\r\n  </div>\r\n</template>\r\n<script>\r\nexport default {\r\n  props:[\"count\"],\r\n  emits: [\"update:count\"],\r\n  methods: {\r\n    addCount() {\r\n      this.$emit(\"update:count\",this.count+1)//触发 update:count 事件 并传递 更新后的值\r\n    },\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n### 后代关系组件间数据共享\r\n**`父组件数据 ---> 子组件数据`**  \r\n```html\r\n<template>\r\n  <p>{{count}}</p>\r\n</template>\r\n\r\n<script>\r\n\r\nexport default {\r\n    inject:[\"count\"]\r\n}\r\n</script>\r\n```\r\n\r\n```html\r\n<template>\r\n  <p>{{count}}</p>\r\n  <button @click=\"count++\">count++</button>\r\n<subTempVue></subTempVue>\r\n</template>\r\n<script>\r\n  import {computed} from \"vue\"\r\n  import subTempVue from \"./components/subTemp.vue\"\r\nexport default{\r\n  data(){\r\n    return{\r\n      count:0,\r\n    }\r\n  },\r\n  components:{\r\n    subTempVue\r\n  },\r\n  provide(){\r\n    return{\r\n    //   count:this.count,  //这种方式共享的数据 当this.cout数据更新时,子组件接收到的数据将不会更新\r\n      count:computed(()=>this.count), // 这种方式能够更新\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n### 兄弟关系组件间数据共享\r\n**`父组件数据 <---> 子组件数据`**  \r\n\r\nmitt\r\n**安装mitt**\r\n```\r\nnpm i mitt\r\n```\r\n\r\n`mittEventBus.js`\r\n```js\r\nimport mitt from \"mitt\"\r\nconst bus = mitt()\r\nexport default bus\r\n```\r\n\r\n`subTemp.vue 和 subTemp2.vue`\r\n```html\r\n<template>\r\n  <p>{{count}}</p>\r\n  <button @click=\"count++\">count++</button>\r\n</template>\r\n\r\n<script>\r\nimport bus from \"./mittEventBus\"\r\nexport default{\r\n    data(){\r\n        return{\r\n            count:0\r\n        }\r\n    },\r\n    created(){\r\n        bus.on(\"countUpdate\",(value)=>{//监听事件\r\n          this.count = value\r\n        })\r\n    },\r\n    updated(){\r\n        bus.emit(\"countUpdate\",this.count)//触发事件\r\n    },\r\n}\r\n</script>\r\n```\r\n\r\n`App.vue`\r\n```html\r\n<template>\r\n<subTempVue></subTempVue>\r\n<subTemp2Vue></subTemp2Vue>\r\n</template>\r\n<script>\r\n  import subTempVue from \"./components/subTemp.vue\"\r\n  import subTemp2Vue from \"./components/subTemp2.vue\"\r\nexport default{\r\n  components:{\r\n    subTempVue,\r\n    subTemp2Vue\r\n  },\r\n}\r\n</script>\r\n```\r\n\r\n### VueX全局数据共享\r\n\r\n\r\n#### 概念\r\nvueX 可以让组件间数据共享高效清晰易维护\r\n\r\n传统共享数据方式 和 vuex共享数据方式 区别\r\n![图 4](./images/vue3学习笔记/a8fcf1f513f66d1815212170da475dc9e1893ff300ec7584c6e063c249db48ce.png)  \r\n\r\n\r\n#### vuex原理\r\n![图 1](./images/vue3学习笔记/a0d4da5f13a6d0c8aa9d4d1cf30a63caff2acca4d44447c362de4ea0362e1b2a.png)  \r\n\r\n\r\n#### 基本使用\r\n\r\n`store/index.js`\r\n```js\r\nimport { createStore } from 'vuex'\r\n\r\nconst state =function () {//state用于存储数据,在vueX4中是一个函数,在VueX3值中是一个对象\r\n    return {\r\n      count: 0 ;\r\n    }\r\n}\r\nconst actions = {//用于响应组件中的动作\r\n  // add(miniStore,value){ //第一个参数是一个阉割版的store 可认为是miniStore 也可认为是context\r\n  add({dispatch,commit,state},value){ //\r\n    commit('ADD',value)\r\n  }\r\n}\r\nconst mutations = {//用于操作数据\r\n  ADD(state,value){\r\n    state.count += value\r\n  }\r\n}\r\n\r\nconst getters = {//非必要的属性,相当于组件的计算属性\r\n  bigCount(state){\r\n    return state.count * 5.123 \r\n  }\r\n}\r\n\r\n// 创建一个新的 store 实例\r\nconst store = createStore({\r\n  actions,\r\n  mutations,\r\n  state,\r\n  getters\r\n})\r\n\r\n// 将 store 实例作为插件安装\r\nexport default store\r\n```\r\n\r\n`main.js`\r\n```js\r\nimport { createApp } from 'vue'\r\nconst app = createApp(App)\r\n\r\napp.use(store)//注册store\r\n\r\napp.mount('#app')\r\n```\r\n\r\n\r\n**组件中操作store**\r\n`someCompoment.vue`\r\n```js\r\n//修改数据\r\nthis.$store.state.dispatch('add',15)\r\n$store.state.dispatch('add',15)\r\n$store.state.commit('ADD',15)\r\n\r\n//展示数据\r\nthis.$store.state.count\r\n$store.state.count\r\n{{this.$store.state.count}}\r\n$store.getters.bigCount\r\n```\r\n\r\n**利用 `mapState` `mapGatters` 在组件中简洁的使用数据**\r\n```js\r\nimport {mapState,mapGatters} from 'vuex'\r\n\r\ncomputed:{//组件的计算属性\r\n  // 手动写计算属性\r\n  // countA : ()=>{return this.$store.state.count}, //使用: {{countA}}\r\n\r\n  // 利用mapState自动生成计算属性\r\n  ...mapState({'countA':'count', ... }),// 等效于 countA : ()=>{return this.$store.state.count}, //使用: {{countA}}\r\n  ...mapmapState(['count', ... ]), // 等效于 count : ()=>{return this.$store.state.count}         //使用: {{count}}\r\n  \r\n  // 利用mapGatters自动生成计算属性\r\n  ...mapGatters({'bigsum':'sum', ... }),// 等效于 bigsum : ()=>{return this.$store.getters.sum}  //使用: {{bigsum}}\r\n  ...mapGatters(['sum', ... ]),// 等效于 sum : ()=>{return this.$store.getters.sum}             //使用: {{sum}}\r\n}\r\n```\r\n\r\n**利用 `mapMutations` `mapActions` 在组件中简洁的使用数据**\r\n```js\r\nimport {mapActions,mapMutationss} from 'vuex'\r\nmethods:{\r\n  //派发行为 dispatch\r\n  ...mapActions({'addCount': \"add\", ... }), //等效于  addCount(value){ this.$store.dispatch('add',value) }   //使用: @click=\"addCount(value)\"\r\n  ...mapActions([\"add\", ... ]), //等效于  add(value){ this.$store.dispatch('add',value) }                     //使用: @click=\"add(value)\"\r\n\r\n  //Mutation  直接发送commit\r\n  ...mapMutations({'ADDCount':\"ADD\", ... }), //等效于  addCount(value){ this.$store.commit('ADD',value) }    //使用: @click=\"ADDCount(value)\"\r\n  ...mapMutations(['ADD', ... ]), //等效于  ADD(value){ this.$store.commit('ADD',value) }                   //使用: @click=\"ADD(value)\"\r\n}\r\n```\r\n\r\n#### vueX的模块化\r\n\r\n`countAbout.js`子模块\r\n```js\r\nconst state =function () {\r\n    return {\r\n      count: 0 ;\r\n    }\r\n}\r\nconst actions = {\r\n  add({dispatch,commit,state},value){\r\n    commit('ADD',value)\r\n  }\r\n}\r\nconst mutations = {\r\n  ADD(state,value){\r\n    state.count += value\r\n  }\r\n}\r\nconst getters = {\r\n  bigCount(state){\r\n    return state.count * 5.123 \r\n  }\r\n}\r\n\r\nconst countAbout = { //子模块对象\r\n  namespaced:true,//启用命名空间 启用后可以使用这种格式的mapState :    `...mapState('countAbout',['count', ... ])`\r\n  state,\r\n  actions,\r\n  mutations,\r\n  getters,\r\n}\r\n\r\nexport default countAbout //导出vuex子模块\r\n```\r\n\r\n`store.js`\r\n```js\r\nimport countAbout from 'countAbout.js'\r\nimport { createStore } from 'vuex'\r\n\r\n// 创建一个新的 store 实例\r\nconst store = createStore({\r\n  modules:{\r\n    countAbout,\r\n    //其他子模块...\r\n    anotherSubStore,//另一个子store\r\n  }\r\n})\r\n\r\n// 导出store\r\nexport default store\r\n```\r\n\r\n`main.js`入口文件\r\n```js\r\nimport store from 'store.js'\r\napp.use(store)\r\n```\r\n\r\n在组件中使用 `mapState` `mapGatters` `mapMutations` `mapActions`\r\n```js\r\nimport {mapState,mapGatters,mapActions,mapMutations} from 'vuex'\r\n{\r\n  computed:{//组件的计算属性\r\n    //vueX没模块化后没有启用命名空间的原始写法:\r\n    ...mapState({'countAbout':'countAbout', ... }), // 等效于 countAbout : ()=>{return this.$store.state.countAbout}, //使用: {{countAbout.count}}\r\n    ...mapState(['countAbout', ... ]),              // 等效于 countAbout : ()=>{return this.$store.state.countAbout}, //使用: {{countAbout.count}}\r\n    ...mapState({'count':state=>state.countAbout.count, ... }), // 等效于 countAbout : ()=>{return this.$store.state.countAbout}, //使用: {{count}}\r\n\r\n    //模块化后并启用命名空间后写法:\r\n    // 利用mapState自动生成计算属性\r\n    ...mapState('countAbout',{'countA':'count', ... }), // 等效于 countA : ()=>{return this.$store.state.countAbout.count}, //使用: {{countA}}\r\n    ...mapState('countAbout',['count', ... ]),          // 等效于 count : ()=>{return this.$store.state.countAbout.count}   //使用: {{count}}\r\n    // 利用mapGatters自动生成计算属性\r\n    ...mapGatters('countAbout',{'bigsum':'sum', ... }), // 等效于 bigsum : ()=>{return this.$store.getters['countAbout/sum']}  //使用: {{bigsum}}\r\n    ...mapGatters('countAbout',['sum', ... ]),          // 等效于 sum : ()=>{return this.$store.getters['countAbout/sum']}     //使用: {{sum}}\r\n  }\r\n  methods:{\r\n    //派发行为 dispatch\r\n    ...mapActions('countAbout',{'addCount': \"add\", ... }),  //等效于  addCount(value){ this.$store.dispatch('countAbout/add',value) }   //使用: @click=\"addCount(value)\"\r\n    ...mapActions('countAbout',[\"add\", ... ]),              //等效于  add(value){ this.$store.dispatch('countAbout/add',value) }        //使用: @click=\"add(value)\"\r\n    //Mutation  直接发送commit\r\n    ...mapMutations('countAbout',{'ADDCount':\"ADD\", ... }), //等效于  addCount(value){ this.$store.commit('countAbout/ADD',value) }    //使用: @click=\"ADDCount(value)\"\r\n    ...mapMutations('countAbout',['ADD', ... ]),            //等效于  ADD(value){ this.$store.commit('countAbout/ADD',value) }         //使用: @click=\"ADD(value)\"\r\n  }\r\n}\r\n```\r\n\r\n\r\n### 总结\r\n* 父子关系组件间数据共享\r\n  * 父`--->`子 属性绑定\r\n  * 父`<---`子 事件绑定\r\n  * 父`<-->`子 v-model\r\n* 后代关系组件间数据共享\r\n  * provide & inject    (父--->后代)\r\n* 兄弟关系组件间数据共享\r\n  * mitt (EventBus)\r\n* 全局数据共享\r\n  * vuex\r\n\r\n\r\n## lodash节流防抖:throttle()\r\n```js\r\nimport {throttle} from 'lodash' //节流防抖\r\n    methods: {\r\n        ...mapActions('home',['getCategoryList']),\r\n        changeIndex:throttle(\r\n            function(index){\r\n                this.currentIndex = index;\r\n                console.log(this);\r\n            },\r\n            200,\r\n        ),\r\n        // 错误写法\r\n        // changeIndex(index){\r\n        //     throttle(\r\n        //         function(index){\r\n        //             this.currentIndex = index;\r\n        //             console.log(this);\r\n        //         },\r\n        //         200,\r\n        //     )\r\n        // },\r\n    }\r\n```\r\n\r\n\r\n## axios\r\n### 全局配置axios\r\n`./src/main.js`\r\n```js\r\nimport { createApp } from 'vue'\r\nimport axios from 'axios'\r\n\r\nimport './style.css'\r\nimport App from './App.vue'\r\n\r\n\r\naxios.defaults.baseURL=\"htts://api.com\"     //配置axios,设置baseURL,以后每次发送请求便不必写完整URL,请求只需要写 axios.get(\"/userinfo\") \r\n\r\nconst app = createApp(App)\r\napp.config.globalProperties.$http = axios //将axios挂载为app的全局自定义属性,从此每个组件的this上都可以直接访问到axios\r\n\r\napp.mount('#app')\r\n```\r\n\r\n### axios的拦截器\r\n\r\n**概念**\r\n* 请求拦截器,从axios发出给API接口服务器的请求将经过请求拦截器\r\n* 响应拦截器,从API接口服务器发回axios的响应将经过响应拦截器\r\n\r\n**请求拦截器**\r\n```js\r\n  // ......\r\naxios.interceptors.request.use(成功回调[,失败回调])\r\naxios.interceptors.response.use(成功回调[,失败回调])\r\n\r\n//示例\r\naxios.interceptors.request.use(config => {\r\n  //修改config\r\n  // ......\r\n  \r\n  //返回config\r\n  return config\r\n},error => {\r\n  return Promise.reject(error)\r\n})\r\n```\r\n\r\n\r\n**为请求头添加token认证**\r\naxios.js\r\n```js\r\nimport axios from 'axios'\r\naxios.defaults.baseURL = 'https://hostname.ltd'\r\naxios.interceptors.request.use(config => {\r\n  //修改config\r\n  config.headers.Authorization = 'Bearer XXX'  \r\n  //返回config\r\n  return config\r\n},error => {//\r\n  return Promise.reject(error)\r\n})\r\n\r\nexport default axios\r\n```\r\n\r\n**loading效果**\r\n```js\r\n// 1.按需导入\r\nimport {Loading} from 'element-ui' //vue2\r\n//声明用于存储Loading实例的变量\r\nlet LoadingInstance = null\r\n\r\naxios.interceptors.request.use(config => {\r\n  //修改config\r\n  config.headers.Authorization = 'Bearer XXX'\r\n  //创建Loading实例\r\n  LoadingInstance = Loading.service({fullscreen:true})\r\n  //返回config\r\n  return config\r\n});\r\n\r\naxios.interceptors.response.use(response => {\r\n  //关闭Loading的实例对象\r\n  LoadingInstance.close()\r\n  return response\r\n});\r\nexport default axios\r\n```\r\n\r\n\r\n\r\n\r\n###  axios配置nprogress进度条\r\n```js\r\nimport axios from 'axios'\r\n\r\nimport nprogress from 'nprogress'//进度条\r\nimport 'nprogress/nprogress.css'//加载的进度条样式\r\n\r\n// axios.defaults.baseURL = ''\r\nlet http = axios.create({\r\n    baseURL: ' http://????/api',\r\n    timeout: 5000,//5s为超时\r\n    //配置 ... \r\n})\r\n\r\n//请求拦截器\r\nhttp.interceptors.request.use((config) => {\r\n    // config.headers\r\n    //进度条开始\r\n    nprogress.start()\r\n\r\n    return config\r\n})\r\n//响应拦截器\r\nhttp.interceptors.response.use(\r\n    (response) => {\r\n        //进度条结束\r\n        nprogress.done()\r\n        return response\r\n    },\r\n    (err) => {\r\n        return Promise.reject(new Error('faile'))\r\n    }\r\n)\r\n\r\nexport default http\r\n```\r\n\r\n\r\n## `购物车案例实现`\r\n实现效果\r\n![图 5](./images/vue3学习笔记/2fbb08b7c47acdb960512432c3bdf516796121e7cb6e05b61525a1239647624b.png)  \r\n\r\n\r\n代码\r\n\r\n`main.js`\r\n```js\r\nimport { createApp } from 'vue'\r\nimport axios from 'axios'\r\nimport 'bootstrap'\r\nimport './style.css'\r\nimport App from './App.vue'\r\n\r\naxios.defaults.baseURL='https://escook.cn' //配置axios\r\nlet app = createApp(App)\r\napp.config.globalProperties.$http=axios //在this上全局挂载axios\r\n\r\napp.mount('#app')\r\n```\r\n\r\n`App.vue`\r\n```html\r\n<template>\r\n\r\n  <esHeaderVue \r\n  headerName=\"购物车\" \r\n  :height=\"40+'px'\"\r\n  ></esHeaderVue>\r\n\r\n  <esOrderListVue\r\n  :orderList=\"orderList\" \r\n  :paddingTop=\"40+'px'\" \r\n  :paddingBottom=\"60+'px'\"\r\n  ></esOrderListVue>\r\n\r\n  <esFooterVue \r\n  :height=\"60+'px'\" \r\n  @checkboxChanged=\"changeAllBeSelecttedStatus\"\r\n  :allIsSelectted=\"allIsSelectted\"\r\n  :totalPrice=\"totalPrice\" \r\n  :countSelectted=\"countSelectted\"\r\n  ></esFooterVue>\r\n\r\n</template>\r\n<script>\r\nimport esHeaderVue from './components/esHeader.vue';\r\nimport esOrderListVue from './components/esOrderList.vue';\r\nimport esFooterVue from './components/esFooter.vue'\r\nexport default\r\n  {\r\n    components:\r\n    {\r\n      esHeaderVue,\r\n      esOrderListVue,\r\n      esFooterVue\r\n    },\r\n    data() {\r\n      return {\r\n        orderList: \r\n        [\r\n          //测试数据\r\n          { \"id\": 1, \"goods_name\": \"班俏BANQIAO超火ins潮卫衣女士2020秋季新款韩版宽松慵懒风薄款外套带帽上衣\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/1.png\", \"goods_price\": 108, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 2, \"goods_name\": \"嘉叶希连帽卫衣女春秋薄款2020新款宽松bf韩版字母印花中长款外套ins潮\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/2.png\", \"goods_price\": 129, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 3, \"goods_name\": \"思蜜怡2020休闲运动套装女春秋季新款时尚大码宽松长袖卫衣两件套\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/3.png\", \"goods_price\": 198, \"goods_count\": 1, \"goods_state\": false },\r\n          { \"id\": 4, \"goods_name\": \"思蜜怡卫衣女加绒加厚2020秋冬装新款韩版宽松上衣连帽中长款外套\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/4.png\", \"goods_price\": 99, \"goods_count\": 1, \"goods_state\": false },\r\n          { \"id\": 5, \"goods_name\": \"幂凝早秋季卫衣女春秋装韩版宽松中长款假两件上衣薄款ins盐系外套潮\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/5.png\", \"goods_price\": 156, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 6, \"goods_name\": \"ME&CITY女装冬季新款针织抽绳休闲连帽卫衣女\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/6.png\", \"goods_price\": 142.8, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 7, \"goods_name\": \"幂凝假两件女士卫衣秋冬女装2020年新款韩版宽松春秋季薄款ins潮外套\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/7.png\", \"goods_price\": 219, \"goods_count\": 2, \"goods_state\": true },\r\n          { \"id\": 8, \"goods_name\": \"依魅人2020休闲运动衣套装女秋季新款秋季韩版宽松卫衣 时尚两件套\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/8.png\", \"goods_price\": 178, \"goods_count\": 1, \"goods_state\": true },\r\n          { \"id\": 9, \"goods_name\": \"芷臻(zhizhen)加厚卫衣2020春秋季女长袖韩版宽松短款加绒春秋装连帽开衫外套冬\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/9.png\", \"goods_price\": 128, \"goods_count\": 1, \"goods_state\": false },\r\n          { \"id\": 10, \"goods_name\": \"Semir森马卫衣女冬装2019新款可爱甜美大撞色小清新连帽薄绒女士套头衫\", \"goods_img\": \"https://www.escook.cn/vuebase/pics/10.png\", \"goods_price\": 153, \"goods_count\": 1, \"goods_state\": false }\r\n        ]\r\n      }\r\n    },\r\n    created() {//created生命周期函数,创建完毕后便调用\r\n      this.getOrderList()\r\n    },\r\n    computed: {\r\n        selectted(){//筛选出选中的项\r\n            return this.orderList.filter(item => item.goods_state)\r\n        },\r\n        totalPrice() {//计算总价\r\n            let totalPrice = 0\r\n            this.selectted.forEach(element => {\r\n                totalPrice += element.goods_price * element.goods_count\r\n            });\r\n            return totalPrice.toFixed(2);//保留两位小数\r\n        },\r\n        countSelectted(){//选中商品数\r\n            return this.selectted.length\r\n        },\r\n        allIsSelectted(){//计算是否全部被选中\r\n            for (let index = 0; index < this.orderList.length; index++) {\r\n                const element = this.orderList[index];\r\n                if(!element.goods_state)\r\n                    return false\r\n                else\r\n                    continue\r\n            }\r\n            return true\r\n        },\r\n    },\r\n    methods:{\r\n      async getOrderList() {//获取订单列表\r\n        let { data: reqBody } = await this.$http.get(\"/api/cart\")\r\n        // this.orderList = reqBody.list\r\n      },\r\n        changeAllBeSelecttedStatus(){//选中全部 或 全部取消选中\r\n            let nowStates = this.allIsSelectted\r\n            this.orderList.forEach(element=>{\r\n                element.goods_state= !nowStates\r\n            })\r\n        }\r\n    }\r\n  }\r\n</script>\r\n<style scoped>\r\n\r\n</style>\r\n```\r\n\r\n`esHeader.vue`\r\n```html\r\n<template>\r\n  <div class=\"esHeaderBox\" :style=\"{'color':color,'background-color': bgcolor,'height':height}\">\r\n  {{headerName}}\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    props:{\r\n        'headerName':{\r\n            type:String,\r\n            required:true,\r\n            default:\"默认标题\",\r\n        },\r\n        'color':{\r\n            type:String,\r\n            default:\"white\",\r\n        },\r\n        'bgcolor':{\r\n            type:String,\r\n            default:\"#0d6efd\",\r\n        },\r\n        'height':{\r\n            type:String,\r\n            default:\"40px\"\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n    .esHeaderBox{\r\n        height: 40px;\r\n        width: 100%;\r\n        display: flex;\r\n        justify-content: center;/*左右居中*/\r\n        align-items: center;/*上下居中*/\r\n        position: fixed;\r\n        top: 0;\r\n        left: 0;\r\n        z-index: 9999;\r\n    }\r\n</style>\r\n```\r\n\r\n`esOrderList.vue`\r\n```html\r\n<template>\r\n    <div class=\"orderListBox\" :style=\"{'padding-top': paddingTop,'padding-bottom': paddingBottom}\">\r\n        <ul>\r\n            <li v-for=\"item in orderList\" :key=\"item.id\">\r\n                <div class=\"form-check checkbox\">\r\n                    <input class=\"form-check-input\" type=\"checkbox\" v-model=\"item.goods_state\">\r\n                </div>\r\n                <img :src=\"item.goods_img\" alt=\"\">\r\n                <div class=\"orderInfo\">\r\n                    <div class=\"goods_name\">{{item.goods_name}}</div>\r\n                    <div class=\"goods_price_info\">\r\n                        <span class=\"goods_price\">¥{{item.goods_price}}</span>\r\n                        <esCounterVue v-model:count=\"item.goods_count\" :min=\"1\"></esCounterVue>\r\n                    </div>\r\n                </div>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport esCounterVue from './esCounter.vue';\r\nexport default {\r\n    props: {\r\n        orderList: {\r\n            type: Array,\r\n            require: true,\r\n        },\r\n        paddingTop:{\r\n            type:String,\r\n            default:\"40px\"\r\n        },\r\n        paddingBottom:{\r\n            type:String,\r\n            default:\"40px\"\r\n        },\r\n    },\r\n    components: {\r\n        esCounterVue\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.orderListBox {\r\n    ul,\r\n    li {\r\n        list-style: none;\r\n        padding: 0;\r\n        margin: 0;\r\n    }\r\n\r\n    li {\r\n        display: flex;\r\n        padding: 10px;\r\n        border-bottom: 1px solid rgb(240, 240, 240);\r\n\r\n        .checkbox {\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            /*左右居中*/\r\n            width: 40px;\r\n\r\n            input {\r\n                border-radius: 50%;\r\n            }\r\n        }\r\n\r\n        img {\r\n            height: 100px;\r\n            width: 100px;\r\n        }\r\n\r\n        .orderInfo {\r\n            flex: 1;\r\n            display: flex;\r\n            flex-direction: column;\r\n            justify-content: space-between;\r\n            margin-left: 10px;\r\n\r\n            .goods_price_info {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                /*上下居中*/\r\n                align-items: center;\r\n                .goods_price {\r\n                    color: red;\r\n                    font-weight: bold;\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n</style>\r\n```\r\n\r\n\r\n`esCounter.vue`\r\n```html\r\n<template>\r\n    <div class=\"counterBox\">\r\n        <button class=\"btn\" @click=\"myCount--\">-</button>\r\n        <!-- @keyup.enter=\"event=>event.target.value=myCount\"表示当enter键抬起事件发生后重新更新input的value,否则当在结合[ v-model.lazy]使用时不会自动更新,显示错误值 -->\r\n        <!-- <input class=\"\" type=\"text\" v-model.lazy=\"myCount\" @keyup.enter=\"event=>event.target.value=myCount\"> -->\r\n        <!-- 下面一行代码完美解决了上述问题 -->\r\n        <input class=\"\" type=\"text\" :value=\"myCount\" @focusout=\"myCount = $event.target.value\">\r\n        <button class=\"btn\" @click=\"myCount++\">+</button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    props: {\r\n        count:{\r\n            type:Number,\r\n            require: true\r\n        },\r\n        min:{\r\n            type:Number,\r\n            default: NaN //默认值表示不进行最小值检查\r\n        }\r\n    },\r\n    emits: [\"update:count\"],\r\n    data(){\r\n        return{\r\n            //本地数据 myCount\r\n            myCount:this.count\r\n        }\r\n    },\r\n    methods: {\r\n        setCount(newValue){//设置外部数据 count\r\n            this.$emit(\"update:count\",newValue)\r\n        }\r\n    },\r\n    watch:{\r\n        // 监听 外部数据 count 的改变 和本地数据 myCount 的改变 \r\n        // 使得 myCount ----> `myCount++ 或 myCount-- 或 从input标签输入myCount` ---->  数据合法性检测 ----> count\r\n        // 使得 myCount <------------------------------------------------------------------------------ count\r\n        \r\n        count(newVal){//监听 外部数据 count 的改变,然使其更新到myCount\r\n            this.myCount = newVal\r\n        },\r\n        myCount(newVal,oldVal){//监听 本地数据 myCount 的改变,然使其更新到 外部数据 count\r\n            newVal = parseInt(newVal)\r\n            oldVal = parseInt(oldVal)\r\n            if(typeof newVal == 'number' &&  (this.min == NaN ||  newVal >= this.min) )//判断是否合法\r\n            {\r\n                this.setCount(newVal) //数据合法,则向外部更新新值\r\n            }\r\n            else{\r\n                this.myCount=oldVal //保持原值\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.counterBox {\r\n    display: flex;\r\n    // 水平\r\n    justify-content: space-between;\r\n    // 垂直居中\r\n    align-items: center;\r\n    button{\r\n        // height: 1em;\r\n        padding-top: 0;\r\n        padding-bottom: 0;\r\n    }\r\n    input,p{\r\n        max-width: 3em;\r\n        text-align: center;\r\n        padding: 0 10px;\r\n        border: 1px solid rgb(220, 220, 220);\r\n        border-radius: 5px;\r\n        font-size: smaller;\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n`esFooter.vue`\r\n```html\r\n<template>\r\n    <div class=\"esFooterBox\" :style=\"{'height':height}\">\r\n        <div class=\"form-check\">\r\n            <input class=\"form-check-input\" type=\"checkbox\" :checked=\"allIsSelectted\" @change=\"checkboxChanged\" id=\"esFooterBox_selecttedAll\">\r\n            <label class=\"form-check-label\" for=\"esFooterBox_selecttedAll\">全选</label>\r\n        </div>\r\n        <div class=\"totalPrice\">\r\n            合计: <span>¥{{totalPrice}}</span> \r\n        </div>\r\n        <button class=\"btn btn-primary checkOut\">\r\n            结算:({{countSelectted}})\r\n        </button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    emits: [\"checkboxChanged\"],\r\n    props: {\r\n        'height': {\r\n            type: String,\r\n            default: \"60px\"\r\n        },\r\n        'allIsSelectted':{\r\n            type:Boolean,\r\n            require:true\r\n        },\r\n        'totalPrice':{\r\n            type:[Number,String],\r\n            require:true\r\n        },\r\n        'countSelectted':{\r\n            type:Number,\r\n            require:true\r\n        }\r\n    },\r\n    methods:{\r\n        checkboxChanged(){\r\n            this.$emit('checkboxChanged')\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.esFooterBox {\r\n    display: flex;\r\n    justify-content:space-between;/*左右居中*/\r\n    align-items: center;/*上下居中*/\r\n    position: fixed;\r\n    bottom: 0;\r\n    left: 0;\r\n    z-index: 9999;\r\n    width: 100%;\r\n    padding:0 10px;\r\n    background-color: white;\r\n    .totalPrice{\r\n        span{\r\n            color: red;\r\n        }\r\n    }\r\n    .checkOut{\r\n        padding: 10px 20px;\r\n        border-radius:99999px;\r\n    }\r\n}\r\n</style>\r\n```\r\n\r\n## DOM的引用---ref属性\r\n\r\n```html\r\n<template>\r\n  <!-- 使用ref为 `html元素` 的DOM设置引用名称 -->\r\n  <p ref=\"refName1\">test</p>\r\n\r\n  <!-- 使用ref为 `组件` 的DOM设置引用名称 -->\r\n  <myComponents ref=\"refName2\"></myComponents>\r\n</template>\r\n\r\n<script>\r\n  export default{\r\n\r\n    mounted(){\r\n      //根据 `ref引用名称` 输出 `html元素` 的DOM实例\r\n      console.log(this.$refs.refName1);\r\n\r\n      //根据 `ref引用名称` 输出 `组件` 的DOM实例\r\n      console.log(this.$refs.refName2);\r\n\r\n      //根据 `ref引用名称` 访问 `组件` 上的数据和方法\r\n      console.log(this.$refs.refName2.数据或方法名);\r\n    },\r\n  }\r\n</script>\r\n```\r\n\r\n## DOM更新时机及nextTick()\r\n`DOM 的更新并不是同步的  更改响应式状态时 Vue 将它们缓存在一个队列中，直到下一个“tick”才一起执行。`\r\n```html\r\n<template>\r\n  <input v-if=\"inputVisible\" type=\"text\" ref=\"inputRef\" >\r\n  <button @click=\"changeInputVisible\">显示/隐藏输入框</button>\r\n</template>\r\n\r\n<script>\r\n  export default{\r\n    data(){\r\n      return{\r\n        inputVisible:false\r\n      }\r\n    },\r\n    methods:{\r\n      changeInputVisible(){\r\n        this.inputVisible=!this.inputVisible //切换输入框可见性\r\n        if(this.inputVisible){  //如果切换为可见\r\n          //当切换输入框可见性后,输入框还未更新DOM,所以 `<input>` 元素并不存在,所以以下代码将因无法获取到DOM对象而报错\r\n          this.$refs.inputRef.focus()  //获取输入框焦点\r\n        }\r\n      }\r\n    }\r\n  }\r\n</script>\r\n```\r\n\r\n`nextTick()`\r\n```html\r\n<template>\r\n  <input v-if=\"inputVisible\" type=\"text\" ref=\"inputRef\" >\r\n  <button @click=\"changeInputVisible\">显示/隐藏输入框</button>\r\n</template>\r\n\r\n<script>\r\nimport { nextTick } from '@vue/runtime-core'\r\n  export default{\r\n    data(){\r\n      return{\r\n        inputVisible:false\r\n      }\r\n    },\r\n    methods:{\r\n      changeInputVisible(){\r\n        this.inputVisible=!this.inputVisible //切换输入框可见性\r\n        if(this.inputVisible){  //如果切换为可见\r\n          //等待一个状态改变后的 DOM 更新完成\r\n          nextTick(()=>{\r\n            this.$refs.inputRef.focus()  //获取输入框焦点\r\n          })\r\n        }\r\n      }\r\n    }\r\n  }\r\n</script>\r\n```\r\n\r\n## 动态组件component\r\n**动态组件**\r\n* 动态组件用于动态切换组件的显示和隐藏\r\n* `<component>`是组件占位符\r\n* 通过`is`属性动态指定要渲染的组件名称`<component is=\"组件名称\"></component>`\r\n* `<keep-alive>`标签作用是切换动态组件时保持组件的状态,使得其内容变量不会被销毁\r\n\r\n**基本使用**\r\n```html\r\n<template>\r\n  <!-- component绑定字符串变量`comNameVal` -->\r\n  <component :is=\"comNameVal\"></component>\r\n  <!-- button切换遍历`comNameVal`的值 -->\r\n  <button @click=\"comNameVal='ComponentA'\">显示ComponentA</button>\r\n  <button @click=\"comNameVal='ComponentB'\">显示ComponentB</button>\r\n</template>\r\n\r\n<script>\r\n  //导入子组件\r\n  import ComponentA from './components/componentA.vue'\r\n  import ComponentB from './components/componentB.vue'\r\n  export default{\r\n    components:{\r\n      //注册子组件\r\n      ComponentA,\r\n      ComponentB\r\n    },\r\n    data(){\r\n      return{\r\n        //定义变量数据\r\n        comNameVal:'ComponentA'\r\n      }\r\n    },\r\n    methods:{\r\n    }\r\n  }\r\n</script>\r\n```\r\n\r\n`<keep-alive>`标签作用是切换动态组件时保持组件的状态,使得其内容变量不会被销毁\r\n```html\r\n  <keep-alive>\r\n    <component :is=\"comNameVal\"></component>\r\n  </keep-alive>\r\n```\r\n\r\n## 插槽Slot\r\n**基本写法:插入到默认插槽**\r\n```html\r\n<!-- 子组件 -->\r\n<template>\r\n  <p>组件的第一个标签</p>\r\n  <!-- slot预留占位标签 -->\r\n  <slot>\r\n    这里是后备(默认)内容(可以不填后备内容),当父组件未提供任何内容则显示后备内容\r\n  </slot>\r\n  <p>组件的最后一个标签</p>\r\n</template>\r\n\r\n\r\n<!-- -------------------------------------------------------- -->\r\n<!-- 父组件 -->\r\n<template>\r\n  <!-- 引入子组件 -->\r\n  <subComponent>\r\n    <p>该标签会插入到子组件subComponent的slot标签处</p>\r\n  </subComponent>\r\n</template>\r\n```\r\n\r\n**具名插槽:分别插入到不同的插槽**\r\n```html\r\n<!-- 子组件 -->\r\n<template>\r\n  <header>\r\n    <slot name='header'></slot>\r\n  </header>\r\n  <main>\r\n    <!-- \r\n      <slot name='default'></slot>\r\n      name='default'可以省略\r\n    -->\r\n    <slot></slot>\r\n  </main>\r\n  \r\n  <footer>\r\n      <slot name='footer'></slot>\r\n  </footer>\r\n</template>\r\n\r\n\r\n<!-- -------------------------------------------------------- -->\r\n<!-- 父组件 -->\r\n<template>\r\n  <!-- 引入子组件 -->\r\n  <subComponent>\r\n    <template v-slot:header>\r\n      <h1>滕王阁序</h1>\r\n    </template>\r\n    <template v-slot:default><!-- 该标签内容将插入到默认插槽 所以该标签 可省略 -->\r\n      <p>滕王高阁临江渚，佩玉鸣鸾罢歌舞。</p>\r\n      <p>画栋朝飞南浦云，珠帘暮卷西山雨。</p>\r\n      <p>闲云潭影日悠悠，物换星移几度秋。</p>\r\n      <p>阁中帝子今何在？槛外长江空自流。</p>\r\n    </template>\r\n    <template v-slot:footer><!-- #footer为v-slot:footer的简写 -->\r\n      <p>落款：王勃</p>\r\n    </template>\r\n  </subComponent>\r\n</template>\r\n```\r\n\r\n**作用域插槽**\r\n```html\r\n<!-- 子组件 -->\r\n<template>\r\n  <h2>这是一个子组件</h2>\r\n  <slot :msgA='msg1' :msgB='msg2' >\r\n  //作用：以何种方式渲染数据，交给父组件处理，所以通过插槽的方式向外部提供一个插入位置和数据\r\n  </slot>\r\n</template>\r\n<script>\r\n  export default{\r\n    data(){\r\n      return{\r\n        msg1:\"内容1\"\r\n        msg2:\"内容2\"\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n\r\n<!-- -------------------------------------------------------- -->\r\n<!-- 父组件 -->\r\n<template>\r\n  <h1>这是一个父组件</h1>\r\n  <subComponent v-slot:default=\"gettedData\"><!-- gettedData是变量名，可以任意 -->\r\n    <p>这是接收到的子组件绑定给插槽的数据msgA: {{gettedData.msgA}}</p>\r\n    <p>这是接收到的子组件绑定给插槽的数据msgB: {{gettedData.msgB}}</p>\r\n  </subComponent>\r\n\r\n  <subComponent v-slot:default=\"{msgA:msgA,msgB:msgB}\"><!-- 由于获取到的数据是一个对象，所以可以解构赋值为{msgA:msgA,msgB:msgB} 或 {msgA,msgB} -->\r\n    <p>这是接收到的子组件绑定给插槽的数据msgA: {{msgA}}</p>\r\n    <p>这是接收到的子组件绑定给插槽的数据msgB: {{msgB}}</p>\r\n  </subComponent>\r\n</template>\r\n```\r\n\r\n## 自定义的指令Directives\r\n\r\n**局部自定义指令**\r\n```html\r\n<template>\r\n<input v-focus />\r\n</template>\r\n\r\n<script>\r\n  const focus = {\r\n    \r\n}\r\n\r\nexport default {\r\n  directives: {\r\n    // 在模板中启用 v-focus\r\n    focus:{\r\n      mounted: (el) => el.focus(),//vue2中函数名为bind\r\n      updated: (el) => el.focus()//vue2中函数名为update\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n**全局自定义指令**\r\n`main.js`\r\n```js\r\nconst app = createApp({})\r\n\r\n// 使 v-focus 在所有组件中都可用\r\napp.directive('focus', {\r\n    mounted: (el) => el.focus(),//vue2中函数名为bind\r\n    updated: (el) => el.focus()//vue2中函数名为update\r\n}\r\n\r\n\r\n)\r\n\r\n// 上述mounted updated 函数内容一致 可以简写为\r\napp.directive('focus',(element)=>{\r\n      el.focus()\r\n}\r\n\r\n\r\n```\r\n\r\n**值令钩子**\r\n```js\r\nexport default {\r\n  directives: {\r\n    // 在模板中启用 v-focus\r\n    focus:{\r\n        // 在绑定元素的 attribute 前 或 事件监听器应用前调用\r\n        created(element, binding, vnode, prevVnode) {},\r\n        // 在元素被插入到 DOM 前调用\r\n        beforeMount(el, binding, vnode, prevVnode) {},\r\n        // 在绑定元素的父组件\r\n        // 及他自己的所有子节点都挂载完成后调用\r\n        mounted(el, binding, vnode, prevVnode) {},\r\n        // 绑定元素的父组件更新前调用\r\n        beforeUpdate(el, binding, vnode, prevVnode) {},\r\n        // 在绑定元素的父组件\r\n        // 及他自己的所有子节点都更新后调用\r\n        updated(el, binding, vnode, prevVnode) {},\r\n        // 绑定元素的父组件卸载前调用\r\n        beforeUnmount(el, binding, vnode, prevVnode) {},\r\n        // 绑定元素的父组件卸载后调用\r\n        unmounted(el, binding, vnode, prevVnode) {}\r\n    }\r\n  }\r\n}\r\n\r\n```\r\n\r\n**值令钩子形式参数**\r\n```js\r\ncreated(element, binding, vnode, prevVnode) {\r\n  // element :DOM元素\r\n  // binding :\r\n              // 若:\r\n              // let 变量名valueName = 123\r\n              // v-focus.修饰符AAA=\"变量名valueName\"\r\n              // 或:\r\n              // v-focus.修饰符AAA:变量名valueName=\"123\"\r\n              //\r\n              // 则:\r\n              // binding的值为:{\r\n              //      arg: '变量名valueName',\r\n              //      value: 变量名valueName的值 123,\r\n              //      oldValue: 上一次`变量名valueName`的值\r\n              //      modifiers: { 修饰符AAA: true },\r\n              // }\r\n}\r\n```\r\n\r\n\r\n## 表格案例实现\r\n\r\n**效果**\r\n\r\n![图 1](./images/vue3学习笔记/5696dd27a68603dec0e7b9ae8e216706db68895d151ddb8f35556d54f1d6796c.png)  \r\n\r\n**代码**\r\n`main.js`\r\n```js\r\nimport { createApp } from 'vue'\r\nimport './style.css'\r\n\r\nimport './assets/bootstrap5.css'\r\n\r\nimport App from './App.vue'\r\ncreateApp(App).mount('#app')\r\n```\r\n\r\n`App.vue`\r\n```html\r\n<template>\r\n  <myTable :data=\"goodsList\">\r\n    <template v-slot:header>\r\n      <td>序号</td>\r\n      <td>商品名称</td>\r\n      <td>价格</td>\r\n      <td>标签</td>\r\n      <td>操作</td>\r\n    </template>\r\n    <template v-slot:item=\"{row}\">\r\n      <td>{{row.id}}</td>\r\n      <td>{{row.name}}</td>\r\n      <td>{{row.price}}</td>\r\n      <td>\r\n        <span\r\n        v-for=\"tag in row.tags\" :key=\"tag\" \r\n        class=\"badge bg-warning text-dark\" \r\n        style=\"margin:0 5px;cursor: pointer;\"\r\n        @click=\"row.tags.splice(row.tags.findIndex(item => item == tag),1)\"\r\n        >{{tag}}</span>\r\n\r\n        <input\r\n        type=\"text\" \r\n        class=\"form-control\"\r\n        style=\"display: inline;width: 100px; float: right;\"\r\n        v-if=\"row.inputVisible\" \r\n        v-model.trim=\"row.inputValue\" \r\n        @blur=\"addTag(row),row.inputValue=''\"\r\n        @keyup.enter=\"addTag(row),row.inputValue=''\"\r\n        @keyup.esc=\"row.inputValue=''\"\r\n        v-focus\r\n        >\r\n\r\n        <button \r\n        v-if=\"!row.inputVisible\" \r\n        type=\"button\"\r\n        class=\"btn btn-primary\" \r\n        style=\"padding:2px auto;float: right;\" \r\n        @click=\"row.inputVisible = true\"\r\n        >+Tag\r\n      </button>\r\n\r\n      </td>\r\n      <td>\r\n        <button type=\"button\"  class=\"btn btn-danger\">删除</button>\r\n      </td>\r\n    </template>\r\n  </myTable>\r\n</template>\r\n\r\n\r\n<script>\r\n  import myTable from './components/myTable.vue'\r\n  export default {\r\n    components: {\r\n      myTable\r\n    },\r\n    data() {\r\n      return {\r\n        goodsList: [\r\n          { id: 1, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 2, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 3, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 4, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 5, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n          { id: 6, name: \"test test test test test test test\", price: 100, inputVisible:false, tags: ['tag1', 'tag2'] },\r\n        ]\r\n      }\r\n    },\r\n    methods:{\r\n      addTag(row){\r\n        let value =  row.inputValue//获取文本框内容\r\n        row.inputVisible = false//隐藏文本框\r\n        if(value || !row.tags.includes(value)){//判断是否为空 是否已经存在标签\r\n          row.tags.push(value)//添加标签\r\n        }\r\n      },\r\n\r\n    },\r\n    directives:{\r\n        focus:{\r\n          mounted(el){\r\n            console.log(el);\r\n            el.focus()\r\n          }\r\n        }\r\n      }\r\n  }\r\n</script>\r\n<style scoped>\r\n\r\n</style>\r\n```\r\n\r\n`myTable.vue`\r\n```html\r\n<template>\r\n  <table class=\"table table-striped table-bordered\">\r\n    <thead>\r\n        <tr>\r\n            <slot name=\"header\">\r\n            </slot>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr v-for=\"item in data\" :key=\"item.id\">\r\n                <slot name=\"item\" :row=\"item\">\r\n                </slot>\r\n        </tr>\r\n    </tbody>\r\n  </table>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    props:{\r\n        data:{\r\n            type:Array,\r\n            require:true,\r\n            default:[]\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style>\r\n\r\n</style>\r\n```\r\n\r\n\r\n## 路由\r\n\r\n### 路由原理\r\n```html\r\n<template>\r\n  <a href=\"#/home\"></a>\r\n  <a href=\"#/about\"></a>\r\n  <component :is=\"comNameVal\"></component>\r\n</template>\r\n<script>\r\n  import homeVue from \"./component/home.vue\"\r\n  import aboutVue from \"./component/about.vue\"\r\n  export default{\r\n    components:{\r\n      homeVue,\r\n      aboutVue,\r\n    },\r\n    data(){\r\n      return{\r\n        comNameVal:'homeVue'\r\n      }\r\n    },\r\n    created(){\r\n      //监听url中hash改变的事件 \r\n      window.onhashchange = ()=>{//回调函数\r\n        switch(window.location.hash){\r\n          case `#/home`:\r\n            this.comNameVal = 'homeVue'\r\n            break;\r\n          case `#/about`:\r\n            this.comNameVal = 'aboutVue'\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n```\r\n\r\n### 基本使用:声明式导航\r\n**声明式导航概念**\r\n* 点击`<a>`标签\r\n* 点击`<<router-link>`标签\r\n\r\n`安装`\r\n```bash\r\n# 安装\r\n# vue2 只能使用vue-router 3\r\n# vue3 只能使用vue-router 4\r\nnpm install vue-router@4 \r\n```\r\n\r\n`router.js`\r\n```js\r\nimport homeVue from \"./component/home.vue\"\r\nimport movieVue from \"./component/movie.vue\"\r\nimport aboutVue from \"./component/about.vue\"\r\nimport {createRouter,createWebHashHistory} from 'vue-router'\r\nconst router = createRouter({//创建路由实例\r\n    history:createWebHashHistory(),//指定路由工作模式\r\n    linkActiveClass:'actived_by_Router',//指定被点击后的链接会被添加上类名,默认为`router-link-active`\r\n    routes:[//指定路由规则\r\n        {path:'/',redirect:'/home'},//重定向路由\r\n        {path:'/home',component:homeVue},\r\n        {\r\n          path: '/search/:someSearchKeywords?',//?表示someSearchKeywords可以传递也可不传递,当不加?且不传递someSearchKeywords参数时,url中的`/search/`路径会没有,这会导致路由错误\r\n          name:'search',  // this.$router.push({ name:'search',query:{categoryid,categoryleve,categoryname}})\r\n          component: Search,\r\n          meta:{showFooter:true}//如此组件中便可以使用该变量: `<Footer v-if=\"$route.meta.showFooter\"></Footer>`\r\n        },\r\n        {\r\n            path:'/movie/:movieId',//`:movieId`是动态路由,使得组件中能通过`{{$route.params.movieId}}`访问属性值\r\n            component:() => import '\"./component/movie.vue\"' , //路由懒加载\r\n            name:'mov',//可以给路由命名,但不能重复\r\n            props:true,//使得组件中可以通过:`props:[movieId]` `{{movieId}}` 获取属性值\r\n        },\r\n        {path:'/about',component:aboutVue,redirect:'/about/tab1',children:[//嵌套路由\r\n            {path:'tab1',component:tab1Vue},\r\n            {path:'tab2',component:tab2Vue},\r\n        ]},\r\n    ]\r\n})\r\nexport default router//导出实例对象\r\n```\r\n\r\n`main.js`\r\n```js\r\nimport App from './App.vue'\r\nconst app = createApp(App)\r\nimport router from \"./router.js\";\r\napp.use(router)\r\napp.mount('#app')\r\n```\r\n\r\n`App.vue`\r\n```html\r\n<template>\r\n  <router-link to='/home' >主页<router-link>\r\n  <router-link to='/movie' >电影<router-link>\r\n  <router-link to='/movie/123' >电影<router-link>\r\n  <router-link :to=\"{name:'mov',params:{id:123}}\" >电影<router-link>\r\n  <router-link to='/about' >关于<router-link>\r\n\r\n  <router-view></router-view>\r\n</template>\r\n\r\n<script>\r\n  export default{\r\n  }\r\n</script>\r\n```\r\n\r\n### 基本使用:编程式导航\r\n**编程式导航概念**\r\n* 修改`window.location.herf`使之跳转页面\r\n* 调用vueAPI\r\n\r\n```html\r\n<button @click=\"$router.push('/home')\">首页</button>\r\n<button @click=\"$router.push({name:'mov',params:{id:123}})\">首页</button>\r\n<button @click=\"$router.go(-1)\">返回</button>\r\n```\r\n\r\n\r\n### 导航守卫\r\n```js\r\nimport homeVue from \"./component/home.vue\"\r\nimport movieVue from \"./component/movie.vue\"\r\nimport aboutVue from \"./component/about.vue\"\r\nimport {createRouter,createWebHashHistory} from 'vue-router'\r\nconst router = createRouter({\r\n  // 略......\r\n    routes:[\r\n        // 略......\r\n        {\r\n          path: '/search/:someSearchKeywords?',//作用: `?`表示`someSearchKeywords`可以传递也可不传递,当不加?且不传递`someSearchKeywords`参数时,`url`中的`/search/`路径会没有,这会导致路由错误\r\n          name:'search',  // 作用:  this.$router.push({ name:'search',params:{key:value,...},query:{categoryid,categoryleve,categoryname}})\r\n          component: Search,\r\n          meta:{showFooter:true}//作用: 如此编写组件中便可以使用该变量: `<Footer v-if=\"$route.meta.showFooter\"></Footer>`\r\n        }\r\n    ]\r\n})\r\n\r\n//全局导航守卫\r\nrouter.beforeEach((to,from,next)=>{\r\n  //to 目标路由对象\r\n  //from 来源路由对象\r\n  //next() 调用后将放行路由 若不接收该参数则自动放行;\r\n    // next('/path') 跳转到指定路径\r\n    // next(false) 强制停留在当前页面\r\n\r\n  if(to.path == '/user' && ! localStorage.getItem('token'))//访问user页面,但没有登陆,则跳转到登陆页面\r\n  {\r\n    next('/login')//路由到登陆页面\r\n  }else{\r\n    next() //放行\r\n  }\r\n\r\n})\r\nexport default router//导出实例对象\r\n```\r\n\r\n\r\n## 登陆案例实现\r\n\r\nmain.js\r\n```js\r\nimport { createApp } from 'vue'\r\nimport './style.css'\r\nimport App from './App.vue'\r\nimport router from './router'\r\nconst app = createApp(App)\r\napp.use(router)\r\napp.mount('#app')\r\n```\r\n\r\nrouter.js\r\n```js\r\nimport {createRouter,createWebHashHistory} from 'vue-router'\r\nimport loginVue from './components/login.vue'\r\nimport userVue from './components/user.vue'\r\nimport userInfoVue from './components/userInfo.vue'\r\nimport userRightVue from './components/userRight.vue'\r\nimport userDetailVue from './components/userDetail.vue'\r\nconst router = createRouter({\r\n    history:createWebHashHistory(),\r\n    linkActiveClass:'actived_by_router',\r\n    routes:[\r\n        {path:'/',redirect:'/login'},\r\n        {path:'/login',component:loginVue},\r\n        {path:'/user',redirect:'/user/info',component:userVue ,children:[\r\n            {path:'info',component:userInfoVue},\r\n            {path:'right',component:userRightVue},\r\n            {path:'detail/:userId',component:userDetailVue,props:true},\r\n        ]},\r\n    ]\r\n})\r\n\r\nrouter.beforeEach((to,before,next)=>{\r\n    if(to.path != '/login' && !localStorage.getItem(\"token\"))//若不是访问/login 且没有登陆token 则重定向到/login\r\n    {\r\n        next('/login')\r\n    }else{\r\n        next()//其他页面则允许访问(其实应当需要更复杂的判断)\r\n    }\r\n})\r\nexport default router\r\n```\r\n\r\nApp.vue\r\n```html\r\n<template>\r\n    <router-view></router-view>\r\n</template>\r\n```\r\n\r\n\r\nlogin.vue\r\n```html\r\n<template>\r\n    <div class=\"loginBox\">\r\n        username:<input type=\"text\" v-model=\"username\"><br>\r\n        password:<input type=\"password\" v-model=\"password\"><br>\r\n        <button @click=\"login\">submit</button>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport {} from \"vue-router\"\r\nexport default {\r\n    data(){\r\n        return{\r\n            username:'',\r\n            password:''\r\n        }\r\n    },\r\n    methods:{\r\n        login(){\r\n            localStorage.setItem(\"token\",\"\")\r\n            if(this.username=='admin' && this.password=='admin')//模拟判断是否登陆成功\r\n            {\r\n                this.$router.push('/user')\r\n                localStorage.setItem(\"token\",\"XXXXXXXX\")//模拟存储token\r\n            }else{\r\n                alert('用户名或密码错误')\r\n            }\r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style>\r\n.loginBox{\r\n    width: 400px;\r\n    height: 400px;\r\n    background-color: #fff;\r\n}\r\n</style>\r\n```\r\n\r\nuser.vue\r\n```html\r\n<template>\r\n  <div class=\"userInfoBox\">\r\n    <div class=\"left\">\r\n      <button @click=\"logout\">登出</button><br>\r\n      <router-link to=\"/user/info\">用户信息</router-link><br>\r\n      <router-link to=\"/user/right\">用户权利</router-link>\r\n    </div>\r\n    <div class=\"right\">\r\n      <router-view></router-view>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  methods:{\r\n    logout(){\r\n      localStorage.setItem(\"token\",'')\r\n      this.$router.push('/')\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\">\r\n.userInfoBox{\r\n  display: flex;\r\n  .left{\r\n    width: 200px;\r\n    background-color: skyblue;\r\n  }\r\n  .right{\r\n    flex: 1;\r\n    background-color: pink;\r\n  }\r\n}\r\n.actived_by_router{\r\n  background-color: red;\r\n}\r\n</style>\r\n```\r\n\r\nuserInfo.vue\r\n```html\r\n<template>\r\n  <p>用户信息..................................</p>\r\n  <p>用户1:<router-link :to=\"'/user/detail/'+1\">张三</router-link> <button @click=\"$router.push('/user/detail/'+1)\">张三</button></p>\r\n  <p>用户2:<router-link :to=\"'/user/detail/'+2\">张四</router-link> <button @click=\"$router.push('/user/detail/'+2)\">张四</button></p>\r\n</template>\r\n```\r\n\r\n\r\nuserRight.vue\r\n```html\r\n<template>\r\n  <p>用户权限..................................</p>\r\n</template>\r\n```\r\n\r\nuserDetail.vue\r\n```html\r\n<template>\r\n  <div class=\"userDetailBox\">\r\n    <button @click=\"$router.go(-1)\">返回上一级</button>\r\n    <h2>用户详细信息</h2>\r\n    <p>userId:{{userId}}</p>\r\n    <p>$route.params.userId:{{$route.params.userId}}</p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    props:['userId']\r\n}\r\n</script>\r\n```\r\n\r\n## vue-cli脚手架\r\n\r\n**安装**\r\n\r\n```bash\r\nnpm install -g @vue/cli\r\nvue --version\r\n```\r\n\r\n**创建项目**\r\n```bash\r\n# 命令行方式创建\r\nnpm create project-Name\r\n# 图形界面创建\r\nvue ui\r\n```\r\n\r\n**建议手动勾选配置的功能**\r\n* [*] 使用设置档案`.babelrc`\r\n* [*] babel\r\n* [*] css预处理器(less Sass stylus)\r\n\r\n## vue组件库\r\n\r\n**PC端组件库**\r\n* Element-UI 饿了吗团队开发的组件库\r\n* View UI\r\n\r\n**移动端组件库**\r\n* mintUI\r\n* Vant\r\n\r\n\r\n### element UI\r\n* Element-UI --> **vue2**\r\n* Element Plus --> **vue3**\r\n\r\n**安装**\r\n```bash\r\nnpm i element-ui -S\r\n```\r\n\r\n**完整引入Element-UI**\r\n```js\r\n// 完整引入\r\nimport Vue from 'vue';\r\nimport ElementUI from 'element-ui'\r\nimport 'element-ui/lib/theme-chalk/index.css'\r\nVue.use(ElementUI)\r\n\r\n\r\n```\r\n**按需引入Element-UI:可减小项目体积**\r\n```js\r\n// 1.安装   npm install babel-plugin-component -D\r\n// 2.修改   .babelrc \r\n\"plugins\": [\r\n    [\r\n      \"component\",\r\n      {\r\n        \"libraryName\": \"element-ui\",\r\n        \"styleLibraryName\": \"theme-chalk\"\r\n      }\r\n    ]\r\n  ]\r\n\r\n// 3.修改main.js\r\nimport Vue from 'vue';\r\nimport { Button, Select } from 'element-ui';\r\nimport App from './App.vue';\r\n\r\nVue.component(Button.name, Button);\r\nVue.component(Select.name, Select);\r\n/*\r\n * 或写为\r\n * Vue.use(Button)\r\n * Vue.use(Select)\r\n*/\r\n```\r\n\r\n\r\n## vue-cli的proxy代理服务\r\n\r\n用于处理跨域的问题\r\n\r\n**示例**\r\n```js\r\n// 1.配置axios\r\naxios.defaults.baseURL = 'https://localhost:8080'\r\n// 2.在vue.config.js中配置proxy代理\r\nmodule.exports = {\r\n  devServer:{\r\n    proxy:'http://www.???.???',\r\n    open:true,//自动打开浏览器\r\n    // port:80\r\n  }\r\n}\r\n\r\n// 3.发送请求\r\nthis.$http.get('/api/users')\r\n// 4.vue发现接口不存在,于是将请求转交给proxy代理\r\n\r\n// 5.proxy代理把请求地址的baseURL替换为devServer.proxy的值,并发起真正的请求\r\n\r\n// 6.proxy代理把请求到的数据转发给axios\r\n\r\n```\r\n\r\n\r\n\r\n## transition动画组件\r\n**基本使用**\r\n```vue\r\n<button @click=\"shouldShow = !shouldShow\">切换组件显示</button>\r\n<transition name=\"transitionName\">\r\n    <div v-if=\"shouldShow\">     1. v-if   </div>\r\n    <div v-show=\"shouldShow\">   2. v-show   </div>\r\n    <component is=\"组件名称\">    3. 动态组件    </component>\r\n</transition>\r\n\r\n<style>\r\n        /* // 进入前 */\r\n        .transitionName-enter-from {\r\n            height: 0;\r\n        }\r\n        /* // 进入中 */\r\n        .transitionName-enter-active {\r\n            transition: all 0.2s linear;\r\n        }\r\n        /* // 进入后 */\r\n        .transitionName-enter-to {\r\n            height: 461px;\r\n        }\r\n        /* // 离开前 */\r\n        .transitionName-leave-from {\r\n            height: 461px;\r\n        }\r\n        /* // 离开中 */\r\n        .transitionName-leave-active {\r\n            transition: all 0.2s linear;\r\n        }\r\n        /* // 离开后 */\r\n        .transitionName-leave-to {\r\n            height: 0;\r\n        }\r\n</style>\r\n```\r\n\r\n## swiper在vue中的使用\r\n\r\n**安装**\r\n```bash\r\nnpm i swiper\r\n```\r\n\r\n**引入**\r\n\r\n根据 `swiper` 的`package.json`的 `exports` 属性可知应当引入 `./bundle` `./css/bundle`\r\n```js\r\n//package.json \r\n\"exports\": {\r\n    \".\": \"./swiper.esm.js\",\r\n    \"./core\": \"./swiper.esm.js\",\r\n    \"./bundle\": \"./swiper-bundle.esm.js\",\r\n    \"./css\": \"./swiper.min.css\",\r\n    \"./css/bundle\": \"./swiper-bundle.min.css\",\r\n    \"./css/a11y\": \"./modules/a11y/a11y.min.css\",\r\n    \"./css/autoplay\": \"./modules/autoplay/autoplay.min.css\",\r\n    \"./css/controller\": \"./modules/controller/controller.min.css\",\r\n    \"./css/effect-coverflow\": \"./modules/effect-coverflow/effect-coverflow.min.css\",\r\n    \"./css/effect-cube\": \"./modules/effect-cube/effect-cube.min.css\",\r\n    \"./css/effect-fade\": \"./modules/effect-fade/effect-fade.min.css\",\r\n    \"./css/effect-flip\": \"./modules/effect-flip/effect-flip.min.css\",\r\n}\r\n```\r\n\r\n\r\n```js\r\nimport 'swiper/css/bundle'\r\nimport Swiper from 'swiper/bundle'\r\n\r\n   import { mapState } from 'vuex';\r\n    import { nextTick } from 'vue'\r\n\r\nexport default {\r\n    mounted(){\r\n      this.$store.dispatch('home/getBannerList')//向服务端发送请求获取数据\r\n      nextTick(()=>{\r\n        // 不应在此处执行 new Swiper 因为此时的nextTick并不是由于`bannerList`更新导致的页面更新 且其不能处理数据后续更新导致的页面更新\r\n      })\r\n    },\r\n    computed:{\r\n      ...mapState('home',['bannerList'])//映射bannerList\r\n    },\r\n    watch:{//监听器\r\n        bannerList:{//bannerList监听器\r\n            immediate:true,\r\n            deep:true,\r\n            handler(newValue,oldValue){\r\n                nextTick(()=>{//监听到数据改变后,等待页面的` v-for=\"item in bannerList\" `渲染完毕后再执行回调,否则swiper功能异常\r\n                    var swiper = new Swiper(\r\n                      // \"#swiper_banner\", //css选择器或DOM对象\r\n                      this.$refs.swiper_banner,//vue的ref引用\r\n                      {\r\n                        autoplay:true,\r\n                        loop:true,\r\n                        navigation: {\r\n                          nextEl: \".swiper-button-next\" ,\r\n                          prevEl: \".swiper-button-prev\" ,\r\n                        },\r\n                        pagination: {\r\n                            el: \".swiper-pagination\" ,\r\n                            clickable: true\r\n                        },\r\n                    });\r\n                    console.log('nextTick执行完毕');\r\n                })\r\n                console.log('watch的回调执行完毕');\r\n            },\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```vue\r\n<!--banner轮播-->\r\n<!-- swiper-container是旧版类名 swiper是新版类名 实际上只需要写一个,携带了一些样式,并用于保证其子代的类名能够应用相关css属性 -->\r\n<div class=\"swiper swiper-container\" id=\"swiper_banner\" ref=\"swiper_banner\">\r\n    <div class=\"swiper-wrapper\">\r\n        <div class=\"swiper-slide\" v-for=\"item in bannerList\" :key=\"item.id\">\r\n            <img :src=\"item.imgUrl\" />\r\n        </div>\r\n    </div>\r\n    <!-- 如果需要分页器 -->\r\n    <div class=\"swiper-pagination Pagi_banner\"></div>\r\n    <!-- 如果需要导航按钮 -->\r\n    <div class=\"swiper-button-prev btnPrev_banner\"></div>\r\n    <div class=\"swiper-button-next btnNext_banner\"></div>\r\n</div>\r\n```\r\n\r\n## 根据页面滚动位置改变盒子高度(存在兼容性问题)\r\n```vue\r\n<template>\r\n    <div ref=\"cover\" class=\"cover\">\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    data() {\r\n        return {\r\n        }\r\n    },\r\n    mounted() {\r\n        document.addEventListener('scroll', () => {//根据页面滚动改变div高度\r\n            /* css\r\n                min-height: 20vh;\r\n                height: 80vh;\r\n                max-height: 80vh;\r\n            */\r\n            let px_100vh = window.innerHeight; //px单位的100vh\r\n            let px_scrolled_height = window.pageYOffset; //px单位的滚动内容的高度\r\n            let vh_scrolled_height = px_scrolled_height / px_100vh * 100; //vh单位的滚动内容的高度\r\n\r\n            let vh_min_height = 20;\r\n            let vh_max_height = 80;\r\n            let px_current_height = this.$refs.cover.clientHeight;\r\n            let vh_current_height = px_current_height / px_100vh * 100;\r\n\r\n            let new_vh_current_height = vh_current_height - vh_scrolled_height\r\n            console.log(new_vh_current_height);\r\n            if (vh_min_height <= new_vh_current_height && new_vh_current_height <= vh_max_height) {\r\n                this.$refs.cover.style.height = new_vh_current_height + 'vh';\r\n                window.scroll(0, 0)\r\n            }\r\n        })\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\" scoped>\r\n.cover {\r\n    width: 100%;\r\n    min-height: 20vh;\r\n    height: 80vh;\r\n    max-height: 80vh;\r\n    background-color:red;\r\n}\r\n</style>\r\n```"},{"shortInfo":{"title":"关于博主","date":"2022-02-24T03:00:00.000Z","layout":"post","cover":"\\self_server\\assets\\images\\面对大河我无限惭愧.png","type":"Nav","id":"about","hideAtIndex":true,"categories":"日志","tags":["日志","关于博主","Nav"],"countWords":273,"readSeconds":27.3,"assetsbaseUrl":"/self_server/assets/"},"content":"啥也不是 啥也不想说...\n\n<!-- ## 都在歌里\n{% meting \"8373757826\" \"tencent\" \"playlist\" \"autoplay\" \"volume:0.75\" \"theme:#ff0000\" %} -->\n\n\n\n\n\n<!-- ## 博客日志 -->\n<!-- * 2022年06月6日 [永远有下一座最高峰](/2022/06/06/永远有下一座最高峰/) -->\n<!-- * 2022年06月06日 [心累啊](/article/心累啊/)\n* 2022年06月05日 [那些最痛苦的日子已经过去了](/article/那些最痛苦的日子已经过去了/)\n* 2022年02月23日 [整理了下最近的笔记](/article/整理了下最近的笔记/)\n* 2021年12月28日 [Wubba lubba dub dub](/article/I%20am%20Tiny%20Rick/) -->\n\n<!-- ## 我的自述\n平平无奇,暂时无话可说~~~ -->\n\n<!-- ## 看过的书\n* [豆瓣](https://www.douban.com/people/178881271/) -->\n\n\n<!-- ## 听过的歌\n* [网易云音乐](https://music.163.com/#/user/home?id=369656412) -->\n\n\n<!-- {% gallery %}\n![text](https://cdn.jsdelivr.net/gh/nexmoe/image@latest/20210207192753.jpg)\n![text](https://cdn.jsdelivr.net/gh/nexmoe/image@latest/20210207192754.jpg)\n![text](https://cdn.jsdelivr.net/gh/nexmoe/image@latest/20210207192755.jpg)\n![text](https://cdn.jsdelivr.net/gh/nexmoe/image@latest/20210207192756.jpg)\n![text](https://cdn.jsdelivr.net/gh/nexmoe/image@latest/20210207192534.jpg)\n![text](https://cdn.jsdelivr.net/gh/nexmoe/image@latest/20210207192535.jpg)\n![text](https://cdn.jsdelivr.net/gh/nexmoe/image@latest/20210207192415.jpg)\n![text](https://cdn.jsdelivr.net/gh/nexmoe/image@latest/20210207192533.jpg)\n{% endgallery %} -->"},{"shortInfo":{"title":"站点新建 暂无友链","date":"2022-02-24T03:00:00.000Z","layout":"post","cover":"\\self_server\\assets\\images\\当我痛苦地站在你面前.png","type":"Nav","id":"friends","hideAtIndex":true,"categories":"日志","tags":["日志","Nav"],"countWords":4,"readSeconds":0.4,"assetsbaseUrl":"/self_server/assets/"},"content":"空空如也"},{"shortInfo":{"title":"2022年待办事项","date":"2022-02-24T05:34:00.000Z","cover":"\\self_server\\assets\\images\\我要向前走.png","type":"Nav","id":"schedule","hideAtIndex":true,"categories":"日志","tags":["日志","Nav"],"countWords":367,"readSeconds":36.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# 2022年\r\n## 一月 flags 🚩\r\n+ ✅ 尝试用js写俄罗斯方块\r\n+ ✅《概率论与数理统计(宋浩)》学习 \r\n\r\n## 二月 flags 🚩\r\n2月25日-5月22日:\r\n+ ✅ 免试保送政策取消 复习备考 \r\n\r\n## 五月 flags 🚩\r\n5月23日:\r\n+ ⬜ 《数据结构与算法分析》学习\r\n+ ✅ 重学Git补全笔记缺失知识点\r\n\r\n## 六月 flags 🚩\r\n+ ✅ 《七天学会NodeJS》教程学习 \r\n+ ✅ 重学HTML5并做笔记\r\n+ ✅ 重学CSS3并做笔记\r\n+ ✅ CSS3+HTML5项目实战\r\n+ ✅ LESS层叠样式预处理语言学习\r\n+ ✅ 移动web开发学习 \r\n    + ✅ CSS3进阶\r\n    + ✅ 移动端布局及Flex布局模型\r\n    + ✅ Flex布局模型项目实战\r\n    + ✅ 移动适配\r\n    + ✅ 移动适配项目实战\r\n    + ✅ 响应式\r\n    + ✅ 响应式BootStrap框架\r\n    + ✅ 响应式网页项目实战\r\n+ ✅ JavaScript基础知识复习\r\n\r\n\r\n## 七月 flags 🚩\r\n+ ✅ jsAPI:DOM学习\r\n+ ✅ jsAPI:BOM学习\r\n+ ✅ jQuery学习\r\n+ ✅ indexedDB学习笔记\r\n+ ✅ promise学习\r\n+ ✅ 手写实现Promise\r\n\r\n## 八月 flags 🚩\r\n+ ✅ Ajax学习;`XMLHttpRequest` `axios` `window.fetch()`\r\n+ ✅ nodejs学习\r\n+ ✅ js高级语法学习\r\n+ ✅ express学习\r\n  + ✅ session认证机制\r\n  + ✅ jwt认证机制\r\n+ ✅ express项目练习\r\n+ ✅ SQL语法学习\r\n+ ✅ nodejs的mysql模块学习\r\n\r\n## 九月 flags 🚩\r\n\r\n+ ✅ ES6-ES11新特性学习\r\n+ ✅ vue3学习\r\n+ ✅ Vue3项目实战练习: 尚品汇\r\n+ ✅ Vue3项目练习: 用Vue重写博客网站\r\n\r\n## 十月 flags 🚩\r\n+ ⬜ 整理Vue尚品汇及博客项目中可复用代码,解决方案并总结笔记\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n<!-- \r\n📔 Notebook with Decorative Cover\r\n📕 Closed Book\r\n📖 Open Book\r\n📗 Green Book\r\n📘 Blue Book\r\n📙 Orange Book\r\n📚 Books\r\n📓 Notebook\r\n📒 Ledger\r\n📃 Page with Curl\r\n📜 Scroll\r\n📄 Page Facing Up\r\n📰 Newspaper\r\n🗞️ Rolled-Up Newspaper\r\n📑 Bookmark Tabs\r\n🔖 Bookmark\r\n🏷️ Label\r\n💰 Money Bag\r\n\r\n -->"},{"shortInfo":{"title":"WEB开发模式和身份认证的概念","date":"2022-08-30T00:00:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["身份认证"],"hideAtIndex":true,"categories":"后端","id":52,"countWords":1411,"readSeconds":141.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# WEB开发模式和身份认证的概念\r\n\r\n## 目录\r\n- [WEB开发模式和身份认证的概念](#web开发模式和身份认证的概念)\r\n  - [目录](#目录)\r\n  - [WEB开发模式](#web开发模式)\r\n    - [服务端渲染开发模式](#服务端渲染开发模式)\r\n    - [前后端分离开发模式](#前后端分离开发模式)\r\n    - [WEB开发模式的选择](#web开发模式的选择)\r\n  - [身份认证](#身份认证)\r\n    - [session认证机制](#session认证机制)\r\n    - [JWT认证机制](#jwt认证机制)\r\n\r\n## WEB开发模式\r\n\r\n### 服务端渲染开发模式\r\n**页面由服务端拼接动态生成后发送给客户端**\r\n* 缺点\r\n    * 开发效率低\r\n    * 耗费服务端资源\r\n* 优点\r\n    * 有利于SEO\r\n    * 节省客户端资源\r\n\r\n\r\n### 前后端分离开发模式\r\n**前端用AJAX调接口,后端负责提供接口**\r\n* 优点\r\n    * 开发效率高,\r\n      * 前端专注于UI界面,\r\n      * 后端专注于API开发,\r\n      * 前端开发时有多种选择,Jquery+模板引擎 或 Vue 或 React 等的框架\r\n    * 用户体验好,容易实现局部刷新\r\n    * 减轻了服务器渲染压力\r\n* 缺点\r\n    * 不利于SEO,\r\n      * 完整的页面内容是通过AJAX获取API接口得到的,\r\n      * 该问题可用VUE React前端框架的SSR(server Side render)解决\r\n\r\n### WEB开发模式的选择\r\n**WEB开发模式的选择需要考虑业务场景**\r\n* 企业网站,主要为展示产品,**没有复杂的交互**,**需要良好的SEO**,则一般使用**服务端渲染**的开发模式\r\n* 后台管理网站,**交互性强**,**不需要考虑SEO**,则一般使用**前后端分离**的开发模式\r\n* 若需**同时考虑首页渲染速度**和**开发效率**,则采用**首页服务器渲染** **其他页面采用前后端分离**的开发模式\r\n\r\n\r\n\r\n## 身份认证\r\n身份认证(Authentication),身份验证,鉴权;指**通过一定手段完成对用户身份的确认**  \r\n身份认证的目的是为了**确认当前所声称为某身份的用户,确实是所声称的用户**\r\n* 手机验证码登陆\r\n* 邮箱验证登陆\r\n* 二维码登陆\r\n* 密码登陆\r\n\r\n不同WEB开发模式采用不同的身份认证机制\r\n* **服务端渲染**的开发模式一般使用**session认证机制**\r\n* **前后端分离**的开发模式一般使用**JWT认证机制**\r\n\r\nSession认证机制需要配合Cookie才能实现,由于Cookie默认不支持跨域,所以但涉及到前端跨域访问后端接口时,需要做很多额外的配置,才能实现跨域Session认证\r\n* 前端不存在跨域访问后端接口,应使用**Session认证机制**\r\n* 前端跨域访问后端接口时应该使用**JWT认证机制**\r\n\r\n\r\n### session认证机制\r\n**HTTP协议的无状态性**  \r\n无状态性是指客户端**每次发送的http请求都是独立的**,多个请求之间没有直接的关系,**服务端也不会保留每次http的请求状态**. 解决该问题需使用`Cookie`,用于确认前后两个请求是同一个用户\r\n\r\n**Cookie**  \r\n* **4KB限制** 是存储在浏览器中一段**不超过4kB的字符串**\r\n* **由键值对组成**,有名称Name,值Value和其他几个可选属性组成(有效期,安全性,使用范围)\r\n* **会过期**\r\n* **按域名独立** **不同域名下的cookie各自独立**\r\n* **自动发送** 客户端发送请求时,**会自动把该域名下所有未过期的cookie发送给服务端**\r\n* **容易被伪造** 浏览器提供了读写cookie的API\r\n* **本身不具有安全性** 不建议存放隐私数据,\r\n![图 1](./images/WEB开发模式和身份认证的概念/40f0452c90f5994d012e9f073038ff3fbc45665c6da45c88587115bbcc12eb4e.png)  \r\n\r\n\r\n**获取;存储;发送cookie过程**\r\n* 客户端第一次向服务端发送请求时,服务端会通过响应头向客户端发送一个cookie  \r\n* 客户端收到该cookie后会**自动保存**到浏览器中  \r\n* 客户端后续的请求头将会**自动携带cookie**\r\n![图 3](./images/WEB开发模式和身份认证的概念/afa9ca9e3772872db3bb9bae6040575703ebddf7d568c9716d1d29a5d1e90d0c.png)  \r\n\r\n\r\n**session认证原理**  \r\nsession认证使用**cookie+身份认证**的方式实现;提高了cookie本身的安全性\r\n![图 4](./images/WEB开发模式和身份认证的概念/b11f8a54b6f620cf5ebc2e775472341c20fe816eda06727d1196139c5cf1d9e0.png)  \r\n\r\n\r\n\r\n**express中的session认证**\r\nexpress中可使用`express-session`的**第三方中间件**来实现  \r\n<red>详细笔记:[express学习笔记]()</red>  \r\n\r\n\r\n\r\n### JWT认证机制\r\n**概念**  \r\n* **JWT(Json Web Token)**,是目前最流行的跨域认证解决方案\r\n* JWT组成: `header头部.Payload有效载荷.Signature签名`\r\n  * `Payload有效载荷` 是用户信息经过加密后的字符串\r\n  * `header头部` 和 `Signature签名` 是安全性相关的内容\r\n\r\n**工作原理**\r\n* 客户端发送登陆请求,提交用户名和密码\r\n* 服务端验证用户名和密码的真实性,将用户信息加密生成`token`发送给客户端\r\n* 客户端收到token后手动保存到`LocalStorage`或`SessionStorage`中\r\n* 客户端后续发送请求时,需携带名为`Authorization`的请求头,格式为`Authorization: Bearer Token字符串;`\r\n* 服务端收到请求后从请求头中提取出`Token`字段,并**解密出用户信息**,身份认证成功后,再根据客户端的请求的内容响应给客户端相应的数据\r\n![图 5](./images/WEB开发模式和身份认证的概念/fdfbe7930227813d1039709dc80d7fb73364fbc99947afa2be37eaa1b3449bff.png)  \r\n\r\n\r\n\r\n**express中的sJWT认证机制机制**\r\n<red>详细笔记:[express学习笔记]()</red>  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<style>\r\n    red{\r\n        color:red;\r\n    }\r\n    sky{\r\n        color:skyblue;\r\n    }\r\n</style>"},{"shortInfo":{"title":"win10将exe配置成服务过程记录","date":"2022-08-04T13:13:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["win10","服务"],"hideAtIndex":true,"categories":"笔记","id":53,"countWords":352,"readSeconds":35.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# win10将exe配置成服务过程记录\r\n\r\n**instsrv 和 srvany**\r\n* instsrv(install service)是用来安装服务\r\n* srvany(service anything)包装任何服务的外壳\r\n* [下载instsrv](/uploads/instsrv.exe) \r\n* [下载srvany](/uploads/srvany.exe)\r\n\r\n## 一、主要步骤\r\n**1.安装服务**\r\n```bash\r\n# cmd\r\ninstsrv.exe  XXXXXX（服务名）  d:\\path\\to\\srvany.exe（必须是完整的绝对路径）\r\n```\r\n\r\n**2.编辑注册表**\r\n1. win+r 输入：regedit\r\n2. 找到[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\XXXXXX(服务名)]\r\n3. 选择“新建”下的“项”，将其命名为Parameters。\r\n4. 单击选定Parameters，\r\n    * 新建名为 `Application` 的字符串值 将其数值数据设置为 XXXXXX（服务名）服务对应的应用程序的绝对路径，比如:E:\\temp\\clean_day\\nginx-1.4.7\\nginx.exe；\r\n    * 新建名为 `AppDirectory` 的字符串值 将其数值数据设置为指定程序所在的目录,如：E:\\temp\\clean_day\\nginx-1.4.7\r\n    * 新建名为 `AppParameters` 的字符串值 AppParameters指明程序运行的参数，如果没有可以不用设值；\r\n\r\n**3.启动服务**\r\n完毕你就可以用`net`命令启动/停止，或者sc命令配置服务了。\r\n```bash\r\nnet start XXXXXX（服务名）\r\nnet stop XXXXXX（服务名）\r\n```\r\n\r\n## 二、其他\r\n\r\n### 删除服务\r\n可以使用instsrv的remove选项来删除服务，当然也可以用sc命令\r\n\r\n### 配置服务\r\nwin+R 输入 `msconfig` 配置服务的开机启动启动或关闭\r\n\r\nwin+R 输入 `services.msc` 配置服务的临时启动和关闭"},{"shortInfo":{"title":"C语言中头文件及其具体实现的编写规范","top":10,"cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-24T22:12:53.000Z","modified":"2022-05-26T18:09:20.016Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":71,"countWords":205,"readSeconds":20.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# C语言中头文件及其具体实现的编写规范\r\n* c语言中约定函数的声明、类型的声明写在XXX.h文件中\r\n* 其结构体、函数的具体实现写在XXX.c中\r\n* 编译时有两种方式\r\n  + 直接将库的源文件XXX.c和main.c一起编译 `gcc main.c XXX.c -o main.exe`\r\n  + 先将库的源文件汇编成.o文件，隐藏具体实现原理 再将.o文件与main.c编译\r\n    + `gcc -c XXX.c -o XXX.o`\r\n    + `gcc main.c XXX.o -o main.exe`\r\n* 结构体的定义写在.c文件还是.h文件？\r\n  + 放c还是h取决于该结构是否要暴露给其他c,原则就是能放c绝不放h,但一般来说既然定义了结构,多半还是要暴露出来的.\r\n"},{"shortInfo":{"layout":"post","top":100,"title":"《数据结构与算法分析》学习笔记","date":"2022-05-24T11:49:04.000Z","modified":"2022-05-28T20:31:14.702Z","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"tags":["《数据结构与算法分析》","笔记","加密"],"categories":"笔记","id":55,"countWords":681,"readSeconds":68.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# 《数据结构与算法分析》学习笔记\r\n\r\n## 说明\r\n* 该笔记主要旨在用自己的语言记录和总结该书中关键知识点；\r\n* 以及编写代码实现该书中提及但未给出具体代码的数据结构和例程。\r\n* 目的是加深印象和方便遗忘时查阅和复习。\r\n\r\n## 笔记目录\r\n\r\n### 第一章 引论\r\n+ [1.2数学知识复习（截图）](/article/《数据结构与算法分析》学习笔记/第1章_1.2数学知识复习（截图）)\r\n+ [1.3递归简论](/article/《数据结构与算法分析》学习笔记/第1章_1.3递归简论)\r\n\r\n### 第二章算法分析\r\n+ [算法分析](/article/《数据结构与算法分析》学习笔记/第2章_算法分析)\r\n\r\n### 第三章 表、栈和队列\r\n+ [1.抽象数据类型ADT](/article/《数据结构与算法分析》学习笔记/第3章_1.抽象数据类型ADT)\r\n+ [2.表](/article/《数据结构与算法分析》学习笔记/第3章_2.表)\r\n+ [3.栈](/article/《数据结构与算法分析》学习笔记/第3章_3.栈)\r\n+ [4.队列](/article/《数据结构与算法分析》学习笔记/第3章_4.队列)\r\n\r\n### 第四章 树\r\n+ [1.树的概念](/article/《数据结构与算法分析》学习笔记/第4章_1.树的概念)\r\n+ [2.二叉树的概念](/article/《数据结构与算法分析》学习笔记/第4章_2.二叉树的概念)\r\n+ [3.表达式树](/article/《数据结构与算法分析》学习笔记/第4章_3.表达式树)\r\n+ [4.二叉查找树](/article/《数据结构与算法分析》学习笔记/第4章_4.二叉查找树)\r\n+ [5.平衡树的概念](/article/《数据结构与算法分析》学习笔记/第4章_5.平衡树的概念)\r\n+ [6.AVL树](/article/《数据结构与算法分析》学习笔记/第4章_6.AVL树)\r\n+ [7.AVL树的实现](/article/《数据结构与算法分析》学习笔记/第4章_7.AVL树的实现)\r\n+ [8.伸展树](/article/《数据结构与算法分析》学习笔记/第4章_8.伸展树)\r\n+ [9.树的遍历](/article/《数据结构与算法分析》学习笔记/第4章_9.树的遍历)\r\n\r\n### 其他琐碎知识点\r\n+ [C语言中头文件及其具体实现的编写规范](/article/《数据结构与算法分析》学习笔记/C语言中头文件及其具体实现的编写规范)\r\n\r\n\r\n<!-- ```\r\n目录附加内容：\r\ntop: 10\r\nlayout: post\r\ntags: [《数据结构与算法分析》,笔记]\r\ncategories: 笔记\r\ndate: 2022-05-24 19:49:04 +0800\r\n所有笔记和目录附加封面：\r\ncover: ./images/《数据结构与算法分析》学习笔记/cover.png\r\ncoverWidth: 813\r\ncoverHeight: 539\r\ncoverWidth: 813\r\ncoverHeight: 539\r\n``` -->\r\n"},{"shortInfo":{"cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"title":"第1章_1.2数学知识复习（截图）","date":"2022-05-26T10:13:18.000Z","modified":"2022-05-26T20:31:18.591Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":54,"countWords":265,"readSeconds":26.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第1章_1.2数学知识复习（截图）\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-13-45.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-13-55.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-14-09.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-14-32.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-14-39.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-15-28.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-16-20.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-16-40.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-24-31.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-24-46.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-25-26.png)\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-25-33.png)\r\n"},{"shortInfo":{"cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"title":"《数据结构与算法分析》第1章_1.3递归简论","date":"2022-05-24T02:34:27.000Z","modified":"2022-05-26T21:32:23.529Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":56,"countWords":374,"readSeconds":37.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第1章_1.3递归简论\r\n## 1.3递归简论\r\n* 有时候数学函数以不太标准的形式来定义\r\n* 当一个函数用它自己来定义时就称为是递归（recursive）\r\n  + f(x)=1 while x==0;\r\n  + f(x)=x*f(x-1) else;\r\n* 编写递归代码的四条基本法则：\r\n  1. 基准情形。必须总有某些基准情形，它无须递归就能解出。\r\n  2. 不断推进。对于那些需要递归求解的情形，每一次递归调用都必须要使求解状况朝接近基准情形的方向推进。\r\n  3. 设计法则。假设所有的递归调用都能运行。\r\n  4. 合成效益法则( compound interest rule)。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。\r\n\r\n## 示例程序1\r\n\r\n```c\r\nint func(int x)\r\n{\r\n  if(x==0) return 1;  //处理基准情况\r\n  else return x*func(x-1); //执行递归调用 且向基准情形推进\r\n}\r\n```\r\n\r\n## 示例程序2\r\n* 注意，以下代码是低效的，mod操作的耗费很大，因为 N%10=N-(N/10)*10\r\n```c\r\nvoid printNum(int num)\r\n{\r\n  if(num>=10) printNum(num/10);\r\n  putchar(num%10+'0');\r\n}\r\n```\r\n\r\n## 练习题\r\n* 1.3 只使用处理I/O的PrintDigit函数，编写一个程序以输出任意实数(可以是负的)。\r\n```c\r\nvoid printNum(int num)\r\n{\r\n  if(num<0)\r\n  {\r\n    putchar('-');\r\n    num=-num;\r\n  }\r\n  if(num>=10)\r\n    printNum(num/10);\r\n  putchar(num%10);\r\n\r\n}\r\n```\r\n\r\n* 运行结果 ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-24-19-49-04.png)\r\n\r\n\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第2章_算法分析","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-24T03:59:09.000Z","modified":"2022-05-31T16:30:13.716Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":57,"countWords":418,"readSeconds":41.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第2章_算法分析\r\n* 用于评价一个算法的好坏\r\n* 确定一个算法需要的时间代价和空间代价\r\n\r\n## 四个定义\r\n1. 定义：如果存在正常数c和n0使得当N>=n0时T(N)<=cf(N)，则记为T(N) = O(f(N))。\r\n1. 定义：如果存在正常数c和n0使得当N>=n0时T(N)>=cf(N)，则记为T(N) = Ω(f(N))。\r\n1. 定义：T(N) = Θ(h(N))当且仅当T(N) = O(h(N))且T(N) = Ω(h(N))。\r\n1. 定义：如果T(N) = O(p(N))且T(N) != Θ(h(N))，则T(N) = o(p(N))。\r\n\r\n## 说明\r\n* 第一个定义是指T(N)的增长率<=f(N)的增长率，则表示为T(N) = O(f(N))\r\n* 第二个定义是指T(N)的增长率>=g(N)的增长率，则表示为T(N) = Ω(g(N))\r\n* 第三个定义是指T(N)的增长率==h(N)的增长率，则表示为T(N) = Θ(h(N))\r\n* 第四个定义是指T(N)的增长率< p(N)的增长率，则表示为T(N) = o(p(N))\r\n* 这些定义的初衷是为了比较2个函数的相对增长率。\r\n* 常见的函数增长率大小关系：\r\n  * c(常数) < logN < log²N（对数平方根）< N < NLogN < N² < N³ < 2ⁿ（指数级）\r\n\r\n## 意义\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-26-02-45-24.png)\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-26-02-46-00.png)\r\n\r\n## 关于时间复杂度logN的理解\r\n\r\n```c\r\nmain()\r\n{\r\n  int i=0;\r\n  while(i<=n)\r\n    i*=2;\r\n}\r\n```\r\n* 计算上述程序的运行次数，就是计算 2的多少次方>=n 写成：$2^?=n$\r\n* 也就是 $\\log_2{N}$\r\n* 算法中 $\\log{N}$一般以2为底 $\\log_2{N}$\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第3章_1.抽象数据类型ADT","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-25T04:42:08.000Z","modified":"2022-05-26T21:32:50.535Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":58,"countWords":654,"readSeconds":65.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第3章_1.抽象数据类型ADT\r\n* 表、栈和队列是最简单和最基本的三种数据结构\r\n* 每个有意义的程序都将至少使用一种这种数据结构\r\n* 不管程序中是否做了声明，栈总要在程序中间接的使用到\r\n* 这些数据结构非常重要，也极容易编程，学习的主要目的在于通过练习写出精简的通用的例程。\r\n\r\n## 抽象数据类型ADT的概念\r\n\r\n### 模块化\r\n* 程序设计的基本法则之一是例程不应超过一页。\r\n* 这可以通过把程序分割为一些模块( nodule)来实现。每个模块是一个逻辑单位并执行某个特定的任务.它通过调用其他模块而使本身保持很小。\r\n* 模块化的优点。\r\n  * 首先,调试小程序比调试大程序要容易\r\n  * 第二,多个人同时对一个模块式程序编程要更容易。\r\n  * 第三,一个写得好的模块化程序把某些依赖关系只局限在一个例程中，这样使得修改起来会更容易。例如，需要以某种格式编写输出．那么重要的当然是让一个例程去实现它。如果打印语句分散在程序各处，那么修改所费的时间就会明显地拖长。全局变量和副作用是有害的观念也正是出于模块化是有益的想法\r\n\r\n### 抽象数据类型概念\r\n* 抽象数据类型(abstract data type、ADT)是一些操作的集合。\r\n* 在ADT的定义中不涉及如何实现这些操作。\r\n* 表、集合和图是一种抽象的数据类型，类似于整数和实数的是一种数据类型\r\n* 这种抽象的数据类型也拥有相关的操作，类似于整数和实数的数据类型有他们的操作。\r\n\r\n### 基本想法\r\n* 这些操作的实现只在程序中编写一次.\r\n* 而程序中任何其他部分需要在该ADT上运行其中的一种操作时可以通过调用适当的函数来进行\r\n* 如果由于某种原因需要改变操作的细节,只需要修改运行这些ADT操作的例程\r\n* 在理想的情况下这种改变对于程序的其余部分通常是完全透明的\r\n* 对于每种ADT并不存在什么法则来告诉我们必须要有哪些操作\r\n* 使用它们的程序没有必要知道它们是如何实现的\r\n\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第3章_2.表","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-24T05:16:26.000Z","modified":"2022-05-28T11:45:44.760Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":59,"countWords":2422,"readSeconds":242.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第3章_2.表\r\n### 表ADT\r\n* 形如A1、A2、A3、A4......Ax的表 表的大小是N\r\n* 大小为0的表为空表\r\n* 对于除空表以为外的任何表，称Ai+1后继Ai 或者说 Ai+1继Ai之后 同时称Ai-1 前驱Ai\r\n* 表中第一个元素是A1 最后一个元素是A_N\r\n* 不定义A1的前驱元，也不定义A_N的后继元\r\n* 元素Ai在表中的位置为i\r\n\r\n### 表ADT的数据操作\r\n一些常见的操作\r\n* printList 打印输出这个表的内容\r\n* makeEmpty 创建一个空表\r\n* Find 返回关键字首次出现的位置\r\n* Insert 在指定位置之后插入某个关键字\r\n* Delete 删除指定位置的关键字\r\n* FindKth 返回某个位置上的元素\r\n* Next 返回其后继元的位置\r\n* Previous 返回期前继元的位置\r\n\r\n## 表的简单数组实现\r\n* 空间代价：\r\n  + 数组可以是动态指定的 （malloc）\r\n  + 需要对表的大小进行最大值估计 通常会估计的大一些，会浪费大量空间，是严重的局限\r\n* 时间代价：\r\n  + printList和Find操作花费线性时间\r\n  + FindKth花费常数时间\r\n  + 插入操作花费昂贵，如果插入一个元素在0的位置，那么其余所有元素将向后挪（复制）\r\n  + 删除操作花费昂贵，如果删除第一个元素，那么其余所有元素将全部向前挪（复制）\r\n  + 平均来看，插入和删除操作都需要移动一半的元素，要花费线性时间\r\n  + 通过N次插入操作来建立一个表需要花费二次时间。\r\n\r\n## 表的链表实现\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-25-20-38-41.png)\r\n* 为避免插入和删除的线性开销，需要允许表可以不连续存储（避免表部分或整体全部移动）。\r\n* 链表结构不必在内存中连续\r\n* 每一个结构含有一个**表元素**和一个**后继元的结构的指针**，称为Next指针\r\n* 最后一个单元的Next指向NULL（具体值由c定义，ansiC规定NULL为0）\r\n* 空间代价：\r\n  + 数组的元素可以在需要插入元素的时候再从内存开辟空间\r\n* 时间代价：\r\n  + PrintList(L)和Find(L,key)花费线性时间\r\n  + FindKth(L,i)花费O(i)时间\r\n  + 删除操作通过修改指针完成\r\n  + 插入操作通过执行两次指针调整完成（需先为新元素分配内存）\r\n* 问题\r\n  + 仅从链表的定义出发，无法在一个元素的前面插入一个元素，因为你只能知道当前表的内容和后继表的指针\r\n  + 在第一个元素位置做表的删除操作，可能导致整个表的丢失。\r\n  + 删除算法要求知道被删除元素的前一个元素的指针，因为需要将前一个元素的Next指针指向后一个元素的地址\r\n* 解决方法：增添表头\r\n  + 表头（header）或哑节点（dummy node）\r\n  + 表头位置为0 第一个元素的位置为1\r\n  + 是否使用头节点是有争议的，但使用头节点将不用再去考虑一些特殊情况\r\n  + 为避免删除算法的问题，需编写一个FindPrevious 将返回被删除元素的前一个元素，这样删除第一个元素时将返回表头的位置\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-25-20-38-23.png)\r\n\r\n### 例程\r\n* 按照C的约定，类型声明以及函数的原型都写在.h头文件中。\r\n* 具体的类型定义写在.c文件中。\r\n\r\n```c\r\n//List.h\r\n#ifndef _List_H_\r\n#define _List_H_\r\n\r\ntypedef int ElementType;\r\n\r\ntypedef struct Node* PtrToNode;\r\ntypedef PtrToNode List;\r\ntypedef PtrToNode Position;\r\n\r\nList MakeEmpty(List L);\r\nint isEmpty(List L);\r\nint isLast(Position P,List L);\r\nPosition Find(ElementType X,List L);\r\nvoid Delete(ElementType X,List L);\r\nPosition FindPrevious(ElementType X,List L);\r\nvoid Insert(ElementType X,List L,Position P);\r\nvoid DeleteList(List L);\r\nPosition Header(List L);\r\nPosition First(List L);\r\nPosition Advance(Position P);\r\nElementType Retrieve(Position P);\r\n\r\n#endif\r\n```\r\n* 注意，Insert例程和IsLast例程都传入了表L参数，尽管它从未被使用过。之所以这么做，是因为别的实现方法可能会需要这些信息，因此，若不传递表L有可能使得使用ADT的想法失败。\r\n\r\n```c\r\n// List.c\r\n#include\"List.h\"\r\n#include<stdlib.h>\r\nstruct Node\r\n{\r\n  ElementType Element;\r\n  Position Next;\r\n};\r\n\r\nList MakeEmpty(List L)\r\n{\r\n    if (L->Next)\r\n    {\r\n        MakeEmpty(L->Next);\r\n        free(L->Next);\r\n    }\r\n    return L;\r\n}\r\nint IsEmpty(List L)//测试空表\r\n{\r\n  return L->Next==NULL;\r\n}\r\nint IsLast(Position P,List L)//测试当前位置是否为链表尾部\r\n{\r\n  return P->Next == NULL;\r\n}\r\nPosition Find(ElementType X,List L)//查找一个元素，返回他的地址\r\n{\r\n  Position P;\r\n  P=L->Next;\r\n  while(P!=NULL && P->Element!=X)//避免用递归来实现\r\n    P=P->Next;\r\n  return P;//特殊情况：如果为空表将返回表头地址，如果查找不到将返回尾部元素地址\r\n}\r\nvoid Delete(ElementType X,List L)//查找并删除一个元素\r\n{\r\n  Position P,tempCell;\r\n  P = FindPrevious(X,L);\r\n\r\n  if(!isLast(P,L))\r\n  {\r\n    tempCell=P->Next;\r\n    P->Next=tempCell->Next;\r\n    free(tempCell);\r\n  }\r\n}\r\nPosition FindPrevious(ElementType X,List L)\r\n{\r\n  Position P;\r\n  P=L;//从表头开始查找\r\n  while(P->Next!=NULL && P->Next->Element!=X)\r\n    P=P->Next;\r\n  return P;//特殊情况：如果为空表则返回表头的地址，如果查找不到则返回最后一个元素的地址\r\n}\r\nvoid Insert(ElementType X,List L,Position P)//插入一个元素到P之后\r\n{\r\n  Position TempCell;\r\n  TempCell=malloc(sizeof(struct Node));\r\n  if(TempCell==NULL)\r\n    ;//out of space\r\n  TempCell->Element=X;\r\n\r\n  TempCell=P->Next;\r\n  P->Next=TempCell;\r\n}\r\nvoid DeleteList(List L)\r\n{\r\n  Position P,temp;\r\n  P=L->Next;\r\n  L->Next=NULL;//头元素不删除\r\n  while(P!=NULL)\r\n  {\r\n    temp=P->Next;\r\n    free(P);\r\n    P=temp;\r\n  }\r\n}\r\nPosition Header(List L)\r\n{\r\n  return L;\r\n}\r\nPosition First(List L)\r\n{\r\n  return L->Next;\r\n}\r\nPosition Advance(Position P)\r\n{\r\n  return P->Next;\r\n}\r\nElementType Retrieve(Position P)\r\n{\r\n  return P->Element;\r\n}\r\n```\r\n\r\n### 双链表\r\n* 解决问题：解决单链表无法倒序扫描的问题\r\n* 代价\r\n  + 空间代价：数据结构中增添的一个指针域\r\n  + 时间代价：\r\n    + 简化了删除操作，原先无法得知前驱元素的指针，现在这个指针是现成的\r\n    + 插入和删除操作的开销增加了一倍，因为多了一倍量的指针需要定位\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-25-20-34-07.png)\r\n\r\n### 循环链表\r\n* 一种流行的做法\r\n* 让最后一个元素的指针域指向第一个元素\r\n* 可以有表头，也可以没有\r\n* 如果有表头，最后一个元素的指针域指向表头\r\n* 可以同时也是双向链表\r\n* 下图为无头循环双链表\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-25-20-46-45.png)\r\n\r\n## 三个使用链表的例子\r\n* 一元多项式\r\n* 基数排序（以线性时间进行）\r\n* 学生课程选课系统\r\n\r\n### 一元多项式(结构体+数组方式实现)\r\n* 如果一个一元的多项式的系数大部分为非零（稠密多项式），那么可以用一个数组来存储这些系数，同时用一个变量来记录这个多项式的最高次项的指数，将其用一个结构体存储，继而可以写出其加减乘微分的操作函数。\r\n\r\n```c\r\n#define MaxDegree 100\r\n\r\nstruct polynomial{//存储一个多项式\r\n  int coeffArray[MaxDegree];//存储各项系数，coeffArray[0] 存储x^0项的系数\r\n  int HighPower;//存储最高此项的指数\r\n};\r\n\r\ntypedef struct polynomial Polynomial;\r\ntypedef struct polynomial* PPolynomial;\r\n\r\nvoid ZeroPolynomial(PPolynomial Poly)//初始化一个多项式\r\n{\r\n  int i;\r\n  for(i=0;i<MaxDegree;i++)\r\n    Poly->coeffArray[i]=0;\r\n  Poly->HighPower=0;\r\n}\r\nvoid AddPolynomial(PPolynomial A1,PPolynomial A2,PPolynomial Result)//加法\r\n{\r\n  int i,j;\r\n  for(i=0;i<MaxDegree;i++)\r\n        Result->coeffArray[i] = A1->coeffArray[i] + A2->coeffArray[j] ;\r\n  Result->HighPower = (A1->HighPower > A2->HighPower)? A1->HighPower : A2->HighPower ;\r\n}\r\nvoid multiplePolynomial(PPolynomial A1,PPolynomial A2,PPolynomial Result)//乘法\r\n{\r\n  if(A1->HighPower + A2->HighPower  >= MaxDegree)\r\n  {\r\n    //out of memory\r\n    return;\r\n  }\r\n  int i,j;\r\n  for(i=0;i<MaxDegree;i++)\r\n  {\r\n    for(j=0;j<MaxDegree;j++)\r\n    {\r\n      Result->coeffArray[i+j] += A1->coeffArray[i] * A2->coeffArray[j] ;\r\n    }\r\n  }\r\n  Result->HighPower = A1->HighPower + A2->HighPower;\r\n}\r\n```\r\n\r\n### 一元多项式(链表方式实现)\r\n* 非稠密多项式用上述方式实现会遇到很多问题，\r\n  + 如当多项式的最高次项为1000，那么用上述方式就需要保存1001个系数，造成空间资源的浪费；\r\n  + 如果这个多项式的系数只有最高次项和最低次项有值其余次项的系数基本上全都是0，那么在做加法运算的时候程序会去计算系数为零的项，造成计算资源的浪费。\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-26-18-46-12.png)\r\n\r\n```c\r\n\r\nstruct Node{\r\n  int Coeff;\r\n  int Exponent;\r\n  struct Node Next;\r\n};\r\ntypedef Node* PPolynomial;\r\ntypedef Node Polynomial;\r\n\r\nvoid addPolynomial(PPolynomial A1,PPolynomial A2,PPolynomial Result)\r\n{\r\n  \r\n}\r\n\r\n\r\n```\r\n\r\n### 基数排序\r\n* 预备知识：桶排序\r\n* 基数排序是桶排序的推广\r\n* 通过从低到高比较基数大小来进行多次桶排序\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-26-20-24-04.png)\r\n\r\n桶排序概念实现\r\n```c\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<time.h>\r\nint main()\r\n{\r\n  int count[100]={0};\r\n  int num[100];\r\n\r\n  int i,j;\r\n  for(i=0;i<100;i++)//随机赋值0~100\r\n    num[i]=(srand(rand()+clock()),rand()%100);\r\n  \r\n  for(i=0;i<100;i++)//桶排序\r\n    count[num[i]]++;\r\n  \r\n  for(i=0;i<100;i++)//输出\r\n    for(j=0;j<count[i];j++)\r\n      printf(\"%4d\",i);\r\n}\r\n\r\n```\r\n\r\n基数排序实现\r\n```c\r\n//略\r\n```\r\n\r\n### 多重表\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-26-22-47-09.png)\r\n\r\n### 链表的游标实现\r\n* 解决一些语言中没有指针的问题\r\n* 需要提前申请一个足够长的数组\r\n* 需要另外一个数组记录内存的分配情况\r\n* 编写函数模拟malloc() 和free()操作\r\n* malloc()就是从数组中查找出一个未被使用的位置，标记其为被占用，返回该元素的索引位置\r\n* free()操作就是标记一个区域为未被占用\r\n* 链表的指针域存储的是索引值\r\n```c\r\n//略\r\n```\r\n\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第3章_3.栈","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-26T06:50:00.000Z","modified":"2022-05-26T21:34:18.337Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":60,"countWords":954,"readSeconds":95.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第3章_3.栈\r\n* 栈(stack)是限制插入和删除只能在一个位置上进行的表\r\n* 栈有时也被叫做LIFO表（先进后出）\r\n* 栈的基本操作\r\n  + Push进栈（压入）\r\n  + Pop出栈（弹出）\r\n* 对空栈进行Pop操作被认为是栈ADT的错误\r\n* Push操作直到空间用尽被认为是现实错误，但不是ADT错误\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-01-52-09.png)\r\n\r\n## 栈的链表实现\r\n* 优点：所有操作花费常数时间\r\n* 缺点：对malloc和free的开销是昂贵的\r\n  + 解决办法：使用第二个栈来避免，当弹出第一个栈中元素时，将被弹出元素放到第二个栈中，待到下一次第一个栈中需要压入元素时，先去检查第二个栈是否为空，不为空则拿出一个存储空间来使用，以此节省调用malloc的开销。\r\n* Stack.h\r\n\r\n```c\r\n#ifndef _Stack_h\r\n#define _Stack_h\r\n\r\n#define ElementType int\r\n\r\nstruct Node;\r\ntypedef struct Node* ptrToNode;\r\ntypedef ptrToNode Stack;\r\n\r\n\r\nint IsEmpty(Stack S);\r\nStack CreatStack(void);\r\nvoid DisposeStack(Stack S);\r\nvoid MakeEmpty(Stack S);\r\nvoid Push(ElementType X,Stack S);\r\nElementType Top(Stack S);\r\nvoid Pop(Stack S); \r\n\r\n#endif\r\n```\r\n\r\n* Stack.c\r\n\r\n```c\r\n#include\"Stack.h\"\r\n#include<stdlib.h>\r\nstruct Node\r\n{\r\n    ElementType Element;\r\n    ptrToNode Next;\r\n};\r\n\r\nint IsEmpty(Stack S)\r\n{\r\n    return S->Next==NULL;\r\n}\r\nStack CreatStack(void)\r\n{\r\n    Stack temp;\r\n    temp = malloc(sizeof(struct Node));\r\n    if (temp==NULL)\r\n        return FatalError(\"error:out of space!!!\");\r\n    temp->Next=NULL;\r\n    MakeEmpty(temp);\r\n    return temp;\r\n}\r\nvoid DisposeStack(Stack S);\r\nvoid MakeEmpty(Stack S)\r\n{\r\n    if (S==NULL)\r\n        return FatalError(\"error:must use creatStack first\");\r\n    while (!IsEmpty(S))\r\n        Pop(S);\r\n}\r\nvoid Push(ElementType X,Stack S)//S是头元素的指针\r\n{\r\n    Stack newElement=malloc(sizeof(struct Node));\r\n    if (newElement==NULL)\r\n        return FatalError(\"error:out of space!!!\");\r\n    newElement->Element=X;\r\n    newElement->Next=S->Next;\r\n    S->Next=newElement;\r\n}\r\nElementType Top(Stack S)\r\n{\r\n    if (isEmpty(S))\r\n    {\r\n        FatalError(\"Empty Stack\");\r\n        return 0;//return value used to avoid warning\r\n    }\r\n    return S->Element;\r\n}\r\nvoid Pop(Stack S)\r\n{\r\n    ptrToNode first;\r\n    if (isEmpty(S))\r\n    {\r\n        FatalError(\"Empty Stack\");\r\n        return;\r\n    }\r\n    first=S->Next;\r\n    S->Next=S->Next->Next;\r\n    free(first);\r\n} \r\n\r\nFatalError(char*p)\r\n{\r\n    printf(\"%s\\n\",p);\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n## 栈的数组实现\r\n* 是一种比较流行的方法\r\n* 优点：避免了使用指针\r\n* 缺点：需要提前指定数组的大小\r\n* `TopOfStack`为-1表示空栈\r\n* 压入元素时`TopOfStack+=1`，`stack[TopOfStack]=X`\r\n* 弹出元素时`return stack[TopOfStack--]`\r\n* 栈应该不止一个，栈的元素应该对其他程序不可见，所以栈应该避免使用全局变量表示。\r\n* 栈的执行效率非常高\r\n* 栈的错误检测影响栈的执行效率\r\n* 除了一些对栈的错误处理非常重要的场合（操作系统），省略栈的错误检测是惯用手法\r\n* 可以声明一个很大的栈使其不至于POP一个空栈，但在当程序非常庞大时，忽略错误检测是不妥的，因为对于整个程序而言栈的错误检测花费的时间很少\r\n\r\n* Stack.h\r\n```c\r\n#ifndef Stack_H\r\n#define Stack_H\r\n\r\n#define ElementType int\r\n\r\nstruct StackRecord;\r\ntypedef struct StackRecord* Stack;\r\n\r\nint IsEmpty(Stack S);\r\nint IsFull(Stack S);\r\nStack CreatStack(int MaxElements);\r\nvoid DisposeStack(Stack S);\r\nvoid MakeEmpty(Stack S);\r\nvoid Push(ElementType X,Stack S);\r\nElementType Top(Stack S);\r\nvoid Pop(Stack S);\r\nElementType TopAndPop(Stack S);\r\n\r\n#endif\r\n```\r\n* Stack.c\r\n```c\r\n#include\"Stack.h\"\r\n#include<stdio.h>\r\n#define EmptyTOS (-1)\r\n#define MinStackSize (5)\r\n\r\nstruct StackRecord\r\n{\r\n    int Capacity;\r\n    int TopOfStack;\r\n    ElementType *Arry;\r\n};\r\n\r\nint IsEmpty(Stack S)\r\n{\r\n    return S->TopOfStack<=EmptyTOS;\r\n}\r\nint IsFull(Stack S)\r\n{\r\n    return S->TopOfStack>=S->Capacity-1;\r\n}\r\nStack CreatStack(int MaxElements)\r\n{\r\n    Stack S;\r\n    if(MaxElements<MinStackSize)\r\n    {\r\n        Error(\"Stack size is too small\");\r\n        return 0;\r\n    }\r\n    S = malloc(sizeof(struct StackRecord));\r\n    if(S==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return 0;\r\n    }\r\n    S->Arry=malloc(sizeof(ElementType)*MaxElements);\r\n    if (S->Arry==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return 0;\r\n    }\r\n    S->Capacity=MaxElements;\r\n    MakeEmpty(S);\r\n    return S;\r\n}\r\nvoid DisposeStack(Stack S)\r\n{\r\n    if (S!=NULL)\r\n    {\r\n        free(S->Arry);\r\n        free(S);\r\n    }\r\n}\r\nvoid MakeEmpty(Stack S)\r\n{\r\n    S->TopOfStack=EmptyTOS;\r\n}\r\nvoid Push(ElementType X,Stack S)\r\n{\r\n    if (isFull(S))\r\n    {\r\n        Error(\"Full Stack\");\r\n        return;\r\n    }else\r\n        S->Arry[++S->TopOfStack]=X;\r\n}\r\nElementType Top(Stack S)\r\n{\r\n    if (isEmpty(S))\r\n    {\r\n        Error(\"Empty Stack\");\r\n        return 0;\r\n    }\r\n    return S->Arry[S->TopOfStack];\r\n}\r\nvoid Pop(Stack S)\r\n{\r\n    if (isEmpty(S))\r\n    {\r\n        Error(\"Empty Stack\");\r\n        return;\r\n    }\r\n    S->TopOfStack--;\r\n}\r\nElementType TopAndPop(Stack S)\r\n{\r\n    if (isEmpty(S))\r\n    {\r\n        Error(\"Empty Stack\");\r\n        return 0;\r\n    }\r\n    return S->Arry[S->TopOfStack--];\r\n}\r\nError(char*p)\r\n{\r\n    printf(\"%s\\n\",p);\r\n}\r\n```\r\n\r\n### 应用\r\n* 平衡符号\r\n* 后缀表达式\r\n* 函数调用\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 栈ADT的递归运用\r\n# 队列ADT\r\n# 队列ADT在操作系统和算法设计中的应用\r\n\r\n\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第3章_4.队列","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-26T09:48:30.000Z","modified":"2022-05-27T09:16:54.972Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":61,"countWords":897,"readSeconds":89.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第3章_4.队列\r\n* 队列（queue）也是表\r\n* 队列的插入操作在一端进行，删除操作在另一端进行\r\n* 队列的基本操作\r\n  + Enqueue()入列，在表末尾（队尾rear）插入一个元素\r\n  + Dequeue()出列，删除或返回表头（对头front）元素\r\n* 队列抽象模型\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-01-53-23.png)\r\n\r\n## 队列的数组实现\r\n* 队列结构体\r\n  + 数组Queue[]\r\n  + 队列头 Front\r\n  + 队列尾 Rear\r\n  + 队列实际元素个数 Size\r\n* 入列操作：Size+=1,Rear+=1,Queue[Rear]=X;\r\n* 出列操作：Size-=1;return Queue[Front++];\r\n* 警惕：\r\n  + 出列操作时检测队列是否为空很重要\r\n  + 如果队列的大小是计算得出的，需要考虑一些特殊情况，修改代码时也需要更仔细\r\n* 潜在问题：队列满了之后怎么办？\r\n  + 解决方法：循环数组（circular array）实现,Front或Rear达到数组尾部时，使其绕回到开头位置。\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-43-40.png)\r\n\r\n### 具体实现\r\n```c\r\n//Queue.h\r\n#ifndef Queue_H\r\n#define Queue_H\r\n\r\n#define ElementType int\r\n\r\nstruct QueueRecord;\r\ntypedef struct QueueRecord* Queue;\r\n\r\nint IsEmpty(Queue Q);\r\nint IsFull(Queue Q);\r\nQueue CreatQueue(int MaxElements);\r\nvoid DisposeQueue(Queue Q);\r\nvoid MakeEmpty(Queue Q);\r\nvoid Enqueue(ElementType X,Queue Q);\r\nvoid Dequeue(Queue Q);\r\nElementType GetFront(Queue Q);\r\nElementType GetFrontAndDequeue(Queue Q);\r\n#endif\r\n```\r\n\r\n```c\r\n//Queue.c\r\n#include\"Queue.h\"\r\n#include<stdlib.h>\r\n#define MinQueueSize (10)\r\n\r\nstruct QueueRecord\r\n{\r\n    int Capacity;\r\n    int Front;\r\n    int Rear;\r\n    int Size;\r\n    ElementType *Array;\r\n};\r\n\r\nint IsEmpty(Queue Q)\r\n{\r\n    return Q->Size <= 0;\r\n}\r\nint IsFull(Queue Q)\r\n{\r\n    return Q->Size >= Q->Capacity;\r\n}\r\nQueue CreatQueue(int MaxElements)\r\n{\r\n    if (MaxElements<MinQueueSize)\r\n    {\r\n        Error(\"Queue size is too small\");\r\n    }\r\n    \r\n    Queue Q=malloc(sizeof(struct QueueRecord));\r\n    if (Q==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return;\r\n    }\r\n    Q->Array = malloc(sizeof(ElementType)*MaxElements);\r\n    if (Q->Array==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return;\r\n    }\r\n    MakeEmpty(Q);\r\n    return Q;\r\n}\r\nvoid DisposeQueue(Queue Q)\r\n{\r\n    if (Q!=NULL)\r\n    {   \r\n        if (Q->Array!=NULL)\r\n            free(Q->Array);\r\n        free(Q);\r\n    }\r\n}\r\nvoid MakeEmpty(Queue Q)\r\n{\r\n    Q->Size=0;\r\n    Q->Front=1;//Rear被初始化为0，意味着入列一个元素后，第一个元素的位置是1\r\n    Q->Rear=0;\r\n}\r\n\r\nvoid Enqueue(ElementType X,Queue Q)\r\n{\r\n    if (!IsFull(Q))\r\n    {\r\n        Q->Rear = getNextPosition(Q->Rear,Q);\r\n        Q->Array[Q->Rear]=X;\r\n        Q->Size++;\r\n    }\r\n    Error(\"Queue is full\");\r\n}\r\nvoid Dequeue(Queue Q)\r\n{\r\n    if (!isEmpty(Q))\r\n    {\r\n        Q->Front = getNextPosition(Q->Front,Q);\r\n        Q->Size--;\r\n        return;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nElementType GetFront(Queue Q)\r\n{\r\n    if (!isEmpty(Q))\r\n    {\r\n        return Q->Array[Q->Front];\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nElementType GetFrontAndDequeue(Queue Q)\r\n{\r\n    if (!isEmpty(Q))\r\n    {\r\n        ElementType temp = Q->Array[Q->Front];\r\n        Q->Front = getNextPosition(Q->Front,Q);\r\n        Q->Size--;\r\n        return temp;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nstatic Error(char *str)\r\n{\r\n    printf(\"%s\\n\",str);\r\n}\r\nstatic int getNextPosition(int Position,Queue Q)\r\n{\r\n    if(++Position >= Q->Capacity)\r\n        Position=0;\r\n    return Position;\r\n}\r\n\r\n```\r\n## 队列的链表实现\r\n```c\r\n//Queue.h\r\n#ifndef Queue_H\r\n#define Queue_H\r\n\r\n#define ElementType int\r\n\r\nstruct QueueRecord;\r\ntypedef struct QueueRecord* Queue;\r\n\r\nint IsEmpty(Queue Q);\r\nint IsFull(Queue Q);\r\nQueue CreatQueue();\r\nvoid DisposeQueue(Queue Q);\r\nvoid MakeEmpty(Queue Q);\r\nvoid Enqueue(ElementType X,Queue Q);\r\nvoid Dequeue(Queue Q);\r\nElementType GetFront(Queue Q);\r\nElementType GetFrontAndDequeue(Queue Q);\r\n#endif\r\n\r\n```\r\n\r\n```c\r\n//Queue.c\r\n\r\n#include\"Queue.h\"\r\n#include<stdio.h>\r\n\r\ntypedef struct \r\n{\r\n    ElementType Element;\r\n    Node *Next;\r\n    Node *Ahead;\r\n}Node;\r\n\r\nstruct QueueRecord\r\n{\r\n    int Size;\r\n    Node *Front;\r\n    Node *Ended;\r\n};\r\n\r\nint IsEmpty(Queue Q)\r\n{\r\n    return Q->Size<=0;\r\n}\r\nQueue CreatQueue()\r\n{\r\n    Queue Q=malloc(sizeof(struct QueueRecord));\r\n    if (Q!=NULL)\r\n    {\r\n        Q->Front=0;\r\n        Q->Ended=0;\r\n        return Q;    \r\n    }\r\n    Error(\"out of memory\");\r\n    return 0;\r\n}\r\nvoid DisposeQueue(Queue Q)\r\n{\r\n    Node *temp=Q->Front;\r\n    while (temp!=NULL)\r\n    {\r\n        temp=temp->Next;\r\n        free(temp->Ahead);\r\n    }\r\n    free(Q);\r\n}\r\nvoid MakeEmpty(Queue Q)\r\n{\r\n    Node *temp=Q->Front;\r\n    while (temp!=NULL)\r\n    {\r\n        temp=temp->Next;\r\n        free(temp->Ahead);\r\n    }\r\n    Q->Size=0;\r\n    Q->Ended=NULL;\r\n    Q->Front=NULL;\r\n}\r\nvoid Enqueue(ElementType X,Queue Q)\r\n{\r\n    Node *temp=malloc(sizeof(Node));\r\n    if (temp==NULL)\r\n    {\r\n        Error(\"out of memory\");\r\n        return;\r\n    }\r\n    temp->Element=X;\r\n    \r\n    if (Q->Front==NULL)\r\n    {\r\n        Q->Front=temp;\r\n    }\r\n    if (Q->Ended==NULL)\r\n    {\r\n        Q->Ended=temp;\r\n    }\r\n    \r\n    temp->Ahead=Q->Ended;\r\n    temp->Next=NULL;\r\n    \r\n    Q->Ended=temp;\r\n\r\n    Q->Size++;\r\n}\r\nvoid Dequeue(Queue Q)\r\n{\r\n    if (!IsEmpty(Q))\r\n    {\r\n        Node *temp = Q->Front->Next;\r\n        free(Q->Front);\r\n        Q->Front=temp;\r\n        Q->Size--;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nElementType GetFront(Queue Q)\r\n{\r\n    if (!IsEmpty(Q))\r\n    {\r\n        return Q->Front->Element;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\nElementType GetFrontAndDequeue(Queue Q)\r\n{\r\n    if (!IsEmpty(Q))\r\n    {\r\n        ElementType Element=Q->Front->Element;\r\n        Node *temp = Q->Front->Next;\r\n\r\n        free(Q->Front);\r\n        Q->Front=temp;\r\n        Q->Size--;\r\n\r\n        return Element;\r\n    }\r\n    Error(\"Queue is Empty\");\r\n}\r\n\r\n```\r\n\r\n## 队列的应用\r\n* 打印机的任务\r\n* 网络文件服务器的访问顺序，先请求先访问\r\n* 传呼系统\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_1.树的概念","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-27T01:24:41.000Z","modified":"2022-05-28T20:35:41.330Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":63,"countWords":1153,"readSeconds":115.3,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_1.树的概念\r\n* 对于大量输入数据，线性链表访问时间太慢不宜使用。\r\n* 树的大部分操作运行时间平均为O(log N)\r\n\r\n## 一些相关概念\r\n* **定义**\r\n  + 定义树的方式有多种\r\n  + 定义树的一种方式是递归的方式（类似于定义一个基准情况，然后自己定义自己）\r\n* **组成**\r\n  + 一棵树是一些**节点**的集合，该集合可以是空集。\r\n  + 一棵树由**根(root)节点**和0个子树或多个非空的**子树**组成\r\n  + 子树的根被一条来自根节点的有向的**边edge**所连接。(根节点指向子节点的边)\r\n  + 一棵树是N个节点和N-1条边的集合，其中一个节点叫做根\r\n  + **一个节点可有0个或多个子节点**\r\n* **称呼**\r\n  + 根节点是其下属的子树根节点的**父亲(parent)**\r\n  + 子树的根节点是父节点的**儿子(child)**\r\n  + 没有子节点的节点称为**树叶(leaf)**\r\n  + 有相同父节点的节点称为**兄弟(sibling)**\r\n  + 祖父grandparent、孙子grandchild关系以此类推\r\n+ **路径** \r\n  + 子节点到父节点之间的路径长度为其边数，也就是1\r\n  + 如果前一个节点是后一个节点的父节点，N1到Nk的路径长度为K-1,也就是该路径上的边数\r\n  + 一个节点从自己到自己的路径长度为0,可以理解为经过了0条边\r\n+ **深度**\r\n  + **某节点**的深度为根节点到该节点唯一路径的长\r\n  + **根节点**的深度为0\r\n  + **一棵树**的深度等于这棵树最深的树叶的深度，同时也等于这棵树的高\r\n+ **高度**\r\n  + **某节点**的高度为从该节点到最深叶节点的路径的长\r\n  + **叶节点**的高度为0\r\n  + **一棵树**的高度等于其根节点的高，也等于其最深叶节点的深度\r\n+ **一个树的深度等于它的最深的树叶的深度;该深度总是等于这棵树的高。**\r\n+ **祖先、真祖先**\r\n  + N1节点到N2节点存在一条路径，那么N1是N2的一位**祖先**ancestor，N2是N1的一个**后裔**descentdant\r\n  + N1节点到N2节点存在一条路径，**且N1!=N2**，那么N1是N2的一位**真祖先**proper ancestor，N2是N1的一个**真后裔**proper descentdant\r\n\r\n## 树的实现\r\n* **理想的实现方式：** 根节点拥有多个指针域分别指向其多个子节点\r\n  + **缺点：** 子节点个数是未知的，无法提前预知需要多少个指针域\r\n* **实际的实现方式：** 每个节点只有两个指针域，一个指向其子节点，另一个指向其兄弟节点\r\n```c\r\ntypedef struct TreeNode* PtrToNode;\r\nstruct TreeNode\r\n{\r\n  ElementType Element;//数据域\r\n  PtrToNode FirstChild;//指向其第一个子节点\r\n  PtrToNode NextSibling;//指向其兄弟节点\r\n};\r\n```\r\n* **各节点的逻辑关系**\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-01-24-54.png)\r\n* **各节点中指针的实际指向**\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-01-24-38.png)\r\n\r\n## 树的应用及其遍历\r\n* **unix文件系统**\r\n  + unix文件系统的目录中有一个指针指向本身，还有一个指针指向父目录，所以严格来说unix文件系统是类树(treeLike)结构.\r\n* 根据深度打印tab个数，文件名，换行符号\r\n* 一种遍历策略称为**先序遍历（preorder traversal）**。在先序遍历中，对当前所在节点的处理工作是在其子节点之前进行(pre)的\r\n* 另一种遍历策略称之为**后序遍历（postorder traversal）**。也就是先处理当前节点的子节点，再来处理当前节点。\r\n  + 应用：计算文件夹内文件的大小\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-02-30-27.png)\r\n\r\n### 先序遍历\r\n* 代码\r\n```c\r\nvoid ListDirectory(DirectoryFile D)\r\n{\r\n  ListDir(D,0);\r\n}\r\n\r\nstatic void ListDir(DirectoryFile D,int Depth)\r\n{\r\n  if(D是一条合法记录)//D是文件夹或文件\r\n  {\r\n    Print(D,Depth);//根据深度打印tab个数，文件名，换行符\r\n    if(D是一个文件夹)\r\n      for(C=getFirstChild(D);C!=NULL;C=getNextChild(D))//遍历\r\n        ListDir(C,Depth+1);\r\n  }\r\n}\r\n\r\n```\r\n* 遍历结果\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-02-42-17.png)\r\n\r\n### 后序遍历\r\n* 代码实现\r\n```c\r\nint SizeDirectory(DirectoryOrFile D)\r\n{\r\n  int totle=0;\r\n  if(D是文件或文件夹)\r\n  {\r\n    if(D是文件)\r\n    {\r\n      totle=FileSize(D);\r\n    }\r\n    for(C=getFirstChild(D);C!=NULL;C=getNextChild(D))\r\n    {\r\n      totle+=SizeDirectory(D);\r\n    }\r\n    Print(D,totle);\r\n  }\r\n  return totle;\r\n}\r\n\r\n```\r\n* 输出结果\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-03-14-24.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_10.B树","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-10-11T07:24:05.000Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":72,"countWords":155,"readSeconds":15.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# B树\r\n* B树有多种定义，\r\n  * 有的定义要求数据存储在树叶上，\r\n  * 有的定义允许数据存储在树叶和节点内部\r\n* B树不是二叉查找树\r\n* 阶(深度)为M的树的特征\r\n  * 根是一片叶子 或 根的儿子数在**2～M**之间（最少为2 最多为M）\r\n  * 除根外，非树叶节点的儿子数**M/2～M**之间 \r\n  * 所有的树叶在**相同的深度上**\r\n\r\n## B树特点\r\n* 所有的数据存储在树叶上\r\n* 节点包含指向各子节点的指针，分别指向其子树中最小关键值\r\n\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_2.二叉树的概念","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-27T11:22:35.000Z","modified":"2022-05-31T00:23:01.121Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":62,"countWords":147,"readSeconds":14.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_2.二叉树的概念\r\n* 二叉树（binary tree）\r\n* 每个节点最多拥有两个子节点\r\n* 有N个节点的二叉树平均深度为O(√N)\r\n* 二叉查找树的平均深度为O(log N)\r\n* 画图时，用圆圈和直线表示，因为二叉树实际上是图（graph）\r\n* 最差情况下其深度为N-1\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-04-00-27.png)\r\n\r\n## 具体实现\r\n* **构成：** 一个值域两个指针域\r\n```c\r\n#define ElementType int\r\ntypedef struct TreeNode * ptrToNode;\r\ntypedef struct ptrToNode * Tree;\r\nstruct TreeNode\r\n{\r\n  ElementType Element;\r\n  ptrToNode Left;\r\n  ptrToNode Right;\r\n};\r\n```\r\n\r\n\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_3.表达式树","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-27T13:18:06.000Z","modified":"2022-05-28T20:26:14.083Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":64,"countWords":689,"readSeconds":68.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_3.表达式树\r\n## 二叉树的应用\r\n* 表达式树\r\n* 查找\r\n* 编译器设计\r\n\r\n## 表达式树(expression tree)\r\n* 树叶是操作数（operand），常量或变量\r\n* 根是操作符（operator）,单目或双目或三目运算符\r\n  + 对于单目运算符，一个节点有一个叶子；\r\n  + 双目运算符，一个节点有两个叶子；\r\n  + 三目运算符，一个节点有三片叶子。\r\n* 通过递归可以计算一个节点的两个子树的值，从而得到两个操作数的具体值。\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-04-41-02.png)\r\n\r\n### 几种打印输出方式\r\n* **打印输出中缀表达式(infix expression)：**\r\n    + 这种递归方式称为**中序遍历（inorder traversal）** ,先处理左节点，在处理当前所在节点元素，然后再处理右节点。\r\n    + 递归时的打印输出顺序为：左括号、左表达式、操作符号、右表达式、右括号\r\n    + 输出结果大概为：```（（A+(B * C))+(（ ( d * e ) + f ） * g)）```\r\n\r\n*  **打印输出后缀表达式：** \r\n    + 这种递归方式称为**后序遍历（postorder traversal）**\r\n    + 递归时的打印输出顺序为：左操作数、右操作数、操作符\r\n    + 输出结果大概为：``a b c * + d e * f +g *+``\r\n\r\n*  **打印输出前缀表达式：** \r\n    + 这种递归方式称为**先序遍历（preorder traversal）**\r\n    + 递归时的打印输出顺序为：操作符 左操作数、右操作数、\r\n    + 输出结果大概为：``+ + a * b c * + * d e f g``\r\n\r\n## 一种将后缀表达式转变为表达式树的算法\r\n* 算法步骤：\r\n  1. 扫描输入字符\r\n  1. 输入是数字，\r\n      1. 构建表达式树，\r\n      1. 存入操作数，\r\n      1. 对该树的地址执行入栈操作\r\n  1. 输入是双目操作符，\r\n      1. 构建一个表达式树，\r\n      1. 存入操作符，\r\n      1. 执行两次出栈操作，\r\n      1. 将出栈的两棵树挂到表达式树上，\r\n      1. 再对该树的地址执行入栈操作\r\n  1. 循环执行上述步骤，直至字符读取完\r\n  1. 弹出栈顶地址，该地址就是该表达式树的指针\r\n\r\n* **书中演示的过程：**\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-05-10-55.png)\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-05-11-06.png)\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-05-11-22.png)\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-05-11-31.png)\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-05-11-39.png)\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-05-11-46.png)\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-05-11-55.png)\r\n\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_4.二叉查找树","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-27T13:22:27.000Z","modified":"2022-05-31T06:05:19.539Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":65,"countWords":2219,"readSeconds":221.9,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_4.二叉查找树\r\n\r\n## 二叉树的应用\r\n* 表达式树\r\n* 查找\r\n* 编译器设计\r\n\r\n## 查找树ADT————二叉查找树binary search tree\r\n* **二叉查找树binary search tree**\r\n* 查找是二叉树的重要应用\r\n* 使二叉树成为查找树的性质是：\r\n  + 树中每个节点X的**左子树**中的**所有(包括子树的子树)** 关键字**小于**节点X的关键字\r\n  + 树中每个节点X的**右子树**中的**所有(包括子树的子树)** 关键字**大于**节点X的关键字\r\n  + ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-21-40-24.png)\r\n\r\n## 二叉查找树ADT\r\n  + 由于树的递归定义，其例程通常也是递归编写的\r\n  + 由于二叉树的平均深度是O(log N),也不必担心栈空间耗尽\r\n  + 其删除操作可能导致树的不平衡，因为在处理**被删除的节点有两个子节点的情况**时，其删除策略总是从左或右子树中挑选一个最大或最小的元素删除。\r\n    + 解决办法：通过随机决定\r\n\r\n### 几个需要简略讨论一下的操作\r\n* **MakeEmpty**操作\r\n  + 用于初始化\r\n  + 根据树的递归定义，该操作倾向于认为树没有头节点，所以其操作过程为，先递归为左右两子树释放内存，然后再释放当前节点的内存。\r\n* **Find**操作\r\n  + 返回树种具有某关键字的节点的指针\r\n  + 如果该节点不存在则返回NULL\r\n  + 需要首先对当前所在树的指针进行测试，判断是否为一个空树\r\n  + 其余测试应该安排最不可能的情况最后进行\r\n* **FindMin**和**FindMax**操作\r\n  + 为了与**Find**操作相统一,其返回值是元素的地址而不是元素的值\r\n* **Insert**操作\r\n  + 插入过程是递归进行的；\r\n  + 若插入的元素已经存在，可以什么都不做，也可以提前使节点记录中保留一个域用于记录插入的次数。\r\n  + 若插入的元素不存在，找到了合适的位置就为新树分配内存，初始化该树，赋值\r\n  + 返回值时新树的地址\r\n  + 返回值为树地址意味着可以用该函数创建一棵树\r\n* **Delete**操作\r\n  + 书中delete函数的写法`SearchTree Delete(ElementType X,SearchTree T);`\r\n  + 我的delete函数的写法`SearchTree Delete(ElementType X,SearchTree T,Position Parent);`\r\n    + 主要是考虑到父节的指针域需要修改\r\n  + 需要谨慎考虑返回值，因为如果删除了根节点，整颗树的地址将丢失，所以定义返回值被删除后所在位置元素的地址\r\n  + 和许多数据结构一样，删除操作是最难的。需要考虑多种情况\r\n  + **如果被删除的节点是一个树叶**\r\n    1. 查找值为9的节点\r\n    1. 发现没有子节点，所以直接删除该节点\r\n    1. 同时将其父节点相应的指针域设置NULL\r\n    1. 返回值：NULL\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-29-02-25-13.png)\r\n  + **如果被删除的节点有一个子节点**\r\n    1. 查找值为7的节点\r\n    1. 发现有一个子节点，所以记录下其子节点的指针，然后删除当前所在节点\r\n    1. 同时将其父节点相应的指针域设置为当前所在节点的子节点的指针\r\n    1. 返回值为：子节点地址\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-29-02-38-32.png)\r\n  + **如果被删除的节点有两个子节点**\r\n    1. 查找值为7的节点\r\n    1. 发现有两个子节点，所以找到其继承人，将继承人的值复制到当前位置，然后通过递归调用删除继承人节点\r\n        + 寻找继承人就是在左子树中寻找最大值也就是4，或者就是在右子树中寻找最小值也就是8\r\n        + 递归调用删除元素8的过程，会按照**如果被删除的节点有一个子节点的情况**处理，总之元素8会被删除，元素10的左树指针域将会指向元素9\r\n    1. 返回值为：当前所在节点的地址\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-29-02-43-48.png)\r\n\r\n### 二叉查找树ADT实现\r\n```c\r\n//SearchTree.h\r\n#ifndef _Tree_H_\r\n#define _Tree_H_\r\ntypedef int ElementType;\r\nstruct TreeNode;\r\ntypedef struct TreeNode* Position;\r\ntypedef struct TreeNode* SearchTree;\r\n\r\nSearchTree MakeEmpty(SearchTree T);\r\nPosition Find(ElementType X,SearchTree T);\r\nPosition FindMin(SearchTree T);\r\nPosition FindMax(SearchTree T);\r\nSearchTree Insert(ElementType X,SearchTree T);\r\nSearchTree Delete(ElementType X,SearchTree T,Position Parent);\r\nElementType Retrieve(Position P);\r\n#endif\r\n\r\n```\r\n\r\n```c\r\n//SearchTree.c\r\n#include \"SearchTree.h\"\r\n#include<stdlib.h>\r\nstruct TreeNode\r\n{\r\n    ElementType Element;\r\n    SearchTree Left;\r\n    SearchTree Right;\r\n};\r\n\r\nSearchTree MakeEmpty(SearchTree T)\r\n{\r\n    if (T!=NULL)\r\n    {\r\n        MakeEmpty(T->Left);\r\n        MakeEmpty(T->Right);\r\n        free(T);\r\n    }\r\n}\r\nPosition Find(ElementType X,SearchTree T)\r\n{\r\n    if (T==NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (X < T->Element)\r\n    {\r\n        return Find(X,T->Left);\r\n    }else\r\n    if (X > T->Element)\r\n    {\r\n        return Find(X,T->Right);\r\n    }\r\n    else\r\n        return T;\r\n}\r\nPosition FindMin(SearchTree T)//递归实现\r\n{\r\n    if(T==NULL)\r\n        return NULL;\r\n\r\n    if (T->Left==NULL)//没有左子树，说明已经到达该树的最深处\r\n        return T;\r\n    else\r\n        return FindMin(T->Left);\r\n}\r\nPosition FindMax(SearchTree T)//非递归方式实现\r\n{\r\n    if (T==NULL)\r\n        return NULL;\r\n\r\n    while (T->Right!=NULL)\r\n        T=T->Right;\r\n    return T;\r\n}\r\nSearchTree Insert(ElementType X,SearchTree T)\r\n{\r\n    if (T==NULL)\r\n    {\r\n        T = malloc(sizeof(struct TreeNode));\r\n        if (T == NULL)\r\n            Error(\"out of memory\");\r\n        T->Element = X;\r\n        T->Left = NULL;\r\n        T->Right = NULL;\r\n        return T;\r\n    }\r\n\r\n    if (X < T->Element)\r\n        return Insert(X,T->Left);\r\n    else\r\n    if (X > T->Element)\r\n        return Insert(X,T->Right);\r\n    else//X==T->Element\r\n        ;//T->Element.Count++\r\n\r\n    return T;\r\n}\r\nSearchTree Delete(ElementType X,SearchTree T,Position Parent)\r\n{\r\n    if (T==NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (X < T->Element)\r\n    {\r\n        return Delete(X,T->Left,T);\r\n    }else\r\n    if(X > T->Element)\r\n    {\r\n        return Delete(X,T->Right,T);\r\n    }else//查找到该节点\r\n    {\r\n        if (T->Left && T->Right)//如果该节点有两个子节点\r\n        {\r\n            Position successor;//继承人\r\n            successor=FindMin(T->Right);//继承人就是左子树中最大值，或者就是右子树中最小值\r\n            T->Element=successor->Element;//替换值\r\n            Delete(successor->Element,T->Right,T);//查找并删除继承人原先的所在的位置(递归调用)\r\n            return T;//想象删除的是整颗树的根节点，返回值应该是什么？不管是什么，一定不会是其父节点的地址\r\n        }\r\n        else//如果该节点有0个子节点,那么使当前父节点相应的指针域为NULL,同时释放当前节点的内存\r\n        if(T->Left==NULL && T->Right==NULL)\r\n        {\r\n            if (Parent!=NULL)//重新指定父节点指针\r\n            {\r\n                if(Parent->Left==T)\r\n                    Parent->Left=NULL;\r\n                else\r\n                    Parent->Right=NULL;\r\n            }\r\n            free(T);\r\n            T=NULL;\r\n            return T;\r\n        }else//否则就是只有一个子节点,那么找出当前节点的唯一子节点，使当前节点的父节点的相应的指针域指向当前所在节点的子节点，然后删除当前所在子节点\r\n        {\r\n            Position onlyChild=T->Left==NULL? T->Right:T->Left;\r\n            if (Parent!=NULL)//重新指定父节点指针\r\n            {\r\n                if(Parent->Left==T)\r\n                    Parent->Left=onlyChild;\r\n                else\r\n                    Parent->Right=onlyChild;\r\n            }\r\n            free(T);\r\n            T=onlyChild;\r\n            return T;\r\n        }\r\n    }\r\n}\r\nElementType Retrieve(Position P)\r\n{\r\n    if (P!=NULL)\r\n    {\r\n        return P->Element;\r\n    }\r\n    return 0;\r\n}\r\n```\r\n\r\n### 我写的Delete例程\r\n```c\r\nSearchTree Delete(ElementType X,SearchTree T,Position Parent)\r\n{\r\n    if (T==NULL)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    if (X < T->Element)\r\n    {\r\n        return Delete(X,T->Left,T);\r\n    }else\r\n    if(X > T->Element)\r\n    {\r\n        return Delete(X,T->Right,T);\r\n    }else//查找到该节点\r\n    {\r\n        if (T->Left && T->Right)//如果该节点有两个子节点\r\n        {\r\n            Position successor;//继承人\r\n            successor=FindMin(T->Right);//继承人就是左子树中最大值，或者就是右子树中最小值\r\n            T->Element=successor->Element;//替换值\r\n            Delete(successor->Element,T->Right,T);//查找并删除继承人原先的所在的位置(递归调用)\r\n            return T;//想象删除的是整颗树的根节点，返回值应该是什么？不管是什么，一定不会是其父节点的地址\r\n        }\r\n        else//如果该节点有0个子节点,那么使当前父节点相应的指针域为NULL,同时释放当前节点的内存\r\n        if(T->Left==NULL && T->Right==NULL)\r\n        {\r\n            if (Parent!=NULL)//重新指定父节点指针\r\n            {\r\n                if(Parent->Left==T)\r\n                    Parent->Left=NULL;\r\n                else\r\n                    Parent->Right=NULL;\r\n            }\r\n            free(T);\r\n            T=NULL;\r\n            return T;\r\n        }else//否则就是只有一个子节点,那么找出当前节点的唯一子节点，使当前节点的父节点的相应的指针域指向当前所在节点的子节点，然后删除当前所在子节点\r\n        {\r\n            Position onlyChild=T->Left==NULL? T->Right:T->Left;\r\n            if (Parent!=NULL)//重新指定父节点指针\r\n            {\r\n                if(Parent->Left==T)\r\n                    Parent->Left=onlyChild;\r\n                else\r\n                    Parent->Right=onlyChild;\r\n            }\r\n            free(T);\r\n            T=onlyChild;\r\n            return T;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 书中给出的Delete例程(难以理解)\r\n```c\r\n        SearchTree\r\n        Delete( ElementType X, SearchTree T )\r\n        {\r\n            Position TmpCell;\r\n\r\n            if( T == NULL )\r\n                Error( \"Element not found\" );\r\n            else\r\n            if( X < T->Element )  /* Go left */\r\n                T->Left = Delete( X, T->Left );\r\n            else\r\n            if( X > T->Element )  /* Go right */\r\n                T->Right = Delete( X, T->Right );\r\n            else  /* Found element to be deleted */\r\n            if( T->Left && T->Right )  /* Two children */\r\n            {\r\n                /* Replace with smallest in right subtree */\r\n                TmpCell = FindMin( T->Right );\r\n                T->Element = TmpCell->Element;\r\n                T->Right = Delete( T->Element, T->Right );//？？？？？？难以理解？？？？？？\r\n            }\r\n            else  /* One or zero children */\r\n            {\r\n                TmpCell = T;\r\n                if( T->Left == NULL ) \r\n                    T = T->Right;\r\n                else if( T->Right == NULL )\r\n                    T = T->Left;\r\n                //上述两个if将会使得T的值被修改，如果T没有子树，T的值为NULL,如果T有一个子树，T的值为子树的地址\r\n                free( TmpCell );\r\n            }\r\n\r\n            return T;\r\n        }\r\n```\r\n\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_5.平衡树的概念","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-30T16:18:26.000Z","modified":"2022-05-31T00:36:11.025Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":67,"countWords":287,"readSeconds":28.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_5.平衡树的概念\r\n## 平衡树\r\n* 将一个有序的数据插入到一颗空的二叉树中，插入完成后，二叉树将会变得没有左节点只有右节点，也就是说退化成了链表。而链表的插入操作，往一个长度为n的有序链表中插入一个数据，其平均时间复杂度为O(n)，那么插入n个数据，将会花费二次时间。\r\n* **解决办法：**要有一个附加的**平衡(balance)结构的条件:任何节点的深度不得过深**\r\n* **较老的实现平衡树方法**\r\n  * 算法大部分都比标准二叉查找树复杂\r\n  * 更新平均也要花费更长的时间\r\n  * 最老的一种平衡查找树就是**AVL树**\r\n* **较新的实现平衡树方法**\r\n  + 放弃平衡条件，允许树有任意深度\r\n  + 为使后续操作更高效，每次操作之后要**根据调整规则进行调整**\r\n  + 这种数据结构属于自调整类结构(self-adjusting)\r\n  + **伸展树(splay tree)** 就是这种数据类型，其分析相当复杂 \r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_6.AVL树","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-05-28T12:31:53.000Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":66,"countWords":2611,"readSeconds":261.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_6.AVL树\r\n\r\n## AVL树 \r\n* **AVL(Adelson-Velskii and Landis)树**,名字取自其发明者**G.M.Adelson-Velsky**和**E.M. Landis**的首字母\r\n* 是一种带有**平衡条件**的**二叉查找树**\r\n* **是最老的一种平衡树**\r\n* 这个平衡条件**必须要容易保持**，且**必须保证树的深度**是O(log N)\r\n* **在每个节点中记录高度信息**\r\n* 通常定义**空子树的高度为-1**\r\n  + 高度为-1的AVL树，意味着应该有0个节点\r\n  + 高度为0的AVL树，意味着应该有1个节点，0个子树\r\n  + 高度为1的AVL树，意味着应该有1或2个叶子。\r\n  + 空树的高度为-1的约定实际上在AVL树中有一些实际用途,因为它简化了平衡因子的计算以及何时旋转子代。\r\n* **每个节点的左子树和右子树高度最多相差1**\r\n  + 不符合该要求的不是AVL树![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-11-18-54.png)\r\n\r\n## 一些不好的平衡条件：\r\n+ 一种是要求**根节点**的**左右子树**具有**相同的高度**\r\n  + **不强求深度要浅**\r\n  + 最坏情况：![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-29-07-06-48.png)\r\n  + 根据定义允许的情况：![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-09-04-11.png)\r\n+ 另一种树要求**每个节点**的**左右子树**的**高度必须相同**\r\n  + 能够保证树的深度，但条件过于严格\r\n\r\n## **AVL树高度h和节点数S(h)之间的关系**\r\n+ 讨论这个关系的意义在于明确高度为h时AVL树的节点数的界(下界、上界)\r\n+ 高度为-1的树,节点数至少为0 至多为0\r\n  + **Min(S(-1))=0**\r\n  + **Max(S(-1))=0**\r\n  + 左图为反映了至少有多少个节点，\r\n  + 右图反映了至多有多少个节点，\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-19-50.png)\r\n+ 高度为 0的树,节点数至少为1 至多为1\r\n  + **Min(S(0))=1**\r\n  + **Max(S(0))=1**\r\n  + 左图为反映了至少有多少个节点，\r\n  + 右图反映了至多有多少个节点，\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-19-26.png)\r\n+ 高度为 1的树,节点数至少为2 至多为3\r\n  + Min(S(**1**))=Min(S(**0**))+Min(S(**-1**))+1=2\r\n  + Max(S(**1**))=Max(S(**0**))+Max(S(**0**))+1=3\r\n  + 左图为反映了至少有多少个节点，其中树的左子树就是n-1的情况 右子树是n-2的情况\r\n  + 右图反映了至多有多少个节点，其中树的左子树和右子树都是n-1的情况\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-11-48-10.png)\r\n+ 高度为 2的树,节点数至少为4 至多为7\r\n  + Min(S(**2**))=Min(S(**1**))+Min(S(**0**))+1=4\r\n  + Max(S(**2**))=Max(S(**1**))+Max(S(**1**))+1=7\r\n  + 左图为反映了至少有多少个节点，其中树的左子树就是n-1的情况 右子树是n-2的情况\r\n  + 右图反映了至多有多少个节点，其中树的左子树和右子树都是n-1的情况\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-12-54.png)\r\n+ 高度为 3的树,节点数至少为7 至多为5\r\n  + Min(S(**3**))=Min(S(**2**))+Min(S(**1**))+1=7\r\n  + Max(S(**3**))=Max(S(**2**))+Max(S(**2**))+1=5\r\n  + 左图为反映了至少有多少个节点，其中树的左子树就是n-1的情况 右子树是n-2的情况\r\n  + 右图反映了至多有多少个节点，其中树的左子树和右子树都是n-1的情况\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-11-51.png)\r\n+ 高度为 4的树,节点数至少为4+7+1=12 至多为5+5+1=11\r\n  + Min(S(**4**))=Min(S(**3**))+Min(S(**2**))+1=12\r\n  + Max(S(**4**))=Max(S(**3**))+Max(S(**3**))+1=11\r\n  + 左图为反映了至少有多少个节点，其中树的左子树就是n-1的情况 右子树是n-2的情况\r\n  + 右图反映了至多有多少个节点，其中树的左子树和右子树都是n-1的情况\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-12-06-39.png)\r\n+ 所以可以总结出其关系类似于斐波那契数列，\r\n  + 定义S(-1)=0;S(0)=1;高度为h的AVL树的节点数至少为：**S(h)=S(h-1)+S(h-2)+1**\r\n  + 定义S(-1)=0;S(0)=1;高度为h的AVL树的节点数至多为：**S(h)=S(h-1)+S(h-1)+1**\r\n+ 若问：高度为9的AVL树至少有多少个节点、至多有多少个？\r\n  若定义S(-1)=0;S(0)=1;\r\n  则至少有min(S(9))=min(S(9-1))+min(S(9-2))+1个节点\r\n  至多有max(S(9))=max(S(9-1))+max(S(9-1))+1个节点\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-31-13-22-18.png)\r\n\r\n## 时间复杂度\r\n* 除去插入操作外（并且假设删除操作是懒惰删除），所有树的操作都可以以时间$O(log N)$执行\r\n  * 这里的懒惰删除是指删除时只是将节点标记为删除，不去真的删除这个节点\r\n* 插入操作存在困难的原因在于，插入一个节点后可能会破坏AVL树的平衡\r\n  * 如果这种情况发生，需要执行操作恢复AVL树的平衡，这样插入操作才算结束\r\n  + 这种操作称为**旋转（rotation）**\r\n\r\n## 旋转\r\n* 对于一个节点a,插入元素前是平衡的，插入后该节点不平衡了，也就是说其子树的高度相差2，出现这种情况的可能一共有四种\r\n  1. 对a的左儿子的左子树进行了插入操作\r\n  1. 对a的右儿子的右子树进行了插入操作\r\n  1. 对a的左儿子的右子树进行了插入操作\r\n  1. 对a的右儿子的左子树进行了插入操作\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-03-22-34.png)\r\n\r\n### 单旋转\r\n* 对于前两种情况可以使用单旋转使树恢复平衡\r\n* 具体操作就是（下图），将K1的右子树Y分给k2使其变成k2的左子树，然后将k2变成k1的右子树\r\n* 这么操作之后不影响元素的大小顺序\r\n* 整棵树的高度和插入前保持一致，所以不会影响其他部分的平衡情况（因为这整颗树可能是另一颗树的子树）\r\n* 使用单旋转对前两种情况使树恢复平衡![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-28-38.png)\r\n* 关于左单旋、右单旋名称的由来\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-01-09-18-34.png)\r\n* 插入示例\r\n  * 插入3、2、1\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-06-29.png)\r\n  * 插入4、5\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-06-55.png)\r\n  * 插入6\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-08-15.png)\r\n  * 插入7\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-08-41.png)\r\n\r\n### 双旋转\r\n* 对于后两种情况无法使用单旋转使树恢复平衡\r\n![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-18-22.png)\r\n* 需要使用双旋转恢复平衡\r\n* 具体操作就是（下图），将k2的两个节点看成是两颗树（其中一颗一定是空的），将这两颗树分别分给k1和k3,然后将k1和k3分别变成k2的左右子树\r\n* 这么操作之后不影响元素的大小顺序\r\n* 整棵树的高度和插入前保持一致，不会影响其他部分的平衡情况\r\n* 使用双旋转对前两种情况恢复平衡![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-27-28.png)\r\n* 对于双旋转名称的个人理解\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-06-23-14.png)\r\n* 插入示例\r\n  * 插入16、15\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-35-52.png)\r\n  * 插入7、14\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-37-04.png)\r\n  * 插入13\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-37-30.png)\r\n  * 插入12\r\n  ![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-06-02-04-39-03.png)\r\n\r\n## 单旋转、双旋转操作总结\r\n* 步骤：\r\n  1. 将关键字X插入到AVL树T中，递归地将X插入到T相应的子树(称$T_{LR}$)中，如果插入后$T_{LR}$高度不变，则完成插入操作\r\n  1. 否则判断T是否出现高度不平衡，如果依然平衡，则完成插入操作\r\n  1. 如果不平衡则根据情况做相应的单旋转或双旋转，更新高度，则完成插入操作\r\n* 递归与非递归的效率问题\r\n  * 因为一次旋转操作就能解决问题，所以效率上编写的非递归的程序会快很多。\r\n  * “非递归程序编写正确是相当困难的”，许多人还在用递归方式实现AVL树\r\n* 高度信息的存储的效率问题\r\n  + 存储子树高度差\r\n    + 由于真正需要的是子树的高度差，所以可以用两个二进位（存储0 -1 +1）来表示这个差\r\n    + 优点：这么做可以避免平衡因子的重复计算\r\n    + 缺点：\r\n      + 丧失了简明性\r\n      + 程序也会比原先更复杂\r\n    + 评价：\r\n      + 采取这种方式获得的速度优势难以抵消清晰度和相对简明性的损失”\r\n      + 由于大部分机器的最小存储单位是8bit,“因此所用的空间量不可能有任何差别”\r\n        + 意思是指就算你想用2bit来存储这个差，最后计算机也是用8bit来存储。\r\n  + 存储自身的高度\r\n    + 8bit能表示的树的高度高达255，再由于树是平衡的，书中的观点认为这是：“不可想象这会少到不够用”————够用的。\r\n"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_7.AVL树的实现","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-06-01T13:54:05.000Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":68,"countWords":748,"readSeconds":74.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# 第4章_7.AVL树的实现\r\n* **AvlTree.h**\r\n```c\r\n#ifndef _AvlTree_H_\r\n#define _AvlTree_H_\r\n\r\ntypedef int ElementType;\r\nstruct AvlTreeNode;\r\ntypedef struct AvlTreeNode *Position;\r\ntypedef struct AvlTreeNode *AvlTree;\r\n\r\nAvlTree MakeEmpty(AvlTree T);\r\nAvlTree Insert(ElementType X,AvlTree T);//插入操作应该返回根节点地址，所以返回值是树\r\nAvlTree Delete(ElementType X,AvlTree T);//同上\r\nPosition Find(ElementType X,AvlTree T);\r\nPosition FindMax(AvlTree T);\r\nPosition FindMin(AvlTree T);\r\nElementType Retrieve(Position P);\r\n#endif\r\n```\r\n\r\n* **AvlTree.c**\r\n```c\r\n//      不是标准答案，可能会有错\r\n//      另外Delete操作会比Insert操作还要复杂，书中暂未讨论\r\n//      如果Delete操作采用懒惰删除的话，需要注意修改查找和插入操作的判断条件\r\n#include \"AvlTree.h\"\r\n#include <stdlib.h>\r\nstruct AvlTreeNode\r\n{\r\n    ElementType Element;\r\n    int Hight;\r\n    AvlTree Left;\r\n    AvlTree Right;\r\n};\r\n\r\nAvlTree MakeEmpty(AvlTree T)\r\n{\r\n    if (T != NULL)\r\n    {\r\n        MakeEmpty(T->Left);\r\n        MakeEmpty(T->Right);\r\n        free(T);\r\n    }\r\n    return T;\r\n}\r\nAvlTree Insert(ElementType X, AvlTree T) //插入操作应该返回根节点地址，所以返回值是树\r\n{\r\n    if (T==NULL)\r\n    {\r\n        T=malloc(sizeof(struct AvlTreeNode));\r\n        if(T==NULL)\r\n            FatalError(\"out of memory\");\r\n        T->Element=X;\r\n        T->Hight=0;\r\n    }else if(X<T->Element)\r\n    {\r\n        T->Left=Insert(X,T->Left); //插入进左子树\r\n        if(Hight(T->Left)-Hight(T->Right)==2) //左子树高减右子树高\r\n            if(X<T->Left->Element) //判断是否插入在了左子树的左子树\r\n                T=singleRotateToRight(T);\r\n            else //否则插入在了左子树的右子树\r\n                T=doubleRotateToRight(T);\r\n    }else if(X>T->Element)\r\n    {\r\n        T->Right=Insert(X,T->Right);\r\n        if(Hight(T->Right)-Hight(T->Left)==2)\r\n            if(X>T->Right->Element)\r\n                T=singleRotateToLeft(T);\r\n            else\r\n                T=doubleRotateToLeft(T);\r\n    }else if(X==T->Element)\r\n        ;\r\n    \r\n    // 如果其最高子树是一颗空树(-1) 那么当前树的高度应该是-1+1=0\r\n    // 如果其最高子树是一片叶子(0) 那么当前树的高度应该是0+1=1\r\n    // 如果其最高子树有一片叶子(1) 那么当前树的高度应该是1+1=1\r\n    T->Hight = MAX(Hight(T->Left),Hight(T->Right)) + 1;\r\n    return T;\r\n}\r\nAvlTree Delete(ElementType X, AvlTree T)\r\n{\r\n}\r\nPosition Find(ElementType X, AvlTree T)\r\n{\r\n    if (T == NULL)\r\n        return T;\r\n    else if (X < T->Element)\r\n        return Find(X, T->Left);\r\n    else if (X > T->Element)\r\n        return Find(X, T->Right);\r\n    else\r\n        return T;\r\n}\r\nPosition FindMax(AvlTree T)\r\n{\r\n    if (T == NULL)\r\n        return T;\r\n    else if (T->Right == NULL)\r\n        return T;\r\n    else\r\n        return FindMax(T->Right);\r\n}\r\nPosition FindMin(AvlTree T)\r\n{\r\n    if (T == NULL)\r\n        return T;\r\n    else if (T->Left == NULL)\r\n        return T;\r\n    else\r\n        return FindMin(T->Left);\r\n}\r\nElementType Retrieve(Position P)\r\n{\r\n    return P != NULL ? P->Element : 0;\r\n}\r\nstatic int MAX(int a,int b)\r\n{\r\n    return a>b? a:b;\r\n}\r\nstatic int Hight(AvlTree T)\r\n{\r\n    if (T==NULL)\r\n        return -1;\r\n    else\r\n        return T->Hight;\r\n}\r\n\r\nstatic AvlTree singleRotateToRight(AvlTree T)\r\n{   //调整指针\r\n    AvlTree newRoot=T->Left;\r\n    T->Left=newRoot->Right;\r\n    newRoot->Right=T;\r\n    //更新高度时应该先更新子节点再更新根节点\r\n    T->Hight=MAX(Hight(T->Left),Hight(T->Right))+1;\r\n    newRoot->Hight=MAX(Hight(newRoot->Left),Hight(newRoot->Right))+1;\r\n    return newRoot;\r\n}\r\n\r\nstatic AvlTree singleRotateToLeft(AvlTree T)\r\n{   //调整指针\r\n    AvlTree newRoot=T->Right;\r\n    T->Right=newRoot->Left;\r\n    newRoot->Left=T;\r\n    //更新高度时应该先更新子节点再更新根节点\r\n    T->Hight=MAX(Hight(T->Left),Hight(T->Right))+1;\r\n    newRoot->Hight=MAX(Hight(newRoot->Left),Hight(newRoot->Right))+1;\r\n    return newRoot;\r\n}\r\n\r\nstatic AvlTree doubleRotateToRight(AvlTree T)\r\n{\r\n    T->Left=singleRotateToLeft(T->Left);//先对根节点的左子树做右旋操作\r\n    return singleRotateToRight(T);//再对根节点做左旋操作\r\n}\r\n\r\nstatic AvlTree doubleRotateToLeft(AvlTree T)\r\n{\r\n    T->Right=singleRotateToRight(T->Right);//先对根节点的左子树做左旋操作\r\n    return singleRotateToLeft(T);//再对根节点做右旋操作\r\n}\r\n```"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_8.伸展树","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-06-06T02:00:05.000Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":69,"countWords":581,"readSeconds":58.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# 伸展树\r\n* **基本想法：** 访问一个节点后，通过一系列的旋转操作将该节点放到根节点上，这样这个节点和这条路径上的所有节点的深度就会降低，下一次访问所花费的时间就会更少。\r\n* 不需要保存或计算高度信息和平衡信息\r\n* 它保证从空树开始任意连续M次对树的操作最多花费 $O(MlogN)$ \r\n* 但不保证某次操作花费$O(N)$时间的可能，\r\n* 这种单次最坏$O(N)$的时间花费虽不如平均最坏花费$O(logN)$时间短，但实际效果是一样的：不存在坏的输入序列\r\n* 当M次操作的序列总的最坏情形运行时间为$O(MF(N))$时，称它的摊还运行时间为$O(F(N))$,因此一颗伸展树每次操作的摊还代价是$O(logN)$\r\n    * 摊还分析用来评价某个数据结构的一系列操作的平均代价，有时可能某个操作的代价特别高，但总体上来看也并非那么糟糕，可以形象的理解为把高代价的操作“分摊”到其他操作上去了，要求的就是均摊后的平均代价。\r\n\r\n## 展开操作Splaying\r\n* 展开操作类似于AVL的旋转操作\r\n* 不过在旋转如何实施上稍微有了选择的余地\r\n* 仍然**从底部向上沿着访问路径旋转**\r\n* 令X是在访问路径上的一个（非根）节点，在这个路径上实施旋转操作。\r\n* 如果X的父节点是根节点，则只需要旋转X和根节点。这就是沿着访问路径上的最后的旋转。\r\n* 否则,X就有父节点P和祖父节点G,这样就有四种情形\r\n    * zig-zig X是P的左子树，P是G的左子树\r\n    * zag-zag X是P的右子树，P是G的右子树\r\n    * zig-zag X是P的右子树，P是G的左子树\r\n    * zag-zig X是P的左子树，P是G的右子树\r\n* ![](./images/《数据结构与算法分析》学习笔记/2022-06-06-15-15-30.png)\r\n\r\n* 对节点1做展开操作的示例\r\n![](./images/《数据结构与算法分析》学习笔记/2022-06-06-15-16-22.png)"},{"shortInfo":{"title":"《数据结构与算法分析》第4章_9.树的遍历","cover":"\\self_server\\assets\\images\\《数据结构与算法分析》学习笔记\\cover.png","coverWidth":813,"coverHeight":539,"date":"2022-06-06T07:24:05.000Z","tags":["《数据结构与算法分析》","笔记"],"hideAtIndex":true,"categories":"笔记","id":70,"countWords":304,"readSeconds":30.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 树的遍历\r\n\r\n## 中序遍历\r\n* 中序遍历，先遍历左子树，再处理当前节点，再遍历右子树。\r\n* 由于二叉树中对信息进行了排序，因而按照排序的顺序列出所有关键字会很简单。\r\n* 下面为采用**中序遍历**的递归方式实现\r\n    * 由于在每个节点的花费都是常数时间，共N个节点，所以整个操作的时间复杂度为$O(N)$\r\n\r\n```c\r\nvoid PrintTree(SearchTree T)\r\n{\r\n    if(T!=NULL)\r\n    {\r\n        PrintTree(T->Left);\r\n        PrintElement(T->Element);\r\n        PrintTree(T->Right);\r\n    }\r\n}\r\n```\r\n\r\n## 后序遍历\r\n* 后续遍历，先遍历子节点，后处理当前节点\r\n* 采用**后序遍历**计算树的高度的例子,时间复杂度也是$O(N)$\r\n\r\n```c\r\nint Height(AVLTree T)\r\n{\r\n    if(T==NULL)\r\n        return -1;\r\n    else\r\n        return 1 + Max(Height(T->Left),Height(T->Right));\r\n}\r\n```\r\n\r\n## 先序遍历\r\n* 当前节点在子节点之前被处理\r\n* 可以利用节点深度标志每一个节点，可以用来打印目录结构\r\n\r\n![](./images/《数据结构与算法分析》学习笔记/2022-06-06-15-44-54.png)\r\n\r\n## 层序遍历(level-order traversal)\r\n* 深度为D的节点要在深度为D+1的节点之前处理\r\n* 不是使用递归编写\r\n* 需要用到队列\r\n"},{"shortInfo":{"title":"使用原生js实现轮播图","date":"2022-07-05T21:55:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["轮播图","js"],"categories":"笔记","id":73,"countWords":4936,"readSeconds":493.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 使用原生js实现轮播图\r\n\r\n## [-->最终效果<--](./demos/index.html)\r\n\r\n## 实现的功能\r\n* **自动切换** ，当切换到最后一张时，切换方式将由 从前往后 切换自动改为 从后往前 切换\r\n* **自动暂停** ，当鼠标移动到banner图上时，暂停自动播放，鼠标离开时，恢复自动播放\r\n* **手动切换** ，\r\n    * 点击按钮`》`，实现切换到下一张，当切换到最后一张时，停止切换\r\n    * 点击按钮`《`，实现切换到上一张，当切换到第前一张时，停止切换\r\n    * 节流处理：频繁点击切换按钮时，仅允许切换一张，切换完毕后才允许切换下一张\r\n* **任意切换** ，点击底部圆点时，切换到相对应的图片\r\n* **PC端鼠标拖动切换**\r\n    * 鼠标左右拖动图片，移动到一定的阈值后松开鼠标，\r\n        * 允许鼠标移动到图片之外（通过嵌套，给document添加事件监听器和移除事件监听器实现）\r\n        * 允许鼠标松开时在图片之外（通过嵌套，给document添加事件监听器和移除事件监听器实现）\r\n    * 如达到指定阈值，且移动的方向有另一张图片，则切换到该图片\r\n    * 如未达到指定阈值，或移动的方向没有图片，则恢复原位\r\n* **移动端手指拖动切换**\r\n    * 功能及判断逻辑如上\r\n\r\n## 碰到的问题总结\r\n### 问题1：`ul>li`一行排列的问题\r\n* 在`.box>ul>li`的结构中，若想设置：\r\n    * `.box`有宽高\r\n    * `li`有宽高，一行排列\r\n* 有两种解决方案\r\n    1. 给`ul`设置一个很大的宽度，给li设置左浮动\r\n        * 优点是`li`之间没有任何间距\r\n        * 缺点是要设置宽度,如果设置的不好或`li`过多会造成`li`的换行排列\r\n    1. 给ul设置`white-space:nowrap;`，给li设置行内块，\r\n        * 优点是不用设置`ul`宽度\r\n        * 缺点是`li`之间会有由源代码中换行符造成的间隔\r\n\r\n### 问题2：确定下一个li的问题\r\n* 在ul>li的结构中，需要确定下一次需要展示的li是谁，\r\n* 同时需要考虑当展示最后一个li是，下一个待展示的li是谁\r\n\r\n**我的解决方案**  \r\n写一个函数，循环获取下一个子元素，  \r\n如：若一个元素中有子元素1，2，3，4；  \r\n则该函数每次调用将分别获取的元素为:1->2->3->4->3->2->1->2->3->4->3->2->1->2\r\n\r\n\r\n```js\r\n//循环获取下一个子元素\r\nfunction getNextActivedElement(elementObj){//如有子元素1，2，3，4 则该该函数返回的是 1->2->3->4->3->2->1->2->3->4->3->2->1....\r\n    if(!elementObj.activedLiIndex)//若activedLiIndex属性不存在则对其初始化\r\n    {\r\n        elementObj.activedLiIndex=0;//初始化索引为第一个元素\r\n    }\r\n    if(!elementObj.moveguide)//若moveguide属性不存在则对其初始化\r\n    {\r\n        elementObj.moveguide=\"forward\";//初始化移动方向为向右\r\n    }\r\n    if(elementObj.moveguide==\"forward\")//移动方向是向前\r\n    {\r\n        if(elementObj.children[elementObj.activedLiIndex].nextElementSibling)//如果能够找到下一个元素\r\n        {\r\n            elementObj.activedLiIndex+=1;//索引定位到下一个\r\n        }else{//如果找不到下一个元素\r\n            elementObj.moveguide=\"backward\";//设置移动方向为往前\r\n            elementObj.activedLiIndex-=1;//索引定位到前一个\r\n        }\r\n    }else{//移动方向是向后\r\n        if(elementObj.children[elementObj.activedLiIndex].previousElementSibling)//如果能够找到前一个元素\r\n        {\r\n            elementObj.activedLiIndex-=1;//索引定位到前一个\r\n        }else{\r\n            elementObj.moveguide=\"forward\";//设置移动方向为往后\r\n            elementObj.activedLiIndex+=1;//索引定位到下一个\r\n        }\r\n    }\r\n    return elementObj.children[elementObj.activedLiIndex];\r\n}\r\n```\r\n\r\n### 问题3：移动距离\r\n在`.banner>ul>li`的结构中，移动的是`ul`，移动距离应该是`-li[index].offsetLeft`\r\n\r\n### 问题4：无缝滚动的问题\r\n* 当前由于实现思路的问题暂时没有做无缝滚动的效果\r\n* 若要做无缝滚动效果，需要在最后一个li之后添加第一个li的拷贝，\r\n* 如图，当做完动画3->1的切换后，直接设置ul的偏移为0，使得显示第一张图片\r\n\r\n![](./images/js轮播图/2022-07-06-20-09-37.png)\r\n\r\n\r\n### 问题4：节流阀\r\n节流阀用于防止事件触发的过快，导致上一个事件还未处理完又去处理下一个事件\r\n```\r\nrightBtn.addEventListener(\"click\",function(){\r\n    if(!rightBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        rightBtn.flag=true;//打开节流阀\r\n        if(!bannerUl.activedLiIndex)\r\n        {   //第一次调用则初始化新属性\r\n            bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n        }\r\n        if(bannerUl.children[bannerUl.activedLiIndex].nextElementSibling)//如果该元素存在后一个兄弟元素\r\n        {\r\n            bannerUl.activedLiIndex+=1;//索引+1\r\n            //根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                rightBtn.flag=false;//关闭节流阀\r\n            })\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n### 问题5：鼠标移入banner效果\r\n* 鼠标移入banner则暂停自动播放  \r\n* 鼠标离开banner则启动自动播放\r\n\r\n**实现代码**\r\n```js\r\n//自动播放\r\nvar autoSwitch = null;\r\n//开启自动播放\r\nfunction startAutoSwitch(){\r\n    stopAutoSwitch();//先清除定时器\r\n    autoSwitch = setInterval(function(){\r\n        //循环获取下一个li\r\n        var nextLi = getNextActivedElement(bannerUl)\r\n        //将ul移动，偏移量为li的负offset\r\n        animate(bannerUl,-nextLi.offsetLeft)\r\n        //更新底部Ul状态\r\n        updataBottomUl(nextLi.dataset[\"index\"])\r\n    },5000);\r\n}\r\n//关闭自动播放\r\nfunction stopAutoSwitch(){\r\n    clearInterval(autoSwitch)\r\n}\r\n//运行自动播放\r\nstartAutoSwitch();\r\n//鼠标移入banner则暂停自动播放\r\nbanner.addEventListener(\"mouseenter\",function(){\r\n    stopAutoSwitch();\r\n})\r\n//鼠标离开banner则启动自动播放\r\nbanner.addEventListener(\"mouseleave\",function(){\r\n    startAutoSwitch();\r\n})\r\n```\r\n\r\n### 问题6：对前后切换轮播图功能的进一步封装\r\n\r\n该部分功能在切换轮播图的按钮功能及拖动轮播图的功能中都有使用，所以对其进行了封装\r\n\r\n**原代码**\r\n```js\r\n//鼠标点击事件\r\nleftBtn.addEventListener(\"click\",function(){\r\n    if(!leftBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        leftBtn.flag=true;//打开节流阀\r\n        if(!bannerUl.activedLiIndex)\r\n        {   //第一次调用则初始化新属性\r\n            bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n        }\r\n        if(bannerUl.children[bannerUl.activedLiIndex].previousElementSibling)//如果该元素存在前一个兄弟元素\r\n        {\r\n            bannerUl.activedLiIndex-=1;//索引-1\r\n            //根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                leftBtn.flag=false;//关闭节流阀\r\n            })\r\n        }\r\n    }\r\n})\r\nrightBtn.addEventListener(\"click\",function(){\r\n    if(!rightBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        rightBtn.flag=true;//打开节流阀\r\n        if(!bannerUl.activedLiIndex)\r\n        {   //第一次调用则初始化新属性\r\n            bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n        }\r\n        if(bannerUl.children[bannerUl.activedLiIndex].nextElementSibling)//如果该元素存在后一个兄弟元素\r\n        {\r\n            bannerUl.activedLiIndex+=1;//索引+1\r\n            //根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                rightBtn.flag=false;//关闭节流阀\r\n            })\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n\r\n**封装后**\r\n```js\r\n//鼠标点击事件\r\nleftBtn.addEventListener(\"click\",function(){\r\n    if(!leftBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        moveToPrevious(function(){\r\n            // 根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //播放动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                rightBtn.flag=false;//关闭节流阀\r\n            })\r\n        });\r\n    }\r\n})\r\nrightBtn.addEventListener(\"click\",function(){\r\n    if(!rightBtn.flag)//节流阀：防止频繁触发事件\r\n    {\r\n        rightBtn.flag=true;//打开节流阀\r\n        moveToNext(function(){\r\n            // 根据Index值更新底部li\r\n            updataBottomUl(bannerUl.activedLiIndex)\r\n            //播放动画\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                //回调函数：\r\n                rightBtn.flag=false;//关闭节流阀\r\n            })\r\n        });\r\n    }\r\n});\r\nfunction moveToNext(callback){//如果能获取到下一个兄弟元素则修改Index否则保持不变\r\n    if(!bannerUl.activedLiIndex)\r\n    {   //第一次调用则初始化新属性\r\n        bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n    }\r\n    if(bannerUl.children[bannerUl.activedLiIndex].nextElementSibling)//如果该元素存在后一个兄弟元素\r\n    {\r\n        bannerUl.activedLiIndex+=1;//索引+1\r\n    }\r\n    callback && callback();\r\n}\r\nfunction moveToPrevious(callback){//如果能获取到上一个兄弟元素则修改Index否则保持不变\r\n    if(!bannerUl.activedLiIndex)\r\n    {   //第一次调用则初始化新属性\r\n        bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n    }\r\n    if(bannerUl.children[bannerUl.activedLiIndex].previousElementSibling)//如果该元素存在后一个兄弟元素\r\n    {\r\n        bannerUl.activedLiIndex-=1;//索引-1\r\n    }\r\n    callback && callback();\r\n}\r\n```\r\n\r\n\r\n\r\n### 问题7：鼠标拖动翻页功能实现\r\n实现思路：\r\n* 在鼠标点击时记录鼠标坐标`A`，同时记录轮播图在x轴的偏移offsetLeft(`C`)，\r\n* 在鼠标移动时再记录坐标B，  \r\n* 两个坐标差`(B-A)`就是轮播图需要在x轴上相对于原先位置C的偏移的距离，\r\n* 于是`轮播图.Left = C + (B-A) + \"px\"`\r\n* 鼠标弹起时，根据鼠标移动距离是否超过某阈值，最终决定是否移动\r\n\r\n注意点：\r\n* 鼠标按下时，记录相关坐标，同时添加下述两个监听器\r\n* 鼠标移动，应当允许鼠标离开轮播图界面，所以该监听器应当添加给document\r\n* 鼠标弹起，应当允许鼠标离开轮播图界面，所以该监听器应当添加给document\r\n    * 鼠标弹起后，移除这两个监听器\r\n* 上述两个添加给document的监听器应当在整个完整的效果结束时移除，否则在点击网页其他部分时，鼠标弹起是任然会触发该事件\r\n\r\n**核心代码**\r\n\r\n```js\r\n// Pc端鼠标拖动banner>ul效果\r\nbannerUl.addEventListener(\"mousedown\",function(e){\r\n    stopAutoSwitch();//暂停自动播放\r\n    bannerUl.mosedownStartPos = e.clientX ;//鼠标按下时的坐标\r\n    bannerUl.mosedownoffsetLeft = bannerUl.offsetLeft;//鼠标按下时，bannerUl的offsetleft\r\n    document.addEventListener(\"mousemove\",bannerUlMoveWithMouse)//添加事件监听鼠标移动，实现拖动效果\r\n    document.addEventListener(\"mouseup\",bannerUlMoveWithMouseToCorrectPos)//添加事件监听鼠标弹起，实现拖动归位效果\r\n    function bannerUlMoveWithMouse(e){\r\n        //鼠标移动的距离\r\n        bannerUl.mosedownMoveGap = e.clientX  - bannerUl.mosedownStartPos; \r\n        // 新偏移 = 原偏移 + 鼠标移动距离\r\n        bannerUl.style.left = bannerUl.mosedownoffsetLeft + bannerUl.mosedownMoveGap + \"px\"\r\n    }\r\n    function bannerUlMoveWithMouseToCorrectPos (e){//将ul移动到正确的位置上\r\n        if(bannerUl.mosedownMoveGap>50)//当鼠标移动距离超过一个阈值\r\n        {\r\n            moveToPrevious(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                // 根据Index值更新底部li\r\n                updataBottomUl(bannerUl.activedLiIndex)\r\n                //播放动画\r\n                animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n            });\r\n        }\r\n        else if(bannerUl.mosedownMoveGap<-50)//当鼠标移动距离超过一个阈值\r\n        {\r\n            moveToNext(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                // 根据Index值更新底部li\r\n                updataBottomUl(bannerUl.activedLiIndex)\r\n                //播放动画\r\n                animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n            });\r\n        }else//鼠标移动没有超过设定阈值\r\n        {   //归位\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n        }\r\n        document.removeEventListener(\"mousemove\",bannerUlMoveWithMouse);//移除document的mousemove\r\n        document.removeEventListener(\"mouseup\",bannerUlMoveWithMouseToCorrectPos);//移除document的mouseup\r\n        startAutoSwitch();//恢复自动播放\r\n    }\r\n})\r\n\r\n\r\n```\r\n\r\n### 移动端手指拖动bannerul效果 \r\n**相关事件**\r\n* `touchstart` 手指按下\r\n* `touchmove` 手指移动\r\n* `touchend` 手指离开\r\n\r\n**坐标获取**\r\n* `event.targetTouches[0].pageX` 第一个手指的坐标\r\n\r\n```js\r\n// 移动端手指拖动bannerul效果\r\nbannerUl.addEventListener(\"touchstart\",function(e){\r\n    stopAutoSwitch();//暂停自动播放\r\n    bannerUl.fingerDownStartPos = e.targetTouches[0].pageX ;//手指按下时的坐标\r\n    bannerUl.fingerDownoffsetLeft = bannerUl.offsetLeft;//手指按下时，bannerUl的offsetleft\r\n    document.addEventListener(\"touchmove\",bannerUlMoveWithFinger)//添加事件监听手指移动，实现拖动效果\r\n    document.addEventListener(\"touchend\",bannerUlMoveWithFingerToCorrectPos)//添加事件监听手指离开，实现拖动归位效果\r\n    function bannerUlMoveWithFinger(e){\r\n        //手指移动的距离\r\n        bannerUl.fingerDownMoveGap = e.targetTouches[0].pageX  - bannerUl.fingerDownStartPos; \r\n        // 新偏移 = 原偏移 + 手指移动距离\r\n        bannerUl.style.left = bannerUl.fingerDownoffsetLeft + bannerUl.fingerDownMoveGap + \"px\"\r\n    }\r\n    function bannerUlMoveWithFingerToCorrectPos(e){\r\n        bannerUl.removeEventListener(\"touchmove\",bannerUlMoveWithFinger);\r\n        if(bannerUl.fingerDownMoveGap>50)//当手指移动距离超过一个阈值\r\n        {\r\n            moveToPrevious(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                // 根据Index值更新底部li\r\n                updataBottomUl(bannerUl.activedLiIndex)\r\n                //播放动画\r\n                animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n            });\r\n        }\r\n        if(bannerUl.fingerDownMoveGap<-50)//当手指移动距离超过一个阈值\r\n        {\r\n            moveToNext(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                // 根据Index值更新底部li\r\n                updataBottomUl(bannerUl.activedLiIndex)\r\n                //播放动画\r\n                animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n            });\r\n        }else//手指移动没有超过设定阈值\r\n        {   //归位\r\n            animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n        }\r\n        document.removeEventListener(\"touchmove\",bannerUlMoveWithFinger);//移除document的mousemove\r\n        document.removeEventListener(\"touchend\",bannerUlMoveWithFingerToCorrectPos);//移除document的mouseup\r\n        startAutoSwitch();//恢复自动播放\r\n    }\r\n})\r\n```\r\n\r\n\r\n## 完整代码\r\n\r\n\r\n```html\r\n<div class=\"banner\">\r\n    <ul>\r\n        <li data-active=\"true\" style=\"background-color: skyblue;\">轮播图1<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n        <li style=\"background-color: pink;\">轮播图2<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n        <li style=\"background-color: green;\">轮播图3<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n        <li style=\"background-color: yellowgreen;\">轮播图4<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n        <li style=\"background-color: gold;\">轮播图5<br>已实现同时允许pc端鼠标拖动和移动端触摸拖动切换</li>\r\n    </ul>\r\n    <span class=\"left\">《</span>\r\n    <span class=\"right\">》</span>\r\n    <div class=\"bottom\">\r\n        <ul>\r\n            <!--\r\n            <li class=\"active\"></li>\r\n            <li></li>\r\n            <li></li>\r\n            <li></li>\r\n            <li></li>\r\n            -->\r\n        </ul>\r\n    </div>\r\n</div>\r\n<style>\r\n    .banner *{\r\n        margin: 0;\r\n        padding: 0;\r\n    }\r\n    .banner *::before,\r\n    .banner *::after{\r\n        content: none !important;\r\n    }\r\n    .banner{\r\n        position: relative;\r\n        margin: 0 auto;\r\n        width: 100%;\r\n        height: 300px;\r\n        background-color: gray;\r\n        overflow: hidden;\r\n    }\r\n    .banner>ul{\r\n        position: relative;\r\n        top: 0;\r\n        /* 去除ul默认的左40px的内边距padding */\r\n        padding: 0;\r\n        /* 去除ul默认的上下外边距16px */\r\n        margin: 0;\r\n        height: 100%;\r\n        list-style: none;\r\n        white-space:nowrap;\r\n    }\r\n    .banner>ul>li{\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;\r\n        width: 100%;\r\n        background-color: pink;\r\n        vertical-align: top;\r\n        color: black;\r\n    }\r\n    .banner>.left,\r\n    .banner>.right\r\n    {\r\n        position: absolute;\r\n        display: inline-block;\r\n        width: 25px;\r\n        height: 25px;\r\n        /* background-color: gainsboro; */\r\n        cursor: pointer;\r\n        text-align: center;\r\n        vertical-align: middle;\r\n        font-size: 15px;\r\n        line-height: 25px;\r\n        color: white;\r\n    }\r\n    .banner>.left{\r\n        left: 0;\r\n        top: 50%;\r\n        transform: translate(0,-50%);\r\n    }\r\n    .banner>.right{\r\n        right: 0;\r\n        top: 50%;\r\n        transform: translate(0,-50%);\r\n    }\r\n    .banner>.bottom{\r\n        position: absolute;\r\n        bottom: 0;\r\n        left: 0;\r\n        transform: translate(0,-100%);\r\n        width: 100%;\r\n        height: 10px;\r\n        /* background-color: white; */\r\n        text-align: center;\r\n    }\r\n    .banner>.bottom>ul{\r\n        display: inline-block;\r\n        height: 10px;\r\n        /* 去除ul默认的padding,margin */\r\n        padding: 0;\r\n        margin: 0;\r\n        list-style: none;\r\n        /* background-color: green; */\r\n        /* 防止li按文字的baseline对齐 */\r\n        vertical-align: top;\r\n    }\r\n    .banner>.bottom>ul>li{\r\n        float: left;\r\n        margin: 0 5px;\r\n        height: 10px;\r\n        width: 10px;\r\n        background-color: rgb(195, 195, 195);\r\n        border-radius: 50%;\r\n        cursor: pointer;\r\n    }\r\n    .banner>.bottom>ul>li.active{\r\n        background-color: white;\r\n    }\r\n</style>\r\n<script>\r\n    (function(){\r\n        var banner = document.querySelector(\".banner\") \r\n        var bannerUl = document.querySelector(\".banner>ul\") \r\n        var bottomUl = document.querySelector(\".banner>.bottom>ul\") \r\n        var leftBtn = document.querySelector(\".banner>.left\") \r\n        var rightBtn = document.querySelector(\".banner>.right\") \r\n        //为bannerUl添加index属性\r\n        for(var i=0;i<bannerUl.childElementCount;i++)\r\n        {\r\n            bannerUl.children[i].dataset[\"index\"]=i;\r\n        }\r\n        // 为bottom>UL创建li\r\n        for(var i=0;i<bannerUl.childElementCount;i++)\r\n        {\r\n            bottomUl.appendChild(document.createElement(\"li\"))\r\n        }\r\n        // 为bottomU>li[0]添加active类名\r\n        bottomUl.children[0].classList.add(\"active\")\r\n        // 为bottomU>li添加index属性\r\n        for(var i=0;i<bottomUl.childElementCount;i++)\r\n        {\r\n            bottomUl.children[i].dataset[\"index\"]=i;\r\n        }\r\n        //自动播放\r\n        var autoSwitch = null;\r\n        //开启自动播放\r\n        function startAutoSwitch(){\r\n            stopAutoSwitch();//先清除定时器\r\n            autoSwitch = setInterval(function(){\r\n                //循环获取下一个li\r\n                var nextLi = getNextActivedElement(bannerUl)\r\n                //将ul移动，偏移量为li的负offset\r\n                animate(bannerUl,-nextLi.offsetLeft)\r\n                //更新底部Ul状态\r\n                updataBottomUl(nextLi.dataset[\"index\"])\r\n            },5000);\r\n        }\r\n        //关闭自动播放\r\n        function stopAutoSwitch(){\r\n            clearInterval(autoSwitch)\r\n        }\r\n        //运行自动播放\r\n        startAutoSwitch();\r\n        //鼠标移入banner则暂停自动播放\r\n        banner.addEventListener(\"mouseenter\",function(){\r\n            stopAutoSwitch();\r\n        })\r\n        //鼠标离开banner则启动自动播放\r\n        banner.addEventListener(\"mouseleave\",function(){\r\n            startAutoSwitch();\r\n        })\r\n        // Pc端鼠标拖动banner>ul效果\r\n        bannerUl.addEventListener(\"mousedown\",function(e){\r\n            stopAutoSwitch();//暂停自动播放\r\n            bannerUl.mosedownStartPos = e.clientX ;//鼠标按下时的坐标\r\n            bannerUl.mosedownoffsetLeft = bannerUl.offsetLeft;//鼠标按下时，bannerUl的offsetleft\r\n            document.addEventListener(\"mousemove\",bannerUlMoveWithMouse)//添加事件监听鼠标移动，实现拖动效果\r\n            document.addEventListener(\"mouseup\",bannerUlMoveWithMouseToCorrectPos)//添加事件监听鼠标弹起，实现拖动归位效果\r\n            function bannerUlMoveWithMouse(e){\r\n                //鼠标移动的距离\r\n                bannerUl.mosedownMoveGap = e.clientX  - bannerUl.mosedownStartPos; \r\n                // 新偏移 = 原偏移 + 鼠标移动距离\r\n                bannerUl.style.left = bannerUl.mosedownoffsetLeft + bannerUl.mosedownMoveGap + \"px\"\r\n            }\r\n            function bannerUlMoveWithMouseToCorrectPos (e){//将ul移动到正确的位置上\r\n                if(bannerUl.mosedownMoveGap>50)//当鼠标移动距离超过一个阈值\r\n                {\r\n                    moveToPrevious(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                        // 根据Index值更新底部li\r\n                        updataBottomUl(bannerUl.activedLiIndex)\r\n                        //播放动画\r\n                        animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                    });\r\n                }\r\n                else if(bannerUl.mosedownMoveGap<-50)//当鼠标移动距离超过一个阈值\r\n                {\r\n                    moveToNext(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                        // 根据Index值更新底部li\r\n                        updataBottomUl(bannerUl.activedLiIndex)\r\n                        //播放动画\r\n                        animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                    });\r\n                }else//鼠标移动没有超过设定阈值\r\n                {   //归位\r\n                    animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                }\r\n                document.removeEventListener(\"mousemove\",bannerUlMoveWithMouse);//移除document的mousemove\r\n                document.removeEventListener(\"mouseup\",bannerUlMoveWithMouseToCorrectPos);//移除document的mouseup\r\n                startAutoSwitch();//恢复自动播放\r\n            }\r\n        })\r\n        // 移动端手指拖动bannerul效果\r\n        bannerUl.addEventListener(\"touchstart\",function(e){\r\n            stopAutoSwitch();//暂停自动播放\r\n            bannerUl.fingerDownStartPos = e.targetTouches[0].pageX ;//手指按下时的坐标\r\n            bannerUl.fingerDownoffsetLeft = bannerUl.offsetLeft;//手指按下时，bannerUl的offsetleft\r\n            document.addEventListener(\"touchmove\",bannerUlMoveWithFinger)//添加事件监听手指移动，实现拖动效果\r\n            document.addEventListener(\"touchend\",bannerUlMoveWithFingerToCorrectPos)//添加事件监听手指离开，实现拖动归位效果\r\n            function bannerUlMoveWithFinger(e){\r\n                //手指移动的距离\r\n                bannerUl.fingerDownMoveGap = e.targetTouches[0].pageX  - bannerUl.fingerDownStartPos; \r\n                // 新偏移 = 原偏移 + 手指移动距离\r\n                bannerUl.style.left = bannerUl.fingerDownoffsetLeft + bannerUl.fingerDownMoveGap + \"px\"\r\n            }\r\n            function bannerUlMoveWithFingerToCorrectPos(e){\r\n                bannerUl.removeEventListener(\"touchmove\",bannerUlMoveWithFinger);\r\n                if(bannerUl.fingerDownMoveGap>50)//当手指移动距离超过一个阈值\r\n                {\r\n                    moveToPrevious(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                        // 根据Index值更新底部li\r\n                        updataBottomUl(bannerUl.activedLiIndex)\r\n                        //播放动画\r\n                        animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                    });\r\n                }\r\n                if(bannerUl.fingerDownMoveGap<-50)//当手指移动距离超过一个阈值\r\n                {\r\n                    moveToNext(function(){//如果能获取到下一个兄弟元素则修改activedLiIndex否则保持不变\r\n                        // 根据Index值更新底部li\r\n                        updataBottomUl(bannerUl.activedLiIndex)\r\n                        //播放动画\r\n                        animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                    });\r\n                }else//手指移动没有超过设定阈值\r\n                {   //归位\r\n                    animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft)\r\n                }\r\n                document.removeEventListener(\"touchmove\",bannerUlMoveWithFinger);//移除document的mousemove\r\n                document.removeEventListener(\"touchend\",bannerUlMoveWithFingerToCorrectPos);//移除document的mouseup\r\n                startAutoSwitch();//恢复自动播放\r\n            }\r\n        })\r\n        //手指点击事件\r\n        leftBtn.addEventListener(\"click\",function(){\r\n            if(!leftBtn.flag)//节流阀：防止频繁触发事件\r\n            {\r\n                leftBtn.flag=true;//打开节流阀\r\n                moveToPrevious(function(){\r\n                    // 根据Index值更新底部li\r\n                    updataBottomUl(bannerUl.activedLiIndex)\r\n                    //播放动画\r\n                    animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                        //回调函数：\r\n                        rightBtn.flag=false;//关闭节流阀\r\n                    })\r\n                });\r\n            }\r\n        })\r\n        rightBtn.addEventListener(\"click\",function(){\r\n            if(!rightBtn.flag)//节流阀：防止频繁触发事件\r\n            {\r\n                rightBtn.flag=true;//打开节流阀\r\n                moveToNext(function(){\r\n                    // 根据Index值更新底部li\r\n                    updataBottomUl(bannerUl.activedLiIndex)\r\n                    //播放动画\r\n                    animate(bannerUl,-bannerUl.children[bannerUl.activedLiIndex].offsetLeft,function(){\r\n                        //回调函数：\r\n                        rightBtn.flag=false;//关闭节流阀\r\n                    })\r\n                });\r\n            }\r\n        });\r\n        function moveToNext(callback){//如果能获取到下一个兄弟元素则修改Index否则保持不变\r\n            if(!bannerUl.activedLiIndex)\r\n            {   //第一次调用则初始化新属性\r\n                bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n            }\r\n            if(bannerUl.children[bannerUl.activedLiIndex].nextElementSibling)//如果该元素存在后一个兄弟元素\r\n            {\r\n                bannerUl.activedLiIndex+=1;//索引+1\r\n            }\r\n            callback && callback();\r\n        }\r\n        function moveToPrevious(callback){//如果能获取到上一个兄弟元素则修改Index否则保持不变\r\n            if(!bannerUl.activedLiIndex)\r\n            {   //第一次调用则初始化新属性\r\n                bannerUl.activedLiIndex=0;//初始化第一个激活元素为0\r\n            }\r\n            if(bannerUl.children[bannerUl.activedLiIndex].previousElementSibling)//如果该元素存在后一个兄弟元素\r\n            {\r\n                bannerUl.activedLiIndex-=1;//索引-1\r\n            }\r\n            callback && callback();\r\n        }\r\n        bottomUl.addEventListener(\"click\",function(event){\r\n            // 获取被点击li的index\r\n            var index = event.target.dataset[\"index\"]\r\n            //修改索引\r\n            bannerUl.activedLiIndex = parseInt(index)//此处需要注意数据类型\r\n            console.log(bannerUl.activedLiIndex);\r\n            //过渡动画\r\n            animate(bannerUl,-bannerUl.children[index].offsetLeft)//动画\r\n            //更新底部li\r\n            updataBottomUl(index)\r\n        })\r\n        function updataBottomUl(index){//更新底部ul状态\r\n            for(var i=0;i<bottomUl.childElementCount;i++)\r\n            {\r\n                bottomUl.children[i].classList.remove(\"active\")\r\n            }\r\n            bottomUl.children[index].classList.add(\"active\")\r\n        }\r\n        //动画函数\r\n        function animate(elementObj, target, callback) {\r\n            clearInterval(elementObj.timer)//clearInterval可以防止animate被反复调用时导致同时调用多个setInterval，致使timer被覆盖\r\n            elementObj.timer = setInterval(function () {//elementObj.timer可以避免反复申请内存\r\n                if (elementObj.offsetLeft == target) {\r\n                    clearInterval(elementObj.timer)\r\n                    if (callback) {\r\n                        callback();\r\n                    }\r\n                }\r\n                var step = (target - elementObj.offsetLeft) / 10 //根据公式计算步长\r\n                step = step > 0 ? Math.ceil(step) : Math.floor(step)//如果步长是负数则向下取整，如果步长是正数则向上取整。\r\n                elementObj.style.left = elementObj.offsetLeft + step + \"px\"\r\n            }, 15)\r\n        }\r\n        //循环获取下一个子元素\r\n        function getNextActivedElement(elementObj){//如有子元素1，2，3，4 则该该函数返回的是 1->2->3->4->3->2->1->2->3->4->3->2->1....\r\n            if(!elementObj.activedLiIndex)//若activedLiIndex属性不存在则对其初始化\r\n            {\r\n                elementObj.activedLiIndex=0;//初始化索引为第一个元素\r\n            }\r\n            if(!elementObj.moveguide)//若moveguide属性不存在则对其初始化\r\n            {\r\n                elementObj.moveguide=\"forward\";//初始化移动方向为向右\r\n            }\r\n            if(elementObj.moveguide==\"forward\")//移动方向是向前\r\n            {   \r\n                if(elementObj.children[elementObj.activedLiIndex].nextElementSibling)//如果能够找到下一个元素\r\n                {\r\n                    elementObj.activedLiIndex+=1;//索引定位到下一个\r\n                }else{//如果找不到下一个元素\r\n                    elementObj.moveguide=\"backward\";//设置移动方向为往前\r\n                    elementObj.activedLiIndex-=1;//索引定位到前一个\r\n                }\r\n            }else{//移动方向是向后\r\n                if(elementObj.children[elementObj.activedLiIndex].previousElementSibling)//如果能够找到前一个元素\r\n                {\r\n                    elementObj.activedLiIndex-=1;//索引定位到前一个\r\n                }else{\r\n                    elementObj.moveguide=\"forward\";//设置移动方向为往后\r\n                    elementObj.activedLiIndex+=1;//索引定位到下一个\r\n                }\r\n            }\r\n            return elementObj.children[elementObj.activedLiIndex];\r\n        }\r\n    })();\r\n</script>\r\n```\r\n"},{"shortInfo":{"layout":"post","title":"修改Hexo的hightlight.js语法高亮默认样式","date":"2022-02-23T17:06:00.000Z","cover":"\\self_server\\assets\\images\\hightlightjs2.png","tags":["笔记","Hexo","hightlight.js"],"hideAtIndex":true,"categories":"前端","id":74,"countWords":545,"readSeconds":54.5,"assetsbaseUrl":"/self_server/assets/"},"content":"### hightlight.js特性说明\r\n1. hightlight.js一般的使用流程\r\n```html\r\n# 导入css主题（导入的css决定配色方案）\r\n<link rel=\"stylesheet\" href=\"https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/a11y-dark.min.css\">\r\n# 导入js文件\r\n<script src=\"https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/highlight.min.js\"></script>\r\n# 调用函数\r\n<script>hljs.highlightAll();</script>\r\n# 指定为html，也可不指定\r\n<pre>\r\n    <code class=\"language-html\">\r\n        需要高亮的代码\r\n    </code>\r\n</pre>\r\n```\r\n\r\n### hexo代码高亮特性说明\r\n1. **hexo**支持代码高亮，代码封装在**hexo-util**插件中，使用的是**hightlight.js**库\r\n    * 但是**hightlight.js**本身是没有实现行号支持的，**hexo**对**hightlight.js**封装后使其支持了行号显示。\r\n1. Hexo的_config.yml配置文件中关于代码高亮的配置说明:\r\n```yml\r\n# _config.yml\r\nhighlight:              # hightlight.js语法高亮\r\n  enable: true          # true为在服务端渲染，false为在客户端渲染\r\n  hljs: true            # 为代码的class 添加 hljs- 前缀 使其能够代码高亮\r\n  auto_detect: true     # 自动检测代码块的语言\r\n  line_number: true     # 行号显示\r\n  wrap: true            # 须和和line_number一致\r\n  tab_replace: '  '     # /t制表符替换成什么\r\n# prismjs:                # 另一个语法高亮插件,主要是面向浏览器的。两语法高亮插件只需启用一个\r\n#   enable: false         # 启用 PrimeJS 前应设置 highlight.enable 为 false\r\n#   preprocess: true      # preprocess 与 line_number 均设为 true，需要引入 prism-line-numbers.css 即可启用行号显示。均设为 false，需将prism-line-numbers.css 和 prism-line-numbers.js 都引入\r\n#   line_number: true    # 是否显示行号\r\n#   tab_replace: '  '     # /t制表符替换成什么\r\n```\r\n\r\n\r\n### 修改后\r\n1. 在hexo主题的源文件中找到博客文章页面的布局文件，添加hightlight.js的css链接。\r\n    * ```<link href=\"/css/base16_dracula.min.css\" rel=\"stylesheet\">```\r\n    * ```<link href=\"https://cdn.bootcdn.net/ajax/libs/highlight.js/11.4.0/styles/base16/dracula.min.css\" rel=\"stylesheet\">```\r\n1. _config.yml中配置为：\r\n```\r\nhighlight:              # hightlight.js语法高亮\r\n  enable: true          # true为在服务端渲染，false为在客户端渲染\r\n  hljs: true            # 为代码的class 添加 hljs- 前缀 使其能够代码高亮\r\n  auto_detect: true     # 自动检测代码块的语言\r\n  line_number: false    # 行号显示\r\n  wrap: false           # 须和和line_number一致\r\n  tab_replace: '  '     # /t制表符替换成什么\r\n```\r\n1. 效果预览\r\n风格名: base16/dracula\r\n![](../images/hightlightjs2.png)"},{"shortInfo":{"title":"前端实现简易待办任务管理工具","date":"2022-07-19T17:40:00.000Z","cover":"\\self_server\\assets\\images\\前端实现简易待办任务管理工具\\2022-07-20-14-20-53.png","tags":["前端","toDoList"],"categories":"前端","id":74,"countWords":446,"readSeconds":44.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 记录前端实现的简易待办任务管理工具\r\n**简记**\r\n* 使用js在客户端动态渲染页面\r\n* 为了实现数据的大容量持久存储，使用IndexedDB数据库，数据存储在客户端\r\n* 实现了在客户端对本地数据库的增删改查\r\n* 响应式；对移动端，pc端，ipad做了兼容性适配\r\n* 使用到的技术: indexedDB JQuery bootstrap promsie LESS\r\n* 代码量：总共约2000行代码\r\n\r\n## [-->测试<--](./demos/tools/demo/index.html)\r\n\r\n## 当前实现效果\r\n\r\n### 移动端效果\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-45-18.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-45-29.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-45-50.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-45-57.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-46-03.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-48-44.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-48-51.png)\r\n\r\n### PC端效果\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-20-14.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-23-18.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-21-38.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-20-53.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-37-47.png)\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-38-30.png)\r\n\r\n![](./images/前端实现简易待办任务管理工具/2022-07-20-14-41-26.png)\r\n\r\n"},{"shortInfo":{"title":"前端常用插件及框架","date":"2022-07-06T21:27:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["前端常用插件及框架"],"hideAtIndex":true,"categories":"笔记","id":75,"countWords":116,"readSeconds":11.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 前端常用插件及框架\r\n* 插件一般是为解决某一问题而存在的，功能单一\r\n* 框架提供了完整的解决方案，框架的控制权在框架本身，使用者需按照框架的规范开发，既能开发移动端也能开发pc端\r\n\r\n## 前端常用插件\r\n* 轮播图插件网站：[swiper](https://www.swiper.com.cn/)\r\n* superslide\r\n* iscroll\r\n* zy.media.js 视频插件\r\n\r\n## 前端常用框架\r\n* bootstrap\r\n* Vue\r\n* Angular\r\n* React"},{"shortInfo":{"title":"前端本地存储","date":"2022-07-06T22:03:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["前端本地存储"],"hideAtIndex":true,"categories":"笔记","id":76,"countWords":501,"readSeconds":50.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# 前端本地存储\r\n\r\n## 特性\r\n* 数据存储在用户浏览器中\r\n* 设置、读取方便，关闭浏览器不丢失数据\r\n* 容量大，\r\n    * `window.sessionStorage` 越5M\r\n    * `window.localStorage` 越20M\r\n* 只能存储字符串，可将对象通过json编码后存储`JSON.stringify(obj)`\r\n\r\n## window.sessionStorage\r\n* 生命周期为关闭浏览器窗口\r\n* 在单个窗口的多页面中，数据可共享\r\n* 以键值对的形式存储使用\r\n\r\n**存储数据**\r\n```js\r\nsessionStorage.setItem(key,value)\r\n```\r\n\r\n**获取数据**\r\n```js\r\nsessionStorage.getItem(key)\r\n```\r\n\r\n**移除数据**\r\n```js\r\nsessionStorage.removeItem(key)\r\n```\r\n\r\n**清除所有数据**\r\n```js\r\nsessionStorage.clear()\r\n```\r\n\r\n## window.localStorage\r\n* 生命周期永久，除非手动删除\r\n* 可多窗口共享数据\r\n* 以键值对存储\r\n\r\n**存储数据**\r\n```js\r\nlocalStorage.setItem(key,value)\r\n```\r\n\r\n**获取数据**\r\n```js\r\nlocalStorage.getItem(key)\r\n```\r\n\r\n**移除数据**\r\n```js\r\nlocalStorage.removeItem(key)\r\n```\r\n\r\n**清除所有数据**\r\n```js\r\nlocalStorage.clear()\r\n```\r\n\r\n## 记住用户名案例\r\n\r\n<div id=\"demoiwfow\">\r\n    <input id=\"username\" type=\"text\"><input type=\"checkbox\" name=\"\" id=\"rember\" ><span>记住用户名，下次自动填写</span>\r\n</div>\r\n<style>\r\n    #demoiwfow *{\r\n        display: inline-block;\r\n        padding: 0;\r\n        margin: 0;\r\n        height: 25px;\r\n        line-height: 25px;\r\n        vertical-align: middle;\r\n    }\r\n</style>\r\n<script>\r\n    var username = document.querySelector(\"#username\")\r\n    var rember = document.querySelector(\"#rember\")\r\n    username.value = localStorage.getItem('username')\r\n    username.addEventListener(\"keyup\",function(){\r\n        if(rember.checked)\r\n        {\r\n            localStorage.setItem(\"username\",username.value)\r\n        }else{\r\n            localStorage.removeItem(\"username\")\r\n        }\r\n    })\r\n    rember.addEventListener(\"change\",function(){\r\n        if(rember.checked)\r\n        {\r\n            localStorage.setItem(\"username\",username.value)\r\n        }else{\r\n            localStorage.removeItem(\"username\")\r\n        }\r\n    })\r\n</script>\r\n\r\n```html\r\n<div id=\"demoiwfow\">\r\n    <input id=\"username\" type=\"text\"><input type=\"checkbox\" name=\"\" id=\"rember\" ><span>记住用户名，下次自动填写</span>\r\n</div>\r\n<style>\r\n    #demoiwfow *{\r\n        display: inline-block;\r\n        padding: 0;\r\n        margin: 0;\r\n        height: 25px;\r\n        line-height: 25px;\r\n        vertical-align: middle;\r\n    }\r\n</style>\r\n<script>\r\n    var username = document.querySelector(\"#username\")\r\n    var rember = document.querySelector(\"#rember\")\r\n    username.value = localStorage.getItem('username')\r\n    username.addEventListener(\"keyup\",function(){\r\n        if(rember.checked)\r\n        {\r\n            localStorage.setItem(\"username\",username.value)\r\n        }else{\r\n            localStorage.removeItem(\"username\")\r\n        }\r\n    })\r\n    rember.addEventListener(\"change\",function(){\r\n        if(rember.checked)\r\n        {\r\n            localStorage.setItem(\"username\",username.value)\r\n        }else{\r\n            localStorage.removeItem(\"username\")\r\n        }\r\n    })\r\n</script>\r\n```\r\n\r\n\r\n## JSON\r\n\r\n* 本地存储只能存储字符串类型的数据\r\n* 要存储js对象类型的数据，需利用`JSON.stringify()`来做转换\r\n* 获取本地存储的js对象时，由于存储的是字符串，所以须用`JSON.parse()`来做转换\r\n\r\n```js\r\nvar listObj = [{\r\n    title:\"???\",\r\n    data:\"20220714\"\r\n    content:\"???????????\"\r\n}]\r\n//存储数据\r\nlocalStorage.setItem(\"文章列表\",JSON.stringify(listObj))\r\n//获取数据\r\nvar temp = localStorage.getItem(\"文章列表\")\r\n```"},{"shortInfo":{"title":"前端项目笔记","cover":"\\self_server\\assets\\images\\CSS3重学笔记\\cover.png","coverWidth":1920,"coverHeight":1080,"date":"2022-06-09T08:00:00.000Z","date_end":"2022-06-09T08:00:00.000Z","tags":["HTML","CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":77,"countWords":2452,"readSeconds":245.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# 前端项目笔记\r\n## 更新日志\r\n* `2022.06.09`：v1.0\r\n* `2022.06.11`: 原生进度条，自定义进度条实现 \r\n* `2022.06.12`: 精灵图、一般的网站项目目录结构\r\n* `2022.06.16`: logo图的SEO、惯用类名、网页部分内容名称\r\n* `2022.06.19`: html的默认高度\r\n\r\n## 目录\r\n- [前端项目笔记](#前端项目笔记)\r\n  - [更新日志](#更新日志)\r\n  - [目录](#目录)\r\n  - [版心居中](#版心居中)\r\n  - [网页logo结构](#网页logo结构)\r\n  - [记得设置宽高](#记得设置宽高)\r\n  - [清除浏览器默认样式](#清除浏览器默认样式)\r\n    - [清除超链接下划线](#清除超链接下划线)\r\n    - [清除列表的标号](#清除列表的标号)\r\n    - [去除浮动元素对父元素的影响](#去除浮动元素对父元素的影响)\r\n  - [html5原生进度条](#html5原生进度条)\r\n    - [meter](#meter)\r\n    - [progress](#progress)\r\n  - [自定义进度条](#自定义进度条)\r\n  - [css单标签进度条动态效果](#css单标签进度条动态效果)\r\n  - [非阻塞的指定时间后执行代码](#非阻塞的指定时间后执行代码)\r\n  - [精灵图](#精灵图)\r\n  - [logo图SEO搜索引擎优化写法](#logo图seo搜索引擎优化写法)\r\n  - [一些惯用类名](#一些惯用类名)\r\n  - [一些名词](#一些名词)\r\n  - [一般的项目结构](#一般的项目结构)\r\n    - [base.css代码示例](#basecss代码示例)\r\n  - [html的默认高度](#html的默认高度)\r\n  - [移动端主体部分的下边距问题](#移动端主体部分的下边距问题)\r\n  - [设计图中的虚线框](#设计图中的虚线框)\r\n  - [flex布局滚动条](#flex布局滚动条)\r\n    - [清除滚动条样式](#清除滚动条样式)\r\n  - [文字溢出省略](#文字溢出省略)\r\n\r\n## 版心居中\r\n* 版心居中效果实际工作中一般写在一个名为`.wrapper{};`的css类选择器中\r\n* 有元素需要版心居中效果，就给这个元素**附加**这个类名\r\n* 版心常见的宽度值为960px、980px、1000px、1200px等\r\n```html\r\n<style>\r\n    /* 版心居中 */\r\n    .wrapper{\r\n        width: 1200px;\r\n        margin: 0 auto;\r\n    }\r\n</style>\r\n<div class=\"otherClassName wrapper\">导航条</div>\r\n```\r\n\r\n## 网页logo结构\r\n* 网页logo应该使用的标签结构 h1>a>img\r\n\r\n## 记得设置宽高\r\n* `box-sizing:border-box;`属性生效必须设置宽或高\r\n\r\n## 清除浏览器默认样式\r\n\r\n### 清除超链接下划线\r\n```css\r\na{\r\n    text-decoration:none;\r\n}\r\n```\r\n### 清除列表的标号\r\n```css\r\nli{\r\n    list-style:none;\r\n}\r\n```\r\n\r\n### 去除浮动元素对父元素的影响\r\n```css\r\n.clearfix:before,\r\n.clearfix:after{\r\n    content:'';\r\n    display:table;\r\n}\r\n.clearfix:after{\r\n    clear:both;\r\n}\r\n```\r\n## html5原生进度条\r\n* 无法有效的修改标签的样式,背景色，进度前景色等。\r\n* 浏览器默认样式的表现在不同浏览器之间并不一致\r\n* 无法添加动画效果、交互效果\r\n* 生产环境，几乎是不会看到 `<meter>` 和 `<progress>` 标签\r\n\r\n### meter\r\n\r\n```html\r\n<!-- min、max、value 分别表示最大值，最小值与当前值。 -->\r\n<meter min=\"0\" max=\"500\" value=\"350\">350 degrees</meter> \r\n<style>\r\nmeter { \r\n    width: 200px; \r\n} \r\n</style>\r\n```\r\n效果：\r\n<meter min=\"0\" max=\"500\" value=\"350\">350 degrees</meter>\r\n<style>\r\nmeter { \r\n    width: 200px; \r\n} \r\n</style>\r\n\r\n### progress\r\n```html\r\n<!-- max 属性描述这个 progress 元素所表示的任务一共需要完成多少工作量，value 属性用来指定该进度条已完成的工作量。 -->\r\n<progress max=\"100\" value=\"70\"> 70% </progress> \r\n<style>\r\nprogress { \r\n    width: 200px; \r\n} \r\n</style>\r\n\r\n```\r\n效果：\r\n<progress max=\"100\" value=\"70\"> 70% </progress> \r\n<style>\r\nprogress { \r\n    width: 200px; \r\n} \r\n</style>\r\n\r\n## 自定义进度条\r\n```html\r\n<div class=\"progress-container\"><div class=\"process\" style=\"width:80%;\"></div></div>\r\n<style>\r\n.progress-container{\r\n    /* position:absolute;\r\n    right: 0px;\r\n    z-index: 1; */\r\n    display: inline-block;\r\n    width: 200px;\r\n    height: 1em;\r\n    background-color: #fff;\r\n    border-radius: 0.5em;\r\n    vertical-align: middle;\r\n}\r\n.process{\r\n    height: 1em;\r\n    /* background-color: #0f0; */\r\n    background: linear-gradient(90deg, #0f0, #0ff);\r\n    border-radius: 0.5em;\r\n}\r\n</style>\r\n```\r\n效果：\r\n\r\n<div class=\"progress-container\"><div class=\"process\" style=\"width:80%;\"></div></div>\r\n<style>\r\n.progress-container{\r\n    /* position:absolute;\r\n    right: 0px;\r\n    z-index: 1; */\r\n    display: inline-block;\r\n    width: 200px;\r\n    height: 1em;\r\n    background-color: #fff;\r\n    border-radius: 0.5em;\r\n    vertical-align: middle;\r\n}\r\n.process{\r\n    height: 1em;\r\n    /* background-color: #0f0; */\r\n    background: linear-gradient(90deg, #0f0, #0ff);\r\n    border-radius: 0.5em;\r\n}\r\n</style>\r\n\r\n\r\n## css单标签进度条动态效果\r\n* 动态是指在修改`--progress: 20%`属性值时会有动态效果\r\n\r\n```html\r\n<div class=\"g-progress\" style=\"--progress: 70%\"></div> \r\n<style>\r\n@property --progress { \r\n  syntax: '<percentage>'; \r\n  inherits: false; \r\n  initial-value: 0%; \r\n} \r\n.g-progress { \r\n    margin: auto; \r\n    width: 240px; \r\n    height: 25px; \r\n    border-radius: 25px; \r\n    background: linear-gradient(90deg, #0f0, #0ff var(--progress), transparent 0); \r\n    border: 1px solid #eee; \r\n    transition: .3s --progress; \r\n} \r\n</style>\r\n\r\n```\r\n效果：\r\n<div class=\"g-progress\" style=\"--progress: 20%\"></div>\r\n<style>\r\n@property --progress { \r\n  syntax: '<percentage>'; \r\n  inherits: false; \r\n  initial-value: 0%; \r\n} \r\n.g-progress { \r\n    margin: auto; \r\n    width: 240px; \r\n    height: 25px; \r\n    border-radius: 25px; \r\n    background: linear-gradient(90deg, #0f0, #0ff var(--progress), transparent 0); \r\n    border: 1px solid #eee; \r\n    transition: .3s --progress; \r\n} \r\n</style>\r\n\r\n\r\n## 非阻塞的指定时间后执行代码\r\n\r\n```js\r\n    <script >\r\n        setTimeout(\"func()\",0 );  \r\n        function func(){  \r\n            do\r\n            {\r\n                执行语句;\r\n            }while(结束条件)\r\n        }  \r\n    </script>\r\n```\r\n\r\n## 精灵图\r\n* 将项目中多个小图合并成一张大图，这张大图称为精灵图\r\n* 优点，减少服务器发送图片次数，减轻服务器压力，提高页面加载速度\r\n* 步骤\r\n    * 设置盒子的**宽高**为**小图的宽高**\r\n    * 设置盒子的**背景**为**大图的url()**\r\n    * 设置背景图的**起始绘制位置**为所需**小图左上角的坐标**\r\n* 注意\r\n    * 精灵图一般使用行内/行内块标签\r\n    * 属性名：`background-position:水平方向位置 垂直方向位置;`\r\n        * 水平方向正数表示背景图右移，负数表示左移\r\n        * 水平方向正数表示背景图下移，负数表示上移\r\n    * 具体位置偏移量要用像素大厨软件测量，然后取负数\r\n\r\n* 实例![](./images/前端项目笔记/2022-06-12-14-33-17.png)\r\n\r\n## logo图SEO搜索引擎优化写法\r\n1. 标签结构`<h1><a href=\"#\">网站名</a></h1>`\r\n2. 将网站logo设置为a的背景图\r\n3. 设置`background-size:contain;`\r\n4. 将文字大小设置为0，`font-size:0;`\r\n\r\n\r\n## 一些惯用类名\r\n![](./images/前端项目笔记/2022-06-16-02-03-54.png)\r\n\r\n\r\n## 一些名词\r\n* 快捷菜单和主导航![](./images/前端项目笔记/2022-06-15-21-00-23.png)\r\n\r\n## 一般的项目结构\r\n* 项目文件夹不建议包含中文\r\n* favicon.ico一般放项目根目录\r\n* 根目录的images文件夹放网站固定使用的图片素材，如logo，样式修饰图\r\n* 根目录的uploads文件夹存放网站非固定使用的图片，如商品图片，宣传图片\r\n* 根目录的lib文件夹存放网站所引用的一些库文件、框架文件的文件夹\r\n* index.html放根目录\r\n* 根目录下css文件夹保存网页样式\r\n    * base.css 基础公共样式，如默认样式的清除，列表符号清除 超链接下划线清除\r\n    * common.css 网页中多个网页相同模板的重复样式，如头部，底部\r\n    * index.css 首页样式\r\n    * 注意三个文件的引入顺序，后引入的覆盖先引入的\r\n![](./images/前端项目笔记/2022-06-12-21-36-00.png)\r\n\r\n### base.css代码示例\r\n```css\r\n/* 清除默认样式的代码 */\r\n/* 去除常见标签默认的 margin 和 padding */\r\nbody,\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\nh5,\r\nh6,\r\np,\r\nul,\r\nol,\r\nli,\r\ndl,\r\ndt,\r\ndd,\r\ninput {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\n/* 內减模式 */\r\n* {\r\n    box-sizing: border-box;\r\n}\r\n\r\n/* 设置网页统一的字体大小、行高、字体系列相关属性 */\r\nbody {\r\n  font: 16px/1.5 \"Helvetica Neue\", Helvetica, Arial, \"Microsoft Yahei\",\r\n    \"Hiragino Sans GB\", \"Heiti SC\", \"WenQuanYi Micro Hei\", sans-serif;\r\n  color: #333;\r\n}\r\n\r\n/* 去除列表默认样式 */\r\nul,\r\nol {\r\n  list-style: none;\r\n}\r\n\r\n/* 去除默认的倾斜效果 */\r\nem,\r\ni {\r\n  font-style: normal;\r\n}\r\n\r\n/* 去除a标签默认下划线，并设置默认文字颜色 */\r\na {\r\n  text-decoration: none;\r\n  color: #333;\r\n}\r\n\r\n/* 设置img的垂直对齐方式为居中对齐，去除img默认下间隙 */\r\nimg {\r\n  vertical-align: middle;\r\n}\r\n\r\n/* 去除input默认样式 */\r\ninput {\r\n  border: none;\r\n  outline: none;\r\n  color: #333;\r\n}\r\n\r\n/* 左浮动 */\r\n.fl {\r\n  float: left;\r\n}\r\n\r\n/* 右浮动 */\r\n.fr {\r\n  float: right;\r\n}\r\n\r\n/* 双伪元素清除法 */\r\n.clearfix::before,\r\n.clearfix::after {\r\n  content: \"\";\r\n  display: table;\r\n}\r\n.clearfix::after {\r\n  clear: both;\r\n}\r\n\r\n```\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n\r\n## html的默认高度\r\n当要给body标签添加背景图时可能会遇到图片不显示的问题，原因是因为body的高度默认靠内容撑开，其高度为0，但当设置body高度为100%会发现仍然不解决问题，原因是body标签的父级标签html的高度是0，所以还应该设置html高度为100%\r\n\r\n```css\r\nhtml{\r\n  height:100%\r\n}\r\nbody{\r\n  height:100%\r\n  background-image:url();\r\n}\r\n\r\n```\r\n\r\n## 移动端主体部分的下边距问题\r\n由于最底部的导航条是固定定位，会脱离标准流，如果主体部分的内容的底部没有外边距或内边距，版权信息就会被遮挡，正确的做法是应该添加一个边距\r\n\r\n![](./images/前端项目笔记/2022-06-20-01-10-33.png)\r\n\r\n## 设计图中的虚线框\r\n* 意思是这些地方是能点击的\r\n* 整个虚线框都是点击范围\r\n* 这个范围的宽高一般多为44这样的偶数\r\n![](./images/前端项目笔记/2022-06-20-02-28-34.png)\r\n\r\n## flex布局滚动条\r\n当手机端排版时，如果 ul 中 li 过多，一行装不下时，希望显示水平滚动条，而不是折行。\r\n\r\nflex 实现：\r\n\r\nul\r\n```css\r\ndisplay: flex;\r\noverflow-x: auto;\r\n```\r\nli\r\n```css\r\nflex: none;\r\n```\r\n\r\n![](./images/前端项目笔记/2022-06-22-08-54-37.png)\r\n![](./images/前端项目笔记/2022-06-22-08-51-18.png)\r\n\r\n![](./images/前端项目笔记/2022-06-22-08-51-48.png)\r\n\r\n### 清除滚动条样式\r\n仅在支持WebKit的浏览器 (例如, 谷歌Chrome, 苹果Safari)可以使用.\r\n\r\n\r\n滚动条相关伪元素名\r\n* ::-webkit-scrollbar — 整个滚动条.\r\n* ::-webkit-scrollbar-button — 滚动条上的按钮 (上下箭头).\r\n* ::-webkit-scrollbar-thumb — 滚动条上的滚动滑块.\r\n* ::-webkit-scrollbar-track — 滚动条轨道.\r\n* ::-webkit-scrollbar-track-piece — 滚动条没有滑块的轨道部分.\r\n* ::-webkit-scrollbar-corner — 当同时有垂直滚动条和水平滚动条时交汇的部分.\r\n* ::-webkit-resizer — 某些元素的corner部分的部分样式(例:textarea的可拖动按钮).\r\n\r\n示例\r\n```less\r\n&::-webkit-scrollbar{\r\n    // 清除滚动条\r\n    display: none;\r\n}\r\n```\r\n\r\n## 文字溢出省略\r\n```css\r\n/* 溢出隐藏 */\r\noverflow: hidden;\r\n/* 文字溢出显示省略号 */\r\ntext-overflow: ellipsis;\r\n/* 强制在同一行内显示所有文本，直到文本结束或者遭遇 br 对象 */\r\nwhite-space: nowrap;\r\n```"},{"shortInfo":{"title":"同源策略和跨域","date":"2022-08-26T15:43:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["前端"],"hideAtIndex":true,"categories":"笔记","id":78,"countWords":586,"readSeconds":58.6,"assetsbaseUrl":"/self_server/assets/"},"content":"## 同源策略和跨域\r\n同源策略(Same-Origin Policy)最早由Netscape公司提出,是**浏览器**的一种安全策略\r\n* **同源**: 协议 域名 端口号 均一致\r\n* **跨域**: 违背同源策略就是跨域,\r\n* **具体表现**: 如果在`a.com`的页面中向`b.com`的服务器的发送**请求报文**,则其**响应报文**会被浏览器**拦截**.\r\n\r\n## CROS跨域(源)资源共享\r\n**CROS**(Cross-Origin Resource Sharing)跨域(源)资源共享,解决跨域资源共享的解决方案.\r\n\r\n**特点**: 不需要在客户端做特殊操作,解决跨域的步骤完全在服务器中进行.\r\n\r\n**工作原理**: 通过设置一个**响应头**来告诉浏览器该请求允许跨域\r\n```\r\nAccess-Control-Allow-Origin: *\r\n```\r\n\r\n\r\n## 完整访问控制请求头\r\n* `Access-Control-Allow-Origin: URL或*` 指定了允许访问该资源的外域\r\n* `Access-Control-Expose-Headers: 自定义响应头名1, 自定义响应头名2` 使得客户端能够获取到自定义的响应头\r\n* `Access-Control-Max-Age: <delta-seconds>` 指定了 preflight 请求的结果能够被缓存多久\r\n* `Access-Control-Allow-Credentials: true` 指定跨域请求时候能够携带验证信息,如cookie\r\n* `Access-Control-Allow-Methods: <method>[, <method>]*` 设置请求允许的方法,默认仅支持 GET POST HEAD\r\n* `Access-Control-Allow-Headers: <field-name>[, <field-name>]*` 设置允许的请求头的头名,默认仅支持9个请求头\r\n\r\n\r\n## CORS请求分类\r\n* 简单请求 : \r\n  * 请求方式必须为: `GET` `POST` `HEAD`\r\n  * 请求头必须: **不能包含自定义请求** ,仅能包含默认支持9个请求头\r\n  * 简单请求仅会在客户端和服务端之间发送一次请求,\r\n* 预检请求 : \r\n  * 请求方式: 除去`GET` `POST` `HEAD`之外的请求\r\n  * 请求头为: 请求头中**包含自定义的头部** 或包含 `application/json`\r\n  * 预检请求会在客户端和服务端之间发送两次请求,第一次会发送OPTIONS类型的请求进行预检,之后才会发送真正的请求\r\n\r\n**预检请求**  \r\n在浏览器和服务器通信前,浏览器会先发送OPTIONS类型的请求进行预检,以获知服务器是否允许该实际请求,  \r\n**服务器响应OPTIONS类型的请求后浏览器才会发送真正的请求并携带真实的数据**"},{"shortInfo":{"title":"响应式学习笔记","date":"2022-06-20T22:35:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["响应式","媒体查询","前端"],"hideAtIndex":true,"categories":"笔记","id":79,"countWords":511,"readSeconds":51.1,"assetsbaseUrl":"/self_server/assets/"},"content":"# 响应式学习笔记\r\n## 概述\r\n* 能更具设备的视口宽度自适应的调整网页的布局方式\r\n* 对于企业站等类似内容比较少的网站可以做成响应式，电商站不适合做响应式，一般单独开发成pc端页面和移动端页面的两个独立的页面\r\n![](./images/响应式/2022-06-23-00-04-33.png)\r\n\r\n* 解决方案\r\n    * 媒体查询\r\n    * bootstrap\r\n\r\n\r\n## 媒体查询\r\n* 根据设备宽度的变化，设置差异化样式\r\n* 常用写法\r\n    * **max-width:XXXpx** **>=XXXpx** 对最大不超过该数的宽度生效\r\n    * **min-width:XXXpx** **<=XXXpx** 对最小不低于该数的宽度生效\r\n* 关键词\r\n    * `and`\r\n    * `only`\r\n    * `not`\r\n* 媒体类型\r\n    ![](./images/响应式/2022-06-23-00-45-58.png)\r\n* 媒体特征\r\n    ![](./images/响应式/2022-06-23-00-46-43.png)\r\n\r\n* 语法格式\r\n```html\r\n<style>\r\n/* 完整写法 */\r\n    @media 关键词 媒体类型 and (媒体特性){\r\n        选择器{\r\n            样式\r\n        }\r\n    }\r\n/* 省略写法 */\r\n    @media (媒体特性){\r\n        选择器{\r\n            样式\r\n        }\r\n    }\r\n</style>\r\n\r\n<!-- 外链式写法 -->\r\n    <!-- 完整写法 -->\r\n        <link rel=\"stylesheet\" media=\"逻辑符 媒体类型 and (媒体特征)\" href=\"style.css\">\r\n    <!-- 完整写法 -->\r\n        <link rel=\"stylesheet\" media=\"(媒体特征)\" href=\"style.css\">\r\n\r\n```\r\n\r\n**示例代码1**\r\n```css\r\n/* 视口宽度小于768px：背景显示粉色 */\r\n@media (max-width:768px){\r\n    body{\r\n        background-color:pink;\r\n    }\r\n}\r\n/* 视口宽度大于768px：背景显示绿色 */\r\n@media (min-width:768px){\r\n    body{\r\n        background-color:green ;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**示例代码2**\r\n```less\r\n// bootstrap的间断点\r\n// ExtraSmall <576px\r\n// Small ≥576px\r\n// Medium ≥768px\r\n// Large ≥992px\r\n// X-Large ≥1200px\r\n// XX-Large ≥1400px\r\n\r\nbody{\r\n    //对于视口宽度在 1400px-无穷 的设备生效\r\n    @media(min-width:1400px){\r\n        background-color:black ;\r\n    }\r\n    //对于视口宽度在 0-1400px 的设备生效\r\n    @media(max-width:1400px){\r\n        background-color:red ;\r\n    }\r\n    //对于视口宽度在 0-1200px 的设备生效\r\n    @media(max-width:1200px){\r\n        background-color:blue ;\r\n    }\r\n    //对于视口宽度在 0-992px 的设备生效\r\n    @media(max-width:992px){\r\n        background-color:gold ;\r\n    }\r\n    //对于视口宽度在 0-768px 的设备生效\r\n    @media(max-width:768px){\r\n        background-color:green ;\r\n    }\r\n    //对于视口宽度在 0-576px 的设备生效\r\n    @media(max-width:576px){\r\n        background-color:skyblue ;\r\n    }\r\n    //根据层叠性和叠加性,\r\n}\r\n```\r\n\r\n## bootstrap\r\n* 内容较独立，单独做笔记"},{"shortInfo":{"layout":"post","cover":"\\self_server\\assets\\images\\default_cover2.jpg","title":"响应式网页项目实战","date":"2022-06-23T09:21:00.000Z","tags":["响应式","BootStrap","demo"],"hideAtIndex":true,"categories":"前端","id":80,"countWords":94,"readSeconds":9.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 响应式网页项目实战\r\n\r\n## Demos\r\n* [-->AlloyTeam官网仿写<--](./demos/响应式网页项目实战AlloyTeam/AlloyTeam/index.html)\r\n    * 基本上对网站的所有动态效果做了完整实现\r\n    * 响应式功能能够适配手机平板电脑\r\n    * 底部版权信息部分没有实现\r\n    * [原网站](http://www.alloyteam.com/)\r\n    * ![](./images/2022-10-18-14-41-37.png)\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"layout":"post","title":"完蛋还剩不到六十天","date":"2022-02-24T17:12:00.000Z","cover":"\\self_server\\assets\\images\\加倍努力.jfif","tags":["日志"],"categories":"日志","id":81,"countWords":65,"readSeconds":6.5,"assetsbaseUrl":"/self_server/assets/"},"content":"## 完蛋还剩不到六十天\r\n\r\n**保送政策取消了，考试还剩不到六十天，这来得及吗，这来不及了，这能放弃吗，这不能放弃！！！**\r\n\r\n![](./images/233.gif)\r\n<!-- <img src=\"./images/233.gif\" style=\"display:block;margin:0 auto;height:200px;\"> -->\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"title":"手写实现Promise","date":"2022-07-24T17:32:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["Promise"],"hideAtIndex":true,"categories":"笔记","id":82,"countWords":13544,"readSeconds":1354.4,"assetsbaseUrl":"/self_server/assets/"},"content":"## 基本结构搭建\r\n\r\n```js\r\n//1. 声明构造函数\r\n    function Promise(executor){\r\n\r\n    }\r\n//2. 添加then方法\r\n    Promise.prototype.then = function(onResolved,onRejected){\r\n\r\n    }\r\n    // let p = new Promise((resolve,reject)=>{\r\n    //     resolve(\"OK\")\r\n    // })\r\n    // p.then((value)=>{\r\n    //     console.log(value)\r\n    // })\r\n```\r\n\r\n\r\n## resolve与reject函数的结构搭建\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n\r\n//1. 执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n//2. 执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    executor(resolve,reject);\r\n\r\n\r\n//3. resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n\r\n    }\r\n//4. reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n\r\n    }\r\n\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n\r\n## resolve函数与reject函数的实现\r\n\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n//0. 添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n//1. 保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    executor(resolve,reject);\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n//2. 修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n//3. 修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n//4. reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// console.log(p)\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n## 实现异常处理\r\n执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n// 0. 异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// console.log(p)\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n## 实现状态只能修改一次\r\n执行器中的代码应该只能在第一次调用`resolve()`或`reject()`时修改**状态**和**结果**值，实现该功能只需在修改 **状态** 前判断其是否为初始值\r\n\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n    //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //0. 实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n//1. 实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n\r\n}\r\nlet p = new Promise((resolve,reject)=>{\r\n    resolve(\"OK\")\r\n})\r\nconsole.log(p)\r\np.then((value)=>{\r\n    console.log(value)\r\n})\r\n```\r\n\r\n## then()执行回调函数的实现\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n    //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n//0. 根据promise状态执行回调函数\r\n    if(this.PromsieState == \"fulfilled\")\r\n    {\r\n//2. 传递value\r\n        onResolved(this.PromsieResult);\r\n    }\r\n//1. 根据promise状态执行回调函数\r\n    if(this.PromsieState == \"rejected\")\r\n    {\r\n//3. 传递reason\r\n        onRejected(this.PromsieResult);\r\n    }\r\n    \r\n\r\n}\r\n// let p = new Promise((resolve,reject)=>{\r\n//     resolve(\"OK\")\r\n// })\r\n// console.log(p)\r\n// p.then((value)=>{\r\n//     console.log(value)\r\n// })\r\n```\r\n\r\n## then处理异步执行的实现\r\n执行器中的代码存在异步语句时，then方法中需要处理该种情形\r\n```js\r\n//声明构造函数\r\nfunction Promise(executor){\r\n    //添加属性\r\n    this.PromsieState = 'pending';\r\n    this.PromsieResult = null ;\r\n// 1. 声明属性用于保存回调函数\r\n    this.callBack = {}\r\n    //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n    const self = this;//self _this that\r\n\r\n    //执行器函数executor在构造函数中是同步调用的:\r\n    // executor();\r\n\r\n    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n    // executor(resolve,reject);\r\n\r\n    //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n    try{\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        executor(resolve,reject);\r\n    }catch(error){\r\n        reject(error)\r\n    }\r\n\r\n\r\n    //resolve()是一个函数，应当有一个形式参数\r\n    function resolve(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //修改实例化对象的状态值(属性名：promiseState)\r\n        self.PromsieState = \"fulfilled\"\r\n        //修改实例化对象的结果值(属性名：promiseResult)\r\n        self.PromsieResult = data;\r\n// 3. 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n        if(self.callBack.onResolved)\r\n        {\r\n//4. 执行保存的回调函数\r\n            self.callBack.onResolved(data)\r\n        }\r\n    }\r\n    //reject()是一个函数，应当有一个形式参数\r\n    function reject(data){\r\n        //实现状态只能修改一次：判断状态是否为初始状态\r\n        if (self.PromsieState !==\"pending\") return;\r\n        \r\n        //reject()函数同resolve一样\r\n        self.PromsieState = \"rejected\"\r\n        self.PromsieResult = data;\r\n\r\n// 5. 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n        if(self.callBack.onRejected)\r\n        {\r\n//6. 执行保存的回调函数\r\n            self.callBack.onRejected(data)\r\n        }\r\n    }\r\n}\r\n//添加then方法\r\nPromise.prototype.then = function(onResolved,onRejected){\r\n    //根据promise状态执行回调函数\r\n    if(this.PromsieState == \"fulfilled\")\r\n    {\r\n        //传递value\r\n        onResolved(this.PromsieResult);\r\n    }\r\n    //根据promise状态执行回调函数\r\n    if(this.PromsieState == \"rejected\")\r\n    {\r\n        //传递reason\r\n        onRejected(this.PromsieResult);\r\n    }\r\n//0. 处理当执行器中存在异步语句的情形\r\n    if(this.PromsieState == \"pending\")\r\n    {\r\n// 2. 保存回调函数\r\n        this.callBack = {\r\n            onResolved:onResolved,\r\n            onRejected:onRejected\r\n        }\r\n    }\r\n    \r\n\r\n}\r\nlet p = new Promise((resolve,reject)=>{\r\n    resolve(\"OK\")\r\n})\r\nconsole.log(p)\r\np.then((value)=>{\r\n    console.log(value)\r\n})\r\n```\r\n\r\n## then处理异步执行的多个回调函数的实现\r\n\r\n```js\r\n    //声明构造函数\r\n    function Promise(executor){\r\n        //添加属性\r\n        this.PromsieState = 'pending';\r\n        this.PromsieResult = null ;\r\n        // 声明属性用于保存回调函数\r\n        // this.callBack = {}\r\n//0. 修改为保存数组\r\n        this.callBacks = []\r\n\r\n        //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n        const self = this;//self _this that\r\n\r\n        //执行器函数executor在构造函数中是同步调用的:\r\n        // executor();\r\n\r\n        //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n        // executor(resolve,reject);\r\n\r\n        //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n        try{\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            executor(resolve,reject);\r\n        }catch(error){\r\n            reject(error)\r\n        }\r\n\r\n\r\n        //resolve()是一个函数，应当有一个形式参数\r\n        function resolve(data){\r\n            //实现状态只能修改一次：判断状态是否为初始状态\r\n            if (self.PromsieState !==\"pending\") return;\r\n            \r\n            //修改实例化对象的状态值(属性名：promiseState)\r\n            self.PromsieState = \"fulfilled\"\r\n            //修改实例化对象的结果值(属性名：promiseResult)\r\n            self.PromsieResult = data;\r\n            // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n            // if(self.callBack.onResolved)\r\n            // {\r\n            //     //执行保存的回调函数\r\n            //     self.callBack.onResolved(data)\r\n            // }\r\n//2. 执行所有成功的回调函数\r\n            self.callBacks.forEach(item=>{\r\n                item.onResolved(data)\r\n            })\r\n        }\r\n        //reject()是一个函数，应当有一个形式参数\r\n        function reject(data){\r\n            //实现状态只能修改一次：判断状态是否为初始状态\r\n            if (self.PromsieState !==\"pending\") return;\r\n            \r\n            //reject()函数同resolve一样\r\n            self.PromsieState = \"rejected\"\r\n            self.PromsieResult = data;\r\n\r\n            // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n            // if(self.callBack.onRejected)\r\n            // {\r\n            //     //执行保存的回调函数\r\n            //     self.callBack.onRejected(data)\r\n            // }\r\n//3. 执行所有失败的回调函数\r\n            self.callBacks.forEach(item=>{\r\n                item.onRejected(data)\r\n            })\r\n        }\r\n    }\r\n    //添加then方法\r\n    Promise.prototype.then = function(onResolved,onRejected){\r\n        //根据promise状态执行回调函数\r\n        if(this.PromsieState == \"fulfilled\")\r\n        {\r\n            //传递value\r\n            onResolved(this.PromsieResult);\r\n        }\r\n        //根据promise状态执行回调函数\r\n        if(this.PromsieState == \"rejected\")\r\n        {\r\n            //传递reason\r\n            onRejected(this.PromsieResult);\r\n        }\r\n        //处理当执行器中存在异步语句的情形\r\n        if(this.PromsieState == \"pending\")\r\n        {\r\n            // 保存回调函数\r\n            // this.callBack = {\r\n            //     onResolved:onResolved,\r\n            //     onRejected:onRejected\r\n            // }\r\n//1. 保存所有回调函数\r\n            this.callBacks.push({\r\n                onResolved:onResolved,\r\n                onRejected:onRejected\r\n            })\r\n        }\r\n        \r\n\r\n    }\r\n    let p = new Promise((resolve,reject)=>{\r\n        resolve(\"OK\")\r\n    })\r\n    console.log(p)\r\n    p.then((value)=>{\r\n        console.log(value)\r\n    })\r\n```\r\n\r\n## 处理执行器中同步执行状态下then的返回值\r\nthen的返回值由其中的回调函数决定\r\n* 若回调函数的返回值是一个promise对象，则then返回的promise的状态和值与该对象一致\r\n* 若回调函数的返回值是一个非promise对象，则then返回的是状态为成功的promise对象，且其值为该返回值\r\n* 若回调函数中出现异常，则返回失败promise 且其值为抛出的异常\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n//0. then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n\r\n//5. 处理抛出异常的情况\r\n                    try{\r\n//1. 获取返回值\r\n                        let result = onResolved(this.PromsieResult);\r\n//2. 判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n//3. 分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n//4. 处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n//6. 处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n\r\n\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n//7. rejected处理过程类似\r\n//处理抛出异常的情况\r\n                    try{\r\n//获取返回值\r\n                        let result = onRejected(this.PromsieResult);\r\n//判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n//分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n//处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n//处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        onResolved:onResolved,\r\n                        onRejected:onRejected\r\n                    })\r\n                }\r\n            })\r\n\r\n            \r\n\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            resolve(\"OK\")\r\n        })\r\n        console.log(p)\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n```\r\n\r\n\r\n## 处理执行器中异步执行状态下then的返回值\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n\r\n                    //处理抛出异常的情况\r\n                    try{\r\n                        //获取返回值\r\n                        let result = onResolved(this.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n\r\n\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //处理抛出异常的情况\r\n                    try{\r\n                    //获取返回值\r\n                        let result = onRejected(this.PromsieResult);\r\n                    //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n//1. 处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //处理抛出异常的情况\r\n                            try{\r\n                                //获取返回值\r\n                                let result = onResolved(data);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        },\r\n                        onRejected:function(data){\r\n                            //处理抛出异常的情况\r\n                            try{\r\n                                //获取返回值\r\n                                let result = onRejected(data);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n            \r\n\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                resolve(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n```\r\n\r\n\r\n## then方法优化\r\n对重复执行的代码块进行封装\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n//1. 声明变量\r\n                let self = this\r\n// 2. 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n//3. 调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n//4. 调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n//5. 调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n//6. 调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n            \r\n\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                resolve(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n```\r\n\r\n## catch方法及异常穿透的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n//2. 处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n//3. 处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n        }\r\n//1. 添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n        .then(value=>{\r\n            console.log(value);\r\n        })\r\n        .catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n```\r\n\r\n## resolve方法的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n//1. 添加resolve方法\r\n        Promise.resolve = function(value){\r\n//2. 返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n        .then(value=>{\r\n            console.log(value);\r\n        })\r\n        .catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n//3. 使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n```\r\n\r\n## reject方法的实现\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n\r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n//1. 添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        })\r\n        .then(value=>{\r\n            console.log(value);\r\n        })\r\n        .catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n//2. 使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## all方法的实现\r\n\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n            \r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        //添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n//1. 添加all方法\r\n        Promise.all = function(Promises=[]){\r\n            return new Promise((resolve,reject)=>{\r\n//2. 声明计数器\r\n                let count = 0\r\n//3. 成功结果数字\r\n                let results = []\r\n                for(let i =0 ; i<Promises.length;i++)\r\n                Promises[i].then(value=>{\r\n//4. 自增计数器\r\n                    count++;\r\n//5. 存入结果值\r\n                    results[i]=value\r\n//6. 判断是否所有都成功\r\n                    if(count == Promises.length){\r\n//7. 返回结果\r\n                        resolve(results)\r\n                    }\r\n                },reason=>{\r\n//8. 若有任何一个结果为失败，则all返回的也是失败\r\n                    reject(reason);\r\n                })\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## race方法的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n                    try{\r\n                        //获取返回值\r\n                        let result = type(self.PromsieResult);\r\n                        //判断是否为promise对象\r\n                        if(result instanceof Promise){\r\n                            //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                            result.then(v=>{\r\n                                resolve(v)\r\n                            },r=>{\r\n                                reject(r)\r\n                            })\r\n                        }else{\r\n                            //处理非promise对象的情况\r\n                            resolve(result)\r\n                        }\r\n                    }catch(error){\r\n                        //处理抛出的异常\r\n                        reject(error)\r\n                    }\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n            \r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        //添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n        //添加all方法\r\n        Promise.all = function(Promises=[]){\r\n            return new Promise((resolve,reject)=>{\r\n        //声明计数器\r\n                let count = 0\r\n        //成功结果数字\r\n                let results = []\r\n                for(let i =0 ; i<Promises.length;i++)\r\n                Promises[i].then(value=>{\r\n        //自增计数器\r\n                    count++;\r\n        //存入结果值\r\n                    results[i]=value\r\n        //判断是否所有都成功\r\n                    if(count == Promises.length){\r\n        //返回结果\r\n                        resolve(results)\r\n                    }\r\n                },reason=>{\r\n        //若有任何一个结果为失败，则all返回的也是失败\r\n                    reject(reason);\r\n                })\r\n            })\r\n        }\r\n//1. 添加race方法\r\n        Promise.race = function(Promises=[]){\r\n//2. 返回\r\n            return new Promise((resolve,reject)=>{\r\n//3. 遍历\r\n                for(let i=0 ; i<Promises.length;i++){\r\n//4. 谁先改变状态，谁就能决定返回值的状态\r\n                    Promises[i].then(value=>{\r\n                        resolve(value)\r\n                    },reason=>{\r\n                        reject(reason)\r\n                    })\r\n                }\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## then方法中的回调函数异步执行的实现\r\n```js\r\n        //声明构造函数\r\n        function Promise(executor){\r\n            //添加属性\r\n            this.PromsieState = 'pending';\r\n            this.PromsieResult = null ;\r\n            // 声明属性用于保存回调函数\r\n            // this.callBack = {}\r\n            //修改为保存数组\r\n            this.callBacks = []\r\n\r\n            //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n            const self = this;//self _this that\r\n\r\n            //执行器函数executor在构造函数中是同步调用的:\r\n            // executor();\r\n\r\n            //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n            // executor(resolve,reject);\r\n\r\n            //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n            try{\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                executor(resolve,reject);\r\n            }catch(error){\r\n                reject(error)\r\n            }\r\n\r\n\r\n            //resolve()是一个函数，应当有一个形式参数\r\n            function resolve(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //修改实例化对象的状态值(属性名：promiseState)\r\n                self.PromsieState = \"fulfilled\"\r\n                //修改实例化对象的结果值(属性名：promiseResult)\r\n                self.PromsieResult = data;\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onResolved)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onResolved(data)\r\n                // }\r\n                //执行所有成功的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onResolved(data)\r\n                })\r\n            }\r\n            //reject()是一个函数，应当有一个形式参数\r\n            function reject(data){\r\n                //实现状态只能修改一次：判断状态是否为初始状态\r\n                if (self.PromsieState !==\"pending\") return;\r\n                \r\n                //reject()函数同resolve一样\r\n                self.PromsieState = \"rejected\"\r\n                self.PromsieResult = data;\r\n\r\n                // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                // if(self.callBack.onRejected)\r\n                // {\r\n                //     //执行保存的回调函数\r\n                //     self.callBack.onRejected(data)\r\n                // }\r\n                //执行所有失败的回调函数\r\n                self.callBacks.forEach(item=>{\r\n                    item.onRejected(data)\r\n                })\r\n            }\r\n        }\r\n        //添加then方法\r\n        Promise.prototype.then = function(onResolved,onRejected){\r\n            //then的返回值是一个promise\r\n            return new Promise((resolve,reject)=>{\r\n                //声明变量\r\n                let self = this\r\n                //处理失败回调函数为undefined的情况（省略没有写）\r\n                if(onRejected !== \"function\"){\r\n                    onRejected = (reason)=>{\r\n                        throw reason;\r\n                    }\r\n                }\r\n                //处理成功回调函数为undefined的情况（省略没有写）\r\n                if(onResolved !== \"function\"){\r\n                    onResolved = value=>value\r\n                }\r\n                // 定义函数\r\n                function callback(type){\r\n//0. 使得回调函数异步执行\r\n                    setTimeout(() => {\r\n                        try{\r\n                            //获取返回值\r\n                            let result = type(self.PromsieResult);\r\n                            //判断是否为promise对象\r\n                            if(result instanceof Promise){\r\n                                //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                result.then(v=>{\r\n                                    resolve(v)\r\n                                },r=>{\r\n                                    reject(r)\r\n                                })\r\n                            }else{\r\n                                //处理非promise对象的情况\r\n                                resolve(result)\r\n                            }\r\n                        }catch(error){\r\n                            //处理抛出的异常\r\n                            reject(error)\r\n                        }\r\n                    }, 0);\r\n\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"fulfilled\")\r\n                {\r\n                    //传递value\r\n                    // onResolved(this.PromsieResult);\r\n                    //调用函数\r\n                    callback(onResolved)\r\n                }\r\n                //根据promise状态执行回调函数\r\n                if(this.PromsieState == \"rejected\")\r\n                {\r\n                    //传递reason\r\n                    // onRejected(this.PromsieResult);\r\n                    //rejected处理过程类似\r\n                    //调用函数\r\n                    callback(onRejected)\r\n                }\r\n                //处理当执行器中存在异步语句的情形\r\n                if(this.PromsieState == \"pending\")\r\n                {\r\n                    // 保存回调函数\r\n                    // this.callBack = {\r\n                    //     onResolved:onResolved,\r\n                    //     onRejected:onRejected\r\n                    // }\r\n                    //保存所有回调函数\r\n                    this.callBacks.push({\r\n                        //处理执行器中异步执行时回调\r\n                        onResolved:function(data){\r\n                            //调用函数\r\n                            callback(onResolved)\r\n                        },\r\n                        onRejected:function(data){\r\n                            //调用函数\r\n                            callback(onRejected)\r\n                        }\r\n                    })\r\n                }\r\n            })\r\n            \r\n        }\r\n        //添加catch方法\r\n        Promise.prototype.catch = function(onRejected){\r\n            return this.then(undefined,onRejected);\r\n        }\r\n        //添加resolve方法\r\n        Promise.resolve = function(value){\r\n        //返回promise对象\r\n            return new Promise((resolve,reject)=>{\r\n                if(value instanceof Promise){\r\n                    value.then(v=>{\r\n                        resolve(v);\r\n                    },r=>{\r\n                        reject(r);\r\n                    });\r\n                }else{\r\n                    resolve(value);\r\n                }\r\n            })\r\n        }\r\n        //添加reject方法\r\n        Promise.reject = function(reason){\r\n            return new Promise((resolve,reject)=>{\r\n                reject(reason)\r\n            })\r\n        }\r\n        //添加all方法\r\n        Promise.all = function(Promises=[]){\r\n            return new Promise((resolve,reject)=>{\r\n        //声明计数器\r\n                let count = 0\r\n        //成功结果数字\r\n                let results = []\r\n                for(let i =0 ; i<Promises.length;i++)\r\n                Promises[i].then(value=>{\r\n        //自增计数器\r\n                    count++;\r\n        //存入结果值\r\n                    results[i]=value\r\n        //判断是否所有都成功\r\n                    if(count == Promises.length){\r\n        //返回结果\r\n                        resolve(results)\r\n                    }\r\n                },reason=>{\r\n        //若有任何一个结果为失败，则all返回的也是失败\r\n                    reject(reason);\r\n                })\r\n            })\r\n        }\r\n        // 添加race方法\r\n        Promise.race = function(Promises=[]){\r\n        // 返回\r\n            return new Promise((resolve,reject)=>{\r\n        // 遍历\r\n                for(let i=0 ; i<Promises.length;i++){\r\n        // 谁先改变状态，谁就能决定返回值的状态\r\n                    Promises[i].then(value=>{\r\n                        resolve(value)\r\n                    },reason=>{\r\n                        reject(reason)\r\n                    })\r\n                }\r\n            })\r\n        }\r\n        let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## 封装成类\r\n```js\r\n//1. 类名\r\n        class Promise{\r\n//2. 构造函数\r\n            constructor(executor){\r\n                //添加属性\r\n                this.PromsieState = 'pending';\r\n                this.PromsieResult = null ;\r\n                // 声明属性用于保存回调函数\r\n                // this.callBack = {}\r\n                //修改为保存数组\r\n                this.callBacks = []\r\n\r\n                //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n                const self = this;//self _this that\r\n\r\n                //执行器函数executor在构造函数中是同步调用的:\r\n                // executor();\r\n\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                // executor(resolve,reject);\r\n\r\n                //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n                try{\r\n                    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                    executor(resolve,reject);\r\n                }catch(error){\r\n                    reject(error)\r\n                }\r\n\r\n\r\n                //resolve()是一个函数，应当有一个形式参数\r\n                function resolve(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //修改实例化对象的状态值(属性名：promiseState)\r\n                    self.PromsieState = \"fulfilled\"\r\n                    //修改实例化对象的结果值(属性名：promiseResult)\r\n                    self.PromsieResult = data;\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onResolved)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onResolved(data)\r\n                    // }\r\n                    //执行所有成功的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onResolved(data)\r\n                    })\r\n                }\r\n                //reject()是一个函数，应当有一个形式参数\r\n                function reject(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //reject()函数同resolve一样\r\n                    self.PromsieState = \"rejected\"\r\n                    self.PromsieResult = data;\r\n\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onRejected)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onRejected(data)\r\n                    // }\r\n                    //执行所有失败的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onRejected(data)\r\n                    })\r\n                }\r\n        }\r\n//3. then方法\r\n            then(onResolved,onRejected){\r\n                //then的返回值是一个promise\r\n                return new Promise((resolve,reject)=>{\r\n                    //声明变量\r\n                    let self = this\r\n                    //处理失败回调函数为undefined的情况（省略没有写）\r\n                    if(onRejected !== \"function\"){\r\n                        onRejected = (reason)=>{\r\n                            throw reason;\r\n                        }\r\n                    }\r\n                    //处理成功回调函数为undefined的情况（省略没有写）\r\n                    if(onResolved !== \"function\"){\r\n                        onResolved = value=>value\r\n                    }\r\n                    // 定义函数\r\n                    function callback(type){\r\n                        //使得回调函数异步执行\r\n                        setTimeout(() => {\r\n                            try{\r\n                                //获取返回值\r\n                                let result = type(self.PromsieResult);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        }, 0);\r\n\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"fulfilled\")\r\n                    {\r\n                        //传递value\r\n                        // onResolved(this.PromsieResult);\r\n                        //调用函数\r\n                        callback(onResolved)\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"rejected\")\r\n                    {\r\n                        //传递reason\r\n                        // onRejected(this.PromsieResult);\r\n                        //rejected处理过程类似\r\n                        //调用函数\r\n                        callback(onRejected)\r\n                    }\r\n                    //处理当执行器中存在异步语句的情形\r\n                    if(this.PromsieState == \"pending\")\r\n                    {\r\n                        // 保存回调函数\r\n                        // this.callBack = {\r\n                        //     onResolved:onResolved,\r\n                        //     onRejected:onRejected\r\n                        // }\r\n                        //保存所有回调函数\r\n                        this.callBacks.push({\r\n                            //处理执行器中异步执行时回调\r\n                            onResolved:function(data){\r\n                                //调用函数\r\n                                callback(onResolved)\r\n                            },\r\n                            onRejected:function(data){\r\n                                //调用函数\r\n                                callback(onRejected)\r\n                            }\r\n                        })\r\n                    }\r\n                })\r\n                \r\n            }\r\n//4. catch方法\r\n            catch(onRejected){\r\n                return this.then(undefined,onRejected);\r\n            }\r\n//5. resolve方法\r\n            static resolve(value){\r\n            //返回promise对象\r\n                return new Promise((resolve,reject)=>{\r\n                    if(value instanceof Promise){\r\n                        value.then(v=>{\r\n                            resolve(v);\r\n                        },r=>{\r\n                            reject(r);\r\n                        });\r\n                    }else{\r\n                        resolve(value);\r\n                    }\r\n                })\r\n            }\r\n//6. reject方法\r\n            static reject(reason){\r\n                return new Promise((resolve,reject)=>{\r\n                    reject(reason)\r\n                })\r\n            }\r\n// 7. all方法\r\n            static all(Promises=[]){\r\n                return new Promise((resolve,reject)=>{\r\n            //声明计数器\r\n                    let count = 0\r\n            //成功结果数字\r\n                    let results = []\r\n                    for(let i =0 ; i<Promises.length;i++)\r\n                    Promises[i].then(value=>{\r\n            //自增计数器\r\n                        count++;\r\n            //存入结果值\r\n                        results[i]=value\r\n            //判断是否所有都成功\r\n                        if(count == Promises.length){\r\n            //返回结果\r\n                            resolve(results)\r\n                        }\r\n                    },reason=>{\r\n            //若有任何一个结果为失败，则all返回的也是失败\r\n                        reject(reason);\r\n                    })\r\n                })\r\n            }\r\n// 8. race方法\r\n            static race(Promises=[]){\r\n            // 返回\r\n                return new Promise((resolve,reject)=>{\r\n            // 遍历\r\n                    for(let i=0 ; i<Promises.length;i++){\r\n            // 谁先改变状态，谁就能决定返回值的状态\r\n                        Promises[i].then(value=>{\r\n                            resolve(value)\r\n                        },reason=>{\r\n                            reject(reason)\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n       let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```\r\n\r\n## 封装成类\r\n```js\r\n//1. 类名\r\n        class Promise{\r\n//2. 构造函数\r\n            constructor(executor){\r\n                //添加属性\r\n                this.PromsieState = 'pending';\r\n                this.PromsieResult = null ;\r\n                // 声明属性用于保存回调函数\r\n                // this.callBack = {}\r\n                //修改为保存数组\r\n                this.callBacks = []\r\n\r\n                //保存变量;因为在resolve()中会使用到this，而resolve()并不是通过this.resolve()调用的，而是resolve()直接调用的，所以其中this指向的是window\r\n                const self = this;//self _this that\r\n\r\n                //执行器函数executor在构造函数中是同步调用的:\r\n                // executor();\r\n\r\n                //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                // executor(resolve,reject);\r\n\r\n                //异常处理：执行器函数中的代码抛出异常后应当改变实例化后的promise对象状态，同时结果值应当改变为该抛出的异常\r\n                try{\r\n                    //执行器函数executor()的实参resolve(),reject()本身也是函数，是预先定义的，通过值传递的\r\n                    executor(resolve,reject);\r\n                }catch(error){\r\n                    reject(error)\r\n                }\r\n\r\n\r\n                //resolve()是一个函数，应当有一个形式参数\r\n                function resolve(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //修改实例化对象的状态值(属性名：promiseState)\r\n                    self.PromsieState = \"fulfilled\"\r\n                    //修改实例化对象的结果值(属性名：promiseResult)\r\n                    self.PromsieResult = data;\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onResolved)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onResolved(data)\r\n                    // }\r\n                    //执行所有成功的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onResolved(data)\r\n                    })\r\n                }\r\n                //reject()是一个函数，应当有一个形式参数\r\n                function reject(data){\r\n                    //实现状态只能修改一次：判断状态是否为初始状态\r\n                    if (self.PromsieState !==\"pending\") return;\r\n                    \r\n                    //reject()函数同resolve一样\r\n                    self.PromsieState = \"rejected\"\r\n                    self.PromsieResult = data;\r\n\r\n                    // 处理执行器中存在异步语句的情形：判断是否保存有回调函数\r\n                    // if(self.callBack.onRejected)\r\n                    // {\r\n                    //     //执行保存的回调函数\r\n                    //     self.callBack.onRejected(data)\r\n                    // }\r\n                    //执行所有失败的回调函数\r\n                    self.callBacks.forEach(item=>{\r\n                        item.onRejected(data)\r\n                    })\r\n                }\r\n        }\r\n//3. then方法\r\n            then(onResolved,onRejected){\r\n                //then的返回值是一个promise\r\n                return new Promise((resolve,reject)=>{\r\n                    //声明变量\r\n                    let self = this\r\n                    //处理失败回调函数为undefined的情况（省略没有写）\r\n                    if(onRejected !== \"function\"){\r\n                        onRejected = (reason)=>{\r\n                            throw reason;\r\n                        }\r\n                    }\r\n                    //处理成功回调函数为undefined的情况（省略没有写）\r\n                    if(onResolved !== \"function\"){\r\n                        onResolved = value=>value\r\n                    }\r\n                    // 定义函数\r\n                    function callback(type){\r\n                        //使得回调函数异步执行\r\n                        setTimeout(() => {\r\n                            try{\r\n                                //获取返回值\r\n                                let result = type(self.PromsieResult);\r\n                                //判断是否为promise对象\r\n                                if(result instanceof Promise){\r\n                                    //分情况处理:回调函数返回成功的promise则then也返回成功的promise,反之亦然\r\n                                    result.then(v=>{\r\n                                        resolve(v)\r\n                                    },r=>{\r\n                                        reject(r)\r\n                                    })\r\n                                }else{\r\n                                    //处理非promise对象的情况\r\n                                    resolve(result)\r\n                                }\r\n                            }catch(error){\r\n                                //处理抛出的异常\r\n                                reject(error)\r\n                            }\r\n                        }, 0);\r\n\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"fulfilled\")\r\n                    {\r\n                        //传递value\r\n                        // onResolved(this.PromsieResult);\r\n                        //调用函数\r\n                        callback(onResolved)\r\n                    }\r\n                    //根据promise状态执行回调函数\r\n                    if(this.PromsieState == \"rejected\")\r\n                    {\r\n                        //传递reason\r\n                        // onRejected(this.PromsieResult);\r\n                        //rejected处理过程类似\r\n                        //调用函数\r\n                        callback(onRejected)\r\n                    }\r\n                    //处理当执行器中存在异步语句的情形\r\n                    if(this.PromsieState == \"pending\")\r\n                    {\r\n                        // 保存回调函数\r\n                        // this.callBack = {\r\n                        //     onResolved:onResolved,\r\n                        //     onRejected:onRejected\r\n                        // }\r\n                        //保存所有回调函数\r\n                        this.callBacks.push({\r\n                            //处理执行器中异步执行时回调\r\n                            onResolved:function(data){\r\n                                //调用函数\r\n                                callback(onResolved)\r\n                            },\r\n                            onRejected:function(data){\r\n                                //调用函数\r\n                                callback(onRejected)\r\n                            }\r\n                        })\r\n                    }\r\n                })\r\n                \r\n            }\r\n//4. catch方法\r\n            catch(onRejected){\r\n                return this.then(undefined,onRejected);\r\n            }\r\n//5. resolve方法\r\n            static resolve(value){\r\n            //返回promise对象\r\n                return new Promise((resolve,reject)=>{\r\n                    if(value instanceof Promise){\r\n                        value.then(v=>{\r\n                            resolve(v);\r\n                        },r=>{\r\n                            reject(r);\r\n                        });\r\n                    }else{\r\n                        resolve(value);\r\n                    }\r\n                })\r\n            }\r\n//6. reject方法\r\n            static reject(reason){\r\n                return new Promise((resolve,reject)=>{\r\n                    reject(reason)\r\n                })\r\n            }\r\n// 7. all方法\r\n            static all(Promises=[]){\r\n                return new Promise((resolve,reject)=>{\r\n            //声明计数器\r\n                    let count = 0\r\n            //成功结果数字\r\n                    let results = []\r\n                    for(let i =0 ; i<Promises.length;i++)\r\n                    Promises[i].then(value=>{\r\n            //自增计数器\r\n                        count++;\r\n            //存入结果值\r\n                        results[i]=value\r\n            //判断是否所有都成功\r\n                        if(count == Promises.length){\r\n            //返回结果\r\n                            resolve(results)\r\n                        }\r\n                    },reason=>{\r\n            //若有任何一个结果为失败，则all返回的也是失败\r\n                        reject(reason);\r\n                    })\r\n                })\r\n            }\r\n// 8. race方法\r\n            static race(Promises=[]){\r\n            // 返回\r\n                return new Promise((resolve,reject)=>{\r\n            // 遍历\r\n                    for(let i=0 ; i<Promises.length;i++){\r\n            // 谁先改变状态，谁就能决定返回值的状态\r\n                        Promises[i].then(value=>{\r\n                            resolve(value)\r\n                        },reason=>{\r\n                            reject(reason)\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        }\r\n\r\n       let p = new Promise((resolve,reject)=>{\r\n            setTimeout(() => {\r\n                reject(\"ok\")\r\n            }, 1000);\r\n        })\r\n        p.then((value)=>{\r\n            console.log(value)\r\n        }).then(value=>{\r\n            console.log(value);\r\n        }).catch((reason)=>{\r\n            console.log(reason)\r\n        })\r\n        //使用测试\r\n        let k = Promise.resolve(\"OKKKKK\")\r\n        console.log(k);\r\n        //使用测试\r\n        let j = Promise.reject(\"fail\")\r\n        console.log(j);\r\n```"},{"shortInfo":{"layout":"post","title":"整理了下最近的笔记","date":"2022-02-23T02:31:00.000Z","cover":"\\self_server\\assets\\images\\book1.jpg","tags":["日志","加密"],"hideAtIndex":true,"categories":"日志","id":84,"countWords":523,"readSeconds":52.3,"assetsbaseUrl":"/self_server/assets/"},"content":"## 整理了下最近的笔记😎\r\n\r\n有段时间没写博客了,突然觉得应该把这两个月的笔记整理下,又因为觉得原先的网站配色不是很好看，又有点BUG，于是就把之前在GitHub上收藏的一个博客主题找了出来，打算配置下用用看。这个主题是Hexo框架的，原先用的是jekyll的框架。Hexo框架好像使用nodejs写的，nodejs之前学过，npm工具之类的不算陌生。安装配置倒是没遇到什么问题，就是这个主题有点毛病，修修改改的弄了好半天。然后又把原先的文章迁移过来，一顿修修改改。最近做的笔记，整理整理，又是一顿修修改改。还有这段时间在学Deep Learning，做的jupyter笔记，转换格式成markdown，修修改改。这一顿操作下来，遇到的问题写一写，记录一下，修修改改，一晚上时间没了~\r\n\r\n## 23333👀\r\n\r\n因为过程中看了看别人写的博客，那种从好几年前一直记录到现在的，生活的、学习的，工作的，反正什么都有，看起来还挺不错的，感觉我这么写下去应该也能达到那种效果。\r\n\r\n## 关于为什么写博客\r\n\r\n相信大多数写技术博客的人的初衷都是一样的，就是把博客当备忘笔记来写。因为有时候会碰到那种需要百度半天才能找到的解决方法，而如果过了很长时间之后的下次又碰到同样的问题，想不起来也没有博客当笔记的话就又得到百度上找半天，非常浪费时间。学过的知识点不记录也是一样的，过了很长时间之后要是想不起来了，几乎是要翻书百度很长时间。索性不如第一遍学的时候就归纳总结写下来，下次要是忘了就能到自己写的博客上查，多方便啊~😁"},{"shortInfo":{"layout":"post","title":"本科上岸了","date":"2022-06-28T11:12:00.000Z","coverWidth":700,"coverHeight":394,"cover":"\\self_server\\assets\\images\\本科上岸了\\2022-07-01-22-32-19.png","tags":["日志"],"categories":"日志","id":83,"countWords":80,"readSeconds":8,"assetsbaseUrl":"/self_server/assets/"},"content":"## 上岸了\r\n\r\n**上岸了，录取了，至少不是大专了**\r\n<!-- <img src=\"/images/本科上岸了/2022-07-01-22-18-42.png\" style=\"display:inline-block;height:30px;border-radius: 0;\">,以后也是全日制本科了** -->\r\n\r\n![](./images/本科上岸了/2022-07-01-22-17-12.png)\r\n\r\n\r\n<!-- ![](./images/本科上岸了/2022-07-01-22-35-33.png) -->\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"layout":"post","title":"欢迎来到我的博客站点(旧版)","date":"2021-12-28T11:32:00.000Z","cover":"\\self_server\\assets\\images\\home1.jpg","tags":["欢迎","日志"],"hideAtIndex":true,"categories":"日志","id":85,"countWords":55,"readSeconds":5.5,"assetsbaseUrl":"/self_server/assets/"},"content":"# 欢迎\r\n这是一个搭建在GitHub Pages的个人博客站点\r\n<br>网站使用HTML语言和Liquid编写 最终使用jekyllrb生成\r\n```\r\n#include<stdio.h>\r\nint main()\r\n{\r\n    printf(\"欢迎来到我的博客站点\");\r\n    return 0;\r\n}\r\n```\r\n"},{"shortInfo":{"title":"滚动条动态居中","cover":"\\self_server\\assets\\images\\default_cover2.jpg","date":"2022-06-02T06:58:57.000Z","tags":["html","js"],"hideAtIndex":true,"categories":"前端","id":86,"countWords":112,"readSeconds":11.2,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动端滚动条动态水平居中\r\n* **关键代码**\r\n\r\n```js\r\n//滚动条位置居中,使得标题能在移动端被居中\r\n    function middleScroll(step,totalTime){\r\n      let f = document.getElementById(\"BOX_outside\")\r\n      let s = document.getElementById(\"BOX_inside\")\r\n      let delayTime= totalTime / ((s.clientWidth - f.clientWidth) / 2 / step)\r\n\r\n      let scrollTimer = setInterval(\r\n        () => {\r\n          if (f.scrollLeft <= (s.clientWidth - f.clientWidth) / 2 )\r\n          {\r\n            f.scrollLeft+=step;\r\n          }else\r\n          {\r\n            clearInterval(scrollTimer);\r\n          }\r\n      }, delayTime);\r\n  }\r\n  window.addEventListener('loaded',middleScroll(2,500)) //移动端动态局居中效果，每次移动2px 在500ms内使标题居中\r\n```\r\n\r\n* **效果**\r\n![](../images/gif/2022_06_02_15_07_08_663.gif)\r\n"},{"shortInfo":{"layout":"post","title":"用js写了个网页版俄罗斯方块","date":"2022-01-09T13:39:00.000Z","cover":"\\self_server\\assets\\images\\俄罗斯方块.png","tags":["网站","游戏"],"categories":"前端","id":87,"countWords":28,"readSeconds":2.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# [-->点击试玩V1.01<--](./demos/html-js_russia_client/index.html)\r\n# [-->点击试玩V1.00<--](./demos/games/html_jsRussia_client/index.html)\r\n\r\n<style>\r\nh1{\r\n    text-align: center;\r\n}\r\n</style>"},{"shortInfo":{"layout":"post","title":"用WordPress搭建的新博客站点","date":"2022-05-24T17:12:00.000Z","cover":"\\self_server\\assets\\images\\新站点.png","tags":["前端"],"hideAtIndex":true,"categories":"前端","id":89,"countWords":26,"readSeconds":2.6,"assetsbaseUrl":"/self_server/assets/"},"content":"#### 用WordPress搭建的新博客站点:\r\n\r\n\r\n<a href=\"http://120.27.243.59:22222/\"><h1>新博客站点</h1></a>"},{"shortInfo":{"title":"电路原理核心知识点笔记","cover":"\\self_server\\assets\\images\\电路原理\\cover.jpg","coverWidth":480,"coverHeight":307,"date":"2022-06-19T00:08:00.000Z","tags":["电路"],"hideAtIndex":true,"categories":"笔记","id":88,"countWords":1256,"readSeconds":125.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 电路原理核心知识点笔记\r\n\r\n## 目录\r\n- [电路原理核心知识点笔记](#电路原理核心知识点笔记)\r\n  - [目录](#目录)\r\n  - [支路量](#支路量)\r\n    - [电流](#电流)\r\n    - [电压](#电压)\r\n    - [电位](#电位)\r\n    - [电动势](#电动势)\r\n    - [变量的大小写](#变量的大小写)\r\n  - [参考方向](#参考方向)\r\n    - [电流参考方向的两种表示方式](#电流参考方向的两种表示方式)\r\n    - [电压参考方向的三种表示方式](#电压参考方向的三种表示方式)\r\n    - [电动势参考方向的三种表示方式](#电动势参考方向的三种表示方式)\r\n    - [关联参考方向](#关联参考方向)\r\n    - [非关联参考方向](#非关联参考方向)\r\n  - [功率](#功率)\r\n    - [功率的发出和吸收的判断](#功率的发出和吸收的判断)\r\n      - [一种记忆理解方式](#一种记忆理解方式)\r\n      - [另一种记忆理解方式](#另一种记忆理解方式)\r\n  - [端口](#端口)\r\n\r\n## 支路量\r\n\r\n### 电流\r\n* 定义：电荷随时间的变化率\r\n* 表达式：![](./images/电路原理/2022-06-19-08-09-16.png)\r\n* 计算的电流：正电荷在单位时间内流过导体的数量\r\n* 单位：$A$安培\r\n\r\n### 电压\r\n* 定义： **电场力**将单位的正电荷移动所做的功\r\n* 表达式：![](./images/电路原理/2022-06-19-08-14-40.png)\r\n* 单位：$V$伏特\r\n\r\n### 电位\r\n* 定义： 从某一点到参考点的电压\r\n* 参考点：\r\n    * 参考点的电位值人为定义为0\r\n    * 符号$φ$或$U$\r\n    * 单位V伏特\r\n    * 一个电路只能有一个参考点(0电位点)\r\n* 两点之间的电压等于两点之间电位差$U_{ab}=φ_a-φ_b$\r\n* 两点之间电位差可以称为电位降，电位降就是电压，所以也称电压为电压降\r\n* 两点之间的电压和参考点是谁无关\r\n\r\n### 电动势\r\n* 定义： **非电场力**将单位正电荷移动所做的功\r\n* 表达式： ![](./images/电路原理/2022-06-19-08-36-05.png)\r\n* 对比电场力和非电场力\r\n    * $e_{BA}$表征的是非电场力使得单位正电荷从B点到A点移动，使得电位升高，意味着能量的增加 $e_{BA}=φ_a-φ_b$\r\n    * $u_{AB}$表征的是电场力使得单位正电荷从A点到B点移动，使得电位降低，意味着能量的消耗 $u_{BA}=φ_a-φ_b$\r\n\r\n### 变量的大小写\r\n* 常量用大写$U$ $I$\r\n* 可能发生改变用小写$u(t)$ $i(t)$\r\n\r\n## 参考方向\r\n### 电流参考方向的两种表示方式\r\n* 箭头：箭头指向电流的流向方向\r\n* 下标：$i_{AB}$表示电流方向从A流向B，如果$i_{AB}>0$ 则电流的实际方向和参考方向一致\r\n<!-- ![](./images/电路原理/2022-06-19-09-05-49.png) -->\r\n### 电压参考方向的三种表示方式\r\n* 箭头\r\n* 正负号\r\n* 双下标：$U_{AB}$ 表示电压从A到B的电位降\r\n![](./images/电路原理/2022-06-19-09-04-27.png)\r\n\r\n### 电动势参考方向的三种表示方式\r\n* 箭头\r\n* 正负号\r\n* 双下标：$e_{AB}$ 表示电动势从B到A的电位升\r\n![](./images/电路原理/2022-06-19-09-05-19.png)\r\n\r\n### 关联参考方向\r\n* 电流从电压的正端流入 负端流出\r\n![](./images/电路原理/2022-06-19-09-08-45.png)\r\n\r\n### 非关联参考方向\r\n* 电流从电压的负端流入 正端流出\r\n![](./images/电路原理/2022-06-19-09-08-55.png)\r\n\r\n## 功率\r\n* 定义：电场力在单位时间内所做的功\r\n* 定义式：\r\n    * ![](./images/电路原理/2022-06-19-09-13-01.png)\r\n    * ![](./images/电路原理/2022-06-19-09-13-42.png)\r\n* 功率的单位是瓦\r\n* 能量的单位是焦耳\r\n* 功率守恒：一个电路所发出的总功率等于这个电路所吸收的总功率\r\n\r\n### 功率的发出和吸收的判断\r\n![](./images/电路原理/2022-06-19-09-26-44.png)\r\n#### 一种记忆理解方式\r\n* **认为在关联参考方向下，计算的是元件吸收的功率$P_a=ui$，功率为正，实际为吸收**\r\n* **认为在关联参考方向下，计算的是元件吸收的功率$P_a=ui$，功率为负，实际为发出**\r\n* 认为在非关联参考方向下，计算的是元件发出的功率$P_d=ui$，功率为正，实际为发出\r\n* 认为在非关联参考方向下，计算的是元件发出的功率$P_d=ui$，功率为负，实际为吸收\r\n\r\n#### 另一种记忆理解方式\r\n* 认为在关联参考方向下，计算的是元件**吸收**的功率$P_a=ui$，功率为正，实际为吸收\r\n* 认为在关联参考方向下，计算的是元件**吸收**的功率$P_a=ui$，功率为负，实际为发出\r\n* 认为在非关联参考方向下，计算的是元件**吸收**的功率$P_a=-ui$，功率为正，实际为吸收\r\n* 认为在非关联参考方向下，计算的是元件**吸收**的功率$P_a=-ui$，功率为负，实际为发出\r\n\r\n## 端口"},{"shortInfo":{"title":"移动端click事件问题","date":"2022-07-06T19:50:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["移动端","click事件"],"hideAtIndex":true,"categories":"笔记","id":90,"countWords":3544,"readSeconds":354.4,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动端click事件问题\r\n移动端click事件会有300ms的延迟，因为最初移动端需要用两只手指来放大页面，然后通过双击页面来恢复页面大小（double tap to zoom），300ms的延迟就是用来判断是否双击屏幕的，若两次点击屏幕的间隔小于300ms则判断是双击屏幕，大于300ms则被判断为click事件\r\n\r\n## 解决方案:禁用缩放\r\n禁用缩放后也就不存在双击屏幕恢复页面默认大小的功能，于是300ms的延迟就不存在了\r\n```html\r\n<meta name=\"viewport\" content=\"user-scalable=no\">\r\n```\r\n\r\n## 解决方案:利用touch事件自己封装函数\r\n* 手指触摸时记录触摸时间\r\n* 手指离开时记录离开时间\r\n* 手指移动时记录是否移动\r\n* 当手指触摸和离开时间间隔小于150ms 且手指没有滑动屏幕，则判断为点击\r\n\r\n```js\r\nfunction tap(obj,callback){\r\n    obj.isMove = false;\r\n    obj.touchStart = 0;\r\n    obj.touchEnd = 0;\r\n    obj.addEventListener(\"touchstart\",function(){\r\n        obj.touchStart = +new Date();//记录触摸时间\r\n    });\r\n    obj.addEventListener(\"touchmove\",function(){\r\n        obj.isMove = true;//记录是否移动\r\n    });\r\n    obj.addEventListener(\"touchend\",function(){\r\n        obj.touchEnd = +new Date();//记录离开时间\r\n        if(obj.touchEnd -  obj.touchStart > 150  && !obj.isMove)\r\n        {\r\n            callback && callback();\r\n        }\r\n        obj.isMove = false;\r\n        obj.touchStart = 0;\r\n        obj.touchEnd = 0;\r\n    });\r\n}\r\n//使用\r\ntap(div,function(){\r\n    //do something\r\n})\r\n```\r\n\r\n## 解决方案:使用fastclick.js插件\r\n\r\n\r\n\r\ngithub仓库：[fastclick.js](https://github.com/ftlabs/fastclick)  \r\n\r\n使用：****\r\n```html\r\n<script type='application/javascript' src='/path/to/fastclick.js'></script>\r\n<script>\r\n    // 原生js使用：\r\n    if ('addEventListener' in document) {\r\n        document.addEventListener('DOMContentLoaded', function() {\r\n\t\t    FastClick.attach(document.body);\r\n\t    }, false);\r\n    }\r\n    //jQuery使用：\r\n    $(function() {\r\n        FastClick.attach(document.body);\r\n    });\r\n</script>\r\n```\r\n\r\n**注意**\r\n\r\nNote: As of late 2015 most mobile browsers - notably Chrome and Safari - no longer have a 300ms touch delay, so fastclick offers no benefit on newer browsers, and risks introducing bugs into your application. Consider carefully whether you really need to use it.\r\n\r\n截止到2015年，Chrome and Safari已经不再有300毫秒的触摸延迟了\r\n\r\n\r\n**完整源代码**\r\n```js\r\n;(function () {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.\r\n\t *\r\n\t * @codingstandard ftlabs-jsv2\r\n\t * @copyright The Financial Times Limited [All Rights Reserved]\r\n\t * @license MIT License (see LICENSE.txt)\r\n\t */\r\n\r\n\t/*jslint browser:true, node:true*/\r\n\t/*global define, Event, Node*/\r\n\r\n\r\n\t/**\r\n\t * Instantiate fast-clicking listeners on the specified layer.\r\n\t *\r\n\t * @constructor\r\n\t * @param {Element} layer The layer to listen on\r\n\t * @param {Object} [options={}] The options to override the defaults\r\n\t */\r\n\tfunction FastClick(layer, options) {\r\n\t\tvar oldOnClick;\r\n\r\n\t\toptions = options || {};\r\n\r\n\t\t/**\r\n\t\t * Whether a click is currently being tracked.\r\n\t\t *\r\n\t\t * @type boolean\r\n\t\t */\r\n\t\tthis.trackingClick = false;\r\n\r\n\r\n\t\t/**\r\n\t\t * Timestamp for when click tracking started.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.trackingClickStart = 0;\r\n\r\n\r\n\t\t/**\r\n\t\t * The element being tracked for a click.\r\n\t\t *\r\n\t\t * @type EventTarget\r\n\t\t */\r\n\t\tthis.targetElement = null;\r\n\r\n\r\n\t\t/**\r\n\t\t * X-coordinate of touch start event.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.touchStartX = 0;\r\n\r\n\r\n\t\t/**\r\n\t\t * Y-coordinate of touch start event.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.touchStartY = 0;\r\n\r\n\r\n\t\t/**\r\n\t\t * ID of the last touch, retrieved from Touch.identifier.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.lastTouchIdentifier = 0;\r\n\r\n\r\n\t\t/**\r\n\t\t * Touchmove boundary, beyond which a click will be cancelled.\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.touchBoundary = options.touchBoundary || 10;\r\n\r\n\r\n\t\t/**\r\n\t\t * The FastClick layer.\r\n\t\t *\r\n\t\t * @type Element\r\n\t\t */\r\n\t\tthis.layer = layer;\r\n\r\n\t\t/**\r\n\t\t * The minimum time between tap(touchstart and touchend) events\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.tapDelay = options.tapDelay || 200;\r\n\r\n\t\t/**\r\n\t\t * The maximum time for a tap\r\n\t\t *\r\n\t\t * @type number\r\n\t\t */\r\n\t\tthis.tapTimeout = options.tapTimeout || 700;\r\n\r\n\t\tif (FastClick.notNeeded(layer)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Some old versions of Android don't have Function.prototype.bind\r\n\t\tfunction bind(method, context) {\r\n\t\t\treturn function() { return method.apply(context, arguments); };\r\n\t\t}\r\n\r\n\r\n\t\tvar methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];\r\n\t\tvar context = this;\r\n\t\tfor (var i = 0, l = methods.length; i < l; i++) {\r\n\t\t\tcontext[methods[i]] = bind(context[methods[i]], context);\r\n\t\t}\r\n\r\n\t\t// Set up event handlers as required\r\n\t\tif (deviceIsAndroid) {\r\n\t\t\tlayer.addEventListener('mouseover', this.onMouse, true);\r\n\t\t\tlayer.addEventListener('mousedown', this.onMouse, true);\r\n\t\t\tlayer.addEventListener('mouseup', this.onMouse, true);\r\n\t\t}\r\n\r\n\t\tlayer.addEventListener('click', this.onClick, true);\r\n\t\tlayer.addEventListener('touchstart', this.onTouchStart, false);\r\n\t\tlayer.addEventListener('touchmove', this.onTouchMove, false);\r\n\t\tlayer.addEventListener('touchend', this.onTouchEnd, false);\r\n\t\tlayer.addEventListener('touchcancel', this.onTouchCancel, false);\r\n\r\n\t\t// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\r\n\t\t// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick\r\n\t\t// layer when they are cancelled.\r\n\t\tif (!Event.prototype.stopImmediatePropagation) {\r\n\t\t\tlayer.removeEventListener = function(type, callback, capture) {\r\n\t\t\t\tvar rmv = Node.prototype.removeEventListener;\r\n\t\t\t\tif (type === 'click') {\r\n\t\t\t\t\trmv.call(layer, type, callback.hijacked || callback, capture);\r\n\t\t\t\t} else {\r\n\t\t\t\t\trmv.call(layer, type, callback, capture);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlayer.addEventListener = function(type, callback, capture) {\r\n\t\t\t\tvar adv = Node.prototype.addEventListener;\r\n\t\t\t\tif (type === 'click') {\r\n\t\t\t\t\tadv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {\r\n\t\t\t\t\t\tif (!event.propagationStopped) {\r\n\t\t\t\t\t\t\tcallback(event);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}), capture);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadv.call(layer, type, callback, capture);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\t// If a handler is already declared in the element's onclick attribute, it will be fired before\r\n\t\t// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and\r\n\t\t// adding it as listener.\r\n\t\tif (typeof layer.onclick === 'function') {\r\n\r\n\t\t\t// Android browser on at least 3.2 requires a new reference to the function in layer.onclick\r\n\t\t\t// - the old one won't work if passed to addEventListener directly.\r\n\t\t\toldOnClick = layer.onclick;\r\n\t\t\tlayer.addEventListener('click', function(event) {\r\n\t\t\t\toldOnClick(event);\r\n\t\t\t}, false);\r\n\t\t\tlayer.onclick = null;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.\r\n\t*\r\n\t* @type boolean\r\n\t*/\r\n\tvar deviceIsWindowsPhone = navigator.userAgent.indexOf(\"Windows Phone\") >= 0;\r\n\r\n\t/**\r\n\t * Android requires exceptions.\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;\r\n\r\n\r\n\t/**\r\n\t * iOS requires exceptions.\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;\r\n\r\n\r\n\t/**\r\n\t * iOS 4 requires an exception for select elements.\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsIOS4 = deviceIsIOS && (/OS 4_\\d(_\\d)?/).test(navigator.userAgent);\r\n\r\n\r\n\t/**\r\n\t * iOS 6.0-7.* requires the target element to be manually derived\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\\d/).test(navigator.userAgent);\r\n\r\n\t/**\r\n\t * BlackBerry requires exceptions.\r\n\t *\r\n\t * @type boolean\r\n\t */\r\n\tvar deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;\r\n\r\n\t/**\r\n\t * Determine whether a given element requires a native click.\r\n\t *\r\n\t * @param {EventTarget|Element} target Target DOM element\r\n\t * @returns {boolean} Returns true if the element needs a native click\r\n\t */\r\n\tFastClick.prototype.needsClick = function(target) {\r\n\t\tswitch (target.nodeName.toLowerCase()) {\r\n\r\n\t\t// Don't send a synthetic click to disabled inputs (issue #62)\r\n\t\tcase 'button':\r\n\t\tcase 'select':\r\n\t\tcase 'textarea':\r\n\t\t\tif (target.disabled) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase 'input':\r\n\r\n\t\t\t// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)\r\n\t\t\tif ((deviceIsIOS && target.type === 'file') || target.disabled) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase 'label':\r\n\t\tcase 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames\r\n\t\tcase 'video':\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn (/\\bneedsclick\\b/).test(target.className);\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Determine whether a given element requires a call to focus to simulate click into element.\r\n\t *\r\n\t * @param {EventTarget|Element} target Target DOM element\r\n\t * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.\r\n\t */\r\n\tFastClick.prototype.needsFocus = function(target) {\r\n\t\tswitch (target.nodeName.toLowerCase()) {\r\n\t\tcase 'textarea':\r\n\t\t\treturn true;\r\n\t\tcase 'select':\r\n\t\t\treturn !deviceIsAndroid;\r\n\t\tcase 'input':\r\n\t\t\tswitch (target.type) {\r\n\t\t\tcase 'button':\r\n\t\t\tcase 'checkbox':\r\n\t\t\tcase 'file':\r\n\t\t\tcase 'image':\r\n\t\t\tcase 'radio':\r\n\t\t\tcase 'submit':\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// No point in attempting to focus disabled inputs\r\n\t\t\treturn !target.disabled && !target.readOnly;\r\n\t\tdefault:\r\n\t\t\treturn (/\\bneedsfocus\\b/).test(target.className);\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Send a click event to the specified element.\r\n\t *\r\n\t * @param {EventTarget|Element} targetElement\r\n\t * @param {Event} event\r\n\t */\r\n\tFastClick.prototype.sendClick = function(targetElement, event) {\r\n\t\tvar clickEvent, touch;\r\n\r\n\t\t// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)\r\n\t\tif (document.activeElement && document.activeElement !== targetElement) {\r\n\t\t\tdocument.activeElement.blur();\r\n\t\t}\r\n\r\n\t\ttouch = event.changedTouches[0];\r\n\r\n\t\t// Synthesise a click event, with an extra attribute so it can be tracked\r\n\t\tclickEvent = document.createEvent('MouseEvents');\r\n\t\tclickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\r\n\t\tclickEvent.forwardedTouchEvent = true;\r\n\t\ttargetElement.dispatchEvent(clickEvent);\r\n\t};\r\n\r\n\tFastClick.prototype.determineEventType = function(targetElement) {\r\n\r\n\t\t//Issue #159: Android Chrome Select Box does not open with a synthetic click event\r\n\t\tif (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {\r\n\t\t\treturn 'mousedown';\r\n\t\t}\r\n\r\n\t\treturn 'click';\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * @param {EventTarget|Element} targetElement\r\n\t */\r\n\tFastClick.prototype.focus = function(targetElement) {\r\n\t\tvar length;\r\n\r\n\t\t// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.\r\n\t\tif (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month' && targetElement.type !== 'email') {\r\n\t\t\tlength = targetElement.value.length;\r\n\t\t\ttargetElement.setSelectionRange(length, length);\r\n\t\t} else {\r\n\t\t\ttargetElement.focus();\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.\r\n\t *\r\n\t * @param {EventTarget|Element} targetElement\r\n\t */\r\n\tFastClick.prototype.updateScrollParent = function(targetElement) {\r\n\t\tvar scrollParent, parentElement;\r\n\r\n\t\tscrollParent = targetElement.fastClickScrollParent;\r\n\r\n\t\t// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the\r\n\t\t// target element was moved to another parent.\r\n\t\tif (!scrollParent || !scrollParent.contains(targetElement)) {\r\n\t\t\tparentElement = targetElement;\r\n\t\t\tdo {\r\n\t\t\t\tif (parentElement.scrollHeight > parentElement.offsetHeight) {\r\n\t\t\t\t\tscrollParent = parentElement;\r\n\t\t\t\t\ttargetElement.fastClickScrollParent = parentElement;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparentElement = parentElement.parentElement;\r\n\t\t\t} while (parentElement);\r\n\t\t}\r\n\r\n\t\t// Always update the scroll top tracker if possible.\r\n\t\tif (scrollParent) {\r\n\t\t\tscrollParent.fastClickLastScrollTop = scrollParent.scrollTop;\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * @param {EventTarget} targetElement\r\n\t * @returns {Element|EventTarget}\r\n\t */\r\n\tFastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {\r\n\r\n\t\t// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.\r\n\t\tif (eventTarget.nodeType === Node.TEXT_NODE) {\r\n\t\t\treturn eventTarget.parentNode;\r\n\t\t}\r\n\r\n\t\treturn eventTarget;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * On touch start, record the position and scroll offset.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onTouchStart = function(event) {\r\n\t\tvar targetElement, touch, selection;\r\n\r\n\t\t// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).\r\n\t\tif (event.targetTouches.length > 1) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\ttargetElement = this.getTargetElementFromEventTarget(event.target);\r\n\t\ttouch = event.targetTouches[0];\r\n\r\n\t\tif (deviceIsIOS) {\r\n\r\n\t\t\t// Only trusted events will deselect text on iOS (issue #49)\r\n\t\t\tselection = window.getSelection();\r\n\t\t\tif (selection.rangeCount && !selection.isCollapsed) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tif (!deviceIsIOS4) {\r\n\r\n\t\t\t\t// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):\r\n\t\t\t\t// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched\r\n\t\t\t\t// with the same identifier as the touch event that previously triggered the click that triggered the alert.\r\n\t\t\t\t// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an\r\n\t\t\t\t// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.\r\n\t\t\t\t// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,\r\n\t\t\t\t// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,\r\n\t\t\t\t// random integers, it's safe to to continue if the identifier is 0 here.\r\n\t\t\t\tif (touch.identifier && touch.identifier === this.lastTouchIdentifier) {\r\n\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.lastTouchIdentifier = touch.identifier;\r\n\r\n\t\t\t\t// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:\r\n\t\t\t\t// 1) the user does a fling scroll on the scrollable layer\r\n\t\t\t\t// 2) the user stops the fling scroll with another tap\r\n\t\t\t\t// then the event.target of the last 'touchend' event will be the element that was under the user's finger\r\n\t\t\t\t// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check\r\n\t\t\t\t// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).\r\n\t\t\t\tthis.updateScrollParent(targetElement);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.trackingClick = true;\r\n\t\tthis.trackingClickStart = event.timeStamp;\r\n\t\tthis.targetElement = targetElement;\r\n\r\n\t\tthis.touchStartX = touch.pageX;\r\n\t\tthis.touchStartY = touch.pageY;\r\n\r\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\r\n\t\tif ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\r\n\t\t\tevent.preventDefault();\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.touchHasMoved = function(event) {\r\n\t\tvar touch = event.changedTouches[0], boundary = this.touchBoundary;\r\n\r\n\t\tif (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Update the last position.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onTouchMove = function(event) {\r\n\t\tif (!this.trackingClick) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// If the touch has moved, cancel the click tracking\r\n\t\tif (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {\r\n\t\t\tthis.trackingClick = false;\r\n\t\t\tthis.targetElement = null;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Attempt to find the labelled control for the given label element.\r\n\t *\r\n\t * @param {EventTarget|HTMLLabelElement} labelElement\r\n\t * @returns {Element|null}\r\n\t */\r\n\tFastClick.prototype.findControl = function(labelElement) {\r\n\r\n\t\t// Fast path for newer browsers supporting the HTML5 control attribute\r\n\t\tif (labelElement.control !== undefined) {\r\n\t\t\treturn labelElement.control;\r\n\t\t}\r\n\r\n\t\t// All browsers under test that support touch events also support the HTML5 htmlFor attribute\r\n\t\tif (labelElement.htmlFor) {\r\n\t\t\treturn document.getElementById(labelElement.htmlFor);\r\n\t\t}\r\n\r\n\t\t// If no for attribute exists, attempt to retrieve the first labellable descendant element\r\n\t\t// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label\r\n\t\treturn labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * On touch end, determine whether to send a click event at once.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onTouchEnd = function(event) {\r\n\t\tvar forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;\r\n\r\n\t\tif (!this.trackingClick) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\r\n\t\tif ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\r\n\t\t\tthis.cancelNextClick = true;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Reset to prevent wrong click cancel on input (issue #156).\r\n\t\tthis.cancelNextClick = false;\r\n\r\n\t\tthis.lastClickTime = event.timeStamp;\r\n\r\n\t\ttrackingClickStart = this.trackingClickStart;\r\n\t\tthis.trackingClick = false;\r\n\t\tthis.trackingClickStart = 0;\r\n\r\n\t\t// On some iOS devices, the targetElement supplied with the event is invalid if the layer\r\n\t\t// is performing a transition or scroll, and has to be re-detected manually. Note that\r\n\t\t// for this to function correctly, it must be called *after* the event target is checked!\r\n\t\t// See issue #57; also filed as rdar://13048589 .\r\n\t\tif (deviceIsIOSWithBadTarget) {\r\n\t\t\ttouch = event.changedTouches[0];\r\n\r\n\t\t\t// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null\r\n\t\t\ttargetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;\r\n\t\t\ttargetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;\r\n\t\t}\r\n\r\n\t\ttargetTagName = targetElement.tagName.toLowerCase();\r\n\t\tif (targetTagName === 'label') {\r\n\t\t\tforElement = this.findControl(targetElement);\r\n\t\t\tif (forElement) {\r\n\t\t\t\tthis.focus(targetElement);\r\n\t\t\t\tif (deviceIsAndroid) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetElement = forElement;\r\n\t\t\t}\r\n\t\t} else if (this.needsFocus(targetElement)) {\r\n\r\n\t\t\t// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.\r\n\t\t\t// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).\r\n\t\t\tif ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {\r\n\t\t\t\tthis.targetElement = null;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tthis.focus(targetElement);\r\n\t\t\tthis.sendClick(targetElement, event);\r\n\r\n\t\t\t// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.\r\n\t\t\t// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)\r\n\t\t\tif (!deviceIsIOS || targetTagName !== 'select') {\r\n\t\t\t\tthis.targetElement = null;\r\n\t\t\t\tevent.preventDefault();\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (deviceIsIOS && !deviceIsIOS4) {\r\n\r\n\t\t\t// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled\r\n\t\t\t// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).\r\n\t\t\tscrollParent = targetElement.fastClickScrollParent;\r\n\t\t\tif (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Prevent the actual click from going though - unless the target node is marked as requiring\r\n\t\t// real clicks or if it is in the allowlist in which case only non-programmatic clicks are permitted.\r\n\t\tif (!this.needsClick(targetElement)) {\r\n\t\t\tevent.preventDefault();\r\n\t\t\tthis.sendClick(targetElement, event);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * On touch cancel, stop tracking the click.\r\n\t *\r\n\t * @returns {void}\r\n\t */\r\n\tFastClick.prototype.onTouchCancel = function() {\r\n\t\tthis.trackingClick = false;\r\n\t\tthis.targetElement = null;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Determine mouse events which should be permitted.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onMouse = function(event) {\r\n\r\n\t\t// If a target element was never set (because a touch event was never fired) allow the event\r\n\t\tif (!this.targetElement) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (event.forwardedTouchEvent) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Programmatically generated events targeting a specific element should be permitted\r\n\t\tif (!event.cancelable) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Derive and check the target element to see whether the mouse event needs to be permitted;\r\n\t\t// unless explicitly enabled, prevent non-touch click events from triggering actions,\r\n\t\t// to prevent ghost/doubleclicks.\r\n\t\tif (!this.needsClick(this.targetElement) || this.cancelNextClick) {\r\n\r\n\t\t\t// Prevent any user-added listeners declared on FastClick element from being fired.\r\n\t\t\tif (event.stopImmediatePropagation) {\r\n\t\t\t\tevent.stopImmediatePropagation();\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\r\n\t\t\t\tevent.propagationStopped = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Cancel the event\r\n\t\t\tevent.stopPropagation();\r\n\t\t\tevent.preventDefault();\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// If the mouse event is permitted, return true for the action to go through.\r\n\t\treturn true;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * On actual clicks, determine whether this is a touch-generated click, a click action occurring\r\n\t * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or\r\n\t * an actual click which should be permitted.\r\n\t *\r\n\t * @param {Event} event\r\n\t * @returns {boolean}\r\n\t */\r\n\tFastClick.prototype.onClick = function(event) {\r\n\t\tvar permitted;\r\n\r\n\t\t// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.\r\n\t\tif (this.trackingClick) {\r\n\t\t\tthis.targetElement = null;\r\n\t\t\tthis.trackingClick = false;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.\r\n\t\tif (event.target.type === 'submit' && event.detail === 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tpermitted = this.onMouse(event);\r\n\r\n\t\t// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.\r\n\t\tif (!permitted) {\r\n\t\t\tthis.targetElement = null;\r\n\t\t}\r\n\r\n\t\t// If clicks are permitted, return true for the action to go through.\r\n\t\treturn permitted;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Remove all FastClick's event listeners.\r\n\t *\r\n\t * @returns {void}\r\n\t */\r\n\tFastClick.prototype.destroy = function() {\r\n\t\tvar layer = this.layer;\r\n\r\n\t\tif (deviceIsAndroid) {\r\n\t\t\tlayer.removeEventListener('mouseover', this.onMouse, true);\r\n\t\t\tlayer.removeEventListener('mousedown', this.onMouse, true);\r\n\t\t\tlayer.removeEventListener('mouseup', this.onMouse, true);\r\n\t\t}\r\n\r\n\t\tlayer.removeEventListener('click', this.onClick, true);\r\n\t\tlayer.removeEventListener('touchstart', this.onTouchStart, false);\r\n\t\tlayer.removeEventListener('touchmove', this.onTouchMove, false);\r\n\t\tlayer.removeEventListener('touchend', this.onTouchEnd, false);\r\n\t\tlayer.removeEventListener('touchcancel', this.onTouchCancel, false);\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Check whether FastClick is needed.\r\n\t *\r\n\t * @param {Element} layer The layer to listen on\r\n\t */\r\n\tFastClick.notNeeded = function(layer) {\r\n\t\tvar metaViewport;\r\n\t\tvar chromeVersion;\r\n\t\tvar blackberryVersion;\r\n\t\tvar firefoxVersion;\r\n\r\n\t\t// Devices that don't support touch don't need FastClick\r\n\t\tif (typeof window.ontouchstart === 'undefined') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Chrome version - zero for other browsers\r\n\t\tchromeVersion = +(/Chrome\\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];\r\n\r\n\t\tif (chromeVersion) {\r\n\r\n\t\t\tif (deviceIsAndroid) {\r\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\r\n\r\n\t\t\t\tif (metaViewport) {\r\n\t\t\t\t\t// Chrome on Android with user-scalable=\"no\" doesn't need FastClick (issue #89)\r\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Chrome 32 and above with width=device-width or less don't need FastClick\r\n\t\t\t\t\tif (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t// Chrome desktop doesn't need FastClick (issue #15)\r\n\t\t\t} else {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (deviceIsBlackBerry10) {\r\n\t\t\tblackberryVersion = navigator.userAgent.match(/Version\\/([0-9]*)\\.([0-9]*)/);\r\n\r\n\t\t\t// BlackBerry 10.3+ does not require Fastclick library.\r\n\t\t\t// https://github.com/ftlabs/fastclick/issues/251\r\n\t\t\tif (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {\r\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\r\n\r\n\t\t\t\tif (metaViewport) {\r\n\t\t\t\t\t// user-scalable=no eliminates click delay.\r\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// width=device-width (or less than device-width) eliminates click delay.\r\n\t\t\t\t\tif (document.documentElement.scrollWidth <= window.outerWidth) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)\r\n\t\tif (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Firefox version - zero for other browsers\r\n\t\tfirefoxVersion = +(/Firefox\\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];\r\n\r\n\t\tif (firefoxVersion >= 27) {\r\n\t\t\t// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896\r\n\r\n\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\r\n\t\t\tif (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version\r\n\t\t// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx\r\n\t\tif (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Factory method for creating a FastClick object\r\n\t *\r\n\t * @param {Element} layer The layer to listen on\r\n\t * @param {Object} [options={}] The options to override the defaults\r\n\t */\r\n\tFastClick.attach = function(layer, options) {\r\n\t\treturn new FastClick(layer, options);\r\n\t};\r\n\r\n\r\n\tif (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\r\n\r\n\t\t// AMD. Register as an anonymous module.\r\n\t\tdefine(function() {\r\n\t\t\treturn FastClick;\r\n\t\t});\r\n\t} else if (typeof module !== 'undefined' && module.exports) {\r\n\t\tmodule.exports = FastClick.attach;\r\n\t\tmodule.exports.FastClick = FastClick;\r\n\t} else {\r\n\t\twindow.FastClick = FastClick;\r\n\t}\r\n}());\r\n```"},{"shortInfo":{"title":"移动端布局及Flex布局模型","date":"2022-06-18T16:23:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["Flex","移动端","前端"],"hideAtIndex":true,"categories":"笔记","id":91,"countWords":3387,"readSeconds":338.7,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动端布局及Flex布局模型\r\n## 目录\r\n- [移动端布局及Flex布局模型](#移动端布局及flex布局模型)\r\n  - [目录](#目录)\r\n  - [pc端和移动端分辨率](#pc端和移动端分辨率)\r\n    - [pc端分辨率物理分辨率和逻辑分辨率](#pc端分辨率物理分辨率和逻辑分辨率)\r\n    - [手机端物理分辨率和逻辑分辨率](#手机端物理分辨率和逻辑分辨率)\r\n  - [视口](#视口)\r\n  - [二倍图](#二倍图)\r\n  - [百分比布局](#百分比布局)\r\n  - [flex布局](#flex布局)\r\n    - [flex布局的构成](#flex布局的构成)\r\n    - [主轴对齐方式](#主轴对齐方式)\r\n      - [主轴对齐方式测试](#主轴对齐方式测试)\r\n    - [侧轴对齐方式](#侧轴对齐方式)\r\n      - [侧轴对齐方式测试](#侧轴对齐方式测试)\r\n      - [控制单个盒子的侧轴对齐方式](#控制单个盒子的侧轴对齐方式)\r\n    - [flex伸缩比](#flex伸缩比)\r\n    - [修改主轴方向](#修改主轴方向)\r\n      - [修改主轴方向后修改主轴的对齐方式](#修改主轴方向后修改主轴的对齐方式)\r\n      - [使用示例](#使用示例)\r\n    - [弹性盒子的换行](#弹性盒子的换行)\r\n    - [弹性盒子的侧轴对齐方式](#弹性盒子的侧轴对齐方式)\r\n      - [效果测试](#效果测试)\r\n      - [问题](#问题)\r\n\r\n\r\n\r\n## pc端和移动端分辨率\r\n\r\n### pc端分辨率物理分辨率和逻辑分辨率\r\n* pc端常见分辨率-**物理分辨率**\r\n    * 1920x1080\r\n    * 1366x760\r\n* pc端设置按比例缩放后的分辨率-**逻辑分辨率**\r\n    * 缩放150%后的分辨率：(1920/150%)x(1080/150%)\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-00-53-45.png)\r\n\r\n* 写html时应该参考**逻辑**分辨率\r\n\r\n\r\n### 手机端物理分辨率和逻辑分辨率\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-01-46-41.png)\r\n\r\n## 视口\r\n* 一些概念\r\n    ```\r\n    1.什么是视口?\r\n        视口简单理解就是可视区域大小我们称之为视口\r\n        在PC端，视口大小就是浏览器窗口可视区域的大小\r\n        在移动端, 视口大小并不等于窗口大小, 移动端视口宽度被人为定义为了980\r\n\r\n    2.为什么是980而不是其他的值?\r\n        **因为过去网页的版心都是980**\r\n        乔老爷子为了能够让网页在移动端完美的展示, 所以将iOS手机视口的大小定义为了980\r\n        后来谷歌也觉得这是一个非常牛X的方案, 所以Android手机的视口也定义为了980\r\n\r\n    3.移动端自动将视口宽度设置为980带来的问题\r\n        虽然移动端自动将视口宽度设置为980之后让我们可以很完美的看到整个网页\r\n        但是由于移动端的物理尺寸(设备宽度)是远远小于视口宽度的\r\n        所以为了能够在较小的范围内看到视口中所有的内容, 那么就必须将内容缩小\r\n        (和前面讲解Canvas时讲解的viewbox一样, 近大远小原理)\r\n\r\n    4.如何保证在移动端不自动缩放网页的尺寸?\r\n        通过meta设置视口大小\r\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n        width=device-width 设置视口宽度等于设备的宽度\r\n        initial-scale=1.0 初始缩放比例, 1不缩放\r\n        maximum-scale：允许用户缩放到的最大比例\r\n        minimum-scale：允许用户缩放到的最小比例\r\n        user-scalable：用户是否可以手动缩放\r\n    ```\r\n* **移动端**网页视口默认的宽是**980px**\r\n* **PC端**网页视口默认的宽和**电脑逻辑分辨率的宽度**一致\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-01-51-53.png)\r\n\r\n* 使用`meta`标签设置**视口**，可以使**网页宽度**和设备的**逻辑宽度**一致\r\n    ```html\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    ```\r\n    ![](./images/移动端布局及Flex布局模型/2022-06-19-01-56-49.png)\r\n\r\n\r\n## 二倍图\r\n* 当前移动端网页一般参考iPhone6、7、8出设计稿，然后再想办法适配其他机型\r\n* 但由于分辨率的原因，设计稿将会按照物理分辨率设计，因为如果按照逻辑分辨率设计，一张低分辨率的图到了高分辨率的屏幕将会变得模糊不清，所以往往是设计稿用高分辨率的图，但用低分辨率的尺寸，这样经过移动端浏览器的放大，图片的尺寸被放大后依然是清晰的，又由于其物理分辨率和逻辑分辨率**往往是**二倍的关系，所以这样的设计稿的图称为**二倍图**\r\n* 所以结论就是当设计稿中页面宽度为750px时,其实际尺寸应该写375px\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-01-46-41.png)\r\n* 需要注意的是，pc端的设计图也存在二倍图，如果设计图标识网页宽度为3840px，则其实际宽度很可能是1920px\r\n\r\n\r\n## 百分比布局\r\n* 过去普遍使用的一种布局\r\n* 百分比布局也叫流式布局\r\n* 具体就是盒子的宽度取百分比，高度取固定值\r\n* 效果：宽度自适应，高度固定\r\n\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-02-58-50.png)\r\n\r\n\r\n## flex布局\r\n* flex布局也叫弹性布局\r\n* 是一种**浏览器提倡**的**布局模型**\r\n* 非常适合结构化的布局模型\r\n* 布局网页更简单、灵活\r\n* 能够避免浮动脱标的问题\r\n* flex是专门用来布局的模型\r\n* 而浮动一开始只是为了文字环绕效果而开发的，并不是专门用来做布局的\r\n* 对于ie浏览器不兼容\r\n* 查看是否兼容[caniuse.com](https://caniuse.com)\r\n\r\n\r\n### flex布局的构成\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-03-39-43.png)\r\n* 设置方式：父元素添加`display:flex`\r\n* 作用：设置后子元素可以自动的挤压或拉伸\r\n* 各组成部分的名称\r\n    * **弹性容器** ：显示模式为flex的父元素\r\n    * **弹性盒子** ：子元素\r\n    * **主轴** ： **默认** 在水平方向\r\n    * **侧轴/交叉轴** ： **默认** 在垂直方向\r\n\r\n### 主轴对齐方式\r\n* 在flex布局模型中，调节主轴或侧轴的对齐方式可以设置盒子之间的间距\r\n* 属性名：`justify-content`\r\n* 属性值：![](./images/移动端布局及Flex布局模型/2022-06-19-03-57-53.png)\r\n* **当主轴方向为默认方向时，`justify-content`控制水平方向对齐方式**\r\n\r\n#### 主轴对齐方式测试\r\n* 主轴对齐方式justify-content:flex-start 左对齐\r\n<div id=\"textFlex1\">\r\n    <div>flex-start</div>\r\n    <div>flex-start</div>\r\n    <div>flex-start</div>\r\n    <div>flex-start</div>\r\n</div>\r\n<style>\r\n    #textFlex1{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content: flex-start;\r\n    }\r\n    #textFlex1 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 主轴对齐方式justify-content:flex-end 右对齐\r\n<div id=\"textFlex2\">\r\n    <div>flex-end</div>\r\n    <div>flex-end</div>\r\n    <div>flex-end</div>\r\n    <div>flex-end</div>\r\n</div>\r\n<style>\r\n    #textFlex2{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:flex-end;\r\n    }\r\n    #textFlex2 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n* 主轴对齐方式justify-content:flex-center 弹性盒子居中 两边留白\r\n<div id=\"textFlex3\">\r\n    <div>center</div>\r\n    <div>center</div>\r\n    <div>center</div>\r\n    <div>center</div>\r\n</div>\r\n<style>\r\n    #textFlex3{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:center;\r\n    }\r\n    #textFlex3 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 主轴对齐方式justify-content:flex-around 弹性盒子的周围留白\r\n<div id=\"textFlex4\">\r\n    <div>space-around</div>\r\n    <div>space-around</div>\r\n    <div>space-around</div>\r\n    <div>space-around</div>\r\n</div>\r\n<style>\r\n    #textFlex4{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-around;\r\n    }\r\n    #textFlex4 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 主轴对齐方式justify-content:flex-between 弹性盒子的之间留白\r\n<div id=\"textFlex5\">\r\n    <div>space-between</div>\r\n    <div>space-between</div>\r\n    <div>space-between</div>\r\n    <div>space-between</div>\r\n</div>\r\n<style>\r\n    #textFlex5{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-between;\r\n    }\r\n    #textFlex5 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 主轴对齐方式justify-content:flex-evenly 弹性盒子的之间和两边留相同宽度的白\r\n<div id=\"textFlex6\">\r\n    <div>space-evenly</div>\r\n    <div>space-evenly</div>\r\n    <div>space-evenly</div>\r\n    <div>space-evenly</div>\r\n</div>\r\n<style>\r\n    #textFlex6{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n    }\r\n    #textFlex6 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n### 侧轴对齐方式\r\n* 属性名align-items **添加给弹性容器**，控制**所有**盒子的侧轴对齐方式\r\n* 属性名align-self **添加给弹性盒子**,控制**单个**盒子的侧轴对齐方式\r\n![](./images/移动端布局及Flex布局模型/2022-06-19-04-31-31.png)\r\n* **当主轴方向为默认方向时，`align-self`控制垂直方向对齐方式**\r\n\r\n#### 侧轴对齐方式测试\r\n* 侧轴对齐方式`align-items:flex-start` 弹性盒子的顶对齐\r\n<div id=\"textFlex7\">\r\n    <div>space-start</div>\r\n    <div>space-start</div>\r\n    <div>space-start</div>\r\n    <div>space-start</div>\r\n</div>\r\n<style>\r\n    #textFlex7{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items: flex-start;\r\n        height: 150px;\r\n    }\r\n    #textFlex7 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n* 侧轴对齐方式 `align-items:flex-end` 弹性盒子的底对齐\r\n<div id=\"textFlex8\">\r\n    <div>space-end</div>\r\n    <div>space-end</div>\r\n    <div>space-end</div>\r\n    <div>space-end</div>\r\n</div>\r\n<style>\r\n    #textFlex8{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items: flex-end;\r\n        height: 150px;\r\n    }\r\n    #textFlex8 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 侧轴对齐方式`align-items:center` 弹性盒子垂直居中对齐\r\n<div id=\"textFlex9\">\r\n    <div>space-center</div>\r\n    <div>space-center</div>\r\n    <div>space-center</div>\r\n    <div>space-center</div>\r\n</div>\r\n<style>\r\n    #textFlex9{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items:center;\r\n        height: 150px;\r\n    }\r\n    #textFlex9 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n* 侧轴对齐方式`align-items:stretch` 弹性盒子**没有高度时**，将被拉长至铺满高度\r\n<div id=\"textFlex10\">\r\n    <div>space-stretch</div>\r\n    <div>space-stretch</div>\r\n    <div>space-stretch</div>\r\n    <div>space-stretch</div>\r\n</div>\r\n<style>\r\n    #textFlex10{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items:stretch;\r\n        height: 150px;\r\n    }\r\n    #textFlex10 div{\r\n        width: 100px;\r\n        /* height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n#### 控制单个盒子的侧轴对齐方式\r\n<div id=\"textFlex11\">\r\n    <div>space-center</div>\r\n    <div style=\"align-self:flex-end;\">flex-end</div>\r\n    <div>space-center</div>\r\n    <div>space-center</div>\r\n</div>\r\n<style>\r\n    #textFlex11{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items:center;\r\n        height: 150px;\r\n    }\r\n    #textFlex11 div{\r\n        width: 100px;\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n\r\n### flex伸缩比\r\n* 语法格式: `flex:数值;`\r\n* 表示占用父盒子的剩余尺寸的份数\r\n<div id=\"textFlex12\">\r\n    <div>宽50px</div>\r\n    <div>不指定宽，靠内容撑开</div>\r\n    <div>flex: 2;剩余部分的2份</div>\r\n    <div>flex: 4;剩余部分的4份</div>\r\n</div>\r\n<style>\r\n    #textFlex12{\r\n        display: flex;\r\n        background-color:gray;\r\n        justify-content:space-evenly;\r\n        align-items:center;\r\n        height: 150px;\r\n    }\r\n    #textFlex12 div{\r\n        height: 100px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n    #textFlex12 div:nth-child(1){\r\n        width: 80px;\r\n    }\r\n    #textFlex12 div:nth-child(2){\r\n        /* 不指定宽 */\r\n    }\r\n    #textFlex12 div:nth-child(3){\r\n        flex: 2;\r\n    }\r\n    #textFlex12 div:nth-child(4){\r\n        flex: 4;\r\n    }\r\n</style>\r\n\r\n### 修改主轴方向\r\n* 作用：修改主轴方向，实现子元素垂直排列\r\n* 属性名：`flex-direction`\r\n* 属性值：\r\n    ![](./images/移动端布局及Flex布局模型/2022-06-20-06-54-01.png)\r\n* 主轴修改为垂直方向后，水平方向的轴就是侧轴\r\n\r\n#### 修改主轴方向后修改主轴的对齐方式\r\n* 主轴修改为垂直方向后，想要控制主轴（垂直方向）的对齐方式依然使用`justify-content`属性\r\n* 主轴修改为垂直方向后，想要控制侧轴（水平方向）的对齐方式依然使用`align-items`属性\r\n\r\n#### 使用示例\r\n<div id=\"textFlex13\">\r\n    <div>justify-content:flex-start</div>\r\n    <div>justify-content:flex-start</div>\r\n    <div>justify-content:flex-start</div>\r\n</div>\r\n<style>\r\n    #textFlex13{\r\n        display: flex;\r\n        flex-direction: column;\r\n        height: 300px;\r\n        background-color:gray;\r\n        justify-content: flex-start;\r\n    }\r\n    #textFlex13 div{\r\n        /* width: 300px; */\r\n        height: 50px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n<br>\r\n<div id=\"textFlex14\">\r\n    <div>justify-content:space-around; align-items:center;</div>\r\n    <div>justify-content:space-around; align-items:center;</div>\r\n    <div>justify-content:space-around; align-items:center;</div>\r\n</div>\r\n<style>\r\n    #textFlex14{\r\n        display: flex;\r\n        flex-direction: column;\r\n        height: 300px;\r\n        background-color:gray;\r\n        justify-content:space-around;\r\n        align-items:center;\r\n    }\r\n    #textFlex14 div{\r\n        /* width: 300px; */\r\n        height: 50px;\r\n        /* line-height: 100px; */\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n### 弹性盒子的换行\r\n* 默认情况下，当**弹性容器**的一行之内不能容纳下所有**弹性盒子**时，弹性盒子的**宽**会**缩小**\r\n* 使用`flex-wrap`属性可以实现弹性盒子的换行排列效果\r\n* 取值：\r\n    * `no-wrap` 默认值\r\n        * 弹性盒子会受到挤压，设定的宽度会失效\r\n        * ![](./images/移动端布局及Flex布局模型/2022-06-20-08-10-02.png)\r\n    * `wrap` 换行 \r\n        * 弹性盒子的尺寸不会受到挤压，会在弹性容器容纳不下时换行\r\n        * ![](./images/移动端布局及Flex布局模型/2022-06-20-08-09-01.png)\r\n            * 水平方向末尾留下了多余空间因为justify-content（主轴方向对齐方式）默认值是justify-content:flex-start）\r\n            * 垂直方向行间留下了多余空间 这是因为align-content(侧轴方向对齐方式)默认值的影响）\r\n\r\n\r\n### 弹性盒子的侧轴对齐方式\r\n* 属性名`align-content`\r\n* 属性值：和主轴对齐方式`justify-content`的取值几乎一致（没有`space-evenly`）\r\n* 默认情况下，弹性盒子是不换行的，所以设置侧轴对齐方式会看不到效果，要先设置`flex-wrap:wrap;`属性后才能看到效果\r\n\r\n#### 效果测试\r\n<div id=\"textFlex15\">\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n    <div>123</div>\r\n</div>\r\n<style>\r\n    #textFlex15{\r\n        display: flex;\r\n        flex-wrap:wrap;\r\n        justify-content:center;\r\n        align-content:center;\r\n        /* justify-items: center; */\r\n        /* align-items: center; */\r\n        /* height: 300px; */\r\n        /* width: 300px; */\r\n        background-color:gray;\r\n        align-items:center;\r\n    }\r\n    #textFlex15 div{\r\n        width: 50px;\r\n        height: 50px;\r\n        margin:5px;\r\n        background-color:green;\r\n        border: 1px solid white;\r\n    }\r\n</style>\r\n\r\n#### 问题\r\n* 如何处理最后一行不能左对齐的问题？\r\n![](./images/移动端布局及Flex布局模型/2022-06-20-08-58-31.png)\r\n\r\n\r\n"},{"shortInfo":{"title":"移动适配","date":"2022-06-20T22:35:00.000Z","cover":"\\self_server\\assets\\images\\default_cover2.jpg","tags":["移动适配","CSS","前端"],"hideAtIndex":true,"categories":"笔记","id":92,"countWords":908,"readSeconds":90.8,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动适配\r\n\r\n## 目录\r\n- [移动适配](#移动适配)\r\n  - [目录](#目录)\r\n  - [概述](#概述)\r\n  - [rem](#rem)\r\n    - [媒体查询](#媒体查询)\r\n    - [根标签字号的取值](#根标签字号的取值)\r\n    - [元素宽高取值的确定](#元素宽高取值的确定)\r\n    - [使用步骤](#使用步骤)\r\n    - [flexiblejs适配所有移动端视口宽度的解决方案](#flexiblejs适配所有移动端视口宽度的解决方案)\r\n  - [vwvh](#vwvh)\r\n    - [计算示例](#计算示例)\r\n    - [元素宽高取值的确定](#元素宽高取值的确定-1)\r\n\r\n\r\n## 概述\r\n传统的像素单位和百分比布局都存在一定的问题，像素单位会把元素的尺寸写死，在pc端多少像素，移动端也是多少像素，百分比布局虽然可以根据设备屏幕的宽度实现宽度的自适应，但是其高度仍然必须指定一个像素，不能做到同时自适应改变宽和高以适配不同机型的屏幕  \r\n\r\n**移动适配就是让网页根据不同机型的屏幕宽度，自适应的改变网页中元素的宽高、边距、字号大小**\r\n\r\n![](./images/移动适配/2022-06-21-06-42-08.png)\r\n\r\n* 两种解决方案\r\n    * `rem`:目前多数企业(小米)在使用的解决方法\r\n    * `vw/vh`:未来的解决方案,大厂(bilibili、天猫)已经开始使用\r\n\r\n## rem\r\n* rem是一个相对单位\r\n* rem是相对于根标签(HTML标签)的字号计算的\r\n* 1rem=1HTML字号大小\r\n\r\n\r\n\r\n### 媒体查询\r\n* 媒体查询能够检测视口的宽度，然后编写差异化的css样式\r\n* 写法\r\n    ```css\r\n    @media (媒体特征){\r\n        选择器{\r\n            css属性;\r\n        }\r\n    }\r\n    ```\r\n\r\n### 根标签字号的取值\r\n实现移动适配的关键在于如何给根标签的字号取一个合适的值,要实现这一点需要用到的技术就是**媒体查询**\r\n目前rem布局方案中，根标签的字号一般取视口宽度的$\\frac{1}{10}$\r\n* 示例\r\n    ```css\r\n    @media (width:414px){\r\n        html{\r\n            font-size:41.4px;\r\n        }\r\n    }\r\n    @media (width:375px){\r\n        html{\r\n            font-size:37.5px;\r\n        }\r\n    }\r\n    ```\r\n\r\n### 元素宽高取值的确定\r\n假设设计稿是根据iPhone6/7/8的视口宽度365px设计的，第一步应该是计算并设置根标签的字号大小`html{font-size:36.5px;}`,然后假设测量某元素的宽高是63px，42px，那么其宽就应该是$\\frac{63}{36.5}=1.726rem$;高就应该是$\\frac{42}{36.5}=1.150rem$;\r\n\r\n* 宽高的自动计算可以使用less插件\r\n\r\n### 使用步骤\r\n* 先给html标签设置字号\r\n    ```css\r\n    @media (width:375px){\r\n        html{\r\n            font-size:37.5px;\r\n        }\r\n    }\r\n    @media (width:414px){\r\n        html{\r\n            font-size:41.4px;\r\n        }\r\n    }\r\n    @media (width:375px){\r\n        html{\r\n            font-size:37.5px;\r\n        }\r\n    }\r\n    ```\r\n* 盒子宽高使用为rem单位\r\n    ```css\r\n    .box{\r\n        width:5rem;\r\n        height:5rem;\r\n        background-color:green;\r\n    }\r\n    ```\r\n\r\n### flexiblejs适配所有移动端视口宽度的解决方案\r\n* **flexible.js**是手机淘宝开发出的解决方案\r\n* 原理就是根据不同的视口宽度自动修改根标签字号大小\r\n* 一般把这个js放在body的结束标签位置之前\r\n\r\n\r\n\r\n## vwvh\r\n* vw/vh是一个相对单位\r\n* 相对视口的尺寸计算\r\n* **vw(viewport width)** **1vw=$\\frac{1}{100}$视口宽度**\r\n* **vh(viewport height)** **1vh=$\\frac{1}{100}$视口高度**\r\n* 一般对一个盒子，指定其宽高时，不同时使用vm vh单位，否则根据竖屏设计的网页，到了宽屏就会比例失调\r\n  \r\n### 计算示例\r\n### 元素宽高取值的确定\r\n假设设计稿是根据iPhone6/7/8的视口宽度365px设计的，假设测量某元素的宽高是63px，42px，那么其宽就应该是`63/3.65vw` 高就应该是`42/3.65vw`"},{"shortInfo":{"layout":"post","cover":"\\self_server\\assets\\images\\default_cover2.jpg","title":"移动适配项目实战","date":"2022-06-21T15:57:00.000Z","tags":["网站","demo"],"hideAtIndex":true,"categories":"前端","id":93,"countWords":66,"readSeconds":6.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 移动适配项目实战\r\n\r\n## Demos\r\n* [-->rem单位的使用(移动端游乐园网页实例)<--](./demos/移动适配项目实战/youleyuan/)\r\n* [-->vw单位的使用(移动端bilibili网页仿照实现)<--](./demos/移动适配项目实战/m-bilibili/)\r\n\r\n\r\n<br>\r\n<br>\r\n<br>\r\n<br>"},{"shortInfo":{"layout":"post","title":"记录本网站的搭建过程(旧版)","subtitle":"第一篇技术博客","date":"2021-12-27T13:45:00.000Z","cover":"\\self_server\\assets\\images\\timePencil.jpg","tags":["技术博客","网站搭建"],"hideAtIndex":true,"categories":"笔记","id":94,"countWords":446,"readSeconds":44.6,"assetsbaseUrl":"/self_server/assets/"},"content":"# 本网站搭建\r\n### 一、创建github仓库\r\n1. 仓库名前缀要和GitHub用户名同名，不区分大小写。\r\n    >用户名如为:YiguiDing,仓库名则为：YiguiDing.github.io\r\n2. 该仓库需为公开仓库。\r\n\r\n### 二、本地仓库的初始化和提交到远程仓库\r\n0. 下载安装git。`略`\r\n   + git配置过程省略\r\n1. 使用git命令初始化本地仓库`git init`\r\n2. 或使用克隆命令直接克隆本网站`git clone https://github.com/YiguiDing/YiguiDing.github.io.git`\r\n3. 为远程仓库添加别名 `git remote add origin https://github.com/你的用户名/你的仓库名.git`\r\n4. 将本地仓库提交到你的GitHub `git push origin master`\r\n\r\n### 三、本地测试环境的搭建与测试\r\n* 在win10中安装`Ubuntu20.04 LTS`子系统\r\n    + 若干步骤省略\r\n* 安装ruby2.7和ruby2.7-dev\r\n    + `apt search ruby2.7`\r\n    + `apt install ruby2.7 ruby2.7-dev`\r\n    + 这里用2.7是为了和github保持一致,详情查看[GitHub PagesDependency versions](https://pages.github.com/versions/)\r\n* 用ruby的gem安装bundler\r\n\t+ `gem install bundler`\r\n* 创建Gemfile文件安装jekyll3.9\r\n    + \r\n        ```shell\r\n        cat >Gemfile<<\"EOF\"\r\n        source \"https://rubygems.org\"\r\n        gem \"jekyll\", \"~> 3.9.0\"\r\n        EOF\r\n        ```\r\n    + `apt install make gcc` //没有这一步下一步会报错\r\n    + `bundler install`\r\n* 安装网站所需运行环境 即/YiguiDing.github.io/Gemfile中所描述依赖\r\n    + `cd YiguiDing.github.io`\r\n    + `apt install g++`     //下一步的编译安装过程中需要用到g++\r\n    + `bundler install`\r\n* 本机访问\r\n  * `bundle exec jekyll serve -w --host=127.0.0.1 --livereload --port=80`\r\n  * 其中\r\n    * `--livereload`表示动态加载页面，即当页面文件改动后，静态页面将会重新生成\r\n    * `--host=127.0.0.1`表示指定ip地址，此时为仅本机访问，若要局域网内部访问，则指定为`--host=0.0.0.0`或`--host=本机局域网Ip`\r\n    * `--port=80`表示指定端口，默认为4000"},{"shortInfo":{"title":"记录用Vue3写的新博客站点","date":"2022-10-17T17:24:00.000Z","cover":"\\self_server\\assets\\images\\IMG_5251.PNG","tags":["vue3","blog","demo"],"categories":"笔记","id":3132888776,"countWords":48,"readSeconds":4.8,"assetsbaseUrl":"/self_server/assets/"},"content":"## 实现效果记录\r\n\r\n![](./images/IMG_5250.PNG)\r\n![](./images/IMG_5251.PNG)\r\n\r\n\r\n![](./images/IMG_5242.PNG)\r\n![](./images/IMG_5243.PNG)\r\n![](./images/IMG_5244.PNG)\r\n![](./images/IMG_5245.PNG)\r\n![](./images/IMG_5246.PNG)\r\n![](./images/IMG_5247.PNG)\r\n![](./images/IMG_5248.PNG)\r\n![](./images/IMG_5249.PNG)\r\n\r\n![](./images/IMG_5252.PNG)\r\n![](./images/IMG_5253.PNG)\r\n![](./images/IMG_5254.PNG)\r\n![](./images/IMG_5255.PNG)"}]