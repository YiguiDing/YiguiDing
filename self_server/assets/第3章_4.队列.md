---
title: 《数据结构与算法分析》第3章_4.队列
cover: /images/《数据结构与算法分析》学习笔记/cover.png
coverWidth: 813
coverHeight: 539
date: '2022-05-26 17:48:30 +08:00'
modified: '2022-05-27T09:16:54.972Z'
tags: [《数据结构与算法分析》,笔记]
hideAtIndex: true
categories: 笔记
id: 61
---


# 第3章_4.队列
* 队列（queue）也是表
* 队列的插入操作在一端进行，删除操作在另一端进行
* 队列的基本操作
  + Enqueue()入列，在表末尾（队尾rear）插入一个元素
  + Dequeue()出列，删除或返回表头（对头front）元素
* 队列抽象模型
![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-01-53-23.png)

## 队列的数组实现
* 队列结构体
  + 数组Queue[]
  + 队列头 Front
  + 队列尾 Rear
  + 队列实际元素个数 Size
* 入列操作：Size+=1,Rear+=1,Queue[Rear]=X;
* 出列操作：Size-=1;return Queue[Front++];
* 警惕：
  + 出列操作时检测队列是否为空很重要
  + 如果队列的大小是计算得出的，需要考虑一些特殊情况，修改代码时也需要更仔细
* 潜在问题：队列满了之后怎么办？
  + 解决方法：循环数组（circular array）实现,Front或Rear达到数组尾部时，使其绕回到开头位置。
![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-27-02-43-40.png)

### 具体实现
```c
//Queue.h
#ifndef Queue_H
#define Queue_H

#define ElementType int

struct QueueRecord;
typedef struct QueueRecord* Queue;

int IsEmpty(Queue Q);
int IsFull(Queue Q);
Queue CreatQueue(int MaxElements);
void DisposeQueue(Queue Q);
void MakeEmpty(Queue Q);
void Enqueue(ElementType X,Queue Q);
void Dequeue(Queue Q);
ElementType GetFront(Queue Q);
ElementType GetFrontAndDequeue(Queue Q);
#endif
```

```c
//Queue.c
#include"Queue.h"
#include<stdlib.h>
#define MinQueueSize (10)

struct QueueRecord
{
    int Capacity;
    int Front;
    int Rear;
    int Size;
    ElementType *Array;
};

int IsEmpty(Queue Q)
{
    return Q->Size <= 0;
}
int IsFull(Queue Q)
{
    return Q->Size >= Q->Capacity;
}
Queue CreatQueue(int MaxElements)
{
    if (MaxElements<MinQueueSize)
    {
        Error("Queue size is too small");
    }
    
    Queue Q=malloc(sizeof(struct QueueRecord));
    if (Q==NULL)
    {
        Error("out of memory");
        return;
    }
    Q->Array = malloc(sizeof(ElementType)*MaxElements);
    if (Q->Array==NULL)
    {
        Error("out of memory");
        return;
    }
    MakeEmpty(Q);
    return Q;
}
void DisposeQueue(Queue Q)
{
    if (Q!=NULL)
    {   
        if (Q->Array!=NULL)
            free(Q->Array);
        free(Q);
    }
}
void MakeEmpty(Queue Q)
{
    Q->Size=0;
    Q->Front=1;//Rear被初始化为0，意味着入列一个元素后，第一个元素的位置是1
    Q->Rear=0;
}

void Enqueue(ElementType X,Queue Q)
{
    if (!IsFull(Q))
    {
        Q->Rear = getNextPosition(Q->Rear,Q);
        Q->Array[Q->Rear]=X;
        Q->Size++;
    }
    Error("Queue is full");
}
void Dequeue(Queue Q)
{
    if (!isEmpty(Q))
    {
        Q->Front = getNextPosition(Q->Front,Q);
        Q->Size--;
        return;
    }
    Error("Queue is Empty");
}
ElementType GetFront(Queue Q)
{
    if (!isEmpty(Q))
    {
        return Q->Array[Q->Front];
    }
    Error("Queue is Empty");
}
ElementType GetFrontAndDequeue(Queue Q)
{
    if (!isEmpty(Q))
    {
        ElementType temp = Q->Array[Q->Front];
        Q->Front = getNextPosition(Q->Front,Q);
        Q->Size--;
        return temp;
    }
    Error("Queue is Empty");
}
static Error(char *str)
{
    printf("%s\n",str);
}
static int getNextPosition(int Position,Queue Q)
{
    if(++Position >= Q->Capacity)
        Position=0;
    return Position;
}

```
## 队列的链表实现
```c
//Queue.h
#ifndef Queue_H
#define Queue_H

#define ElementType int

struct QueueRecord;
typedef struct QueueRecord* Queue;

int IsEmpty(Queue Q);
int IsFull(Queue Q);
Queue CreatQueue();
void DisposeQueue(Queue Q);
void MakeEmpty(Queue Q);
void Enqueue(ElementType X,Queue Q);
void Dequeue(Queue Q);
ElementType GetFront(Queue Q);
ElementType GetFrontAndDequeue(Queue Q);
#endif

```

```c
//Queue.c

#include"Queue.h"
#include<stdio.h>

typedef struct 
{
    ElementType Element;
    Node *Next;
    Node *Ahead;
}Node;

struct QueueRecord
{
    int Size;
    Node *Front;
    Node *Ended;
};

int IsEmpty(Queue Q)
{
    return Q->Size<=0;
}
Queue CreatQueue()
{
    Queue Q=malloc(sizeof(struct QueueRecord));
    if (Q!=NULL)
    {
        Q->Front=0;
        Q->Ended=0;
        return Q;    
    }
    Error("out of memory");
    return 0;
}
void DisposeQueue(Queue Q)
{
    Node *temp=Q->Front;
    while (temp!=NULL)
    {
        temp=temp->Next;
        free(temp->Ahead);
    }
    free(Q);
}
void MakeEmpty(Queue Q)
{
    Node *temp=Q->Front;
    while (temp!=NULL)
    {
        temp=temp->Next;
        free(temp->Ahead);
    }
    Q->Size=0;
    Q->Ended=NULL;
    Q->Front=NULL;
}
void Enqueue(ElementType X,Queue Q)
{
    Node *temp=malloc(sizeof(Node));
    if (temp==NULL)
    {
        Error("out of memory");
        return;
    }
    temp->Element=X;
    
    if (Q->Front==NULL)
    {
        Q->Front=temp;
    }
    if (Q->Ended==NULL)
    {
        Q->Ended=temp;
    }
    
    temp->Ahead=Q->Ended;
    temp->Next=NULL;
    
    Q->Ended=temp;

    Q->Size++;
}
void Dequeue(Queue Q)
{
    if (!IsEmpty(Q))
    {
        Node *temp = Q->Front->Next;
        free(Q->Front);
        Q->Front=temp;
        Q->Size--;
    }
    Error("Queue is Empty");
}
ElementType GetFront(Queue Q)
{
    if (!IsEmpty(Q))
    {
        return Q->Front->Element;
    }
    Error("Queue is Empty");
}
ElementType GetFrontAndDequeue(Queue Q)
{
    if (!IsEmpty(Q))
    {
        ElementType Element=Q->Front->Element;
        Node *temp = Q->Front->Next;

        free(Q->Front);
        Q->Front=temp;
        Q->Size--;

        return Element;
    }
    Error("Queue is Empty");
}

```

## 队列的应用
* 打印机的任务
* 网络文件服务器的访问顺序，先请求先访问
* 传呼系统
