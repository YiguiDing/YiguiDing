---
title: 《数据结构与算法分析》第4章_1.树的概念
cover: /images/《数据结构与算法分析》学习笔记/cover.png
coverWidth: 813
coverHeight: 539
date: '2022-05-27 09:24:41 +08:00'
modified: '2022-05-28T20:35:41.330Z'
tags: [《数据结构与算法分析》,笔记]
hideAtIndex: true
categories: 笔记
id: 63
---


# 第4章_1.树的概念
* 对于大量输入数据，线性链表访问时间太慢不宜使用。
* 树的大部分操作运行时间平均为O(log N)

## 一些相关概念
* **定义**
  + 定义树的方式有多种
  + 定义树的一种方式是递归的方式（类似于定义一个基准情况，然后自己定义自己）
* **组成**
  + 一棵树是一些**节点**的集合，该集合可以是空集。
  + 一棵树由**根(root)节点**和0个子树或多个非空的**子树**组成
  + 子树的根被一条来自根节点的有向的**边edge**所连接。(根节点指向子节点的边)
  + 一棵树是N个节点和N-1条边的集合，其中一个节点叫做根
  + **一个节点可有0个或多个子节点**
* **称呼**
  + 根节点是其下属的子树根节点的**父亲(parent)**
  + 子树的根节点是父节点的**儿子(child)**
  + 没有子节点的节点称为**树叶(leaf)**
  + 有相同父节点的节点称为**兄弟(sibling)**
  + 祖父grandparent、孙子grandchild关系以此类推
+ **路径** 
  + 子节点到父节点之间的路径长度为其边数，也就是1
  + 如果前一个节点是后一个节点的父节点，N1到Nk的路径长度为K-1,也就是该路径上的边数
  + 一个节点从自己到自己的路径长度为0,可以理解为经过了0条边
+ **深度**
  + **某节点**的深度为根节点到该节点唯一路径的长
  + **根节点**的深度为0
  + **一棵树**的深度等于这棵树最深的树叶的深度，同时也等于这棵树的高
+ **高度**
  + **某节点**的高度为从该节点到最深叶节点的路径的长
  + **叶节点**的高度为0
  + **一棵树**的高度等于其根节点的高，也等于其最深叶节点的深度
+ **一个树的深度等于它的最深的树叶的深度;该深度总是等于这棵树的高。**
+ **祖先、真祖先**
  + N1节点到N2节点存在一条路径，那么N1是N2的一位**祖先**ancestor，N2是N1的一个**后裔**descentdant
  + N1节点到N2节点存在一条路径，**且N1!=N2**，那么N1是N2的一位**真祖先**proper ancestor，N2是N1的一个**真后裔**proper descentdant

## 树的实现
* **理想的实现方式：** 根节点拥有多个指针域分别指向其多个子节点
  + **缺点：** 子节点个数是未知的，无法提前预知需要多少个指针域
* **实际的实现方式：** 每个节点只有两个指针域，一个指向其子节点，另一个指向其兄弟节点
```c
typedef struct TreeNode* PtrToNode;
struct TreeNode
{
  ElementType Element;//数据域
  PtrToNode FirstChild;//指向其第一个子节点
  PtrToNode NextSibling;//指向其兄弟节点
};
```
* **各节点的逻辑关系**
![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-01-24-54.png)
* **各节点中指针的实际指向**
![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-01-24-38.png)

## 树的应用及其遍历
* **unix文件系统**
  + unix文件系统的目录中有一个指针指向本身，还有一个指针指向父目录，所以严格来说unix文件系统是类树(treeLike)结构.
* 根据深度打印tab个数，文件名，换行符号
* 一种遍历策略称为**先序遍历（preorder traversal）**。在先序遍历中，对当前所在节点的处理工作是在其子节点之前进行(pre)的
* 另一种遍历策略称之为**后序遍历（postorder traversal）**。也就是先处理当前节点的子节点，再来处理当前节点。
  + 应用：计算文件夹内文件的大小
![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-02-30-27.png)

### 先序遍历
* 代码
```c
void ListDirectory(DirectoryFile D)
{
  ListDir(D,0);
}

static void ListDir(DirectoryFile D,int Depth)
{
  if(D是一条合法记录)//D是文件夹或文件
  {
    Print(D,Depth);//根据深度打印tab个数，文件名，换行符
    if(D是一个文件夹)
      for(C=getFirstChild(D);C!=NULL;C=getNextChild(D))//遍历
        ListDir(C,Depth+1);
  }
}

```
* 遍历结果
![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-02-42-17.png)

### 后序遍历
* 代码实现
```c
int SizeDirectory(DirectoryOrFile D)
{
  int totle=0;
  if(D是文件或文件夹)
  {
    if(D是文件)
    {
      totle=FileSize(D);
    }
    for(C=getFirstChild(D);C!=NULL;C=getNextChild(D))
    {
      totle+=SizeDirectory(D);
    }
    Print(D,totle);
  }
  return totle;
}

```
* 输出结果
![](./images/《数据结构与算法分析》学习笔记/Clipboard_2022-05-28-03-14-24.png)

















