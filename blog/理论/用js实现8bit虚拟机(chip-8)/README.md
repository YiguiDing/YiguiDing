---
title: 用js实现8bit虚拟机(chip-8)
date: 2025-01-23T00:58:00
article: true 
index: true
---


# 用js实现8bit虚拟机(chip-8)


## cpu实现

@[code js](./projecs/01.demo/src/chip-8/cpu.js)

## render实现

@[code js](./projecs/01.demo/src/chip-8/render.js)

## speaker实现

@[code js](./projecs/01.demo/src/chip-8/speaker.js)

## keyboard实现

@[code js](./projecs/01.demo/src/chip-8/keyboard.js)

## main.js

@[code js](./projecs/01.demo/src/main.js)

## mindex.html

@[code html](./projecs/01.demo/index.html)


## 参考文档

> - [Cowgod's Chip-8 Technical Reference v1.0](http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#2.4)
> - [creating-your-very-own-chip-8-emulator](https://www.freecodecamp.org/news/creating-your-very-own-chip-8-emulator/)
> - [github.com/ericgrandt/chip8-emulator](https://github.com/ericgrandt/chip8-emulator)


## 关于 chip-8

“Chip-8 是一种简单的解释型编程语言，最早在 20 世纪 70 年代末和 80 年代初用于一些 DIY 计算机系统。COSMAC VIP、DREAM 6800 和 ETI 660 计算机就是其中几个例子。这些计算机通常设计为使用电视作为显示器，具有 1 到 4K 的 RAM，并使用 16 键十六进制键盘进行输入。该解释器仅占用 512 字节内存，而以十六进制输入计算机的程序甚至更小。

20 世纪 90 年代初，一个名叫 Andreas Gustafsson 的人使 Chip-8 语言再次流行。他为 HP48 图形计算器创建了一个 Chip-8 解释器，称为 Chip-48。当时，HP48 缺乏一种轻松制作快速游戏的方法，而 Chip-8 就是答案。Chip-48 后来催生了 Super Chip-48，这是 Chip-48 的改进版，允许更高分辨率的图形以及其他图形增强功能。

Chip-48 启发了一系列适用于各种平台的全新 Chip-8 解释器，包括 MS-DOS、Windows 3.1、Amiga、HP48、MSX、Adam 和 ColecoVision。”


## 内存 Memory

- Chip-8 语言能够访问最多 4KB（4,096 字节）的 RAM，从位置 0x000（0）到 0xFFF（4095）。
- 前 512 个字节（从 0x000 到 0x1FF）是原始解释器所在的位置，不应由程序使用。
- 大多数 Chip-8 程序从位置 0x200（512）开始，但有些从 0x600（1536）开始。
- 从 0x600 开始的程序适用于 ETI 660 计算机。

```bash
+---------------+= 0xFFF (4095) 内存结束地址
|               |
|               |
|               |
|               |
|               |
| 0x200 to 0xFFF|
|     Chip-8    |
| Program / Data|
|     Space     |
|               |
|               |
|               |
+- - - - - - - -+= 0x600 (1536) ETI 660 Chip-8 程序的开始位置
|               |
|               |
|               |
+---------------+= 0x200 (512) 大多数 Chip-8 程序的开始位置
| 0x000 to 0x1FF|
| Reserved for  |
|  interpreter  |
+---------------+= 0x000 (0) 内存开始地址
```

## 寄存器 Registers


**Vx 通用寄存器**

-  16 个通用 8 位寄存器，通常称为 Vx，其中 x 是十六进制数字（0 到 F）。

**I 存储内存地址寄存器**  

- 一个 16 位寄存器，称为 I。
- 此寄存器通常用于存储内存地址，因此通常只使用最低（最右边）的 12 位。

**VF 寄存器**

- VF 寄存器不应由任何程序使用，因为它被某些指令用作标志。

**2 个专用 8 位寄存器**

- Chip-8 还有两个专用 8 位寄存器，用于延迟和声音计时器。
- 当这些寄存器非零时，它们会自动以 60Hz 的速率递减。


**程序计数器 (PC)**  

- 程序计数器 (PC) 应该是 16 位，用于存储当前执行的地址。

**堆栈指针 (SP)**

- 堆栈指针 (SP) 可以是 8 位，用于指向堆栈的最顶层。
- 堆栈是一个由 16 个 16 位值组成的数组，用于存储解释器在完成子程序后应返回的地址。
- Chip-8 最多允许 16 层嵌套子程序。

**伪寄存器**

- 还有一些“伪寄存器”无法从 Chip-8 程序访问。


## 键盘 Keyboard 

最初使用 Chip-8 语言的计算机有一个 16 键十六进制键盘，布局如下：

```bash
1	2	3	C
4	5	6	D
7	8	9	E
A	0	B	F
```

## 显示器 Display


Chip-8 语言的原始实现使用了 64x32 像素的单色显示器，其格式如下：

```bash
(00,00) +-------------------+ (63,00)
        |                   |
        |                   |
(00,31) +-------------------+ (63,31)
```

其他一些解释器（最著名的是 ETI 660 上的解释器）也具有 64x48 和 64x64 模式。

HP48 计算器的解释器 Super Chip-48 添加了 128x64 像素模式。其他平台上的大多数解释器都支持此模式。

Chip-8 通过使用精灵（sprite）在屏幕上绘制图形。精灵是一组字节，是所需图片的二进制表示。

Chip-8 精灵可能最多有 15 个字节，精灵大小可能为 8x15。

程序还可以引用一组表示十六进制数字 0 到 F 的精灵。

这些精灵长 5 个字节，或 8x5 像素。

数据应存储在 Chip-8 内存的解释器区域（0x000 到 0x1FF）。

以下是每个字符的字节的二进制和十六进制列表：

```bash
"0"	    Binary	    Hex
****    11110000    0xF0
*  *    10010000    0x90
*  *    10010000    0x90
*  *    10010000    0x90
****    11110000    0xF0
"1"
  *     00100000    0x20
 **     01100000    0x60
  *     00100000    0x20
  *     00100000    0x20
 ***    01110000    0x70
"2"
****    11110000    0xF0
   *    00010000    0x10
****    11110000    0xF0
*       10000000    0x80
****    11110000    0xF0
"3"
****    11110000    0xF0
   *    00010000    0x10
****    11110000    0xF0
   *    00010000    0x10
****    11110000    0xF0
"4"
*  *    10010000    0x90
*  *    10010000    0x90
****    11110000    0xF0
   *    00010000    0x10
   *    00010000    0x10
"5"
****    11110000    0xF0
*       10000000    0x80
****    11110000    0xF0
   *    00010000    0x10
****    11110000    0xF0
"6"
****    11110000    0xF0
*       10000000    0x80
****    11110000    0xF0
*  *    10010000    0x90
****    11110000    0xF0
"7"
****    11110000    0xF0
   *    00010000    0x10
  *     00100000    0x20
 *      01000000    0x40
 *      01000000    0x40
"8"
****    11110000    0xF0
*  *    10010000    0x90
****    11110000    0xF0
*  *    10010000    0x90
****    11110000    0xF0
"9"
****    11110000    0xF0
*  *    10010000    0x90
****    11110000    0xF0
   *    00010000    0x10
****    11110000    0xF0
"A"
****    11110000    0xF0
*  *    10010000    0x90
****    11110000    0xF0
*  *    10010000    0x90
*  *    10010000    0x90
"B"
***     11100000    0xE0
*  *    10010000    0x90
***     11100000    0xE0
*  *    10010000    0x90
***     11100000    0xE0
"C"
****    11110000    0xF0
*       10000000    0x80
*       10000000    0x80
*       10000000    0x80
****    11110000    0xF0
"D"
***     11100000    0xE0
*  *    10010000    0x90
*  *    10010000    0x90
*  *    10010000    0x90
***     11100000    0xE0
"E"
****    11110000   0xF0
*       10000000   0x80
****    11110000   0xF0
*       10000000   0x80
****    11110000   0xF0
"F"
****    11110000    0xF0
*       10000000    0x80
****    11110000    0xF0
*       10000000    0x80
*       10000000    0x80
```

## 定时器和声音 Timers & Sound

Chip-8 提供 2 个定时器，一个延迟定时器和一个声音定时器。

只要延迟定时器寄存器 (DT) 非零，延迟定时器就会激活。此定时器所做的只是以 60Hz 的速率从 DT 的值中减 1。当 DT 达到 0 时，它将停用。

只要声音定时器寄存器 (ST) 非零，声音定时器就会激活。此定时器也以 60Hz 的速率递减，但是，只要 ST 的值大于零，Chip-8 蜂鸣器就会发声。当 ST 达到零时，声音定时器将停用。

Chip-8 解释器产生的声音只有一个音调。此音调的频率由解释器的作者决定。


## 指令 Instructions 

Chip-8 语言的原始实现包括 36 条不同的指令，包括数学、图形和流控制功能。

Super Chip-48 又增加了 10 条指令，总共 46 条。

所有指令都是 2 个字节长，并以最高有效字节优先的方式存储。在内存中，每条指令的第一个字节应位于偶数地址。如果程序包含精灵数据，则应对其进行填充，以便其后的任何指令都能正确放置在 RAM 中。

在这些列表中，使用了以下变量：

- `nnn` 或 `addr` - 12 位值，指令的最低 12 位
- `n` 或 `nibble` - 4 位值，指令的最低 4 位
- `x` - 4 位值，指令高字节的低 4 位
- `y` - 4 位值，指令低字节的高 4 位
- `kk` 或 `byte` - 8 位值，指令的最低 8 位



### 标准指令 Standard Chip-8 Instructions

`0nnn - SYS addr`
- 跳转到 nnn 处的机器代码例程。
- 此指令仅用于最初实现 Chip-8 的旧计算机。现代解释器会忽略它。

`00E0 - CLS`
- 清除显示。

`00EE - RET`
- 从子例程返回。
- 解释器将程序计数器设置为堆栈顶部的地址，然后从堆栈指针中减 1。

`1nnn - JP addr`
- 跳转到位置 nnn。
- 解释器将程序计数器设置为 nnn。

`2nnn - CALL addr`
- 调用 nnn 处的子例程。
- 解释器增加堆栈指针，然后将当前 PC 放在堆栈顶部。然后将 PC 设置为 nnn。

`3xkk - SE Vx,byte`
- 如果 Vx = kk，则跳过下一条指令。
- 解释器将寄存器 Vx 与 kk 进行比较，如果它们相等，则将程序计数器加 2。

`4xkk - SNE Vx,byte`
- 如果 Vx != kk，则跳过下一条指令。
- 解释器将寄存器 Vx 与 kk 进行比较，如果它们不相等，则将程序计数器加 2。

`5xy0 - SE Vx，Vy`
- 如果 Vx = Vy，则跳过下一条指令。
- 解释器将寄存器 Vx 与寄存器 Vy 进行比较，如果它们相等，则将程序计数器加 2。

`6xkk - LD Vx,byte`
- 设置 Vx = kk。
- 解释器将值 kk 放入寄存器 Vx。

`7xkk - ADD Vx,byte`
- 设置 Vx = Vx + kk。
- 将值 kk 添加到寄存器 Vx 的值，然后将结果存储在 Vx 中。

`8xy0 - LD Vx, Vy`
- 设置 Vx = Vy。
- 将寄存器 Vy 的值存储在寄存器 Vx 中。

`8xy1 - OR Vx, Vy`
- 设置 Vx = Vx OR Vy。
- 对 Vx 和 Vy 的值执行按位或，然后将结果存储在 Vx 中。按位或比较两个值的对应位，如果任一位为 1，则结果中的同一位也为 1。否则为 0。

`8xy2 - AND Vx, Vy`
- 设置 Vx = Vx AND Vy。
- 对 Vx 和 Vy 的值执行按位与，然后将结果存储在 Vx 中。按位与比较两个值的对应位，如果两个位都是 1，则结果中的相同位也为 1。否则，结果为 0。

`8xy3 - XOR Vx, Vy`
- 设置 Vx = Vx XOR Vy。
- 对 Vx 和 Vy 的值执行按位异或，然后将结果存储在 Vx 中。异或比较两个值的对应位，如果两个位不相同，则结果中的对应位设置为 1。否则，结果为 0。

`8xy4 - ADD Vx, Vy`
- 设置 Vx = Vx + Vy，设置 VF = 进位。
- 将 Vx 和 Vy 的值相加。如果结果大于 8 位（即 > 255），则 VF 设置为 1，否则为 0。只保留结果的最低 8 位，并存储在 Vx 中。

`8xy5 - SUB Vx, Vy`
- 设置 Vx = Vx - Vy，设置 VF = NOT 借位。
- 如果 Vx > Vy，则将 VF 设置为 1，否则设置为 0。然后从 Vx 中减去 Vy，并将结果存储在 Vx 中。

`8xy6 - SHR Vx {, Vy}`
- 设置 Vx = Vx SHR 1。
- 如果 Vx 的最低有效位为 1，则将 VF 设置为 1，否则设置为 0。然后将 Vx 除以 2。

`8xy7 - SUBN Vx, Vy`
- 设置 Vx = Vy - Vx，设置 VF = NOT 借位。
- 如果 Vy > Vx，则将 VF 设置为 1，否则设置为 0。然后从 Vy 中减去 Vx，并将结果存储在 Vx 中。

`8xyE - SHL Vx {, Vy}`
- 设置 Vx = Vx SHL 1。
- 如果 Vx 的最高有效位为 1，则将 VF 设置为 1，否则设置为 0。然后将 Vx 乘以 2。

`9xy0 - SNE Vx, Vy`
- 如果 Vx != Vy，则跳过下一条指令。
- 比较 Vx 和 Vy 的值，如果它们不相等，则程序计数器增加 2。

`Annn - LD I, addr`
- 设置 I = nnn。
- 寄存器 I 的值设置为 nnn。

`Bnnn - JP V0, addr`
- 跳转到位置 nnn + V0。
- 程序计数器设置为 nnn 加上 V0 的值。

`Cxkk - RND Vx, byte`
- 设置 Vx = 随机字节 AND kk。
- 解释器生成一个从 0 到 255 的随机数，然后将其与值 kk 进行 AND 运算。结果存储在 Vx 中。有关 AND 的更多信息，请参阅指令 8xy2。

`Dxyn - DRW Vx、Vy、nibble`
- 显示从内存位置 I 的 (Vx, Vy) 开始的 n 字节精灵，设置 VF = 碰撞。
- 解释器从内存中读取 n 个字节，从存储在 I 中的地址开始。然后，这些字节在屏幕上的坐标 (Vx, Vy) 处显示为精灵。精灵在现有屏幕上进行异或运算。如果这导致任何像素被擦除，则 VF 设置为 1，否则设置为 0。如果精灵的位置使其部分超出显示器的坐标，则它会绕到屏幕的另一侧。有关 XOR 的更多信息，请参阅指令 8xy3；

`Ex9E - SKP Vx`
- 如果按下值为 Vx 的键，则跳过下一条指令。
- 检查键盘，如果与 Vx 值对应的键当前处于向下位置，则 PC 增加 2。

`ExA1 - SKNP Vx`
- 如果未按下值为 Vx 的键，则跳过下一条指令。
- 检查键盘，如果与 Vx 值对应的键当前处于向上位置，则 PC 增加 2。

`Fx07 - LD Vx, DT`
- 设置 Vx = 延迟定时器值。
- DT 的值放入 Vx。

`Fx0A - LD Vx, K`
- 等待按键，将按键的值存储在 Vx 中。
- 所有执行停止，直到按下按键，然后

### 扩展指令 Super Chip-48 Instructions

`00Cn - SCD nibble`

`00FB - SCR`

`00FC - SCL`

`00FD - EXIT`

`00FE - LOW`

`00FF - HIGH`

`Dxy0 - DRW Vx, Vy, 0`

`Fx30 - LD HF, Vx`

`Fx75 - LD R, Vx`

`Fx85 - LD Vx, R`


## 实现

|     Title     |    Version     |                   Author                   |         Platform(s)          |
| :-----------: | :------------: | :----------------------------------------: | :--------------------------: |
|    Chip-48    |      2.20      |            Anrdreas Gustafsson             |             HP48             |
|     Chip8     |      1.1       |              Paul Robson	DOS               |
|    Chip-8     | Emulator	2.0.0 |                David Winter                |             DOS              |
|    CowChip    |      0.1       |              Thomas P. Greene              |         Windows 3.1          |
|   DREAM MON   |      1.1       |                Paul Hayter                 |            Amiga             |
| Super Chip-48 |      1.1       | Based on Chip-48, modified by Erik Bryntse |             HP48             |
|   Vision-8    |      1.0       |              Marcel de Kogel               | DOS, Adam, MSX, ColecoVision |