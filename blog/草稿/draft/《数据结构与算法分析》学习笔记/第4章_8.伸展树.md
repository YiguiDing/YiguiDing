---
title: 《数据结构与算法分析》第4章_8.伸展树
date: '2022-06-06 10:00:05 +08:00'
cover: ./cover/《数据结构与算法分析》学习笔记.png
tag: [《数据结构与算法分析》,笔记]
# ---article: false---
category: 笔记
---


# 伸展树

- **基本想法：** 访问一个节点后，通过一系列的旋转操作将该节点放到根节点上，这样这个节点和这条路径上的所有节点的深度就会降低，下一次访问所花费的时间就会更少。
- 不需要保存或计算高度信息和平衡信息
- 它保证从空树开始任意连续M次对树的操作最多花费 $O(MlogN)$
- 但不保证某次操作花费$O(N)$时间的可能，
- 这种单次最坏$O(N)$的时间花费虽不如平均最坏花费$O(logN)$时间短，但实际效果是一样的：不存在坏的输入序列
- 当M次操作的序列总的最坏情形运行时间为$O(MF(N))$时，称它的摊还运行时间为$O(F(N))$,因此一颗伸展树每次操作的摊还代价是$O(logN)$
  - 摊还分析用来评价某个数据结构的一系列操作的平均代价，有时可能某个操作的代价特别高，但总体上来看也并非那么糟糕，可以形象的理解为把高代价的操作“分摊”到其他操作上去了，要求的就是均摊后的平均代价。

## 展开操作Splaying

- 展开操作类似于AVL的旋转操作
- 不过在旋转如何实施上稍微有了选择的余地
- 仍然**从底部向上沿着访问路径旋转**
- 令X是在访问路径上的一个（非根）节点，在这个路径上实施旋转操作。
- 如果X的父节点是根节点，则只需要旋转X和根节点。这就是沿着访问路径上的最后的旋转。
- 否则,X就有父节点P和祖父节点G,这样就有四种情形
  - zig-zig X是P的左子树，P是G的左子树
  - zag-zag X是P的右子树，P是G的右子树
  - zig-zag X是P的右子树，P是G的左子树
  - zag-zig X是P的左子树，P是G的右子树
- ![](./images/《数据结构与算法分析》学习笔记/2022-06-06-15-15-30.png)

- 对节点1做展开操作的示例
![](./images/《数据结构与算法分析》学习笔记/2022-06-06-15-16-22.png)
