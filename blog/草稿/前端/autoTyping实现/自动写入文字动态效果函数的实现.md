---
title: 自动写入文字动态效果函数的实现
date: 2022-10-03T20:26:00+08:00
# top: 10
cover: ./cover/default_cover.jpg
# coverWidth: 1920
# coverHeight: 1080
tag: [vue,demo]
# ---article: false---
category: 前端
---



# 自动写入文字动态效果函数的实现

**代码**

```js
/****
    * @param {DOM元素} DomElement 
    * @param {初始字符串} start_TextString 
    * @param {目标字符串} ended_TextString 
    * @param {字符写入速度} interval 
    */
export const autoTyping = async function(DomElement, start_TextString ,ended_TextString,interval=150) {
    return new Promise(async(TypingResolve,TypingReject)=>{
        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中
            DomElement.in_use = true;//节流阀:标记为正在使用中
            let index = 0;
            DomElement.innerText = start_TextString //初始化
            function WriteCharOnce(){
                return new Promise((WriteCharOnceResolve, reject) => {
                    setTimeout(() => {
                        if (index < ended_TextString.length) {
                            let char = ended_TextString[index++]
                            DomElement.innerText += (char == ' ') ? '\xa0' : char; //空格无法直接拼接,需要转移
                            WriteCharOnceResolve('isTyping')
                        } else {
                            DomElement.in_use = false;//节流阀:标记为使用完毕
                            WriteCharOnceResolve('done') //WriteCharOnce 的 done
                        }
                    }, interval);
                });
            }
            while (await WriteCharOnce() == 'isTyping');
            TypingResolve('done') //autoTyping 的 done
        } else {
            TypingReject('in_use');
        }
    });
}


/****
    * @param {DOM元素} DomElement 
    * @param {初始字符串} start_TextString 
    * @param {目标字符串} ended_TextString 
    * @param {字符写入速度} interval 
    */
export const autoBackSpacing = async function(DomElement, start_TextString ,ended_TextString='',interval=150) {
    return new Promise(async(BackSpaceResolve,BackSpaceReject)=>{
        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中
            DomElement.in_use = true;//节流阀:标记为正在使用中
            let index = 0;
            DomElement.innerText = start_TextString //初始化
            function BackSpaceCharOnce(){
                return new Promise((BackSpaceCharOnceResolve, reject) => {
                    setTimeout(() => {
                        if (DomElement.innerText.length != 0 && DomElement.innerText!=ended_TextString ) {
                            DomElement.innerText = DomElement.innerText.substring(0,DomElement.innerText.length-1) //删除最后一个字符
                            BackSpaceCharOnceResolve('isBackSpacing')
                        } else {
                            DomElement.in_use = false;//节流阀:标记为使用完毕
                            BackSpaceCharOnceResolve('done')
                        }
                    }, interval);
                });
            }
            while (await BackSpaceCharOnce() == 'isBackSpacing');
            BackSpaceResolve('done');
        } else {
            BackSpaceReject('in_use');
        }
    });
}

/**
 * 
 * @param {延迟时间} timeout 500
 * @returns Promise对象
 */
export const waitMs = function(timeout){
    return new Promise((resolve)=>{
        setTimeout(() => {
            resolve('done');
        }, timeout);
    });
}
```

**测试代码**

<span id="span" data-value="在绝望中坚持真理,在荒诞中奋起抵抗." ></span><span class="_">_</span>
<br>
<button id="btn">点击测试效果</button>
<script>
let span = document.querySelector("#span")
let btn = document.querySelector("#btn")
btn.addEventListener('click',async ()=>{
    try{
        await autoTyping(span,'',span.dataset['value'],150)
        await waitMs(2000)
        await autoBackSpacing(span,span.dataset['value'],'',50)
    }catch(e){
        console.log(e);
    }
})
/****
    * @param {DOM元素} DomElement
    * @param {初始字符串} start_TextString
    * @param {目标字符串} ended_TextString
    * @param {字符写入速度} interval
    */
    async function autoTyping(DomElement, start_TextString ,ended_TextString,interval=150) {
    return new Promise(async(TypingResolve,TypingReject)=>{
        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中
            DomElement.in_use = true;//节流阀:标记为正在使用中
            let index = 0;
            DomElement.innerText = start_TextString //初始化
            function WriteCharOnce(){
                return new Promise((WriteCharOnceResolve, reject) => {
                    setTimeout(() => {
                        if (index < ended_TextString.length) {
                            let char = ended_TextString[index++]
                            DomElement.innerText += (char == ' ') ? '\xa0' : char; //空格无法直接拼接,需要转移
                            WriteCharOnceResolve('isTyping')
                        } else {
                            DomElement.in_use = false;//节流阀:标记为使用完毕
                            WriteCharOnceResolve('done') //WriteCharOnce 的 done
                        }
                    }, interval);
                });
            }
            while (await WriteCharOnce() == 'isTyping');
            TypingResolve('done') //autoTyping 的 done
        } else {
            TypingReject('in_use');
        }
    });
}
/****
    * @param {DOM元素} DomElement
    * @param {初始字符串} start_TextString
    * @param {目标字符串} ended_TextString
    * @param {字符写入速度} interval
    */
async function autoBackSpacing(DomElement, start_TextString ,ended_TextString='',interval=150) {
    return new Promise(async(BackSpaceResolve,BackSpaceReject)=>{
        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中
            DomElement.in_use = true;//节流阀:标记为正在使用中
            let index = 0;
            DomElement.innerText = start_TextString //初始化
            function BackSpaceCharOnce(){
                return new Promise((BackSpaceCharOnceResolve, reject) => {
                    setTimeout(() => {
                        if (DomElement.innerText.length != 0 && DomElement.innerText!=ended_TextString ) {
                            DomElement.innerText = DomElement.innerText.substring(0,DomElement.innerText.length-1) //删除最后一个字符
                            BackSpaceCharOnceResolve('isBackSpacing')
                        } else {
                            DomElement.in_use = false;//节流阀:标记为使用完毕
                            BackSpaceCharOnceResolve('done')
                        }
                    }, interval);
                });
            }
            while (await BackSpaceCharOnce() == 'isBackSpacing');
            BackSpaceResolve('done');
        } else {
            BackSpaceReject('in_use');
        }
    });
}
/**
 *
 * @param {延迟时间} timeout 500
 * @returns Promise对象
 */
function waitMs(timeout){
    return new Promise((resolve)=>{
        setTimeout(() => {
            resolve('done');
        }, timeout);
    });
}
</script>

<style>
._{
    display: inline-block;
    margin-left: 5px;
    animation: dash_flash 0.7s ease infinite;
}
@keyframes dash_flash {
    /*定义动画*/
    from{opacity: 0;}
    to{opacity: 1;}
}
</style>

```html
<span id="span" data-value="在绝望中坚持真理,在荒诞中奋起抵抗." ></span><span class="_">_</span>
<br>
<button id="btn">点击测试</button>
<script>
let span = document.querySelector("#span")
let btn = document.querySelector("#btn")
btn.addEventListener('click',async ()=>{
    try{
        await autoTyping(span,'',span.dataset['value'])
        await waitMs(2000)
        await autoBackSpacing(span,span.dataset['value'],'')
    }catch(e){
        console.log(e);
    }
})
/****
    * @param {DOM元素} DomElement 
    * @param {初始字符串} start_TextString 
    * @param {目标字符串} ended_TextString 
    * @param {字符写入速度} interval 
    */
    async function autoTyping(DomElement, start_TextString ,ended_TextString,interval=150) {
    return new Promise(async(TypingResolve,TypingReject)=>{
        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中
            DomElement.in_use = true;//节流阀:标记为正在使用中
            let index = 0;
            DomElement.innerText = start_TextString //初始化
            function WriteCharOnce(){
                return new Promise((WriteCharOnceResolve, reject) => {
                    setTimeout(() => {
                        if (index < ended_TextString.length) {
                            let char = ended_TextString[index++]
                            DomElement.innerText += (char == ' ') ? '\xa0' : char; //空格无法直接拼接,需要转移
                            WriteCharOnceResolve('isTyping')
                        } else {
                            DomElement.in_use = false;//节流阀:标记为使用完毕
                            WriteCharOnceResolve('done') //WriteCharOnce 的 done
                        }
                    }, interval);
                });
            }
            while (await WriteCharOnce() == 'isTyping');
            TypingResolve('done') //autoTyping 的 done
        } else {
            TypingReject('in_use');
        }
    });
}
/****
    * @param {DOM元素} DomElement 
    * @param {初始字符串} start_TextString 
    * @param {目标字符串} ended_TextString 
    * @param {字符写入速度} interval 
    */
async function autoBackSpacing(DomElement, start_TextString ,ended_TextString='',interval=150) {
    return new Promise(async(BackSpaceResolve,BackSpaceReject)=>{
        if (DomElement.in_use != true) {//节流阀:判断是否正在使用中
            DomElement.in_use = true;//节流阀:标记为正在使用中
            let index = 0;
            DomElement.innerText = start_TextString //初始化
            function BackSpaceCharOnce(){
                return new Promise((BackSpaceCharOnceResolve, reject) => {
                    setTimeout(() => {
                        if (DomElement.innerText.length != 0 && DomElement.innerText!=ended_TextString ) {
                            DomElement.innerText = DomElement.innerText.substring(0,DomElement.innerText.length-1) //删除最后一个字符
                            BackSpaceCharOnceResolve('isBackSpacing')
                        } else {
                            DomElement.in_use = false;//节流阀:标记为使用完毕
                            BackSpaceCharOnceResolve('done')
                        }
                    }, interval);
                });
            }
            while (await BackSpaceCharOnce() == 'isBackSpacing');
            BackSpaceResolve('done');
        } else {
            BackSpaceReject('in_use');
        }
    });
}
/**
 * 
 * @param {延迟时间} timeout 500
 * @returns Promise对象
 */
function waitMs(timeout){
    return new Promise((resolve)=>{
        setTimeout(() => {
            resolve('done');
        }, timeout);
    });
}
</script>

<style>
._{
    display: inline-block;
    margin-left: 5px;
    animation: dash_flash 0.7s ease infinite;
}
@keyframes dash_flash {
    /* 定义动画 */
    from{opacity: 0;}
    to{opacity: 1;}
}
</style>
```
