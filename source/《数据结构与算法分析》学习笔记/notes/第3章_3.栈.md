---
attachments: [Clipboard_2022-05-27-01-52-09.png, Clipboard_2022-05-27-01-52-41.png]




cover: /《数据结构与算法分析》学习笔记/attachments/Clipboard_2022-05-27-02-08-50.png
title: 第3章_3.栈
created: '2022-05-26T14:50:00.836Z'
modified: '2022-05-26T21:34:18.337Z'
---

# 第3章_3.栈
* 栈(stack)是限制插入和删除只能在一个位置上进行的表
* 栈有时也被叫做LIFO表（先进后出）
* 栈的基本操作
  + Push进栈（压入）
  + Pop出栈（弹出）
* 对空栈进行Pop操作被认为是栈ADT的错误
* Push操作直到空间用尽被认为是现实错误，但不是ADT错误

![](/《数据结构与算法分析》学习笔记/attachments/Clipboard_2022-05-27-01-52-09.png)

## 栈的链表实现
* 优点：所有操作花费常数时间
* 缺点：对malloc和free的开销是昂贵的
  + 解决办法：使用第二个栈来避免，当弹出第一个栈中元素时，将被弹出元素放到第二个栈中，待到下一次第一个栈中需要压入元素时，先去检查第二个栈是否为空，不为空则拿出一个存储空间来使用，以此节省调用malloc的开销。
* Stack.h

```c
#ifndef _Stack_h
#define _Stack_h

#define ElementType int

struct Node;
typedef struct Node* ptrToNode;
typedef ptrToNode Stack;


int IsEmpty(Stack S);
Stack CreatStack(void);
void DisposeStack(Stack S);
void MakeEmpty(Stack S);
void Push(ElementType X,Stack S);
ElementType Top(Stack S);
void Pop(Stack S); 

#endif
```

* Stack.c

```c
#include"Stack.h"
#include<stdlib.h>
struct Node
{
    ElementType Element;
    ptrToNode Next;
};

int IsEmpty(Stack S)
{
    return S->Next==NULL;
}
Stack CreatStack(void)
{
    Stack temp;
    temp = malloc(sizeof(struct Node));
    if (temp==NULL)
        return FatalError("error:out of space!!!");
    temp->Next=NULL;
    MakeEmpty(temp);
    return temp;
}
void DisposeStack(Stack S);
void MakeEmpty(Stack S)
{
    if (S==NULL)
        return FatalError("error:must use creatStack first");
    while (!IsEmpty(S))
        Pop(S);
}
void Push(ElementType X,Stack S)//S是头元素的指针
{
    Stack newElement=malloc(sizeof(struct Node));
    if (newElement==NULL)
        return FatalError("error:out of space!!!");
    newElement->Element=X;
    newElement->Next=S->Next;
    S->Next=newElement;
}
ElementType Top(Stack S)
{
    if (isEmpty(S))
    {
        FatalError("Empty Stack");
        return 0;//return value used to avoid warning
    }
    return S->Element;
}
void Pop(Stack S)
{
    ptrToNode first;
    if (isEmpty(S))
    {
        FatalError("Empty Stack");
        return;
    }
    first=S->Next;
    S->Next=S->Next->Next;
    free(first);
} 

FatalError(char*p)
{
    printf("%s\n",p);
}


```



## 栈的数组实现
* 是一种比较流行的方法
* 优点：避免了使用指针
* 缺点：需要提前指定数组的大小
* `TopOfStack`为-1表示空栈
* 压入元素时`TopOfStack+=1`，`stack[TopOfStack]=X`
* 弹出元素时`return stack[TopOfStack--]`
* 栈应该不止一个，栈的元素应该对其他程序不可见，所以栈应该避免使用全局变量表示。
* 栈的执行效率非常高
* 栈的错误检测影响栈的执行效率
* 除了一些对栈的错误处理非常重要的场合（操作系统），省略栈的错误检测是惯用手法
* 可以声明一个很大的栈使其不至于POP一个空栈，但在当程序非常庞大时，忽略错误检测是不妥的，因为对于整个程序而言栈的错误检测花费的时间很少

* Stack.h
```c
#ifndef Stack_H
#define Stack_H

#define ElementType int

struct StackRecord;
typedef struct StackRecord* Stack;

int IsEmpty(Stack S);
int IsFull(Stack S);
Stack CreatStack(int MaxElements);
void DisposeStack(Stack S);
void MakeEmpty(Stack S);
void Push(ElementType X,Stack S);
ElementType Top(Stack S);
void Pop(Stack S);
ElementType TopAndPop(Stack S);

#endif
```
* Stack.c
```c
#include"Stack.h"
#include<stdio.h>
#define EmptyTOS (-1)
#define MinStackSize (5)

struct StackRecord
{
    int Capacity;
    int TopOfStack;
    ElementType *Arry;
};

int IsEmpty(Stack S)
{
    return S->TopOfStack<=EmptyTOS;
}
int IsFull(Stack S)
{
    return S->TopOfStack>=S->Capacity-1;
}
Stack CreatStack(int MaxElements)
{
    Stack S;
    if(MaxElements<MinStackSize)
    {
        Error("Stack size is too small");
        return 0;
    }
    S = malloc(sizeof(struct StackRecord));
    if(S==NULL)
    {
        Error("out of memory");
        return 0;
    }
    S->Arry=malloc(sizeof(ElementType)*MaxElements);
    if (S->Arry==NULL)
    {
        Error("out of memory");
        return 0;
    }
    S->Capacity=MaxElements;
    MakeEmpty(S);
    return S;
}
void DisposeStack(Stack S)
{
    if (S!=NULL)
    {
        free(S->Arry);
        free(S);
    }
}
void MakeEmpty(Stack S)
{
    S->TopOfStack=EmptyTOS;
}
void Push(ElementType X,Stack S)
{
    if (isFull(S))
    {
        Error("Full Stack");
        return;
    }else
        S->Arry[++S->TopOfStack]=X;
}
ElementType Top(Stack S)
{
    if (isEmpty(S))
    {
        Error("Empty Stack");
        return 0;
    }
    return S->Arry[S->TopOfStack];
}
void Pop(Stack S)
{
    if (isEmpty(S))
    {
        Error("Empty Stack");
        return;
    }
    S->TopOfStack--;
}
ElementType TopAndPop(Stack S)
{
    if (isEmpty(S))
    {
        Error("Empty Stack");
        return 0;
    }
    return S->Arry[S->TopOfStack--];
}
Error(char*p)
{
    printf("%s\n",p);
}
```

### 应用
* 平衡符号
* 后缀表达式
* 函数调用

























# 栈ADT的递归运用
# 队列ADT
# 队列ADT在操作系统和算法设计中的应用


