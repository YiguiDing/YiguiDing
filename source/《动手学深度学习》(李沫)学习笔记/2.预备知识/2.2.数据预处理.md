---
title: 2.2.数据预处理
layout: post
cover: /《动手学深度学习》(李沫)学习笔记/cover.jpg
---

# 2.2. 数据预处理
* 用深度学习来解决现实世界问题时，没有现成的张量格式的数据。
* 数据预处理就是将现实世界的原始数据转换成张量格式的数据。
* panda
    + pandas软件包是Python中常用的数据分析工具
    + pandas与张量兼容
* 本节内容
    + 使用pandas预处理原始数据，
    + 将原始数据转换为张量格式

## 2.2.1. 读取数据集
* 创建人工数据集`../data/house_tiny.csv` 
* CSV——Comma-Separated Values——逗号 分隔 值


```python
# 创建人工数据集
import os # 操作系统接口模块

#在当前目录下创建data文件夹，允许文件夹已经存在（不报错）
os.makedirs(os.path.join(".","data"),exist_ok=True)
#创建一个文件路径的字符串
data_file_path=os.path.join(".","data","house_tiny.csv")

#打开写入文件 #with语句是为了自动调用close()
with open(data_file_path,"w",encoding="utf8") as file:
    file.write("房间数,巷子类型,价格\n")
    file.write("NA,铺石子,127500\n")
    file.write("2,NA,106000\n")
    file.write('4,NA,178100\n')
    file.write('NA,NA,140000\n')

```


```python
# !pip install pandas
import pandas as pd
fileTableData = pd.read_csv(data_file_path)

print(fileTableData)
fileTableData
```

       房间数 巷子类型      价格
    0  NaN  铺石子  127500
    1  2.0  NaN  106000
    2  4.0  NaN  178100
    3  NaN  NaN  140000
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>房间数</th>
      <th>巷子类型</th>
      <th>价格</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>铺石子</td>
      <td>127500</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2.0</td>
      <td>NaN</td>
      <td>106000</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.0</td>
      <td>NaN</td>
      <td>178100</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>140000</td>
    </tr>
  </tbody>
</table>
</div>



## 2.2.2. 处理缺失值
* “NaN”项代表缺失值。
* 通过位置索引iloc[1,2]
* 通过标签索引loc["行标签(数值或字符串)"]
* 处理缺失数据
    + 插值法
        + 用一个替代值弥补缺失值（以下演示的方法）
    + 删除法
        + 直接忽略缺失值


```python
fileTableData.iloc[0,1]
```




    '铺石子'




```python
fileTableData.loc[0]
```




    房间数        NaN
    巷子类型       铺石子
    价格      127500
    Name: 0, dtype: object




```python
inputs=fileTableData.iloc[:,0:-1] # 选出所有行 前两列 作为网络输入
outputs=fileTableData.iloc[:,-1] # 选出所有行 最后列 作为网络输出
print(inputs)
print()
print(outputs)
print()

print()
#用pandas将含na的值替换为其所在列的均值
#mean——n.中间; 平均数;median--中位数 -mod(n)---取余.....

#inputs = inputs.fillna(inputs.mean()) #报错写法
inputs = inputs.fillna({"房间数":fileTableData.iloc[:,0].mean()})

print(inputs)
```

       房间数 巷子类型
    0  NaN  铺石子
    1  2.0  NaN
    2  4.0  NaN
    3  NaN  NaN
    
    0    127500
    1    106000
    2    178100
    3    140000
    Name: 价格, dtype: int64
    
    
       房间数 巷子类型
    0  3.0  铺石子
    1  2.0  NaN
    2  4.0  NaN
    3  3.0  NaN
    

* “巷子类型”只有两种类型“铺石子”和“NaN”
* 可用pandas将此列转换为两列“巷子类型_铺石子”和“铺石子_nan”
*  特征提取之pd.get_dummies():
    + `pandas.get_dummies(data,prefix = None,prefix_sep ='_',dummy_na = False,columns = None,sparse = False,drop_first = False,dtype = None)`
    + data ： array-like，Series或DataFrame

    * one-hot的基本思想：将离散型特征的每一种取值都看成一种状态，若你的这一特征中有N个不相同的取值，那么我们就可以将该特征抽象成N种不同的状态


```python
#用pandas将"巷子类型"列转换为两列
inputs = pd.get_dummies(inputs,dummy_na=True)
print(inputs)

```

       房间数  巷子类型_铺石子  巷子类型_nan
    0  3.0         1         0
    1  2.0         0         1
    2  4.0         0         1
    3  3.0         0         1
    

## 2.2.3. 转换为张量格式


```python
#pip install torch
# import torch
import torch

X=torch.tensor(inputs.values)
Y=torch.tensor(outputs.values)

print(inputs.values)

print(X)
print(Y)
```

    [[3. 1. 0.]
     [2. 0. 1.]
     [4. 0. 1.]
     [3. 0. 1.]]
    tensor([[3., 1., 0.],
            [2., 0., 1.],
            [4., 0., 1.],
            [3., 0., 1.]], dtype=torch.float64)
    tensor([127500, 106000, 178100, 140000])
    

## 2.2.4. 小结
* pandas软件包是Python中常用的数据分析工具，pandas可以与张量兼容。
* 用pandas处理缺失数据时，可根据情况选择用插值法和删除法。

## 2.2.5. 练习
1. 创建包含更多行和列的原始数据集。
2. 删除缺失值最多的列。
3. 将预处理后的数据集转换为张量格式。

#### dropna()
* `DataFrame.dropna(axis=0, how='any', thresh=None, subset=None, inplace=False)`
* axis	0为行 1为列，default 0，数据删除维度
* how	{‘any’, ‘all’}, default ‘any’，any：删除带有nan的行；all：删除全为nan的行
* thresh	int，保留至少 int 个非nan行（值为4则过滤掉4个有效数据也没有的行）
* subset	list，在特定列缺失值处理
* inplace	bool，是否修改源文件



```python
# 删除缺失值最多的列
fileTableData = pd.read_csv(data_file_path)
print(fileTableData)
print(fileTableData.count())#每列的有效数据的个数
print(fileTableData.count().min())#有效数据个数最少的列的有效数据个数

fileTableData.dropna(axis=1,thresh=fileTableData.count().min()+1)#按列过滤，过滤掉有效数据个数<2的列

```

       房间数 巷子类型      价格
    0  NaN  铺石子  127500
    1  2.0  NaN  106000
    2  4.0  NaN  178100
    3  NaN  NaN  140000
    房间数     2
    巷子类型    1
    价格      4
    dtype: int64
    1
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>房间数</th>
      <th>价格</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>NaN</td>
      <td>127500</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2.0</td>
      <td>106000</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.0</td>
      <td>178100</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>140000</td>
    </tr>
  </tbody>
</table>
</div>


